{"SourceCode": "/**\r\n\r\n   // BitCouille - La crypto fran\u00e7aise qui va r\u00e9volutionner le monde.\r\n   \r\n   BTCO pour les intimes est la cryptomonnaie du futur, celle qui va venir faire taire le shiba et rejoindre Elon sur la Lune.\r\n   Monnaie qui r\u00e9compense sa communaut\u00e9 de mani\u00e8re \u00e9quitable en suivant plusieurs phases qui sont grav\u00e9es dans la roche si je puis dire, ou plut\u00f4t grav\u00e9es dans le smartcode.\r\n   \r\n  Telegram: https://t.me/BitCouille\r\n  Website: https://BitCouille.com\r\n  \r\n  Total de BTCO : 21 millions et pas un de plus\r\n  \r\n  /!\\ ATTENTION - C'EST PAS UNE ASSOCIATION NON-LUCRATIVE, ICI C'EST L'OSEILLE LE NERF DE LA GUERRE /!\\\r\n  \r\n  Il fonctionne automatiquement en plusieurs phases, chaque phase change automatiquement au fil du temps, plus il y'a de transactions plus les phases \u00e9voluent rapidement. \r\n  \r\n  12% de fees \u00e0 vie sur chaque transaction\r\n  \r\n  Phase 1 - ON FAIT LA MOULA \r\n  Dans cette phase c'est tr\u00e8s simple, chaque transaction est soumise \u00e0 une taxe en BTCO : \r\n  10% pour le cr\u00e9ateur du BitCouille et son d\u00e9veloppement, 2% pour les holdeurs\r\n  \r\n  > Fin de la phase 1 apr\u00e8s 105000BTCO de fees\r\n  \r\n  Phase 2 - R\u00e9partition des richesses\r\n  Cette phase elle commence \u00e0 faire plaisir aux holdeurs, vous touchez 4% la mif\r\n  8% pour le BitCouille cr\u00e9ateur, 4% pour les holdeurs\r\n  \r\n  > Fin de la phase 2 apr\u00e8s 210000BTCO de fees\r\n  \r\n  Phase 3 - L'\u00e9quilibre\r\n  Ils sont content les holdeurs, on gagne autant \u00e0 cr\u00e9er un shitcoin ou l'acheter\r\n  6% pour le Bitcouille cr\u00e9ateur, 6% pour les holdeurs\r\n  \r\n  > Fin de la phase 3 apr\u00e8s 420000BTCO de fees\r\n  \r\n  Phase 4 - La bikrave \u00e7a paye\r\n  Alors la vous gagnez plus que moi, vous \u00eates trop chaud!\r\n  4% pour le BitCouille cr\u00e9ateur, 8% pour les holdeurs\r\n  \r\n  > Fin de la phase 4 apr\u00e8s 1 Million de BTCO de fees\r\n   \r\n  Phase 5 - Enrichissement du peuple\r\n  La derni\u00e8re phase est arriv\u00e9e, vous gagnez plus que moi et c'est pour la vie <3\r\n  1% pour le BitCouille cr\u00e9ateur, 11% pour les holdeurs\r\n  \r\n  > Aucune fin de la phase 5, le BitCouille est devenu une monnaie incontournable\r\n  \r\n  Arretez d'acheter des shitcoins, vous pouvez all-in clairement sur le BitCouille avant qu'il ne soit trop tard.\r\n  \r\n\r\n   // ENGLISH VERSION\r\n   \r\n   BTCO is a really good token made in France, shiba will die...\r\n   \r\n   I DON'T HAVE A GOOD ENGLISH SO I'M SORRY BUT TRUST ME THIS COIN IS GOOD. HE HAS 5 FASES AND DEFLATIONIST FOR LIFE.\r\n   \r\n   BUY BITCOUILLE AND GET BITCOUILLE.\r\n   \r\n   Telegram: https://t.me/BitCouille\r\n   Website: https://BitCouille.com\r\n\r\n   Total Supply: 21 Millions (21,000,000) and no one more.\r\n   12% fees automatically share for creator, liquidity and holders\r\n\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function geUnlockTime() public view returns (uint256) {\r\n        return _lockTime;\r\n    }\r\n\r\n    //Locks the contract for owner for the amount of time provided\r\n    function lock(uint256 time) public virtual onlyOwner {\r\n        _previousOwner = _owner;\r\n        _owner = address(0);\r\n        _lockTime = block.timestamp + time;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n    \r\n    //Unlocks the contract for owner when _lockTime is exceeds\r\n    function unlock() public virtual {\r\n        require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\r\n        require(block.timestamp > _lockTime , \"Contract is locked until some time passes\");\r\n        emit OwnershipTransferred(_owner, _previousOwner);\r\n        _owner = _previousOwner;\r\n    }\r\n}\r\n\r\ncontract BitCouille is Context, IERC20, Ownable {\r\n    using Address for address;\r\n\r\n    //addresses pour le sang de la veine\r\n    //address private constant _burnAddress = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant _burnAddress = 0xd55FB6bD34bD8AFD65ae4662b0D485B96A385Fa4;\r\n\r\n    //MAPINGS\r\n    //mapping balance and reflected balance of address\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => uint256) private _reflectBalances;\r\n\r\n    //allowances of address to address with amount about this token\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    //mapping who is excluded from what (Fees or recieve Rewards)\r\n    mapping (address => bool) private _isExcludedFromFee;\r\n    mapping (address => bool) private _isExcludedFromReward;\r\n    address[] private _excludedFromReward;\r\n\r\n    //PROJECT SETTINGS\r\n    //Name Symbol Decimals\r\n    string private constant _name = 'BitCouille'; // to be determined\r\n    string private constant _symbol = 'BTCO'; // to be determined\r\n    uint8 private constant _decimals = 2;\r\n\r\n    //Supply and Reflected Supply and other options\r\n    uint256 private constant _decimalFactor = 10**uint256(_decimals);\r\n    uint256 private _tokenTotal = 21000000 * _decimalFactor ; // 19300000000000 per bnb!!\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private _reflectedTotal = (MAX - (MAX % _tokenTotal));\r\n    uint256 private constant _granularity = 100; // this allows 0.5 percentages for example\r\n    uint256 private _totalTokenFee = 0;\r\n\r\n    uint256 private _totalBurn;\r\n    bool private _disableFees = false;\r\n\r\n    constructor () {\r\n \r\n        _reflectBalances[_msgSender()] = _reflectedTotal; //\r\n        \r\n        _isExcludedFromFee[owner()] = true;\r\n        \r\n        _isExcludedFromReward[_burnAddress] = true;\r\n        \r\n        \r\n        emit Transfer(address(0), _msgSender(), _tokenTotal);\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _tokenTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        if (_isExcludedFromReward[account]) return _balances[account];\r\n        return tokenFromReflection(_reflectBalances[account]);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"transfer from the zero address\");\r\n        require(recipient != address(0), \"transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n\r\n        (uint256 burnFee, uint256 reflectFee) = getTransferFee(sender, recipient);\r\n        uint256 currentRate = _getRate();\r\n        uint256 burnToken = ((amount*burnFee)/_granularity)/100;\r\n        uint256 reflectToken = ((amount*reflectFee)/_granularity)/100;\r\n\r\n        _reflectBalances[sender] -= amount*currentRate;\r\n        _reflectBalances[recipient] += ((amount-burnToken-reflectToken)*currentRate);\r\n        _reflectBalances[_burnAddress]+=burnToken*currentRate;\r\n        if(_isExcludedFromReward[sender]) _balances[sender] -= amount ;\r\n        if(_isExcludedFromReward[recipient]) _balances[recipient] += (amount-burnToken-reflectToken);\r\n        if(_isExcludedFromReward[_burnAddress]) _balances[_burnAddress] += burnToken;\r\n        _reflectedTotal -= reflectToken*currentRate;\r\n        emit Transfer(sender, recipient, amount-burnToken-reflectToken);\r\n        if (burnToken!=uint256(0)) emit Transfer(sender, _burnAddress, burnToken);\r\n    }\r\n\r\n    function getTransferFee(address sender, address recipient) private view returns (uint256, uint256){\r\n        if (_disableFees || _isExcludedFromFee[sender] || _isExcludedFromFee[recipient] ){\r\n            return (uint256(0),uint256(0));\r\n        }\r\n        uint256 burnFee = 600;\r\n        uint256 reflectFee = 600;\r\n        uint256 burnt = balanceOf(_burnAddress);\r\n\r\n        if ( burnt < _tokenTotal/200 ){\r\n            burnFee = 1000;\r\n            reflectFee = 200;\r\n        }else if ( burnt < _tokenTotal/100 ){\r\n            burnFee = 800;\r\n            reflectFee = 400;\r\n        }else if( burnt < _tokenTotal/50 ){\r\n            burnFee =  600;\r\n            reflectFee = 600;\r\n        }else if( burnt < _tokenTotal/20 ){\r\n            burnFee =  400;\r\n            reflectFee = 800;\r\n        }else{\r\n            burnFee = 100;\r\n            reflectFee = 1100;\r\n        }\r\n        \r\n        return (burnFee,reflectFee);\r\n    }\r\n\r\n\r\n    function tokenFromReflection(uint256 reflectedAmount) public view returns(uint256) {\r\n        require(reflectedAmount <= _reflectedTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return reflectedAmount / currentRate ;\r\n        //return reflectedAmount.div(currentRate);\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 reflectedSupply, uint256 tokenSupply) = _getCurrentSupply();\r\n        return reflectedSupply / tokenSupply ;\r\n    }\r\n\r\n    function _getSupply() public view returns(uint256){\r\n        return _tokenTotal-balanceOf(_burnAddress);\r\n    }\r\n\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 reflectedSupply = _reflectedTotal;\r\n        uint256 tokenSupply = _tokenTotal;      \r\n        for (uint256 i = 0; i < _excludedFromReward.length; i++) {\r\n            if (_reflectBalances[_excludedFromReward[i]] > reflectedSupply || _balances[_excludedFromReward[i]] > tokenSupply) return (_reflectedTotal, _tokenTotal);\r\n            reflectedSupply -= _reflectBalances[_excludedFromReward[i]];\r\n            tokenSupply -= _balances[_excludedFromReward[i]];\r\n        }\r\n        if (reflectedSupply < (_reflectedTotal /_tokenTotal) ) return (_reflectedTotal, _tokenTotal);\r\n        return (reflectedSupply, tokenSupply);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"approve from the zero address\");\r\n        require(spender != address(0), \"approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    function excludeFromFees(address account) public onlyOwner{\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n\r\n    \r\n    function includeInFees(address account) public onlyOwner{\r\n        _isExcludedFromFee[account] = false;\r\n    }\r\n\r\n    function excludeFromReward(address account) public onlyOwner {\r\n        require(!_isExcludedFromReward[account], \"Account is already excluded\");\r\n        if(_reflectBalances[account] > 0) {\r\n            _balances[account] = tokenFromReflection(_reflectBalances[account]);\r\n        }\r\n        _isExcludedFromReward[account] = true;\r\n        _excludedFromReward.push(account);\r\n    }\r\n\r\n    function includeInReward(address account) external onlyOwner {\r\n        require(_isExcludedFromReward[account], \"Account is not excluded\");\r\n        for (uint256 i = 0; i < _excludedFromReward.length; i++) {\r\n            if (_excludedFromReward[i] == account) {\r\n                _excludedFromReward[i] = _excludedFromReward[_excludedFromReward.length - 1];\r\n                _balances[account] = 0;\r\n                _isExcludedFromReward[account] = false;\r\n                _excludedFromReward.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setFeesState(bool _enabled) public onlyOwner {\r\n        _disableFees = _enabled;\r\n    }\r\n\r\n    function getFeeInfo() public view returns(uint256,uint256){\r\n        return (getTransferFee(_burnAddress, _burnAddress));\r\n    }\r\n\r\n    function getFase() public view returns(string memory){\r\n        (uint256 bf,) = getTransferFee(_burnAddress, _burnAddress);\r\n        if (bf==uint256(1000)){\r\n            return \"Phase 1 - La moula\";\r\n        }else if(bf==uint256(800)){\r\n            return \"Phase 2 - Repartition des richesses\";\r\n        }else if(bf==uint256(600)){\r\n            return \"Phase 3 - L'equilibre\";\r\n        }else if(bf==uint256(400)){\r\n            return \"Phase 4 - La bikrave ca paye\";\r\n        }else if(bf==uint256(100)){\r\n            return \"Phase 5 - Enrichissement du peuple\";\r\n        }else{\r\n            return \"Wesh on est plus en phase\";\r\n        }\r\n    }\r\n\r\n    function isExcludedFromFee(address account) public view returns(bool){\r\n        return _isExcludedFromFee[account];\r\n    }\r\n\r\n    function isExcludedFromReward(address account) public view returns(bool){\r\n        return _isExcludedFromReward[account];\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_getSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"geUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFase\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setFeesState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reflectedAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BitCouille", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ec4b19f00b791a937600d327dd42efc88ba0553cdaaf150d8b45b2b8d4b1fffa"}