{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/connectors/interfaces/IExchangeConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\ninterface IExchangeConnector {\\n\\n    // Events\\n    \\n    event Swap(address[] path, uint[] amounts, address receiver);\\n\\n    // Read-only functions\\n\\n    function name() external view returns (string memory);\\n\\n    function exchangeRouter() external view returns (address);\\n\\n    function liquidityPoolFactory() external view returns (address);\\n\\n    function wrappedNativeToken() external view returns (address);\\n\\n    function getInputAmount(\\n        uint _outputAmount,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (bool, uint);\\n\\n    function getOutputAmount(\\n        uint _inputAmount,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (bool, uint);\\n\\n    // State-changing functions\\n\\n    function setExchangeRouter(address _exchangeRouter) external;\\n\\n    function setLiquidityPoolFactory() external;\\n\\n    function setWrappedNativeToken() external;\\n\\n    function swap(\\n        uint256 _inputAmount,\\n        uint256 _outputAmount,\\n        address[] memory _path,\\n        address _to,\\n        uint256 _deadline,\\n        bool _isFixedToken\\n    ) external returns (bool, uint[] memory);\\n\\n    function isPathValid(address[] memory _path) external view returns(bool);\\n}\"\r\n    },\r\n    \"contracts/oracle/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\ninterface IPriceOracle {\\n\\n    /// @notice                     Emits when new exchange router is added\\n    /// @param exchangeRouter       Address of new exchange router\\n    /// @param exchangeConnector    Address of exchange connector\\n    event ExchangeConnectorAdded(address indexed exchangeRouter, address indexed exchangeConnector);\\n\\n    /// @notice                     Emits when an exchange router is removed\\n    /// @param exchangeRouter       Address of removed exchange router\\n    event ExchangeConnectorRemoved(address indexed exchangeRouter);\\n\\n    /// @notice                     Emits when a price proxy is set\\n    /// @param _token               Address of the token\\n    /// @param _priceProxyAddress   Address of price proxy contract\\n    event SetPriceProxy(address indexed _token, address indexed _priceProxyAddress);\\n\\n    /// @notice                     Emits when changes made to acceptable delay\\n\\tevent NewAcceptableDelay(uint oldAcceptableDelay, uint newAcceptableDelay);\\n\\n    /// @notice                     Emits when changes made to oracle native token\\n\\tevent NewOracleNativeToken(address indexed oldOracleNativeToken, address indexed newOracleNativeToken);\\n\\n    // Read-only functions\\n    \\n    /// @notice                     Gives USD price proxy address for a token\\n    /// @param _token          Address of the token\\n    /// @return                     Address of price proxy contract\\n    function ChainlinkPriceProxy(address _token) external view returns (address);\\n\\n    /// @notice                     Gives exchange connector address for an exchange router\\n    /// @param _exchangeRouter      Address of exchange router\\n    /// @return                     Address of exchange connector\\n    function exchangeConnector(address _exchangeRouter) external view returns (address);\\n\\n    /// @notice                     Gives address of an exchange router from exchange routers list\\n    /// @param _index               Index of exchange router\\n    /// @return                     Address of exchange router\\n    function exchangeRoutersList(uint _index) external view returns (address);\\n\\n    function getExchangeRoutersListLength() external view returns (uint);\\n\\n    function acceptableDelay() external view returns (uint);\\n\\n    function oracleNativeToken() external view returns (address);\\n\\n    function equivalentOutputAmountByAverage(\\n        uint _inputAmount,\\n        uint _inputDecimals,\\n        uint _outputDecimals,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (uint);\\n\\n    function equivalentOutputAmount(\\n        uint _inputAmount,\\n        uint _inputDecimals,\\n        uint _outputDecimals,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (uint);\\n\\n    function equivalentOutputAmountFromOracle(\\n        uint _inputAmount,\\n        uint _inputDecimals,\\n        uint _outputDecimals,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (uint);\\n\\n    function equivalentOutputAmountFromExchange(\\n        address _exchangeRouter,\\n        uint _inputAmount,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (uint);\\n    \\n    // State-changing functions\\n    \\n    function addExchangeConnector(address _exchangeRouter, address _exchangeConnector) external;\\n\\n    function removeExchangeConnector(uint _exchangeRouterIndex) external;\\n\\n    function setPriceProxy(address _token, address _priceProxyAddress) external;\\n\\n    function setAcceptableDelay(uint _acceptableDelay) external;\\n\\n    function setOracleNativeToken(address _oracleNativeToken) external;\\n}\"\r\n    },\r\n    \"contracts/oracle/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"./interfaces/IPriceOracle.sol\\\";\\nimport \\\"../connectors/interfaces/IExchangeConnector.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\n\\ncontract PriceOracle is IPriceOracle, Ownable {\\n\\n    using SafeCast for uint;\\n\\n    modifier nonZeroAddress(address _address) {\\n        require(_address != address(0), \\\"PriceOracle: zero address\\\");\\n        _;\\n    }\\n\\n    // Public variables\\n    mapping (address => address) public override ChainlinkPriceProxy; // Given two token addresses returns related Chainlink price proxy\\n    mapping(address => address) public override exchangeConnector; // Mapping from exchange router to exchange connector\\n    address[] public override exchangeRoutersList; // List of available exchange routers\\n    uint public override acceptableDelay;\\n    address public constant NATIVE_TOKEN = address(1); // ONE_ADDRESS is used for getting price of blockchain native token \\n    address public override oracleNativeToken;\\n\\n    /// @notice                         This contract is used to get relative price of two assets from Chainlink and available exchanges \\n    /// @param _acceptableDelay         Maximum acceptable delay for data given from Chainlink\\n    /// @param _oracleNativeToken       The address of the chainlink oracle for the native token\\n    constructor(uint _acceptableDelay,address _oracleNativeToken) {\\n        _setAcceptableDelay(_acceptableDelay);\\n        _setOracleNativeToken(_oracleNativeToken);\\n    }\\n\\n    function renounceOwnership() public virtual override onlyOwner {}\\n\\n    /// @notice                 Getter for the length of exchange router list\\n    function getExchangeRoutersListLength() public view override returns (uint) {\\n        return exchangeRoutersList.length;\\n    }\\n\\n    /// @notice                         Finds amount of output token that has same value as the input amount of the input token\\n    /// @dev                            First we try to get the output amount from Chain Link\\n    ///                                 Only if the price is not available or out-of-date we will \\n    ///                                 reach to exchange routers\\n    /// @param _inputAmount             Amount of the input token\\n    /// @param _inputDecimals           Number of input token decimals\\n    /// @param _outputDecimals          Number of output token decimals\\n    /// @param _inputToken              Address of the input token\\n    /// @param _outputToken             Address of output token\\n    /// @return                         Amount of the output token\\n    function equivalentOutputAmountByAverage(\\n        uint _inputAmount,\\n        uint _inputDecimals,\\n        uint _outputDecimals,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view nonZeroAddress(_inputToken) nonZeroAddress(_outputToken) override returns (uint) {\\n        // Gets output amount from oracle\\n        (bool result, uint outputAmount, uint timestamp) = _equivalentOutputAmountFromOracle(\\n            _inputAmount,\\n            _inputDecimals,\\n            _outputDecimals,\\n            _inputToken,\\n            _outputToken\\n        );\\n\\n        // Checks timestamp of the oracle result\\n        if (result == true && _abs(timestamp.toInt256() - block.timestamp.toInt256()) <= acceptableDelay) {\\n            return outputAmount;\\n        } else {\\n            uint _totalAmount;\\n            uint _totalNumber;\\n\\n            // If Chainlink price is available but out-of-date, we still use it\\n            if (result == true) {\\n                _totalAmount = outputAmount;\\n                _totalNumber = 1;\\n            }\\n\\n            // Gets output amounts from exchange routers\\n            // note: we assume that the decimal of exchange returned result is _outputDecimals.\\n            for (uint i = 0; i < getExchangeRoutersListLength(); i++) {\\n                (result, outputAmount) = _equivalentOutputAmountFromExchange(\\n                    exchangeRoutersList[i],\\n                    _inputAmount,\\n                    _inputToken,\\n                    _outputToken\\n                );\\n\\n                if (result == true) {\\n                    _totalNumber = _totalNumber + 1;\\n                    _totalAmount = _totalAmount + outputAmount;\\n                }\\n            }\\n\\n            require(_totalNumber > 0, \\\"PriceOracle: no price feed is available\\\");\\n\\n            // Returns average of results from different sources\\n            return _totalAmount/_totalNumber;\\n        }\\n    }\\n\\n    /// @notice                         Finds amount of output token that has equal value\\n    ///                                 as the input amount of the input token\\n    /// @dev                            The oracle is ChainLink\\n    /// @param _inputAmount             Amount of the input token\\n    /// @param _inputDecimals           Number of input token decimals\\n    /// @param _outputDecimals          Number of output token decimals\\n    /// @param _inputToken              Address of the input token\\n    /// @param _outputToken             Address of output token\\n    /// @return _outputAmount           Amount of the output token\\n    function equivalentOutputAmount(\\n        uint _inputAmount,\\n        uint _inputDecimals,\\n        uint _outputDecimals,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view nonZeroAddress(_inputToken) nonZeroAddress(_outputToken) override returns (uint _outputAmount) {\\n        bool result;\\n        (result, _outputAmount, /*timestamp*/) = _equivalentOutputAmountFromOracle(\\n            _inputAmount,\\n            _inputDecimals,\\n            _outputDecimals,\\n            _inputToken,\\n            _outputToken\\n        );\\n        require(result == true, \\\"PriceOracle: oracle not exist or up to date\\\");\\n    }\\n\\n    /// @notice                         Finds amount of output token that has equal value\\n    ///                                 as the input amount of the input token\\n    /// @dev                            The oracle is ChainLink\\n    /// @param _inputAmount             Amount of the input token\\n    /// @param _inputDecimals           Number of input token decimals\\n    /// @param _outputDecimals          Number of output token decimals\\n    /// @param _inputToken              Address of the input token\\n    /// @param _outputToken             Address of output token\\n    /// @return _outputAmount           Amount of the output token\\n    function equivalentOutputAmountFromOracle(\\n        uint _inputAmount,\\n        uint _inputDecimals,\\n        uint _outputDecimals,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view nonZeroAddress(_inputToken) nonZeroAddress(_outputToken) override returns (uint _outputAmount) {\\n        bool result;\\n        (result, _outputAmount, /*timestamp*/) = _equivalentOutputAmountFromOracle(\\n            _inputAmount,\\n            _inputDecimals,\\n            _outputDecimals,\\n            _inputToken,\\n            _outputToken\\n        );\\n        require(result == true, \\\"PriceOracle: oracle not exist or up to date\\\");\\n    }\\n\\n    /// @notice                         Finds amount of output token that has same value \\n    ///                                 as the input amount of the input token\\n    /// @dev                            Input amount should have the same decimal as input token\\n    ///                                 Output amount has the same decimal as output token\\n    /// @param _exchangeRouter          Address of the exchange router we are reading the price from\\n    /// @param _inputAmount             Amount of the input token\\n    /// @param _inputToken              Address of the input token\\n    /// @param _outputToken             Address of output token\\n    /// @return                         Amount of the output token\\n    function equivalentOutputAmountFromExchange(\\n        address _exchangeRouter,\\n        uint _inputAmount,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view nonZeroAddress(_inputToken) nonZeroAddress(_outputToken) override returns (uint) {\\n        (bool result, uint outputAmount) = _equivalentOutputAmountFromExchange(\\n            _exchangeRouter,\\n            _inputAmount,\\n            _inputToken,\\n            _outputToken\\n        );\\n        require(result == true, \\\"PriceOracle: Pair does not exist on exchange\\\");\\n        return outputAmount;\\n    }\\n\\n    /// @notice                    Adds an exchange connector\\n    /// @dev                       Only owner can call this\\n    /// @param _exchangeRouter     Exchange router contract address\\n    /// @param _exchangeConnector  New exchange connector contract address\\n    function addExchangeConnector(\\n        address _exchangeRouter, \\n        address _exchangeConnector\\n    ) external nonZeroAddress(_exchangeRouter) nonZeroAddress(_exchangeConnector) override onlyOwner {\\n        require(exchangeConnector[_exchangeRouter] == address(0), \\\"PriceOracle: exchange router already exists\\\");\\n        exchangeRoutersList.push(_exchangeRouter);\\n        exchangeConnector[_exchangeRouter] = _exchangeConnector;\\n        emit ExchangeConnectorAdded(_exchangeRouter, _exchangeConnector);\\n    }\\n\\n    /// @notice                       Removes an exchange connector\\n    /// @dev                          Only owner can call this\\n    /// @param _exchangeRouterIndex   The exchange router index in the list\\n    function removeExchangeConnector(uint _exchangeRouterIndex) external override onlyOwner {\\n        require(_exchangeRouterIndex < exchangeRoutersList.length, \\\"PriceOracle: Index is out of bound\\\");\\n        address exchangeRouterAddress = exchangeRoutersList[_exchangeRouterIndex];\\n        _removeElementFromExchangeRoutersList(_exchangeRouterIndex);\\n        exchangeConnector[exchangeRouterAddress] = address(0);\\n        emit ExchangeConnectorRemoved(exchangeRouterAddress);\\n    }\\n\\n    /// @notice                     Sets a USD price proxy for a token\\n    /// @dev                        Only owner can call this\\n    ///                             This price proxy gives exchange rate of _token/USD\\n    ///                             Setting price proxy address to zero means that we remove it\\n    /// @param _token               Address of the token\\n    /// @param _priceProxyAddress   The address of the proxy price\\n    function setPriceProxy(\\n        address _token, \\n        address _priceProxyAddress\\n    ) external nonZeroAddress(_token) override onlyOwner {\\n        ChainlinkPriceProxy[_token] = _priceProxyAddress;\\n        emit SetPriceProxy(_token, _priceProxyAddress);\\n    }\\n\\n    /// @notice                     Sets acceptable delay for oracle responses\\n    /// @dev                        If oracle data has not been updated for a while, \\n    ///                             we will get data from exchange routers\\n    /// @param _acceptableDelay     Maximum acceptable delay (in seconds)\\n    function setAcceptableDelay(uint _acceptableDelay) external override onlyOwner {\\n        _setAcceptableDelay(_acceptableDelay);\\n    }\\n\\n    /// @notice                     Sets oracle native token address\\n    function setOracleNativeToken(address _oracleNativeToken) external override onlyOwner {\\n       _setOracleNativeToken(_oracleNativeToken);\\n    }\\n\\n    /// @notice                     Internal setter for acceptable delay for oracle responses\\n    /// @dev                        If oracle data has not been updated for a while, \\n    ///                             we will get data from exchange routers\\n    /// @param _acceptableDelay     Maximum acceptable delay (in seconds)\\n    function _setAcceptableDelay(uint _acceptableDelay) private {\\n        emit NewAcceptableDelay(acceptableDelay, _acceptableDelay);\\n        require(\\n            _acceptableDelay > 0,\\n            \\\"PriceOracle: zero amount\\\"\\n        );\\n        acceptableDelay = _acceptableDelay;\\n    }\\n\\n    /// @notice                     Internal setter for oracle native token address\\n    function _setOracleNativeToken(address _oracleNativeToken) private nonZeroAddress(_oracleNativeToken) {\\n        emit NewOracleNativeToken(oracleNativeToken, _oracleNativeToken);\\n        oracleNativeToken = _oracleNativeToken;\\n    }\\n\\n    /// @notice                         Finds amount of output token that has same value \\n    ///                                 as the input amount of the input token\\n    /// @param _exchangeRouter          Address of the exchange we are reading the price from\\n    /// @param _inputAmount             Amount of the input token\\n    /// @param _inputToken              Address of the input token\\n    /// @param _outputToken             Address of output token\\n    /// @return _result                 True if getting amount was successful\\n    /// @return _outputAmount           Amount of the output token\\n    function _equivalentOutputAmountFromExchange(\\n        address _exchangeRouter,\\n        uint _inputAmount,\\n        address _inputToken,\\n        address _outputToken\\n    ) private view returns (bool _result, uint _outputAmount) {\\n        if (_inputToken == NATIVE_TOKEN) {\\n            // note: different exchanges may use different wrapped native token versions\\n            address wrappedNativeToken = IExchangeConnector(exchangeConnector[_exchangeRouter]).wrappedNativeToken();\\n\\n            (_result, _outputAmount) = IExchangeConnector(exchangeConnector[_exchangeRouter]).getOutputAmount(\\n                _inputAmount,\\n                wrappedNativeToken,\\n                _outputToken\\n            );\\n        } else if (_outputToken == NATIVE_TOKEN) {\\n            // note: different exchanges may use different wrapped native token versions\\n            address wrappedNativeToken = IExchangeConnector(exchangeConnector[_exchangeRouter]).wrappedNativeToken();\\n\\n            (_result, _outputAmount) = IExchangeConnector(exchangeConnector[_exchangeRouter]).getOutputAmount(\\n                _inputAmount,\\n                _inputToken,\\n                wrappedNativeToken\\n            );\\n        } else {\\n            (_result, _outputAmount) = IExchangeConnector(exchangeConnector[_exchangeRouter]).getOutputAmount(\\n                _inputAmount,\\n                _inputToken,\\n                _outputToken\\n            );\\n        }\\n\\n    }\\n\\n    /// @notice                         Finds amount of output token that is equal as the input amount of the input token\\n    /// @dev                            The oracle is ChainLink\\n    /// @param _inputAmount             Amount of the input token\\n    /// @param _inputDecimals           Number of input token decimals\\n    /// @param _outputDecimals          Number of output token decimals\\n    /// @param _inputToken              Address of the input token\\n    /// @param _outputToken             Address of output token\\n    /// @return _result                 True if getting amount was successful\\n    /// @return _outputAmount           Amount of the output token\\n    /// @return _timestamp              Timestamp of the result\\n    function _equivalentOutputAmountFromOracle(\\n        uint _inputAmount,\\n        uint _inputDecimals,\\n        uint _outputDecimals,\\n        address _inputToken,\\n        address _outputToken\\n    ) private view returns (bool, uint _outputAmount, uint _timestamp) {\\n        uint decimals0;\\n        uint decimals1;\\n        int price0;\\n        int price1;\\n\\n        if (_inputToken == NATIVE_TOKEN) {\\n            _inputToken = oracleNativeToken;\\n        }\\n\\n        if (_outputToken == NATIVE_TOKEN) {\\n            _outputToken = oracleNativeToken;\\n        }\\n\\n        if (ChainlinkPriceProxy[_inputToken] != address(0) && ChainlinkPriceProxy[_outputToken] != address(0)) {\\n            uint[2] memory _timestamps;\\n\\n            // Gets price of _inputToken/USD\\n            (\\n            /*uint80 roundID*/,\\n            price0,\\n            /*uint startedAt*/,\\n            _timestamps[0],\\n            /*uint80 answeredInRound*/\\n            ) = AggregatorV3Interface(ChainlinkPriceProxy[_inputToken]).latestRoundData();\\n\\n            require(price0 != 0, \\\"PriceOracle: zero price for input token\\\");\\n\\n            // Gets number of decimals\\n            decimals0 = AggregatorV3Interface(ChainlinkPriceProxy[_inputToken]).decimals();\\n\\n\\n            // Gets price of _outputToken/USD\\n            (\\n            /*uint80 roundID*/,\\n            price1,\\n            /*uint startedAt*/,\\n            _timestamps[1],\\n            /*uint80 answeredInRound*/\\n            ) = AggregatorV3Interface(ChainlinkPriceProxy[_outputToken]).latestRoundData();\\n\\n            require(price1 != 0, \\\"PriceOracle: zero price for output token\\\");\\n\\n            // Gets number of decimals\\n            decimals1 = AggregatorV3Interface(ChainlinkPriceProxy[_outputToken]).decimals();\\n\\n            // uint price = (uint(price0) * 10**(decimals1)) / (uint(price1) * 10**(decimals0));\\n\\n            // // note: to make inside of power parentheses greater than zero, we add them with one\\n            // _outputAmount = price*_inputAmount*(10**(_outputDecimals + 1))/(10**(_inputDecimals + 1));\\n\\n            // convert the above calculation to the below one to eliminate precision loss\\n            _outputAmount = (uint(price0) * 10**(decimals1))*_inputAmount*(10**(_outputDecimals + 1));\\n            _outputAmount = _outputAmount/((10**(_inputDecimals + 1))*(uint(price1) * 10**(decimals0)));\\n\\n            if (_abs(block.timestamp.toInt256() - _timestamps[0].toInt256()) > acceptableDelay) {\\n                return (false, _outputAmount, _timestamps[0]);\\n            }\\n\\n            if (_abs(block.timestamp.toInt256() - _timestamps[1].toInt256()) > acceptableDelay) {\\n                return (false, _outputAmount, _timestamps[1]);\\n            }\\n\\n            _timestamp = _timestamps[0] > _timestamps[1] ? _timestamps[1] : _timestamps[0];\\n\\n            return (true, _outputAmount, _timestamp);\\n            \\n        } else {\\n            return (false, 0, 0);\\n        }\\n    }\\n\\n    /// @notice             Removes an element of excahngeRouterList\\n    /// @dev                Deletes and shifts the array\\n    /// @param _index       Index of the element that will be deleted\\n    function _removeElementFromExchangeRoutersList(uint _index) private {\\n        exchangeRoutersList[_index] = exchangeRoutersList[exchangeRoutersList.length - 1];\\n        exchangeRoutersList.pop();\\n    }\\n\\n    /// @notice             Returns absolute value\\n    function _abs(int _value) private pure returns (uint) {\\n        return _value >= 0 ? uint(_value) : uint(-_value);\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_acceptableDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracleNativeToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeRouter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeConnector\",\"type\":\"address\"}],\"name\":\"ExchangeConnectorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeRouter\",\"type\":\"address\"}],\"name\":\"ExchangeConnectorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAcceptableDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAcceptableDelay\",\"type\":\"uint256\"}],\"name\":\"NewAcceptableDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOracleNativeToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOracleNativeToken\",\"type\":\"address\"}],\"name\":\"NewOracleNativeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_priceProxyAddress\",\"type\":\"address\"}],\"name\":\"SetPriceProxy\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ChainlinkPriceProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptableDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeConnector\",\"type\":\"address\"}],\"name\":\"addExchangeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outputDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_outputToken\",\"type\":\"address\"}],\"name\":\"equivalentOutputAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outputDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_outputToken\",\"type\":\"address\"}],\"name\":\"equivalentOutputAmountByAverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_outputToken\",\"type\":\"address\"}],\"name\":\"equivalentOutputAmountFromExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outputDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_outputToken\",\"type\":\"address\"}],\"name\":\"equivalentOutputAmountFromOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exchangeRoutersList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangeRoutersListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleNativeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exchangeRouterIndex\",\"type\":\"uint256\"}],\"name\":\"removeExchangeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_acceptableDelay\",\"type\":\"uint256\"}],\"name\":\"setAcceptableDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleNativeToken\",\"type\":\"address\"}],\"name\":\"setOracleNativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceProxyAddress\",\"type\":\"address\"}],\"name\":\"setPriceProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceOracle", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000b1000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}