{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-4.8.2/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-4.8.2/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable-4.3.2/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable-4.3.2/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/handler/ExternalSlippageControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts-4.8.2/access/Ownable.sol\\\";\\n\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\n\\n/*\\n  This contract is for DEX slippage to protect the users of high slippage due to market conditions\\n */\\nabstract contract ExternalSlippageControl is Ownable {\\n  uint256 public constant HUNDRED_PERCENT = 10_000;\\n  uint256 public constant MAX_SLIPPAGE = 1_000;\\n\\n  uint256 public maxSlippage = MAX_SLIPPAGE;\\n\\n  event AddOrUpdateProtocolSlippage(uint256 _slippage);\\n\\n  /**\\n   * @notice This function updates/adds max slippage allowed\\n   */\\n  function addOrUpdateProtocolSlippage(uint256 _slippage) public onlyOwner {\\n    if (!(_slippage < HUNDRED_PERCENT && _slippage <= MAX_SLIPPAGE)) revert ErrorLibrary.IncorrectSlippageRange();\\n    maxSlippage = _slippage;\\n    emit AddOrUpdateProtocolSlippage(_slippage);\\n  }\\n\\n  /**\\n   * @notice This function calculates slippage from the called protocol\\n   */\\n  function getSlippage(uint256 _amount) private view returns (uint256 minAmount) {\\n    minAmount = (_amount * (HUNDRED_PERCENT - maxSlippage)) / (HUNDRED_PERCENT);\\n  }\\n\\n  /**\\n   * @notice This function validates the sell amount and buy amount and checks for validity\\n   */\\n\\n  function validateSwap(uint priceSellToken, uint priceBuyToken) internal view {\\n    if (maxSlippage != 0) {\\n      if (priceBuyToken < getSlippage(priceSellToken)) {\\n        revert ErrorLibrary.InvalidAmount();\\n      }\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/handler/PancakeSwapHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n/**\\n * @title IndexManager for a particular Index\\n * @author Velvet.Capital\\n * @notice This contract is used for transferring funds form vault to contract and vice versa \\n           and swap tokens to and fro from BNB\\n * @dev This contract includes functionalities:\\n *      1. Deposit tokens to vault\\n *      2. Withdraw tokens from vault\\n *      3. Swap BNB for tokens\\n *      4. Swap tokens for BNB\\n */\\n\\npragma solidity 0.8.16;\\n\\nimport {IUniswapV2Router02} from \\\"../interfaces/IUniswapV2Router02.sol\\\";\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/proxy/utils/Initializable.sol\\\";\\n\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\nimport {IPriceOracle} from \\\"../oracle/IPriceOracle.sol\\\";\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts-4.8.2/access/Ownable.sol\\\";\\n\\nimport {ExternalSlippageControl} from \\\"./ExternalSlippageControl.sol\\\";\\n\\ncontract PancakeSwapHandler is Initializable, Ownable, ExternalSlippageControl {\\n  IUniswapV2Router02 internal pancakeSwapRouter;\\n  IPriceOracle internal oracle;\\n\\n  uint256 public constant DIVISOR_INT = 10_000;\\n\\n  constructor() {}\\n\\n  function init(address _router, address _oracle) external initializer {\\n    pancakeSwapRouter = IUniswapV2Router02(_router);\\n    oracle = IPriceOracle(_oracle);\\n  }\\n\\n  function getETH() public view returns (address) {\\n    return pancakeSwapRouter.WETH();\\n  }\\n\\n  function getSwapAddress() public view returns (address) {\\n    return address(pancakeSwapRouter);\\n  }\\n\\n  function swapTokensToETH(\\n    uint256 _swapAmount,\\n    uint256 _slippage,\\n    address _t,\\n    address _to,\\n    bool isEnabled\\n  ) public returns (uint256 swapResult) {\\n    TransferHelper.safeApprove(_t, address(pancakeSwapRouter), _swapAmount);\\n    uint256 internalSlippage = isEnabled ? getSlippage(_swapAmount, _slippage, getPathForToken(_t)) : 1;\\n    swapResult = pancakeSwapRouter.swapExactTokensForETH(\\n      _swapAmount,\\n      internalSlippage,\\n      getPathForToken(_t),\\n      _to,\\n      block.timestamp\\n    )[1];\\n  }\\n\\n  function swapTokenToTokens(\\n    uint256 _swapAmount,\\n    uint256 _slippage,\\n    address _tokenIn,\\n    address _tokenOut,\\n    address _to,\\n    bool isEnabled\\n  ) public returns (uint256 swapResult) {\\n    TransferHelper.safeApprove(_tokenIn, address(pancakeSwapRouter), _swapAmount);\\n    if (isEnabled) {\\n      swapResult = pancakeSwapRouter.swapExactTokensForTokens(\\n        _swapAmount,\\n        getSlippage(_swapAmount, _slippage, getPathForMultiToken(_tokenIn, _tokenOut)),\\n        getPathForMultiToken(_tokenIn, _tokenOut),\\n        _to,\\n        block.timestamp\\n      )[1];\\n    } else {\\n      swapResult = pancakeSwapRouter.swapExactTokensForTokens(\\n        _swapAmount,\\n        1,\\n        getPathForRewardToken(_tokenIn, _tokenOut),\\n        _to,\\n        block.timestamp\\n      )[2];\\n    }\\n  }\\n\\n  function swapETHToTokens(uint256 _slippage, address _t, address _to) public payable returns (uint256 swapResult) {\\n    swapResult = pancakeSwapRouter.swapExactETHForTokens{value: msg.value}(\\n      getSlippage(msg.value, _slippage, getPathForETH(_t)),\\n      getPathForETH(_t),\\n      _to,\\n      block.timestamp\\n    )[1];\\n  }\\n\\n  /**\\n   * @notice The function sets the path (ETH, token) for a token\\n   * @return Path for (ETH, token)\\n   */\\n  function getPathForETH(address crypto) public view returns (address[] memory) {\\n    address[] memory path = new address[](2);\\n    path[0] = getETH();\\n    path[1] = crypto;\\n\\n    return path;\\n  }\\n\\n  /**\\n   * @notice The function sets the path (token, ETH) for a token\\n   * @return Path for (token, ETH)\\n   */\\n  function getPathForToken(address token) public view returns (address[] memory) {\\n    address[] memory path = new address[](2);\\n    path[0] = token;\\n    path[1] = getETH();\\n\\n    return path;\\n  }\\n\\n  /**\\n   * @notice The function sets the path (token, token) for a token\\n   * @return Path for (token, token)\\n   */\\n  function getPathForMultiToken(address _tokenIn, address _tokenOut) public pure returns (address[] memory) {\\n    address[] memory path = new address[](2);\\n    path[0] = _tokenIn;\\n    path[1] = _tokenOut;\\n\\n    return path;\\n  }\\n\\n  /**\\n   * @notice The function sets the path (token, token) for a token\\n   * @return Path for (token, token)\\n   */\\n  function getPathForRewardToken(address _tokenIn, address _tokenOut) public view returns (address[] memory) {\\n    address[] memory path = new address[](3);\\n    path[0] = _tokenIn;\\n    path[1] = getETH();\\n    path[2] = _tokenOut;\\n\\n    return path;\\n  }\\n\\n  function getSlippage(\\n    uint256 _amount,\\n    uint256 _slippage,\\n    address[] memory path\\n  ) internal view returns (uint256 minAmount) {\\n    if (!(_slippage < DIVISOR_INT)) {\\n      revert ErrorLibrary.SlippageCannotBeGreaterThan100();\\n    }\\n    if (_slippage > maxSlippage) {\\n      revert ErrorLibrary.InvalidSlippage();\\n    }\\n    uint256 currentAmount;\\n    if (path[0] == getETH()) {\\n      currentAmount = oracle.getPriceForAmount(path[1], _amount, false);\\n    } else if (path[1] != getETH()) {\\n      currentAmount = oracle.getPriceForTokenAmount(path[0], path[1], _amount);\\n    } else {\\n      currentAmount = oracle.getPriceForAmount(path[0], _amount, true);\\n    }\\n    minAmount = (currentAmount * (DIVISOR_INT - _slippage)) / (DIVISOR_INT);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\ninterface IUniswapV2Router02 {\\n  function factory() external view returns (address);\\n\\n  function WETH() external view returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 amountADesired,\\n    uint256 amountBDesired,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint256 amountTokenDesired,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 liquidity,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountA, uint256 amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint256 liquidity,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 amountA, uint256 amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint256 amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256[] memory amounts);\\n\\n  function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\\n\\n  function getAmountOut(\\n    uint256 amountIn,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) external pure returns (uint256 amountOut);\\n\\n  function getAmountIn(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) external pure returns (uint256 amountIn);\\n\\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/library/ErrorLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @title ErrorLibrary\\n * @author Velvet.Capital\\n * @notice This is a library contract including custom defined errors\\n */\\n\\nlibrary ErrorLibrary {\\n  error ContractPaused();\\n  /// @notice Thrown when caller is not rebalancer contract\\n  error CallerNotRebalancerContract();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotAssetManager();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotSuperAdmin();\\n  /// @notice Thrown when caller is not whitelist manager\\n  error CallerNotWhitelistManager();\\n  /// @notice Thrown when length of slippage array is not equal to tokens array\\n  error InvalidSlippageLength();\\n  /// @notice Thrown when length of tokens array is zero\\n  error InvalidLength();\\n  /// @notice Thrown when token is not permitted\\n  error TokenNotPermitted();\\n  /// @notice Thrown when user is not allowed to invest\\n  error UserNotAllowedToInvest();\\n  /// @notice Thrown when index token in not initialized\\n  error NotInitialized();\\n  /// @notice Thrown when investment amount is greater than or less than the set range\\n  error WrongInvestmentAmount(uint256 minInvestment, uint256 maxInvestment);\\n  /// @notice Thrown when swap amount is greater than BNB balance of the contract\\n  error NotEnoughBNB();\\n  /// @notice Thrown when the total sum of weights is not equal to 10000\\n  error InvalidWeights(uint256 totalWeight);\\n  /// @notice Thrown when balance is below set velvet min investment amount\\n  error BalanceCantBeBelowVelvetMinInvestAmount(uint256 minVelvetInvestment);\\n  /// @notice Thrown when caller is not holding underlying token amount being swapped\\n  error CallerNotHavingGivenTokenAmount();\\n  /// @notice Thrown when length of denorms array is not equal to tokens array\\n  error InvalidInitInput();\\n  /// @notice Thrown when the tokens are already initialized\\n  error AlreadyInitialized();\\n  /// @notice Thrown when the token is not whitelisted\\n  error TokenNotWhitelisted();\\n  /// @notice Thrown when denorms array length is zero\\n  error InvalidDenorms();\\n  /// @notice Thrown when token address being passed is zero\\n  error InvalidTokenAddress();\\n  /// @notice Thrown when token is not permitted\\n  error InvalidToken();\\n  /// @notice Thrown when token is not approved\\n  error TokenNotApproved();\\n  /// @notice Thrown when transfer is prohibited\\n  error Transferprohibited();\\n  /// @notice Thrown when transaction caller balance is below than token amount being invested\\n  error LowBalance();\\n  /// @notice Thrown when address is already approved\\n  error AddressAlreadyApproved();\\n  /// @notice Thrown when swap handler is not enabled inside token registry\\n  error SwapHandlerNotEnabled();\\n  /// @notice Thrown when swap amount is zero\\n  error ZeroBalanceAmount();\\n  /// @notice Thrown when caller is not index manager\\n  error CallerNotIndexManager();\\n  /// @notice Thrown when caller is not fee module contract\\n  error CallerNotFeeModule();\\n  /// @notice Thrown when lp balance is zero\\n  error LpBalanceZero();\\n  /// @notice Thrown when desired swap amount is greater than token balance of this contract\\n  error InvalidAmount();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInAlpacaProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValue();\\n  /// @notice Thrown when the mint function returned 0 for success & 1 for failure\\n  error MintProcessFailed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInApeSwap();\\n  /// @notice Thrown when the redeeming was success(0) or failure(1)\\n  error RedeemingCTokenFailed();\\n  /// @notice Thrown when native BNB is sent for any vault other than mooVenusBNB\\n  error PleaseDepositUnderlyingToken();\\n  /// @notice Thrown when redeem amount is greater than tokenBalance of protocol\\n  error NotEnoughBalanceInBeefyProtocol();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBeefy();\\n  /// @notice Thrown when the deposit amount of underlying token A is more than contract balance\\n  error InsufficientTokenABalance();\\n  /// @notice Thrown when the deposit amount of underlying token B is more than contract balance\\n  error InsufficientTokenBBalance();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBiSwapProtocol();\\n  //Not enough funds\\n  error InsufficientFunds(uint256 available, uint256 required);\\n  //Not enough eth for protocol fee\\n  error InsufficientFeeFunds(uint256 available, uint256 required);\\n  //Order success but amount 0\\n  error ZeroTokensSwapped();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInLiqeeProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValuePassed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInPancakeProtocol();\\n  /// @notice Thrown when Pid passed is not equal to Pid stored in Pid map\\n  error InvalidPID();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error InsufficientBalance();\\n  /// @notice Thrown when the redeem function returns 1 for fail & 0 for success\\n  error RedeemingFailed();\\n  /// @notice Thrown when the token passed in getUnderlying is not vToken\\n  error NotVToken();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInWombatProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountNotEqualToPassedValue();\\n  /// @notice Thrown when slippage value passed is greater than 100\\n  error SlippageCannotBeGreaterThan100();\\n  /// @notice Thrown when tokens are already staked\\n  error TokensStaked();\\n  /// @notice Thrown when contract is not paused\\n  error ContractNotPaused();\\n  /// @notice Thrown when offchain handler is not valid\\n  error OffHandlerNotValid();\\n  /// @notice Thrown when offchain handler is not enabled\\n  error OffHandlerNotEnabled();\\n  /// @notice Thrown when swapHandler is not enabled\\n  error SwaphandlerNotEnabled();\\n  /// @notice Thrown when account other than asset manager calls\\n  error OnlyAssetManagerCanCall();\\n  /// @notice Thrown when already redeemed\\n  error AlreadyRedeemed();\\n  /// @notice Thrown when contract is not paused\\n  error NotPaused();\\n  /// @notice Thrown when token is not index token\\n  error TokenNotIndexToken();\\n  /// @notice Thrown when swaphandler is invalid\\n  error SwapHandlerNotValid();\\n  /// @notice Thrown when token that will be bought is invalid\\n  error BuyTokenAddressNotValid();\\n  /// @notice Thrown when not redeemed\\n  error NotRedeemed();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerIsNotAssetManager();\\n  /// @notice Thrown when account other than asset manager is trying to pause\\n  error OnlyAssetManagerCanCallUnpause();\\n  /// @notice Thrown when trying to redeem token that is not staked\\n  error TokensNotStaked();\\n  /// @notice Thrown when account other than asset manager is trying to revert or unpause\\n  error FifteenMinutesNotExcedeed();\\n  /// @notice Thrown when swapping weight is zero\\n  error WeightNotGreaterThan0();\\n  /// @notice Thrown when dividing by zero\\n  error DivBy0Sumweight();\\n  /// @notice Thrown when lengths of array are not equal\\n  error LengthsDontMatch();\\n  /// @notice Thrown when contract is not paused\\n  error ContractIsNotPaused();\\n  /// @notice Thrown when set time period is not over\\n  error TimePeriodNotOver();\\n  /// @notice Thrown when trying to set any fee greater than max allowed fee\\n  error InvalidFee();\\n  /// @notice Thrown when zero address is passed for treasury\\n  error ZeroAddressTreasury();\\n  /// @notice Thrown when assetManagerFee or performaceFee is set zero\\n  error ZeroFee();\\n  /// @notice Thrown when trying to enable an already enabled handler\\n  error HandlerAlreadyEnabled();\\n  /// @notice Thrown when trying to disable an already disabled handler\\n  error HandlerAlreadyDisabled();\\n  /// @notice Thrown when zero is passed as address for oracle address\\n  error InvalidOracleAddress();\\n  /// @notice Thrown when zero is passed as address for handler address\\n  error InvalidHandlerAddress();\\n  /// @notice Thrown when token is not in price oracle\\n  error TokenNotInPriceOracle();\\n  /// @notice Thrown when address is not approved\\n  error AddressNotApproved();\\n  /// @notice Thrown when minInvest amount passed is less than minInvest amount set\\n  error InvalidMinInvestmentAmount();\\n  /// @notice Thrown when maxInvest amount passed is greater than minInvest amount set\\n  error InvalidMaxInvestmentAmount();\\n  /// @notice Thrown when zero address is being passed\\n  error InvalidAddress();\\n  /// @notice Thrown when caller is not the owner\\n  error CallerNotOwner();\\n  /// @notice Thrown when out asset address is zero\\n  error InvalidOutAsset();\\n  /// @notice Thrown when protocol is not paused\\n  error ProtocolNotPaused();\\n  /// @notice Thrown when protocol is paused\\n  error ProtocolIsPaused();\\n  /// @notice Thrown when proxy implementation is wrong\\n  error ImplementationNotCorrect();\\n  /// @notice Thrown when caller is not offChain contract\\n  error CallerNotOffChainContract();\\n  /// @notice Thrown when user has already redeemed tokens\\n  error TokenAlreadyRedeemed();\\n  /// @notice Thrown when user has not redeemed tokens\\n  error TokensNotRedeemed();\\n  /// @notice Thrown when user has entered wrong amount\\n  error InvalidSellAmount();\\n  /// @notice Thrown when trasnfer fails\\n  error WithdrawTransferFailed();\\n  /// @notice Thrown when caller is not having minter role\\n  error CallerNotMinter();\\n  /// @notice Thrown when caller is not handler contract\\n  error CallerNotHandlerContract();\\n  /// @notice Thrown when token is not enabled\\n  error TokenNotEnabled();\\n  /// @notice Thrown when index creation is paused\\n  error IndexCreationIsPause();\\n  /// @notice Thrown denorm value sent is zero\\n  error ZeroDenormValue();\\n  /// @notice Thrown when asset manager is trying to input token which already exist\\n  error TokenAlreadyExist();\\n  /// @notice Thrown when cool down period is not passed\\n  error CoolDownPeriodNotPassed();\\n  /// @notice Thrown When Buy And Sell Token Are Same\\n  error BuyAndSellTokenAreSame();\\n  /// @notice Throws arrow when token is not a reward token\\n  error NotRewardToken();\\n  /// @notice Throws arrow when MetaAggregator Swap Failed\\n  error SwapFailed();\\n  /// @notice Throws arrow when Token is Not  Primary\\n  error NotPrimaryToken();\\n  /// @notice Throws when the setup is failed in gnosis\\n  error ModuleNotInitialised();\\n  /// @notice Throws when threshold is more than owner length\\n  error InvalidThresholdLength();\\n  /// @notice Throws when no owner address is passed while fund creation\\n  error NoOwnerPassed();\\n  /// @notice Throws when length of underlying token is greater than 1\\n  error InvalidTokenLength();\\n  /// @notice Throws when already an operation is taking place and another operation is called\\n  error AlreadyOngoingOperation();\\n  /// @notice Throws when wrong function is executed for revert offchain fund\\n  error InvalidExecution();\\n  /// @notice Throws when Final value after investment is zero\\n  error ZeroFinalInvestmentValue();\\n  /// @notice Throws when token amount after swap / token amount to be minted comes out as zero\\n  error ZeroTokenAmount();\\n  /// @notice Throws eth transfer failed\\n  error ETHTransferFailed();\\n  /// @notice Thorws when the caller does not have a default admin role\\n  error CallerNotAdmin();\\n  /// @notice Throws when buyAmount is not correct in offchainIndexSwap\\n  error InvalidBuyValues();\\n  /// @notice Throws when token is not primary\\n  error TokenNotPrimary();\\n  /// @notice Throws when tokenOut during withdraw is not permitted in the asset manager config\\n  error _tokenOutNotPermitted();\\n  /// @notice Throws when token balance is too small to be included in index\\n  error BalanceTooSmall();\\n  /// @notice Throws when a public fund is tried to made transferable only to whitelisted addresses\\n  error PublicFundToWhitelistedNotAllowed();\\n  /// @notice Throws when list input by user is invalid (meta aggregator)\\n  error InvalidInputTokenList();\\n  /// @notice Generic call failed error\\n  error CallFailed();\\n  /// @notice Generic transfer failed error\\n  error TransferFailed();\\n  /// @notice Throws when incorrect token amount is encountered during offchain/onchain investment\\n  error IncorrectInvestmentTokenAmount();\\n  /// @notice Throws when final invested amount after slippage is 0\\n  error ZeroInvestedAmountAfterSlippage();\\n  /// @notice Throws when the slippage trying to be set is in incorrect range\\n  error IncorrectSlippageRange();\\n  /// @notice Throws when invalid LP slippage is passed\\n  error InvalidLPSlippage();\\n  /// @notice Throws when invalid slippage for swapping is passed\\n  error InvalidSlippage();\\n  /// @notice Throws when msg.value is less than the amount passed into the handler\\n  error WrongNativeValuePassed();\\n  /// @notice Throws when there is an overflow during muldiv full math operation\\n  error FULLDIV_OVERFLOW();\\n  /// @notice Throws when the oracle price is not updated under set timeout\\n  error PriceOracleExpired();\\n  /// @notice Throws when the oracle price is returned 0\\n  error PriceOracleInvalid();\\n  /// @notice Throws when the initToken or updateTokenList function of IndexSwap is having more tokens than set by the Registry\\n  error TokenCountOutOfLimit(uint256 limit);\\n  /// @notice Throws when the array lenghts don't match for adding price feed or enabling tokens\\n  error IncorrectArrayLength();\\n  /// @notice Common Reentrancy error for IndexSwap and IndexSwapOffChain\\n  error ReentrancyGuardReentrantCall();\\n  /// @notice Throws when user calls updateFees function before proposing a new fee\\n  error NoNewFeeSet();\\n  /// @notice Throws when token is not ETH\\n  error TokenNotETH();\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {AggregatorV2V3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\ninterface IPriceOracle {\\n  function WETH() external returns(address);\\n\\n  function _addFeed(address base, address quote, AggregatorV2V3Interface aggregator) external;\\n\\n  function decimals(address base, address quote) external view returns (uint8);\\n\\n  function latestRoundData(address base, address quote) external view returns (int256);\\n\\n  function getUsdEthPrice(uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getEthUsdPrice(uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getPrice(address base, address quote) external view returns (int256);\\n\\n  function getPriceForAmount(address token, uint256 amount, bool ethPath) external view returns (uint256 amountOut);\\n\\n  function getPriceForTokenAmount(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amount\\n  ) external view returns (uint256 amountOut);\\n\\n  function getPriceTokenUSD18Decimals(address _base, uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getPriceForOneTokenInUSD(address _base) external view returns (uint256 amountOut);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IncorrectSlippageRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSlippage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlippageCannotBeGreaterThan100\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"AddOrUpdateProtocolSlippage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DIVISOR_INT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HUNDRED_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SLIPPAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"addOrUpdateProtocolSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crypto\",\"type\":\"address\"}],\"name\":\"getPathForETH\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"getPathForMultiToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"getPathForRewardToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPathForToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"swapETHToTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapResult\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"swapTokenToTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapResult\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"swapTokensToETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapResult\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PancakeSwapHandler", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}