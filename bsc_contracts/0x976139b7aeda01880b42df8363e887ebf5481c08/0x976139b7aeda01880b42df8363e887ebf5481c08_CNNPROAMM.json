{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cnnproStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\ninterface BEP20Interface {\\n    function transfer(address to, uint tokens) external returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ncontract CNNPROAMM {\\n    using SafeMath for uint256;\\n\\n    \\n    uint256[] public REFERRAL_PERCENTS = [100, 50, 30, 20, 10];\\n    uint256 public constant PERCENTS_DIVIDER = 1000;\\n\\n    uint256 public constant TIME_STEP = 1 days;\\n    uint256 public constant LEADER_BONUS_STEP = 5;\\n    uint256 public constant MAX_LEADER_PERCENT = 5;\\n    uint256 public constant Withdraw_Period = 7*TIME_STEP;\\n    uint256 public SWAP_FEES = 25;\\n\\n    uint256 public totalUsers;\\n    uint256 public totalInvested;\\n    uint256 public totalWithdrawn;\\n    uint256 public totalDeposits;\\n\\n    address payable ownerAddress;\\n    BEP20Interface public USDTAddress =\\n        BEP20Interface(0x55d398326f99059fF775485246999027B3197955);\\n    BEP20Interface public tokenAddress =\\n        BEP20Interface(0xD3F738881606DF53d6AD94cc2Db10cd481175Da7);\\n    uint256 public priceInUsdt;\\n\\n\\n    struct PoolDetails {\\n        uint256 minInvestment;\\n        uint256 life_days;\\n        uint256 maturityPercentage;\\n    }\\n\\n    struct Deposit {\\n        uint256 amount;\\n        uint256 withdrawn;\\n        uint256 start;\\n        uint256 checkpoint;\\n    }\\n\\n    struct User {\\n        Deposit[] deposits;\\n        uint256 staked;\\n        address payable referrer;\\n        uint256 bonus;\\n        uint256 refEarning;\\n        uint256 refEarningOnDividend;\\n        bool isExist;\\n        uint256 referredUsers;\\n        mapping(uint256 => uint256) refEarningsLevel;\\n        mapping(uint256 => uint256) refCount;\\n        uint256 totalAmount;\\n        uint256 withdrawn;\\n        uint256 last_withdrawn;\\n    }\\n\\n    mapping(address => User) internal users;\\n    mapping(address => bool) public isBlocked;\\n    PoolDetails public pool;\\n    bool public isRunningSwap = true;\\n\\n    event Newbie(address user);\\n    event NewDeposit(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RefBonus(\\n        address indexed referrer,\\n        address indexed referral,\\n        uint256 indexed level,\\n        uint256 amount\\n    );\\n    event priceChange(address indexed user, uint256 price, uint256 date);\\n    event buyCNN(address indexed user, uint256 priceInUsdt, uint256 tokens);\\n    event sellCNN(address indexed user, uint256 priceInUsdt, uint256 tokens);\\n\\n    constructor(address payable marketingAddr) {\\n        require(!isContract(marketingAddr));\\n        ownerAddress = marketingAddr;\\n        users[ownerAddress].referrer = ownerAddress;\\n        users[ownerAddress].isExist = true;\\n        priceInUsdt = 10 ** 18;\\n    \\n        pool.minInvestment = 100 * 10 ** 18;\\n        pool.maturityPercentage = 200;\\n        pool.life_days = 200;\\n    }\\n\\n    \\n    /*******Swapping ********/\\n    function setPrice(uint256 amount) public {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        require(amount > 0, \\\"Invalid amount or plan\\\");\\n        priceInUsdt = amount;\\n    }\\n\\n    function setSwapFees(uint256 fees) public {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        require(fees > 0, \\\"Invalid amount or plan\\\");\\n        SWAP_FEES = fees;\\n    }\\n\\n    //type 0 for buy\\n    //type 1 for toBUSD\\n    //type 2 for toUSDT\\n\\n    function exchange(\\n        uint256 amount,\\n        bool toUsdt\\n    ) public payable {\\n        require(!isBlocked[msg.sender], \\\"You are blocked\\\");\\n        require(amount > 0, \\\"Invalid Amount\\\");\\n        address payable userAddress = payable(msg.sender);\\n        if (toUsdt) {\\n            convertToUsdt(amount, userAddress);\\n        } else {\\n            convertToToken(amount, userAddress);\\n        }\\n    }\\n\\n    function convertToUsdt(\\n        uint256 tokenAmount,\\n        address payable userAddress\\n    ) private {\\n        uint256 usdtAmount = (tokenAmount).mul(priceInUsdt).div(1e18);\\n        require(\\n            BEP20Interface(tokenAddress).transferFrom(\\n                userAddress,\\n                address(this),\\n                tokenAmount\\n            ),\\n            \\\"Token transfer failed\\\"\\n        );\\n         require(\\n                BEP20Interface(address(USDTAddress)).transfer(\\n                    address(userAddress),\\n                    usdtAmount.mul(uint256(1000).sub(SWAP_FEES)).div(1000)\\n                ),\\n                \\\"Token transfer failed\\\"\\n            );\\n        emit sellCNN(userAddress, usdtAmount, tokenAmount);\\n    }\\n\\n    function convertToToken(\\n        uint256 usdtAmount,\\n        address userAddress\\n    ) private {\\n\\n            require(\\n                BEP20Interface(USDTAddress).transferFrom(\\n                    userAddress,\\n                    address(this),\\n                    usdtAmount\\n                ),\\n                \\\"Token transfer failed\\\"\\n            );\\n       \\n        uint256 tokenAmount = usdtAmount.mul(1e18).div(priceInUsdt);\\n        require(\\n            BEP20Interface(address(tokenAddress)).transfer(\\n                address(userAddress),\\n                tokenAmount\\n            ),\\n            \\\"Token transfer failed\\\"\\n        );\\n\\n        emit buyCNN(userAddress, usdtAmount, tokenAmount);\\n    }\\n\\n\\n\\n    function invest(\\n        address payable referrer,\\n        uint256 totalAmount\\n    ) public payable {\\n        require(!isBlocked[msg.sender], \\\"You are blocked\\\");\\n        require(totalAmount >= pool.minInvestment, \\\"Invalid amount\\\");\\n        require(users[referrer].isExist, \\\"Invalid referrer\\\");\\n        collect(msg.sender);\\n        uint256 _amount = totalAmount;\\n        require(\\n            BEP20Interface(tokenAddress).transferFrom(\\n                msg.sender,\\n                address(this),\\n                totalAmount\\n            ),\\n            \\\"Token transfer failed\\\"\\n        );\\n\\n        User storage user = users[msg.sender];\\n        users[msg.sender].isExist = true;\\n        bool isNew;\\n        if (user.referrer == address(0) && referrer != msg.sender) {\\n            user.referrer = referrer;\\n            isNew = true;\\n        }\\n        if (user.referrer != address(0)) {\\n            address upline = user.referrer;\\n            for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {\\n                if (upline != address(0)) {\\n                    uint256 amount = _amount.mul(REFERRAL_PERCENTS[i]).div(\\n                        PERCENTS_DIVIDER\\n                    );\\n                    users[upline].bonus = users[upline].bonus.add(amount);\\n                    if (isNew) {\\n                        users[upline].refCount[i] = users[upline]\\n                            .refCount[i]\\n                            .add(1);\\n                    }\\n                    users[upline].refEarningsLevel[i] = users[upline]\\n                        .refEarningsLevel[i]\\n                        .add(amount);\\n                    emit RefBonus(upline, msg.sender, i, amount);\\n                    upline = users[upline].referrer;\\n                } else break;\\n            }\\n        }\\n\\n        totalUsers = totalUsers.add(1);\\n        user.referredUsers++;\\n        emit Newbie(msg.sender);\\n\\n        user.deposits.push(\\n            Deposit(_amount, 0, block.timestamp, block.timestamp)\\n        );\\n        user.staked = user.staked.add(_amount);\\n        totalInvested = totalInvested.add(_amount);\\n        totalDeposits = totalDeposits.add(1);\\n\\n        emit NewDeposit(msg.sender, _amount);\\n    }\\n\\n    function withdraw() public {\\n        require(!isBlocked[msg.sender], \\\"You are blocked\\\");\\n        User storage user = users[msg.sender];\\n        require(block.timestamp>user.last_withdrawn.add(Withdraw_Period),\\\"Need to wait\\\");\\n        collect(msg.sender);\\n        uint256 earnings = user.totalAmount;\\n        require(earnings > 0, \\\"User has no dividends\\\");\\n\\n        require(\\n            BEP20Interface(tokenAddress).transfer(msg.sender, earnings),\\n            \\\"Token transfer failed\\\"\\n        );\\n        user.totalAmount = 0;\\n        user.withdrawn = user.withdrawn.add(earnings);\\n        totalWithdrawn = totalWithdrawn.add(earnings);\\n        user.last_withdrawn = block.timestamp;\\n        emit Withdrawn(msg.sender, earnings);\\n    }\\n\\n    function collect(address _user) private {\\n        User storage user = users[_user];\\n        uint256 dividends;\\n        for (uint256 i = 0; i < user.deposits.length; i++) {\\n            Deposit storage dep = user.deposits[i];\\nuint256 profit = dep.amount.mul(pool.maturityPercentage).div(\\n                    100\\n                );\\n            if (\\n                dep.withdrawn < profit\\n            ) {\\n                \\n\\n                uint256 from = dep.checkpoint > dep.start\\n                    ? dep.checkpoint\\n                    : dep.start;\\n                uint256 to = block.timestamp;\\n\\n                dividends = (\\n                    dep\\n                        .amount\\n                        .mul(pool.maturityPercentage)\\n                        .div(pool.life_days)\\n                        .div(100)\\n                ).mul(to.sub(from)).div(TIME_STEP);\\n                if (\\n                dep.withdrawn.add(dividends) > profit\\n                ){\\n                    dividends = profit\\n                        .sub(dep.withdrawn);\\n                }  \\n\\n                users[users[msg.sender].referrer].refEarningOnDividend = users[\\n                    users[msg.sender].referrer\\n                ].refEarningOnDividend.add(dividends.div(10));\\n\\n\\n                uint256 pendingProfit = profit.sub(\\n                    dep.withdrawn.add(dividends)\\n                );\\n                if (user.bonus > pendingProfit) {\\n                    dividends = dividends.add(pendingProfit);\\n                    user.bonus = user.bonus.sub(pendingProfit);\\n                } else {\\n                    dividends = dividends.add(user.bonus);\\n                    user.bonus = 0;\\n                }\\n\\n                users[users[msg.sender].referrer].bonus = users[\\n                    users[msg.sender].referrer\\n                ].bonus.add(dividends.div(10));\\n                \\n                dep.withdrawn = dep.withdrawn.add(dividends); /// changing of storage data\\n                user.totalAmount = user.totalAmount.add(dividends);\\n                dep.checkpoint = block.timestamp;\\n            }\\n        }\\n        user.bonus = 0;\\n    }\\n\\n    function getContractBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function getContractBalanceBUSD() public view returns (uint256) {\\n        return BEP20Interface(USDTAddress).balanceOf(address(this));\\n    }\\n\\n    function getUserDividends(\\n        address userAddress\\n    ) public view returns (uint256) {\\n        User storage user = users[userAddress];\\n        uint256 totalAmount;\\n        uint256 dividends;\\n        uint256 bonus = user.bonus;\\n        for (uint256 i = 0; i < user.deposits.length; i++) {\\n            Deposit storage dep = user.deposits[i];\\n            uint256 profit = dep.amount.mul(pool.maturityPercentage).div(\\n                    100\\n                );\\n            if (\\n                dep.withdrawn < profit\\n            ) {\\n                \\n\\n                uint256 from = dep.checkpoint > dep.start\\n                    ? dep.checkpoint\\n                    : dep.start;\\n                uint256 to = block.timestamp;\\n\\n                dividends = (\\n                    dep\\n                        .amount\\n                        .mul(pool.maturityPercentage)\\n                        .div(pool.life_days)\\n                        .div(100)\\n                ).mul(to.sub(from)).div(TIME_STEP);\\n\\n                if (\\n                dep.withdrawn.add(dividends) > profit\\n                ){\\n                    dividends = profit\\n                        .sub(dep.withdrawn);\\n                }   \\n\\n                uint256 pendingProfit = profit.sub(\\n                    dep.withdrawn.add(dividends)\\n                );\\n                if (bonus > pendingProfit) {\\n                    dividends = dividends.add(pendingProfit);\\n                    bonus = bonus.sub(pendingProfit);\\n                } else {\\n                    dividends = dividends.add(bonus);\\n                    bonus = 0;\\n                }\\n\\n                totalAmount = totalAmount.add(dividends);\\n            }\\n        }\\n        return totalAmount.add(user.totalAmount);\\n    }\\n\\n    function getUserInfo(\\n        address userAddress\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invested,\\n            uint256 withdrawn,\\n            uint256 refWithdrawable,\\n            uint256 refEarning,\\n            address upline,\\n            uint256 refEarningOnDividend\\n        )\\n    {\\n        User storage user = users[userAddress];\\n        return (\\n            user.staked,\\n            user.withdrawn,\\n            user.bonus,\\n            user.refEarning,\\n            user.referrer,\\n            user.refEarningOnDividend\\n        );\\n    }\\n\\n    function getDeposits(address _user) external view returns(Deposit[] memory deposits)\\n    {\\n        return users[_user].deposits;\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        uint size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function getReferralIncome(\\n        address userAddress\\n    )\\n        public\\n        view\\n        returns (uint256[] memory referrals, uint256[] memory referralEarnings,uint256[] memory ref_percents)\\n    {\\n        uint256[] memory _referrals = new uint256[](REFERRAL_PERCENTS.length);\\n        uint256[] memory _referralearnings = new uint256[](\\n            REFERRAL_PERCENTS.length\\n        );\\n        \\n        for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {\\n            _referrals[i] = users[userAddress].refEarningsLevel[i];\\n            _referralearnings[i] = users[userAddress].refCount[i];\\n        }\\n        return (_referrals, _referralearnings,REFERRAL_PERCENTS);\\n    }\\n\\n    function setAffiliate(uint256 percent, uint level) external {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        REFERRAL_PERCENTS[level - 1] = percent;\\n    }\\n\\n    function blockUnblockUser(address user, bool status) public {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        isBlocked[user] = status;\\n    }\\n\\n    function updatePool(\\n        uint256 _minInvestment,\\n        uint256 _maturityPercentage,\\n        uint256 _life_days\\n    ) public {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        pool.minInvestment = _minInvestment;\\n        pool.maturityPercentage = _maturityPercentage;\\n        pool.life_days = _life_days;\\n    }\\n\\n    function bnbdeposite(address payable userAddress, uint256 amount) public {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        userAddress.transfer(amount);\\n    }\\n\\n    function cnndeposite(address payable userAddress, uint256 amount) public {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        require(\\n            BEP20Interface(address(tokenAddress)).transfer(\\n                address(userAddress),\\n                amount\\n            ),\\n            \\\"Token transfer failed\\\"\\n        );\\n    }\\n\\n    function busddeposite(address payable userAddress, uint256 amount) public {\\n        require(msg.sender == ownerAddress, \\\"Invalid user\\\");\\n        require(\\n            BEP20Interface(address(USDTAddress)).transfer(\\n                address(userAddress),\\n                amount\\n            ),\\n            \\\"Token transfer failed\\\"\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"marketingAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInUsdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"buyCNN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"priceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInUsdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"sellCNN\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LEADER_BONUS_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LEADER_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_FEES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTAddress\",\"outputs\":[{\"internalType\":\"contract BEP20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdraw_Period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"blockUnblockUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bnbdeposite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"busddeposite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cnndeposite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toUsdt\",\"type\":\"bool\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalanceBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"}],\"internalType\":\"struct CNNPROAMM.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getReferralIncome\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"referrals\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"referralEarnings\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ref_percents\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"invested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refWithdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refEarning\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refEarningOnDividend\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRunningSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"life_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityPercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceInUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setAffiliate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"setSwapFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"contract BEP20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maturityPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_life_days\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CNNPROAMM", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005639429a35961f5336233aebf63e349ceee6bac1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}