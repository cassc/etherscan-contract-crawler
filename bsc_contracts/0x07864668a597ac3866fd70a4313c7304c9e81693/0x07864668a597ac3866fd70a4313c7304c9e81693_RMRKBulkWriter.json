{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/equippable/IERC6220.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"../multiasset/IERC5773.sol\\\";\\n\\n/**\\n * @title IERC6220\\n * @author RMRK team\\n * @notice Interface smart contract of the RMRK equippable module.\\n */\\ninterface IERC6220 is IERC5773 {\\n    /**\\n     * @notice Used to store the core structure of the `Equippable` RMRK lego.\\n     * @return assetId The ID of the asset equipping a child\\n     * @return childAssetId The ID of the asset used as equipment\\n     * @return childId The ID of token that is equipped\\n     * @return childEquippableAddress Address of the collection to which the child asset belongs to\\n     */\\n    struct Equipment {\\n        uint64 assetId;\\n        uint64 childAssetId;\\n        uint256 childId;\\n        address childEquippableAddress;\\n    }\\n\\n    /**\\n     * @notice Used to provide a struct for inputing equip data.\\n     * @dev Only used for input and not storage of data.\\n     * @return tokenId ID of the token we are managing\\n     * @return childIndex Index of a child in the list of token's active children\\n     * @return assetId ID of the asset that we are equipping into\\n     * @return slotPartId ID of the slot part that we are using to equip\\n     * @return childAssetId ID of the asset that we are equipping\\n     */\\n    struct IntakeEquip {\\n        uint256 tokenId;\\n        uint256 childIndex;\\n        uint64 assetId;\\n        uint64 slotPartId;\\n        uint64 childAssetId;\\n    }\\n\\n    /**\\n     * @notice Used to notify listeners that a child's asset has been equipped into one of its parent assets.\\n     * @param tokenId ID of the token that had an asset equipped\\n     * @param assetId ID of the asset associated with the token we are equipping into\\n     * @param slotPartId ID of the slot we are using to equip\\n     * @param childId ID of the child token we are equipping into the slot\\n     * @param childAddress Address of the child token's collection\\n     * @param childAssetId ID of the asset associated with the token we are equipping\\n     */\\n    event ChildAssetEquipped(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed slotPartId,\\n        uint256 childId,\\n        address childAddress,\\n        uint64 childAssetId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that a child's asset has been unequipped from one of its parent assets.\\n     * @param tokenId ID of the token that had an asset unequipped\\n     * @param assetId ID of the asset associated with the token we are unequipping out of\\n     * @param slotPartId ID of the slot we are unequipping from\\n     * @param childId ID of the token being unequipped\\n     * @param childAddress Address of the collection that a token that is being unequipped belongs to\\n     * @param childAssetId ID of the asset associated with the token we are unequipping\\n     */\\n    event ChildAssetUnequipped(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed slotPartId,\\n        uint256 childId,\\n        address childAddress,\\n        uint64 childAssetId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that the assets belonging to a `equippableGroupId` have been marked as\\n     *  equippable into a given slot and parent\\n     * @param equippableGroupId ID of the equippable group being marked as equippable into the slot associated with\\n     *  `slotPartId` of the `parentAddress` collection\\n     * @param slotPartId ID of the slot part of the catalog into which the parts belonging to the equippable group\\n     *  associated with `equippableGroupId` can be equipped\\n     * @param parentAddress Address of the collection into which the parts belonging to `equippableGroupId` can be\\n     *  equipped\\n     */\\n    event ValidParentEquippableGroupIdSet(\\n        uint64 indexed equippableGroupId,\\n        uint64 indexed slotPartId,\\n        address parentAddress\\n    );\\n\\n    /**\\n     * @notice Used to equip a child into a token.\\n     * @dev The `IntakeEquip` stuct contains the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @param data An `IntakeEquip` struct specifying the equip data\\n     */\\n    function equip(IntakeEquip memory data) external;\\n\\n    /**\\n     * @notice Used to unequip child from parent token.\\n     * @dev This can only be called by the owner of the token or by an account that has been granted permission to\\n     *  manage the given token by the current owner.\\n     * @param tokenId ID of the parent from which the child is being unequipped\\n     * @param assetId ID of the parent's asset that contains the `Slot` into which the child is equipped\\n     * @param slotPartId ID of the `Slot` from which to unequip the child\\n     */\\n    function unequip(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) external;\\n\\n    /**\\n     * @notice Used to check whether the token has a given child equipped.\\n     * @dev This is used to prevent from transferring a child that is equipped.\\n     * @param tokenId ID of the parent token for which we are querying for\\n     * @param childAddress Address of the child token's smart contract\\n     * @param childId ID of the child token\\n     * @return A boolean value indicating whether the child token is equipped into the given token or not\\n     */\\n    function isChildEquipped(\\n        uint256 tokenId,\\n        address childAddress,\\n        uint256 childId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Used to verify whether a token can be equipped into a given parent's slot.\\n     * @param parent Address of the parent token's smart contract\\n     * @param tokenId ID of the token we want to equip\\n     * @param assetId ID of the asset associated with the token we want to equip\\n     * @param slotId ID of the slot that we want to equip the token into\\n     * @return A boolean indicating whether the token with the given asset can be equipped into the desired slot\\n     */\\n    function canTokenBeEquippedWithAssetIntoSlot(\\n        address parent,\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Used to get the Equipment object equipped into the specified slot of the desired token.\\n     * @dev The `Equipment` struct consists of the following data:\\n     *  [\\n     *      assetId,\\n     *      childAssetId,\\n     *      childId,\\n     *      childEquippableAddress\\n     *  ]\\n     * @param tokenId ID of the token for which we are retrieving the equipped object\\n     * @param targetCatalogAddress Address of the `Catalog` associated with the `Slot` part of the token\\n     * @param slotPartId ID of the `Slot` part that we are checking for equipped objects\\n     * @return The `Equipment` struct containing data about the equipped object\\n     */\\n    function getEquipment(\\n        uint256 tokenId,\\n        address targetCatalogAddress,\\n        uint64 slotPartId\\n    ) external view returns (Equipment memory);\\n\\n    /**\\n     * @notice Used to get the asset and equippable data associated with given `assetId`.\\n     * @param tokenId ID of the token for which to retrieve the asset\\n     * @param assetId ID of the asset of which we are retrieving\\n     * @return metadataURI The metadata URI of the asset\\n     * @return equippableGroupId ID of the equippable group this asset belongs to\\n     * @return catalogAddress The address of the catalog the part belongs to\\n     * @return partIds An array of IDs of parts included in the asset\\n     */\\n    function getAssetAndEquippableData(\\n        uint256 tokenId,\\n        uint64 assetId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory metadataURI,\\n            uint64 equippableGroupId,\\n            address catalogAddress,\\n            uint64[] memory partIds\\n        );\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/library/RMRKErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\n/// @title RMRKErrors\\n/// @author RMRK team\\n/// @notice A collection of errors used in the RMRK suite\\n/// @dev Errors are kept in a centralised file in order to provide a central point of reference and to avoid error\\n///  naming collisions due to inheritance\\n\\n/// Attempting to grant the token to 0x0 address\\nerror ERC721AddressZeroIsNotaValidOwner();\\n/// Attempting to grant approval to the current owner of the token\\nerror ERC721ApprovalToCurrentOwner();\\n/// Attempting to grant approval when not being owner or approved for all should not be permitted\\nerror ERC721ApproveCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to get approvals for a token owned by 0x0 (considered non-existent)\\nerror ERC721ApprovedQueryForNonexistentToken();\\n/// Attempting to grant approval to self\\nerror ERC721ApproveToCaller();\\n/// Attempting to use an invalid token ID\\nerror ERC721InvalidTokenId();\\n/// Attempting to mint to 0x0 address\\nerror ERC721MintToTheZeroAddress();\\n/// Attempting to manage a token without being its owner or approved by the owner\\nerror ERC721NotApprovedOrOwner();\\n/// Attempting to mint an already minted token\\nerror ERC721TokenAlreadyMinted();\\n/// Attempting to transfer the token from an address that is not the owner\\nerror ERC721TransferFromIncorrectOwner();\\n/// Attempting to safe transfer to an address that is unable to receive the token\\nerror ERC721TransferToNonReceiverImplementer();\\n/// Attempting to transfer the token to a 0x0 address\\nerror ERC721TransferToTheZeroAddress();\\n/// Attempting to grant approval of assets to their current owner\\nerror RMRKApprovalForAssetsToCurrentOwner();\\n/// Attempting to grant approval of assets without being the caller or approved for all\\nerror RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to incorrectly configue a Catalog item\\nerror RMRKBadConfig();\\n/// Attempting to set the priorities with an array of length that doesn't match the length of active assets array\\nerror RMRKBadPriorityListLength();\\n/// Attempting to add an asset entry with `Part`s, without setting the `Catalog` address\\nerror RMRKCatalogRequiredForParts();\\n/// Attempting to transfer a soulbound (non-transferrable) token\\nerror RMRKCannotTransferSoulbound();\\n/// Attempting to accept a child that has already been accepted\\nerror RMRKChildAlreadyExists();\\n/// Attempting to interact with a child, using index that is higher than the number of children\\nerror RMRKChildIndexOutOfRange();\\n/// Attempting to find the index of a child token on a parent which does not own it.\\nerror RMRKChildNotFoundInParent();\\n/// Attempting to pass collaborator address array and collaborator permission array of different lengths\\nerror RMRKCollaboratorArraysNotEqualLength();\\n/// Attempting to register a collection that is already registered\\nerror RMRKCollectionAlreadyRegistered();\\n/// Attempting to manage or interact with colleciton that is not registered\\nerror RMRKCollectionNotRegistered();\\n/// Attempting to equip a `Part` with a child not approved by the Catalog\\nerror RMRKEquippableEquipNotAllowedByCatalog();\\n/// Attempting to pass an epired ECDSA deadline\\nerror RMRKExpiredDeadline();\\n/// Attempting to use ID 0, which is not supported\\n/// @dev The ID 0 in RMRK suite is reserved for empty values. Guarding against its use ensures the expected operation\\nerror RMRKIdZeroForbidden();\\n/// Attempting to interact with an asset, using index greater than number of assets\\nerror RMRKIndexOutOfRange();\\n/// Attempting to reclaim a child that can't be reclaimed\\nerror RMRKInvalidChildReclaim();\\n/// Attempting to use and invalid ECDSA signature\\nerror RMRKInvalidSignature();\\n/// Attempting to interact with an end-user account when the contract account is expected\\nerror RMRKIsNotContract();\\n/// Attempting to interact with a contract that had its operation locked\\nerror RMRKLocked();\\n/// Attempting to add a pending child after the number of pending children has reached the limit (default limit is 128)\\nerror RMRKMaxPendingChildrenReached();\\n/// Attempting to add a pending asset after the number of pending assets has reached the limit (default limit is\\n///  128)\\nerror RMRKMaxPendingAssetsReached();\\n/// Attempting to burn a total number of recursive children higher than maximum set\\n/// @param childContract Address of the collection smart contract in which the maximum number of recursive burns was reached\\n/// @param childId ID of the child token at which the maximum number of recursive burns was reached\\nerror RMRKMaxRecursiveBurnsReached(address childContract, uint256 childId);\\n/// Attempting to mint a number of tokens that would cause the total supply to be greater than maximum supply\\nerror RMRKMintOverMax();\\n/// Attempting to mint a nested token to a smart contract that doesn't support nesting\\nerror RMRKMintToNonRMRKNestableImplementer();\\n/// Attempting to mint zero tokens\\nerror RMRKMintZero();\\n/// Attempting to pass complementary arrays of different lengths\\nerror RMRKMismachedArrayLength();\\n/// Attempting to transfer a child before it is unequipped\\nerror RMRKMustUnequipFirst();\\n/// Attempting to nest a child over the nestable limit (current limit is 100 levels of nesting)\\nerror RMRKNestableTooDeep();\\n/// Attempting to nest the token to own descendant, which would create a loop and leave the looped tokens in limbo\\nerror RMRKNestableTransferToDescendant();\\n/// Attempting to nest the token to a smart contract that doesn't support nesting\\nerror RMRKNestableTransferToNonRMRKNestableImplementer();\\n/// Attempting to nest the token into itself\\nerror RMRKNestableTransferToSelf();\\n/// Attempting to interact with an asset that can not be found\\nerror RMRKNoAssetMatchingId();\\n/// Attempting to manage an asset without owning it or having been granted permission by the owner to do so\\nerror RMRKNotApprovedForAssetsOrOwner();\\n/// Attempting to interact with a token without being its owner or having been granted permission by the\\n///  owner to do so\\n/// @dev When a token is nested, only the direct owner (NFT parent) can mange it. In that case, approved addresses are\\n///  not allowed to manage it, in order to ensure the expected behaviour\\nerror RMRKNotApprovedOrDirectOwner();\\n/// Attempting to manage a collection without being the collection's collaborator\\nerror RMRKNotCollectionCollaborator();\\n/// Attemting to manage a collection without being the collection's issuer\\nerror RMRKNotCollectionIssuer();\\n/// Attempting to manage a collection without being the collection's issuer or collaborator\\nerror RMRKNotCollectionIssuerOrCollaborator();\\n/// Attempting to compose an asset wihtout having an associated Catalog\\nerror RMRKNotComposableAsset();\\n/// Attempting to unequip an item that isn't equipped\\nerror RMRKNotEquipped();\\n/// Attempting to interact with a management function without being the smart contract's owner\\nerror RMRKNotOwner();\\n/// Attempting to interact with a function without being the owner or contributor of the collection\\nerror RMRKNotOwnerOrContributor();\\n/// Attempting to manage a collection without being the specific address\\nerror RMRKNotSpecificAddress();\\n/// Attempting to manage a token without being its owner\\nerror RMRKNotTokenOwner();\\n/// Attempting to transfer the ownership to the 0x0 address\\nerror RMRKNewOwnerIsZeroAddress();\\n/// Attempting to assign a 0x0 address as a contributor\\nerror RMRKNewContributorIsZeroAddress();\\n/// Attemtping to use `Ownable` interface without implementing it\\nerror RMRKOwnableNotImplemented();\\n/// Attempting an operation requiring the token being nested, while it is not\\nerror RMRKParentIsNotNFT();\\n/// Attempting to add a `Part` with an ID that is already used\\nerror RMRKPartAlreadyExists();\\n/// Attempting to use a `Part` that doesn't exist\\nerror RMRKPartDoesNotExist();\\n/// Attempting to use a `Part` that is `Fixed` when `Slot` kind of `Part` should be used\\nerror RMRKPartIsNotSlot();\\n/// Attempting to interact with a pending child using an index greater than the size of pending array\\nerror RMRKPendingChildIndexOutOfRange();\\n/// Attempting to add an asset using an ID that has already been used\\nerror RMRKAssetAlreadyExists();\\n/// Attempting to equip an item into a slot that already has an item equipped\\nerror RMRKSlotAlreadyUsed();\\n/// Attempting to equip an item into a `Slot` that the target asset does not implement\\nerror RMRKTargetAssetCannotReceiveSlot();\\n/// Attempting to equip a child into a `Slot` and parent that the child's collection doesn't support\\nerror RMRKTokenCannotBeEquippedWithAssetIntoSlot();\\n/// Attempting to compose a NFT of a token without active assets\\nerror RMRKTokenDoesNotHaveAsset();\\n/// Attempting to determine the asset with the top priority on a token without assets\\nerror RMRKTokenHasNoAssets();\\n/// Attempting to accept or transfer a child which does not match the one at the specified index\\nerror RMRKUnexpectedChildId();\\n/// Attempting to reject all pending assets but more assets than expected are pending\\nerror RMRKUnexpectedNumberOfAssets();\\n/// Attempting to reject all pending children but children assets than expected are pending\\nerror RMRKUnexpectedNumberOfChildren();\\n/// Attempting to accept or reject an asset which does not match the one at the specified index\\nerror RMRKUnexpectedAssetId();\\n/// Attempting an operation expecting a parent to the token which is not the actual one\\nerror RMRKUnexpectedParent();\\n/// Attempting not to pass an empty array of equippable addresses when adding or setting the equippable addresses\\nerror RMRKZeroLengthIdsPassed();\\n/// Attempting to set the royalties to a value higher than 100% (10000 in basis points)\\nerror RMRKRoyaltiesTooHigh();\\n/// Attempting to do a bulk operation on a token that is not owned by the caller\\nerror RMRKCanOnlyDoBulkOperationsOnOwnedTokens();\\n/// Attempting to do a bulk operation with multiple tokens at a time\\nerror RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime();\\n/// Attempting to pay with native token with a value different than expected\\nerror RMRKWrongValueSent();\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/multiasset/IERC5773.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IERC5773\\n * @author RMRK team\\n * @notice Interface smart contract of the RMRK multi asset module.\\n */\\ninterface IERC5773 is IERC165 {\\n    /**\\n     * @notice Used to notify listeners that an asset object is initialized at `assetId`.\\n     * @param assetId ID of the asset that was initialized\\n     */\\n    event AssetSet(uint64 indexed assetId);\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is added to token's pending asset\\n     *  array.\\n     * @param tokenIds An array of token IDs that received a new pending asset\\n     * @param assetId ID of the asset that has been added to the token's pending assets array\\n     * @param replacesId ID of the asset that would be replaced\\n     */\\n    event AssetAddedToTokens(\\n        uint256[] tokenIds,\\n        uint64 indexed assetId,\\n        uint64 indexed replacesId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is accepted by the token and migrated\\n     *  from token's pending assets array to active assets array of the token.\\n     * @param tokenId ID of the token that had a new asset accepted\\n     * @param assetId ID of the asset that was accepted\\n     * @param replacesId ID of the asset that was replaced\\n     */\\n    event AssetAccepted(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed replacesId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is rejected from token and is dropped\\n     *  from the pending assets array of the token.\\n     * @param tokenId ID of the token that had an asset rejected\\n     * @param assetId ID of the asset that was rejected\\n     */\\n    event AssetRejected(uint256 indexed tokenId, uint64 indexed assetId);\\n\\n    /**\\n     * @notice Used to notify listeners that token's prioritiy array is reordered.\\n     * @param tokenId ID of the token that had the asset priority array updated\\n     */\\n    event AssetPrioritySet(uint256 indexed tokenId);\\n\\n    /**\\n     * @notice Used to notify listeners that owner has granted an approval to the user to manage the assets of a\\n     *  given token.\\n     * @dev Approvals must be cleared on transfer\\n     * @param owner Address of the account that has granted the approval for all token's assets\\n     * @param approved Address of the account that has been granted approval to manage the token's assets\\n     * @param tokenId ID of the token on which the approval was granted\\n     */\\n    event ApprovalForAssets(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that owner has granted approval to the user to manage assets of all of their\\n     *  tokens.\\n     * @param owner Address of the account that has granted the approval for all assets on all of their tokens\\n     * @param operator Address of the account that has been granted the approval to manage the token's assets on all of\\n     *  the tokens\\n     * @param approved Boolean value signifying whether the permission has been granted (`true`) or revoked (`false`)\\n     */\\n    event ApprovalForAllForAssets(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @notice Accepts an asset at from the pending array of given token.\\n     * @dev Migrates the asset from the token's pending asset array to the token's active asset array.\\n     * @dev Active assets cannot be removed by anyone, but can be replaced by a new asset.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits an {AssetAccepted} event.\\n     * @param tokenId ID of the token for which to accept the pending asset\\n     * @param index Index of the asset in the pending array to accept\\n     * @param assetId ID of the asset expected to be in the index\\n     */\\n    function acceptAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) external;\\n\\n    /**\\n     * @notice Rejects an asset from the pending array of given token.\\n     * @dev Removes the asset from the token's pending asset array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits a {AssetRejected} event.\\n     * @param tokenId ID of the token that the asset is being rejected from\\n     * @param index Index of the asset in the pending array to be rejected\\n     * @param assetId ID of the asset expected to be in the index\\n     */\\n    function rejectAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) external;\\n\\n    /**\\n     * @notice Rejects all assets from the pending array of a given token.\\n     * @dev Effecitvely deletes the pending array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     * @dev Emits a {AssetRejected} event with assetId = 0.\\n     * @param tokenId ID of the token of which to clear the pending array.\\n     * @param maxRejections Maximum number of expected assets to reject, used to prevent from rejecting assets which\\n     *  arrive just before this operation.\\n     */\\n    function rejectAllAssets(uint256 tokenId, uint256 maxRejections) external;\\n\\n    /**\\n     * @notice Sets a new priority array for a given token.\\n     * @dev The priority array is a non-sequential list of `uint64`s, where the lowest value is considered highest\\n     *  priority.\\n     * @dev Value `0` of a priority is a special case equivalent to unitialized.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - The length of `priorities` must be equal the length of the active assets array.\\n     * @dev Emits a {AssetPrioritySet} event.\\n     * @param tokenId ID of the token to set the priorities for\\n     * @param priorities An array of priorities of active assets. The succesion of items in the priorities array\\n     *  matches that of the succesion of items in the active array\\n     */\\n    function setPriority(\\n        uint256 tokenId,\\n        uint64[] calldata priorities\\n    ) external;\\n\\n    /**\\n     * @notice Used to retrieve IDs of the active assets of given token.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @dev You can safely get 10k\\n     * @param tokenId ID of the token to retrieve the IDs of the active assets\\n     * @return An array of active asset IDs of the given token\\n     */\\n    function getActiveAssets(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Used to retrieve IDs of the pending assets of given token.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @param tokenId ID of the token to retrieve the IDs of the pending assets\\n     * @return An array of pending asset IDs of the given token\\n     */\\n    function getPendingAssets(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Used to retrieve the priorities of the active resoources of a given token.\\n     * @dev Asset priorities are a non-sequential array of uint64 values with an array size equal to active asset\\n     *  priorites.\\n     * @param tokenId ID of the token for which to retrieve the priorities of the active assets\\n     * @return An array of priorities of the active assets of the given token\\n     */\\n    function getActiveAssetPriorities(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Used to retrieve the asset that will be replaced if a given asset from the token's pending array\\n     *  is accepted.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @param tokenId ID of the token to check\\n     * @param newAssetId ID of the pending asset which will be accepted\\n     * @return ID of the asset which will be replaced\\n     */\\n    function getAssetReplacements(\\n        uint256 tokenId,\\n        uint64 newAssetId\\n    ) external view returns (uint64);\\n\\n    /**\\n     * @notice Used to fetch the asset metadata of the specified token's active asset with the given index.\\n     * @dev Assets are stored by reference mapping `_assets[assetId]`.\\n     * @dev Can be overriden to implement enumerate, fallback or other custom logic.\\n     * @param tokenId ID of the token from which to retrieve the asset metadata\\n     * @param assetId Asset Id, must be in the active assets array\\n     * @return The metadata of the asset belonging to the specified index in the token's active assets\\n     *  array\\n     */\\n    function getAssetMetadata(\\n        uint256 tokenId,\\n        uint64 assetId\\n    ) external view returns (string memory);\\n\\n    // Approvals\\n\\n    /**\\n     * @notice Used to grant permission to the user to manage token's assets.\\n     * @dev This differs from transfer approvals, as approvals are not cleared when the approved party accepts or\\n     *  rejects an asset, or sets asset priorities. This approval is cleared on token transfer.\\n     * @dev Only a single account can be approved at a time, so approving the `0x0` address clears previous approvals.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be an approved operator.\\n     *  - `tokenId` must exist.\\n     * @dev Emits an {ApprovalForAssets} event.\\n     * @param to Address of the account to grant the approval to\\n     * @param tokenId ID of the token for which the approval to manage the assets is granted\\n     */\\n    function approveForAssets(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @notice Used to retrieve the address of the account approved to manage assets of a given token.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @param tokenId ID of the token for which to retrieve the approved address\\n     * @return Address of the account that is approved to manage the specified token's assets\\n     */\\n    function getApprovedForAssets(\\n        uint256 tokenId\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Used to add or remove an operator of assets for the caller.\\n     * @dev Operators can call {acceptAsset}, {rejectAsset}, {rejectAllAssets} or {setPriority} for any token\\n     *  owned by the caller.\\n     * @dev Requirements:\\n     *\\n     *  - The `operator` cannot be the caller.\\n     * @dev Emits an {ApprovalForAllForAssets} event.\\n     * @param operator Address of the account to which the operator role is granted or revoked from\\n     * @param approved The boolean value indicating whether the operator role is being granted (`true`) or revoked\\n     *  (`false`)\\n     */\\n    function setApprovalForAllForAssets(\\n        address operator,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @notice Used to check whether the address has been granted the operator role by a given address or not.\\n     * @dev See {setApprovalForAllForAssets}.\\n     * @param owner Address of the account that we are checking for whether it has granted the operator role\\n     * @param operator Address of the account that we are checking whether it has the operator role or not\\n     * @return A boolean value indicating wehter the account we are checking has been granted the operator role\\n     */\\n    function isApprovedForAllForAssets(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/utils/RMRKBulkWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"../equippable/IERC6220.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"../library/RMRKErrors.sol\\\";\\n\\n/**\\n * @title RMRKBulkWriter\\n * @author RMRK team\\n * @notice Smart contract of the RMRK Bulk Writer module.\\n * @dev Extra utility functions for RMRK contracts.\\n */\\ncontract RMRKBulkWriter {\\n    /**\\n     * @notice Used to provide a struct for inputing unequip data.\\n     * @dev Only used for input and not storage of data.\\n     * @return assetId ID of the asset that we are equipping into\\n     * @return slotPartId ID of the slot part that we are using to unequip\\n     */\\n    struct IntakeUnequip {\\n        uint64 assetId;\\n        uint64 slotPartId;\\n    }\\n\\n    /**\\n     * @notice Reverts if the caller is not the owner of the token.\\n     * @param collection Address of the collection that this contract is managing\\n     * @param tokenId ID of the token we are managing\\n     */\\n    modifier onlyTokenOwner(address collection, uint256 tokenId) {\\n        _checkTokenOwner(collection, tokenId);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract.\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @notice Replaces the current equipped child in the asset and slot combination with the given one.\\n     * @dev The `IntakeEquip` stuct contains the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @param collection Address of the collection that this contract is managing\\n     * @param data An `IntakeEquip` struct specifying the equip data\\n     */\\n    function replaceEquip(\\n        address collection,\\n        IERC6220.IntakeEquip memory data\\n    ) public onlyTokenOwner(collection, data.tokenId) {\\n        IERC6220(collection).unequip(\\n            data.tokenId,\\n            data.assetId,\\n            data.slotPartId\\n        );\\n        IERC6220(collection).equip(data);\\n    }\\n\\n    /**\\n     * @notice Performs multiple unequip and/or equip operations.\\n     * @dev Unequip operations must run first.\\n     * @dev Unequip operations do not need to be related to the equip operations; this method does not force you to only equip the assets into the slots that were unequipped.\\n     * @dev `tokenId` is included as a parameter to be able to do a single check for ownership.\\n     * @dev Every `tokenId` in the `IntakeEquip` structs must match the `tokenId` passed as the argument.\\n     * @dev The `IntakeUnequip` stuct contains the following data:\\n     *  [\\n     *      assetId,\\n     *      slotPartId,\\n     *  ]\\n     * @dev The `IntakeEquip` stuct contains the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @param collection Address of the collection that this contract is managing\\n     * @param tokenId ID of the token we are managing\\n     * @param unequips[] An array of `IntakeUnequip` structs specifying the slots to unequip\\n     * @param equips[] An array of `IntakeEquip` structs specifying the slots to equip\\n     */\\n    function bulkEquip(\\n        address collection,\\n        uint256 tokenId,\\n        IntakeUnequip[] memory unequips,\\n        IERC6220.IntakeEquip[] memory equips\\n    ) public onlyTokenOwner(collection, tokenId) {\\n        uint256 length = unequips.length;\\n        for (uint256 i; i < length; ) {\\n            IERC6220(collection).unequip(\\n                tokenId,\\n                unequips[i].assetId,\\n                unequips[i].slotPartId\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        length = equips.length;\\n        for (uint256 i; i < length; ) {\\n            if (equips[i].tokenId != tokenId) {\\n                revert RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime();\\n            }\\n            IERC6220(collection).equip(equips[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Validates that the caller is the owner of the token.\\n     * @dev Reverts if the caller is not the owner of the token.\\n     * @param collection Address of the collection that this contract is managing\\n     * @param tokenId ID of the token we are managing\\n     */\\n    function _checkTokenOwner(\\n        address collection,\\n        uint256 tokenId\\n    ) internal view {\\n        address tokenOwner = IERC721(collection).ownerOf(tokenId);\\n        if (tokenOwner != msg.sender) {\\n            revert RMRKCanOnlyDoBulkOperationsOnOwnedTokens();\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"RMRKCanOnlyDoBulkOperationsOnOwnedTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"}],\"internalType\":\"struct RMRKBulkWriter.IntakeUnequip[]\",\"name\":\"unequips\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"childAssetId\",\"type\":\"uint64\"}],\"internalType\":\"struct IERC6220.IntakeEquip[]\",\"name\":\"equips\",\"type\":\"tuple[]\"}],\"name\":\"bulkEquip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"childAssetId\",\"type\":\"uint64\"}],\"internalType\":\"struct IERC6220.IntakeEquip\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"replaceEquip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RMRKBulkWriter", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}