{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/FarmBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './interfaces/ICakePool.sol';\\nimport './interfaces/IMasterChefV3.sol';\\nimport './libraries/IterateMapping.sol';\\nimport './interfaces/IPancakeV3Pool.sol';\\n\\ncontract FarmBooster is Ownable {\\n    using IterableMapping for ItMap;\\n\\n    /// @notice Cake token.\\n    address public immutable CAKE;\\n    /// @notice Cake pool.\\n    address public immutable CAKE_POOL;\\n    /// @notice MasterChef V3 contract.\\n    IMasterChefV3 public immutable MASTER_CHEF_V3;\\n\\n    /// @notice Initialize the totalLockedAmount.\\n    bool initialization;\\n\\n    /// @notice Cake Pool total locked cake amount.\\n    uint256 public totalLockedAmount;\\n\\n    /// @notice The latest total locked cake amount In CakePool\\n    uint256 latestTotalLockedAmountInCakePool;\\n\\n    struct UserLockedInfo {\\n        bool init;\\n        uint256 lockedAmount;\\n    }\\n\\n    /// @notice Record user lockedAmount in cake pool\\n    mapping(address => UserLockedInfo) public userLockedInfos;\\n\\n    /// @notice Maximum allowed boosted position numbers\\n    uint256 public MAX_BOOST_POSITION;\\n    /// @notice limit max boost\\n    uint256 public cA;\\n    /// @notice include 1e4\\n    uint256 public constant MIN_CA = 1e4;\\n    /// @notice include 1e5\\n    uint256 public constant MAX_CA = 1e5;\\n    /// @notice cA precision\\n    uint256 public constant CA_PRECISION = 1e5;\\n    /// @notice controls difficulties\\n    uint256 public cB;\\n    /// @notice not include 0\\n    uint256 public constant MIN_CB = 0;\\n    /// @notice include 50\\n    uint256 public constant MAX_CB = 1e8;\\n    /// @notice cB precision\\n    uint256 public constant CB_PRECISION = 1e4;\\n    /// @notice MCV3 basic boost factor, none boosted user\\\"s boost factor\\n    uint256 public constant BOOST_PRECISION = 100 * 1e10;\\n    /// @notice MCV3 Hard limit for maxmium boost factor\\n    uint256 public constant MAX_BOOST_PRECISION = 200 * 1e10;\\n    /// @notice Average boost ratio precision\\n    uint256 public constant BOOST_RATIO_PRECISION = 1e5;\\n    /// @notice Cake pool BOOST_WEIGHT precision\\n    uint256 public constant BOOST_WEIGHT_PRECISION = 100 * 1e10; // 100%\\n\\n    /// @notice Override global cB for special pool pid.\\n    mapping(uint256 => uint256) public cBOverride;\\n\\n    /// @notice The whitelist of pools allowed for farm boosting.\\n    mapping(uint256 => bool) public whiteList;\\n\\n    /// @notice Record whether the farm booster has been turned on, in order to save gas.\\n    mapping(uint256 => bool) public everBoosted;\\n\\n    /// @notice Info of each pool user.\\n    mapping(address => ItMap) public userInfo;\\n\\n    event UpdateMaxBoostPosition(uint256 max);\\n    event UpdateCA(uint256 oldCA, uint256 newCA);\\n    event UpdateCB(uint256 oldCB, uint256 newCB);\\n    event UpdateCBOverride(uint256 pid, uint256 oldCB, uint256 newCB);\\n    event UpdateBoostFarms(uint256 pid, bool status);\\n    event AdjustTotalLockedAmount(bool down, uint256 amount);\\n    event ActiveFarmPool(address indexed user, uint256 indexed pid, uint256 indexed tokenId);\\n    event DeactiveFarmPool(address indexed user, uint256 indexed pid, uint256 indexed tokenId);\\n    event UpdatePoolBoostMultiplier(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 indexed tokenId,\\n        uint256 oldMultiplier,\\n        uint256 newMultiplier\\n    );\\n    event UpdateCakePool(\\n        address indexed user,\\n        uint256 lockedAmount,\\n        uint256 lockedDuration,\\n        uint256 totalLockedAmount,\\n        uint256 maxLockDuration\\n    );\\n\\n    /// @param _cake CAKE token contract address.\\n    /// @param _cakePool Cake Pool contract address.\\n    /// @param _v3 MasterChefV3 contract address.\\n    /// @param _max Maximum allowed boosted farm quantity.\\n    /// @param _cA Limit max boost.\\n    /// @param _cB Controls difficulties.\\n    constructor(address _cake, address _cakePool, IMasterChefV3 _v3, uint256 _max, uint256 _cA, uint256 _cB) {\\n        require(_max > 0 && _cA >= MIN_CA && _cA <= MAX_CA && _cB > MIN_CB && _cB <= MAX_CB, 'Invalid parameter');\\n        CAKE = _cake;\\n        CAKE_POOL = _cakePool;\\n        MASTER_CHEF_V3 = _v3;\\n        MAX_BOOST_POSITION = _max;\\n        cA = _cA;\\n        cB = _cB;\\n    }\\n\\n    /// @notice Checks if the msg.sender is the cake pool.\\n    modifier onlyCakePool() {\\n        require(msg.sender == CAKE_POOL, 'Not cake pool');\\n        _;\\n    }\\n\\n    /// @notice Checks if the msg.sender is the MasterChef V3.\\n    modifier onlyMasterChefV3() {\\n        require(msg.sender == address(MASTER_CHEF_V3), 'Not MasterChef V3');\\n        _;\\n    }\\n\\n    /// @notice Adjust the totalLockedAmount caused by inaccurate calculations.\\n    /// @param _down Down or up.\\n    /// @param _amount The amount need to be adjusted.\\n    function adjustTotalLockedAmount(bool _down, uint256 _amount) external onlyOwner {\\n        if (_down) {\\n            totalLockedAmount -= _amount;\\n        } else {\\n            totalLockedAmount += _amount;\\n        }\\n        emit AdjustTotalLockedAmount(_down, _amount);\\n    }\\n\\n    /// @notice set maximum allowed boosted position numbers.\\n    /// @param _max MAX_BOOST_POSITION.\\n    function setMaxBoostPosition(uint256 _max) external onlyOwner {\\n        require(_max > 0, 'Can not be zero');\\n        MAX_BOOST_POSITION = _max;\\n        emit UpdateMaxBoostPosition(_max);\\n    }\\n\\n    /// @notice Only allow whitelisted pids for farm boosting.\\n    /// @param _pid pool id(Masterchef V3 pool).\\n    /// @param _status farm pool allowed boosted or not.\\n    function setBoosterFarms(uint256 _pid, bool _status) external onlyOwner {\\n        if (_status && !everBoosted[_pid]) everBoosted[_pid] = true;\\n        whiteList[_pid] = _status;\\n        emit UpdateBoostFarms(_pid, _status);\\n    }\\n\\n    /// @notice Limit max boost.\\n    /// @param _cA Max boost.\\n    function setCA(uint256 _cA) external onlyOwner {\\n        require(_cA >= MIN_CA && _cA <= MAX_CA, 'Invalid cA');\\n        uint256 temp = cA;\\n        cA = _cA;\\n        emit UpdateCA(temp, cA);\\n    }\\n\\n    /// @notice Controls difficulties.\\n    /// @param _cB Difficulties.\\n    function setCB(uint256 _cB) external onlyOwner {\\n        require(_cB > MIN_CB && _cB <= MAX_CB, 'Invalid cB');\\n        uint256 temp = cB;\\n        cB = _cB;\\n        emit UpdateCB(temp, cB);\\n    }\\n\\n    /// @notice Set cBOverride.\\n    /// @param _pid Pool pid.\\n    /// @param _cB Difficulties.\\n    function setCBOverride(uint256 _pid, uint256 _cB) external onlyOwner {\\n        // Can set cBOverride[pid] 0 when need to remove override value.\\n        require(_cB <= MAX_CB, 'Invalid cB');\\n        uint256 temp = cB;\\n        cBOverride[_pid] = _cB;\\n        emit UpdateCBOverride(_pid, temp, cB);\\n    }\\n\\n    /// @notice Calculate totalLockedAmount and update UserLockedInfo.\\n    /// @dev This is to fix the totalLockedAmount issue in cake pool.\\n    /// @param _user User address.\\n    function updateTotalLockedAmount(address _user) internal {\\n        uint256 totalLockedAmountInCakePool = ICakePool(CAKE_POOL).totalLockedAmount();\\n        if (!initialization) {\\n            // Record the totalLockedAmount as the initial value after setting farm booster contract in cake pool.\\n            initialization = true;\\n            totalLockedAmount = totalLockedAmountInCakePool;\\n            latestTotalLockedAmountInCakePool = totalLockedAmountInCakePool;\\n        }\\n        (, , , , , , , , uint256 userLockedAmount) = ICakePool(CAKE_POOL).userInfo(_user);\\n        UserLockedInfo storage lockedInfo = userLockedInfos[_user];\\n        if (!lockedInfo.init) {\\n            lockedInfo.init = true;\\n            lockedInfo.lockedAmount = userLockedAmount;\\n\\n            // Deposit cake into cake pool.\\n            if (totalLockedAmountInCakePool >= latestTotalLockedAmountInCakePool) {\\n                totalLockedAmount += totalLockedAmountInCakePool - latestTotalLockedAmountInCakePool;\\n            } else {\\n                // Withdraw cake from cake pool.\\n                totalLockedAmount -= latestTotalLockedAmountInCakePool - totalLockedAmountInCakePool;\\n            }\\n        } else {\\n            totalLockedAmount = totalLockedAmount - lockedInfo.lockedAmount + userLockedAmount;\\n            lockedInfo.lockedAmount = userLockedAmount;\\n        }\\n        latestTotalLockedAmountInCakePool = totalLockedAmountInCakePool;\\n    }\\n\\n    /// @notice Update UserLockedInfo.\\n    /// @dev This will update the userLockedAmount for the users who had already locked cake in cake pool.\\n    /// @param _user User address.\\n    function updateUserLockedAmount(address _user) internal {\\n        UserLockedInfo storage lockedInfo = userLockedInfos[_user];\\n        if (initialization && !lockedInfo.init) {\\n            (, , , , , , , , uint256 userLockedAmount) = ICakePool(CAKE_POOL).userInfo(_user);\\n            lockedInfo.init = true;\\n            lockedInfo.lockedAmount = userLockedAmount;\\n        }\\n    }\\n\\n    /// @notice Cakepool operation(deposit/withdraw) automatically call this function.\\n    /// @param _user User address.\\n    /// @param _lockedAmount User locked amount in cake pool.\\n    /// @param _lockedDuration User locked duration in cake pool.\\n    /// @param _totalLockedAmount Total locked cake amount in cake pool.\\n    /// @param _maxLockDuration Maximum locked duration in cake pool.\\n    function onCakePoolUpdate(\\n        address _user,\\n        uint256 _lockedAmount,\\n        uint256 _lockedDuration,\\n        uint256 _totalLockedAmount,\\n        uint256 _maxLockDuration\\n    ) external onlyCakePool {\\n        updateTotalLockedAmount(_user);\\n        ItMap storage itmap = userInfo[_user];\\n        uint256 length = itmap.keys.length;\\n        if (length > 0) {\\n            uint256 avgDuration = avgLockDuration();\\n            for (uint256 i = 0; i < length; i++) {\\n                uint256 tokenId = itmap.keys[i];\\n                (uint128 liquidity, address user, uint256 pid, ) = getUserPositionInfo(tokenId);\\n                if (_user == user) _updateBoostMultiplier(itmap, user, pid, tokenId, avgDuration, liquidity);\\n            }\\n        }\\n        emit UpdateCakePool(_user, _lockedAmount, _lockedDuration, _totalLockedAmount, _maxLockDuration);\\n    }\\n\\n    /// @notice Update user boost multiplier, only for MasterChef V3.\\n    /// @param _tokenId Token Id of position NFT.\\n    function updatePositionBoostMultiplier(uint256 _tokenId) external onlyMasterChefV3 returns (uint256 _multiplier) {\\n        (uint128 liquidity, address user, uint256 pid, ) = getUserPositionInfo(_tokenId);\\n        // Set default multiplier\\n        _multiplier = BOOST_PRECISION;\\n        // In order to save gas, no need to check the farms which have never beed boosted.\\n        if (everBoosted[pid]) {\\n            ItMap storage itmap = userInfo[user];\\n            uint256 prevMultiplier = itmap.data[_tokenId];\\n            if (prevMultiplier == 0) return BOOST_PRECISION;\\n            if (!whiteList[pid]) {\\n                if (itmap.contains(_tokenId)) {\\n                    itmap.remove(_tokenId);\\n                    emit DeactiveFarmPool(user, pid, _tokenId);\\n                }\\n            } else {\\n                _multiplier = _boostCalculate(user, pid, avgLockDuration(), uint256(liquidity));\\n                itmap.insert(_tokenId, _multiplier);\\n            }\\n            emit UpdatePoolBoostMultiplier(user, pid, _tokenId, prevMultiplier, _multiplier);\\n        }\\n    }\\n\\n    /// @notice Remove user boost multiplier when user withdraw or butn in MasterChef V3.\\n    /// @param _user User address.\\n    /// @param _tokenId Token Id of position NFT.\\n    /// @param _pid Id of MasterChef V3 farm pool.\\n    function removeBoostMultiplier(address _user, uint256 _tokenId, uint256 _pid) external onlyMasterChefV3 {\\n        // In order to save gas, no need to check the farms which have never beed boosted.\\n        if (everBoosted[_pid]) {\\n            ItMap storage itmap = userInfo[_user];\\n            if (itmap.contains(_tokenId)) {\\n                itmap.remove(_tokenId);\\n                emit DeactiveFarmPool(_user, _pid, _tokenId);\\n            }\\n        }\\n    }\\n\\n    /// @notice Active user farm pool.\\n    /// @param _tokenId Token Id of position NFT.\\n    function activate(uint256 _tokenId) external {\\n        (uint128 liquidity, address user, uint256 pid, ) = getUserPositionInfo(_tokenId);\\n        require(whiteList[pid], 'Not boosted farm pool');\\n        require(user == msg.sender, 'Not owner');\\n        ItMap storage itmap = userInfo[user];\\n        require(!itmap.contains(_tokenId), 'Already boosted');\\n        require(itmap.keys.length < MAX_BOOST_POSITION, 'Boosted positions reach to MAX');\\n        updateUserLockedAmount(user);\\n\\n        _updateBoostMultiplier(itmap, user, pid, _tokenId, avgLockDuration(), uint256(liquidity));\\n\\n        emit ActiveFarmPool(user, pid, _tokenId);\\n    }\\n\\n    /// @notice Deactive user farm pool.\\n    /// @param _tokenId Token Id of position NFT.\\n    function deactive(uint256 _tokenId) external {\\n        ItMap storage itmap = userInfo[msg.sender];\\n        require(itmap.contains(_tokenId), 'None boost user');\\n\\n        if (itmap.data[_tokenId] > BOOST_PRECISION) {\\n            MASTER_CHEF_V3.updateBoostMultiplier(_tokenId, BOOST_PRECISION);\\n        }\\n        itmap.remove(_tokenId);\\n\\n        (, , uint256 pid, ) = getUserPositionInfo(_tokenId);\\n        emit DeactiveFarmPool(msg.sender, pid, _tokenId);\\n    }\\n\\n    /// @param _user user address.\\n    /// @param _pid pool id.\\n    /// @param _tokenId token id.\\n    /// @param _duration cake pool average locked duration.\\n    /// @param _liquidity position liquidity.\\n    function _updateBoostMultiplier(\\n        ItMap storage itmap,\\n        address _user,\\n        uint256 _pid,\\n        uint256 _tokenId,\\n        uint256 _duration,\\n        uint256 _liquidity\\n    ) internal {\\n        // Used to be boost farm pool and current is not, remove from mapping\\n        if (!whiteList[_pid]) {\\n            if (itmap.data[_tokenId] > BOOST_PRECISION) {\\n                // reset to BOOST_PRECISION\\n                MASTER_CHEF_V3.updateBoostMultiplier(_tokenId, BOOST_PRECISION);\\n            }\\n            itmap.remove(_tokenId);\\n            emit DeactiveFarmPool(_user, _pid, _tokenId);\\n            return;\\n        }\\n\\n        (, , , uint256 prevMultiplier) = getUserPositionInfo(_tokenId);\\n        uint256 multiplier = _boostCalculate(_user, _pid, _duration, _liquidity);\\n\\n        if (multiplier < BOOST_PRECISION) {\\n            multiplier = BOOST_PRECISION;\\n        } else if (multiplier > MAX_BOOST_PRECISION) {\\n            multiplier = MAX_BOOST_PRECISION;\\n        }\\n\\n        // Update multiplier to MCV3\\n        if (multiplier != prevMultiplier) {\\n            MASTER_CHEF_V3.updateBoostMultiplier(_tokenId, multiplier);\\n        }\\n        itmap.insert(_tokenId, multiplier);\\n\\n        emit UpdatePoolBoostMultiplier(_user, _pid, _tokenId, prevMultiplier, multiplier);\\n    }\\n\\n    /// @notice Whether position boosted specific farm pool.\\n    /// @param _tokenId Token Id of position NFT.\\n    function isBoostedPool(uint256 _tokenId) external view returns (bool, uint256) {\\n        (, address user, uint256 pid, ) = getUserPositionInfo(_tokenId);\\n        return (userInfo[user].contains(_tokenId), pid);\\n    }\\n\\n    /// @notice Actived position list.\\n    /// @param _user user address.\\n    function activedPositions(address _user) external view returns (uint256[] memory positions) {\\n        ItMap storage itmap = userInfo[_user];\\n        if (itmap.keys.length == 0) return positions;\\n\\n        positions = new uint256[](itmap.keys.length);\\n        // solidity for-loop not support multiple variables initializae by \\\",\\\" separate.\\n        for (uint256 index = 0; index < itmap.keys.length; index++) {\\n            positions[index] = itmap.keys[index];\\n        }\\n    }\\n\\n    function getUserPositionInfo(\\n        uint256 _tokenId\\n    ) internal view returns (uint128 liquidity, address user, uint256 pid, uint256 boostMultiplier) {\\n        (liquidity, , , , , , user, pid, boostMultiplier) = MASTER_CHEF_V3.userPositionInfos(_tokenId);\\n    }\\n\\n    /// @notice Anyone can call this function, if you find some guys effectived multiplier is not fair\\n    /// for other users, just call \\\"updateLiquidity\\\" function in MasterChef V3.\\n    /// @param _tokenId Token Id of position NFT.\\n    /// @dev If return value not in range [BOOST_PRECISION, MAX_BOOST_PRECISION]\\n    /// the actual effectived multiplier will be the close to side boundry value.\\n    function getUserMultiplier(uint256 _tokenId) external view returns (uint256) {\\n        (uint128 liquidity, address user, uint256 pid, ) = getUserPositionInfo(_tokenId);\\n        if (!whiteList[pid]) {\\n            return BOOST_PRECISION;\\n        } else {\\n            return _boostCalculate(user, pid, avgLockDuration(), uint256(liquidity));\\n        }\\n    }\\n\\n    /// @notice Cake pool average locked duration calculator.\\n    function avgLockDuration() public view returns (uint256) {\\n        uint256 totalStakedAmount = IERC20(CAKE).balanceOf(CAKE_POOL);\\n\\n        uint256 pricePerFullShare = ICakePool(CAKE_POOL).getPricePerFullShare();\\n\\n        uint256 flexibleShares;\\n        if (totalStakedAmount > totalLockedAmount && pricePerFullShare > 0)\\n            flexibleShares = ((totalStakedAmount - totalLockedAmount) * 1e18) / pricePerFullShare;\\n        if (flexibleShares == 0) return 0;\\n\\n        uint256 originalShares = (totalLockedAmount * 1e18) / pricePerFullShare;\\n        if (originalShares == 0) return 0;\\n\\n        uint256 boostedRatio = ((ICakePool(CAKE_POOL).totalShares() - flexibleShares) * BOOST_RATIO_PRECISION) /\\n            originalShares;\\n        if (boostedRatio <= BOOST_RATIO_PRECISION) return 0;\\n\\n        uint256 boostWeight = ICakePool(CAKE_POOL).BOOST_WEIGHT();\\n        uint256 maxLockDuration = ICakePool(CAKE_POOL).MAX_LOCK_DURATION() * BOOST_RATIO_PRECISION;\\n\\n        uint256 duration = ((boostedRatio - BOOST_RATIO_PRECISION) * 365 * BOOST_WEIGHT_PRECISION) / boostWeight;\\n        return duration <= maxLockDuration ? duration : maxLockDuration;\\n    }\\n\\n    /// @notice Get the total liquidity.\\n    /// @dev Will use the smaller value between MasterChefV3 pool totalLiquidity and V3 pool liquidity.\\n    /// @param _pid pool id(MasterchefV3 pool).\\n    function _getTotalLiquidity(uint256 _pid) internal view returns (uint256) {\\n        (, address v3Pool, , , , uint256 totalLiquidity, ) = MASTER_CHEF_V3.poolInfo(_pid);\\n        uint256 v3PoolLiquidity = IPancakeV3Pool(v3Pool).liquidity();\\n        if (totalLiquidity > v3PoolLiquidity) {\\n            totalLiquidity = v3PoolLiquidity;\\n        }\\n        return totalLiquidity;\\n    }\\n\\n    /// @param _user user address.\\n    /// @param _pid pool id(MasterchefV3 pool).\\n    /// @param _duration cake pool average locked duration.\\n    /// @param _liquidity position liquidity.\\n    function _boostCalculate(\\n        address _user,\\n        uint256 _pid,\\n        uint256 _duration,\\n        uint256 _liquidity\\n    ) internal view returns (uint256) {\\n        if (_duration == 0) return BOOST_PRECISION;\\n\\n        uint256 dB = (cA * _liquidity) / CA_PRECISION;\\n        // dB == 0 means _liquidity close to 0\\n        if (_liquidity == 0 || dB == 0) return BOOST_PRECISION;\\n\\n        (, , , , uint256 lockStartTime, uint256 lockEndTime, , , uint256 userLockedAmount) = ICakePool(CAKE_POOL)\\n            .userInfo(_user);\\n        if (userLockedAmount == 0 || block.timestamp >= lockEndTime) return BOOST_PRECISION;\\n\\n        uint256 totalLiquidity = _getTotalLiquidity(_pid);\\n\\n        uint256 userLockedDuration = (lockEndTime - lockStartTime) / (3600 * 24); // days\\n\\n        // will use cBOverride[pid] If cBOverride[pid] is greater than 0 , or will use global cB.\\n        uint256 realCB = cBOverride[_pid] > 0 ? cBOverride[_pid] : cB;\\n\\n        uint256 aB = (((totalLiquidity * userLockedAmount * userLockedDuration) *\\n            BOOST_RATIO_PRECISION *\\n            CB_PRECISION) / realCB) / (totalLockedAmount * _duration);\\n\\n        // should \\\"*\\\" BOOST_PRECISION\\n        return ((_liquidity < (dB + aB) ? _liquidity : (dB + aB)) * BOOST_PRECISION) / dB;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICakePool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICakePool {\\n    function userInfo(\\n        address _user\\n    ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);\\n\\n    function getPricePerFullShare() external view returns (uint256);\\n\\n    function totalLockedAmount() external view returns (uint256);\\n\\n    function totalShares() external view returns (uint256);\\n\\n    function BOOST_WEIGHT() external view returns (uint256);\\n\\n    function MAX_LOCK_DURATION() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasterChefV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IMasterChefV3 {\\n    function userPositionInfos(\\n        uint256 _tokenId\\n    ) external view returns (uint128, uint128, int24, int24, uint256, uint256, address, uint256, uint256);\\n\\n    function poolInfo(\\n        uint256 _pid\\n    ) external view returns (uint256, address, address, address, uint24, uint256, uint256);\\n\\n    function getBoostMultiplier(address _user, uint256 _pid) external view returns (uint256);\\n\\n    function updateBoostMultiplier(uint256 _tokenId, uint256 _newMultiplier) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeV3Pool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPancakeV3Pool {\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/IterateMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nstruct ItMap {\\n    // pid => boost\\n    mapping(uint256 => uint256) data;\\n    // pid => index\\n    mapping(uint256 => uint256) indexs;\\n    // array of pid\\n    uint256[] keys;\\n    // never use it, just for keep compile success.\\n    uint256 size;\\n}\\n\\nlibrary IterableMapping {\\n    function insert(ItMap storage self, uint256 key, uint256 value) internal {\\n        uint256 keyIndex = self.indexs[key];\\n        self.data[key] = value;\\n        if (keyIndex > 0) return;\\n        else {\\n            self.indexs[key] = self.keys.length + 1;\\n            self.keys.push(key);\\n            return;\\n        }\\n    }\\n\\n    function remove(ItMap storage self, uint256 key) internal {\\n        uint256 index = self.indexs[key];\\n        if (index == 0) return;\\n        uint256 lastKey = self.keys[self.keys.length - 1];\\n        if (key != lastKey) {\\n            self.keys[index - 1] = lastKey;\\n            self.indexs[lastKey] = index;\\n        }\\n        delete self.data[key];\\n        delete self.indexs[key];\\n        self.keys.pop();\\n    }\\n\\n    function contains(ItMap storage self, uint256 key) internal view returns (bool) {\\n        return self.indexs[key] > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cake\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cakePool\",\"type\":\"address\"},{\"internalType\":\"contract IMasterChefV3\",\"name\":\"_v3\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ActiveFarmPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"down\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AdjustTotalLockedAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"DeactiveFarmPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateBoostFarms\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCA\",\"type\":\"uint256\"}],\"name\":\"UpdateCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCB\",\"type\":\"uint256\"}],\"name\":\"UpdateCB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCB\",\"type\":\"uint256\"}],\"name\":\"UpdateCBOverride\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalLockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLockDuration\",\"type\":\"uint256\"}],\"name\":\"UpdateCakePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxBoostPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMultiplier\",\"type\":\"uint256\"}],\"name\":\"UpdatePoolBoostMultiplier\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOOST_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_RATIO_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_WEIGHT_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAKE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAKE_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CA_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CB_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MASTER_CHEF_V3\",\"outputs\":[{\"internalType\":\"contract IMasterChefV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOOST_POSITION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOOST_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"activedPositions\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"positions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_down\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"adjustTotalLockedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgLockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cBOverride\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"deactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"everBoosted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUserMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isBoostedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockedDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxLockDuration\",\"type\":\"uint256\"}],\"name\":\"onCakePoolUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"removeBoostMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBoosterFarms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cA\",\"type\":\"uint256\"}],\"name\":\"setCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cB\",\"type\":\"uint256\"}],\"name\":\"setCB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cB\",\"type\":\"uint256\"}],\"name\":\"setCBOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMaxBoostPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"updatePositionBoostMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLockedInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FarmBooster", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000000e09fabb73bd3ade0a17ecc321fd13a19e81ce8200000000000000000000000045c54210128a065de780c4b0df3d16664f7f859e000000000000000000000000556b9306565093c855aea9ae92a594704c2cd59e0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000c35000000000000000000000000000000000000000000000000000000000000186a0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}