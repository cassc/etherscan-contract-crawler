{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Games/LuckyDraw/LuckyDraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\ninterface IERC20 {\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ncontract LuckyDraw {\\n    uint256 private maxTicketsPerAddress;\\n    uint256 public gameStartTimestamp;\\n\\n    address private ownerAddress;\\n\\n    mapping(uint256 => address) private tickets;\\n    mapping(address => uint256[]) private userTickets;\\n\\n    address[] public winners;\\n    uint256[] public winningTickets;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private totalTicketsCount;\\n\\n    constructor(address _ownerAddress, uint256 _maxTicketsPerAddress) {\\n        ownerAddress = _ownerAddress;\\n        maxTicketsPerAddress = _maxTicketsPerAddress;\\n        gameStartTimestamp = block.timestamp;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == ownerAddress,\\n            \\\"Only owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    function buyTickets(\\n        address _ticketHolder,\\n        uint _numTickets\\n    ) external onlyOwner returns (bool) {\\n        for (uint256 i = 0; i < _numTickets; i++) {\\n            tickets[totalTicketsCount.current()] = _ticketHolder;\\n            userTickets[_ticketHolder].push(totalTicketsCount.current());\\n            totalTicketsCount.increment();\\n        }\\n        return true;\\n    }\\n\\n    function drawWinners(\\n        uint256[] memory _randomWords,\\n        uint8 _numWinners\\n    ) external onlyOwner {\\n        uint256 _ticket0;\\n        uint256 _ticketN;\\n        uint256 _totalTicketsCount = totalTicketsCount.current();\\n        _ticket0 = _randomWords[0] % _totalTicketsCount;\\n        winners.push(tickets[_ticket0]);\\n        winningTickets.push(_ticket0);\\n        for (uint256 i = 1; i < _numWinners; i++) {\\n            _ticketN =\\n                (_ticket0 +\\n                    ((_randomWords[0] % (_totalTicketsCount - i)) + i)) %\\n                _totalTicketsCount;\\n            winners.push(tickets[_ticketN]);\\n            winningTickets.push(_ticketN);\\n        }\\n    }\\n\\n    function setGameStartTimestamp(\\n        uint256 _gameStartTimestamp\\n    ) external onlyOwner {\\n        gameStartTimestamp = _gameStartTimestamp;\\n    }\\n\\n    function getTicketHolder(\\n        uint256 _ticketNumber\\n    ) external view returns (address) {\\n        return tickets[_ticketNumber];\\n    }\\n\\n    function getUserTickets(\\n        address _userAddress\\n    ) external view returns (uint256[] memory) {\\n        return userTickets[_userAddress];\\n    }\\n\\n    function getUserTicketsCount(\\n        address _userAddress\\n    ) external view returns (uint256) {\\n        return userTickets[_userAddress].length;\\n    }\\n\\n    function getTotalTicketsCount() external view returns (uint256) {\\n        return totalTicketsCount.current();\\n    }\\n\\n    function getWinners() external view returns (address[] memory) {\\n        return winners;\\n    }\\n\\n    function getWinningTickets() external view returns (uint256[] memory) {\\n        return winningTickets;\\n    }\\n\\n    function getWinnersNumber() external view returns (uint256) {\\n        return winners.length;\\n    }\\n\\n    function withdrawToken(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        require(IERC20(_token).transfer(_to, _amount), \\\"Transfer failed\\\");\\n    }\\n\\n    function withdrawETH(address _to, uint256 _amount) external onlyOwner {\\n        (bool success, ) = payable(_to).call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Games/LuckyDraw/LuckyDrawFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"./LuckyDraw.sol\\\";\\n\\ncontract LuckyDrawFactory {\\n    LuckyDraw private currentGame;\\n\\n    enum GameState {\\n        STARTED,\\n        VRF_REQUESTED,\\n        VRF_DRAWN,\\n        OVER\\n    }\\n\\n    GameState private gameState = GameState.OVER;\\n\\n    struct GameInfos {\\n        GameState gameState;\\n        uint256 gameNumber;\\n        address gameAddress;\\n        uint256 ticketPrice;\\n        uint256 maxTicketsPerAddress;\\n        uint256 maxTicketsPerAddressAtOnce;\\n        uint256 gameStartTimestamp;\\n        uint256 drawInterval;\\n        uint8 houseFeePercent;\\n        uint8 numWinners;\\n        uint256 totalTicketsCount;\\n    }\\n\\n    struct VRFRequests {\\n        uint256 id;\\n        uint256 blockNumber;\\n    }\\n    VRFRequests public VRFRequest;\\n\\n    uint256 private ticketPrice;\\n    uint256 private maxTicketsPerAddress = 1000;\\n    uint256 private maxTicketsPerAddressAtOnce = 300;\\n    uint256 private drawInterval = 82800;\\n\\n    address public ownerAddress;\\n    address public houseAddress;\\n    address public token;\\n    address public chainlinkVRF;\\n    bytes32 public chainlinkVRFKeyHash;\\n\\n    uint64 public chainlinkVRFSubscriptionId = 0;\\n\\n    uint8 private houseFeePercent = 10;\\n    uint8 private numWinners = 3;\\n\\n    mapping(uint256 => address) public dailyDrawGames;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private gamesCounter;\\n\\n    event GameCreated(address indexed gameAddress, uint256 indexed gameNumber);\\n    event GameOver(address indexed gameAddress, uint256 indexed gameNumber);\\n    event ticketBuy(\\n        address indexed buyer,\\n        uint256 indexed gameNumber,\\n        uint256 numTickets,\\n        uint256 ticketPrice\\n    );\\n    event drawWinners(\\n        uint256 indexed gameNumber,\\n        address[] winners,\\n        uint256[] winningTicket,\\n        uint256 prizeVal\\n    );\\n    event VRFRequested(uint256 indexed gameNumber, uint256 indexed requestId);\\n\\n    constructor(\\n        address _chainlinkVRF,\\n        bytes32 _chainlinkVRFKeyHash,\\n        uint64 _chainlinkVRFSubscriptionId,\\n        address _token,\\n        uint256 _ticketPrice,\\n        address _ownerAddress\\n    ) {\\n        token = _token;\\n        ticketPrice = _ticketPrice;\\n        ownerAddress = _ownerAddress;\\n        houseAddress = _ownerAddress;\\n        chainlinkVRF = _chainlinkVRF;\\n        chainlinkVRFKeyHash = _chainlinkVRFKeyHash;\\n        chainlinkVRFSubscriptionId = _chainlinkVRFSubscriptionId;\\n        createGame();\\n    }\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == ownerAddress,\\n            \\\"Only owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    function createGame() private {\\n        require(gameState == GameState.OVER, \\\"A Game is Already Running\\\");\\n        gamesCounter.increment();\\n        dailyDrawGames[gamesCounter.current()] = address(\\n            new LuckyDraw(address(this), maxTicketsPerAddress)\\n        );\\n        currentGame = LuckyDraw(dailyDrawGames[gamesCounter.current()]);\\n        gameState = GameState.STARTED;\\n        emit GameCreated(address(currentGame), gamesCounter.current());\\n    }\\n\\n    function buyTickets(uint numTickets) external {\\n        require(gameState == GameState.STARTED, \\\"Game not started\\\");\\n        require(\\n            numTickets > 0 && numTickets <= maxTicketsPerAddressAtOnce,\\n            \\\"Must buy at least one ticket and less than maxTicketsPerAddressAtOnce\\\"\\n        );\\n        require(\\n            currentGame.getUserTicketsCount(msg.sender) + numTickets <=\\n                maxTicketsPerAddress,\\n            \\\"Cannot buy more than maxTicketsPerAddress\\\"\\n        );\\n        require(\\n            IERC20(token).transferFrom(\\n                msg.sender,\\n                address(this),\\n                ticketPrice * numTickets\\n            ),\\n            \\\"Transfer failed\\\"\\n        );\\n        require(\\n            currentGame.buyTickets(msg.sender, numTickets),\\n            \\\"can't buy ticket\\\"\\n        );\\n        emit ticketBuy(\\n            msg.sender,\\n            gamesCounter.current(),\\n            numTickets,\\n            ticketPrice\\n        );\\n    }\\n\\n    function drawWinnersRequest() external onlyOwner returns (uint256) {\\n        require(gameState == GameState.STARTED, \\\"Game not started\\\");\\n\\n        require(\\n            block.timestamp >= currentGame.gameStartTimestamp() + drawInterval,\\n            \\\"Draw interval not reached\\\"\\n        );\\n        require(currentGame.getWinnersNumber() == 0, \\\"Winners already drawn\\\");\\n\\n        if (currentGame.getTotalTicketsCount() <= numWinners) {\\n            currentGame.setGameStartTimestamp(block.timestamp);\\n            return 0;\\n        }\\n\\n        uint256 requestId;\\n        requestId = VRFCoordinatorV2Interface(chainlinkVRF).requestRandomWords(\\n            chainlinkVRFKeyHash,\\n            chainlinkVRFSubscriptionId,\\n            10,\\n            2500000,\\n            1\\n        );\\n\\n        VRFRequest = VRFRequests(requestId, block.number);\\n        gameState = GameState.VRF_REQUESTED;\\n\\n        emit VRFRequested(gamesCounter.current(), requestId);\\n\\n        return requestId;\\n    }\\n\\n    function rawFulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords\\n    ) external {\\n        require(\\n            msg.sender == chainlinkVRF,\\n            \\\"only chainlink VRF can call this function\\\"\\n        );\\n        fulfillRandomWords(requestId, randomWords);\\n    }\\n\\n    function fulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords\\n    ) private {\\n        require(gameState == GameState.VRF_REQUESTED, \\\"VRF not requested\\\");\\n        require(VRFRequest.id == requestId, \\\"Wrong requestId\\\");\\n\\n        gameState = GameState.VRF_DRAWN;\\n\\n        currentGame.drawWinners(randomWords, numWinners);\\n\\n        sendPrizes();\\n    }\\n\\n    function sendPrizes() private {\\n        require(gameState == GameState.VRF_DRAWN, \\\"VRF not drawn\\\");\\n        require(\\n            currentGame.getWinnersNumber() == numWinners,\\n            \\\"Winners not drawn\\\"\\n        );\\n\\n        address[] memory winners = currentGame.getWinners();\\n        require(winners.length == numWinners, \\\"Wrong number of winners\\\");\\n\\n        uint256 totalPrize = currentGame.getTotalTicketsCount() * ticketPrice;\\n        require(\\n            IERC20(token).balanceOf(address(this)) >= totalPrize,\\n            \\\"Not enough balance\\\"\\n        );\\n\\n        uint256 houseFee = (totalPrize * houseFeePercent) / 100;\\n        uint256 prizePerWinner = (totalPrize - houseFee) / numWinners;\\n\\n        emit drawWinners(\\n            gamesCounter.current(),\\n            winners,\\n            currentGame.getWinningTickets(),\\n            prizePerWinner\\n        );\\n\\n        for (uint8 i = 0; i < numWinners; i++) {\\n            require(\\n                IERC20(token).transfer(winners[i], prizePerWinner),\\n                \\\"Transfer failed\\\"\\n            );\\n        }\\n\\n        require(\\n            IERC20(token).transfer(houseAddress, houseFee),\\n            \\\"Transfer failed\\\"\\n        );\\n\\n        gameState = GameState.OVER;\\n        emit GameOver(address(currentGame), gamesCounter.current());\\n\\n        createGame();\\n    }\\n\\n    function setTicketPrice(uint256 _ticketPrice) external onlyOwner {\\n        ticketPrice = _ticketPrice;\\n    }\\n\\n    function setMaxTicketsPerAddress(\\n        uint256 _maxTicketsPerAddress\\n    ) external onlyOwner {\\n        maxTicketsPerAddress = _maxTicketsPerAddress;\\n    }\\n\\n    function setMaxTicketsPerAddressAtOnce(\\n        uint _maxTicketsPerAddressAtOnce\\n    ) external onlyOwner {\\n        maxTicketsPerAddressAtOnce = _maxTicketsPerAddressAtOnce;\\n    }\\n\\n    function setDrawInterval(uint256 _drawInterval) external onlyOwner {\\n        drawInterval = _drawInterval;\\n    }\\n\\n    function setHouseFeePercent(uint8 _houseFeePercent) external onlyOwner {\\n        houseFeePercent = _houseFeePercent;\\n    }\\n\\n    function setNumWinners(uint8 _numWinners) external onlyOwner {\\n        numWinners = _numWinners;\\n    }\\n\\n    function setOwnerAddress(address _ownerAddress) external onlyOwner {\\n        ownerAddress = _ownerAddress;\\n    }\\n\\n    function setHouseAddress(address _houseAddress) external onlyOwner {\\n        houseAddress = _houseAddress;\\n    }\\n\\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner {\\n        require(\\n            IERC20(_token).transfer(msg.sender, _amount),\\n            \\\"Transfer failed\\\"\\n        );\\n    }\\n\\n    function withdrawEth(uint256 _amount) external onlyOwner {\\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function withdrawTokenFromGame(\\n        address _game,\\n        address _token,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        LuckyDraw(_game).withdrawToken(_token, msg.sender, _amount);\\n    }\\n\\n    function withdrawEthFromGame(\\n        address _game,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        LuckyDraw(_game).withdrawETH(msg.sender, _amount);\\n    }\\n\\n    function getCurrentGameInfo() external view returns (GameInfos memory) {\\n        GameInfos memory currentGameInfos;\\n        currentGameInfos.gameState = gameState;\\n        currentGameInfos.gameNumber = gamesCounter.current();\\n        currentGameInfos.gameAddress = dailyDrawGames[gamesCounter.current()];\\n        currentGameInfos.ticketPrice = ticketPrice;\\n        currentGameInfos.maxTicketsPerAddress = maxTicketsPerAddress;\\n        currentGameInfos\\n            .maxTicketsPerAddressAtOnce = maxTicketsPerAddressAtOnce;\\n        currentGameInfos.gameStartTimestamp = currentGame.gameStartTimestamp();\\n        currentGameInfos.drawInterval = drawInterval;\\n        currentGameInfos.houseFeePercent = houseFeePercent;\\n        currentGameInfos.numWinners = numWinners;\\n        currentGameInfos.totalTicketsCount = currentGame.getTotalTicketsCount();\\n        return currentGameInfos;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chainlinkVRF\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_chainlinkVRFKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_chainlinkVRFSubscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gameNumber\",\"type\":\"uint256\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gameNumber\",\"type\":\"uint256\"}],\"name\":\"GameOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gameNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"VRFRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gameNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"winningTicket\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prizeVal\",\"type\":\"uint256\"}],\"name\":\"drawWinners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gameNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTickets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketPrice\",\"type\":\"uint256\"}],\"name\":\"ticketBuy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VRFRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTickets\",\"type\":\"uint256\"}],\"name\":\"buyTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkVRF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkVRFKeyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkVRFSubscriptionId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyDrawGames\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drawWinnersRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentGameInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"enum LuckyDrawFactory.GameState\",\"name\":\"gameState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"gameNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gameAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTicketsPerAddress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTicketsPerAddressAtOnce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"drawInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"houseFeePercent\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"numWinners\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalTicketsCount\",\"type\":\"uint256\"}],\"internalType\":\"struct LuckyDrawFactory.GameInfos\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"houseAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_drawInterval\",\"type\":\"uint256\"}],\"name\":\"setDrawInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_houseAddress\",\"type\":\"address\"}],\"name\":\"setHouseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_houseFeePercent\",\"type\":\"uint8\"}],\"name\":\"setHouseFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTicketsPerAddress\",\"type\":\"uint256\"}],\"name\":\"setMaxTicketsPerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTicketsPerAddressAtOnce\",\"type\":\"uint256\"}],\"name\":\"setMaxTicketsPerAddressAtOnce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_numWinners\",\"type\":\"uint8\"}],\"name\":\"setNumWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"setOwnerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_game\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthFromGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_game\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenFromGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LuckyDrawFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c587d9053cd1118f25f645f9e08bb98c9712a4ee17cd473250a9a479dc7f234c64332ed4bc8af9e8ded7556aa6e66d83da49f470000000000000000000000000000000000000000000000000000000000000035c000000000000000000000000f7f73f6697bab84d9d3818fd14720b3b116be87300000000000000000000000000000000000000000000021e19e0c9bab2400000000000000000000000000000a9d3f54595f7ab540f988e1973c33402c997d10b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}