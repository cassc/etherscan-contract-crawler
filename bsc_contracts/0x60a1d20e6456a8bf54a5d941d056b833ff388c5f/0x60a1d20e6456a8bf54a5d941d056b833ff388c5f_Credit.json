{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Credit is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint32 internal dayTimeStemp = 86400;\r\n    uint32 internal monthTimeStemp = 2592000;\r\n    IERC20 public commissionToken;\r\n    uint256 public commissionAmount = 3000 ether;\r\n    IERC20 public creditToken;\r\n    uint8 internal decimals = 18;\r\n    uint256 private latePaymentFee = 30 ether;\r\n    uint256 private earlyRepaymentFee = 30 ether;\r\n    address public stakingAddress;\r\n    uint256 public minAmount = 1000 ether;\r\n\r\n    struct CreditData {\r\n        uint24 loanRate;\r\n        uint24 loanRateDiv;\r\n        uint8 term;\r\n    }\r\n\r\n    struct DepositData {\r\n        uint256 depositRate;\r\n        uint256 depositRateDiv;\r\n        address aggregatorV3Interface;\r\n        uint8 decimals;\r\n        uint32 lastWithdrawDay;\r\n    }\r\n\r\n    struct CreditorData {\r\n        address depositTokenAddress;\r\n        uint256 depositAmount;\r\n        uint32 nextPaymentTimeStemp;\r\n        uint8 term;\r\n        uint256 paidOut;\r\n        uint256 amount;\r\n        uint256 interest;\r\n    }\r\n\r\n    mapping(address => DepositData) public depositTokens;\r\n    mapping(uint8 => CreditData) public creditData;\r\n    mapping(address => CreditorData) internal creditor;\r\n\r\n    mapping(uint32 => mapping(address => uint256)) internal withdrawData;\r\n\r\n    constructor(\r\n        address _stakingAddress\r\n    ) {\r\n        creditToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        commissionToken = IERC20(0xA80D88D15c315a8f40229fed2d01551747B97FD2);\r\n        creditData[1] = CreditData(12, 100, 1);\r\n        creditData[2] = CreditData(12, 100, 2);\r\n        creditData[3] = CreditData(11, 100, 3);\r\n        creditData[6] = CreditData(10, 100, 6);\r\n        depositTokens[address(0)] = DepositData(7, 10, 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE, 18, 19757);\r\n        depositTokens[0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c] = DepositData(7, 10, 0x264990fbd0A4796A3E3d8E37C4d5F87a3aCa5Ebf, 18, 19757);\r\n        depositTokens[0x2170Ed0880ac9A755fd29B2688956BD959F933F8] = DepositData(7, 10, 0x9ef1B8c0E4F7dc8bF5719Ea496883DC6401d5b2e, 18, 19757);\r\n\r\n        stakingAddress = _stakingAddress;\r\n    }\r\n\r\n    function getData() public view returns(CreditorData memory) {\r\n        return creditor[msg.sender];\r\n    }\r\n\r\n    function credit(uint256 _amount, uint8 _term, address _depositToken) public {\r\n        require(_amount >= minAmount, \"Less than the minimum value\");\r\n        if (\r\n            (creditor[msg.sender].paidOut < creditor[msg.sender].amount.add(creditor[msg.sender].interest.mul(creditor[msg.sender].term))) && \r\n            block.timestamp <= (creditor[msg.sender].nextPaymentTimeStemp + (15 * dayTimeStemp))\r\n        ) {\r\n            require(false, \"You already have a loan\");\r\n        }\r\n\r\n        require(_depositToken != address(0), \"To deposit in BNB, you need to call creditBNB()\");\r\n        require(depositTokens[_depositToken].aggregatorV3Interface != address(0), \"This token cannot be pawned\");\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        require(_amount <= creditToken.balanceOf(address(this)), \"There are not enough funds on the contract\");\r\n        require(commissionAmount <= commissionToken.balanceOf(msg.sender), \"Commision is more than the balance\");\r\n        require(creditData[_term].term == _term, \"Term is invalid\");\r\n        require(_term != 0, \"Term is invalid\");\r\n\r\n        uint256 _depositAmount = getDepositAmount(_amount, _depositToken);\r\n\r\n        require(_depositAmount <= IERC20(_depositToken).balanceOf(msg.sender), \"Amount is more than the balance\");\r\n\r\n        creditor[msg.sender] = CreditorData(\r\n            _depositToken,\r\n            _depositAmount,\r\n            uint32(block.timestamp.add(monthTimeStemp)),\r\n            _term,\r\n            0,\r\n            _amount,\r\n            _amount.mul(creditData[_term].loanRate).div(creditData[_term].loanRateDiv).div(12)\r\n        );\r\n\r\n        withdrawData[uint32(block.timestamp.div(dayTimeStemp).add(46))][_depositToken] += _depositAmount;\r\n\r\n        IERC20(_depositToken).transferFrom(msg.sender, address(this), _depositAmount);\r\n        commissionToken.transferFrom(msg.sender, address(this), commissionAmount);\r\n        creditToken.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    function creditBNB(uint256 _amount, uint8 _term, address _depositToken) public payable {\r\n        require(_amount >= minAmount, \"Less than the minimum value\");\r\n        if (\r\n        (creditor[msg.sender].paidOut < creditor[msg.sender].amount.add(creditor[msg.sender].interest.mul(creditor[msg.sender].term))) && \r\n        block.timestamp <= (creditor[msg.sender].nextPaymentTimeStemp + (15 * dayTimeStemp))) {\r\n            require(false, \"You already have a loan\");\r\n        }\r\n\r\n        require(_depositToken == address(0), \"To deposit in ERC20 token, you need to call credit()\");\r\n        require(depositTokens[_depositToken].aggregatorV3Interface != address(0), \"This token cannot be pawned\");\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        require(_amount <= creditToken.balanceOf(address(this)), \"There are not enough funds on the contract\");\r\n        require(commissionAmount <= commissionToken.balanceOf(msg.sender), \"Commision is more than the balance\");\r\n        require(creditData[_term].term == _term, \"Term is invalid\");\r\n        require(_term != 0, \"Term is invalid\");\r\n\r\n        uint256 _depositAmount = getDepositAmount(_amount, _depositToken);\r\n\r\n        if (msg.value<_depositAmount.mul(101).div(100) && msg.value>_depositAmount.mul(99).div(100)) {\r\n            _depositAmount = msg.value;\r\n        }\r\n\r\n        require(msg.value == _depositAmount, \"Error value\");\r\n\r\n        creditor[msg.sender] = CreditorData(\r\n            _depositToken,\r\n            _depositAmount,\r\n            uint32(block.timestamp.add(monthTimeStemp)),\r\n            _term,\r\n            0,\r\n            _amount,\r\n            _amount.mul(creditData[_term].loanRate).div(creditData[_term].loanRateDiv).div(12)\r\n        );\r\n\r\n        withdrawData[uint32(block.timestamp.div(dayTimeStemp).add(46))][_depositToken] += _depositAmount;\r\n\r\n        commissionToken.transferFrom(msg.sender, address(this), commissionAmount);\r\n        creditToken.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    function monthly() public {\r\n        require(creditor[msg.sender].amount.add(creditor[msg.sender].interest.mul(creditor[msg.sender].term)) > creditor[msg.sender].paidOut, \"You do not have a loan\");\r\n        require(block.timestamp <= (creditor[msg.sender].nextPaymentTimeStemp + (15 * dayTimeStemp)), \"The loan is overdue\");\r\n        require(block.timestamp > (creditor[msg.sender].nextPaymentTimeStemp - monthTimeStemp), \"The payment has already been made this month\");\r\n\r\n        uint256 fee = 0;\r\n        if (block.timestamp > creditor[msg.sender].nextPaymentTimeStemp) {\r\n            fee = latePaymentFee;\r\n        }\r\n\r\n        creditToken.transferFrom(\r\n            msg.sender, \r\n            address(this), \r\n            creditor[msg.sender].amount\r\n                .div(creditor[msg.sender].term)\r\n                .add((creditor[msg.sender].interest.add(fee)).div(2))\r\n            );\r\n\r\n        creditToken.transferFrom(\r\n            msg.sender, \r\n            stakingAddress, \r\n            creditor[msg.sender].interest.add(fee).div(2)\r\n        );\r\n\r\n        creditor[msg.sender].paidOut += creditor[msg.sender].amount.div(creditor[msg.sender].term).add(creditor[msg.sender].interest);\r\n\r\n        withdrawData\r\n            [uint32(uint256(creditor[msg.sender].nextPaymentTimeStemp).div(dayTimeStemp).add(16))]\r\n            [creditor[msg.sender].depositTokenAddress] -= creditor[msg.sender].depositAmount;\r\n\r\n        if (creditor[msg.sender].paidOut < creditor[msg.sender].amount.add(creditor[msg.sender].interest.mul(creditor[msg.sender].term))) {\r\n            withdrawData\r\n                [uint32(uint256(creditor[msg.sender].nextPaymentTimeStemp).div(dayTimeStemp).add(46))]\r\n                [creditor[msg.sender].depositTokenAddress] += creditor[msg.sender].depositAmount;\r\n            creditor[msg.sender].nextPaymentTimeStemp += monthTimeStemp;\r\n        } else {\r\n            if (creditor[msg.sender].depositTokenAddress != address(0)) {\r\n                IERC20(creditor[msg.sender].depositTokenAddress).transfer(msg.sender, creditor[msg.sender].depositAmount);\r\n            } else {\r\n                (bool success, ) = msg.sender.call{value: creditor[msg.sender].depositAmount}(\"\");\r\n                require(success, \"Failed to send Ether\");\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function earlyRepayment() public {\r\n        require(creditor[msg.sender].amount.add(creditor[msg.sender].interest.mul(creditor[msg.sender].term)) > creditor[msg.sender].paidOut, \"You do not have a loan\");\r\n        require(block.timestamp <= (creditor[msg.sender].nextPaymentTimeStemp + (15 * dayTimeStemp)), \"The loan is overdue\");\r\n\r\n        uint8 monthsLeft = creditor[msg.sender].term - uint8(creditor[msg.sender].paidOut.div(creditor[msg.sender].amount.div(creditor[msg.sender].term).add(creditor[msg.sender].interest)));\r\n        uint256 amount = creditor[msg.sender].amount.mul(monthsLeft).div(creditor[msg.sender].term);\r\n\r\n        uint256 fee = 0;\r\n\r\n        if (monthsLeft>1||(monthsLeft==1&&block.timestamp<creditor[msg.sender].nextPaymentTimeStemp-(30 *dayTimeStemp))) {\r\n            fee = earlyRepaymentFee;\r\n        }\r\n        if (block.timestamp > creditor[msg.sender].nextPaymentTimeStemp) {\r\n            fee += latePaymentFee;\r\n        }\r\n\r\n        creditToken.transferFrom(\r\n            msg.sender, \r\n            address(this), \r\n            amount\r\n                .add((creditor[msg.sender].interest.add(fee)).div(2))\r\n        );\r\n        \r\n        creditToken.transferFrom(\r\n            msg.sender, \r\n            stakingAddress, \r\n            creditor[msg.sender].interest.add(fee).div(2)\r\n        );\r\n\r\n        withdrawData\r\n            [uint32(uint256(creditor[msg.sender].nextPaymentTimeStemp).div(dayTimeStemp).add(16))]\r\n            [creditor[msg.sender].depositTokenAddress] -= creditor[msg.sender].depositAmount;\r\n\r\n        creditor[msg.sender].paidOut = creditor[msg.sender].amount.add(creditor[msg.sender].interest.mul(creditor[msg.sender].term));\r\n\r\n        if (creditor[msg.sender].depositTokenAddress != address(0)) {\r\n            IERC20(creditor[msg.sender].depositTokenAddress).transfer(msg.sender, creditor[msg.sender].depositAmount);\r\n        } else {\r\n            (bool success, ) = msg.sender.call{value: creditor[msg.sender].depositAmount}(\"\");\r\n            require(success, \"Failed to send Ether\");\r\n        }\r\n    }\r\n\r\n    function getDepositAmount(uint256 _amount, address _depositToken) public view returns(uint256) {\r\n        if (depositTokens[_depositToken].decimals <= decimals) {\r\n            return _amount\r\n                .mul(depositTokens[_depositToken].depositRateDiv)\r\n                .mul(10**AggregatorV3Interface(depositTokens[_depositToken].aggregatorV3Interface).decimals())\r\n                .div(depositTokens[_depositToken].depositRate)\r\n                .div(uint256(AggregatorV3Interface(depositTokens[_depositToken].aggregatorV3Interface).latestAnswer()))\r\n                .div(10**(decimals - depositTokens[_depositToken].decimals));\r\n        } else {\r\n            return _amount\r\n                .mul(depositTokens[_depositToken].depositRateDiv)\r\n                .mul(10**AggregatorV3Interface(depositTokens[_depositToken].aggregatorV3Interface).decimals())\r\n                .div(depositTokens[_depositToken].depositRate)\r\n                .div(10**(depositTokens[_depositToken].decimals - decimals))\r\n                .div(uint256(AggregatorV3Interface(depositTokens[_depositToken].aggregatorV3Interface).latestAnswer()));\r\n        }\r\n    }\r\n\r\n\r\n    // owner\r\n\r\n    function withdraw(address _depositToken, uint256 _amount) public onlyOwner {\r\n        if (_depositToken == address(commissionToken)) {\r\n            commissionToken.transfer(msg.sender, commissionToken.balanceOf(address(this)));\r\n        } else if (_depositToken == address(creditToken)) {\r\n            creditToken.transfer(msg.sender, _amount);\r\n        } else {\r\n\r\n            (uint256 amount, uint256 _newLastDay) = getWithdrawAmount(_depositToken);\r\n\r\n            if (amount > 0) {\r\n                if (_depositToken == address(0)) {\r\n                    (bool success, ) = msg.sender.call{value: amount}(\"\");\r\n                    require(success, \"Failed to send Ether\");\r\n                } else {\r\n                    require(amount <= IERC20(_depositToken).balanceOf(address(this)), \"Amount is more than the balance\");\r\n                    IERC20(_depositToken).transfer(msg.sender, amount);\r\n                }\r\n            }\r\n            depositTokens[_depositToken].lastWithdrawDay = uint32(_newLastDay.add(1));\r\n        }\r\n    }\r\n\r\n    function getWithdrawAmount(address _depositToken) public view onlyOwner returns(uint256, uint256) {\r\n        uint256 _amount;\r\n        uint256 _newLastDay = block.timestamp.div(dayTimeStemp);\r\n        for (uint32 _i = depositTokens[_depositToken].lastWithdrawDay; _i <= _newLastDay; _i++) {\r\n            _amount += withdrawData[_i][_depositToken];\r\n        }\r\n        return (_amount, _newLastDay);\r\n    }\r\n\r\n    function setCommissionAmount(uint256 _commissionAmount) public onlyOwner {\r\n        commissionAmount = _commissionAmount;\r\n    }\r\n\r\n    function setDepositTokens(\r\n        address _tokenAddress, \r\n        uint256 _depositRate, \r\n        uint256 _depositRateDiv, \r\n        address _aggregatorV3Interface, \r\n        uint8 _decimals\r\n    ) public onlyOwner {\r\n        depositTokens[_tokenAddress] = DepositData(\r\n            _depositRate,\r\n            _depositRateDiv,\r\n            _aggregatorV3Interface,\r\n            _decimals,\r\n            depositTokens[_tokenAddress].lastWithdrawDay\r\n        );\r\n    }\r\n\r\n    function setCreditData(uint8 _termId, uint24 _loanRate, uint24 _loanRateDiv, uint8 _term) public onlyOwner {\r\n        creditData[_termId] = CreditData(\r\n            _loanRate,\r\n            _loanRateDiv,\r\n            _term\r\n        );\r\n    }\r\n\r\n    function setStakingAddress(address _stakingAddress) public onlyOwner {\r\n        stakingAddress = _stakingAddress;\r\n    }\r\n\r\n    function setMinAmount(uint256 _minAmount) public onlyOwner {\r\n        minAmount = _minAmount;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"commissionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_term\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"}],\"name\":\"credit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_term\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"}],\"name\":\"creditBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"creditData\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"loanRate\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"loanRateDiv\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"term\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creditToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositRateDiv\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"aggregatorV3Interface\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"lastWithdrawDay\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyRepayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"depositTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nextPaymentTimeStemp\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"term\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"paidOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"}],\"internalType\":\"struct Credit.CreditorData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"}],\"name\":\"getDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"}],\"name\":\"getWithdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commissionAmount\",\"type\":\"uint256\"}],\"name\":\"setCommissionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_termId\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"_loanRate\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"_loanRateDiv\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"_term\",\"type\":\"uint8\"}],\"name\":\"setCreditData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositRateDiv\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_aggregatorV3Interface\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"setDepositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"}],\"name\":\"setMinAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingAddress\",\"type\":\"address\"}],\"name\":\"setStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Credit", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000372002babfff2124dc323a95b201e5552db1f3ba", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://869ef4ab07e645a36b8dd3ac9149e204889d0c13818d07ba062b4c1489c3045a"}