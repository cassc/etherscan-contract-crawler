{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface Verifier{\r\n    function verifyProof(\r\n            uint[2] memory a,\r\n            uint[2][2] memory b,\r\n            uint[2] memory c,\r\n            uint[2] memory input\r\n        ) external view returns (bool r);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor (){\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Privacy is ReentrancyGuard {\r\n\r\n    struct CommitFeatures {\r\n        //uint id;\r\n        bool status;\r\n        uint balance;\r\n    }\r\n\r\n    struct NulliFeatures {\r\n        bool status;\r\n        bool used;\r\n        uint balance;\r\n    }\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping(bytes32 => CommitFeatures) public depositCommitments;\r\n    mapping(bytes32 => NulliFeatures) private nullif_;\r\n\r\n    uint public totalDeposit = 0;\r\n\r\n    Verifier public verify;\r\n    address relayer;\r\n\r\n    uint public protocolFee = 5;\r\n\r\n    address protocol = msg.sender;\r\n\r\n    constructor(Verifier _verifier, address _relayer){\r\n        verify = (_verifier);\r\n        relayer = _relayer;\r\n    }\r\n\r\n    //allow contract to recieve ether from EOA or other contract\r\n    receive () payable external {}\r\n    \r\n    function changeProtocolAddy(address addy) external onlyOwner{\r\n        protocol = addy;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == protocol, \"Ownable: caller is not the Admin\");\r\n        _;\r\n    }\r\n\r\n    function setProtocolFee(uint newFee) external onlyOwner{\r\n        require(newFee <= 5, \"Fee cannot be more than 5%\");\r\n        protocolFee = newFee;\r\n    }\r\n\r\n    function setRelayerAddress(address newAddress) external onlyOwner{\r\n        relayer = newAddress;\r\n    }\r\n\r\n    function deposit(bytes32 _commitment, bytes32 _nullif) payable external nonReentrant{\r\n        require(!depositCommitments[_commitment].status, \"This Commitment is already used\");\r\n        require(!nullif_[_nullif].status, \"This Nullifier is already used\");\r\n        uint depositing = msg.value;\r\n        require(depositing > 0, \"You cannot make empty deposit\");\r\n        \r\n        depositCommitments[_commitment].status = true;\r\n        depositCommitments[_commitment].balance = depositing;\r\n\r\n        nullif_[_nullif].status = true;\r\n        nullif_[_nullif].balance = depositing;\r\n\r\n        totalDeposit += 1;\r\n    }\r\n\r\n    function withdraw(  \r\n                        bytes32 _nullif,\r\n                        address _receiver,\r\n                        uint[2] memory a,\r\n                        uint[2][2] memory b,\r\n                        uint[2] memory c,\r\n                        uint[2] memory input\r\n                                            ) external nonReentrant{\r\n\r\n        bytes32 nullifierHash32 = keccak256(abi.encodePacked(bytes32(input[0])));\r\n        bytes32 nullifierHashKecClient = keccak256(abi.encodePacked(_nullif));\r\n\r\n        bool used = nullif_[nullifierHash32].used;\r\n        require(!used, \"Nullifier Hash already used\");        \r\n\r\n        require(nullifierHash32 == nullifierHashKecClient, \"Nullifier Hash does not Match\");\r\n\r\n        bool status = nullif_[nullifierHash32].status;\r\n        require(status, \"Nullifier Hash Does not exist\");\r\n\r\n        address recipient = address(uint160(input[1])); //for receiver\r\n        require(recipient == _receiver, \"Receiver Address does not match\");\r\n\r\n        uint balance = nullif_[nullifierHash32].balance;\r\n\r\n        require(!nullif_[nullifierHash32].used, \"nullifier already used\"); \r\n        nullif_[nullifierHash32].used = true;//now used.\r\n\r\n        require(verify.verifyProof(a, b, c, input), \"Invalid Proof.\");\r\n\r\n        uint relayerFees = balance.mul(protocolFee).div(100);\r\n        \r\n        uint amountToReceiver = balance.sub(relayerFees);\r\n\r\n        (bool success, ) = recipient.call{value: amountToReceiver}(\"\");\r\n        require(success, \"Withdraw Error. Unable to withdraw to receiver\");\r\n\r\n        (bool success2, ) = relayer.call{value: relayerFees}(\"\");\r\n        require(success2, \"Withdraw Error. Unable to withdraw to relayer\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract Verifier\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"changeProtocolAddy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_nullif\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"depositCommitments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setRelayerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"contract Verifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nullif\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"input\",\"type\":\"uint256[2]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Privacy", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009cc5f56dcdc05b8521bea7913f9e6ce6003a1f1b0000000000000000000000009ac020d099c1c4e2dae9726009d56bc365cff78e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f50dac40b630327867d32ef90cdaa0304ece0e16e670f6a124b28675d1765401"}