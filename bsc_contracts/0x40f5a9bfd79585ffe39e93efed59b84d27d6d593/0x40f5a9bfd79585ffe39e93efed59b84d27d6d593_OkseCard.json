{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OkseCard.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: LICENSED\\r\\n\\r\\n// Solidity files have to start with this pragma.\\r\\n// It will be used by the Solidity compiler to validate its version.\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n// We import this library to be able to use console.log\\r\\n// import \\\"hardhat/console.sol\\\";\\r\\nimport \\\"./libraries/TransferHelper.sol\\\";\\r\\nimport \\\"./interfaces/PriceOracle.sol\\\";\\r\\nimport \\\"./interfaces/ILimitManager.sol\\\";\\r\\nimport \\\"./interfaces/ILevelManager.sol\\\";\\r\\nimport \\\"./interfaces/IMarketManager.sol\\\";\\r\\nimport \\\"./interfaces/ICashBackManager.sol\\\";\\r\\nimport \\\"./interfaces/IWETH9.sol\\\";\\r\\nimport \\\"./interfaces/ISwapper.sol\\\";\\r\\nimport \\\"./interfaces/ERC20Interface.sol\\\";\\r\\nimport \\\"./interfaces/IConverter.sol\\\";\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\n\\r\\nimport \\\"./OwnerConstants.sol\\\";\\r\\nimport \\\"./SignerRole.sol\\\";\\r\\n\\r\\n// This is the main building block for smart contracts.\\r\\ncontract OkseCard is OwnerConstants, SignerRole {\\r\\n    //  bytes4 public constant PAY_MONTHLY_FEE = bytes4(keccak256(bytes('payMonthlyFee')));\\r\\n    bytes4 public constant PAY_MONTHLY_FEE = 0x529a8d6c;\\r\\n    //  bytes4 public constant WITHDRAW = bytes4(keccak256(bytes('withdraw')));\\r\\n    bytes4 public constant WITHDRAW = 0x855511cc;\\r\\n    //  bytes4 public constant BUYGOODS = bytes4(keccak256(bytes('buyGoods')));\\r\\n    bytes4 public constant BUYGOODS = 0xa8fd19f2;\\r\\n    //  bytes4 public constant SET_USER_MAIN_MARKET = bytes4(keccak256(bytes('setUserMainMarket')));\\r\\n    bytes4 public constant SET_USER_MAIN_MARKET = 0x4a22142e;\\r\\n\\r\\n    // uint256 public constant CARD_VALIDATION_TIME = 10 minutes; // 30 days in prodcution\\r\\n    uint256 public constant CARD_VALIDATION_TIME = 30 days; // 30 days in prodcution\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    address public immutable converter;\\r\\n    address public swapper;\\r\\n\\r\\n    // Price oracle address, which is used for verification of swapping assets amount\\r\\n    address public priceOracle;\\r\\n    address public limitManager;\\r\\n    address public levelManager;\\r\\n    address public marketManager;\\r\\n    address public cashbackManager;\\r\\n\\r\\n    // Governor can set followings:\\r\\n    address public governorAddress; // Governance address\\r\\n\\r\\n    /*** Main Actions ***/\\r\\n    // user's deposited balance.\\r\\n    // user  => ( market => balances)\\r\\n    mapping(address => mapping(address => uint256)) public usersBalances;\\r\\n\\r\\n    mapping(address => uint256) public userValidTimes;\\r\\n\\r\\n    //prevent reentrancy attack\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n    uint256 private _status;\\r\\n    bool private initialized;\\r\\n\\r\\n    // uint256 public timeDiff;\\r\\n    struct SignKeys {\\r\\n        uint8 v;\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n    }\\r\\n    struct SignData {\\r\\n        bytes4 method;\\r\\n        uint256 id;\\r\\n        address market;\\r\\n        address userAddr;\\r\\n        uint256 amount;\\r\\n        uint256 validTime;\\r\\n    }\\r\\n    // emit event\\r\\n\\r\\n    event UserBalanceChanged(\\r\\n        address indexed userAddr,\\r\\n        address indexed market,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event GovernorAddressChanged(\\r\\n        address indexed previousGovernor,\\r\\n        address indexed newGovernor\\r\\n    );\\r\\n    event MonthlyFeePaid(\\r\\n        uint256 id,\\r\\n        address userAddr,\\r\\n        uint256 userValidTime,\\r\\n        uint256 usdAmount\\r\\n    );\\r\\n    event UserDeposit(address userAddr, address market, uint256 amount);\\r\\n    event UserWithdraw(\\r\\n        uint256 id,\\r\\n        address userAddr,\\r\\n        address market,\\r\\n        uint256 amount,\\r\\n        uint256 remainedBalance\\r\\n    );\\r\\n    event SignerBuyGoods(\\r\\n        uint256 id,\\r\\n        address signer1,\\r\\n        address signer2,\\r\\n        address market,\\r\\n        address userAddr,\\r\\n        uint256 usdAmount\\r\\n    );\\r\\n    event UserMainMarketChanged(\\r\\n        uint256 id,\\r\\n        address userAddr,\\r\\n        address market,\\r\\n        address beforeMarket\\r\\n    );\\r\\n    event ContractAddressChanged(\\r\\n        address priceOracle,\\r\\n        address swapper,\\r\\n        address limitManager,\\r\\n        address levelManager,\\r\\n        address marketManager,\\r\\n        address cashbackManager\\r\\n    );\\r\\n    event WithdrawTokens(address token, address to, uint256 amount);\\r\\n\\r\\n    // verified\\r\\n    /**\\r\\n     * Contract initialization.\\r\\n     *\\r\\n     * The `constructor` is executed only once when the contract is created.\\r\\n     * The `public` modifier makes a function callable from outside the contract.\\r\\n     */\\r\\n    constructor(address _converter, address _initialSigner)\\r\\n        SignerRole(_initialSigner)\\r\\n    {\\r\\n        converter = _converter;\\r\\n        // The totalSupply is assigned to transaction sender, which is the account\\r\\n        // that is deploying the contract.\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    receive() external payable {\\r\\n        // require(msg.sender == WETH, 'Not WETH9');\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function initialize(\\r\\n        address _priceOracle,\\r\\n        address _limitManager,\\r\\n        address _levelManager,\\r\\n        address _marketManager,\\r\\n        address _cashbackManager,\\r\\n        address _financialAddress,\\r\\n        address _masterAddress,\\r\\n        address _treasuryAddress,\\r\\n        address _governorAddress,\\r\\n        address _monthlyFeeAddress,\\r\\n        address _stakeContractAddress,\\r\\n        address _swapper\\r\\n    ) public {\\r\\n        require(!initialized, \\\"ai\\\");\\r\\n        // owner = _owner;\\r\\n        // _addSigner(_owner);\\r\\n        priceOracle = _priceOracle;\\r\\n        limitManager = _limitManager;\\r\\n        levelManager = _levelManager;\\r\\n        marketManager = _marketManager;\\r\\n        cashbackManager = _cashbackManager;\\r\\n        treasuryAddress = _treasuryAddress;\\r\\n        financialAddress = _financialAddress;\\r\\n        masterAddress = _masterAddress;\\r\\n        governorAddress = _governorAddress;\\r\\n        monthlyFeeAddress = _monthlyFeeAddress;\\r\\n        stakeContractAddress = _stakeContractAddress;\\r\\n        swapper = _swapper;\\r\\n        //private variables initialize.\\r\\n        _status = _NOT_ENTERED;\\r\\n        //initialize OwnerConstants arrays\\r\\n\\r\\n        stakePercent = 15 * (100 + 15);\\r\\n        buyFeePercent = 250;\\r\\n        buyTxFee = 0.7 ether;\\r\\n        withdrawFeePercent = 0;\\r\\n        monthlyFeeAmount = 6.99 ether;\\r\\n        okseMonthlyProfit = 1000;\\r\\n        initialized = true;\\r\\n    }\\r\\n\\r\\n    /// modifier functions\\r\\n    // verified\\r\\n    modifier onlyGovernor() {\\r\\n        require(_msgSender() == governorAddress, \\\"og\\\");\\r\\n        _;\\r\\n    }\\r\\n    // // verified\\r\\n    modifier marketEnabled(address market) {\\r\\n        require(IMarketManager(marketManager).marketEnable(market), \\\"mdnd\\\");\\r\\n        _;\\r\\n    }\\r\\n    // verified\\r\\n    modifier noExpired(address userAddr) {\\r\\n        require(!getUserExpired(userAddr), \\\"user expired\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    // verified\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"rc\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    modifier validSignOfUser(\\r\\n        SignData calldata sign_data,\\r\\n        SignKeys calldata sign_key\\r\\n    ) {\\r\\n        require(\\r\\n            sign_data.userAddr == getecrecover(sign_data, sign_key),\\r\\n            \\\"ssst\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n    modifier noEmergency() {\\r\\n        require(!IMarketManager(marketManager).emergencyStop(), \\\"stopped\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getUserOkseBalance(address userAddr)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return usersBalances[userAddr][IMarketManager(marketManager).OKSE()];\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function getUserExpired(address _userAddr) public view returns (bool) {\\r\\n        if (userValidTimes[_userAddr].add(25 days) > block.timestamp) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // set Governance address\\r\\n    function setGovernor(address newGovernor) public onlyGovernor {\\r\\n        address oldGovernor = governorAddress;\\r\\n        governorAddress = newGovernor;\\r\\n        emit GovernorAddressChanged(oldGovernor, newGovernor);\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function updateSigner(address _signer, bool bAddOrRemove)\\r\\n        public\\r\\n        onlyGovernor\\r\\n    {\\r\\n        if (bAddOrRemove) {\\r\\n            _addSigner(_signer);\\r\\n        } else {\\r\\n            _removeSigner(_signer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    function onUpdateUserBalance(\\r\\n        address userAddr,\\r\\n        address market,\\r\\n        uint256 amount,\\r\\n        uint256 beforeAmount\\r\\n    ) internal returns (bool) {\\r\\n        emit UserBalanceChanged(userAddr, market, amount);\\r\\n        if (market != IMarketManager(marketManager).OKSE()) return true;\\r\\n        return\\r\\n            ILevelManager(levelManager).updateUserLevel(userAddr, beforeAmount);\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    // newly verified\\r\\n    function deposit(address market, uint256 amount)\\r\\n        public\\r\\n        marketEnabled(market)\\r\\n        nonReentrant\\r\\n        noEmergency\\r\\n    {\\r\\n        TransferHelper.safeTransferFrom(\\r\\n            market,\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amount\\r\\n        );\\r\\n        _addUserBalance(market, msg.sender, amount);\\r\\n        emit UserDeposit(msg.sender, market, amount);\\r\\n    }\\r\\n\\r\\n    // newly verified\\r\\n    function depositETH() public payable nonReentrant {\\r\\n        address WETH = IMarketManager(marketManager).WETH();\\r\\n        require(IMarketManager(marketManager).marketEnable(WETH), \\\"me\\\");\\r\\n        IWETH9(WETH).deposit{value: msg.value}();\\r\\n        _addUserBalance(WETH, msg.sender, msg.value);\\r\\n        emit UserDeposit(msg.sender, WETH, msg.value);\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function _addUserBalance(\\r\\n        address market,\\r\\n        address userAddr,\\r\\n        uint256 amount\\r\\n    ) internal marketEnabled(market) {\\r\\n        uint256 beforeAmount = usersBalances[userAddr][market];\\r\\n        usersBalances[userAddr][market] = usersBalances[userAddr][market].add(\\r\\n            amount\\r\\n        );\\r\\n        onUpdateUserBalance(\\r\\n            userAddr,\\r\\n            market,\\r\\n            usersBalances[userAddr][market],\\r\\n            beforeAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // newly verified\\r\\n    function setUserMainMarket(\\r\\n        uint256 id,\\r\\n        address market,\\r\\n        uint256 validTime,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public {\\r\\n        address userAddr = msg.sender;\\r\\n        uint256 chainId;\\r\\n        assembly {\\r\\n            chainId := chainid()\\r\\n        }\\r\\n        require(\\r\\n            isSigner(\\r\\n                ecrecover(\\r\\n                    toEthSignedMessageHash(\\r\\n                        keccak256(\\r\\n                            abi.encodePacked(\\r\\n                                this,\\r\\n                                SET_USER_MAIN_MARKET,\\r\\n                                id,\\r\\n                                userAddr,\\r\\n                                market,\\r\\n                                chainId,\\r\\n                                uint256(0),\\r\\n                                validTime\\r\\n                            )\\r\\n                        )\\r\\n                    ),\\r\\n                    v,\\r\\n                    r,\\r\\n                    s\\r\\n                )\\r\\n            ),\\r\\n            \\\"summ\\\"\\r\\n        );\\r\\n        require(signatureId[id] == false, \\\"pru\\\");\\r\\n        signatureId[id] = true;\\r\\n        require(validTime > block.timestamp, \\\"expired\\\");\\r\\n        address beforeMarket = IMarketManager(marketManager).getUserMainMarket(\\r\\n            userAddr\\r\\n        );\\r\\n        IMarketManager(marketManager).setUserMainMakret(userAddr, market);\\r\\n        emit UserMainMarketChanged(id, userAddr, market, beforeMarket);\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function payMonthlyFee(\\r\\n        uint256 id,\\r\\n        SignData calldata _data,\\r\\n        SignKeys calldata user_key,\\r\\n        address market\\r\\n    )\\r\\n        public\\r\\n        nonReentrant\\r\\n        marketEnabled(market)\\r\\n        noEmergency\\r\\n        validSignOfUser(_data, user_key)\\r\\n        onlySigner\\r\\n    {\\r\\n        address userAddr = _data.userAddr;\\r\\n        require(userValidTimes[userAddr] <= block.timestamp, \\\"e\\\");\\r\\n        require(monthlyFeeAmount <= _data.amount, \\\"over paid\\\");\\r\\n        require(\\r\\n            signatureId[id] == false && _data.method == PAY_MONTHLY_FEE,\\r\\n            \\\"pru\\\"\\r\\n        );\\r\\n        signatureId[id] = true;\\r\\n        // increase valid period\\r\\n\\r\\n        // extend user's valid time\\r\\n        uint256 _monthlyFee = getMonthlyFeeAmount(\\r\\n            market == IMarketManager(marketManager).OKSE()\\r\\n        );\\r\\n        uint256 _tempVal = _monthlyFee;\\r\\n        userValidTimes[userAddr] = block.timestamp.add(CARD_VALIDATION_TIME);\\r\\n\\r\\n        if (stakeContractAddress != address(0)) {\\r\\n            _tempVal = (_monthlyFee.mul(10000)).div(stakePercent.add(10000));\\r\\n        }\\r\\n\\r\\n        uint256 beforeAmount = usersBalances[userAddr][market];\\r\\n        calculateAmount(\\r\\n            market,\\r\\n            userAddr,\\r\\n            _tempVal,\\r\\n            monthlyFeeAddress,\\r\\n            stakeContractAddress,\\r\\n            stakePercent\\r\\n        );\\r\\n        onUpdateUserBalance(\\r\\n            userAddr,\\r\\n            market,\\r\\n            usersBalances[userAddr][market],\\r\\n            beforeAmount\\r\\n        );\\r\\n        emit MonthlyFeePaid(\\r\\n            id,\\r\\n            userAddr,\\r\\n            userValidTimes[userAddr],\\r\\n            _monthlyFee\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // newly verified\\r\\n    function withdraw(\\r\\n        uint256 id,\\r\\n        address market,\\r\\n        uint256 amount,\\r\\n        uint256 validTime,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public nonReentrant {\\r\\n        address userAddr = msg.sender;\\r\\n        uint256 chainId;\\r\\n        assembly {\\r\\n            chainId := chainid()\\r\\n        }\\r\\n        require(\\r\\n            isSigner(\\r\\n                ecrecover(\\r\\n                    toEthSignedMessageHash(\\r\\n                        keccak256(\\r\\n                            abi.encodePacked(\\r\\n                                this,\\r\\n                                WITHDRAW,\\r\\n                                id,\\r\\n                                userAddr,\\r\\n                                market,\\r\\n                                chainId,\\r\\n                                amount,\\r\\n                                validTime\\r\\n                            )\\r\\n                        )\\r\\n                    ),\\r\\n                    v,\\r\\n                    r,\\r\\n                    s\\r\\n                )\\r\\n            ),\\r\\n            \\\"ssst\\\"\\r\\n        );\\r\\n        require(signatureId[id] == false, \\\"pru\\\");\\r\\n        signatureId[id] = true;\\r\\n        require(validTime > block.timestamp, \\\"expired\\\");\\r\\n        uint256 beforeAmount = usersBalances[userAddr][market];\\r\\n        // require(beforeAmount >= amount, \\\"ib\\\");\\r\\n        usersBalances[userAddr][market] = beforeAmount.sub(amount);\\r\\n        address WETH = IMarketManager(marketManager).WETH();\\r\\n        if (market == WETH) {\\r\\n            IWETH9(WETH).withdraw(amount);\\r\\n            if (treasuryAddress != address(0)) {\\r\\n                uint256 feeAmount = (amount.mul(withdrawFeePercent)).div(10000);\\r\\n                if (feeAmount > 0) {\\r\\n                    TransferHelper.safeTransferETH(treasuryAddress, feeAmount);\\r\\n                }\\r\\n                TransferHelper.safeTransferETH(\\r\\n                    msg.sender,\\r\\n                    amount.sub(feeAmount)\\r\\n                );\\r\\n            } else {\\r\\n                TransferHelper.safeTransferETH(msg.sender, amount);\\r\\n            }\\r\\n        } else {\\r\\n            if (treasuryAddress != address(0)) {\\r\\n                uint256 feeAmount = (amount.mul(withdrawFeePercent)).div(10000);\\r\\n                if (feeAmount > 0) {\\r\\n                    TransferHelper.safeTransfer(\\r\\n                        market,\\r\\n                        treasuryAddress,\\r\\n                        feeAmount\\r\\n                    );\\r\\n                }\\r\\n                TransferHelper.safeTransfer(\\r\\n                    market,\\r\\n                    msg.sender,\\r\\n                    amount.sub(feeAmount)\\r\\n                );\\r\\n            } else {\\r\\n                TransferHelper.safeTransfer(market, msg.sender, amount);\\r\\n            }\\r\\n        }\\r\\n        uint256 userBal = usersBalances[userAddr][market];\\r\\n        onUpdateUserBalance(userAddr, market, userBal, beforeAmount);\\r\\n        emit UserWithdraw(id, userAddr, market, amount, userBal);\\r\\n    }\\r\\n\\r\\n    // decimal of usdAmount is 18\\r\\n    // newly verified\\r\\n    function buyGoods(SignData calldata _data, SignKeys[2] calldata signer_key)\\r\\n        external\\r\\n        nonReentrant\\r\\n        marketEnabled(_data.market)\\r\\n        noExpired(_data.userAddr)\\r\\n        noEmergency\\r\\n    {\\r\\n        address[2] memory signers = [\\r\\n            getecrecover(_data, signer_key[0]),\\r\\n            getecrecover(_data, signer_key[1])\\r\\n        ];\\r\\n        require(\\r\\n            isSigner(signers[0]) &&\\r\\n                isSigner(signers[1]) &&\\r\\n                (signers[0] != signers[1]),\\r\\n            \\\"is\\\"\\r\\n        );\\r\\n        require(\\r\\n            signatureId[_data.id] == false && _data.method == BUYGOODS,\\r\\n            \\\"pru\\\"\\r\\n        );\\r\\n        signatureId[_data.id] = true;\\r\\n        if (_data.market == IMarketManager(marketManager).OKSE()) {\\r\\n            require(IMarketManager(marketManager).oksePaymentEnable(), \\\"jsy\\\");\\r\\n        }\\r\\n        require(\\r\\n            IMarketManager(marketManager).getUserMainMarket(_data.userAddr) ==\\r\\n                _data.market,\\r\\n            \\\"jsy2\\\"\\r\\n        );\\r\\n        uint256 spendAmount = _makePayment(\\r\\n            _data.market,\\r\\n            _data.userAddr,\\r\\n            _data.amount\\r\\n        );\\r\\n        cashBack(_data.userAddr, spendAmount);\\r\\n        emit SignerBuyGoods(\\r\\n            _data.id,\\r\\n            signers[0],\\r\\n            signers[1],\\r\\n            _data.market,\\r\\n            _data.userAddr,\\r\\n            _data.amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // deduce user assets using usd amount\\r\\n    // decimal of usdAmount is 18\\r\\n    // verified\\r\\n    function _makePayment(\\r\\n        address market,\\r\\n        address userAddr,\\r\\n        uint256 usdAmount\\r\\n    ) internal returns (uint256 spendAmount) {\\r\\n        uint256 beforeAmount = usersBalances[userAddr][market];\\r\\n        spendAmount = calculateAmount(\\r\\n            market,\\r\\n            userAddr,\\r\\n            usdAmount,\\r\\n            masterAddress,\\r\\n            treasuryAddress,\\r\\n            buyFeePercent\\r\\n        );\\r\\n        ILimitManager(limitManager).updateUserSpendAmount(userAddr, usdAmount);\\r\\n\\r\\n        onUpdateUserBalance(\\r\\n            userAddr,\\r\\n            market,\\r\\n            usersBalances[userAddr][market],\\r\\n            beforeAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // calculate aseet amount from market and required usd amount\\r\\n    // decimal of usdAmount is 18\\r\\n    // spendAmount is decimal 18\\r\\n    function calculateAmount(\\r\\n        address market,\\r\\n        address userAddr,\\r\\n        uint256 usdAmount,\\r\\n        address targetAddress,\\r\\n        address feeAddress,\\r\\n        uint256 feePercent\\r\\n    ) internal returns (uint256 spendAmount) {\\r\\n        uint256 _amount;\\r\\n        address USDC = IMarketManager(marketManager).USDC();\\r\\n        if (feeAddress != address(0)) {\\r\\n            _amount = usdAmount.add((usdAmount.mul(feePercent)).div(10000)).add(\\r\\n                    buyTxFee\\r\\n                );\\r\\n        } else {\\r\\n            _amount = usdAmount;\\r\\n        }\\r\\n        // change _amount to USDC asset amounts\\r\\n        uint256 assetAmountIn = IConverter(converter).getAssetAmount(\\r\\n            market,\\r\\n            _amount,\\r\\n            priceOracle\\r\\n        );\\r\\n        assetAmountIn = assetAmountIn.add(\\r\\n            (assetAmountIn.mul(IMarketManager(marketManager).slippage())).div(10000)\\r\\n        );\\r\\n        _amount = IConverter(converter).convertUsdAmountToAssetAmount(\\r\\n            _amount,\\r\\n            USDC\\r\\n        );\\r\\n        uint256 userBal = usersBalances[userAddr][market];\\r\\n        if (market != USDC) {\\r\\n            // we need to change somehting here, because if there are not pair {market, USDC} , then we have to add another path\\r\\n            // so please check the path is exist and if no, please add market, weth, usdc to path\\r\\n            address[] memory path = ISwapper(swapper).getOptimumPath(\\r\\n                market,\\r\\n                USDC\\r\\n            );\\r\\n            uint256[] memory amounts = ISwapper(swapper).getAmountsIn(\\r\\n                _amount,\\r\\n                path\\r\\n            );\\r\\n\\r\\n            require(amounts[0] < assetAmountIn, \\\"ua\\\");\\r\\n            usersBalances[userAddr][market] = userBal.sub(amounts[0]);\\r\\n            TransferHelper.safeTransfer(\\r\\n                path[0],\\r\\n                ISwapper(swapper).GetReceiverAddress(path),\\r\\n                amounts[0]\\r\\n            );\\r\\n            ISwapper(swapper)._swap(amounts, path, address(this));\\r\\n        } else {\\r\\n            // require(_amount <= usersBalances[userAddr][market], \\\"uat\\\");\\r\\n            require(_amount < assetAmountIn, \\\"au\\\");\\r\\n            usersBalances[userAddr][market] = userBal.sub(_amount);\\r\\n        }\\r\\n        require(targetAddress != address(0), \\\"mis\\\");\\r\\n        uint256 usdcAmount = IConverter(converter)\\r\\n            .convertUsdAmountToAssetAmount(usdAmount, USDC);\\r\\n        require(_amount >= usdcAmount, \\\"sp\\\");\\r\\n        TransferHelper.safeTransfer(USDC, targetAddress, usdcAmount);\\r\\n        uint256 fee = _amount.sub(usdcAmount);\\r\\n        if (feeAddress != address(0))\\r\\n            TransferHelper.safeTransfer(USDC, feeAddress, fee);\\r\\n        spendAmount = IConverter(converter).convertAssetAmountToUsdAmount(\\r\\n            _amount,\\r\\n            USDC\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function cashBack(address userAddr, uint256 usdAmount) internal {\\r\\n        if (!ICashBackManager(cashbackManager).cashBackEnable()) return;\\r\\n        uint256 cashBackPercent = ICashBackManager(cashbackManager)\\r\\n            .getCashBackPercent(\\r\\n                ILevelManager(levelManager).getUserLevel(userAddr)\\r\\n            );\\r\\n        address OKSE = IMarketManager(marketManager).OKSE();\\r\\n        uint256 okseAmount = IConverter(converter).getAssetAmount(\\r\\n            OKSE,\\r\\n            (usdAmount.mul(cashBackPercent)).div(10000),\\r\\n            priceOracle\\r\\n        );\\r\\n        // require(ERC20Interface(OKSE).balanceOf(address(this)) >= okseAmount , \\\"insufficient OKSE\\\");\\r\\n        if (usersBalances[financialAddress][OKSE] > okseAmount) {\\r\\n            usersBalances[financialAddress][OKSE] = usersBalances[\\r\\n                financialAddress\\r\\n            ][OKSE].sub(okseAmount);\\r\\n            //needs extra check that owner deposited how much OKSE for cashBack\\r\\n            _addUserBalance(OKSE, userAddr, okseAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function getUserAssetAmount(address userAddr, address market)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return usersBalances[userAddr][market];\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function encodePackedData(SignData calldata _data)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        uint256 chainId;\\r\\n        assembly {\\r\\n            chainId := chainid()\\r\\n        }\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    this,\\r\\n                    _data.method,\\r\\n                    _data.id,\\r\\n                    _data.userAddr,\\r\\n                    _data.market,\\r\\n                    chainId,\\r\\n                    _data.amount,\\r\\n                    _data.validTime\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function getecrecover(SignData calldata _data, SignKeys calldata key)\\r\\n        public\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        uint256 chainId;\\r\\n        assembly {\\r\\n            chainId := chainid()\\r\\n        }\\r\\n        return\\r\\n            ecrecover(\\r\\n                toEthSignedMessageHash(\\r\\n                    keccak256(\\r\\n                        abi.encodePacked(\\r\\n                            this,\\r\\n                            _data.method,\\r\\n                            _data.id,\\r\\n                            _data.userAddr,\\r\\n                            _data.market,\\r\\n                            chainId,\\r\\n                            _data.amount,\\r\\n                            _data.validTime\\r\\n                        )\\r\\n                    )\\r\\n                ),\\r\\n                key.v,\\r\\n                key.r,\\r\\n                key.s\\r\\n            );\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function setContractAddress(bytes calldata signData, bytes calldata keys)\\r\\n        public\\r\\n        validSignOfOwner(signData, keys, \\\"setContractAddress\\\")\\r\\n    {\\r\\n        (, , , bytes memory params) = abi.decode(\\r\\n            signData,\\r\\n            (bytes4, uint256, uint256, bytes)\\r\\n        );\\r\\n        (\\r\\n            address _priceOracle,\\r\\n            address _swapper,\\r\\n            address _limitManager,\\r\\n            address _levelManager,\\r\\n            address _marketManager,\\r\\n            address _cashbackManager\\r\\n        ) = abi.decode(\\r\\n                params,\\r\\n                (address, address, address, address, address, address)\\r\\n            );\\r\\n        priceOracle = _priceOracle;\\r\\n        swapper = _swapper;\\r\\n        limitManager = _limitManager;\\r\\n        levelManager = _levelManager;\\r\\n        marketManager = _marketManager;\\r\\n        cashbackManager = _cashbackManager;\\r\\n        emit ContractAddressChanged(\\r\\n            priceOracle,\\r\\n            swapper,\\r\\n            limitManager,\\r\\n            levelManager,\\r\\n            marketManager,\\r\\n            cashbackManager\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // owner function\\r\\n    function withdrawTokens(bytes calldata signData, bytes calldata keys)\\r\\n        public\\r\\n        validSignOfOwner(signData, keys, \\\"withdrawTokens\\\")\\r\\n    {\\r\\n        (, , , bytes memory params) = abi.decode(\\r\\n            signData,\\r\\n            (bytes4, uint256, uint256, bytes)\\r\\n        );\\r\\n        (address token, address to) = abi.decode(params, (address, address));\\r\\n\\r\\n        require(!IMarketManager(marketManager).isMarketExist(token), \\\"me\\\");\\r\\n        uint256 amount;\\r\\n        if (token == address(0)) {\\r\\n            amount = address(this).balance;\\r\\n            TransferHelper.safeTransferETH(to, amount);\\r\\n        } else {\\r\\n            amount = ERC20Interface(token).balanceOf(address(this));\\r\\n            TransferHelper.safeTransfer(token, to, amount);\\r\\n        }\\r\\n        emit WithdrawTokens(token, to, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/PriceOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract PriceOracle {\\r\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\r\\n    bool public constant isPriceOracle = true;\\r\\n\\r\\n    /**\\r\\n      * @notice Get the underlying price of a cToken asset\\r\\n      * @param market The cToken to get the underlying price of\\r\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\r\\n      *  Zero means the price is unavailable.\\r\\n      */\\r\\n    function getUnderlyingPrice(address market) external virtual view returns (uint);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILimitManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface ILimitManager {\\r\\n    function getUserLimit(address userAddr) external view returns (uint256);\\r\\n\\r\\n    function getDailyLimit(uint256 level) external view returns (uint256);\\r\\n\\r\\n    function getSpendAmountToday(address userAddr)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function withinLimits(address userAddr, uint256 usdAmount)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function updateUserSpendAmount(address userAddr, uint256 usdAmount)\\r\\n        external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILevelManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface ILevelManager {\\r\\n    function getUserLevel(address userAddr) external view returns (uint256);\\r\\n\\r\\n    function getLevel(uint256 _okseAmount) external view returns (uint256);\\r\\n\\r\\n    function updateUserLevel(\\r\\n        address userAddr,\\r\\n        uint256 beforeAmount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IMarketManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IMarketManager {\\r\\n    function WETH() external view returns (address);\\r\\n\\r\\n    function USDC() external view returns (address);\\r\\n\\r\\n    function OKSE() external view returns (address);\\r\\n\\r\\n    function defaultMarket() external view returns (address);\\r\\n\\r\\n    function oksePaymentEnable() external view returns (bool);\\r\\n\\r\\n    function emergencyStop() external view returns (bool);\\r\\n\\r\\n    function marketEnable(address market) external view returns (bool);\\r\\n\\r\\n    function isMarketExist(address market) external view returns (bool);\\r\\n\\r\\n    function userMainMarket(address userAddr) external view returns (address);\\r\\n\\r\\n    function slippage() external view returns (uint256);\\r\\n\\r\\n    function getUserMainMarket(address userAddr)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function setUserMainMakret(address userAddr, address market) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICashBackManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface ICashBackManager {\\r\\n    function cashBackEnable() external view returns (bool);\\r\\n\\r\\n    function getCashBackPercent(uint256 level) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.7.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface ISwapper {\\r\\n  function _swap(\\r\\n    uint256[] memory amounts,\\r\\n    address[] memory path,\\r\\n    address _to\\r\\n  ) external;\\r\\n\\r\\n  function getAmountsIn(\\r\\n    uint256 amountOut,\\r\\n    address[] memory path\\r\\n  ) external view returns (uint256[] memory amounts);\\r\\n\\r\\n  function GetReceiverAddress(\\r\\n    address[] memory path\\r\\n  ) external view returns (address);\\r\\n  \\r\\n  function getOptimumPath(\\r\\n    address token0,\\r\\n    address token1\\r\\n  ) external view returns (address[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC20Interface.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface ERC20Interface {\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens in existence.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token decimals.\\r\\n   */\\r\\n  function decimals() external view returns (uint8);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token symbol.\\r\\n   */\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the token name.\\r\\n  */\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the bep token owner.\\r\\n   */\\r\\n  function getOwner() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender's allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller's\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n   * another (`to`).\\r\\n   *\\r\\n   * Note that `value` may be zero.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n   * a call to {approve}. `value` is the new allowance.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IConverter {\\r\\n    function convertUsdAmountToAssetAmount(\\r\\n        uint256 usdAmount,\\r\\n        address assetAddress\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function convertAssetAmountToUsdAmount(\\r\\n        uint256 assetAmount,\\r\\n        address assetAddress\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function getUsdAmount(\\r\\n        address market,\\r\\n        uint256 assetAmount,\\r\\n        address priceOracle\\r\\n    ) external view returns (uint256 usdAmount);\\r\\n\\r\\n    function getAssetAmount(\\r\\n        address market,\\r\\n        uint256 usdAmount,\\r\\n        address priceOracle\\r\\n    ) external view returns (uint256 assetAmount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n  /**\\r\\n   * @dev Returns the addition of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity's `+` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Addition cannot overflow.\\r\\n   */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return add(a, b, \\\"SafeMath: addition overflow\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity's `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, errorMessage);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity's `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity's `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    require(b <= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity's `*` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Multiplication cannot overflow.\\r\\n   */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n    // benefit is lost if 'b' is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b > 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts with custom message when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    require(b != 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/OwnerConstants.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\nimport \\\"./MultiSigOwner.sol\\\";\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\n\\r\\ncontract OwnerConstants is MultiSigOwner {\\r\\n    using SafeMath for uint256;\\r\\n    // daily limit contants\\r\\n    uint256 public constant MAX_LEVEL = 5;\\r\\n\\r\\n    // this is reward address for user's withdraw and payment for goods.\\r\\n    address public treasuryAddress;\\r\\n    // this address should be deposit okse in his balance and users can get cashback from this address.\\r\\n    address public financialAddress;\\r\\n    // master address is used to send USDC tokens when user buy goods.\\r\\n    address public masterAddress;\\r\\n    // monthly fee rewarded address\\r\\n    address public monthlyFeeAddress;\\r\\n\\r\\n    // staking contract address, which is used to receive 20% of monthly fee, so staked users can be rewarded from this contract\\r\\n    address public stakeContractAddress;\\r\\n    // statking amount of monthly fee\\r\\n    uint256 public stakePercent; // 15 %\\r\\n\\r\\n    // withdraw fee and payment fee should not exeed this amount, 1% is coresponding to 100.\\r\\n    uint256 public constant MAX_FEE_AMOUNT = 500; // 5%\\r\\n    // buy fee setting.\\r\\n    uint256 public buyFeePercent; // 1%\\r\\n\\r\\n    // withdraw fee setting.\\r\\n    uint256 public withdrawFeePercent; // 0.1 %\\r\\n\\r\\n    // set monthly fee of user to use card payment, unit is usd amount ( 1e18)\\r\\n    uint256 public monthlyFeeAmount; // 6.99 USD\\r\\n    // if user pay monthly fee using okse, then he will pay less amount fro this percent. 0% => 0, 100% => 10000\\r\\n    uint256 public okseMonthlyProfit; // 10%\\r\\n    // buy tx fee in usd\\r\\n    uint256 public buyTxFee; // 0.7 usd\\r\\n    event ManagerAddressChanged(\\r\\n        address treasuryAddress,\\r\\n        address financialAddress,\\r\\n        address masterAddress,\\r\\n        address monthlyFeeAddress\\r\\n    );\\r\\n    event FeeValuesChanged(\\r\\n        uint256 monthlyFeeAmount,\\r\\n        uint256 okseMonthlyProfit,\\r\\n        uint256 withdrawFeePercent,\\r\\n        uint256 buyTxFee,\\r\\n        uint256 buyFeePercent\\r\\n    );\\r\\n    event StakeContractParamChanged(\\r\\n        address stakeContractAddress,\\r\\n        uint256 stakePercent\\r\\n    );\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    function getMonthlyFeeAmount(bool payFromOkse)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 result;\\r\\n        if (payFromOkse) {\\r\\n            result = monthlyFeeAmount.sub(\\r\\n                (monthlyFeeAmount.mul(okseMonthlyProfit)).div(10000)\\r\\n            );\\r\\n        } else {\\r\\n            result = monthlyFeeAmount;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function setManagerAddresses(bytes calldata signData, bytes calldata keys)\\r\\n        public\\r\\n        validSignOfOwner(signData, keys, \\\"setManagerAddresses\\\")\\r\\n    {\\r\\n        (, , , bytes memory params) = abi.decode(\\r\\n            signData,\\r\\n            (bytes4, uint256, uint256, bytes)\\r\\n        );\\r\\n        (\\r\\n            address _newTreasuryAddress,\\r\\n            address _newFinancialAddress,\\r\\n            address _newMasterAddress,\\r\\n            address _mothlyFeeAddress\\r\\n        ) = abi.decode(params, (address, address, address, address));\\r\\n\\r\\n        treasuryAddress = _newTreasuryAddress;\\r\\n        financialAddress = _newFinancialAddress;\\r\\n        masterAddress = _newMasterAddress;\\r\\n        monthlyFeeAddress = _mothlyFeeAddress;\\r\\n        emit ManagerAddressChanged(\\r\\n            treasuryAddress,\\r\\n            financialAddress,\\r\\n            masterAddress,\\r\\n            monthlyFeeAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // verified\\r\\n    function setFeeValues(bytes calldata signData, bytes calldata keys)\\r\\n        public\\r\\n        validSignOfOwner(signData, keys, \\\"setFeeValues\\\")\\r\\n    {\\r\\n        (, , , bytes memory params) = abi.decode(\\r\\n            signData,\\r\\n            (bytes4, uint256, uint256, bytes)\\r\\n        );\\r\\n        (\\r\\n            uint256 _monthlyFeeAmount,\\r\\n            uint256 _okseMonthlyProfit,\\r\\n            uint256 _withdrawFeePercent,\\r\\n            uint256 newBuyFeePercent,\\r\\n            uint256 newBuyTxFee\\r\\n        ) = abi.decode(params, (uint256, uint256, uint256, uint256, uint256));\\r\\n        require(_okseMonthlyProfit <= 10000, \\\"over percent\\\");\\r\\n        require(_withdrawFeePercent <= MAX_FEE_AMOUNT, \\\"mfo\\\");\\r\\n        monthlyFeeAmount = _monthlyFeeAmount;\\r\\n        okseMonthlyProfit = _okseMonthlyProfit;\\r\\n        withdrawFeePercent = _withdrawFeePercent;\\r\\n        require(newBuyFeePercent <= MAX_FEE_AMOUNT, \\\"mpo\\\");\\r\\n        buyFeePercent = newBuyFeePercent;\\r\\n        buyTxFee = newBuyTxFee;\\r\\n        emit FeeValuesChanged(\\r\\n            monthlyFeeAmount,\\r\\n            okseMonthlyProfit,\\r\\n            withdrawFeePercent,\\r\\n            buyTxFee,\\r\\n            buyFeePercent\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setStakeContractParams(\\r\\n        bytes calldata signData,\\r\\n        bytes calldata keys\\r\\n    ) public validSignOfOwner(signData, keys, \\\"setStakeContractParams\\\") {\\r\\n        (, , , bytes memory params) = abi.decode(\\r\\n            signData,\\r\\n            (bytes4, uint256, uint256, bytes)\\r\\n        );\\r\\n        (address _stakeContractAddress, uint256 _stakePercent) = abi.decode(\\r\\n            params,\\r\\n            (address, uint256)\\r\\n        );\\r\\n        stakeContractAddress = _stakeContractAddress;\\r\\n        stakePercent = _stakePercent;\\r\\n        emit StakeContractParamChanged(stakeContractAddress, stakePercent);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/SignerRole.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.0;\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n  struct Role {\\r\\n    mapping(address => bool) bearer;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Give an account access to this role.\\r\\n   */\\r\\n  function add(Role storage role, address account) internal {\\r\\n    require(!has(role, account), \\\"Roles: account already has role\\\");\\r\\n    role.bearer[account] = true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Remove an account's access to this role.\\r\\n   */\\r\\n  function remove(Role storage role, address account) internal {\\r\\n    // require(has(role, account), \\\"Roles: account does not have role\\\");\\r\\n    role.bearer[account] = false;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Check if an account has this role.\\r\\n   * @return bool\\r\\n   */\\r\\n  function has(Role storage role, address account)\\r\\n    internal\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(account != address(0), \\\"Roles: account is the zero address\\\");\\r\\n    return role.bearer[account];\\r\\n  }\\r\\n}\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n  // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n  // an instance of this contract, which should be used via inheritance.\\r\\n  constructor() {}\\r\\n\\r\\n  // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n  function _msgSender() internal view returns (address payable) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n\\r\\n  function _msgData() internal view returns (bytes memory) {\\r\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n    return msg.data;\\r\\n  }\\r\\n}\\r\\n\\r\\nabstract contract SignerRole is Context {\\r\\n  using Roles for Roles.Role;\\r\\n\\r\\n  event SignerAdded(address indexed account);\\r\\n  event SignerRemoved(address indexed account);\\r\\n\\r\\n  Roles.Role private _signers;\\r\\n\\r\\n  constructor(address _signer) {\\r\\n    _addSigner(_signer);\\r\\n  }\\r\\n\\r\\n  modifier onlySigner() {\\r\\n    require(\\r\\n      isSigner(_msgSender()),\\r\\n      \\\"SignerRole: caller does not have the Signer role\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function isSigner(address account) public view returns (bool) {\\r\\n    return _signers.has(account);\\r\\n  }\\r\\n\\r\\n  function _addSigner(address account) internal {\\r\\n    _signers.add(account);\\r\\n    emit SignerAdded(account);\\r\\n  }\\r\\n\\r\\n  function _removeSigner(address account) internal {\\r\\n    _signers.remove(account);\\r\\n    emit SignerRemoved(account);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/MultiSigOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LICENSED\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\n// 2/3 Multi Sig Owner\\r\\ncontract MultiSigOwner {\\r\\n    address[] public owners;\\r\\n    mapping(uint256 => bool) public signatureId;\\r\\n    bool private initialized;\\r\\n    // events\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n    event SignValidTimeChanged(uint256 newValue);\\r\\n    modifier validSignOfOwner(\\r\\n        bytes calldata signData,\\r\\n        bytes calldata keys,\\r\\n        string memory functionName\\r\\n    ) {\\r\\n        require(isOwner(msg.sender), \\\"on\\\");\\r\\n        address signer = getSigner(signData, keys);\\r\\n        require(\\r\\n            signer != msg.sender && isOwner(signer) && signer != address(0),\\r\\n            \\\"is\\\"\\r\\n        );\\r\\n        (bytes4 method, uint256 id, uint256 validTime, ) = abi.decode(\\r\\n            signData,\\r\\n            (bytes4, uint256, uint256, bytes)\\r\\n        );\\r\\n        require(\\r\\n            signatureId[id] == false &&\\r\\n                method == bytes4(keccak256(bytes(functionName))),\\r\\n            \\\"sru\\\"\\r\\n        );\\r\\n        require(validTime > block.timestamp, \\\"ep\\\");\\r\\n        signatureId[id] = true;\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner(address addr) public view returns (bool) {\\r\\n        bool _isOwner = false;\\r\\n        for (uint256 i = 0; i < owners.length; i++) {\\r\\n            if (owners[i] == addr) {\\r\\n                _isOwner = true;\\r\\n            }\\r\\n        }\\r\\n        return _isOwner;\\r\\n    }\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    function initializeOwners(address[3] memory _owners) public {\\r\\n        require(\\r\\n            !initialized &&\\r\\n                _owners[0] != address(0) &&\\r\\n                _owners[1] != address(0) &&\\r\\n                _owners[2] != address(0),\\r\\n            \\\"ai\\\"\\r\\n        );\\r\\n        owners = [_owners[0], _owners[1], _owners[2]];\\r\\n        initialized = true;\\r\\n    }\\r\\n\\r\\n    function getSigner(bytes calldata _data, bytes calldata keys)\\r\\n        public\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        uint256 chainId;\\r\\n        assembly {\\r\\n            chainId := chainid()\\r\\n        }\\r\\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(\\r\\n            keys,\\r\\n            (uint8, bytes32, bytes32)\\r\\n        );\\r\\n        return\\r\\n            ecrecover(\\r\\n                toEthSignedMessageHash(\\r\\n                    keccak256(abi.encodePacked(this, chainId, _data))\\r\\n                ),\\r\\n                v,\\r\\n                r,\\r\\n                s\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function encodePackedData(bytes calldata _data)\\r\\n        public\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        uint256 chainId;\\r\\n        assembly {\\r\\n            chainId := chainid()\\r\\n        }\\r\\n        return keccak256(abi.encodePacked(this, chainId, _data));\\r\\n    }\\r\\n\\r\\n    function toEthSignedMessageHash(bytes32 hash)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    // Set functions\\r\\n    // verified\\r\\n    function transferOwnership(bytes calldata signData, bytes calldata keys)\\r\\n        public\\r\\n        validSignOfOwner(signData, keys, \\\"transferOwnership\\\")\\r\\n    {\\r\\n        (, , , bytes memory params) = abi.decode(\\r\\n            signData,\\r\\n            (bytes4, uint256, uint256, bytes)\\r\\n        );\\r\\n        address newOwner = abi.decode(params, (address));\\r\\n        uint256 index;\\r\\n        for (uint256 i = 0; i < owners.length; i++) {\\r\\n            if (owners[i] == msg.sender) {\\r\\n                index = i;\\r\\n            }\\r\\n        }\\r\\n        address oldOwner = owners[index];\\r\\n        owners[index] = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_converter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_initialSigner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"limitManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"levelManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cashbackManager\",\"type\":\"address\"}],\"name\":\"ContractAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"monthlyFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"okseMonthlyProfit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawFeePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTxFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyFeePercent\",\"type\":\"uint256\"}],\"name\":\"FeeValuesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"financialAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"monthlyFeeAddress\",\"type\":\"address\"}],\"name\":\"ManagerAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userValidTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"}],\"name\":\"MonthlyFeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"SignValidTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SignerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"}],\"name\":\"SignerBuyGoods\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SignerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakePercent\",\"type\":\"uint256\"}],\"name\":\"StakeContractParamChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beforeMarket\",\"type\":\"address\"}],\"name\":\"UserMainMarketChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainedBalance\",\"type\":\"uint256\"}],\"name\":\"UserWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUYGOODS\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CARD_VALIDATION_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LEVEL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAY_MONTHLY_FEE\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SET_USER_MAIN_MARKET\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAW\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OkseCard.SignData\",\"name\":\"_data\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OkseCard.SignKeys[2]\",\"name\":\"signer_key\",\"type\":\"tuple[2]\"}],\"name\":\"buyGoods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cashbackManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"encodePackedData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OkseCard.SignData\",\"name\":\"_data\",\"type\":\"tuple\"}],\"name\":\"encodePackedData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"financialAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"payFromOkse\",\"type\":\"bool\"}],\"name\":\"getMonthlyFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keys\",\"type\":\"bytes\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"getUserAssetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getUserExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getUserOkseBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OkseCard.SignData\",\"name\":\"_data\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OkseCard.SignKeys\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"getecrecover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_limitManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_levelManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cashbackManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_financialAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_monthlyFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapper\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_owners\",\"type\":\"address[3]\"}],\"name\":\"initializeOwners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levelManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthlyFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthlyFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"okseMonthlyProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OkseCard.SignData\",\"name\":\"_data\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OkseCard.SignKeys\",\"name\":\"user_key\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"payMonthlyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keys\",\"type\":\"bytes\"}],\"name\":\"setContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keys\",\"type\":\"bytes\"}],\"name\":\"setFeeValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"setGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keys\",\"type\":\"bytes\"}],\"name\":\"setManagerAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keys\",\"type\":\"bytes\"}],\"name\":\"setStakeContractParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"validTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"setUserMainMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signatureId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keys\",\"type\":\"bytes\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"bAddOrRemove\",\"type\":\"bool\"}],\"name\":\"updateSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userValidTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keys\",\"type\":\"bytes\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OkseCard", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000d962e220ed470084cc2dbf425784e8ccbcfe7ce90000000000000000000000005126ea3894671e1c6cce47d3fb462e3c270e499e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}