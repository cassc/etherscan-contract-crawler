{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: TransferHelper.sol\r\n\r\n\r\npragma solidity >=0.8.3;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferBNB(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: BNB_TRANSFER_FAILED');\r\n    }\r\n}\r\n// File: iWBNB.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iWBNB {\r\n    function withdraw(uint256) external;\r\n}\r\n// File: iPOOLFACTORY.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iPOOLFACTORY {\r\n    function isCuratedPool(address) external view returns (bool);\r\n    function addCuratedPool(address) external;\r\n    function removeCuratedPool(address) external;\r\n    function isPool(address) external returns (bool);\r\n    function getPool(address) external view returns(address);\r\n    function getVaultAssets() external view returns(address [] memory);\r\n    function getPoolAssets() external view returns(address [] memory);\r\n    function curatedPoolCount() external view returns (uint);\r\n}\r\n\r\n// File: iRESERVE.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iRESERVE {\r\n    function grantPOLFunds(uint, address) external; \r\n     function grantFunds(uint, address) external; \r\n    function emissions() external returns(bool); \r\n    function setGlobalFreeze(bool) external; \r\n    function setIncentiveAddresses(address, address, address, address) external;\r\n    function globalFreeze() external returns(bool); \r\n    function freezeTime() external returns(uint256); \r\n    function polPoolAddress() external view returns(address); \r\n}\r\n\r\n// File: iSYNTHVAULT.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTHVAULT{\r\n   function depositForMember(address synth, address member) external;\r\n   function setReserveClaim(uint256 _setSynthClaim) external;\r\n}\r\n// File: iSYNTHFACTORY.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTHFACTORY {\r\n    function isSynth(address) external view returns (bool);\r\n    function getSynth(address) external view returns (address);\r\n    function removeSynth(address _token) external;\r\n    function synthCount() external returns(uint);\r\n}\r\n// File: iSYNTH.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTH {\r\n    function genesis() external view returns(uint);\r\n    function TOKEN() external view returns(address);\r\n    function POOL() external view returns(address);\r\n    function mintSynth(address, uint) external returns(uint256);\r\n    function burnSynth(uint) external returns(uint);\r\n    function realise() external;\r\n}\r\n\r\n// File: iROUTER.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iROUTER {\r\n    function addLiquidityForMember(uint, uint, address, address) external payable returns (uint);\r\n      function synthMinting() external view returns (bool);\r\n      function lastMonth() external view returns(uint); \r\n      function mapAddress_30DayDividends(address) external returns (uint);\r\n      function mapAddress_Past30DayPoolDividends(address) external returns (uint);\r\n      function addLiquidityAsym(uint input, bool fromBase, address token) external;\r\n      function removeLiquidityExactAsym(uint input, bool fromBase, address token) external;\r\n      function syncPool(address, uint256) external;\r\n}\r\n// File: iDAOVAULT.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iDAOVAULT{\r\n  function getMemberWeight(address) external view returns (uint256);\r\n  function getMemberPoolBalance(address, address) external view returns(uint);\r\n  function getMemberLPWeight(address) external view returns(uint, uint);\r\n  function depositLP(address, uint, address) external;\r\n  function withdraw(address, address) external returns (bool);\r\n  function totalWeight() external view returns (uint);\r\n  function mapTotalPool_balance(address) external view returns (uint);\r\n}\r\n// File: iDAO.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iDAO {\r\n    function ROUTER() external view returns(address);\r\n    function DAOVAULT() external view returns(address);\r\n    function BASE() external view returns(address);\r\n    function LEND() external view returns(address);\r\n    function UTILS() external view returns(address);\r\n    function DAO() external view returns (address);\r\n    function RESERVE() external view returns(address);\r\n    function SYNTHVAULT() external view returns(address);\r\n    function BONDVAULT() external view returns(address);\r\n    function SYNTHFACTORY() external view returns(address);\r\n    function POOLFACTORY() external view returns(address);\r\n    function depositForMember(address pool, uint256 amount, address member) external;\r\n    function currentProposal() external view returns (uint);\r\n    function mapPID_open(uint) external view returns (bool);\r\n    function isListed(address) external view returns (bool);\r\n    function arrayMembers(uint) external view returns (address);\r\n    function mapMember_lastTime(address) external view returns (uint);\r\n}\r\n// File: iBASE.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\ninterface iBASE {\r\n    function DAO() external view returns (iDAO);\r\n    function secondsPerEra() external view returns (uint256);\r\n    function changeDAO(address) external;\r\n    function setParams(uint256, uint256) external;\r\n    function flipEmissions() external;\r\n    function mintFromDAO(uint256, address) external; \r\n    function burn(uint256) external; \r\n}\r\n// File: iUTILS.sol\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\ninterface iUTILS {\r\n    function calcShare(uint, uint, uint) external pure returns (uint);\r\n    function getFeeOnTransfer(uint256, uint256) external view returns(uint);\r\n    function getPoolShareWeight(address, uint)external view returns(uint);\r\n    function calcLiquidityUnits(uint, uint, uint, uint, uint) external pure returns (uint);\r\n    function calcLiquidityHoldings(uint, address, address) external pure returns (uint);\r\n    function calcSwapOutput(uint, uint, uint) external pure returns (uint);\r\n    function calcSwapFee(uint, uint, uint) external pure returns (uint);\r\n    function calcSwapValueInBase(address, uint) external view returns (uint);\r\n    function calcSwapValueInToken(address, uint) external view returns (uint);\r\n    function calcSpotValueInBaseWithSynth(address, uint) external view returns (uint);\r\n    function calcSpotValueInBase(address, uint) external view returns (uint);\r\n    function calcPart(uint, uint) external pure returns (uint);\r\n    function calcLiquidityUnitsAsym(uint, address)external pure returns (uint);\r\n    function calcActualSynthUnits(address, uint) external view returns (uint);\r\n}\r\n// File: iBEP20.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iBEP20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function allowance(address, address) external view returns (uint256);\r\n    function approve(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function burn(uint) external;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: Pool.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Pool is iBEP20 {  \r\n    address public immutable BASE;  // Address of SPARTA base token contract\r\n    address public immutable TOKEN; // Address of the layer1 TOKEN represented in this pool\r\n    uint256 public synthCap;    // Basis points hard cap of synths that can be minted vs tokenDepth\r\n    uint256 public baseCap;     // Cap on the depth of the pool (in SPARTA)\r\n    uint256 public oldRate;    // Pool ratio from last period\r\n    uint256 private period;     // Timestamp of next period\r\n    uint256 private freezePoint; // Basis points change to trigger a freeze\r\n    bool public freeze;         // Freeze status of the pool\r\n    uint256 private oneWeek;\r\n\r\n    uint256 public stirRate; // Rate of steaming\r\n    uint public lastStirred; // timestamp of last steamed\r\n    uint public stirStamp; // timestamp of last time stir rate was adjusted\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 public override immutable decimals;\r\n    uint256 public override totalSupply;\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint256 public baseAmount;  // SPARTA amount that should be in the pool\r\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\r\n\r\n    uint private lastMonth;          // Timestamp of the start of current metric period (For UI)\r\n    uint public immutable genesis;  // Timestamp from when the pool was first deployed (For UI)\r\n\r\n    uint256 public map30DPoolRevenue;       // Tally of revenue during current incomplete metric period (for UI)\r\n    uint256 public mapPast30DPoolRevenue;   // Tally of revenue from last full metric period (for UI)\r\n    uint256 [] private revenueArray;         // Array of the last two full metric periods (For UI)\r\n    \r\n    event AddLiquidity(address indexed member, address indexed tokenAddress, uint inputBase, uint inputToken, uint unitsIssued);\r\n    event RemoveLiquidity(address indexed member, address indexed tokenAddress, uint outputBase, uint outputToken, uint unitsClaimed);\r\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\r\n    event MintSynth(address indexed member, address indexed synthAddress, uint256 baseAmount, uint256 liqUnits, uint256 synthAmount);\r\n    event BurnSynth(address indexed member, address indexed synthAddress, uint256 baseAmount, uint256 liqUnits, uint256 synthAmount);\r\n\r\n    function SYNTH() public view returns(address) {\r\n        return iSYNTHFACTORY(_DAO().SYNTHFACTORY()).getSynth(TOKEN); // Get the relevant synth address\r\n    }\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return iBASE(BASE).DAO(); // Get the DAO address reported by Sparta base contract\r\n    }\r\n\r\n    // Restrict access\r\n    modifier onlyPROTOCOL() {\r\n        require(msg.sender == _DAO().ROUTER() || msg.sender == _DAO().SYNTHVAULT() || msg.sender == _DAO().POOLFACTORY()); \r\n        _;\r\n    }\r\n    modifier onlyDAO() {\r\n        require(msg.sender == _DAO().DAO() || msg.sender == _DAO().ROUTER() || msg.sender == _DAO().SYNTHVAULT());\r\n        _;\r\n    }\r\n     modifier onlySYNTH() {\r\n        require(msg.sender == SYNTH());\r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(SYNTH()));\r\n        _;\r\n    }\r\n\r\n    constructor (address _base, address _token) {\r\n        BASE = _base;\r\n        TOKEN = _token;\r\n        string memory poolName = \"-SpartanProtocolPool\";\r\n        string memory poolSymbol = \"-SPP\";\r\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\r\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\r\n        decimals = 18;\r\n        genesis = block.timestamp;\r\n        period = block.timestamp + 60; \r\n        lastMonth = block.timestamp;\r\n        synthCap = 2500; //25%\r\n        freezePoint = 3000; //30%\r\n        baseCap = 100000*10**18; //RAISE THE CAPS\r\n        lastStirred = 0;\r\n        oneWeek = 604800;//604800 mainnet\r\n    }\r\n\r\n    //========================================iBEP20=========================================//\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"!approval\");\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"!owner\");\r\n        require(spender != address(0), \"!spender\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"!approval\");\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"!sender\");\r\n        require(recipient != address(0), '!BURN');\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"!balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external onlySYNTH virtual override {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"!balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    //====================================POOL FUNCTIONS =================================//\r\n\r\n    // Contract adds liquidity for user \r\n    function addForMember(address member) external onlyPROTOCOL returns (uint liquidityUnits){\r\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\r\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\r\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\r\n        if(baseAmount == 0 || tokenAmount == 0){\r\n            uint createFee = 100 * liquidityUnits / 10000; // First liqAdd charges 1% fee to the base contract (permanently removed from circulation; prevent 1wei rounding)\r\n            liquidityUnits -= createFee; // Remove fee from the calculated LP units\r\n            _mint(BASE, createFee); // Mint the fee portion of the LP units to the BASE contract (permanently removed from circulation)\r\n            oldRate = (10**18 * _actualInputBase) / _actualInputToken; // Set the first / initial rate\r\n        }\r\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\r\n        _mint(member, liquidityUnits); // Mint the remaining LP tokens directly to the user\r\n        emit AddLiquidity(member, TOKEN, _actualInputBase, _actualInputToken, liquidityUnits);\r\n        return liquidityUnits;\r\n    }\r\n\r\n    // Contract removes liquidity for the user\r\n    function removeForMember(address recipient, address actualMember) external onlyPROTOCOL returns (uint outputBase, uint outputToken) {\r\n        require(block.timestamp > (genesis + oneWeek)); // Can not remove liquidity until 7 days after pool's creation\r\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\r\n        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract\r\n        outputBase = _utils.calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\r\n        outputToken = _utils.calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\r\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded SPARTA and TOKEN amounts\r\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\r\n        _safeTransfer(BASE, recipient,outputBase);        \r\n        _safeTransfer(TOKEN, recipient,outputToken);\r\n        emit RemoveLiquidity(actualMember, TOKEN, outputBase, outputToken, _actualInputUnits);\r\n        return (outputBase, outputToken);\r\n    }\r\n\r\n    // Contract swaps tokens for the member\r\n    function swapTo(address token, address member) external onlyPROTOCOL returns (uint outputAmount, uint fee) {\r\n        require((token == BASE || token == TOKEN)); // Must be SPARTA or the pool's relevant TOKEN\r\n        address _fromToken; uint _amount;\r\n        if(token == BASE){\r\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\r\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\r\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\r\n        } else {\r\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\r\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\r\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\r\n        }\r\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\r\n        _safeTransfer(token, member,outputAmount);  \r\n        return (outputAmount, fee);\r\n    }\r\n\r\n    // Swap SPARTA for Synths\r\n    function mintSynth(address member) external onlyPROTOCOL returns(uint outputAmount, uint fee) {\r\n        address synthOut = SYNTH(); // Get the synth address\r\n        require(iROUTER(_DAO().ROUTER()).synthMinting());  \r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut)); // Must be a valid Synth\r\n        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract\r\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\r\n        uint256 steamedSynths = stirCauldron(synthOut);\r\n        uint256 output = _utils.calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN (virtualised)\r\n        lastStirred = block.timestamp;\r\n        outputAmount = output * 9900 / 10000; //1% fee reduction\r\n        require(outputAmount <= steamedSynths); //steam synths\r\n        uint _liquidityUnits = _utils.calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\r\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\r\n        uint _fee = _utils.calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN (virtualised)\r\n        fee = _utils.calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\r\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\r\n        iSYNTH(synthOut).mintSynth(address(_DAO().SYNTHVAULT()), outputAmount); // Mint the Synth tokens directly to the synthVault\r\n        iSYNTHVAULT(_DAO().SYNTHVAULT()).depositForMember(synthOut, member); //Deposit on behalf of member\r\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\r\n        emit MintSynth(member,synthOut, _actualInputBase, _liquidityUnits, outputAmount);\r\n        return (outputAmount, fee);\r\n    }\r\n    \r\n    // Swap Synths for SPARTA\r\n    function burnSynth(address recipient, address actualMember) external onlyPROTOCOL returns(uint outputAmount, uint fee) {\r\n        address synthIN = SYNTH(); // Get the synth address\r\n        require(synthIN != address(0)); // Must be a valid Synth\r\n        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract\r\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\r\n        uint output = _utils.calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA (virtualised)\r\n        uint outputBase = output * 9500 / 10000; //5% reduction\r\n        fee = _utils.calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA (virtualised)\r\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\r\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\r\n        uint liqUnits = iSYNTH(synthIN).burnSynth(_actualInputSynth); // Burn the input SYNTH units \r\n        _burn(synthIN, liqUnits); // Burn the synth-held LP units\r\n        _safeTransfer(BASE, recipient,outputBase);  \r\n        emit BurnSynth(actualMember,synthIN, outputBase, liqUnits, _actualInputSynth);\r\n        return (outputBase, fee);\r\n    }\r\n\r\n    function stirCauldron(address synth) public returns (uint256 steamedSynths){ \r\n          uint256 synthsCap = tokenAmount * synthCap / 10000;\r\n          uint256 liquidSynths; uint256 totalSup = iBEP20(synth).totalSupply();\r\n          steamedSynths = 0;\r\n         if(synthsCap >= totalSup){\r\n             liquidSynths = synthsCap - totalSup; \r\n         }\r\n         if(lastStirred != 0){ \r\n            uint secondsSinceStirred = block.timestamp - lastStirred; //Get last time since stirred\r\n            steamedSynths = secondsSinceStirred * stirRate; //time since last minted\r\n         }else{\r\n            lastStirred = block.timestamp;\r\n            stirStamp = block.timestamp;\r\n            stirRate = liquidSynths / oneWeek;\r\n            steamedSynths = 14400 * stirRate;  //4hrs\r\n         }\r\n         if(block.timestamp > (stirStamp + oneWeek)){\r\n            stirRate = liquidSynths / oneWeek;\r\n            stirStamp = block.timestamp;\r\n         }\r\n    }\r\n\r\n    //=======================================INTERNAL MATHS======================================//\r\n\r\n    // Check the SPARTA amount received by this Pool\r\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\r\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this));\r\n        if(_baseBalance > baseAmount){\r\n            _actual = _baseBalance - baseAmount;\r\n        } else {\r\n            _actual = 0;\r\n        }\r\n        return _actual;\r\n    }\r\n  \r\n    // Check the TOKEN amount received by this Pool\r\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\r\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \r\n        if(_tokenBalance > tokenAmount){\r\n            _actual = _tokenBalance - tokenAmount;\r\n        } else {\r\n            _actual = 0;\r\n        }\r\n        return _actual;\r\n    }\r\n\r\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\r\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\r\n        uint256 _X = baseAmount;\r\n        uint256 _Y = tokenAmount;\r\n        iUTILS _utils = iUTILS(_DAO().UTILS());\r\n        _y =  _utils.calcSwapOutput(_x, _X, _Y); // Calc TOKEN output \r\n        uint fee = _utils.calcSwapFee(_x, _X, _Y); // Calc TOKEN fee \r\n        _fee = _utils.calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\r\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\r\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\r\n        return (_y, _fee);\r\n    }\r\n\r\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\r\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\r\n        uint256 _X = tokenAmount;\r\n        uint256 _Y = baseAmount;\r\n        iUTILS _utils = iUTILS(_DAO().UTILS());\r\n        _y = _utils.calcSwapOutput(_x, _X, _Y); // Calc SPARTA output \r\n        _fee = _utils.calcSwapFee(_x, _X, _Y); // Calc SPARTA fee \r\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\r\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\r\n        return (_y, _fee);\r\n    }\r\n\r\n    //=======================================BALANCES=========================================//\r\n\r\n    // Sync internal balances to actual\r\n    function sync() external onlyDAO  {\r\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\r\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\r\n    }\r\n\r\n    // Set internal balances\r\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal {\r\n        baseAmount = _baseAmount;\r\n        tokenAmount = _tokenAmount; \r\n        _safetyCheck();\r\n    }\r\n\r\n    // Increment internal balances\r\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal {\r\n        require((baseAmount + _baseAmount) < baseCap); // SPARTA input must not push TVL over the cap\r\n        baseAmount += _baseAmount;\r\n        tokenAmount += _tokenAmount;\r\n        _safetyCheck();\r\n    }\r\n\r\n    // Decrement internal balances\r\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal {\r\n        baseAmount -= _baseAmount;\r\n        tokenAmount -= _tokenAmount; \r\n        _safetyCheck();\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function _safetyCheck() internal {\r\n            uint currentRate = (10**18 * baseAmount) / tokenAmount; // Get current rate\r\n            uint rateDiff; uint256 rateDiffBP;\r\n            if (currentRate > oldRate) {\r\n                rateDiff = currentRate - oldRate; // Get absolute rate diff\r\n                rateDiffBP = rateDiff * 10000 / currentRate; // Get basispoints difference\r\n            } else {\r\n                rateDiff = oldRate - currentRate; // Get absolute rate diff\r\n                rateDiffBP = rateDiff * 10000 / oldRate; // Get basispoints difference\r\n            }\r\n            if (rateDiffBP >= freezePoint) {\r\n                freeze = true; // If exceeding; flip freeze to true\r\n            } else if (block.timestamp > period) {\r\n                period = block.timestamp + 3600; // Set new period\r\n                oldRate = currentRate; // Update the stored ratio\r\n            }\r\n            if(freeze){\r\n                if(rateDiffBP <= freezePoint){\r\n                    freeze = false; // If exceeding; flip freeze to false\r\n                }\r\n                if (block.timestamp > period) {\r\n                    period = block.timestamp + 3600; // Set new period\r\n                    oldRate = (currentRate + oldRate ) / 2; //Smooth rate increase\r\n                }\r\n            }  \r\n    }\r\n  \r\n    //===========================================POOL FEE ROI=================================//\r\n\r\n    function _addPoolMetrics(uint256 _fee) internal {\r\n        if (block.timestamp <= (lastMonth + 2592000)) {\r\n            map30DPoolRevenue = map30DPoolRevenue + _fee;\r\n        } else {\r\n            lastMonth = block.timestamp;\r\n            mapPast30DPoolRevenue = map30DPoolRevenue;\r\n            _archiveRevenue(mapPast30DPoolRevenue);\r\n            map30DPoolRevenue = _fee;\r\n        }\r\n    }\r\n\r\n    function _archiveRevenue(uint _totalRev) internal {\r\n        if (revenueArray.length == 2) {\r\n            revenueArray[0] = revenueArray[1]; // Shift previous value to start of array\r\n            revenueArray[1] = _totalRev; // Replace end of array with new value\r\n        } else {\r\n            revenueArray.push(_totalRev);\r\n        }\r\n    }\r\n\r\n    //=========================================== SYNTH CAPS =================================//\r\n    \r\n    function setSynthCap(uint256 _synthCap) external onlyPROTOCOL {\r\n        require(_synthCap <= 3000);\r\n        synthCap = _synthCap;\r\n    }\r\n\r\n    function RTC(uint256 _newRTC) external onlyPROTOCOL {\r\n        require(_newRTC <= (baseCap * 2));\r\n        baseCap = _newRTC;\r\n    }\r\n\r\n    function setFreezePoint(uint256 _newFreezePoint) external onlyPROTOCOL {\r\n        freezePoint = _newFreezePoint;\r\n    }\r\n}\r\n\r\n// File: Router.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Router is ReentrancyGuard{\r\n    address private immutable BASE;  // SPARTA base contract address\r\n    address private immutable WBNB;  // Address of WBNB\r\n    address private DEPLOYER;        // Address that deployed the contract\r\n    uint256 public diviClaim;       // Basis points vs RESERVE holdings max dividend per month\r\n    uint public lastMonth;          // Timestamp of the start of current metric period (For UI)\r\n    uint256 private curatedPoolsCount; // Count of curated pools, synced from PoolFactory once per month\r\n    bool public synthMinting;\r\n    uint public minDiv;\r\n\r\n    mapping(address=> uint) public mapAddress_30DayDividends; // Current incomplete-period NET SPARTA divis by pool\r\n    mapping(address=> uint) public mapAddress_Past30DayPoolDividends; // Previous full-period NET SPARTA divis by pool\r\n    event Dividend(address Pool, uint256 amount);\r\n    // Restrict access\r\n    modifier onlyDAO() {\r\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);\r\n        _;\r\n    }\r\n    modifier onlyRESERVE() {\r\n        require(msg.sender == _DAO().RESERVE());\r\n        _;\r\n    }\r\n\r\n    // Can purge deployer once DAO is stable and final\r\n    function purgeDeployer() external onlyDAO {\r\n        DEPLOYER = address(0);\r\n    }\r\n\r\n    constructor (address _base, address _wbnb) {\r\n        BASE = _base;\r\n        WBNB = _wbnb;\r\n        diviClaim = 500;\r\n        synthMinting = false;\r\n        DEPLOYER = msg.sender;\r\n        minDiv = 10**18;\r\n    }\r\n\r\n    receive() external payable {} // Used to receive BNB from WBNB contract\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return iBASE(BASE).DAO(); // Get the DAO address from SPARTA base contract\r\n    }\r\n\r\n    // User adds liquidity\r\n    function addLiquidity(uint inputToken, uint baseAmount, address token) external payable{\r\n        addLiquidityForMember(inputToken, baseAmount, token, msg.sender);\r\n    }\r\n\r\n    // Contract adds liquidity for user\r\n    function addLiquidityForMember(uint inputToken, uint baseAmount, address token, address member) public payable returns (uint256 LPsMinted) {\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        address pool = _poolFactory.getPool(token); // Get pool address\r\n        require(_poolFactory.isPool(pool) == true, '!POOL'); // Pool must be valid\r\n        _handleTransferIn(BASE, baseAmount, pool); // Transfer SPARTA (User -> Pool)\r\n        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN (User -> Pool)\r\n        LPsMinted = Pool(pool).addForMember(member); // Add liquidity; tsf LPs (Pool -> User)\r\n        _safetyTrigger(pool); // Check pool ratios\r\n    }\r\n\r\n    function addLiquidityAsym(uint input, bool fromBase, address token) external payable {\r\n        addLiquidityAsymForMember(input, fromBase, token, msg.sender);\r\n    }\r\n\r\n    function addLiquidityAsymForMember(uint _input, bool _fromBase, address token, address _member) public payable {\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        address _pool = _poolFactory.getPool(token); // Get pool address\r\n        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid\r\n        address _token = token; // Get token address\r\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\r\n        if(_fromBase){\r\n            _handleTransferIn(BASE, _input, address(this));\r\n            _handleTransferOut(BASE, (_input / 2), _pool);\r\n            Pool(_pool).swapTo(_token, address(this)); // Swap TOKEN to SPARTA (Pool -> router)\r\n            _handleTransferOut(BASE, iBEP20(BASE).balanceOf(address(this)), _pool); // Tsf swapped SPARTA (Router -> Pool)\r\n            _handleTransferOut(_token, iBEP20(_token).balanceOf(address(this)), _pool); // Tsf remaining BNB (Router -> Pool)\r\n        } else {\r\n            _handleTransferIn(token, _input, address(this));\r\n            _handleTransferOut(_token, (_input / 2), _pool);\r\n            Pool(_pool).swapTo(BASE, address(this)); // Swap TOKEN to SPARTA (Pool -> router)\r\n            _handleTransferOut(BASE, iBEP20(BASE).balanceOf(address(this)), _pool); // Tsf swapped SPARTA (Router -> Pool)\r\n            _handleTransferOut(_token, iBEP20(_token).balanceOf(address(this)), _pool); // Tsf remaining BNB (Router -> Pool)\r\n        }\r\n        Pool(_pool).addForMember(_member); // Add liquidity; tsf LPs (Pool -> User)\r\n        _safetyTrigger(_pool); // Check pool ratios\r\n    }\r\n\r\n    // Swap LP tokens for a different pool's LP tokens\r\n    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external nonReentrant {\r\n        require(fromPool != toPool && unitsInput > 0, '!VALID'); // Pools must be different and input must be valid\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        require(_poolFactory.isPool(fromPool) == true, '!POOL'); // FromPool must be a valid pool\r\n        if(_poolFactory.isCuratedPool(fromPool)){\r\n            require(Pool(fromPool).freeze() == false);\r\n        }\r\n        require(_poolFactory.isPool(toPool) == true, '!POOL'); // ToPool must be a valid pool\r\n        address _fromToken = Pool(fromPool).TOKEN(); // Get token underlying the fromPool\r\n        address _toToken = Pool(toPool).TOKEN(); // Get token underlying the toPool\r\n        address _member = msg.sender; // Get user's address\r\n        TransferHelper.safeTransferFrom(fromPool, _member, fromPool, unitsInput);\r\n        Pool(fromPool).removeForMember(address(this), _member); // Remove liquidity; tsf SPARTA and fromTOKEN (Pool -> Router)\r\n        TransferHelper.safeTransfer(_fromToken, fromPool, iBEP20(_fromToken).balanceOf(address(this)));\r\n        Pool(fromPool).swapTo(BASE, address(this)); // Swap fromTOKEN for SPARTA (FromPool -> Router)\r\n        TransferHelper.safeTransfer(BASE, toPool, iBEP20(BASE).balanceOf(address(this)) / 2);\r\n        Pool(toPool).swapTo(_toToken, address(this)); // Swap SPARTA for toTOKEN (ToPool -> Router)\r\n        TransferHelper.safeTransfer(BASE, toPool, iBEP20(BASE).balanceOf(address(this)));\r\n        TransferHelper.safeTransfer(_toToken, toPool, iBEP20(_toToken).balanceOf(address(this)));\r\n        Pool(toPool).addForMember(_member); // Add liquidity; tsf LPs (Pool -> User)\r\n        _safetyTrigger(fromPool); // Check fromPool ratios\r\n        _safetyTrigger(toPool); // Check toPool ratios\r\n    }\r\n\r\n    // User removes liquidity - redeems exact qty of LP tokens\r\n    function removeLiquidityExact(uint units, address token) public {\r\n        require(units > 0, '!VALID'); // Must be a valid amount\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        address _pool = _poolFactory.getPool(token); // Get the pool address\r\n        if(_poolFactory.isCuratedPool(_pool)){\r\n            require(Pool(_pool).freeze() == false);\r\n        }\r\n        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid\r\n        address _member = msg.sender; // Get user's address\r\n        TransferHelper.safeTransferFrom(_pool, _member, _pool, units);\r\n        if(token != address(0)){\r\n            Pool(_pool).removeForMember(_member, _member); // If not BNB; remove liquidity; tsf SPARTA and TOKEN (Pool -> User)\r\n        } else {\r\n            Pool(_pool).removeForMember(address(this), _member); // If BNB; remove liquidity; tsf SPARTA and WBNB (Pool -> Router)\r\n            uint outputBase = iBEP20(BASE).balanceOf(address(this)); // Check the received SPARTA amount (Router)\r\n            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); // Check the received WBNB amount (Router)\r\n            _handleTransferOut(token, outputToken, _member); // Unwrap to BNB & tsf (Router -> User)\r\n            _handleTransferOut(BASE, outputBase, _member); // Tsf SPARTA (Router -> User)\r\n        }\r\n        _safetyTrigger(_pool); // Check pool ratio\r\n\r\n    }\r\n\r\n    function removeLiquidityExactAsym(uint units, bool toBase, address token) public {\r\n        require(units > 0, '!VALID'); // Must be a valid amount\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        address _pool = _poolFactory.getPool(token); // Get pool address\r\n        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid\r\n        require(Pool(_pool).freeze() == false); \r\n        address _member = msg.sender; // Get user's address\r\n        TransferHelper.safeTransferFrom(_pool, _member, _pool, units);\r\n        Pool(_pool).removeForMember(address(this),_member); // Remove liquidity; tsf SPARTA and TOKEN (Wrapped) (Pool -> Router)\r\n        address _token = token; // Get token address\r\n        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\r\n        uint fee;\r\n        if(toBase){\r\n            TransferHelper.safeTransfer(_token, _pool, iBEP20(_token).balanceOf(address(this)));\r\n            (, fee) = Pool(_pool).swapTo(BASE, address(this)); // Swap TOKEN (Wrapped) to SPARTA (Pool -> Router)\r\n             TransferHelper.safeTransfer(BASE, _member, iBEP20(BASE).balanceOf(address(this)));\r\n        } else {\r\n            TransferHelper.safeTransfer(BASE, _pool, iBEP20(BASE).balanceOf(address(this)));\r\n            (, fee) = Pool(_pool).swapTo(_token, address(this)); // Swap SPARTA to TOKEN (Pool -> Router)\r\n            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); // Tsf total TOKEN (Router -> User)\r\n        } \r\n        _safetyTrigger(_pool); // Check pool ratios\r\n        _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)\r\n    }\r\n \r\n    //============================== Swapping Functions ====================================//\r\n    \r\n    // Swap SPARTA for TOKEN\r\n    function buyTo(uint amount, address token, address member, uint minAmount) public {\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        address _pool = _poolFactory.getPool(token); // Get the pool address\r\n        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid\r\n        _handleTransferIn(BASE, amount, _pool); // Tsf SPARTA (User -> Pool)\r\n        uint fee;\r\n        if(token != address(0)){\r\n            (uint output, uint feey) = Pool(_pool).swapTo(token, member); // If not BNB; swap SPARTA to TOKEN (Pool -> User)\r\n            require(output >= minAmount, '!RATE'); // Revert if output is too low\r\n            fee = feey;\r\n        } else {\r\n            (uint output, uint feez) = Pool(_pool).swapTo(WBNB, address(this)); // If BNB; Swap SPARTA to WBNB (Pool -> Router)\r\n            require(output >= minAmount, '!RATE'); // Revert if output is too low\r\n            _handleTransferOut(token, output, member); // Unwrap to BNB & tsf (Router -> User)\r\n            fee = feez;\r\n        }\r\n        _safetyTrigger(_pool); // Check pool ratios\r\n        _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)\r\n    }\r\n\r\n    // Swap TOKEN for SPARTA\r\n    function sellTo(uint amount, address token, address member, uint minAmount, bool yesDiv) public payable returns (uint){\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        address _pool = _poolFactory.getPool(token); // Get pool address\r\n        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid\r\n        _handleTransferIn(token, amount, _pool); // Tsf TOKEN (Not wrapped) (User -> Pool)\r\n        (uint output, uint fee) = Pool(_pool).swapTo(BASE, member); // Swap TOKEN to SPARTA (Pool -> User)\r\n        require(output >= minAmount, '!RATE'); // Revert if output is too low\r\n        _safetyTrigger(_pool); // Check pool ratios\r\n        if(yesDiv){\r\n             _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)\r\n        }\r\n        return fee;\r\n    }\r\n\r\n    // User performs a simple swap (to -> from)\r\n    function swap(uint256 inputAmount, address fromToken, address toToken, uint256 minAmount) external payable{\r\n        swapTo(inputAmount, fromToken, toToken, msg.sender, minAmount);\r\n    }\r\n\r\n    // Contract checks which swap function the user will require\r\n    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member, uint256 minAmount) public payable{\r\n        require(fromToken != toToken); // Tokens must not be the same\r\n        if(fromToken == BASE){\r\n            buyTo(inputAmount, toToken, member, minAmount); // Swap SPARTA to TOKEN (User -> Pool -> User)\r\n        } else if(toToken == BASE) {\r\n            sellTo(inputAmount, fromToken, member, minAmount, true); // Swap TOKEN to SPARTA (User -> Pool -> User)\r\n        } else {\r\n            iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n            address _poolTo = _poolFactory.getPool(toToken); // Get pool address\r\n            require(_poolFactory.isPool(_poolTo) == true, '!POOL'); // Pool must be valid\r\n            sellTo(inputAmount, fromToken, _poolTo, 0, false); // Swap TOKEN (Not wrapped) to SPARTA (User -> fromPool -> toPool)\r\n            address _toToken = toToken;\r\n            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB -> WBNB\r\n            (uint _zz, uint _feez) = Pool(_poolTo).swapTo(_toToken, address(this)); // Swap SPARTA to TOKEN (Wrapped) (toPool -> Router)\r\n            require(_zz >= minAmount, '!RATE'); // Revert if output is too low\r\n            _safetyTrigger(_poolTo); // Check pool ratios\r\n            _handleTransferOut(toToken, iBEP20(_toToken).balanceOf(address(this)), member); // Tsf TOKEN (Unwrapped) (Router -> User)\r\n            _getsDividend(_poolTo, _feez); // Check for dividend & tsf (Reserve -> Pool)\r\n        }\r\n    }\r\n\r\n    //================================ Swap Synths ========================================//\r\n    \r\n    // Swap TOKEN to Synth\r\n    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {\r\n        require(inputAmount > 0, '!VALID'); // Must be a valid amount\r\n        require(fromToken != toSynth); // Tokens must not be the same\r\n        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze\r\n        address _pool = iSYNTH(toSynth).POOL(); // Get underlying pool address\r\n        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true, '!POOL'); // Pool must be valid\r\n        if(fromToken != BASE){\r\n            sellTo(inputAmount, fromToken, address(this), 0, false); // Swap TOKEN to SPARTA (User -> Pool -> Router)\r\n           TransferHelper.safeTransfer(BASE, _pool, iBEP20(BASE).balanceOf(address(this)));\r\n        } else {\r\n             TransferHelper.safeTransferFrom(BASE, msg.sender, _pool, inputAmount);\r\n        }\r\n        (, uint fee) = Pool(_pool).mintSynth(msg.sender); // Swap SPARTA for SYNTH (Pool -> User)\r\n        _safetyTrigger(_pool); // Check pool ratios\r\n        _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)\r\n        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze\r\n    }\r\n   \r\n    // Swap Synth to TOKEN\r\n    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {\r\n        require(inputAmount > 0, '!VALID'); // Must be a valid amount\r\n        require(fromSynth != toToken); // Tokens must not be the same\r\n        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze\r\n        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory\r\n        address _synthPool = iSYNTH(fromSynth).POOL(); // Get underlying synthPool address\r\n        require(_poolFactory.isPool(_synthPool) == true, '!POOL'); // synthPool must be valid\r\n        TransferHelper.safeTransferFrom(fromSynth, msg.sender, _synthPool, inputAmount);\r\n        uint synthFee;\r\n        if(toToken == BASE){\r\n            (, synthFee) = Pool(_synthPool).burnSynth(msg.sender, msg.sender); // Swap SYNTH to SPARTA (synthPool -> User)\r\n        } else {\r\n             address _swapPool = _poolFactory.getPool(toToken); // Get TOKEN's relevant swapPool address\r\n               require(_poolFactory.isPool(_swapPool) == true, '!POOL'); // swapPool must be valid\r\n               uint swapFee;\r\n               uint outputAmountY;\r\n            (, synthFee) = Pool(_synthPool).burnSynth(address(this), msg.sender); // Swap SYNTH to SPARTA (synthPool -> Router)\r\n                _handleTransferOut(BASE, iBEP20(BASE).balanceOf(address(this)), _swapPool); // Tsf SPARTA (Router -> swapPool)\r\n            if(toToken != address(0)){\r\n                (, swapFee) = Pool(_swapPool).swapTo(toToken, msg.sender); // Swap SPARTA to TOKEN (swapPool -> User)\r\n            } else {\r\n                (outputAmountY, swapFee) = Pool(_swapPool).swapTo(WBNB, address(this)); // Swap SPARTA to WBNB (swapPool -> Router)\r\n                _handleTransferOut(toToken, outputAmountY, msg.sender); // Tsf BNB (Unwrapped) (Router -> User)\r\n            }\r\n            _safetyTrigger(_swapPool); // Check swapPool ratios\r\n            _getsDividend(_swapPool, swapFee); // Check for dividend & tsf (Reserve -> swapPool)\r\n        }\r\n        _safetyTrigger(_synthPool); // Check synthPool ratios\r\n        _getsDividend(_synthPool, synthFee); // Check for dividend & tsf (Reserve -> synthPool)\r\n        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze\r\n    }\r\n\r\n    //============================== Token Transfer Functions ======================================//\r\n    \r\n    // Handle the transfer of assets from user (wrap BNB)\r\n    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal nonReentrant {\r\n        require(_amount > 0, '!GAS'); // Amount must be valid\r\n        if(_token == address(0)){\r\n            require((_amount == msg.value)); // Amount must be == msg.value\r\n            TransferHelper.safeTransferBNB(WBNB,  _amount);\r\n            TransferHelper.safeTransfer(WBNB, _pool, _amount);\r\n        } else {\r\n            TransferHelper.safeTransferFrom(_token, msg.sender, _pool, _amount);\r\n        }\r\n    }\r\n\r\n    // Handle the transfer of assets to user (Unwrap BNB)\r\n    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal nonReentrant {\r\n        if(_amount > 0) {\r\n            if (_token == address(0)) {\r\n                iWBNB(WBNB).withdraw(_amount); // Unwrap WBNB to BNB (Router -> Router)\r\n                TransferHelper.safeTransferBNB( _recipient,  _amount);\r\n            } else {\r\n                TransferHelper.safeTransfer(_token, _recipient, _amount);\r\n            }\r\n        }\r\n    }\r\n    \r\n    //============================= Token Dividends / Curated Pools =================================//\r\n\r\n    // Check if fee should generate a dividend & send it to the pool\r\n    function _getsDividend(address _pool, uint fee) internal {\r\n        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){\r\n            if(fee < minDiv){\r\n                fee = minDiv;\r\n            }\r\n            _addDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)\r\n        }\r\n    }\r\n\r\n    // Calculate the Dividend and transfer it to the pool\r\n    function _addDividend(address _pool, uint256 _fees) internal {\r\n        uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); // Get SPARTA balance in the RESERVE contract\r\n        bool emissions = iRESERVE(_DAO().RESERVE()).emissions();\r\n        if(reserve > 0 && emissions){\r\n           uint256 _curatedPoolsCount = iPOOLFACTORY(_DAO().POOLFACTORY()).curatedPoolCount(); \r\n           if(_curatedPoolsCount != curatedPoolsCount){\r\n               curatedPoolsCount = _curatedPoolsCount;\r\n           }\r\n            uint256 _dividendReward = (reserve * diviClaim) / _curatedPoolsCount / 10000; // Get the dividend share \r\n            if((mapAddress_30DayDividends[_pool] + _fees) < _dividendReward){\r\n                _revenueDetails(_fees, _pool); // Add to revenue metrics\r\n                iRESERVE(_DAO().RESERVE()).grantFunds(_fees, _pool); // Tsf SPARTA dividend (Reserve -> Pool)\r\n                Pool(_pool).sync(); // Sync the pool balances to attribute the dividend to the existing LPers\r\n                emit Dividend(_pool, _fees); \r\n            }\r\n        }\r\n    }\r\n\r\n    function _revenueDetails(uint _fees, address _pool) internal {\r\n        if(lastMonth == 0){\r\n            lastMonth = block.timestamp;\r\n        }\r\n        if(block.timestamp <= lastMonth + 2592000){ // 30 days\r\n            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;\r\n        } else {\r\n            lastMonth = block.timestamp;\r\n            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];\r\n            mapAddress_30DayDividends[_pool] = _fees;\r\n        }\r\n    }\r\n    function _migrateRevenue(address oldRouter) external onlyDAO {\r\n        lastMonth = iROUTER(oldRouter).lastMonth();  \r\n        address [] memory pools = iPOOLFACTORY(_DAO().POOLFACTORY()).getPoolAssets(); \r\n        for(uint i = 0; i < pools.length; i++){\r\n            mapAddress_30DayDividends[pools[i]] = iROUTER(oldRouter).mapAddress_30DayDividends(pools[i]);  \r\n            mapAddress_Past30DayPoolDividends[pools[i]] = iROUTER(oldRouter).mapAddress_Past30DayPoolDividends(pools[i]);   \r\n        }\r\n    }\r\n    \r\n    //======================= Change Dividend Variables ===========================//\r\n\r\n    function changeDiviClaim(uint _newDiviClaim, uint _newDivFee) external onlyDAO {\r\n        require(_newDiviClaim > 0 && _newDiviClaim < 5000, '!VALID');\r\n        require(_newDivFee < 1000, '!VALID');\r\n        diviClaim = _newDiviClaim;\r\n        minDiv = _newDivFee * 10**18;\r\n    }\r\n\r\n    function changeSynthCap(uint synthCap, address _pool) external onlyDAO {\r\n        Pool(_pool).setSynthCap(synthCap);\r\n    }\r\n\r\n    function RTC(uint poolRTC, address _pool) external onlyDAO {\r\n        Pool(_pool).RTC(poolRTC);\r\n    }\r\n    function flipSynthMinting() external onlyDAO {\r\n        synthMinting = !synthMinting;\r\n    }\r\n    function syncPool(address _pool, uint256 amount) external onlyRESERVE {\r\n        address _token = Pool(_pool).TOKEN();\r\n        uint256 baseValue = iUTILS(_DAO().UTILS()).calcSpotValueInBase(_token, amount);\r\n        _revenueDetails(baseValue, _pool);\r\n        Pool(_pool).sync(); // Sync the pool balances to attribute reward to the LPers\r\n    }\r\n\r\n    function _safetyTrigger(address _pool) internal {\r\n        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool)){\r\n            if(Pool(_pool).freeze()){\r\n                iRESERVE(_DAO().RESERVE()).setGlobalFreeze(true);   \r\n            } \r\n            if(iRESERVE(_DAO().RESERVE()).globalFreeze()){\r\n                uint256 freezeTime = iRESERVE(_DAO().RESERVE()).freezeTime(); \r\n                if(block.timestamp > freezeTime + 3600){\r\n                   iRESERVE(_DAO().RESERVE()).setGlobalFreeze(false);   \r\n                }\r\n              }\r\n        }\r\n    }\r\n\r\n\r\n    function updatePoolStatus() external {\r\n       if(iRESERVE(_DAO().RESERVE()).globalFreeze()){\r\n        address [] memory _vaultAssets = iPOOLFACTORY(_DAO().POOLFACTORY()).getVaultAssets(); // Get list of vault enabled assets\r\n        bool unfreeze = true;\r\n        for(uint i = 0; i < _vaultAssets.length; i++){\r\n            if(Pool(_vaultAssets[i]).freeze()){\r\n               unfreeze = false;\r\n            }\r\n        }\r\n        if(unfreeze){\r\n           iRESERVE(_DAO().RESERVE()).setGlobalFreeze(false);\r\n        }\r\n    }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbnb\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Dividend\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolRTC\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"RTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldRouter\",\"type\":\"address\"}],\"name\":\"_migrateRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fromBase\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addLiquidityAsym\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_input\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_fromBase\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addLiquidityAsymForMember\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"addLiquidityForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LPsMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"buyTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDiviClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDivFee\",\"type\":\"uint256\"}],\"name\":\"changeDiviClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"synthCap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"changeSynthCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"diviClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipSynthMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapAddress_30DayDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapAddress_Past30DayPoolDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purgeDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeLiquidityExact\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toBase\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeLiquidityExactAsym\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"yesDiv\",\"type\":\"bool\"}],\"name\":\"sellTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toSynth\",\"type\":\"address\"}],\"name\":\"swapAssetToSynth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromSynth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"swapSynthToAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"swapTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"syncPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthMinting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePoolStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitsInput\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toPool\",\"type\":\"address\"}],\"name\":\"zapLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Router", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003910db0600ea925f63c36ddb1351ab6e2c6eb102000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f5528f105bb8cd0e865892a4cf8027df379b47d33f2e1749c535709747e69a93"}