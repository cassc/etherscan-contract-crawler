{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/Common/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/communal/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11 <0.9.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/communal/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/communal/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"lib/communal/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a >= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/communal/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// https://docs.synthetix.io/contracts/Owned\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n    address public nominatedOwner;\\r\\n\\r\\n    constructor (address _owner) public {\\r\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\r\\n        owner = _owner;\\r\\n        emit OwnerChanged(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function nominateNewOwner(address _owner) external onlyOwner {\\r\\n        nominatedOwner = _owner;\\r\\n        emit OwnerNominated(_owner);\\r\\n    }\\r\\n\\r\\n    function acceptOwnership() external {\\r\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\r\\n        emit OwnerChanged(owner, nominatedOwner);\\r\\n        owner = nominatedOwner;\\r\\n        nominatedOwner = address(0);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    event OwnerNominated(address newOwner);\\r\\n    event OwnerChanged(address oldOwner, address newOwner);\\r\\n}\"\r\n    },\r\n    \"lib/communal/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor () internal {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/communal/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/communal/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/communal/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint value) internal {\\r\\n        (bool success,) = to.call{value:value}(new bytes(0));\\r\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/ERC20/ERC20Custom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\nimport \\\"../Common/Context.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"../Math/SafeMath.sol\\\";\\r\\nimport \\\"../Utils/Address.sol\\\";\\r\\n\\r\\n// Due to compiling issues, _name, _symbol, and _decimals were removed\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20Mintable}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20Custom is Context, IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address => uint256) internal _balances;\\r\\n\\r\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20};\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for `sender`'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from the caller.\\r\\n     *\\r\\n     * See {ERC20-_burn}.\\r\\n     */\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(_msgSender(), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have allowance for `accounts`'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function burnFrom(address account, uint256 amount) public virtual {\\r\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\r\\n\\r\\n        _approve(account, _msgSender(), decreasedAllowance);\\r\\n        _burn(account, amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\r\\n     * from the caller's allowance.\\r\\n     *\\r\\n     * See {_burn} and {_approve}.\\r\\n     */\\r\\n    function _burnFrom(address account, uint256 amount) internal virtual {\\r\\n        _burn(account, amount);\\r\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n}\"\r\n    },\r\n    \"lib/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\nimport \\\"../Common/Context.sol\\\";\\r\\nimport \\\"../Math/SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"lib/forge-std/src/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.4.22 <0.9.0;\\r\\n\\r\\nlibrary console {\\r\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\r\\n\\r\\n    function _sendLogPayload(bytes memory payload) private view {\\r\\n        uint256 payloadLength = payload.length;\\r\\n        address consoleAddress = CONSOLE_ADDRESS;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let payloadStart := add(payload, 32)\\r\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function log() internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\r\\n    }\\r\\n\\r\\n    function logInt(int p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logUint(uint p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logString(string memory p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBool(bool p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logAddress(address p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes(bytes memory p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes1(bytes1 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes2(bytes2 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes3(bytes3 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes4(bytes4 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes5(bytes5 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes6(bytes6 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes7(bytes7 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes8(bytes8 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes9(bytes9 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes10(bytes10 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes11(bytes11 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes12(bytes12 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes13(bytes13 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes14(bytes14 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes15(bytes15 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes16(bytes16 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes17(bytes17 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes18(bytes18 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes19(bytes19 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes20(bytes20 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes21(bytes21 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes22(bytes22 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes23(bytes23 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes24(bytes24 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes25(bytes25 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes26(bytes26 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes27(bytes27 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes28(bytes28 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes29(bytes29 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes30(bytes30 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes31(bytes31 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes32(bytes32 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(uint p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(bool p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(address p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"lib/Governance/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\nimport \\\"../Utils/EnumerableSet.sol\\\";\\r\\nimport \\\"../Utils/Address.sol\\\";\\r\\nimport \\\"../Common/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module that allows children to implement role-based access\\r\\n * control mechanisms.\\r\\n *\\r\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\r\\n * in the external API and be unique. The best way to achieve this is by\\r\\n * using `public constant` hash digests:\\r\\n *\\r\\n * ```\\r\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\r\\n * ```\\r\\n *\\r\\n * Roles can be used to represent a set of permissions. To restrict access to a\\r\\n * function call, use {hasRole}:\\r\\n *\\r\\n * ```\\r\\n * function foo() public {\\r\\n *     require(hasRole(MY_ROLE, msg.sender));\\r\\n *     ...\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\r\\n * {revokeRole} functions. Each role has an associated admin role, and only\\r\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\r\\n *\\r\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\r\\n * that only accounts with this role will be able to grant or revoke other\\r\\n * roles. More complex role relationships can be created by using\\r\\n * {_setRoleAdmin}.\\r\\n *\\r\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\r\\n * grant and revoke this role. Extra precautions should be taken to secure\\r\\n * accounts that have been granted it.\\r\\n */\\r\\nabstract contract AccessControl is Context {\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    using Address for address;\\r\\n\\r\\n    struct RoleData {\\r\\n        EnumerableSet.AddressSet members;\\r\\n        bytes32 adminRole;\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 => RoleData) private _roles;\\r\\n\\r\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; //bytes32(uint256(0x4B437D01b575618140442A4975db38850e3f8f5f) << 96);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\r\\n        return _roles[role].members.contains(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of accounts that have `role`. Can be used\\r\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\r\\n     */\\r\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\r\\n        return _roles[role].members.length();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\r\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\r\\n     *\\r\\n     * Role bearers are not sorted in any particular way, and their ordering may\\r\\n     * change at any point.\\r\\n     *\\r\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\r\\n     * you perform all queries on the same block. See the following\\r\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\r\\n     * for more information.\\r\\n     */\\r\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\r\\n        return _roles[role].members.at(index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\r\\n        return _roles[role].adminRole;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) public virtual {\\r\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\r\\n\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) public virtual {\\r\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\r\\n\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) public virtual {\\r\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\r\\n\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\r\\n     * checks on the calling account.\\r\\n     *\\r\\n     * [WARNING]\\r\\n     * ====\\r\\n     * This function should only be called from the constructor when setting\\r\\n     * up the initial roles for the system.\\r\\n     *\\r\\n     * Using this function in any other way is effectively circumventing the admin\\r\\n     * system imposed by {AccessControl}.\\r\\n     * ====\\r\\n     */\\r\\n    function _setupRole(bytes32 role, address account) internal virtual {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\r\\n     *\\r\\n     * Emits a {RoleAdminChanged} event.\\r\\n     */\\r\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\r\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\r\\n        _roles[role].adminRole = adminRole;\\r\\n    }\\r\\n\\r\\n    function _grantRole(bytes32 role, address account) private {\\r\\n        if (_roles[role].members.add(account)) {\\r\\n            emit RoleGranted(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revokeRole(bytes32 role, address account) private {\\r\\n        if (_roles[role].members.remove(account)) {\\r\\n            emit RoleRevoked(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/Math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"../../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\r\\n * instead returning `false` on failure. This behavior is nonetheless\\r\\n * conventional and does not conflict with the expectations of ERC20\\r\\n * applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./draft-IERC20Permit.sol\\\";\\r\\nimport \\\"../ERC20.sol\\\";\\r\\nimport \\\"../../../utils/cryptography/ECDSA.sol\\\";\\r\\nimport \\\"../../../utils/cryptography/EIP712.sol\\\";\\r\\nimport \\\"../../../utils/Counters.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n *\\r\\n * _Available since v3.4._\\r\\n */\\r\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\r\\n    using Counters for Counters.Counter;\\r\\n\\r\\n    mapping(address => Counters.Counter) private _nonces;\\r\\n\\r\\n    // solhint-disable-next-line var-name-mixedcase\\r\\n    bytes32 private constant _PERMIT_TYPEHASH =\\r\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n    /**\\r\\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\\r\\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\\r\\n     * to reserve a slot.\\r\\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\\r\\n     */\\r\\n    // solhint-disable-next-line var-name-mixedcase\\r\\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\r\\n     *\\r\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\r\\n     */\\r\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20Permit-permit}.\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual override {\\r\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20Permit-nonces}.\\r\\n     */\\r\\n    function nonces(address owner) public view virtual override returns (uint256) {\\r\\n        return _nonces[owner].current();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\r\\n        return _domainSeparatorV4();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\r\\n     *\\r\\n     * _Available since v4.1._\\r\\n     */\\r\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\r\\n        Counters.Counter storage nonce = _nonces[owner];\\r\\n        current = nonce.current();\\r\\n        nonce.increment();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\r\\n     * given ``owner``'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../ERC20.sol\\\";\\r\\nimport \\\"../../../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\r\\n * tokens and those that they have an allowance for, in a way that can be\\r\\n * recognized off-chain (via event analysis).\\r\\n */\\r\\nabstract contract ERC20Burnable is Context, ERC20 {\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from the caller.\\r\\n     *\\r\\n     * See {ERC20-_burn}.\\r\\n     */\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(_msgSender(), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function burnFrom(address account, uint256 amount) public virtual {\\r\\n        _spendAllowance(account, _msgSender(), amount);\\r\\n        _burn(account, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\r\\nimport \\\"../../../utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safePermit(\\r\\n        IERC20Permit token,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal {\\r\\n        uint256 nonceBefore = token.nonces(owner);\\r\\n        token.permit(owner, spender, value, deadline, v, r, s);\\r\\n        uint256 nonceAfter = token.nonces(owner);\\r\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Counters\\r\\n * @author Matt Condon (@shrugs)\\r\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\r\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\r\\n *\\r\\n * Include with `using Counters for Counters.Counter;`\\r\\n */\\r\\nlibrary Counters {\\r\\n    struct Counter {\\r\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\r\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\r\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\r\\n        uint256 _value; // default: 0\\r\\n    }\\r\\n\\r\\n    function current(Counter storage counter) internal view returns (uint256) {\\r\\n        return counter._value;\\r\\n    }\\r\\n\\r\\n    function increment(Counter storage counter) internal {\\r\\n        unchecked {\\r\\n            counter._value += 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function decrement(Counter storage counter) internal {\\r\\n        uint256 value = counter._value;\\r\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\r\\n        unchecked {\\r\\n            counter._value = value - 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function reset(Counter storage counter) internal {\\r\\n        counter._value = 0;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../Strings.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n */\\r\\nlibrary ECDSA {\\r\\n    enum RecoverError {\\r\\n        NoError,\\r\\n        InvalidSignature,\\r\\n        InvalidSignatureLength,\\r\\n        InvalidSignatureS,\\r\\n        InvalidSignatureV // Deprecated in v4.8\\r\\n    }\\r\\n\\r\\n    function _throwError(RecoverError error) private pure {\\r\\n        if (error == RecoverError.NoError) {\\r\\n            return; // no error: do nothing\\r\\n        } else if (error == RecoverError.InvalidSignature) {\\r\\n            revert(\\\"ECDSA: invalid signature\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\r\\n            revert(\\\"ECDSA: invalid signature length\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureS) {\\r\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature` or error string. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n     *\\r\\n     * Documentation for signature generation:\\r\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\r\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\r\\n        if (signature.length == 65) {\\r\\n            bytes32 r;\\r\\n            bytes32 s;\\r\\n            uint8 v;\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := mload(add(signature, 0x40))\\r\\n                v := byte(0, mload(add(signature, 0x60)))\\r\\n            }\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        } else {\\r\\n            return (address(0), RecoverError.InvalidSignatureLength);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature`. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\r\\n        _throwError(error);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\r\\n     *\\r\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        bytes32 r,\\r\\n        bytes32 vs\\r\\n    ) internal pure returns (address, RecoverError) {\\r\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\r\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\r\\n        return tryRecover(hash, v, r, s);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function recover(\\r\\n        bytes32 hash,\\r\\n        bytes32 r,\\r\\n        bytes32 vs\\r\\n    ) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\r\\n        _throwError(error);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address, RecoverError) {\\r\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\r\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n        //\\r\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n        // these malleable signatures as well.\\r\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\r\\n            return (address(0), RecoverError.InvalidSignatureS);\\r\\n        }\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        if (signer == address(0)) {\\r\\n            return (address(0), RecoverError.InvalidSignature);\\r\\n        }\\r\\n\\r\\n        return (signer, RecoverError.NoError);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function recover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\r\\n        _throwError(error);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\r\\n     * produces hash corresponding to the one signed with the\\r\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\r\\n     * JSON-RPC method as part of EIP-191.\\r\\n     *\\r\\n     * See {recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\r\\n        // 32 is the length in bytes of hash,\\r\\n        // enforced by the type signature above\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\r\\n     * produces hash corresponding to the one signed with the\\r\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\r\\n     * JSON-RPC method as part of EIP-191.\\r\\n     *\\r\\n     * See {recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\r\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\r\\n     * to the one signed with the\\r\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\r\\n     * JSON-RPC method as part of EIP-712.\\r\\n     *\\r\\n     * See {recover}.\\r\\n     */\\r\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ECDSA.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\r\\n *\\r\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\r\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\r\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\r\\n *\\r\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\r\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\r\\n * ({_hashTypedDataV4}).\\r\\n *\\r\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\r\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\r\\n *\\r\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\r\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\r\\n *\\r\\n * _Available since v3.4._\\r\\n */\\r\\nabstract contract EIP712 {\\r\\n    /* solhint-disable var-name-mixedcase */\\r\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\r\\n    // invalidate the cached domain separator if the chain id changes.\\r\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\r\\n    uint256 private immutable _CACHED_CHAIN_ID;\\r\\n    address private immutable _CACHED_THIS;\\r\\n\\r\\n    bytes32 private immutable _HASHED_NAME;\\r\\n    bytes32 private immutable _HASHED_VERSION;\\r\\n    bytes32 private immutable _TYPE_HASH;\\r\\n\\r\\n    /* solhint-enable var-name-mixedcase */\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the domain separator and parameter caches.\\r\\n     *\\r\\n     * The meaning of `name` and `version` is specified in\\r\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\r\\n     *\\r\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\r\\n     * - `version`: the current major version of the signing domain.\\r\\n     *\\r\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\r\\n     * contract upgrade].\\r\\n     */\\r\\n    constructor(string memory name, string memory version) {\\r\\n        bytes32 hashedName = keccak256(bytes(name));\\r\\n        bytes32 hashedVersion = keccak256(bytes(version));\\r\\n        bytes32 typeHash = keccak256(\\r\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\r\\n        );\\r\\n        _HASHED_NAME = hashedName;\\r\\n        _HASHED_VERSION = hashedVersion;\\r\\n        _CACHED_CHAIN_ID = block.chainid;\\r\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\r\\n        _CACHED_THIS = address(this);\\r\\n        _TYPE_HASH = typeHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator for the current chain.\\r\\n     */\\r\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\r\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\r\\n            return _CACHED_DOMAIN_SEPARATOR;\\r\\n        } else {\\r\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _buildDomainSeparator(\\r\\n        bytes32 typeHash,\\r\\n        bytes32 nameHash,\\r\\n        bytes32 versionHash\\r\\n    ) private view returns (bytes32) {\\r\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\r\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\r\\n     *\\r\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\r\\n     *\\r\\n     * ```solidity\\r\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\r\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\r\\n     *     mailTo,\\r\\n     *     keccak256(bytes(mailContents))\\r\\n     * )));\\r\\n     * address signer = ECDSA.recover(digest, signature);\\r\\n     * ```\\r\\n     */\\r\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\r\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    enum Rounding {\\r\\n        Down, // Toward negative infinity\\r\\n        Up, // Toward infinity\\r\\n        Zero // Toward zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds up instead\\r\\n     * of rounding down.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\r\\n     * with further edits by Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod0 := mul(x, y)\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            require(denominator > prod1);\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\r\\n            // See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n            uint256 twos = denominator & (~denominator + 1);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\r\\n            // in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 denominator,\\r\\n        Rounding rounding\\r\\n    ) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\r\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\r\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 << (log2(a) >> 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                value >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 4 > 0) {\\r\\n                value >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 2 > 0) {\\r\\n                value >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 1 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10**64) {\\r\\n                value /= 10**64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10**32) {\\r\\n                value /= 10**32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10**16) {\\r\\n                value /= 10**16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10**8) {\\r\\n                value /= 10**8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10**4) {\\r\\n                value /= 10**4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10**2) {\\r\\n                value /= 10**2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10**1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations.\\r\\n *\\r\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SignedSafeMath {\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two signed integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a + b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./math/Math.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            uint256 length = Math.log10(value) + 1;\\r\\n            string memory buffer = new string(length);\\r\\n            uint256 ptr;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                ptr := add(buffer, add(32, length))\\r\\n            }\\r\\n            while (true) {\\r\\n                ptr--;\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\r\\n                }\\r\\n                value /= 10;\\r\\n                if (value == 0) break;\\r\\n            }\\r\\n            return buffer;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            return toHexString(value, Math.log256(value) + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"../../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\r\\n * instead returning `false` on failure. This behavior is nonetheless\\r\\n * conventional and does not conflict with the expectations of ERC20\\r\\n * applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n        }\\r\\n        _balances[to] += amount;\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n        }\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\r\\n     * given ``owner``'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\r\\nimport \\\"../../../utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safePermit(\\r\\n        IERC20Permit token,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal {\\r\\n        uint256 nonceBefore = token.nonces(owner);\\r\\n        token.permit(owner, spender, value, deadline, v, r, s);\\r\\n        uint256 nonceAfter = token.nonces(owner);\\r\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/utils/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations.\\r\\n *\\r\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SignedSafeMath {\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two signed integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a + b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/prb-math/src/Core.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\n/// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\\r\\n/// always operate with SD59x18 and UD60x18 numbers.\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                                CUSTOM ERRORS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\n/// @notice Emitted when the ending result in the fixed-point version of `mulDiv` would overflow uint256.\\r\\nerror PRBMath__MulDiv18Overflow(uint256 x, uint256 y);\\r\\n\\r\\n/// @notice Emitted when the ending result in `mulDiv` would overflow uint256.\\r\\nerror PRBMath__MulDivOverflow(uint256 x, uint256 y, uint256 denominator);\\r\\n\\r\\n/// @notice Emitted when attempting to run `mulDiv` with one of the inputs `type(int256).min`.\\r\\nerror PRBMath__MulDivSignedInputTooSmall();\\r\\n\\r\\n/// @notice Emitted when the ending result in the signed version of `mulDiv` would overflow int256.\\r\\nerror PRBMath__MulDivSignedOverflow(int256 x, int256 y);\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                                    CONSTANTS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\n/// @dev How many trailing decimals can be represented.\\r\\nuint256 constant UNIT = 1e18;\\r\\n\\r\\n/// @dev Largest power of two that is a divisor of `UNIT`.\\r\\nuint256 constant UNIT_LPOTD = 262144;\\r\\n\\r\\n/// @dev The `UNIT` number inverted mod 2^256.\\r\\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                                    FUNCTIONS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\n/// @notice Finds the zero-based index of the first one in the binary representation of x.\\r\\n/// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\r\\n///\\r\\n/// Each of the steps in this implementation is equivalent to this high-level code:\\r\\n///\\r\\n/// ```solidity\\r\\n/// if (x >= 2 ** 128) {\\r\\n///     x >>= 128;\\r\\n///     result += 128;\\r\\n/// }\\r\\n/// ```\\r\\n///\\r\\n/// Where 128 is swapped with each respective power of two factor. See the full high-level implementation here:\\r\\n/// https://gist.github.com/paulrberg/f932f8693f2733e30c4d479e8e980948\\r\\n///\\r\\n/// A list of the Yul instructions used below:\\r\\n/// - \\\"gt\\\" is \\\"greater than\\\"\\r\\n/// - \\\"or\\\" is the OR bitwise operator\\r\\n/// - \\\"shl\\\" is \\\"shift left\\\"\\r\\n/// - \\\"shr\\\" is \\\"shift right\\\"\\r\\n///\\r\\n/// @param x The uint256 number for which to find the index of the most significant bit.\\r\\n/// @return result The index of the most significant bit as an uint256.\\r\\nfunction msb(uint256 x) pure returns (uint256 result) {\\r\\n    // 2^128\\r\\n    assembly {\\r\\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\r\\n        x := shr(factor, x)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n    // 2^64\\r\\n    assembly {\\r\\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\\r\\n        x := shr(factor, x)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n    // 2^32\\r\\n    assembly {\\r\\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\\r\\n        x := shr(factor, x)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n    // 2^16\\r\\n    assembly {\\r\\n        let factor := shl(4, gt(x, 0xFFFF))\\r\\n        x := shr(factor, x)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n    // 2^8\\r\\n    assembly {\\r\\n        let factor := shl(3, gt(x, 0xFF))\\r\\n        x := shr(factor, x)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n    // 2^4\\r\\n    assembly {\\r\\n        let factor := shl(2, gt(x, 0xF))\\r\\n        x := shr(factor, x)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n    // 2^2\\r\\n    assembly {\\r\\n        let factor := shl(1, gt(x, 0x3))\\r\\n        x := shr(factor, x)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n    // 2^1\\r\\n    // No need to shift x any more.\\r\\n    assembly {\\r\\n        let factor := gt(x, 0x1)\\r\\n        result := or(result, factor)\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\r\\n///\\r\\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\r\\n///\\r\\n/// Requirements:\\r\\n/// - The denominator cannot be zero.\\r\\n/// - The result must fit within uint256.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - This function does not work with fixed-point numbers.\\r\\n///\\r\\n/// @param x The multiplicand as an uint256.\\r\\n/// @param y The multiplier as an uint256.\\r\\n/// @param denominator The divisor as an uint256.\\r\\n/// @return result The result as an uint256.\\r\\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\\r\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n    // variables such that product = prod1 * 2^256 + prod0.\\r\\n    uint256 prod0; // Least significant 256 bits of the product\\r\\n    uint256 prod1; // Most significant 256 bits of the product\\r\\n    assembly {\\r\\n        let mm := mulmod(x, y, not(0))\\r\\n        prod0 := mul(x, y)\\r\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n    }\\r\\n\\r\\n    // Handle non-overflow cases, 256 by 256 division.\\r\\n    if (prod1 == 0) {\\r\\n        unchecked {\\r\\n            return prod0 / denominator;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n    if (prod1 >= denominator) {\\r\\n        revert PRBMath__MulDivOverflow(x, y, denominator);\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////\\r\\n    // 512 by 256 division.\\r\\n    ///////////////////////////////////////////////\\r\\n\\r\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n    uint256 remainder;\\r\\n    assembly {\\r\\n        // Compute remainder using the mulmod Yul instruction.\\r\\n        remainder := mulmod(x, y, denominator)\\r\\n\\r\\n        // Subtract 256 bit number from 512 bit number.\\r\\n        prod1 := sub(prod1, gt(remainder, prod0))\\r\\n        prod0 := sub(prod0, remainder)\\r\\n    }\\r\\n\\r\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\r\\n    // See https://cs.stackexchange.com/q/138556/92363.\\r\\n    unchecked {\\r\\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n        uint256 lpotdod = denominator & (~denominator + 1);\\r\\n        assembly {\\r\\n            // Divide denominator by lpotdod.\\r\\n            denominator := div(denominator, lpotdod)\\r\\n\\r\\n            // Divide [prod1 prod0] by lpotdod.\\r\\n            prod0 := div(prod0, lpotdod)\\r\\n\\r\\n            // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\r\\n            lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\r\\n        }\\r\\n\\r\\n        // Shift in bits from prod1 into prod0.\\r\\n        prod0 |= prod1 * lpotdod;\\r\\n\\r\\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n        // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n        uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\r\\n        // in modular arithmetic, doubling the correct bits in each step.\\r\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n        // is no longer required.\\r\\n        result = prod0 * inverse;\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates floor(x*y\u00f71e18) with full precision.\\r\\n///\\r\\n/// @dev Variant of `mulDiv` with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\r\\n/// final result, we add 1 if `(x * y) % UNIT >= HALF_UNIT`. Without this adjustment, 6.6e-19 would be truncated to 0\\r\\n/// instead of being rounded to 1e-18. See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\r\\n///\\r\\n/// Requirements:\\r\\n/// - The result must fit within uint256.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - The body is purposely left uncommented; to understand how this works, see the NatSpec comments in `mulDiv`.\\r\\n/// - It is assumed that the result can never be `type(uint256).max` when x and y solve the following two equations:\\r\\n///     1. x * y = type(uint256).max * UNIT\\r\\n///     2. (x * y) % UNIT >= UNIT / 2\\r\\n///\\r\\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\r\\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\r\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\r\\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\\r\\n    uint256 prod0;\\r\\n    uint256 prod1;\\r\\n    assembly {\\r\\n        let mm := mulmod(x, y, not(0))\\r\\n        prod0 := mul(x, y)\\r\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n    }\\r\\n\\r\\n    if (prod1 >= UNIT) {\\r\\n        revert PRBMath__MulDiv18Overflow(x, y);\\r\\n    }\\r\\n\\r\\n    uint256 remainder;\\r\\n    assembly {\\r\\n        remainder := mulmod(x, y, UNIT)\\r\\n    }\\r\\n\\r\\n    if (prod1 == 0) {\\r\\n        unchecked {\\r\\n            return prod0 / UNIT;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    assembly {\\r\\n        result := mul(\\r\\n            or(\\r\\n                div(sub(prod0, remainder), UNIT_LPOTD),\\r\\n                mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\\r\\n            ),\\r\\n            UNIT_INVERSE\\r\\n        )\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\r\\n///\\r\\n/// @dev An extension of `mulDiv` for signed numbers. Works by computing the signs and the absolute values separately.\\r\\n///\\r\\n/// Requirements:\\r\\n/// - None of the inputs can be `type(int256).min`.\\r\\n/// - The result must fit within int256.\\r\\n///\\r\\n/// @param x The multiplicand as an int256.\\r\\n/// @param y The multiplier as an int256.\\r\\n/// @param denominator The divisor as an int256.\\r\\n/// @return result The result as an int256.\\r\\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\\r\\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\r\\n        revert PRBMath__MulDivSignedInputTooSmall();\\r\\n    }\\r\\n\\r\\n    // Get hold of the absolute values of x, y and the denominator.\\r\\n    uint256 absX;\\r\\n    uint256 absY;\\r\\n    uint256 absD;\\r\\n    unchecked {\\r\\n        absX = x < 0 ? uint256(-x) : uint256(x);\\r\\n        absY = y < 0 ? uint256(-y) : uint256(y);\\r\\n        absD = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\r\\n    }\\r\\n\\r\\n    // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\\r\\n    uint256 rAbs = mulDiv(absX, absY, absD);\\r\\n    if (rAbs > uint256(type(int256).max)) {\\r\\n        revert PRBMath__MulDivSignedOverflow(x, y);\\r\\n    }\\r\\n\\r\\n    // Get the signs of x, y and the denominator.\\r\\n    uint256 sx;\\r\\n    uint256 sy;\\r\\n    uint256 sd;\\r\\n    assembly {\\r\\n        // This works thanks to two's complement.\\r\\n        // \\\"sgt\\\" stands for \\\"signed greater than\\\" and \\\"sub(0,1)\\\" is max uint256.\\r\\n        sx := sgt(x, sub(0, 1))\\r\\n        sy := sgt(y, sub(0, 1))\\r\\n        sd := sgt(denominator, sub(0, 1))\\r\\n    }\\r\\n\\r\\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\\r\\n    // If there are, the result should be negative. Otherwise, it should be positive.\\r\\n    unchecked {\\r\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\r\\n/// @dev Has to use 192.64-bit fixed-point numbers.\\r\\n/// See https://ethereum.stackexchange.com/a/96594/24693.\\r\\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\r\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\r\\nfunction prbExp2(uint256 x) pure returns (uint256 result) {\\r\\n    unchecked {\\r\\n        // Start from 0.5 in the 192.64-bit fixed-point format.\\r\\n        result = 0x800000000000000000000000000000000000000000000000;\\r\\n\\r\\n        // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\r\\n        // because the initial result is 2^191 and all magic factors are less than 2^65.\\r\\n        if (x & 0xFF00000000000000 > 0) {\\r\\n            if (x & 0x8000000000000000 > 0) {\\r\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\r\\n            }\\r\\n            if (x & 0x4000000000000000 > 0) {\\r\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\r\\n            }\\r\\n            if (x & 0x2000000000000000 > 0) {\\r\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\r\\n            }\\r\\n            if (x & 0x1000000000000000 > 0) {\\r\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\r\\n            }\\r\\n            if (x & 0x800000000000000 > 0) {\\r\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\r\\n            }\\r\\n            if (x & 0x400000000000000 > 0) {\\r\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\r\\n            }\\r\\n            if (x & 0x200000000000000 > 0) {\\r\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\r\\n            }\\r\\n            if (x & 0x100000000000000 > 0) {\\r\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (x & 0xFF000000000000 > 0) {\\r\\n            if (x & 0x80000000000000 > 0) {\\r\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\r\\n            }\\r\\n            if (x & 0x40000000000000 > 0) {\\r\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\r\\n            }\\r\\n            if (x & 0x20000000000000 > 0) {\\r\\n                result = (result * 0x100162F3904051FA1) >> 64;\\r\\n            }\\r\\n            if (x & 0x10000000000000 > 0) {\\r\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\r\\n            }\\r\\n            if (x & 0x8000000000000 > 0) {\\r\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\r\\n            }\\r\\n            if (x & 0x4000000000000 > 0) {\\r\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\r\\n            }\\r\\n            if (x & 0x2000000000000 > 0) {\\r\\n                result = (result * 0x1000162E525EE0547) >> 64;\\r\\n            }\\r\\n            if (x & 0x1000000000000 > 0) {\\r\\n                result = (result * 0x10000B17255775C04) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (x & 0xFF0000000000 > 0) {\\r\\n            if (x & 0x800000000000 > 0) {\\r\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\r\\n            }\\r\\n            if (x & 0x400000000000 > 0) {\\r\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\r\\n            }\\r\\n            if (x & 0x200000000000 > 0) {\\r\\n                result = (result * 0x10000162E43F4F831) >> 64;\\r\\n            }\\r\\n            if (x & 0x100000000000 > 0) {\\r\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\r\\n            }\\r\\n            if (x & 0x80000000000 > 0) {\\r\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\r\\n            }\\r\\n            if (x & 0x40000000000 > 0) {\\r\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\r\\n            }\\r\\n            if (x & 0x20000000000 > 0) {\\r\\n                result = (result * 0x100000162E430E5A2) >> 64;\\r\\n            }\\r\\n            if (x & 0x10000000000 > 0) {\\r\\n                result = (result * 0x1000000B172183551) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (x & 0xFF00000000 > 0) {\\r\\n            if (x & 0x8000000000 > 0) {\\r\\n                result = (result * 0x100000058B90C0B49) >> 64;\\r\\n            }\\r\\n            if (x & 0x4000000000 > 0) {\\r\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\r\\n            }\\r\\n            if (x & 0x2000000000 > 0) {\\r\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\r\\n            }\\r\\n            if (x & 0x1000000000 > 0) {\\r\\n                result = (result * 0x10000000B17217FBB) >> 64;\\r\\n            }\\r\\n            if (x & 0x800000000 > 0) {\\r\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\r\\n            }\\r\\n            if (x & 0x400000000 > 0) {\\r\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\r\\n            }\\r\\n            if (x & 0x200000000 > 0) {\\r\\n                result = (result * 0x10000000162E42FF1) >> 64;\\r\\n            }\\r\\n            if (x & 0x100000000 > 0) {\\r\\n                result = (result * 0x100000000B17217F8) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (x & 0xFF00000000 > 0) {\\r\\n            if (x & 0x80000000 > 0) {\\r\\n                result = (result * 0x10000000058B90BFC) >> 64;\\r\\n            }\\r\\n            if (x & 0x40000000 > 0) {\\r\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\r\\n            }\\r\\n            if (x & 0x20000000 > 0) {\\r\\n                result = (result * 0x100000000162E42FF) >> 64;\\r\\n            }\\r\\n            if (x & 0x10000000 > 0) {\\r\\n                result = (result * 0x1000000000B17217F) >> 64;\\r\\n            }\\r\\n            if (x & 0x8000000 > 0) {\\r\\n                result = (result * 0x100000000058B90C0) >> 64;\\r\\n            }\\r\\n            if (x & 0x4000000 > 0) {\\r\\n                result = (result * 0x10000000002C5C860) >> 64;\\r\\n            }\\r\\n            if (x & 0x2000000 > 0) {\\r\\n                result = (result * 0x1000000000162E430) >> 64;\\r\\n            }\\r\\n            if (x & 0x1000000 > 0) {\\r\\n                result = (result * 0x10000000000B17218) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (x & 0xFF0000 > 0) {\\r\\n            if (x & 0x800000 > 0) {\\r\\n                result = (result * 0x1000000000058B90C) >> 64;\\r\\n            }\\r\\n            if (x & 0x400000 > 0) {\\r\\n                result = (result * 0x100000000002C5C86) >> 64;\\r\\n            }\\r\\n            if (x & 0x200000 > 0) {\\r\\n                result = (result * 0x10000000000162E43) >> 64;\\r\\n            }\\r\\n            if (x & 0x100000 > 0) {\\r\\n                result = (result * 0x100000000000B1721) >> 64;\\r\\n            }\\r\\n            if (x & 0x80000 > 0) {\\r\\n                result = (result * 0x10000000000058B91) >> 64;\\r\\n            }\\r\\n            if (x & 0x40000 > 0) {\\r\\n                result = (result * 0x1000000000002C5C8) >> 64;\\r\\n            }\\r\\n            if (x & 0x20000 > 0) {\\r\\n                result = (result * 0x100000000000162E4) >> 64;\\r\\n            }\\r\\n            if (x & 0x10000 > 0) {\\r\\n                result = (result * 0x1000000000000B172) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (x & 0xFF00 > 0) {\\r\\n            if (x & 0x8000 > 0) {\\r\\n                result = (result * 0x100000000000058B9) >> 64;\\r\\n            }\\r\\n            if (x & 0x4000 > 0) {\\r\\n                result = (result * 0x10000000000002C5D) >> 64;\\r\\n            }\\r\\n            if (x & 0x2000 > 0) {\\r\\n                result = (result * 0x1000000000000162E) >> 64;\\r\\n            }\\r\\n            if (x & 0x1000 > 0) {\\r\\n                result = (result * 0x10000000000000B17) >> 64;\\r\\n            }\\r\\n            if (x & 0x800 > 0) {\\r\\n                result = (result * 0x1000000000000058C) >> 64;\\r\\n            }\\r\\n            if (x & 0x400 > 0) {\\r\\n                result = (result * 0x100000000000002C6) >> 64;\\r\\n            }\\r\\n            if (x & 0x200 > 0) {\\r\\n                result = (result * 0x10000000000000163) >> 64;\\r\\n            }\\r\\n            if (x & 0x100 > 0) {\\r\\n                result = (result * 0x100000000000000B1) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (x & 0xFF > 0) {\\r\\n            if (x & 0x80 > 0) {\\r\\n                result = (result * 0x10000000000000059) >> 64;\\r\\n            }\\r\\n            if (x & 0x40 > 0) {\\r\\n                result = (result * 0x1000000000000002C) >> 64;\\r\\n            }\\r\\n            if (x & 0x20 > 0) {\\r\\n                result = (result * 0x10000000000000016) >> 64;\\r\\n            }\\r\\n            if (x & 0x10 > 0) {\\r\\n                result = (result * 0x1000000000000000B) >> 64;\\r\\n            }\\r\\n            if (x & 0x8 > 0) {\\r\\n                result = (result * 0x10000000000000006) >> 64;\\r\\n            }\\r\\n            if (x & 0x4 > 0) {\\r\\n                result = (result * 0x10000000000000003) >> 64;\\r\\n            }\\r\\n            if (x & 0x2 > 0) {\\r\\n                result = (result * 0x10000000000000001) >> 64;\\r\\n            }\\r\\n            if (x & 0x1 > 0) {\\r\\n                result = (result * 0x10000000000000001) >> 64;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // We're doing two things at the same time:\\r\\n        //\\r\\n        //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\r\\n        //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\r\\n        //      rather than 192.\\r\\n        //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\r\\n        //\\r\\n        // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\r\\n        result *= UNIT;\\r\\n        result >>= (191 - (x >> 64));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates the square root of x, rounding down if x is not a perfect square.\\r\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\r\\n/// Credits to OpenZeppelin for the explanations in code comments below.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - This function does not work with fixed-point numbers.\\r\\n///\\r\\n/// @param x The uint256 number for which to calculate the square root.\\r\\n/// @return result The result as an uint256.\\r\\nfunction prbSqrt(uint256 x) pure returns (uint256 result) {\\r\\n    if (x == 0) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of x.\\r\\n    //\\r\\n    // We know that the \\\"msb\\\" (most significant bit) of x is a power of 2 such that we have:\\r\\n    //\\r\\n    // $$\\r\\n    // msb(x) <= x <= 2*msb(x)$\\r\\n    // $$\\r\\n    //\\r\\n    // We write $msb(x)$ as $2^k$ and we get:\\r\\n    //\\r\\n    // $$\\r\\n    // k = log_2(x)\\r\\n    // $$\\r\\n    //\\r\\n    // Thus we can write the initial inequality as:\\r\\n    //\\r\\n    // $$\\r\\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\\\\\\r\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\\\\\\r\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\\r\\n    // $$\\r\\n    //\\r\\n    // Consequently, $2^{log_2(x) /2}` is a good first approximation of sqrt(x) with at least one correct bit.\\r\\n    uint256 xAux = uint256(x);\\r\\n    result = 1;\\r\\n    if (xAux >= 2 ** 128) {\\r\\n        xAux >>= 128;\\r\\n        result <<= 64;\\r\\n    }\\r\\n    if (xAux >= 2 ** 64) {\\r\\n        xAux >>= 64;\\r\\n        result <<= 32;\\r\\n    }\\r\\n    if (xAux >= 2 ** 32) {\\r\\n        xAux >>= 32;\\r\\n        result <<= 16;\\r\\n    }\\r\\n    if (xAux >= 2 ** 16) {\\r\\n        xAux >>= 16;\\r\\n        result <<= 8;\\r\\n    }\\r\\n    if (xAux >= 2 ** 8) {\\r\\n        xAux >>= 8;\\r\\n        result <<= 4;\\r\\n    }\\r\\n    if (xAux >= 2 ** 4) {\\r\\n        xAux >>= 4;\\r\\n        result <<= 2;\\r\\n    }\\r\\n    if (xAux >= 2 ** 2) {\\r\\n        result <<= 1;\\r\\n    }\\r\\n\\r\\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\\r\\n    // most 128 bits, since  it is the square root of a uint256. Newton's method converges quadratically (precision\\r\\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\\r\\n    // precision into the expected uint128 result.\\r\\n    unchecked {\\r\\n        result = (result + x / result) >> 1;\\r\\n        result = (result + x / result) >> 1;\\r\\n        result = (result + x / result) >> 1;\\r\\n        result = (result + x / result) >> 1;\\r\\n        result = (result + x / result) >> 1;\\r\\n        result = (result + x / result) >> 1;\\r\\n        result = (result + x / result) >> 1;\\r\\n\\r\\n        // Round down the result in case x is not a perfect square.\\r\\n        uint256 roundedDownResult = x / result;\\r\\n        if (result >= roundedDownResult) {\\r\\n            result = roundedDownResult;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/prb-math/src/UD60x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \\\"./Core.sol\\\";\\r\\n\\r\\n/// @notice The unsigned 60.18-decimal fixed-point number representation, which can have up to 60 digits and up to 18 decimals.\\r\\n/// The values of this are bound by the minimum and the maximum values permitted by the Solidity type uint256.\\r\\ntype UD60x18 is uint256;\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                                CUSTOM ERRORS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\n/// @notice Emitted when adding two numbers overflows UD60x18.\\r\\nerror PRBMathUD60x18__AddOverflow(uint256 x, UD60x18 y);\\r\\n\\r\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\r\\nerror PRBMathUD60x18__CeilOverflow(UD60x18 x);\\r\\n\\r\\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\\r\\nerror PRBMathUD60x18__ExpInputTooBig(UD60x18 x);\\r\\n\\r\\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\\r\\nerror PRBMathUD60x18__Exp2InputTooBig(UD60x18 x);\\r\\n\\r\\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows UD60x18.\\r\\nerror PRBMathUD60x18__GmOverflow(UD60x18 x, UD60x18 y);\\r\\n\\r\\n/// @notice Emitted when taking the logarithm of a number less than 1.\\r\\nerror PRBMathUD60x18__LogInputTooSmall(UD60x18 x);\\r\\n\\r\\n/// @notice Emitted when calculating the square root overflows UD60x18.\\r\\nerror PRBMathUD60x18__SqrtOverflow(UD60x18 x);\\r\\n\\r\\n/// @notice Emitted when subtracting one number from another underflows UD60x18.\\r\\nerror PRBMathUD60x18__SubUnderflow(UD60x18 x, UD60x18 y);\\r\\n\\r\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows UD60x18.\\r\\nerror PRBMathUD60x18__ToUD60x18Overflow(uint256 x);\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                                    CONSTANTS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\n/// NOTICE: the \\\"u\\\" prefix stands for \\\"unwrapped\\\".\\r\\n\\r\\n/// @dev Euler's number as an UD60x18 number.\\r\\nUD60x18 constant E = UD60x18.wrap(2_718281828459045235);\\r\\n\\r\\n/// @dev Half the UNIT number.\\r\\nuint256 constant uHALF_UNIT = 0.5e18;\\r\\nUD60x18 constant HALF_UNIT = UD60x18.wrap(uHALF_UNIT);\\r\\n\\r\\n/// @dev log2(10) as an UD60x18 number.\\r\\nuint256 constant uLOG2_10 = 3_321928094887362347;\\r\\nUD60x18 constant LOG2_10 = UD60x18.wrap(uLOG2_10);\\r\\n\\r\\n/// @dev log2(e) as an UD60x18 number.\\r\\nuint256 constant uLOG2_E = 1_442695040888963407;\\r\\nUD60x18 constant LOG2_E = UD60x18.wrap(uLOG2_E);\\r\\n\\r\\n/// @dev The maximum value an UD60x18 number can have.\\r\\nuint256 constant uMAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\r\\nUD60x18 constant MAX_UD60x18 = UD60x18.wrap(uMAX_UD60x18);\\r\\n\\r\\n/// @dev The maximum whole value an UD60x18 number can have.\\r\\nuint256 constant uMAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\r\\nUD60x18 constant MAX_WHOLE_UD60x18 = UD60x18.wrap(uMAX_WHOLE_UD60x18);\\r\\n\\r\\n/// @dev PI as an UD60x18 number.\\r\\nUD60x18 constant PI = UD60x18.wrap(3_141592653589793238);\\r\\n\\r\\n/// @dev The unit amount which implies how many trailing decimals can be represented.\\r\\nuint256 constant uUNIT = 1e18;\\r\\nUD60x18 constant UNIT = UD60x18.wrap(uUNIT);\\r\\n\\r\\n/// @dev Zero as an UD60x18 number.\\r\\nUD60x18 constant ZERO = UD60x18.wrap(0);\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                            MATHEMATICAL FUNCTIONS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\nusing { avg, ceil, div, exp, exp2, floor, frac, gm, inv, ln, log10, log2, mul, pow, powu, sqrt } for UD60x18 global;\\r\\n\\r\\n/// @notice Calculates the arithmetic average of x and y, rounding down.\\r\\n///\\r\\n/// @dev Based on the formula:\\r\\n///\\r\\n/// $$\\r\\n/// avg(x, y) = (x & y) + ((xUint ^ yUint) / 2)\\r\\n/// $$\\r\\n//\\r\\n/// In English, what this formula does is:\\r\\n///\\r\\n/// 1. AND x and y.\\r\\n/// 2. Calculate half of XOR x and y.\\r\\n/// 3. Add the two results together.\\r\\n///\\r\\n/// This technique is known as SWAR, which stands for \\\"SIMD within a register\\\". You can read more about it here:\\r\\n/// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\\r\\n///\\r\\n/// @param x The first operand as an UD60x18 number.\\r\\n/// @param y The second operand as an UD60x18 number.\\r\\n/// @return result The arithmetic average as an UD60x18 number.\\r\\nfunction avg(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n    uint256 yUint = unwrap(y);\\r\\n    unchecked {\\r\\n        result = wrap((xUint & yUint) + ((xUint ^ yUint) >> 1));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Yields the smallest whole UD60x18 number greater than or equal to x.\\r\\n///\\r\\n/// @dev This is optimized for fractional value inputs, because for every whole value there are \\\"1e18 - 1\\\" fractional\\r\\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\r\\n///\\r\\n/// Requirements:\\r\\n/// - x must be less than or equal to `MAX_WHOLE_UD60x18`.\\r\\n///\\r\\n/// @param x The UD60x18 number to ceil.\\r\\n/// @param result The least number greater than or equal to x, as an UD60x18 number.\\r\\nfunction ceil(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n    if (xUint > uMAX_WHOLE_UD60x18) {\\r\\n        revert PRBMathUD60x18__CeilOverflow(x);\\r\\n    }\\r\\n\\r\\n    assembly {\\r\\n        // Equivalent to \\\"x % UNIT\\\" but faster.\\r\\n        let remainder := mod(x, uUNIT)\\r\\n\\r\\n        // Equivalent to \\\"UNIT - remainder\\\" but faster.\\r\\n        let delta := sub(uUNIT, remainder)\\r\\n\\r\\n        // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\r\\n        result := add(x, mul(delta, gt(remainder, 0)))\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Divides two UD60x18 numbers, returning a new UD60x18 number. Rounds towards zero.\\r\\n///\\r\\n/// @dev Uses `mulDiv` to enable overflow-safe multiplication and division.\\r\\n///\\r\\n/// Requirements:\\r\\n/// - The denominator cannot be zero.\\r\\n///\\r\\n/// @param x The numerator as an UD60x18 number.\\r\\n/// @param y The denominator as an UD60x18 number.\\r\\n/// @param result The quotient as an UD60x18 number.\\r\\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    result = wrap(mulDiv(unwrap(x), uUNIT, unwrap(y)));\\r\\n}\\r\\n\\r\\n/// @notice Calculates the natural exponent of x.\\r\\n///\\r\\n/// @dev Based on the formula:\\r\\n///\\r\\n/// $$\\r\\n/// e^x = 2^{x * log_2{e}}\\r\\n/// $$\\r\\n///\\r\\n/// Requirements:\\r\\n/// - All from `log2`.\\r\\n/// - x must be less than 133.084258667509499441.\\r\\n///\\r\\n/// @param x The exponent as an UD60x18 number.\\r\\n/// @return result The result as an UD60x18 number.\\r\\nfunction exp(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n\\r\\n    // Without this check, the value passed to `exp2` would be greater than 192.\\r\\n    if (xUint >= 133_084258667509499441) {\\r\\n        revert PRBMathUD60x18__ExpInputTooBig(x);\\r\\n    }\\r\\n\\r\\n    unchecked {\\r\\n        // We do the fixed-point multiplication inline rather than via the `mul` function to save gas.\\r\\n        uint256 doubleUnitProduct = xUint * uLOG2_E;\\r\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\r\\n///\\r\\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\r\\n///\\r\\n/// Requirements:\\r\\n/// - x must be 192 or less.\\r\\n/// - The result must fit within `MAX_UD60x18`.\\r\\n///\\r\\n/// @param x The exponent as an UD60x18 number.\\r\\n/// @return result The result as an UD60x18 number.\\r\\nfunction exp2(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n\\r\\n    // Numbers greater than or equal to 2^192 don't fit within the 192.64-bit format.\\r\\n    if (xUint >= 192e18) {\\r\\n        revert PRBMathUD60x18__Exp2InputTooBig(x);\\r\\n    }\\r\\n\\r\\n    // Convert x to the 192.64-bit fixed-point format.\\r\\n    uint256 x_192x64 = (xUint << 64) / uUNIT;\\r\\n\\r\\n    // Pass x to the `prbExp2` function, which uses the 192.64-bit fixed-point number representation.\\r\\n    result = wrap(prbExp2(x_192x64));\\r\\n}\\r\\n\\r\\n/// @notice Yields the greatest whole UD60x18 number less than or equal to x.\\r\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\r\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\r\\n/// @param x The UD60x18 number to floor.\\r\\n/// @param result The greatest integer less than or equal to x, as an UD60x18 number.\\r\\nfunction floor(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    assembly {\\r\\n        // Equivalent to \\\"x % UNIT\\\" but faster.\\r\\n        let remainder := mod(x, uUNIT)\\r\\n\\r\\n        // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\r\\n        result := sub(x, mul(remainder, gt(remainder, 0)))\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Yields the excess beyond the floor of x.\\r\\n/// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\r\\n/// @param x The UD60x18 number to get the fractional part of.\\r\\n/// @param result The fractional part of x as an UD60x18 number.\\r\\nfunction frac(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    assembly {\\r\\n        result := mod(x, uUNIT)\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates the geometric mean of x and y, i.e. $$sqrt(x * y)$$, rounding down.\\r\\n///\\r\\n/// @dev Requirements:\\r\\n/// - x * y must fit within `MAX_UD60x18`, lest it overflows.\\r\\n///\\r\\n/// @param x The first operand as an UD60x18 number.\\r\\n/// @param y The second operand as an UD60x18 number.\\r\\n/// @return result The result as an UD60x18 number.\\r\\nfunction gm(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n    uint256 yUint = unwrap(y);\\r\\n    if (xUint == 0 || yUint == 0) {\\r\\n        return ZERO;\\r\\n    }\\r\\n\\r\\n    unchecked {\\r\\n        // Checking for overflow this way is faster than letting Solidity do it.\\r\\n        uint256 xyUint = xUint * yUint;\\r\\n        if (xyUint / xUint != yUint) {\\r\\n            revert PRBMathUD60x18__GmOverflow(x, y);\\r\\n        }\\r\\n\\r\\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\\r\\n        // during multiplication. See the comments in the `prbSqrt` function.\\r\\n        result = wrap(prbSqrt(xyUint));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates 1 / x, rounding toward zero.\\r\\n///\\r\\n/// @dev Requirements:\\r\\n/// - x cannot be zero.\\r\\n///\\r\\n/// @param x The UD60x18 number for which to calculate the inverse.\\r\\n/// @return result The inverse as an UD60x18 number.\\r\\nfunction inv(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    unchecked {\\r\\n        // 1e36 is UNIT * UNIT.\\r\\n        result = wrap(1e36 / unwrap(x));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates the natural logarithm of x.\\r\\n///\\r\\n/// @dev Based on the formula:\\r\\n///\\r\\n/// $$\\r\\n/// ln{x} = log_2{x} / log_2{e}$$.\\r\\n/// $$\\r\\n///\\r\\n/// Requirements:\\r\\n/// - All from `log2`.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - All from `log2`.\\r\\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\\r\\n///\\r\\n/// @param x The UD60x18 number for which to calculate the natural logarithm.\\r\\n/// @return result The natural logarithm as an UD60x18 number.\\r\\nfunction ln(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    unchecked {\\r\\n        // We do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value\\r\\n        // that `log2` can return is 196.205294292027477728.\\r\\n        result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates the common logarithm of x.\\r\\n///\\r\\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\r\\n/// logarithm based on the formula:\\r\\n///\\r\\n/// $$\\r\\n/// log_{10}{x} = log_2{x} / log_2{10}\\r\\n/// $$\\r\\n///\\r\\n/// Requirements:\\r\\n/// - All from `log2`.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - All from `log2`.\\r\\n///\\r\\n/// @param x The UD60x18 number for which to calculate the common logarithm.\\r\\n/// @return result The common logarithm as an UD60x18 number.\\r\\nfunction log10(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n    if (xUint < uUNIT) {\\r\\n        revert PRBMathUD60x18__LogInputTooSmall(x);\\r\\n    }\\r\\n\\r\\n    // Note that the `mul` in this assembly block is the assembly multiplication operation, not the UD60x18 `mul`.\\r\\n    // prettier-ignore\\r\\n    assembly {\\r\\n        switch x\\r\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\r\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\r\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\r\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\r\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\r\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\r\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\r\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\r\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\r\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\r\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\r\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\r\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\r\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\r\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\r\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\r\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\r\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\r\\n        case 1000000000000000000 { result := 0 }\\r\\n        case 10000000000000000000 { result := uUNIT }\\r\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\r\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\r\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\r\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\r\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\r\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\r\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\r\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\r\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\r\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\r\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\r\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\r\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\r\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\r\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\r\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\r\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\r\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\r\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\r\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\r\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\r\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\r\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\r\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\r\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\r\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\r\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\r\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\r\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\r\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\r\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\r\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\r\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\r\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\r\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\r\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\r\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 59) }\\r\\n        default {\\r\\n            result := uMAX_UD60x18\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (unwrap(result) == uMAX_UD60x18) {\\r\\n        unchecked {\\r\\n            // Do the fixed-point division inline to save gas.\\r\\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Calculates the binary logarithm of x.\\r\\n///\\r\\n/// @dev Based on the iterative approximation algorithm.\\r\\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\r\\n///\\r\\n/// Requirements:\\r\\n/// - x must be greater than or equal to UNIT, otherwise the result would be negative.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\r\\n///\\r\\n/// @param x The UD60x18 number for which to calculate the binary logarithm.\\r\\n/// @return result The binary logarithm as an UD60x18 number.\\r\\nfunction log2(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n\\r\\n    if (xUint < uUNIT) {\\r\\n        revert PRBMathUD60x18__LogInputTooSmall(x);\\r\\n    }\\r\\n\\r\\n    unchecked {\\r\\n        // Calculate the integer part of the logarithm, add it to the result and finally calculate y = x * 2^(-n).\\r\\n        uint256 n = msb(xUint / uUNIT);\\r\\n\\r\\n        // This is the integer part of the logarithm as an UD60x18 number. The operation can't overflow because n\\r\\n        // n is maximum 255 and UNIT is 1e18.\\r\\n        uint256 resultUint = n * uUNIT;\\r\\n\\r\\n        // This is $y = x * 2^{-n}$.\\r\\n        uint256 y = xUint >> n;\\r\\n\\r\\n        // If y is 1, the fractional part is zero.\\r\\n        if (y == uUNIT) {\\r\\n            return wrap(resultUint);\\r\\n        }\\r\\n\\r\\n        // Calculate the fractional part via the iterative approximation.\\r\\n        // The \\\"delta.rshift(1)\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\r\\n        uint256 DOUBLE_UNIT = 2e18;\\r\\n        for (uint256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\r\\n            y = (y * y) / uUNIT;\\r\\n\\r\\n            // Is y^2 > 2 and so in the range [2,4)?\\r\\n            if (y >= DOUBLE_UNIT) {\\r\\n                // Add the 2^{-m} factor to the logarithm.\\r\\n                resultUint += delta;\\r\\n\\r\\n                // Corresponds to z/2 on Wikipedia.\\r\\n                y >>= 1;\\r\\n            }\\r\\n        }\\r\\n        result = wrap(resultUint);\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Multiplies two UD60x18 numbers together, returning a new UD60x18 number.\\r\\n/// @dev See the documentation for the `Core/mulDiv18` function.\\r\\n/// @param x The multiplicand as an UD60x18 number.\\r\\n/// @param y The multiplier as an UD60x18 number.\\r\\n/// @return result The product as an UD60x18 number.\\r\\nfunction mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    result = wrap(mulDiv18(unwrap(x), unwrap(y)));\\r\\n}\\r\\n\\r\\n/// @notice Raises x to the power of y.\\r\\n///\\r\\n/// @dev Based on the formula:\\r\\n///\\r\\n/// $$\\r\\n/// x^y = 2^{log_2{x} * y}\\r\\n/// $$\\r\\n///\\r\\n/// Requirements:\\r\\n/// - All from `exp2`, `log2` and `mul`.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - All from `exp2`, `log2` and `mul`.\\r\\n/// - Assumes 0^0 is 1.\\r\\n///\\r\\n/// @param x Number to raise to given power y, as an UD60x18 number.\\r\\n/// @param y Exponent to raise x to, as an UD60x18 number.\\r\\n/// @return result x raised to power y, as an UD60x18 number.\\r\\nfunction pow(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n    uint256 yUint = unwrap(y);\\r\\n\\r\\n    if (xUint == 0) {\\r\\n        result = yUint == 0 ? UNIT : ZERO;\\r\\n    } else {\\r\\n        if (yUint == uUNIT) {\\r\\n            result = x;\\r\\n        } else {\\r\\n            result = exp2(mul(log2(x), y));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Raises x (an UD60x18 number) to the power y (unsigned basic integer) using the famous algorithm\\r\\n/// \\\"exponentiation by squaring\\\".\\r\\n///\\r\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\r\\n///\\r\\n/// Requirements:\\r\\n/// - The result must fit within `MAX_UD60x18`.\\r\\n///\\r\\n/// Caveats:\\r\\n/// - All from \\\"Core/mulDiv18\\\".\\r\\n/// - Assumes 0^0 is 1.\\r\\n///\\r\\n/// @param x The base as an UD60x18 number.\\r\\n/// @param y The exponent as an uint256.\\r\\n/// @return result The result as an UD60x18 number.\\r\\nfunction powu(UD60x18 x, uint256 y) pure returns (UD60x18 result) {\\r\\n    // Calculate the first iteration of the loop in advance.\\r\\n    uint256 xUint = unwrap(x);\\r\\n    uint256 resultUint = y & 1 > 0 ? xUint : uUNIT;\\r\\n\\r\\n    // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\r\\n    for (y >>= 1; y > 0; y >>= 1) {\\r\\n        xUint = mulDiv18(xUint, xUint);\\r\\n\\r\\n        // Equivalent to \\\"y % 2 == 1\\\" but faster.\\r\\n        if (y & 1 > 0) {\\r\\n            resultUint = mulDiv18(resultUint, xUint);\\r\\n        }\\r\\n    }\\r\\n    result = wrap(resultUint);\\r\\n}\\r\\n\\r\\n/// @notice Calculates the square root of x, rounding down.\\r\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\r\\n///\\r\\n/// Requirements:\\r\\n/// - x must be less than `MAX_UD60x18` divided by `UNIT`.\\r\\n///\\r\\n/// @param x The UD60x18 number for which to calculate the square root.\\r\\n/// @return result The result as an UD60x18 number.\\r\\nfunction sqrt(UD60x18 x) pure returns (UD60x18 result) {\\r\\n    uint256 xUint = unwrap(x);\\r\\n\\r\\n    unchecked {\\r\\n        if (xUint > uMAX_UD60x18 / uUNIT) {\\r\\n            revert PRBMathUD60x18__SqrtOverflow(x);\\r\\n        }\\r\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two UD60x18\\r\\n        // numbers together (in this case, the two numbers are both the square root).\\r\\n        result = wrap(prbSqrt(xUint * uUNIT));\\r\\n    }\\r\\n}\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                            CONVERSION FUNCTIONS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\n/// @notice Converts an UD60x18 number to a simple integer by dividing it by `UNIT`. Rounds towards zero in the process.\\r\\n/// @dev Rounds down in the process.\\r\\n/// @param x The UD60x18 number to convert.\\r\\n/// @return result The same number in basic integer form.\\r\\nfunction fromUD60x18(UD60x18 x) pure returns (uint256 result) {\\r\\n    result = unwrap(x) / uUNIT;\\r\\n}\\r\\n\\r\\n/// @notice Converts a simple integer to UD60x18 by multiplying it by `UNIT`.\\r\\n///\\r\\n/// @dev Requirements:\\r\\n/// - x must be less than or equal to `MAX_UD60x18` divided by `UNIT`.\\r\\n///\\r\\n/// @param x The basic integer to convert.\\r\\n/// @param result The same number converted to UD60x18.\\r\\nfunction toUD60x18(uint256 x) pure returns (UD60x18 result) {\\r\\n    if (x > uMAX_UD60x18 / uUNIT) {\\r\\n        revert PRBMathUD60x18__ToUD60x18Overflow(x);\\r\\n    }\\r\\n    unchecked {\\r\\n        result = wrap(x * uUNIT);\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Wraps an unsigned integer into the UD60x18 type.\\r\\nfunction ud(uint256 x) pure returns (UD60x18 result) {\\r\\n    result = wrap(x);\\r\\n}\\r\\n\\r\\n/// @notice Wraps an unsigned integer into the UD60x18 type.\\r\\n/// @dev Alias for the \\\"ud\\\" function defined above.\\r\\nfunction ud60x18(uint256 x) pure returns (UD60x18 result) {\\r\\n    result = wrap(x);\\r\\n}\\r\\n\\r\\n/// @notice Unwraps an UD60x18 number into the underlying unsigned integer.\\r\\nfunction unwrap(UD60x18 x) pure returns (uint256 result) {\\r\\n    result = UD60x18.unwrap(x);\\r\\n}\\r\\n\\r\\n/// @notice Wraps an unsigned integer into the UD60x18 type.\\r\\nfunction wrap(uint256 x) pure returns (UD60x18 result) {\\r\\n    result = UD60x18.wrap(x);\\r\\n}\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                        GLOBAL-SCOPED HELPER FUNCTIONS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\nusing {\\r\\n    add,\\r\\n    and,\\r\\n    eq,\\r\\n    gt,\\r\\n    gte,\\r\\n    isZero,\\r\\n    lshift,\\r\\n    lt,\\r\\n    lte,\\r\\n    mod,\\r\\n    neq,\\r\\n    or,\\r\\n    rshift,\\r\\n    sub,\\r\\n    uncheckedAdd,\\r\\n    uncheckedSub,\\r\\n    xor\\r\\n} for UD60x18 global;\\r\\n\\r\\n/// @notice Implements the checked addition operation (+) in the UD60x18 type.\\r\\nfunction add(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) + unwrap(y));\\r\\n}\\r\\n\\r\\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\\r\\nfunction and(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) & bits);\\r\\n}\\r\\n\\r\\n/// @notice Implements the equal operation (==) in the UD60x18 type.\\r\\nfunction eq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\r\\n    result = unwrap(x) == unwrap(y);\\r\\n}\\r\\n\\r\\n/// @notice Implements the greater than operation (>) in the UD60x18 type.\\r\\nfunction gt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\r\\n    result = unwrap(x) > unwrap(y);\\r\\n}\\r\\n\\r\\n/// @notice Implements the greater than or equal to operation (>=) in the UD60x18 type.\\r\\nfunction gte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\r\\n    result = unwrap(x) >= unwrap(y);\\r\\n}\\r\\n\\r\\n/// @notice Implements a zero comparison check function in the UD60x18 type.\\r\\nfunction isZero(UD60x18 x) pure returns (bool result) {\\r\\n    // This wouldn't work if x could be negative.\\r\\n    result = unwrap(x) == 0;\\r\\n}\\r\\n\\r\\n/// @notice Implements the left shift operation (<<) in the UD60x18 type.\\r\\nfunction lshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) << bits);\\r\\n}\\r\\n\\r\\n/// @notice Implements the lower than operation (<) in the UD60x18 type.\\r\\nfunction lt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\r\\n    result = unwrap(x) < unwrap(y);\\r\\n}\\r\\n\\r\\n/// @notice Implements the lower than or equal to operation (<=) in the UD60x18 type.\\r\\nfunction lte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\r\\n    result = unwrap(x) <= unwrap(y);\\r\\n}\\r\\n\\r\\n/// @notice Implements the checked modulo operation (%) in the UD60x18 type.\\r\\nfunction mod(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) % unwrap(y));\\r\\n}\\r\\n\\r\\n/// @notice Implements the not equal operation (!=) in the UD60x18 type\\r\\nfunction neq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\r\\n    result = unwrap(x) != unwrap(y);\\r\\n}\\r\\n\\r\\n/// @notice Implements the OR (|) bitwise operation in the UD60x18 type.\\r\\nfunction or(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) | unwrap(y));\\r\\n}\\r\\n\\r\\n/// @notice Implements the right shift operation (>>) in the UD60x18 type.\\r\\nfunction rshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) >> bits);\\r\\n}\\r\\n\\r\\n/// @notice Implements the checked subtraction operation (-) in the UD60x18 type.\\r\\nfunction sub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) - unwrap(y));\\r\\n}\\r\\n\\r\\n/// @notice Implements the unchecked addition operation (+) in the UD60x18 type.\\r\\nfunction uncheckedAdd(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    unchecked {\\r\\n        result = wrap(unwrap(x) + unwrap(y));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Implements the unchecked subtraction operation (-) in the UD60x18 type.\\r\\nfunction uncheckedSub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    unchecked {\\r\\n        result = wrap(unwrap(x) - unwrap(y));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Implements the XOR (^) bitwise operation in the UD60x18 type.\\r\\nfunction xor(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    result = wrap(unwrap(x) ^ unwrap(y));\\r\\n}\\r\\n\\r\\n/*//////////////////////////////////////////////////////////////////////////\\r\\n                        FILE-SCOPED HELPER FUNCTIONS\\r\\n//////////////////////////////////////////////////////////////////////////*/\\r\\n\\r\\nusing { uncheckedDiv, uncheckedMul } for UD60x18;\\r\\n\\r\\n/// @notice Implements the unchecked standard division operation in the UD60x18 type.\\r\\nfunction uncheckedDiv(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    unchecked {\\r\\n        result = wrap(unwrap(x) / unwrap(y));\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Implements the unchecked standard multiplication operation in the UD60x18 type.\\r\\nfunction uncheckedMul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\r\\n    unchecked {\\r\\n        result = wrap(unwrap(x) * unwrap(y));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\r\\n\\r\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\r\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\r\\n    // @param _dstChainId - the destination chain identifier\\r\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\r\\n    // @param _payload - a custom bytes payload to send to the destination contract\\r\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\r\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\r\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\r\\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\\r\\n\\r\\n    // @notice used by the messaging library to publish verified payload\\r\\n    // @param _srcChainId - the source chain identifier\\r\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\r\\n    // @param _dstAddress - the address on destination chain\\r\\n    // @param _nonce - the unbound message ordering nonce\\r\\n    // @param _gasLimit - the gas limit for external contract execution\\r\\n    // @param _payload - verified payload to send to the destination contract\\r\\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\\r\\n\\r\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\r\\n    // @param _srcChainId - the source chain identifier\\r\\n    // @param _srcAddress - the source chain contract address\\r\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\r\\n\\r\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\r\\n    // @param _srcAddress - the source chain contract address\\r\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\r\\n\\r\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\r\\n    // @param _dstChainId - the destination chain identifier\\r\\n    // @param _userApplication - the user app address on this EVM chain\\r\\n    // @param _payload - the custom message to send over LayerZero\\r\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\r\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\r\\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\\r\\n\\r\\n    // @notice get this Endpoint's immutable source identifier\\r\\n    function getChainId() external view returns (uint16);\\r\\n\\r\\n    // @notice the interface to retry failed message on this Endpoint destination\\r\\n    // @param _srcChainId - the source chain identifier\\r\\n    // @param _srcAddress - the source chain contract address\\r\\n    // @param _payload - the payload to be retried\\r\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\r\\n\\r\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\r\\n    // @param _srcChainId - the source chain identifier\\r\\n    // @param _srcAddress - the source chain contract address\\r\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\r\\n\\r\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\r\\n    // @param _userApplication - the user app address on this EVM chain\\r\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\r\\n\\r\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\r\\n    // @param _userApplication - the user app address on this EVM chain\\r\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\r\\n\\r\\n    // @notice query if the non-reentrancy guard for send() is on\\r\\n    // @return true if the guard is on. false otherwise\\r\\n    function isSendingPayload() external view returns (bool);\\r\\n\\r\\n    // @notice query if the non-reentrancy guard for receive() is on\\r\\n    // @return true if the guard is on. false otherwise\\r\\n    function isReceivingPayload() external view returns (bool);\\r\\n\\r\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\r\\n    // @param _version - messaging library version\\r\\n    // @param _chainId - the chainId for the pending config change\\r\\n    // @param _userApplication - the contract address of the user application\\r\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\r\\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\\r\\n\\r\\n    // @notice get the send() LayerZero messaging library version\\r\\n    // @param _userApplication - the contract address of the user application\\r\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\r\\n\\r\\n    // @notice get the lzReceive() LayerZero messaging library version\\r\\n    // @param _userApplication - the contract address of the user application\\r\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/interfaces/ILayerZeroReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface ILayerZeroReceiver {\\r\\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\r\\n    // @param _srcChainId - the source endpoint identifier\\r\\n    // @param _srcAddress - the source sending contract address from the source chain\\r\\n    // @param _nonce - the ordered message nonce\\r\\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\\r\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface ILayerZeroUserApplicationConfig {\\r\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\r\\n    // @param _version - messaging library version\\r\\n    // @param _chainId - the chainId for the pending config change\\r\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\r\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\r\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\r\\n\\r\\n    // @notice set the send() LayerZero messaging library version to _version\\r\\n    // @param _version - new messaging library version\\r\\n    function setSendVersion(uint16 _version) external;\\r\\n\\r\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\r\\n    // @param _version - new messaging library version\\r\\n    function setReceiveVersion(uint16 _version) external;\\r\\n\\r\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\r\\n    // @param _srcChainId - the chainId of the source chain\\r\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\r\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/interfaces/IStargateReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IStargateReceiver {\\r\\n    function sgReceive(\\r\\n        uint16 _chainId,\\r\\n        bytes memory _srcAddress,\\r\\n        uint256 _nonce,\\r\\n        address _token,\\r\\n        uint256 amountLD,\\r\\n        bytes memory payload\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/interfaces/IStargateRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\npragma abicoder v2;\\r\\n\\r\\ninterface IStargateRouter {\\r\\n    struct lzTxObj {\\r\\n        uint256 dstGasForCall;\\r\\n        uint256 dstNativeAmount;\\r\\n        bytes dstNativeAddr;\\r\\n    }\\r\\n\\r\\n    function addLiquidity(\\r\\n        uint256 _poolId,\\r\\n        uint256 _amountLD,\\r\\n        address _to\\r\\n    ) external;\\r\\n\\r\\n    function swap(\\r\\n        uint16 _dstChainId,\\r\\n        uint256 _srcPoolId,\\r\\n        uint256 _dstPoolId,\\r\\n        address payable _refundAddress,\\r\\n        uint256 _amountLD,\\r\\n        uint256 _minAmountLD,\\r\\n        lzTxObj memory _lzTxParams,\\r\\n        bytes calldata _to,\\r\\n        bytes calldata _payload\\r\\n    ) external payable;\\r\\n\\r\\n    function redeemRemote(\\r\\n        uint16 _dstChainId,\\r\\n        uint256 _srcPoolId,\\r\\n        uint256 _dstPoolId,\\r\\n        address payable _refundAddress,\\r\\n        uint256 _amountLP,\\r\\n        uint256 _minAmountLD,\\r\\n        bytes calldata _to,\\r\\n        lzTxObj memory _lzTxParams\\r\\n    ) external payable;\\r\\n\\r\\n    function instantRedeemLocal(\\r\\n        uint16 _srcPoolId,\\r\\n        uint256 _amountLP,\\r\\n        address _to\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function redeemLocal(\\r\\n        uint16 _dstChainId,\\r\\n        uint256 _srcPoolId,\\r\\n        uint256 _dstPoolId,\\r\\n        address payable _refundAddress,\\r\\n        uint256 _amountLP,\\r\\n        bytes calldata _to,\\r\\n        lzTxObj memory _lzTxParams\\r\\n    ) external payable;\\r\\n\\r\\n    function sendCredits(\\r\\n        uint16 _dstChainId,\\r\\n        uint256 _srcPoolId,\\r\\n        uint256 _dstPoolId,\\r\\n        address payable _refundAddress\\r\\n    ) external payable;\\r\\n\\r\\n    function quoteLayerZeroFee(\\r\\n        uint16 _dstChainId,\\r\\n        uint8 _functionType,\\r\\n        bytes calldata _toAddress,\\r\\n        bytes calldata _transferAndCallPayload,\\r\\n        lzTxObj memory _lzTxParams\\r\\n    ) external view returns (uint256, uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/lzApp/LzApp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"../interfaces/ILayerZeroReceiver.sol\\\";\\r\\nimport \\\"../interfaces/ILayerZeroUserApplicationConfig.sol\\\";\\r\\nimport \\\"../interfaces/ILayerZeroEndpoint.sol\\\";\\r\\nimport \\\"../util/BytesLib.sol\\\";\\r\\n\\r\\n/*\\r\\n * a generic LzReceiver implementation\\r\\n */\\r\\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\\r\\n    using BytesLib for bytes;\\r\\n\\r\\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\\r\\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\\r\\n\\r\\n    ILayerZeroEndpoint public immutable lzEndpoint;\\r\\n    mapping(uint16 => bytes) public trustedRemoteLookup;\\r\\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\\r\\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\\r\\n    address public precrime;\\r\\n\\r\\n    event SetPrecrime(address precrime);\\r\\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\\r\\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\\r\\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\\r\\n\\r\\n    constructor(address _endpoint) {\\r\\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\\r\\n    }\\r\\n\\r\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\\r\\n        // lzReceive must be called by the endpoint for security\\r\\n        require(_msgSender() == address(lzEndpoint), \\\"LzApp: invalid endpoint caller\\\");\\r\\n\\r\\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\\r\\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\\r\\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), \\\"LzApp: invalid source sending contract\\\");\\r\\n\\r\\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\r\\n    }\\r\\n\\r\\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\\r\\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\\r\\n\\r\\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\\r\\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\\r\\n        require(trustedRemote.length != 0, \\\"LzApp: destination chain is not a trusted source\\\");\\r\\n        _checkPayloadSize(_dstChainId, _payload.length);\\r\\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\\r\\n    }\\r\\n\\r\\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\\r\\n        uint providedGasLimit = _getGasLimit(_adapterParams);\\r\\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\\r\\n        require(minGasLimit > 0, \\\"LzApp: minGasLimit not set\\\");\\r\\n        require(providedGasLimit >= minGasLimit, \\\"LzApp: gas limit is too low\\\");\\r\\n    }\\r\\n\\r\\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\\r\\n        require(_adapterParams.length >= 34, \\\"LzApp: invalid adapterParams\\\");\\r\\n        assembly {\\r\\n            gasLimit := mload(add(_adapterParams, 34))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\\r\\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\\r\\n        if (payloadSizeLimit == 0) { // use default if not set\\r\\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\\r\\n        }\\r\\n        require(_payloadSize <= payloadSizeLimit, \\\"LzApp: payload size is too large\\\");\\r\\n    }\\r\\n\\r\\n    //---------------------------UserApplication config----------------------------------------\\r\\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\\r\\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\\r\\n    }\\r\\n\\r\\n    // generic config for LayerZero user Application\\r\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\\r\\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\\r\\n    }\\r\\n\\r\\n    function setSendVersion(uint16 _version) external override onlyOwner {\\r\\n        lzEndpoint.setSendVersion(_version);\\r\\n    }\\r\\n\\r\\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\\r\\n        lzEndpoint.setReceiveVersion(_version);\\r\\n    }\\r\\n\\r\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\\r\\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\\r\\n    }\\r\\n\\r\\n    // _path = abi.encodePacked(remoteAddress, localAddress)\\r\\n    // this function set the trusted path for the cross-chain communication\\r\\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external onlyOwner {\\r\\n        trustedRemoteLookup[_srcChainId] = _path;\\r\\n        emit SetTrustedRemote(_srcChainId, _path);\\r\\n    }\\r\\n\\r\\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\\r\\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\\r\\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\\r\\n    }\\r\\n\\r\\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\\r\\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\\r\\n        require(path.length != 0, \\\"LzApp: no trusted path record\\\");\\r\\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\\r\\n    }\\r\\n\\r\\n    function setPrecrime(address _precrime) external onlyOwner {\\r\\n        precrime = _precrime;\\r\\n        emit SetPrecrime(_precrime);\\r\\n    }\\r\\n\\r\\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\\r\\n        require(_minGas > 0, \\\"LzApp: invalid minGas\\\");\\r\\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\\r\\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\\r\\n    }\\r\\n\\r\\n    // if the size is 0, it means default size limit\\r\\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\\r\\n        payloadSizeLimitLookup[_dstChainId] = _size;\\r\\n    }\\r\\n\\r\\n    //--------------------------- VIEW FUNCTION ----------------------------------------\\r\\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\\r\\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\\r\\n        return keccak256(trustedSource) == keccak256(_srcAddress);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/lzApp/NonblockingLzApp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./LzApp.sol\\\";\\r\\nimport \\\"../util/ExcessivelySafeCall.sol\\\";\\r\\n\\r\\n/*\\r\\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\\r\\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\\r\\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\\r\\n */\\r\\nabstract contract NonblockingLzApp is LzApp {\\r\\n    using ExcessivelySafeCall for address;\\r\\n\\r\\n    constructor(address _endpoint) LzApp(_endpoint) {}\\r\\n\\r\\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\\r\\n\\r\\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\\r\\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\\r\\n\\r\\n    // overriding the virtual function in LzReceiver\\r\\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\\r\\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\\r\\n        // try-catch all errors/exceptions\\r\\n        if (!success) {\\r\\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\\r\\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\\r\\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\\r\\n    }\\r\\n\\r\\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\\r\\n        // only internal transaction\\r\\n        require(_msgSender() == address(this), \\\"NonblockingLzApp: caller must be LzApp\\\");\\r\\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\r\\n    }\\r\\n\\r\\n    //@notice override this function\\r\\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\\r\\n\\r\\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\\r\\n        // assert there is message to retry\\r\\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\\r\\n        require(payloadHash != bytes32(0), \\\"NonblockingLzApp: no stored message\\\");\\r\\n        require(keccak256(_payload) == payloadHash, \\\"NonblockingLzApp: invalid payload\\\");\\r\\n        // clear the stored message\\r\\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\\r\\n        // execute the message. revert if it fails again\\r\\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\r\\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/token/oft/extension/ProxyOFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../OFTCore.sol\\\";\\r\\nimport \\\"openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\ncontract ProxyOFT is OFTCore {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 internal immutable innerToken;\\r\\n\\r\\n    constructor(address _lzEndpoint, address _token) OFTCore(_lzEndpoint) {\\r\\n        innerToken = IERC20(_token);\\r\\n    }\\r\\n\\r\\n    function circulatingSupply() public view virtual override returns (uint) {\\r\\n        unchecked {\\r\\n            return innerToken.totalSupply() - innerToken.balanceOf(address(this));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function token() public view virtual override returns (address) {\\r\\n        return address(innerToken);\\r\\n    }\\r\\n\\r\\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\\r\\n        require(_from == _msgSender(), \\\"ProxyOFT: owner is not send caller\\\");\\r\\n        uint before = innerToken.balanceOf(address(this));\\r\\n        innerToken.safeTransferFrom(_from, address(this), _amount);\\r\\n        return innerToken.balanceOf(address(this)) - before;\\r\\n    }\\r\\n\\r\\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\\r\\n        uint before = innerToken.balanceOf(_toAddress);\\r\\n        innerToken.safeTransfer(_toAddress, _amount);\\r\\n        return innerToken.balanceOf(_toAddress) - before;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/token/oft/IOFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport \\\"./IOFTCore.sol\\\";\\r\\nimport \\\"openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the OFT standard\\r\\n */\\r\\ninterface IOFT is IOFTCore, IERC20 {\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/token/oft/IOFTCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport \\\"openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the IOFT core standard\\r\\n */\\r\\ninterface IOFTCore is IERC165 {\\r\\n    /**\\r\\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\\r\\n     * _dstChainId - L0 defined chain id to send tokens too\\r\\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\\r\\n     * _amount - amount of the tokens to transfer\\r\\n     * _useZro - indicates to use zro to pay L0 fees\\r\\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\\r\\n     */\\r\\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\\r\\n\\r\\n    /**\\r\\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\\r\\n     * `_from` the owner of token\\r\\n     * `_dstChainId` the destination chain identifier\\r\\n     * `_toAddress` can be any size depending on the `dstChainId`.\\r\\n     * `_amount` the quantity of tokens in wei\\r\\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\\r\\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\\r\\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\\r\\n     */\\r\\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev returns the circulating amount of tokens on current chain\\r\\n     */\\r\\n    function circulatingSupply() external view returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev returns the address of the ERC20 token\\r\\n     */\\r\\n    function token() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\\r\\n     * `_nonce` is the outbound nonce\\r\\n     */\\r\\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint _amount);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\\r\\n     * `_nonce` is the inbound nonce.\\r\\n     */\\r\\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\\r\\n\\r\\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/token/oft/OFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\nimport \\\"./IOFT.sol\\\";\\r\\nimport \\\"./OFTCore.sol\\\";\\r\\n\\r\\n// override decimal() function is needed\\r\\ncontract OFT is OFTCore, ERC20, IOFT {\\r\\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\\r\\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    function token() public view virtual override returns (address) {\\r\\n        return address(this);\\r\\n    }\\r\\n\\r\\n    function circulatingSupply() public view virtual override returns (uint) {\\r\\n        return totalSupply();\\r\\n    }\\r\\n\\r\\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\\r\\n        address spender = _msgSender();\\r\\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\\r\\n        _burn(_from, _amount);\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\\r\\n        _mint(_toAddress, _amount);\\r\\n        return _amount;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/token/oft/OFTCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../lzApp/NonblockingLzApp.sol\\\";\\r\\nimport \\\"./IOFTCore.sol\\\";\\r\\nimport \\\"openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\r\\n\\r\\nabstract contract OFTCore is NonblockingLzApp, ERC165, IOFTCore {\\r\\n    using BytesLib for bytes;\\r\\n\\r\\n    uint public constant NO_EXTRA_GAS = 0;\\r\\n\\r\\n    // packet type\\r\\n    uint16 public constant PT_SEND = 0;\\r\\n\\r\\n    bool public useCustomAdapterParams;\\r\\n\\r\\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\\r\\n        // mock the payload for sendFrom()\\r\\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\\r\\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\\r\\n    }\\r\\n\\r\\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\\r\\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\\r\\n    }\\r\\n\\r\\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\\r\\n        useCustomAdapterParams = _useCustomAdapterParams;\\r\\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\\r\\n    }\\r\\n\\r\\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\\r\\n        uint16 packetType;\\r\\n        assembly {\\r\\n            packetType := mload(add(_payload, 32))\\r\\n        }\\r\\n\\r\\n        if (packetType == PT_SEND) {\\r\\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\\r\\n        } else {\\r\\n            revert(\\\"OFTCore: unknown packet type\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\\r\\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\\r\\n\\r\\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\\r\\n\\r\\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\\r\\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\\r\\n\\r\\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\\r\\n    }\\r\\n\\r\\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\\r\\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\\r\\n\\r\\n        address to = toAddressBytes.toAddress(0);\\r\\n\\r\\n        amount = _creditTo(_srcChainId, to, amount);\\r\\n        emit ReceiveFromChain(_srcChainId, to, amount);\\r\\n    }\\r\\n\\r\\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\\r\\n        if (useCustomAdapterParams) {\\r\\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\\r\\n        } else {\\r\\n            require(_adapterParams.length == 0, \\\"OFTCore: _adapterParams must be empty.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\\r\\n\\r\\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/util/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\r\\n/*\\r\\n * @title Solidity Bytes Arrays Utils\\r\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\r\\n *\\r\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\r\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\r\\n */\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\n\\r\\nlibrary BytesLib {\\r\\n    function concat(\\r\\n        bytes memory _preBytes,\\r\\n        bytes memory _postBytes\\r\\n    )\\r\\n    internal\\r\\n    pure\\r\\n    returns (bytes memory)\\r\\n    {\\r\\n        bytes memory tempBytes;\\r\\n\\r\\n        assembly {\\r\\n        // Get a location of some free memory and store it in tempBytes as\\r\\n        // Solidity does for memory variables.\\r\\n            tempBytes := mload(0x40)\\r\\n\\r\\n        // Store the length of the first bytes array at the beginning of\\r\\n        // the memory for tempBytes.\\r\\n            let length := mload(_preBytes)\\r\\n            mstore(tempBytes, length)\\r\\n\\r\\n        // Maintain a memory counter for the current write location in the\\r\\n        // temp bytes array by adding the 32 bytes for the array length to\\r\\n        // the starting location.\\r\\n            let mc := add(tempBytes, 0x20)\\r\\n        // Stop copying when the memory counter reaches the length of the\\r\\n        // first bytes array.\\r\\n            let end := add(mc, length)\\r\\n\\r\\n            for {\\r\\n            // Initialize a copy counter to the start of the _preBytes data,\\r\\n            // 32 bytes into its memory.\\r\\n                let cc := add(_preBytes, 0x20)\\r\\n            } lt(mc, end) {\\r\\n            // Increase both counters by 32 bytes each iteration.\\r\\n                mc := add(mc, 0x20)\\r\\n                cc := add(cc, 0x20)\\r\\n            } {\\r\\n            // Write the _preBytes data into the tempBytes memory 32 bytes\\r\\n            // at a time.\\r\\n                mstore(mc, mload(cc))\\r\\n            }\\r\\n\\r\\n        // Add the length of _postBytes to the current length of tempBytes\\r\\n        // and store it as the new length in the first 32 bytes of the\\r\\n        // tempBytes memory.\\r\\n            length := mload(_postBytes)\\r\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\r\\n\\r\\n        // Move the memory counter back from a multiple of 0x20 to the\\r\\n        // actual end of the _preBytes data.\\r\\n            mc := end\\r\\n        // Stop copying when the memory counter reaches the new combined\\r\\n        // length of the arrays.\\r\\n            end := add(mc, length)\\r\\n\\r\\n            for {\\r\\n                let cc := add(_postBytes, 0x20)\\r\\n            } lt(mc, end) {\\r\\n                mc := add(mc, 0x20)\\r\\n                cc := add(cc, 0x20)\\r\\n            } {\\r\\n                mstore(mc, mload(cc))\\r\\n            }\\r\\n\\r\\n        // Update the free-memory pointer by padding our last write location\\r\\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\r\\n        // next 32 byte block, then round down to the nearest multiple of\\r\\n        // 32. If the sum of the length of the two arrays is zero then add\\r\\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\\r\\n            mstore(0x40, and(\\r\\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\r\\n            not(31) // Round down to the nearest 32 bytes.\\r\\n            ))\\r\\n        }\\r\\n\\r\\n        return tempBytes;\\r\\n    }\\r\\n\\r\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\r\\n        assembly {\\r\\n        // Read the first 32 bytes of _preBytes storage, which is the length\\r\\n        // of the array. (We don't need to use the offset into the slot\\r\\n        // because arrays use the entire slot.)\\r\\n            let fslot := sload(_preBytes.slot)\\r\\n        // Arrays of 31 bytes or less have an even value in their slot,\\r\\n        // while longer arrays have an odd value. The actual length is\\r\\n        // the slot divided by two for odd values, and the lowest order\\r\\n        // byte divided by two for even values.\\r\\n        // If the slot is even, bitwise and the slot with 255 and divide by\\r\\n        // two to get the length. If the slot is odd, bitwise and the slot\\r\\n        // with -1 and divide by two.\\r\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\r\\n            let mlength := mload(_postBytes)\\r\\n            let newlength := add(slength, mlength)\\r\\n        // slength can contain both the length and contents of the array\\r\\n        // if length < 32 bytes so let's prepare for that\\r\\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\r\\n            switch add(lt(slength, 32), lt(newlength, 32))\\r\\n            case 2 {\\r\\n            // Since the new array still fits in the slot, we just need to\\r\\n            // update the contents of the slot.\\r\\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\r\\n                sstore(\\r\\n                _preBytes.slot,\\r\\n                // all the modifications to the slot are inside this\\r\\n                // next block\\r\\n                add(\\r\\n                // we can just add to the slot contents because the\\r\\n                // bytes we want to change are the LSBs\\r\\n                fslot,\\r\\n                add(\\r\\n                mul(\\r\\n                div(\\r\\n                // load the bytes from memory\\r\\n                mload(add(_postBytes, 0x20)),\\r\\n                // zero all bytes to the right\\r\\n                exp(0x100, sub(32, mlength))\\r\\n                ),\\r\\n                // and now shift left the number of bytes to\\r\\n                // leave space for the length in the slot\\r\\n                exp(0x100, sub(32, newlength))\\r\\n                ),\\r\\n                // increase length by the double of the memory\\r\\n                // bytes length\\r\\n                mul(mlength, 2)\\r\\n                )\\r\\n                )\\r\\n                )\\r\\n            }\\r\\n            case 1 {\\r\\n            // The stored value fits in the slot, but the combined value\\r\\n            // will exceed it.\\r\\n            // get the keccak hash to get the contents of the array\\r\\n                mstore(0x0, _preBytes.slot)\\r\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\r\\n\\r\\n            // save new length\\r\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\r\\n\\r\\n            // The contents of the _postBytes array start 32 bytes into\\r\\n            // the structure. Our first read should obtain the `submod`\\r\\n            // bytes that can fit into the unused space in the last word\\r\\n            // of the stored array. To get this, we read 32 bytes starting\\r\\n            // from `submod`, so the data we read overlaps with the array\\r\\n            // contents by `submod` bytes. Masking the lowest-order\\r\\n            // `submod` bytes allows us to add that value directly to the\\r\\n            // stored value.\\r\\n\\r\\n                let submod := sub(32, slength)\\r\\n                let mc := add(_postBytes, submod)\\r\\n                let end := add(_postBytes, mlength)\\r\\n                let mask := sub(exp(0x100, submod), 1)\\r\\n\\r\\n                sstore(\\r\\n                sc,\\r\\n                add(\\r\\n                and(\\r\\n                fslot,\\r\\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\r\\n                ),\\r\\n                and(mload(mc), mask)\\r\\n                )\\r\\n                )\\r\\n\\r\\n                for {\\r\\n                    mc := add(mc, 0x20)\\r\\n                    sc := add(sc, 1)\\r\\n                } lt(mc, end) {\\r\\n                    sc := add(sc, 1)\\r\\n                    mc := add(mc, 0x20)\\r\\n                } {\\r\\n                    sstore(sc, mload(mc))\\r\\n                }\\r\\n\\r\\n                mask := exp(0x100, sub(mc, end))\\r\\n\\r\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\r\\n            }\\r\\n            default {\\r\\n            // get the keccak hash to get the contents of the array\\r\\n                mstore(0x0, _preBytes.slot)\\r\\n            // Start copying to the last used word of the stored array.\\r\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\r\\n\\r\\n            // save new length\\r\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\r\\n\\r\\n            // Copy over the first `submod` bytes of the new data as in\\r\\n            // case 1 above.\\r\\n                let slengthmod := mod(slength, 32)\\r\\n                let mlengthmod := mod(mlength, 32)\\r\\n                let submod := sub(32, slengthmod)\\r\\n                let mc := add(_postBytes, submod)\\r\\n                let end := add(_postBytes, mlength)\\r\\n                let mask := sub(exp(0x100, submod), 1)\\r\\n\\r\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\r\\n\\r\\n                for {\\r\\n                    sc := add(sc, 1)\\r\\n                    mc := add(mc, 0x20)\\r\\n                } lt(mc, end) {\\r\\n                    sc := add(sc, 1)\\r\\n                    mc := add(mc, 0x20)\\r\\n                } {\\r\\n                    sstore(sc, mload(mc))\\r\\n                }\\r\\n\\r\\n                mask := exp(0x100, sub(mc, end))\\r\\n\\r\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function slice(\\r\\n        bytes memory _bytes,\\r\\n        uint256 _start,\\r\\n        uint256 _length\\r\\n    )\\r\\n    internal\\r\\n    pure\\r\\n    returns (bytes memory)\\r\\n    {\\r\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\r\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\r\\n\\r\\n        bytes memory tempBytes;\\r\\n\\r\\n        assembly {\\r\\n            switch iszero(_length)\\r\\n            case 0 {\\r\\n            // Get a location of some free memory and store it in tempBytes as\\r\\n            // Solidity does for memory variables.\\r\\n                tempBytes := mload(0x40)\\r\\n\\r\\n            // The first word of the slice result is potentially a partial\\r\\n            // word read from the original array. To read it, we calculate\\r\\n            // the length of that partial word and start copying that many\\r\\n            // bytes into the array. The first word we copy will start with\\r\\n            // data we don't care about, but the last `lengthmod` bytes will\\r\\n            // land at the beginning of the contents of the new array. When\\r\\n            // we're done copying, we overwrite the full first word with\\r\\n            // the actual length of the slice.\\r\\n                let lengthmod := and(_length, 31)\\r\\n\\r\\n            // The multiplication in the next line is necessary\\r\\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\\r\\n            // the following copy loop was copying the origin's length\\r\\n            // and then ending prematurely not copying everything it should.\\r\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\r\\n                let end := add(mc, _length)\\r\\n\\r\\n                for {\\r\\n                // The multiplication in the next line has the same exact purpose\\r\\n                // as the one above.\\r\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\r\\n                } lt(mc, end) {\\r\\n                    mc := add(mc, 0x20)\\r\\n                    cc := add(cc, 0x20)\\r\\n                } {\\r\\n                    mstore(mc, mload(cc))\\r\\n                }\\r\\n\\r\\n                mstore(tempBytes, _length)\\r\\n\\r\\n            //update free-memory pointer\\r\\n            //allocating the array padded to 32 bytes like the compiler does now\\r\\n                mstore(0x40, and(add(mc, 31), not(31)))\\r\\n            }\\r\\n            //if we want a zero-length slice let's just return a zero-length array\\r\\n            default {\\r\\n                tempBytes := mload(0x40)\\r\\n            //zero out the 32 bytes slice we are about to return\\r\\n            //we need to do it because Solidity does not garbage collect\\r\\n                mstore(tempBytes, 0)\\r\\n\\r\\n                mstore(0x40, add(tempBytes, 0x20))\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return tempBytes;\\r\\n    }\\r\\n\\r\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\r\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\r\\n        address tempAddress;\\r\\n\\r\\n        assembly {\\r\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\r\\n        }\\r\\n\\r\\n        return tempAddress;\\r\\n    }\\r\\n\\r\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\r\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\r\\n        uint8 tempUint;\\r\\n\\r\\n        assembly {\\r\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\r\\n        }\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\r\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\r\\n        uint16 tempUint;\\r\\n\\r\\n        assembly {\\r\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\r\\n        }\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\r\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\r\\n        uint32 tempUint;\\r\\n\\r\\n        assembly {\\r\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\r\\n        }\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\r\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\r\\n        uint64 tempUint;\\r\\n\\r\\n        assembly {\\r\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\r\\n        }\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\r\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\r\\n        uint96 tempUint;\\r\\n\\r\\n        assembly {\\r\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\r\\n        }\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\r\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\r\\n        uint128 tempUint;\\r\\n\\r\\n        assembly {\\r\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\r\\n        }\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\r\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\r\\n        uint256 tempUint;\\r\\n\\r\\n        assembly {\\r\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\r\\n        }\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\r\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\r\\n        bytes32 tempBytes32;\\r\\n\\r\\n        assembly {\\r\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\r\\n        }\\r\\n\\r\\n        return tempBytes32;\\r\\n    }\\r\\n\\r\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\r\\n        bool success = true;\\r\\n\\r\\n        assembly {\\r\\n            let length := mload(_preBytes)\\r\\n\\r\\n        // if lengths don't match the arrays are not equal\\r\\n            switch eq(length, mload(_postBytes))\\r\\n            case 1 {\\r\\n            // cb is a circuit breaker in the for loop since there's\\r\\n            //  no said feature for inline assembly loops\\r\\n            // cb = 1 - don't breaker\\r\\n            // cb = 0 - break\\r\\n                let cb := 1\\r\\n\\r\\n                let mc := add(_preBytes, 0x20)\\r\\n                let end := add(mc, length)\\r\\n\\r\\n                for {\\r\\n                    let cc := add(_postBytes, 0x20)\\r\\n                // the next line is the loop condition:\\r\\n                // while(uint256(mc < end) + cb == 2)\\r\\n                } eq(add(lt(mc, end), cb), 2) {\\r\\n                    mc := add(mc, 0x20)\\r\\n                    cc := add(cc, 0x20)\\r\\n                } {\\r\\n                // if any of these checks fails then arrays are not equal\\r\\n                    if iszero(eq(mload(mc), mload(cc))) {\\r\\n                    // unsuccess:\\r\\n                        success := 0\\r\\n                        cb := 0\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            default {\\r\\n            // unsuccess:\\r\\n                success := 0\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    function equalStorage(\\r\\n        bytes storage _preBytes,\\r\\n        bytes memory _postBytes\\r\\n    )\\r\\n    internal\\r\\n    view\\r\\n    returns (bool)\\r\\n    {\\r\\n        bool success = true;\\r\\n\\r\\n        assembly {\\r\\n        // we know _preBytes_offset is 0\\r\\n            let fslot := sload(_preBytes.slot)\\r\\n        // Decode the length of the stored array like in concatStorage().\\r\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\r\\n            let mlength := mload(_postBytes)\\r\\n\\r\\n        // if lengths don't match the arrays are not equal\\r\\n            switch eq(slength, mlength)\\r\\n            case 1 {\\r\\n            // slength can contain both the length and contents of the array\\r\\n            // if length < 32 bytes so let's prepare for that\\r\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\r\\n                if iszero(iszero(slength)) {\\r\\n                    switch lt(slength, 32)\\r\\n                    case 1 {\\r\\n                    // blank the last byte which is the length\\r\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\r\\n\\r\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\r\\n                        // unsuccess:\\r\\n                            success := 0\\r\\n                        }\\r\\n                    }\\r\\n                    default {\\r\\n                    // cb is a circuit breaker in the for loop since there's\\r\\n                    //  no said feature for inline assembly loops\\r\\n                    // cb = 1 - don't breaker\\r\\n                    // cb = 0 - break\\r\\n                        let cb := 1\\r\\n\\r\\n                    // get the keccak hash to get the contents of the array\\r\\n                        mstore(0x0, _preBytes.slot)\\r\\n                        let sc := keccak256(0x0, 0x20)\\r\\n\\r\\n                        let mc := add(_postBytes, 0x20)\\r\\n                        let end := add(mc, mlength)\\r\\n\\r\\n                    // the next line is the loop condition:\\r\\n                    // while(uint256(mc < end) + cb == 2)\\r\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\r\\n                            sc := add(sc, 1)\\r\\n                            mc := add(mc, 0x20)\\r\\n                        } {\\r\\n                            if iszero(eq(sload(sc), mload(mc))) {\\r\\n                            // unsuccess:\\r\\n                                success := 0\\r\\n                                cb := 0\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            default {\\r\\n            // unsuccess:\\r\\n                success := 0\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return success;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solidity-examples/contracts/util/ExcessivelySafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.7.6;\\r\\n\\r\\nlibrary ExcessivelySafeCall {\\r\\n    uint256 constant LOW_28_MASK =\\r\\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\r\\n    /// contract. This prevents the called contract from causing reversion of\\r\\n    /// the caller in as many ways as we can.\\r\\n    /// @dev The main difference between this and a solidity low-level call is\\r\\n    /// that we limit the number of bytes that the callee can cause to be\\r\\n    /// copied to caller memory. This prevents stupid things like malicious\\r\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\r\\n    /// to memory.\\r\\n    /// @param _target The address to call\\r\\n    /// @param _gas The amount of gas to forward to the remote contract\\r\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\r\\n    /// to memory.\\r\\n    /// @param _calldata The data to send to the remote contract\\r\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\r\\n    /// `_maxCopy` bytes.\\r\\n    function excessivelySafeCall(\\r\\n        address _target,\\r\\n        uint256 _gas,\\r\\n        uint16 _maxCopy,\\r\\n        bytes memory _calldata\\r\\n    ) internal returns (bool, bytes memory) {\\r\\n        // set up for assembly call\\r\\n        uint256 _toCopy;\\r\\n        bool _success;\\r\\n        bytes memory _returnData = new bytes(_maxCopy);\\r\\n        // dispatch message to recipient\\r\\n        // by assembly calling \\\"handle\\\" function\\r\\n        // we call via assembly to avoid memcopying a very large returndata\\r\\n        // returned by a malicious contract\\r\\n        assembly {\\r\\n            _success := call(\\r\\n            _gas, // gas\\r\\n            _target, // recipient\\r\\n            0, // ether value\\r\\n            add(_calldata, 0x20), // inloc\\r\\n            mload(_calldata), // inlen\\r\\n            0, // outloc\\r\\n            0 // outlen\\r\\n            )\\r\\n        // limit our copy to 256 bytes\\r\\n            _toCopy := returndatasize()\\r\\n            if gt(_toCopy, _maxCopy) {\\r\\n                _toCopy := _maxCopy\\r\\n            }\\r\\n        // Store the length of the copied bytes\\r\\n            mstore(_returnData, _toCopy)\\r\\n        // copy the bytes from returndata[0:_toCopy]\\r\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\r\\n        }\\r\\n        return (_success, _returnData);\\r\\n    }\\r\\n\\r\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\r\\n    /// contract. This prevents the called contract from causing reversion of\\r\\n    /// the caller in as many ways as we can.\\r\\n    /// @dev The main difference between this and a solidity low-level call is\\r\\n    /// that we limit the number of bytes that the callee can cause to be\\r\\n    /// copied to caller memory. This prevents stupid things like malicious\\r\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\r\\n    /// to memory.\\r\\n    /// @param _target The address to call\\r\\n    /// @param _gas The amount of gas to forward to the remote contract\\r\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\r\\n    /// to memory.\\r\\n    /// @param _calldata The data to send to the remote contract\\r\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\r\\n    /// `_maxCopy` bytes.\\r\\n    function excessivelySafeStaticCall(\\r\\n        address _target,\\r\\n        uint256 _gas,\\r\\n        uint16 _maxCopy,\\r\\n        bytes memory _calldata\\r\\n    ) internal view returns (bool, bytes memory) {\\r\\n        // set up for assembly call\\r\\n        uint256 _toCopy;\\r\\n        bool _success;\\r\\n        bytes memory _returnData = new bytes(_maxCopy);\\r\\n        // dispatch message to recipient\\r\\n        // by assembly calling \\\"handle\\\" function\\r\\n        // we call via assembly to avoid memcopying a very large returndata\\r\\n        // returned by a malicious contract\\r\\n        assembly {\\r\\n            _success := staticcall(\\r\\n            _gas, // gas\\r\\n            _target, // recipient\\r\\n            add(_calldata, 0x20), // inloc\\r\\n            mload(_calldata), // inlen\\r\\n            0, // outloc\\r\\n            0 // outlen\\r\\n            )\\r\\n        // limit our copy to 256 bytes\\r\\n            _toCopy := returndatasize()\\r\\n            if gt(_toCopy, _maxCopy) {\\r\\n                _toCopy := _maxCopy\\r\\n            }\\r\\n        // Store the length of the copied bytes\\r\\n            mstore(_returnData, _toCopy)\\r\\n        // copy the bytes from returndata[0:_toCopy]\\r\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\r\\n        }\\r\\n        return (_success, _returnData);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Swaps function selectors in encoded contract calls\\r\\n     * @dev Allows reuse of encoded calldata for functions with identical\\r\\n     * argument types but different names. It simply swaps out the first 4 bytes\\r\\n     * for the new selector. This function modifies memory in place, and should\\r\\n     * only be used with caution.\\r\\n     * @param _newSelector The new 4-byte selector\\r\\n     * @param _buf The encoded contract args\\r\\n     */\\r\\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\\r\\n    internal\\r\\n    pure\\r\\n    {\\r\\n        require(_buf.length >= 4);\\r\\n        uint256 _mask = LOW_28_MASK;\\r\\n        assembly {\\r\\n        // load the first word of\\r\\n            let _word := mload(add(_buf, 0x20))\\r\\n        // mask out the top 4 bytes\\r\\n        // /x\\r\\n            _word := and(_word, _mask)\\r\\n            _word := or(_newSelector, _word)\\r\\n            mstore(add(_buf, 0x20), _word)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/Staking/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// https://docs.synthetix.io/contracts/Owned\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n    address public nominatedOwner;\\r\\n\\r\\n    constructor (address _owner) public {\\r\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\r\\n        owner = _owner;\\r\\n        emit OwnerChanged(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function nominateNewOwner(address _owner) external onlyOwner {\\r\\n        nominatedOwner = _owner;\\r\\n        emit OwnerNominated(_owner);\\r\\n    }\\r\\n\\r\\n    function acceptOwnership() external {\\r\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\r\\n        emit OwnerChanged(owner, nominatedOwner);\\r\\n        owner = nominatedOwner;\\r\\n        nominatedOwner = address(0);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    event OwnerNominated(address newOwner);\\r\\n    event OwnerChanged(address oldOwner, address newOwner);\\r\\n}\"\r\n    },\r\n    \"lib/Utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.11 <0.9.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"lib/Utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/**\\r\\n * @dev Library for managing\\r\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\r\\n * types.\\r\\n *\\r\\n * Sets have the following properties:\\r\\n *\\r\\n * - Elements are added, removed, and checked for existence in constant time\\r\\n * (O(1)).\\r\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\r\\n *\\r\\n * ```\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\r\\n *\\r\\n *     // Declare a set state variable\\r\\n *     EnumerableSet.AddressSet private mySet;\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\r\\n * (`UintSet`) are supported.\\r\\n */\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping (bytes32 => uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\r\\n\\r\\n            bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n            // Move the last value to the index where the value to delete is\\r\\n            set._values[toDeleteIndex] = lastvalue;\\r\\n            // Update the index for the moved value\\r\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(bytes20(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(bytes20(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(bytes20(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(bytes20(_at(set._inner, index)));\\r\\n    }\\r\\n\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/AnkrFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"local/interfaces/IvdUSH.sol\\\";\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\r\\nimport \\\"openzeppelin/utils/math/SignedSafeMath.sol\\\";\\r\\n\\r\\n\\r\\n// ================================================================\\r\\n// Allows vdUSH stakers to claim farm rewards from partner tokens\\r\\n// Users can claim their rewards at any time\\r\\n// No staking needed, just looks up staked balances from vdUSH farm\\r\\n// No user deposits held in this contract!\\r\\n// Author: unshETH team (github.com/unsheth)\\r\\n// Heavily inspired by StakingRewards, MasterChef\\r\\n\\r\\ninterface IGovFarm {\\r\\n    function getAllUsers() external view returns (address[] memory);\\r\\n    function totalSupplyMultiplier() external view returns (uint);\\r\\n    function isInMatrix(address user) external view returns (bool);\\r\\n}\\r\\n\\r\\ncontract PartnerRewardsFarm is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IvdUSH public constant vdUsh = IvdUSH(0xd027Ef82dB658805C9Ba8053196cD6ED1Dd407E4);\\r\\n    IERC20 public immutable rewardToken;\\r\\n\\r\\n    IGovFarm public govFarm; //govFarm contract\\r\\n    uint public startTime; //start time of the farm\\r\\n    uint public rewardPerSec;\\r\\n\\r\\n    mapping(address => uint) public lastClaimTimestamp;\\r\\n    mapping(address => uint) public lastClaimVdUshBalance;\\r\\n    mapping(address => uint) public lastClaimTotalSupply;\\r\\n    mapping(address => bool) public isBlocked; //if a user is blocked from claiming rewards\\r\\n\\r\\n    struct Point {\\r\\n        int128 bias;\\r\\n        int128 slope; // # -dweight / dt\\r\\n        uint ts;\\r\\n        uint blk; // block\\r\\n    }\\r\\n    uint internal constant WEEK = 1 weeks;\\r\\n\\r\\n    event RewardsClaimed(address indexed _user, uint _rewardClaimed);\\r\\n    event RewardPerSecUpdated(uint _rewardPerSec);\\r\\n    event GovFarmUpdated(address _govFarmAddress);\\r\\n    event BlockListUpdated(address indexed _user, bool _isBlocked);\\r\\n    event FarmStarted(uint _rewardPerSec, uint _startTime);\\r\\n\\r\\n    //Constructor\\r\\n    constructor(address _govFarmAddress, address _rewardToken) {\\r\\n        rewardToken = IERC20(_rewardToken);\\r\\n        govFarm = IGovFarm(_govFarmAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculate user's earned USH and vdUSH rewards since last claim.\\r\\n     * User earned rewards are proportional to their share of total vdUSH at the time of claim.\\r\\n     * @param user The address of the user entering the matrix.\\r\\n     */\\r\\n    function earned(address user) public view returns (uint) {\\r\\n        require(govFarm.isInMatrix(user), \\\"User not in matrix\\\");\\r\\n        require(startTime!= 0 && block.timestamp > startTime, \\\"Farm not started\\\");\\r\\n        require(!isBlocked[user], \\\"User is blocked from claiming rewards\\\");\\r\\n\\r\\n        uint lastClaimTimeStamp = lastClaimTimestamp[user] == 0 ? startTime : lastClaimTimestamp[user];\\r\\n\\r\\n        uint secsSinceLastClaim = block.timestamp - lastClaimTimeStamp;\\r\\n        uint lastEpoch = vdUsh.user_point_epoch(user);\\r\\n        uint lastEpochTimestamp = vdUsh.user_point_history__ts(user, lastEpoch);\\r\\n\\r\\n        uint userVdUsh;\\r\\n        uint totalVdUsh;\\r\\n\\r\\n        userVdUsh = lastClaimVdUshBalance[user];\\r\\n        totalVdUsh = lastClaimTotalSupply[user];\\r\\n\\r\\n        //sampling:\\r\\n        //fyi we start at i=1, bc i=0 is the lastClaim which is already stored\\r\\n        for(uint i = 1; i < 53;) {\\r\\n            uint timestamp = lastClaimTimeStamp + i * 1 weeks;\\r\\n            //if 1 wk after last claim is after current block timestamp, break\\r\\n            if(timestamp > block.timestamp) {\\r\\n                userVdUsh += vdUsh.balanceOf(user);\\r\\n                totalVdUsh += vdUsh.totalSupply();\\r\\n                break;\\r\\n            }\\r\\n            //round down to nearest week if needed\\r\\n            if(timestamp > lastEpochTimestamp) {\\r\\n                timestamp = lastEpochTimestamp;\\r\\n            }\\r\\n\\r\\n            userVdUsh += vdUsh.balanceOfAtT(user, timestamp);\\r\\n            //calculate totalSupplyAtT internally due to versioning issue in ve-contracts\\r\\n            totalVdUsh += _totalSupplyAtT(timestamp);\\r\\n\\r\\n            unchecked{ ++i; }\\r\\n        }\\r\\n\\r\\n        uint averageVdUshShare = userVdUsh * 1e18 / totalVdUsh;\\r\\n        uint claimable = averageVdUshShare * secsSinceLastClaim * rewardPerSec / 1e18 * govFarm.totalSupplyMultiplier() / 1e18;\\r\\n\\r\\n        return claimable;\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Calculations to get correct total supply at historical point T\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function _get_point_history(uint _epoch) internal view returns (Point memory) {\\r\\n        (int128 bias, int128 slope, uint ts, uint blk) = vdUsh.point_history(_epoch);\\r\\n        return Point(bias, slope, ts, blk);\\r\\n    }\\r\\n\\r\\n    function _totalSupplyAtT(uint t) internal view returns (uint) {\\r\\n        uint _epoch = vdUsh.epoch();\\r\\n        Point memory last_point = _get_point_history(_epoch);\\r\\n        return _supply_at(last_point, t);\\r\\n    }\\r\\n\\r\\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\\r\\n        Point memory last_point = point;\\r\\n        uint t_i = (last_point.ts / WEEK) * WEEK;\\r\\n        for (uint i = 0; i < 255; ++i) {\\r\\n            t_i += WEEK;\\r\\n            int128 d_slope = 0;\\r\\n            if (t_i > t) {\\r\\n                t_i = t;\\r\\n            } else {\\r\\n                d_slope = vdUsh.slope_changes(t_i);\\r\\n            }\\r\\n            last_point.bias -= last_point.slope * int128(int(t_i) - int(last_point.ts));\\r\\n            if (t_i == t) {\\r\\n                break;\\r\\n            }\\r\\n            last_point.slope += d_slope;\\r\\n            last_point.ts = t_i;\\r\\n        }\\r\\n\\r\\n        if (last_point.bias < 0) {\\r\\n            last_point.bias = 0;\\r\\n        }\\r\\n        return uint(uint128(last_point.bias));\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Claim\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function claim(address user) external nonReentrant {\\r\\n        uint claimable = earned(user);\\r\\n        require(claimable > 0, \\\"Nothing to claim\\\");\\r\\n\\r\\n        lastClaimTimestamp[user] = block.timestamp;\\r\\n        lastClaimVdUshBalance[user] = vdUsh.balanceOf(user);\\r\\n        lastClaimTotalSupply[user] = vdUsh.totalSupply();\\r\\n        rewardToken.safeTransfer(user, claimable);\\r\\n        emit RewardsClaimed(user, claimable);\\r\\n    }\\r\\n\\r\\n    //view funcs\\r\\n    function getAllUsers() public view returns (address[] memory) {\\r\\n        return govFarm.getAllUsers();\\r\\n    }\\r\\n\\r\\n    function getVdUshTotalSupplyInFarm() public view returns (uint) {\\r\\n        uint totalVdUsh;\\r\\n        address[] memory users = getAllUsers();\\r\\n        for(uint i = 0; i < users.length;) {\\r\\n            uint vdUshBalance = isBlocked[users[i]] ? 0 : vdUsh.balanceOf(users[i]);\\r\\n            totalVdUsh += vdUshBalance;\\r\\n            unchecked{ ++i; }\\r\\n        }\\r\\n        return totalVdUsh;\\r\\n    }\\r\\n\\r\\n    //owner funcs\\r\\n    function startFarm(uint _rewardPerSec) external onlyOwner {\\r\\n        require(startTime == 0, \\\"Farm already started\\\");\\r\\n        rewardPerSec = _rewardPerSec;\\r\\n        startTime = block.timestamp;\\r\\n        emit FarmStarted(_rewardPerSec, startTime);\\r\\n    }\\r\\n\\r\\n    function setRewardPerSec(uint _rewardPerSec) external onlyOwner {\\r\\n        rewardPerSec = _rewardPerSec;\\r\\n        emit RewardPerSecUpdated(_rewardPerSec);\\r\\n    }\\r\\n\\r\\n    function updateGovFarm(address _govFarmAddress) external onlyOwner {\\r\\n        govFarm = IGovFarm(_govFarmAddress);\\r\\n        emit GovFarmUpdated(_govFarmAddress);\\r\\n    }\\r\\n\\r\\n    function updateBlockList(address _user, bool _isBlocked) external onlyOwner {\\r\\n        isBlocked[_user] = _isBlocked;\\r\\n        emit BlockListUpdated(_user, _isBlocked);\\r\\n    }\\r\\n\\r\\n    //emergency funcs\\r\\n    function recoverTokens(uint amount, address dst) external onlyOwner {\\r\\n        rewardToken.safeTransfer(dst, amount);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"src/ARBsgSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\n//import \\\"layerzerolabs/contracts/token/oft/OFT.sol\\\";\\r\\nimport \\\"layerzerolabs/contracts/interfaces/IStargateRouter.sol\\\";\\r\\nimport \\\"communal/TransferHelper.sol\\\";\\r\\nimport \\\"ERC20/IERC20.sol\\\";\\r\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\r\\n\\r\\n\\r\\ninterface ISGETH is IERC20{\\r\\n    function deposit() payable external;\\r\\n}\\r\\n\\r\\ncontract SgSender is Ownable {\\r\\n\\r\\n    //Constants\\r\\n    address public constant stargateRouterAddress = 0x53Bf833A5d6c4ddA888F69c22C88C9f356a41614; //https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\\r\\n    address public constant sgethAddress = 0x82CbeCF39bEe528B5476FE6d1550af59a9dB6Fc0;\\r\\n    uint16 public constant dstChainId = 101; //https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\\r\\n    uint16 public constant srcPoolId = 13;   //https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\\r\\n    uint16 public constant dstPoolId = 13;   //https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\\r\\n\\r\\n    //Mutable variables\\r\\n    address public sgReceiverAddress; //destination contract. it must implement sgReceive()\\r\\n    bool public paused = false;\\r\\n\\r\\n    event PauseToggled(bool paused);\\r\\n    event SgReceiverChanged(address sgReceiverAddress);\\r\\n    event UnshethMinted(address indexed sender, uint256 amount, uint256 min_amount_stargate, uint256 min_amount_unshethZap, uint256 dstGasForCall, uint256 dstNativeAmount, uint256 unsheth_path);\\r\\n\\r\\n    constructor(\\r\\n        address _owner, //desired owner (e.g. multisig)\\r\\n        address _sgReceiver //address of the sgReceiver deployed on ETH\\r\\n    ) {\\r\\n        sgReceiverAddress = _sgReceiver;\\r\\n        //approve sgeth for spending by stargateRouter\\r\\n        TransferHelper.safeApprove(sgethAddress, stargateRouterAddress, type(uint256).max);\\r\\n        //transfer ownership to desired owner\\r\\n        transferOwnership(_owner);\\r\\n    }\\r\\n\\r\\n    modifier onlyWhenUnpaused {\\r\\n        require(paused == false, \\\"Contract is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // owner function that sets the pause parameter\\r\\n    function togglePaused() public onlyOwner {\\r\\n        paused = !paused;\\r\\n        emit PauseToggled(paused);\\r\\n    }\\r\\n\\r\\n    function changeSgReceiver(address _sgReceiver) public onlyOwner {\\r\\n        require(_sgReceiver != address(0), \\\"sgReceiver cannot be zero address\\\");\\r\\n        sgReceiverAddress = _sgReceiver;\\r\\n        emit SgReceiverChanged(_sgReceiver);\\r\\n    }\\r\\n\\r\\n    // mint_unsheth function that sends ETH to the sgReceiver on Mainnet contract to mint unshETH tokens\\r\\n    function mint_unsheth(\\r\\n        uint256 amount,                         // the amount of ETH\\r\\n        uint256 min_amount_stargate,            // the minimum amount of ETH to receive on stargate,\\r\\n        uint256 min_amount_unshethZap,          // the minimum amount of unshETH to receive from the unshETH Zap\\r\\n        uint256 dstGasForCall,                  // the amount of gas to send to the sgReceive contract\\r\\n        uint256 dstNativeAmount,                // leftover eth that will get airdropped to the sgReceive contract\\r\\n        uint256 unsheth_path                    // the path that the unsheth Zap will take to mint unshETH\\r\\n    ) external payable onlyWhenUnpaused {\\r\\n        // ensure the msg.value is greater than the amount of ETH being sent\\r\\n        require(msg.value > amount, \\\"Not enough ETH provided as msg.value\\\");\\r\\n\\r\\n        // deposit the ETH into the sgeth contract\\r\\n        ISGETH(sgethAddress).deposit{value:amount}();\\r\\n\\r\\n        //calculate the fee that will be used to pay for the swap \\r\\n        uint256 feeAmount = msg.value - amount;\\r\\n\\r\\n        bytes memory data = abi.encode(msg.sender, min_amount_unshethZap, unsheth_path);\\r\\n\\r\\n        // Encode payload data to send to destination contract, which it will handle with sgReceive()\\r\\n        IStargateRouter(stargateRouterAddress).swap{value:feeAmount}( //call estimateGasFees to get the msg.value\\r\\n            dstChainId,                                               // the destination chain id - ETH\\r\\n            srcPoolId,                                                // the source Stargate poolId\\r\\n            dstPoolId,                                                // the destination Stargate poolId\\r\\n            payable(msg.sender),                                      // refund address. if msg.sender pays too much gas, return extra ETH to this address\\r\\n            amount,                                                   // total tokens to send to destination chain\\r\\n            min_amount_stargate,                                      // min amount allowed out\\r\\n            IStargateRouter.lzTxObj(dstGasForCall, dstNativeAmount, abi.encodePacked(sgReceiverAddress)), // default lzTxObj\\r\\n            abi.encodePacked(sgReceiverAddress),                      // destination address, the sgReceive() implementer\\r\\n            data                                                      // bytes payload which sgReceive() will parse into an address that the unshETH will be sent too.\\r\\n        );\\r\\n\\r\\n        emit UnshethMinted(msg.sender, amount, min_amount_stargate, min_amount_unshethZap, dstGasForCall, dstNativeAmount, unsheth_path);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/ArbVdUshFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\r\\n\\r\\n// ================================================================\\r\\n// |\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\r\\n// |\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\\r\\n// | \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\\r\\n// ================================================================\\r\\n// ======================= GovernorsFarm =+++======================\\r\\n// ================================================================\\r\\n// Allows vdUSH users to enter the matrix and receive USH rewards\\r\\n// Users can claim their rewards at any time\\r\\n// No staking needed, just enter the matrix and claim rewards\\r\\n// No user deposits held in this contract!\\r\\n// ================================================================\\r\\n// Arbitrum Farm also allows claiming of GRAIL / xGRAIL rewards\\r\\n// ================================================================\\r\\n// Author: unshETH team (github.com/unsheth)\\r\\n// Heavily inspired by StakingRewards, MasterChef\\r\\n//\\r\\n\\r\\ninterface IxGrail is IERC20 {\\r\\n    function convertTo(uint amount, address to) external;\\r\\n}\\r\\n\\r\\ninterface IvdUSH {\\r\\n    function totalSupply() external view returns(uint);\\r\\n    function balanceOf(address account) external view returns(uint);\\r\\n    function deposit_for(address _addr, uint _valueA, uint _valueB, uint _valueC) external;\\r\\n    function balanceOfAtT(address account, uint ts) external view returns(uint);\\r\\n    function totalSupplyAtT(uint t) external view returns(uint);\\r\\n    function user_point_epoch(address account) external view returns(uint);\\r\\n    function user_point_history__ts(address _addr, uint _idx) external view returns (uint);\\r\\n}\\r\\n\\r\\ncontract GovernorsFarm is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public constant USH = IERC20(0x51A80238B5738725128d3a3e06Ab41c1d4C05C74);\\r\\n    IvdUSH public constant vdUsh = IvdUSH(0x69E3877a2A81345BAFD730e3E3dbEF74359988cA);\\r\\n    IERC20 public constant GRAIL = IERC20(0x3d9907F9a368ad0a51Be60f7Da3b97cf940982D8);\\r\\n    IxGrail public constant xGRAIL = IxGrail(0x3CAaE25Ee616f2C8E13C74dA0813402eae3F496b);\\r\\n    \\r\\n    uint public vdUshPercentage = 80e18; //percentage of rewards to lock as vdUSH\\r\\n    uint public xGrailPercentage = 80e18; //percentage of GRAIL rewards to lock as xGRAIL\\r\\n\\r\\n    //check if an address has entered the matrix\\r\\n    mapping(address => bool) public isInMatrix;\\r\\n    address[] public users; //array of users in the matrix\\r\\n\\r\\n    uint public ushPerSec;\\r\\n    uint public grailPerSec;\\r\\n    uint public startTime;\\r\\n\\r\\n    mapping(address => uint) public lastClaimTimestamp;\\r\\n    mapping(address => uint) public lastClaimVdUshBalance;\\r\\n    mapping(address => uint) public lastClaimTotalSupply;\\r\\n    mapping(address => bool) public isBlocked; //if a user is blocked from claiming rewards\\r\\n\\r\\n    uint internal constant WEEK = 1 weeks;\\r\\n\\r\\n    event MatrixEntered(address indexed _user);\\r\\n    event RewardsClaimed(address indexed _user, uint _ushClaimed, uint _vdUSHClaimed, uint _grailClaimed, uint _xGrailClaimed);\\r\\n    event RewardRateUpdated(uint _ushPerSec, uint _grailPerSec);\\r\\n    event LockPercentageUpdated(uint _vdUshLockPercentage, uint _xGrailLockPercentage);\\r\\n    event BlockListUpdated(address indexed _user, bool _isBlocked);\\r\\n    event FarmStarted(uint _ushPerSec, uint _grailPerSec, uint _startTime);\\r\\n\\r\\n    //Constructor\\r\\n    constructor() {\\r\\n        USH.approve(address(vdUsh), type(uint).max); //for locking on behalf of users\\r\\n        GRAIL.approve(address(xGRAIL), type(uint).max); //for locking on behalf of users\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Allows a user with non zero vdUSH balance to enter the matrix and start earning farm rewards.\\r\\n     * The user's address is registered in a mapping.\\r\\n     * The user's last claim timestamp is set to the current block timestamp (rewards start from the moment they enter).\\r\\n     * @param user The address of the user entering the matrix.\\r\\n     */\\r\\n    function enterMatrix(address user) external nonReentrant {\\r\\n        _enterMatrix(user);\\r\\n    }\\r\\n\\r\\n    function _enterMatrix(address user) internal {\\r\\n        require(!isInMatrix[user], \\\"Already in matrix\\\");\\r\\n        require(vdUsh.balanceOf(user) > 0, \\\"Cannot enter the matrix without vdUSH\\\");\\r\\n        isInMatrix[user] = true;\\r\\n        users.push(user);\\r\\n        lastClaimTimestamp[user] = block.timestamp;\\r\\n        emit MatrixEntered(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculate user's earned USH and vdUSH rewards since last claim.\\r\\n     * User earned rewards are proportional to their share of total vdUSH at the time of claim.\\r\\n     * @param user The address of the user entering the matrix.\\r\\n     */\\r\\n    function earned(address user) public view returns (uint, uint, uint, uint) {\\r\\n        require(isInMatrix[user], \\\"User not in matrix\\\");\\r\\n        require(startTime!= 0 && block.timestamp > startTime, \\\"Farm not started\\\");\\r\\n        require(!isBlocked[user], \\\"User is blocked from claiming rewards\\\");\\r\\n\\r\\n        //calculate time from which to start accum rewards, max of (time user entered matrix, farm start time, last claim time)\\r\\n        uint lastClaimTimeStamp = lastClaimTimestamp[user] > startTime ? lastClaimTimestamp[user] : startTime;\\r\\n\\r\\n        uint secsSinceLastClaim = block.timestamp - lastClaimTimeStamp;\\r\\n        uint lastEpoch = vdUsh.user_point_epoch(user);\\r\\n        uint lastEpochTimestamp = vdUsh.user_point_history__ts(user, lastEpoch);\\r\\n\\r\\n        uint userVdUsh;\\r\\n        uint totalVdUsh;\\r\\n\\r\\n        userVdUsh = lastClaimVdUshBalance[user];\\r\\n        totalVdUsh = lastClaimTotalSupply[user];\\r\\n\\r\\n        //sampling:\\r\\n        //fyi we start at i=1, bc i=0 is the lastClaim which is already stored\\r\\n        for(uint i = 1; i < 53;) {\\r\\n            uint timestamp = lastClaimTimeStamp + i * 1 weeks;\\r\\n            //if 1 wk after last claim is after current block timestamp, break\\r\\n            if(timestamp > block.timestamp) {\\r\\n                userVdUsh += vdUsh.balanceOf(user);\\r\\n                totalVdUsh += vdUsh.totalSupply();\\r\\n                break;\\r\\n            }\\r\\n            //round down to nearest week if needed\\r\\n            if(timestamp > lastEpochTimestamp) {\\r\\n                timestamp = lastEpochTimestamp;\\r\\n            }\\r\\n\\r\\n            userVdUsh += vdUsh.balanceOfAtT(user, timestamp);\\r\\n            totalVdUsh += vdUsh.totalSupplyAtT(timestamp);\\r\\n\\r\\n            unchecked{ ++i; }\\r\\n        }\\r\\n\\r\\n        uint averageVdUshShare = userVdUsh * 1e18 / totalVdUsh;\\r\\n\\r\\n        uint totalSupplyMultiplier = vdUsh.totalSupply() * 1e18 / getVdUshTotalSupplyInFarm();\\r\\n\\r\\n        uint totalWeight = averageVdUshShare * secsSinceLastClaim * totalSupplyMultiplier / 1e18;\\r\\n\\r\\n        uint ushEarned = totalWeight * ushPerSec / 1e18;\\r\\n        uint grailEarned = totalWeight * grailPerSec / 1e18;\\r\\n\\r\\n        uint lockedUsh = ushEarned * vdUshPercentage / 100e18;\\r\\n        uint claimableUsh = ushEarned - lockedUsh;\\r\\n\\r\\n        uint lockedGrail = grailEarned * xGrailPercentage / 100e18;\\r\\n        uint claimableGrail = grailEarned - lockedGrail;\\r\\n\\r\\n        return (claimableUsh, lockedUsh, claimableGrail, lockedGrail);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Claim\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function passGoAndCollect(address user) external nonReentrant {\\r\\n        uint claimableUsh;\\r\\n        uint lockedUsh;\\r\\n        uint claimableGrail;\\r\\n        uint lockedGrail;\\r\\n\\r\\n        (claimableUsh, lockedUsh, claimableGrail, lockedGrail) = earned(user);\\r\\n\\r\\n        require(lockedUsh > 0 || claimableUsh > 0 || claimableGrail > 0 || lockedGrail > 0, \\\"Nothing to claim\\\");\\r\\n\\r\\n        lastClaimTimestamp[user] = block.timestamp;\\r\\n        lastClaimVdUshBalance[user] = vdUsh.balanceOf(user);\\r\\n        lastClaimTotalSupply[user] = vdUsh.totalSupply();\\r\\n\\r\\n        //add to user's vdUSH if if nonzero\\r\\n        if(lockedUsh > 0) {\\r\\n            //add to user's vdUSH if their lock hasn't expired\\r\\n            if(vdUsh.balanceOf(user) != 0) {\\r\\n                vdUsh.deposit_for(user, 0, 0, lockedUsh);\\r\\n            } else {\\r\\n                lockedUsh = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        //transfer claimable USH to user if nonzero\\r\\n        if(claimableUsh > 0) {\\r\\n            USH.safeTransfer(user, claimableUsh);\\r\\n        }\\r\\n\\r\\n        //add to user's xGrail if nonzero\\r\\n        if(lockedGrail > 0) {\\r\\n            xGRAIL.convertTo(lockedGrail, user);\\r\\n        }\\r\\n\\r\\n        //transfer claimable Grail to user if nonzero\\r\\n        if(claimableGrail > 0) {\\r\\n            GRAIL.safeTransfer(user, claimableGrail);\\r\\n        }\\r\\n\\r\\n        emit RewardsClaimed(user, claimableUsh, lockedUsh, claimableGrail, lockedGrail);\\r\\n    }\\r\\n\\r\\n    //view funcs\\r\\n    function getAllUsers() public view returns (address[] memory) {\\r\\n        return users;\\r\\n    }\\r\\n\\r\\n    function getVdUshTotalSupply() public view returns (uint) {\\r\\n        return vdUsh.totalSupply();\\r\\n    }\\r\\n\\r\\n    function getVdUshTotalSupplyInFarm() public view returns (uint) {\\r\\n        uint totalVdUsh;\\r\\n        for(uint i = 0; i < users.length;) {\\r\\n            address user = users[i];\\r\\n            if(!isBlocked[user]) {\\r\\n                totalVdUsh += vdUsh.balanceOf(user);\\r\\n            }\\r\\n            unchecked{ ++i; }\\r\\n        }\\r\\n        return totalVdUsh;\\r\\n    }\\r\\n\\r\\n    //owner funcs\\r\\n    function startFarm(uint _ushPerSec, uint _grailPerSec) external onlyOwner {\\r\\n        require(startTime == 0, \\\"Farm already started\\\");\\r\\n        ushPerSec = _ushPerSec;\\r\\n        grailPerSec = _grailPerSec;\\r\\n        startTime = block.timestamp;\\r\\n        emit FarmStarted(_ushPerSec, _grailPerSec, startTime);\\r\\n    }\\r\\n\\r\\n    function updateRewardRate(uint _ushPerSec, uint _grailPerSec) external onlyOwner {\\r\\n        ushPerSec = _ushPerSec;\\r\\n        grailPerSec = _grailPerSec;\\r\\n        emit RewardRateUpdated(_ushPerSec, _grailPerSec);\\r\\n    }\\r\\n\\r\\n    function setLockPercentage(uint _vdUshPercentage, uint _xGrailPercentage) external onlyOwner {\\r\\n        require(_vdUshPercentage <= 100e18, \\\"vdUsh percentage too high\\\");\\r\\n        require(_xGrailPercentage <= 100e18, \\\"xGrail percentage too high\\\");\\r\\n        vdUshPercentage = _vdUshPercentage;\\r\\n        xGrailPercentage = _xGrailPercentage;\\r\\n        emit LockPercentageUpdated(_vdUshPercentage, _xGrailPercentage);\\r\\n    }\\r\\n\\r\\n    function updateBlockList(address _user, bool _isBlocked) external onlyOwner {\\r\\n        isBlocked[_user] = _isBlocked;\\r\\n        emit BlockListUpdated(_user, _isBlocked);\\r\\n    }\\r\\n\\r\\n    //emergency funcs\\r\\n    function recoverTokens(address token, uint amount, address dst) external onlyOwner {\\r\\n        require(dst != address(0), \\\"Cannot recover tokens to the zero address\\\");\\r\\n        IERC20(token).safeTransfer(dst, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/ARBVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n//Modified Multiple Token VotingEscrow Contract\\r\\n//The following changes have been made:\\r\\n//1. Users can lock either 80-20 USH-unshETH BPT, Uniswapv2 style pool2 token, or single-sided USH\\r\\n//2. Make sure deposit() and withdraw() funcs are correctly updated for the multi token model\\r\\n//3. Give owner ability to update boost weight of BPT and Pool2 tokens\\r\\n//4. Price everything in USH terms - this means pricing the BPT and Pool2 tokens in USH terms\\r\\n//5. Make 1 USH = 1vdUSH max locked for single-sided.\\r\\n//6. Pool2 included for easy migration of existing liquidity + enable locking in chains where BPT is not supported\\r\\n\\r\\n/// basically, where tokenAmount is used, we need to use scaledtokenAmount1+weight*tokenAmount2\\r\\n/**\\r\\n@title Multi-Token Weighted Voting Escrow\\r\\n@author unshETH, Original: Curve Finance, Solidity Rewrite: Stargate Finance\\r\\n@license MIT\\r\\n@notice Votes have a weight depending on time, so that users are\\r\\n        committed to the future of (whatever they are voting for)\\r\\n@dev Vote weight decays linearly over time. Lock time cannot be\\r\\n     more than `MAXTIME` (1 years).\\r\\n\\r\\n# Voting escrow to have time-weighted votes\\r\\n# Votes have a weight depending on time, so that users are committed\\r\\n# to the future of (whatever they are voting for).\\r\\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\\r\\n# w ^\\r\\n# 1 +        /\\r\\n#   |      /\\r\\n#   |    /\\r\\n#   |  /\\r\\n#   |/\\r\\n# 0 +--------+------> time\\r\\n#       maxtime (1 years?)\\r\\n*/\\r\\n\\r\\nimport \\\"openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\n\\r\\nstruct Point {\\r\\n    int128 bias;\\r\\n    int128 slope; // # -dweight / dt\\r\\n    uint ts;\\r\\n    uint blk; // block\\r\\n}\\r\\n/* We cannot really do block numbers per se b/c slope is per time, not per block\\r\\n * and per block could be fairly bad b/c Ethereum changes blocktimes.\\r\\n * What we can do is to extrapolate ***At functions */\\r\\n\\r\\nstruct LockedBalance {\\r\\n    int128 amount; //weightedAmount\\r\\n    uint256 amountA;\\r\\n    uint256 amountB;\\r\\n    uint256 amountC;\\r\\n    uint end;\\r\\n}\\r\\n\\r\\ninterface IPool2 is IERC20 {\\r\\n    function getReserves() external view returns (uint112 _reserveA, uint112 _reserveB, uint16 _token0FeePercent, uint16 _token1FeePercent);\\r\\n}\\r\\n\\r\\ninterface IBPT is IERC20 {\\r\\n    function getVault() external view returns (address);\\r\\n    function getPoolId() external view returns (bytes32);\\r\\n}\\r\\n\\r\\ninterface IBPTVault {\\r\\n    function getPoolTokenInfo(\\r\\n        bytes32 poolId,\\r\\n        address token\\r\\n    ) external view returns (uint256, uint256, uint256, address);\\r\\n}\\r\\n\\r\\ncontract VotingEscrow is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    enum DepositType {\\r\\n        DEPOSIT_FOR_TYPE,\\r\\n        CREATE_LOCK_TYPE,\\r\\n        INCREASE_LOCK_AMOUNT,\\r\\n        INCREASE_UNLOCK_TIME\\r\\n    }\\r\\n\\r\\n    event Deposit(\\r\\n        address indexed provider,\\r\\n        uint valueA,\\r\\n        uint valueB,\\r\\n        uint valueC,\\r\\n        uint indexed locktime,\\r\\n        DepositType deposit_type,\\r\\n        uint ts\\r\\n    );\\r\\n    event Withdraw(address indexed provider, uint valueA, uint valueB, uint valueC, uint ts);\\r\\n    event Supply(uint prevSupply, uint supply);\\r\\n\\r\\n    uint internal constant WEEK = 1 weeks;\\r\\n    uint public constant MAXTIME = 53 weeks; //max lock 1 year\\r\\n    int128 internal constant iMAXTIME = 53 weeks;\\r\\n    uint public constant MINTIME = 4 weeks;\\r\\n    uint internal constant MULTIPLIER = 1 ether;\\r\\n\\r\\n    //a dynamic boost weight that is configurable\\r\\n    uint256 public bpt_boost_weight;\\r\\n    uint256 public pool2_boost_weight;\\r\\n\\r\\n    address public immutable tokenA; //BPT\\r\\n    address public immutable tokenB; //Pool2 LP Token\\r\\n    address public immutable tokenC; //Single-sided USH Token\\r\\n    uint public supply;\\r\\n    bool public unlocked;\\r\\n\\r\\n    mapping(address => LockedBalance) public locked; //weighted locked balance\\r\\n\\r\\n    uint public epoch;\\r\\n    mapping(uint => Point) public point_history; // epoch -> unsigned point\\r\\n    mapping(address => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\\r\\n    mapping(address => uint) public user_point_epoch;\\r\\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\\r\\n\\r\\n    // Aragon's view methods for compatibility\\r\\n    address public controller;\\r\\n    bool public transfersEnabled;\\r\\n\\r\\n    string public constant name = \\\"vdUSH\\\";\\r\\n    string public constant symbol = \\\"vdUSH\\\";\\r\\n    string public constant version = \\\"1.0.0\\\";\\r\\n    uint8 public constant decimals = 18;\\r\\n\\r\\n    // Whitelisted (smart contract) wallets which are allowed to deposit\\r\\n    // The goal is to prevent tokenizing the escrow\\r\\n    mapping(address => bool) public contracts_whitelist;\\r\\n\\r\\n    /// @notice Contract constructor\\r\\n    /// @param tokenA_addr BPT\\r\\n    /// @param tokenB_addr Pool2 LP token\\r\\n    /// @param tokenC_addr USH token\\r\\n    constructor(address tokenA_addr, address tokenB_addr, address tokenC_addr) {\\r\\n        tokenA = tokenA_addr;\\r\\n        tokenB = tokenB_addr;\\r\\n        tokenC = tokenC_addr;\\r\\n        bpt_boost_weight = 2.5 ether;\\r\\n        pool2_boost_weight = 5 ether;\\r\\n        point_history[0].blk = block.number;\\r\\n        point_history[0].ts = block.timestamp;\\r\\n        controller = msg.sender;\\r\\n        transfersEnabled = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyUserOrWhitelist() {\\r\\n        if (msg.sender != tx.origin) {\\r\\n            require(contracts_whitelist[msg.sender], \\\"Smart contract not allowed\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notUnlocked() {\\r\\n        require(!unlocked, \\\"unlocked globally\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //helper unit conversion funcs\\r\\n    function bpt_amount_to_ush_units(uint256 amount) internal view returns (uint256) {\\r\\n        //get the contract address of the BPT pool token\\r\\n        IBPT bpt = IBPT(tokenA);\\r\\n        //get vault and pool info\\r\\n        address balancer_vault = bpt.getVault();\\r\\n        bytes32 pool_id = bpt.getPoolId();\\r\\n        //get the balance of token A in the BPT pool\\r\\n        (uint256 ush_balance, , , ) = IBPTVault(balancer_vault).getPoolTokenInfo(pool_id, tokenC);\\r\\n        //get the total supply of the BPT pool\\r\\n        uint256 total_supply = bpt.totalSupply();\\r\\n        //calculate the amount of token C units\\r\\n        return (amount * ush_balance) / total_supply;\\r\\n    }\\r\\n\\r\\n    function pool2_amount_to_ush_units(uint256 amount) internal view returns (uint256) {\\r\\n        //get the contract address of the BPT pool token\\r\\n        IPool2 pool2 = IPool2(tokenB);\\r\\n        //get vault and pool info\\r\\n        (uint256 ush_balance, , , ) = pool2.getReserves();\\r\\n        //get the total supply of the pool2\\r\\n        uint256 total_supply = pool2.totalSupply();\\r\\n        //calculate the amount of token C units\\r\\n        return (amount * ush_balance) / total_supply;\\r\\n    }\\r\\n\\r\\n    function update_bpt_boost_weight(uint256 weight) external onlyOwner {\\r\\n        require(weight > 0, \\\"Cannot set zero boost weight!\\\");\\r\\n        bpt_boost_weight = weight;\\r\\n    }\\r\\n\\r\\n    function update_pool2_boost_weight(uint256 weight) external onlyOwner {\\r\\n        require(weight > 0, \\\"Cannot set zero boost weight!\\\");\\r\\n        pool2_boost_weight = weight;\\r\\n    }\\r\\n\\r\\n    function weighted_amount(uint256 bptAmount, uint256 pool2Amount, uint256 tokenAmount) public view returns (uint256) {\\r\\n\\r\\n        uint256 scaled_bpt_amount = tokenA == address(0) ? 0 : bpt_amount_to_ush_units(bptAmount);\\r\\n\\r\\n        uint256 scaled_pool2_amount = pool2_amount_to_ush_units(pool2Amount);\\r\\n\\r\\n        return (scaled_bpt_amount * bpt_boost_weight) / 1e18 + (scaled_pool2_amount * pool2_boost_weight) / 1e18 + tokenAmount;\\r\\n    }\\r\\n\\r\\n    function int_weighted_amount(uint256 _valueA, uint256 _valueB, uint256 _valueC) internal view returns (int128) {\\r\\n        return int128(int(weighted_amount(_valueA, _valueB, _valueC)));\\r\\n    }\\r\\n\\r\\n    /// @notice Add address to whitelist smart contract depositors `addr`\\r\\n    /// @param addr Address to be whitelisted\\r\\n    function add_to_whitelist(address addr) external onlyOwner {\\r\\n        require(!contracts_whitelist[addr], \\\"Address already whitelisted\\\");\\r\\n        contracts_whitelist[addr] = true;\\r\\n    }\\r\\n\\r\\n    /// @notice Remove a smart contract address from whitelist\\r\\n    /// @param addr Address to be removed from whitelist\\r\\n    function remove_from_whitelist(address addr) external onlyOwner {\\r\\n        require(contracts_whitelist[addr], \\\"Address not whitelisted\\\");\\r\\n        contracts_whitelist[addr] = false;\\r\\n    }\\r\\n\\r\\n    /// @notice Unlock all locked balances\\r\\n    function unlock() external onlyOwner {\\r\\n        unlocked = true;\\r\\n    }\\r\\n\\r\\n    /// @notice Get the most recently recorded rate of voting power decrease for `_addr`\\r\\n    /// @param addr Address of the user wallet\\r\\n    /// @return Value of the slope\\r\\n    function get_last_user_slope(address addr) external view returns (int128) {\\r\\n        uint uepoch = user_point_epoch[addr];\\r\\n        return user_point_history[addr][uepoch].slope;\\r\\n    }\\r\\n\\r\\n    /// @notice Get the timestamp for checkpoint `_idx` for `_addr`\\r\\n    /// @param _addr User wallet address\\r\\n    /// @param _idx User epoch number\\r\\n    /// @return Epoch time of the checkpoint\\r\\n    function user_point_history__ts(address _addr, uint _idx) external view returns (uint) {\\r\\n        return user_point_history[_addr][_idx].ts;\\r\\n    }\\r\\n\\r\\n    /// @notice Get timestamp when `_addr`'s lock finishes\\r\\n    /// @param _addr User wallet address\\r\\n    /// @return Epoch time of the lock end\\r\\n    function locked__end(address _addr) external view returns (uint) {\\r\\n        return locked[_addr].end;\\r\\n    }\\r\\n\\r\\n    function locked__amountA(address user) external view returns (uint) {\\r\\n        return locked[user].amountA;\\r\\n    }\\r\\n\\r\\n    function locked__amountB(address user) external view returns (uint) {\\r\\n        return locked[user].amountB;\\r\\n    }\\r\\n\\r\\n    function locked__amountC(address user) external view returns (uint) {\\r\\n        return locked[user].amountC;\\r\\n    }\\r\\n\\r\\n    /// @notice Record global and per-user data to checkpoint\\r\\n    /// @param _addr User's wallet address. No user checkpoint if 0x0\\r\\n    /// @param old_locked Pevious locked amount / end lock time for the user\\r\\n    /// @param new_locked New locked amount / end lock time for the user\\r\\n    function _checkpoint(\\r\\n        address _addr,\\r\\n        LockedBalance memory old_locked,\\r\\n        LockedBalance memory new_locked\\r\\n    ) internal {\\r\\n        Point memory u_old;\\r\\n        Point memory u_new;\\r\\n        int128 old_dslope = 0;\\r\\n        int128 new_dslope = 0;\\r\\n        uint _epoch = epoch;\\r\\n\\r\\n        //make sure we are using the most current BPT boost weights\\r\\n        //and then make sure the new_locked that was passed in has had the most current boost weights applied (do that elsewhere)\\r\\n        old_locked.amount = int_weighted_amount(old_locked.amountA, old_locked.amountB, old_locked.amountC);\\r\\n\\r\\n        if (_addr != address(0x0)) {\\r\\n            // Calculate slopes and biases\\r\\n            // Kept at zero when they have to\\r\\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\\r\\n                u_old.slope = old_locked.amount / iMAXTIME;\\r\\n                u_old.bias = u_old.slope * int128(int(old_locked.end - block.timestamp));\\r\\n            }\\r\\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\\r\\n                u_new.slope = new_locked.amount / iMAXTIME;\\r\\n                u_new.bias = u_new.slope * int128(int(new_locked.end - block.timestamp));\\r\\n            }\\r\\n\\r\\n            // Read values of scheduled changes in the slope\\r\\n            // old_locked.end can be in the past and in the future\\r\\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\\r\\n            old_dslope = slope_changes[old_locked.end];\\r\\n            if (new_locked.end != 0) {\\r\\n                if (new_locked.end == old_locked.end) {\\r\\n                    new_dslope = old_dslope;\\r\\n                } else {\\r\\n                    new_dslope = slope_changes[new_locked.end];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Point memory last_point = Point({ bias: 0, slope: 0, ts: block.timestamp, blk: block.number });\\r\\n        if (_epoch > 0) {\\r\\n            last_point = point_history[_epoch];\\r\\n        }\\r\\n        uint last_checkpoint = last_point.ts;\\r\\n        // initial_last_point is used for extrapolation to calculate block number\\r\\n        // (approximately, for *At methods) and save them\\r\\n        // as we cannot figure that out exactly from inside the contract\\r\\n\\r\\n        uint initial_last_point_ts = last_point.ts;\\r\\n        uint initial_last_point_blk = last_point.blk;\\r\\n\\r\\n        uint block_slope = 0; // dblock/dt\\r\\n        if (block.timestamp > last_point.ts) {\\r\\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\\r\\n        }\\r\\n        // If last point is already recorded in this block, slope=0\\r\\n        // But that's ok b/c we know the block in such case\\r\\n\\r\\n        // Go over weeks to fill history and calculate what the current point is\\r\\n        uint t_i = (last_checkpoint / WEEK) * WEEK;\\r\\n        for (uint i = 0; i < 255; ++i) {\\r\\n            // Hopefully it won't happen that this won't get used in 5 years!\\r\\n            // If it does, users will be able to withdraw but vote weight will be broken\\r\\n            t_i += WEEK;\\r\\n            int128 d_slope = 0;\\r\\n            if (t_i > block.timestamp) {\\r\\n                t_i = block.timestamp;\\r\\n            } else {\\r\\n                d_slope = slope_changes[t_i];\\r\\n            }\\r\\n            last_point.bias -= last_point.slope * int128(int(t_i - last_checkpoint));\\r\\n            last_point.slope += d_slope;\\r\\n            if (last_point.bias < 0) {\\r\\n                // This can happen\\r\\n                last_point.bias = 0;\\r\\n            }\\r\\n            if (last_point.slope < 0) {\\r\\n                // This cannot happen - just in case\\r\\n                last_point.slope = 0;\\r\\n            }\\r\\n            last_checkpoint = t_i;\\r\\n            last_point.ts = t_i;\\r\\n            last_point.blk =\\r\\n            initial_last_point_blk +\\r\\n            (block_slope * (t_i - initial_last_point_ts)) /\\r\\n            MULTIPLIER;\\r\\n\\r\\n            _epoch += 1;\\r\\n            if (t_i == block.timestamp) {\\r\\n                last_point.blk = block.number;\\r\\n                break;\\r\\n            } else {\\r\\n                point_history[_epoch] = last_point;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        epoch = _epoch;\\r\\n        // Now point_history is filled until t=now\\r\\n\\r\\n        if (_addr != address(0x0)) {\\r\\n            // If last point was in this block, the slope change has been applied already\\r\\n            // But in such case we have 0 slope(s)\\r\\n            last_point.slope += (u_new.slope - u_old.slope);\\r\\n            last_point.bias += (u_new.bias - u_old.bias);\\r\\n            if (last_point.slope < 0) {\\r\\n                last_point.slope = 0;\\r\\n            }\\r\\n            if (last_point.bias < 0) {\\r\\n                last_point.bias = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Record the changed point into history\\r\\n        point_history[_epoch] = last_point;\\r\\n\\r\\n        if (_addr != address(0x0)) {\\r\\n            // Schedule the slope changes (slope is going down)\\r\\n            // We subtract new_user_slope from [new_locked.end]\\r\\n            // and add old_user_slope to [old_locked.end]\\r\\n            if (old_locked.end > block.timestamp) {\\r\\n                // old_dslope was <something> - u_old.slope, so we cancel that\\r\\n                old_dslope += u_old.slope;\\r\\n                if (new_locked.end == old_locked.end) {\\r\\n                    old_dslope -= u_new.slope; // It was a new deposit, not extension\\r\\n                }\\r\\n                slope_changes[old_locked.end] = old_dslope;\\r\\n            }\\r\\n\\r\\n            if (new_locked.end > block.timestamp) {\\r\\n                if (new_locked.end > old_locked.end) {\\r\\n                    new_dslope -= u_new.slope; // old slope disappeared at this point\\r\\n                    slope_changes[new_locked.end] = new_dslope;\\r\\n                }\\r\\n                // else: we recorded it already in old_dslope\\r\\n            }\\r\\n            // Now handle user history\\r\\n            address addr = _addr;\\r\\n            uint user_epoch = user_point_epoch[addr] + 1;\\r\\n\\r\\n            user_point_epoch[addr] = user_epoch;\\r\\n            u_new.ts = block.timestamp;\\r\\n            u_new.blk = block.number;\\r\\n            user_point_history[addr][user_epoch] = u_new;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Record global data to checkpoint\\r\\n    function checkpoint() external notUnlocked {\\r\\n        _checkpoint(\\r\\n            address(0x0),\\r\\n            LockedBalance(int_weighted_amount(0, 0, 0), 0, 0, 0, 0),\\r\\n            LockedBalance(int_weighted_amount(0, 0, 0), 0, 0, 0, 0)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deposit_for(address _addr, uint _valueA, uint _valueB, uint _valueC) external nonReentrant {\\r\\n        LockedBalance memory _locked = locked[_addr];\\r\\n\\r\\n        require(_valueA > 0 || _valueB > 0 || _valueC > 0); // dev: need non-zero value\\r\\n        require(_locked.amount > 0, \\\"No existing lock found\\\");\\r\\n        require(_locked.end > block.timestamp, \\\"Cannot add to expired lock. Withdraw\\\");\\r\\n        _deposit_for(_addr, _valueA, _valueB, _valueC, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\\r\\n    }\\r\\n\\r\\n    function _deposit_for(\\r\\n        address _addr,\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint unlock_time,\\r\\n        LockedBalance memory locked_balance,\\r\\n        DepositType deposit_type\\r\\n    ) internal {\\r\\n        LockedBalance memory _locked = locked_balance;\\r\\n        uint supply_before = supply;\\r\\n\\r\\n        supply = supply_before + weighted_amount(_valueA, _valueB, _valueC);\\r\\n        LockedBalance memory old_locked;\\r\\n        //NOTE: need to be checked\\r\\n        _locked.amount = int128(int(weighted_amount(_locked.amountA, _locked.amountB, _locked.amountC)));\\r\\n        // old_locked.amount = int128(int(weighted_amount(old_locked.amountA, old_locked.amountB)));\\r\\n        (old_locked.amount, old_locked.end) = (_locked.amount, _locked.end);\\r\\n        // Adding to existing lock, or if a lock is expired - creating a new one\\r\\n        _locked.amount += int128(int(weighted_amount(_valueA, _valueB, _valueC)));\\r\\n        _locked.amountA += _valueA;\\r\\n        _locked.amountB += _valueB;\\r\\n        _locked.amountC += _valueC;\\r\\n\\r\\n        if (unlock_time != 0) {\\r\\n            _locked.end = unlock_time;\\r\\n        }\\r\\n        locked[_addr] = _locked;\\r\\n\\r\\n        // Possibilities:\\r\\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\\r\\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\\r\\n        // _locked.end > block.timestamp (always)\\r\\n        _checkpoint(_addr, old_locked, _locked);\\r\\n\\r\\n        if (_valueA != 0) {\\r\\n            IERC20(tokenA).safeTransferFrom(msg.sender, address(this), _valueA);\\r\\n        }\\r\\n\\r\\n        if (_valueB != 0) {\\r\\n            IERC20(tokenB).safeTransferFrom(msg.sender, address(this), _valueB);\\r\\n        }\\r\\n\\r\\n        if (_valueC != 0) {\\r\\n            IERC20(tokenC).safeTransferFrom(msg.sender, address(this), _valueC);\\r\\n        }\\r\\n\\r\\n        emit Deposit(_addr, _valueA, _valueB, _valueC, _locked.end, deposit_type, block.timestamp);\\r\\n        emit Supply(supply_before, supply_before + weighted_amount(_valueA, _valueB, _valueC));\\r\\n    }\\r\\n\\r\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    /// @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\\r\\n    function _create_lock(uint _valueA, uint _valueB, uint _valueC, uint _unlock_time) internal {\\r\\n        require(_valueA > 0 || _valueB > 0 || _valueC > 0); // dev: need non-zero value\\r\\n\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n        require(_locked.amount == 0, \\\"Withdraw old tokens first\\\");\\r\\n\\r\\n        require(_unlock_time >= block.timestamp + MINTIME, \\\"Voting lock must be at least MINTIME\\\");\\r\\n        //NOTE:MAXTIME is set to 1 year, may be changed to 3 years\\r\\n        require(_unlock_time <= block.timestamp + MAXTIME, \\\"Voting lock can be 1 year max\\\");\\r\\n        //NOTE: calc only if valid time to save on gas\\r\\n        uint unlock_time = (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\\r\\n\\r\\n        _deposit_for(msg.sender, _valueA, _valueB, _valueC, unlock_time, _locked, DepositType.CREATE_LOCK_TYPE);\\r\\n    }\\r\\n\\r\\n    /// @notice External function for _create_lock\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    /// @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\\r\\n    function create_lock(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint _unlock_time\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _create_lock(_valueA, _valueB, _valueC, _unlock_time);\\r\\n    }\\r\\n\\r\\n    /// @notice Deposit `_value` additional tokens for `msg.sender` without modifying the unlock time\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    function increase_amount(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _increase_amount(_valueA, _valueB, _valueC);\\r\\n    }\\r\\n\\r\\n    function _increase_amount(uint _valueA, uint _valueB, uint _valueC) internal {\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n\\r\\n        require(_valueA > 0 || _valueB > 0 || _valueC > 0); // dev: need non-zero value\\r\\n        require(_locked.amount > 0, \\\"No existing lock found\\\");\\r\\n        require(_locked.end > block.timestamp, \\\"Cannot add to expired lock. Withdraw\\\");\\r\\n\\r\\n        _deposit_for(msg.sender, _valueA, _valueB, _valueC, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\\r\\n    }\\r\\n\\r\\n    /// @notice Extend the unlock time for `msg.sender` to `_unlock_time`\\r\\n    /// @param _unlock_time New epoch time for unlocking\\r\\n    function increase_unlock_time(uint _unlock_time) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _increase_unlock_time(_unlock_time);\\r\\n    }\\r\\n\\r\\n    function _increase_unlock_time(uint _unlock_time) internal {\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n        uint unlock_time = (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\\r\\n\\r\\n        require(_locked.end > block.timestamp, \\\"Lock expired\\\");\\r\\n        require(_locked.amount > 0, \\\"Nothing is locked\\\");\\r\\n        require(unlock_time > _locked.end, \\\"Can only increase lock duration\\\");\\r\\n        require(unlock_time <= block.timestamp + MAXTIME, \\\"Voting lock can be 3 years max\\\");\\r\\n\\r\\n        _deposit_for(msg.sender, 0, 0, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\\r\\n    }\\r\\n\\r\\n    /// @notice Extend the unlock time and/or for `msg.sender` to `_unlock_time`\\r\\n    /// @param _unlock_time New epoch time for unlocking\\r\\n    function increase_amount_and_time(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint _unlock_time\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        require((_valueA > 0 || _valueB > 0 || _valueC > 0) || _unlock_time > 0, \\\"Value and Unlock cannot both be 0\\\");\\r\\n        if ((_valueA > 0 || _valueB > 0 || _valueC > 0) && _unlock_time > 0) {\\r\\n            _increase_amount(_valueA, _valueB, _valueC);\\r\\n            _increase_unlock_time(_unlock_time);\\r\\n        } else if ((_valueA > 0 || _valueB > 0 || _valueC > 0) && _unlock_time == 0) {\\r\\n            _increase_amount(_valueA, _valueB, _valueC);\\r\\n        } else {\\r\\n            _increase_unlock_time(_unlock_time);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw all tokens for `msg.sender`\\r\\n    /// @dev Only possible if the lock has expired\\r\\n    function _withdraw() internal {\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n        uint256 token_a_balance = _locked.amountA;\\r\\n        uint256 token_b_balance = _locked.amountB;\\r\\n        uint256 token_c_balance = _locked.amountC;\\r\\n        uint value = uint(int(_locked.amount));\\r\\n\\r\\n        if (!unlocked) {\\r\\n            require(block.timestamp >= _locked.end, \\\"The lock didn't expire\\\");\\r\\n        }\\r\\n\\r\\n        locked[msg.sender] = LockedBalance(0, 0, 0, 0, 0);\\r\\n        uint supply_before = supply;\\r\\n        supply = supply_before - value;\\r\\n\\r\\n        // old_locked can have either expired <= timestamp or zero end\\r\\n        // _locked has only 0 end\\r\\n        // Both can have >= 0 amount\\r\\n        _checkpoint(msg.sender, _locked, LockedBalance(0, 0, 0, 0, 0));\\r\\n\\r\\n        if(token_a_balance > 0) {\\r\\n            IERC20(tokenA).safeTransfer(msg.sender, token_a_balance);\\r\\n        }\\r\\n        if(token_b_balance > 0) {\\r\\n            IERC20(tokenB).safeTransfer(msg.sender, token_b_balance);\\r\\n        }\\r\\n        if(token_c_balance > 0) {\\r\\n            IERC20(tokenC).safeTransfer(msg.sender, token_c_balance);\\r\\n        }\\r\\n        emit Withdraw(msg.sender, token_a_balance, token_b_balance, token_c_balance, block.timestamp);\\r\\n        emit Supply(supply_before, supply_before - value);\\r\\n    }\\r\\n\\r\\n    function withdraw() external nonReentrant {\\r\\n        _withdraw();\\r\\n    }\\r\\n\\r\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    /// @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\\r\\n    function withdraw_and_create_lock(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint _unlock_time\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _withdraw();\\r\\n        _create_lock(_valueA, _valueB, _valueC, _unlock_time);\\r\\n    }\\r\\n\\r\\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\\r\\n    // They measure the weights for the purpose of voting, so they don't represent\\r\\n    // real coins.\\r\\n\\r\\n    /// @notice Binary search to estimate timestamp for block number\\r\\n    /// @param _block Block to find\\r\\n    /// @param max_epoch Don't go beyond this epoch\\r\\n    /// @return Approximate timestamp for block\\r\\n    function _find_block_epoch(uint _block, uint max_epoch) internal view returns (uint) {\\r\\n        // Binary search\\r\\n        uint _min = 0;\\r\\n        uint _max = max_epoch;\\r\\n        for (uint i = 0; i < 128; ++i) {\\r\\n            // Will be always enough for 128-bit numbers\\r\\n            if (_min >= _max) {\\r\\n                break;\\r\\n            }\\r\\n            uint _mid = (_min + _max + 1) / 2;\\r\\n            if (point_history[_mid].blk <= _block) {\\r\\n                _min = _mid;\\r\\n            } else {\\r\\n                _max = _mid - 1;\\r\\n            }\\r\\n        }\\r\\n        return _min;\\r\\n    }\\r\\n\\r\\n    /// @notice Get the current voting power for `msg.sender`\\r\\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\r\\n    /// @param addr User wallet address\\r\\n    /// @param _t Epoch time to return voting power at\\r\\n    /// @return User voting power\\r\\n    function _balanceOf(address addr, uint _t) internal view returns (uint) {\\r\\n        uint _epoch = user_point_epoch[addr];\\r\\n        if (_epoch == 0) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            Point memory last_point = user_point_history[addr][_epoch];\\r\\n            last_point.bias -= last_point.slope * int128(int(_t) - int(last_point.ts));\\r\\n            if (last_point.bias < 0) {\\r\\n                last_point.bias = 0;\\r\\n            }\\r\\n            return uint(int(last_point.bias));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function balanceOfAtT(address addr, uint _t) external view returns (uint) {\\r\\n        return _balanceOf(addr, _t);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address addr) external view returns (uint) {\\r\\n        return _balanceOf(addr, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Measure voting power of `addr` at block height `_block`\\r\\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\\r\\n    /// @param addr User's wallet address\\r\\n    /// @param _block Block to calculate the voting power at\\r\\n    /// @return Voting power\\r\\n    function balanceOfAt(address addr, uint _block) external view returns (uint) {\\r\\n        // Copying and pasting totalSupply code because Vyper cannot pass by\\r\\n        // reference yet\\r\\n        require(_block <= block.number);\\r\\n\\r\\n        // Binary search\\r\\n        uint _min = 0;\\r\\n        uint _max = user_point_epoch[addr];\\r\\n        for (uint i = 0; i < 128; ++i) {\\r\\n            // Will be always enough for 128-bit numbers\\r\\n            if (_min >= _max) {\\r\\n                break;\\r\\n            }\\r\\n            uint _mid = (_min + _max + 1) / 2;\\r\\n            if (user_point_history[addr][_mid].blk <= _block) {\\r\\n                _min = _mid;\\r\\n            } else {\\r\\n                _max = _mid - 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Point memory upoint = user_point_history[addr][_min];\\r\\n\\r\\n        uint max_epoch = epoch;\\r\\n        uint _epoch = _find_block_epoch(_block, max_epoch);\\r\\n        Point memory point_0 = point_history[_epoch];\\r\\n        uint d_block = 0;\\r\\n        uint d_t = 0;\\r\\n        if (_epoch < max_epoch) {\\r\\n            Point memory point_1 = point_history[_epoch + 1];\\r\\n            d_block = point_1.blk - point_0.blk;\\r\\n            d_t = point_1.ts - point_0.ts;\\r\\n        } else {\\r\\n            d_block = block.number - point_0.blk;\\r\\n            d_t = block.timestamp - point_0.ts;\\r\\n        }\\r\\n        uint block_time = point_0.ts;\\r\\n        if (d_block != 0) {\\r\\n            block_time += (d_t * (_block - point_0.blk)) / d_block;\\r\\n        }\\r\\n\\r\\n        upoint.bias -= upoint.slope * int128(int(block_time - upoint.ts));\\r\\n        if (upoint.bias >= 0) {\\r\\n            return uint(uint128(upoint.bias));\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate total voting power at some point in the past\\r\\n    /// @param point The point (bias/slope) to start search from\\r\\n    /// @param t Time to calculate the total voting power at\\r\\n    /// @return Total voting power at that time\\r\\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\\r\\n        Point memory last_point = point;\\r\\n        uint t_i = (last_point.ts / WEEK) * WEEK;\\r\\n        for (uint i = 0; i < 255; ++i) {\\r\\n            t_i += WEEK;\\r\\n            int128 d_slope = 0;\\r\\n            if (t_i > t) {\\r\\n                t_i = t;\\r\\n            } else {\\r\\n                d_slope = slope_changes[t_i];\\r\\n            }\\r\\n            last_point.bias -= last_point.slope * int128(int(t_i) - int(last_point.ts));\\r\\n            if (t_i == t) {\\r\\n                break;\\r\\n            }\\r\\n            last_point.slope += d_slope;\\r\\n            last_point.ts = t_i;\\r\\n        }\\r\\n\\r\\n        if (last_point.bias < 0) {\\r\\n            last_point.bias = 0;\\r\\n        }\\r\\n        return uint(uint128(last_point.bias));\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate total voting power\\r\\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\\r\\n    /// @return Total voting power\\r\\n    function _totalSupply(uint t) internal view returns (uint) {\\r\\n        uint _epoch = epoch;\\r\\n        Point memory last_point = point_history[_epoch];\\r\\n        return _supply_at(last_point, t);\\r\\n    }\\r\\n\\r\\n    function totalSupplyAtT(uint t) external view returns (uint) {\\r\\n        return _totalSupply(t);\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view returns (uint) {\\r\\n        return _totalSupply(block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate total voting power at some point in the past\\r\\n    /// @param _block Block to calculate the total voting power at\\r\\n    /// @return Total voting power at `_block`\\r\\n    function totalSupplyAt(uint _block) external view returns (uint) {\\r\\n        require(_block <= block.number);\\r\\n        uint _epoch = epoch;\\r\\n        uint target_epoch = _find_block_epoch(_block, _epoch);\\r\\n\\r\\n        Point memory point = point_history[target_epoch];\\r\\n        uint dt = 0;\\r\\n        if (target_epoch < _epoch) {\\r\\n            Point memory point_next = point_history[target_epoch + 1];\\r\\n            if (point.blk != point_next.blk) {\\r\\n                dt = ((_block - point.blk) * (point_next.ts - point.ts)) / (point_next.blk - point.blk);\\r\\n            }\\r\\n        } else {\\r\\n            if (point.blk != block.number) {\\r\\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\\r\\n            }\\r\\n        }\\r\\n        // Now dt contains info on how far are we beyond point\\r\\n        return _supply_at(point, point.ts + dt);\\r\\n    }\\r\\n\\r\\n    // Dummy methods for compatibility with Aragon\\r\\n    function changeController(address _newController) external {\\r\\n        require(msg.sender == controller);\\r\\n        controller = _newController;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/BnbVdUshFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >0.8.10;\\r\\n\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"local/interfaces/IvdUSH.sol\\\";\\r\\nimport \\\"local/interfaces/IGovFarm.sol\\\";\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SignedSafeMath.sol\\\";\\r\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\r\\n\\r\\n// ================================================================\\r\\n// |\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\r\\n// |\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\\r\\n// | \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\\r\\n// ================================================================\\r\\n// ======================= GovernorsFarm =+++======================\\r\\n// ================================================================\\r\\n// Allows vdUSH users to enter the matrix and receive USH rewards\\r\\n// Users can claim their rewards at any time\\r\\n// No staking needed, just enter the matrix and claim rewards\\r\\n// No user deposits held in this contract!\\r\\n//\\r\\n// Author: unshETH team (github.com/unsheth)\\r\\n// Heavily inspired by StakingRewards, MasterChef\\r\\n//\\r\\n\\r\\ncontract GovernorsFarm is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SignedSafeMath for int256;\\r\\n\\r\\n    IERC20 public immutable USH = IERC20(0x91d6d6aF7635B7b23A8CED9508117965180e2362);\\r\\n    IvdUSH public immutable vdUsh = IvdUSH(0x953212fBA33c20763400370A0481C5129AE752d9);\\r\\n\\r\\n    uint public vdUshPercentage; //percentage of rewards to lock as vdUSH\\r\\n\\r\\n    //check if an address has entered the matrix\\r\\n    mapping(address => bool) public isInMatrix;\\r\\n    address[] public users; //array of users in the matrix\\r\\n\\r\\n    uint public ushPerSec;\\r\\n\\r\\n    mapping(address => uint) public lastClaimTimestamp;\\r\\n    mapping(address => uint) public lastClaimVdUshBalance;\\r\\n    mapping(address => uint) public lastClaimTotalSupply;\\r\\n    mapping(address => bool) public isBlocked; //if a user is blocked from claiming rewards\\r\\n\\r\\n    struct Point {\\r\\n        int128 bias;\\r\\n        int128 slope; // # -dweight / dt\\r\\n        uint ts;\\r\\n        uint blk; // block\\r\\n    }\\r\\n    uint internal constant WEEK = 1 weeks;\\r\\n\\r\\n    event MatrixEntered(address indexed _user);\\r\\n    event RewardsClaimed(address indexed _user, uint _ushClaimed, uint _vdUSHClaimed);\\r\\n    event RewardRateUpdated(uint _ushPerSec);\\r\\n    event LockPercentageUpdated(uint _vdUshLockPercentage);\\r\\n    event BlockListUpdated(address indexed _user, bool _isBlocked);\\r\\n\\r\\n    //Constructor\\r\\n    constructor(uint _ushPerSec, uint _vdUshPercentage, address _oldGovFarm) {\\r\\n        ushPerSec = _ushPerSec;\\r\\n        vdUshPercentage = _vdUshPercentage;\\r\\n        USH.approve(address(vdUsh), type(uint).max); //for locking on behalf of users\\r\\n\\r\\n        //Seed values from V1Farm for migration\\r\\n        IGovFarm oldGovFarm = IGovFarm(_oldGovFarm);\\r\\n        address[] memory v1Users = oldGovFarm.getAllUsers();\\r\\n        //Gas efficient method to migrate users in v1 farm with no require checks or events\\r\\n        for(uint i = 0; i < v1Users.length; ) {\\r\\n            address user = v1Users[i];\\r\\n            isInMatrix[user] = true;\\r\\n            users.push(user);\\r\\n            lastClaimTimestamp[user] = oldGovFarm.lastClaimTimestamp(user);\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows a user with non zero vdUSH balance to enter the matrix and start earning farm rewards.\\r\\n     * The user's address is registered in a mapping.\\r\\n     * The user's last claim timestamp is set to the current block timestamp (rewards start from the moment they enter).\\r\\n     * @param user The address of the user entering the matrix.\\r\\n     */\\r\\n    function enterMatrix(address user) external nonReentrant {\\r\\n        _enterMatrix(user);\\r\\n    }\\r\\n\\r\\n    function _enterMatrix(address user) internal {\\r\\n        require(!isInMatrix[user], \\\"Already in matrix\\\");\\r\\n        require(vdUsh.balanceOf(user) > 0, \\\"Cannot enter the matrix without vdUSH\\\");\\r\\n        isInMatrix[user] = true;\\r\\n        users.push(user);\\r\\n        lastClaimTimestamp[user] = block.timestamp;\\r\\n        emit MatrixEntered(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculate user's earned USH and vdUSH rewards since last claim.\\r\\n     * User earned rewards are proportional to their share of total vdUSH at the time of claim.\\r\\n     * @param user The address of the user entering the matrix.\\r\\n     */\\r\\n    function earned(address user) public view returns (uint, uint) {\\r\\n\\r\\n        require(isInMatrix[user], \\\"User not in matrix\\\");\\r\\n        //require(startTime!= 0 && block.timestamp > startTime, \\\"Farm not started\\\");\\r\\n        require(!isBlocked[user], \\\"User is blocked from claiming rewards\\\");\\r\\n\\r\\n        //calculate time from which to start accum rewards, max of (time user entered matrix, last claim time)\\r\\n        uint lastClaimTimeStamp = lastClaimTimestamp[user];\\r\\n\\r\\n        uint secsSinceLastClaim = block.timestamp - lastClaimTimeStamp;\\r\\n        uint lastEpoch = vdUsh.user_point_epoch(user);\\r\\n        uint lastEpochTimestamp = vdUsh.user_point_history__ts(user, lastEpoch);\\r\\n\\r\\n        uint userVdUsh;\\r\\n        uint totalVdUsh;\\r\\n\\r\\n        userVdUsh = lastClaimVdUshBalance[user];\\r\\n        totalVdUsh = lastClaimTotalSupply[user];\\r\\n\\r\\n        //sampling:\\r\\n        //fyi we start at i=1, bc i=0 is the lastClaim which is already stored\\r\\n        for(uint i = 1; i < 53;) {\\r\\n            uint timestamp = lastClaimTimeStamp + i * 1 weeks;\\r\\n            //if 1 wk after last claim is after current block timestamp, break\\r\\n            if(timestamp > block.timestamp) {\\r\\n                userVdUsh += vdUsh.balanceOf(user);\\r\\n                totalVdUsh += vdUsh.totalSupply();\\r\\n                break;\\r\\n            }\\r\\n            //round down to nearest week if needed\\r\\n            if(timestamp > lastEpochTimestamp) {\\r\\n                timestamp = lastEpochTimestamp;\\r\\n            }\\r\\n\\r\\n            userVdUsh += vdUsh.balanceOfAtT(user, timestamp);\\r\\n            //calculate totalSupplyAtT internally due to versioning issue in ve-contracts\\r\\n            totalVdUsh += _totalSupplyAtT(timestamp);\\r\\n\\r\\n            unchecked{ ++i; }\\r\\n        }\\r\\n\\r\\n        uint averageVdUshShare = userVdUsh * 1e18 / totalVdUsh;\\r\\n\\r\\n        //for bnb, calc totalSupplyMultiplier on the fly as vdUSH totalSupply is inaccurate\\r\\n        uint totalSupplyMultiplier = vdUsh.totalSupply() * 1e18 / getVdUshTotalSupplyInFarm();\\r\\n        uint totalWeight = averageVdUshShare * secsSinceLastClaim * totalSupplyMultiplier / 1e18;\\r\\n        uint ushEarned = totalWeight * ushPerSec / 1e18;\\r\\n\\r\\n        uint lockedUsh = ushEarned * vdUshPercentage / 100e18;\\r\\n        uint claimableUsh = ushEarned - lockedUsh;\\r\\n\\r\\n        return (claimableUsh, lockedUsh);\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Calculations to get correct total supply at historical point T\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function _get_point_history(uint _epoch) internal view returns (Point memory) {\\r\\n        (int128 bias, int128 slope, uint ts, uint blk) = vdUsh.point_history(_epoch);\\r\\n        return Point(bias, slope, ts, blk);\\r\\n    }\\r\\n\\r\\n    function _totalSupplyAtT(uint t) internal view returns (uint) {\\r\\n        uint _epoch = vdUsh.epoch();\\r\\n        Point memory last_point = _get_point_history(_epoch);\\r\\n        return _supply_at(last_point, t);\\r\\n    }\\r\\n\\r\\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\\r\\n        Point memory last_point = point;\\r\\n        uint t_i = (last_point.ts / WEEK) * WEEK;\\r\\n        for (uint i = 0; i < 255; ++i) {\\r\\n            t_i += WEEK;\\r\\n            int128 d_slope = 0;\\r\\n            if (t_i > t) {\\r\\n                t_i = t;\\r\\n            } else {\\r\\n                d_slope = vdUsh.slope_changes(t_i);\\r\\n            }\\r\\n            last_point.bias -= last_point.slope * int128(int(t_i) - int(last_point.ts));\\r\\n            if (t_i == t) {\\r\\n                break;\\r\\n            }\\r\\n            last_point.slope += d_slope;\\r\\n            last_point.ts = t_i;\\r\\n        }\\r\\n\\r\\n        if (last_point.bias < 0) {\\r\\n            last_point.bias = 0;\\r\\n        }\\r\\n        return uint(uint128(last_point.bias));\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Claim\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function passGoAndCollect(address user) external nonReentrant {\\r\\n        uint claimableUsh;\\r\\n        uint lockedUsh;\\r\\n\\r\\n        (claimableUsh, lockedUsh) = earned(user);\\r\\n\\r\\n        require(lockedUsh > 0 || claimableUsh > 0, \\\"Nothing to claim\\\");\\r\\n\\r\\n        lastClaimTimestamp[user] = block.timestamp;\\r\\n        lastClaimVdUshBalance[user] = vdUsh.balanceOf(user);\\r\\n        lastClaimTotalSupply[user] = vdUsh.totalSupply();\\r\\n\\r\\n        if(lockedUsh > 0) {\\r\\n            //add to user's vdUSH if their lock hasn't expired\\r\\n            if(vdUsh.balanceOf(user) != 0) {\\r\\n                vdUsh.deposit_for(user, 0, 0, lockedUsh);\\r\\n            } else {\\r\\n                lockedUsh = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        //transfer claimable USH to user if nonzero\\r\\n        if(claimableUsh > 0) {\\r\\n            USH.safeTransfer(user, claimableUsh);\\r\\n        }\\r\\n\\r\\n        emit RewardsClaimed(user, claimableUsh, lockedUsh);\\r\\n    }\\r\\n\\r\\n    //view funcs\\r\\n    function getAllUsers() public view returns (address[] memory) {\\r\\n        return users;\\r\\n    }\\r\\n\\r\\n    function getVdUshTotalSupply() public view returns (uint) {\\r\\n        return vdUsh.totalSupply();\\r\\n    }\\r\\n\\r\\n    function getVdUshTotalSupplyInFarm() public view returns (uint) {\\r\\n        uint totalVdUsh;\\r\\n        for(uint i = 0; i < users.length;) {\\r\\n            address user = users[i];\\r\\n            if(!isBlocked[user]) {\\r\\n                totalVdUsh += vdUsh.balanceOf(user);\\r\\n            }\\r\\n            unchecked{ ++i; }\\r\\n        }\\r\\n        return totalVdUsh;\\r\\n    }\\r\\n\\r\\n    //owner funcs\\r\\n    function updateRewardRate(uint _ushPerSec) external onlyOwner {\\r\\n        ushPerSec = _ushPerSec;\\r\\n        emit RewardRateUpdated(_ushPerSec);\\r\\n    }\\r\\n\\r\\n    function setLockPercentage(uint _vdUshPercentage) external onlyOwner {\\r\\n        require(_vdUshPercentage <= 100e18, \\\"Percentage too high\\\");\\r\\n        vdUshPercentage = _vdUshPercentage;\\r\\n        emit LockPercentageUpdated(_vdUshPercentage);\\r\\n    }\\r\\n\\r\\n    function updateBlockList(address _user, bool _isBlocked) external onlyOwner {\\r\\n        isBlocked[_user] = _isBlocked;\\r\\n        emit BlockListUpdated(_user, _isBlocked);\\r\\n    }\\r\\n\\r\\n    //emergency funcs\\r\\n    function recoverUSH(uint amount, address dst) external onlyOwner {\\r\\n        USH.safeTransfer(dst, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/CommunalFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.6.11;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// ====================================================================\\r\\n// |     ______                   _______                             |\\r\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\r\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\r\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\r\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\r\\n// |                                                                  |\\r\\n// ====================================================================\\r\\n// =========================== CommunalFarm ===========================\\r\\n// ====================================================================\\r\\n// Multiple tokens with different reward rates can be emitted\\r\\n// Multiple teams can set the reward rates for their token(s)\\r\\n// Apes together strong\\r\\n\\r\\n// Frax Finance: https://github.com/FraxFinance\\r\\n\\r\\n// Primary Author(s)\\r\\n// Travis Moore: https://github.com/FortisFortuna\\r\\n\\r\\n// Reviewer(s) / Contributor(s)\\r\\n// Jason Huan: https://github.com/jasonhuan \\r\\n// Sam Kazemian: https://github.com/samkazemian\\r\\n// Saddle Team: https://github.com/saddle-finance\\r\\n// Fei Team: https://github.com/fei-protocol\\r\\n// Alchemix Team: https://github.com/alchemix-finance\\r\\n// Liquity Team: https://github.com/liquity\\r\\n\\r\\n// Originally inspired by Synthetix.io, but heavily modified by the Frax team\\r\\n// https://raw.githubusercontent.com/Synthetixio/synthetix/develop/contracts/StakingRewards.sol\\r\\n\\r\\nimport \\\"communal/Math.sol\\\";\\r\\nimport \\\"communal/SafeMath.sol\\\";\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport 'communal/TransferHelper.sol';\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\n\\r\\n// Inheritance\\r\\nimport \\\"communal/Owned.sol\\\";\\r\\n\\r\\ncontract CommunalFarm is Owned, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    // Instances\\r\\n    IERC20 public stakingToken;\\r\\n    \\r\\n    // Constant for various precisions\\r\\n    uint256 private constant MULTIPLIER_PRECISION = 1e18;\\r\\n\\r\\n    // Time tracking\\r\\n    uint256 public periodFinish;\\r\\n    uint256 public lastUpdateTime;\\r\\n\\r\\n    // Lock time and multiplier settings\\r\\n    uint256 public lock_max_multiplier = uint256(3e18); // E18. 1x = e18\\r\\n    uint256 public lock_time_for_max_multiplier = 1 * 30 * 86400; // 30 days\\r\\n    uint256 public lock_time_min = 86400; // 1 * 86400  (1 day)\\r\\n\\r\\n    // Reward addresses, rates, and managers\\r\\n    mapping(address => address) public rewardManagers; // token addr -> manager addr\\r\\n    address[] public rewardTokens;\\r\\n    uint256[] public rewardRates;\\r\\n    string[] public rewardSymbols;\\r\\n    mapping(address => uint256) public rewardTokenAddrToIdx; // token addr -> token index\\r\\n    \\r\\n    // Reward period\\r\\n    uint256 public rewardsDuration = 30 * 86400; // 30 * 86400  (30 days)\\r\\n\\r\\n    // Reward tracking\\r\\n    uint256[] private rewardsPerTokenStored;\\r\\n    mapping(address => mapping(uint256 => uint256)) private userRewardsPerTokenPaid; // staker addr -> token id -> paid amount\\r\\n    mapping(address => mapping(uint256 => uint256)) private rewards; // staker addr -> token id -> reward amount\\r\\n    mapping(address => uint256) private lastRewardClaimTime; // staker addr -> timestamp\\r\\n\\r\\n    // Balance tracking\\r\\n    uint256 private _total_liquidity_locked;\\r\\n    uint256 private _total_combined_weight;\\r\\n    mapping(address => uint256) private _locked_liquidity;\\r\\n    mapping(address => uint256) private _combined_weights;\\r\\n\\r\\n    // Stake tracking\\r\\n    mapping(address => LockedStake[]) private lockedStakes;\\r\\n\\r\\n    // Greylisting of bad addresses\\r\\n    mapping(address => bool) public greylist; //how long until this one is offensive too?\\r\\n\\r\\n    // Administrative booleans\\r\\n    bool public stakesUnlocked; // Release locked stakes in case of emergency\\r\\n    bool public withdrawalsPaused; // For emergencies\\r\\n    bool public rewardsCollectionPaused; // For emergencies\\r\\n    bool public stakingPaused; // For emergencies\\r\\n\\r\\n    /* ========== STRUCTS ========== */\\r\\n    \\r\\n    struct LockedStake {\\r\\n        bytes32 kek_id;\\r\\n        uint256 start_timestamp;\\r\\n        uint256 liquidity;\\r\\n        uint256 ending_timestamp;\\r\\n        uint256 lock_multiplier; // 6 decimals of precision. 1x = 1000000\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier onlyByOwner() {\\r\\n        require(msg.sender == owner, \\\"Not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTknMgrs(address reward_token_address) {\\r\\n        require(msg.sender == owner || isTokenManagerFor(msg.sender, reward_token_address), \\\"Not owner or tkn mgr\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notStakingPaused() {\\r\\n        require(stakingPaused == false, \\\"Staking paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateRewardAndBalance(address account, bool sync_too) {\\r\\n        _updateRewardAndBalance(account, sync_too);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    constructor (\\r\\n        address _owner,\\r\\n        address _stakingToken,\\r\\n        string[] memory _rewardSymbols,\\r\\n        address[] memory _rewardTokens,\\r\\n        address[] memory _rewardManagers,\\r\\n        uint256[] memory _rewardRates\\r\\n    ) Owned(_owner){\\r\\n        stakingToken = IERC20(_stakingToken);\\r\\n\\r\\n        rewardTokens = _rewardTokens;\\r\\n        rewardRates = _rewardRates;\\r\\n        rewardSymbols = _rewardSymbols;\\r\\n\\r\\n        for (uint256 i = 0; i < _rewardTokens.length; i++){ \\r\\n            // For fast token address -> token ID lookups later\\r\\n            rewardTokenAddrToIdx[_rewardTokens[i]] = i;\\r\\n\\r\\n            // Initialize the stored rewards\\r\\n            rewardsPerTokenStored.push(0);\\r\\n\\r\\n            // Initialize the reward managers\\r\\n            rewardManagers[_rewardTokens[i]] = _rewardManagers[i];\\r\\n        }\\r\\n\\r\\n        // Other booleans\\r\\n        stakesUnlocked = false;\\r\\n\\r\\n        // Initialization\\r\\n        lastUpdateTime = block.timestamp;\\r\\n        periodFinish = block.timestamp.add(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    // Total locked liquidity tokens\\r\\n    function totalLiquidityLocked() external view returns (uint256) {\\r\\n        return _total_liquidity_locked;\\r\\n    }\\r\\n\\r\\n    // Locked liquidity for a given account\\r\\n    function lockedLiquidityOf(address account) external view returns (uint256) {\\r\\n        return _locked_liquidity[account];\\r\\n    }\\r\\n\\r\\n    // Total 'balance' used for calculating the percent of the pool the account owns\\r\\n    // Takes into account the locked stake time multiplier\\r\\n    function totalCombinedWeight() external view returns (uint256) {\\r\\n        return _total_combined_weight;\\r\\n    }\\r\\n\\r\\n    // Combined weight for a specific account\\r\\n    function combinedWeightOf(address account) external view returns (uint256) {\\r\\n        return _combined_weights[account];\\r\\n    }\\r\\n\\r\\n    // Calculated the combined weight for an account\\r\\n    function calcCurCombinedWeight(address account) public view\\r\\n        returns (\\r\\n            uint256 old_combined_weight,\\r\\n            uint256 new_combined_weight\\r\\n        )\\r\\n    {\\r\\n        // Get the old combined weight\\r\\n        old_combined_weight = _combined_weights[account];\\r\\n\\r\\n        // Loop through the locked stakes, first by getting the liquidity * lock_multiplier portion\\r\\n        new_combined_weight = 0;\\r\\n        for (uint256 i = 0; i < lockedStakes[account].length; i++) {\\r\\n            LockedStake memory thisStake = lockedStakes[account][i];\\r\\n            uint256 lock_multiplier = thisStake.lock_multiplier;\\r\\n\\r\\n            // If the lock is expired\\r\\n            if (thisStake.ending_timestamp <= block.timestamp) {\\r\\n                // If the lock expired in the time since the last claim, the weight needs to be proportionately averaged this time\\r\\n                if (lastRewardClaimTime[account] < thisStake.ending_timestamp){\\r\\n                    uint256 time_before_expiry = (thisStake.ending_timestamp).sub(lastRewardClaimTime[account]);\\r\\n                    uint256 time_after_expiry = (block.timestamp).sub(thisStake.ending_timestamp);\\r\\n\\r\\n                    // Get the weighted-average lock_multiplier\\r\\n                    uint256 numerator = ((lock_multiplier).mul(time_before_expiry)).add(((MULTIPLIER_PRECISION).mul(time_after_expiry)));\\r\\n                    lock_multiplier = numerator.div(time_before_expiry.add(time_after_expiry));\\r\\n                }\\r\\n                // Otherwise, it needs to just be 1x\\r\\n                else {\\r\\n                    lock_multiplier = MULTIPLIER_PRECISION;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            uint256 liquidity = thisStake.liquidity;\\r\\n            uint256 combined_boosted_amount = liquidity.mul(lock_multiplier).div(MULTIPLIER_PRECISION);\\r\\n            new_combined_weight = new_combined_weight.add(combined_boosted_amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // All the locked stakes for a given account\\r\\n    function lockedStakesOf(address account) external view returns (LockedStake[] memory) {\\r\\n        return lockedStakes[account];\\r\\n    }\\r\\n\\r\\n    // All the locked stakes for a given account\\r\\n    function getRewardSymbols() external view returns (string[] memory) {\\r\\n        return rewardSymbols;\\r\\n    }\\r\\n\\r\\n    // All the reward tokens\\r\\n    function getAllRewardTokens() external view returns (address[] memory) {\\r\\n        return rewardTokens;\\r\\n    }\\r\\n\\r\\n    // All the reward rates\\r\\n    function getAllRewardRates() external view returns (uint256[] memory) {\\r\\n        return rewardRates;\\r\\n    }\\r\\n    \\r\\n    // Multiplier amount, given the length of the lock\\r\\n    function lockMultiplier(uint256 secs) public view returns (uint256) {\\r\\n        uint256 lock_multiplier =\\r\\n            uint256(MULTIPLIER_PRECISION).add(\\r\\n                secs\\r\\n                    .mul(lock_max_multiplier.sub(MULTIPLIER_PRECISION))\\r\\n                    .div(lock_time_for_max_multiplier)\\r\\n            );\\r\\n        if (lock_multiplier > lock_max_multiplier) lock_multiplier = lock_max_multiplier;\\r\\n        return lock_multiplier;\\r\\n    }\\r\\n\\r\\n    // Last time the reward was applicable\\r\\n    function lastTimeRewardApplicable() internal view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    // Amount of reward tokens per LP token\\r\\n    function rewardsPerToken() public view returns (uint256[] memory newRewardsPerTokenStored) {\\r\\n        if (_total_liquidity_locked == 0 || _total_combined_weight == 0) {\\r\\n            return rewardsPerTokenStored;\\r\\n        }\\r\\n        else {\\r\\n            newRewardsPerTokenStored = new uint256[](rewardTokens.length);\\r\\n            for (uint256 i = 0; i < rewardsPerTokenStored.length; i++){ \\r\\n                newRewardsPerTokenStored[i] = rewardsPerTokenStored[i].add(\\r\\n                    lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRates[i]).mul(1e18).div(_total_combined_weight)\\r\\n                );\\r\\n            }\\r\\n            return newRewardsPerTokenStored;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Amount of reward tokens an account has earned / accrued\\r\\n    // Note: In the edge-case of one of the account's stake expiring since the last claim, this will\\r\\n    // return a slightly inflated number\\r\\n    function earned(address account) public view returns (uint256[] memory new_earned) {\\r\\n        uint256[] memory reward_arr = rewardsPerToken();\\r\\n        new_earned = new uint256[](rewardTokens.length);\\r\\n\\r\\n        if (_combined_weights[account] == 0){\\r\\n            for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n                new_earned[i] = 0;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n                new_earned[i] = (_combined_weights[account])\\r\\n                    .mul(reward_arr[i].sub(userRewardsPerTokenPaid[account][i]))\\r\\n                    .div(1e18)\\r\\n                    .add(rewards[account][i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Total reward tokens emitted in the given period\\r\\n    function getRewardForDuration() external view returns (uint256[] memory rewards_per_duration_arr) {\\r\\n        rewards_per_duration_arr = new uint256[](rewardRates.length);\\r\\n\\r\\n        for (uint256 i = 0; i < rewardRates.length; i++){ \\r\\n            rewards_per_duration_arr[i] = rewardRates[i].mul(rewardsDuration);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // See if the caller_addr is a manager for the reward token \\r\\n    function isTokenManagerFor(address caller_addr, address reward_token_addr) public view returns (bool){\\r\\n        if (caller_addr == owner) return true; // Contract owner\\r\\n        else if (rewardManagers[reward_token_addr] == caller_addr) return true; // Reward manager\\r\\n        return false; \\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    function _updateRewardAndBalance(address account, bool sync_too) internal {\\r\\n        // Need to retro-adjust some things if the period hasn't been renewed, then start a new one\\r\\n        if (sync_too){\\r\\n            sync();\\r\\n        }\\r\\n        \\r\\n        if (account != address(0)) {\\r\\n            // To keep the math correct, the user's combined weight must be recomputed\\r\\n            (   \\r\\n                uint256 old_combined_weight,\\r\\n                uint256 new_combined_weight\\r\\n            ) = calcCurCombinedWeight(account);\\r\\n\\r\\n            // Calculate the earnings first\\r\\n            _syncEarned(account);\\r\\n\\r\\n            // Update the user's and the global combined weights\\r\\n            if (new_combined_weight >= old_combined_weight) {\\r\\n                uint256 weight_diff = new_combined_weight.sub(old_combined_weight);\\r\\n                _total_combined_weight = _total_combined_weight.add(weight_diff);\\r\\n                _combined_weights[account] = old_combined_weight.add(weight_diff);\\r\\n            } else {\\r\\n                uint256 weight_diff = old_combined_weight.sub(new_combined_weight);\\r\\n                _total_combined_weight = _total_combined_weight.sub(weight_diff);\\r\\n                _combined_weights[account] = old_combined_weight.sub(weight_diff);\\r\\n            }\\r\\n\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _syncEarned(address account) internal {\\r\\n        if (account != address(0)) {\\r\\n            // Calculate the earnings\\r\\n            uint256[] memory earned_arr = earned(account);\\r\\n\\r\\n            // Update the rewards array\\r\\n            for (uint256 i = 0; i < earned_arr.length; i++){ \\r\\n                rewards[account][i] = earned_arr[i];\\r\\n            }\\r\\n\\r\\n            // Update the rewards paid array\\r\\n            for (uint256 i = 0; i < earned_arr.length; i++){ \\r\\n                userRewardsPerTokenPaid[account][i] = rewardsPerTokenStored[i];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Two different stake functions are needed because of delegateCall and msg.sender issues\\r\\n    function stakeLocked(uint256 liquidity, uint256 secs) nonReentrant public {\\r\\n        _stakeLocked(msg.sender, msg.sender, liquidity, secs, block.timestamp);\\r\\n    }\\r\\n\\r\\n    // If this were not internal, and source_address had an infinite approve, this could be exploitable\\r\\n    // (pull funds from source_address and stake for an arbitrary staker_address)\\r\\n    function _stakeLocked(\\r\\n        address staker_address, \\r\\n        address source_address, \\r\\n        uint256 liquidity, \\r\\n        uint256 secs,\\r\\n        uint256 start_timestamp\\r\\n    ) internal updateRewardAndBalance(staker_address, true) {\\r\\n        require(!stakingPaused, \\\"Staking paused\\\");\\r\\n        require(liquidity > 0, \\\"Must stake more than zero\\\");\\r\\n        require(greylist[staker_address] == false, \\\"Address has been greylisted\\\");\\r\\n        require(secs >= lock_time_min, \\\"Minimum stake time not met\\\");\\r\\n        require(secs <= lock_time_for_max_multiplier,\\\"Trying to lock for too long\\\");\\r\\n\\r\\n        uint256 lock_multiplier = lockMultiplier(secs);\\r\\n        bytes32 kek_id = keccak256(abi.encodePacked(staker_address, start_timestamp, liquidity, _locked_liquidity[staker_address]));\\r\\n        lockedStakes[staker_address].push(LockedStake(\\r\\n            kek_id,\\r\\n            start_timestamp,\\r\\n            liquidity,\\r\\n            start_timestamp.add(secs),\\r\\n            lock_multiplier\\r\\n        ));\\r\\n\\r\\n        // Pull the tokens from the source_address\\r\\n        //TODO: do we even need this if we're dealing with Sushi LP not saddle?\\r\\n        TransferHelper.safeTransferFrom(address(stakingToken), source_address, address(this), liquidity);\\r\\n\\r\\n        // Update liquidities\\r\\n        _total_liquidity_locked = _total_liquidity_locked.add(liquidity);\\r\\n        _locked_liquidity[staker_address] = _locked_liquidity[staker_address].add(liquidity);\\r\\n\\r\\n        // Need to call to update the combined weights\\r\\n        _updateRewardAndBalance(staker_address, false);\\r\\n\\r\\n        // Needed for edge case if the staker only claims once, and after the lock expired\\r\\n        if (lastRewardClaimTime[staker_address] == 0) lastRewardClaimTime[staker_address] = block.timestamp;\\r\\n\\r\\n        emit StakeLocked(staker_address, liquidity, secs, kek_id, source_address);\\r\\n    }\\r\\n\\r\\n    // Two different withdrawLocked functions are needed because of delegateCall and msg.sender issues\\r\\n    function withdrawLocked(bytes32 kek_id) nonReentrant public {\\r\\n        require(withdrawalsPaused == false, \\\"Withdrawals paused\\\");\\r\\n        _withdrawLocked(msg.sender, msg.sender, kek_id);\\r\\n    }\\r\\n\\r\\n    // No withdrawer == msg.sender check needed since this is only internally callable and the checks are done in the wrapper\\r\\n    // functions like withdraw()\\r\\n    function _withdrawLocked(address staker_address, address destination_address, bytes32 kek_id) internal  {\\r\\n        // Collect rewards first and then update the balances\\r\\n        _getReward(staker_address, destination_address);\\r\\n\\r\\n        LockedStake memory thisStake;\\r\\n        thisStake.liquidity = 0;\\r\\n        uint theArrayIndex;\\r\\n        for (uint256 i = 0; i < lockedStakes[staker_address].length; i++){ \\r\\n            if (kek_id == lockedStakes[staker_address][i].kek_id){\\r\\n                thisStake = lockedStakes[staker_address][i];\\r\\n                theArrayIndex = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        require(thisStake.kek_id == kek_id, \\\"Stake not found\\\");\\r\\n        require(block.timestamp >= thisStake.ending_timestamp || stakesUnlocked == true, \\\"Stake is still locked!\\\");\\r\\n\\r\\n        uint256 liquidity = thisStake.liquidity;\\r\\n\\r\\n        if (liquidity > 0) {\\r\\n            // Update liquidities\\r\\n            _total_liquidity_locked = _total_liquidity_locked.sub(liquidity);\\r\\n            _locked_liquidity[staker_address] = _locked_liquidity[staker_address].sub(liquidity);\\r\\n\\r\\n            // Remove the stake from the array\\r\\n            delete lockedStakes[staker_address][theArrayIndex];\\r\\n\\r\\n            // Need to call to update the combined weights\\r\\n            _updateRewardAndBalance(staker_address, false);\\r\\n\\r\\n            // Give the tokens to the destination_address\\r\\n            // Should throw if insufficient balance\\r\\n            stakingToken.transfer(destination_address, liquidity);\\r\\n\\r\\n            emit WithdrawLocked(staker_address, liquidity, kek_id, destination_address);\\r\\n        }\\r\\n\\r\\n    }\\r\\n    \\r\\n    // Two different getReward functions are needed because of delegateCall and msg.sender issues\\r\\n    function getReward() external nonReentrant returns (uint256[] memory) {\\r\\n        require(rewardsCollectionPaused == false,\\\"Rewards collection paused\\\");\\r\\n        return _getReward(msg.sender, msg.sender);\\r\\n    }\\r\\n\\r\\n    // No withdrawer == msg.sender check needed since this is only internally callable\\r\\n    function _getReward(address rewardee, address destination_address) internal updateRewardAndBalance(rewardee, true) returns (uint256[] memory rewards_before) {\\r\\n        // Update the rewards array and distribute rewards\\r\\n        rewards_before = new uint256[](rewardTokens.length);\\r\\n\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n            rewards_before[i] = rewards[rewardee][i];\\r\\n            rewards[rewardee][i] = 0;\\r\\n            //use SafeERC20.transfer\\r\\n            IERC20(rewardTokens[i]).transfer(destination_address, rewards_before[i]);\\r\\n            emit RewardPaid(rewardee, rewards_before[i], rewardTokens[i], destination_address);\\r\\n        }\\r\\n\\r\\n        lastRewardClaimTime[rewardee] = block.timestamp;\\r\\n    }\\r\\n\\r\\n    // If the period expired, renew it\\r\\n    function retroCatchUp() internal {\\r\\n        // Failsafe check\\r\\n        require(block.timestamp > periodFinish, \\\"Period has not expired yet!\\\");\\r\\n\\r\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\r\\n        // This keeps the reward rate in the right range, preventing overflows due to\\r\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\r\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\r\\n        uint256 num_periods_elapsed = uint256(block.timestamp.sub(periodFinish)) / rewardsDuration; // Floor division to the nearest period\\r\\n        \\r\\n        // Make sure there are enough tokens to renew the reward period\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n            require(rewardRates[i].mul(rewardsDuration).mul(num_periods_elapsed + 1) <= IERC20(rewardTokens[i]).balanceOf(address(this)), string(abi.encodePacked(\\\"Not enough reward tokens available: \\\", rewardTokens[i])) );\\r\\n        }\\r\\n        \\r\\n        // uint256 old_lastUpdateTime = lastUpdateTime;\\r\\n        // uint256 new_lastUpdateTime = block.timestamp;\\r\\n\\r\\n        // lastUpdateTime = periodFinish;\\r\\n        periodFinish = periodFinish.add((num_periods_elapsed.add(1)).mul(rewardsDuration));\\r\\n\\r\\n        _updateStoredRewardsAndTime();\\r\\n\\r\\n        emit RewardsPeriodRenewed(address(stakingToken));\\r\\n    }\\r\\n\\r\\n    function _updateStoredRewardsAndTime() internal {\\r\\n        // Get the rewards\\r\\n        uint256[] memory rewards_per_token = rewardsPerToken();\\r\\n\\r\\n        // Update the rewardsPerTokenStored\\r\\n        for (uint256 i = 0; i < rewardsPerTokenStored.length; i++){ \\r\\n            rewardsPerTokenStored[i] = rewards_per_token[i];\\r\\n        }\\r\\n\\r\\n        // Update the last stored time\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n    }\\r\\n\\r\\n    function sync() public {\\r\\n        if (block.timestamp > periodFinish) {\\r\\n            retroCatchUp();\\r\\n        }\\r\\n        else {\\r\\n            _updateStoredRewardsAndTime();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    // Added to support recovering LP Rewards and other mistaken tokens from other systems to be distributed to holders\\r\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyTknMgrs(tokenAddress) {\\r\\n        // Cannot rug the staking / LP tokens\\r\\n        require(tokenAddress != address(stakingToken), \\\"Cannot rug staking / LP tokens\\\");\\r\\n\\r\\n        // Check if the desired token is a reward token\\r\\n        bool isRewardToken = false;\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n            if (rewardTokens[i] == tokenAddress) {\\r\\n                isRewardToken = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Only the reward managers can take back their reward tokens\\r\\n        if (isRewardToken && rewardManagers[tokenAddress] == msg.sender){\\r\\n            IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\\r\\n            emit Recovered(msg.sender, tokenAddress, tokenAmount);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Other tokens, like airdrops or accidental deposits, can be withdrawn by the owner\\r\\n        else if (!isRewardToken && (msg.sender == owner)){\\r\\n            IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\\r\\n            emit Recovered(msg.sender, tokenAddress, tokenAmount);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // If none of the above conditions are true\\r\\n        else {\\r\\n            revert(\\\"No valid tokens to recover\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyByOwner {\\r\\n        require(_rewardsDuration >= 86400, \\\"Rewards duration too short\\\");\\r\\n        require(\\r\\n            periodFinish == 0 || block.timestamp > periodFinish,\\r\\n            \\\"Reward period incomplete\\\"\\r\\n        );\\r\\n        rewardsDuration = _rewardsDuration;\\r\\n        emit RewardsDurationUpdated(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    function setMultipliers(uint256 _lock_max_multiplier) external onlyByOwner {\\r\\n        require(_lock_max_multiplier >= uint256(1e18), \\\"Multiplier must be greater than or equal to 1e18\\\");\\r\\n        lock_max_multiplier = _lock_max_multiplier;\\r\\n        emit LockedStakeMaxMultiplierUpdated(lock_max_multiplier);\\r\\n    }\\r\\n\\r\\n    function setLockedStakeTimeForMinAndMaxMultiplier(uint256 _lock_time_for_max_multiplier, uint256 _lock_time_min) external onlyByOwner {\\r\\n        require(_lock_time_for_max_multiplier >= 1, \\\"Mul max time must be >= 1\\\");\\r\\n        require(_lock_time_min >= 1, \\\"Mul min time must be >= 1\\\");\\r\\n\\r\\n        lock_time_for_max_multiplier = _lock_time_for_max_multiplier;\\r\\n        lock_time_min = _lock_time_min;\\r\\n\\r\\n        emit LockedStakeTimeForMaxMultiplier(lock_time_for_max_multiplier);\\r\\n        emit LockedStakeMinTime(_lock_time_min);\\r\\n    }\\r\\n\\r\\n    function greylistAddress(address _address) external onlyByOwner {\\r\\n        greylist[_address] = !(greylist[_address]);\\r\\n    }\\r\\n\\r\\n    function unlockStakes() external onlyByOwner {\\r\\n        stakesUnlocked = !stakesUnlocked;\\r\\n    }\\r\\n\\r\\n    function toggleStaking() external onlyByOwner {\\r\\n        stakingPaused = !stakingPaused;\\r\\n    }\\r\\n\\r\\n    function toggleWithdrawals() external onlyByOwner {\\r\\n        withdrawalsPaused = !withdrawalsPaused;\\r\\n    }\\r\\n\\r\\n    function toggleRewardsCollection() external onlyByOwner {\\r\\n        rewardsCollectionPaused = !rewardsCollectionPaused;\\r\\n    }\\r\\n\\r\\n    // The owner or the reward token managers can set reward rates \\r\\n    function setRewardRate(address reward_token_address, uint256 new_rate, bool sync_too) external onlyTknMgrs(reward_token_address) {\\r\\n        rewardRates[rewardTokenAddrToIdx[reward_token_address]] = new_rate;\\r\\n        \\r\\n        if (sync_too){\\r\\n            sync();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // The owner or the reward token managers can change managers\\r\\n    function changeTokenManager(address reward_token_address, address new_manager_address) external onlyTknMgrs(reward_token_address) {\\r\\n        rewardManagers[reward_token_address] = new_manager_address;\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event StakeLocked(address indexed user, uint256 amount, uint256 secs, bytes32 kek_id, address source_address);\\r\\n    event WithdrawLocked(address indexed user, uint256 amount, bytes32 kek_id, address destination_address);\\r\\n    event RewardPaid(address indexed user, uint256 reward, address token_address, address destination_address);\\r\\n    event RewardsDurationUpdated(uint256 newDuration);\\r\\n    event Recovered(address destination_address, address token, uint256 amount);\\r\\n    event RewardsPeriodRenewed(address token);\\r\\n    event LockedStakeMaxMultiplierUpdated(uint256 multiplier);\\r\\n    event LockedStakeTimeForMaxMultiplier(uint256 secs);\\r\\n    event LockedStakeMinTime(uint256 secs);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Darknet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\n//An oracle that provides prices for different LSDs\\r\\n//NOTE: This is the rate quoted by the LSDs contracts, no pricing of market impact and liquidity risk is calculated\\r\\n\\r\\ninterface IsfrxETH {\\r\\n    function pricePerShare() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IrETH {\\r\\n    function getExchangeRate() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IWStETH {\\r\\n    function stEthPerToken() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IcbETH {\\r\\n    function exchangeRate() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IankrETH {\\r\\n    function sharesToBonds(uint256) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IswETH {\\r\\n    function swETHToETHRate() external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract Darknet {\\r\\n    address public constant sfrxETHAddress = 0xac3E018457B222d93114458476f3E3416Abbe38F;\\r\\n    address public constant rETHAddress = 0xae78736Cd615f374D3085123A210448E74Fc6393;\\r\\n    address public constant wstETHAddress = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\r\\n    address public constant cbETHAddress = 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704;\\r\\n    address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    address public constant ankrETHAddress = 0xE95A203B1a91a908F9B9CE46459d101078c2c3cb;\\r\\n    address public constant swETHAddress = 0xf951E335afb289353dc249e82926178EaC7DEd78;\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    function checkPrice(address lsd) public view returns (uint256) {\\r\\n        if (lsd == wethAddress) return 1e18;\\r\\n        if (lsd == wstETHAddress) return IWStETH(wstETHAddress).stEthPerToken();\\r\\n        if (lsd == sfrxETHAddress) return IsfrxETH(sfrxETHAddress).pricePerShare();\\r\\n        if (lsd == rETHAddress) return IrETH(rETHAddress).getExchangeRate();\\r\\n        if (lsd == cbETHAddress) return IcbETH(cbETHAddress).exchangeRate();\\r\\n        if (lsd == ankrETHAddress) return IankrETH(ankrETHAddress).sharesToBonds(1e18);\\r\\n        if (lsd == swETHAddress) return IswETH(swETHAddress).swETHToETHRate();\\r\\n        else revert();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Darknet2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.18;\\r\\n\\r\\n\\r\\n\\r\\ncontract Darknet2 {\\r\\n    mapping(address => bytes4) public router;\\r\\n    mapping(address => bool) private hasArgs;\\r\\n    address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n\\r\\n    /* ============ Constructor ============ */\\r\\n    constructor(\\r\\n        address[] memory _lsds,\\r\\n        bytes4[] memory _links,\\r\\n        bool[] memory _hasArgs\\r\\n    ) {\\r\\n        require(_lsds.length == _links.length && _lsds.length == _hasArgs.length, \\\"Array length mismatch\\\");\\r\\n        for (uint256 i = 0; i < _lsds.length; i++) {\\r\\n            router[_lsds[i]] = _links[i];\\r\\n            if (_hasArgs[i]) {\\r\\n                hasArgs[_lsds[i]] = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function checkPrice(address lsd) public view returns (uint256) {\\r\\n        if(lsd == wethAddress) {\\r\\n            return 1e18;\\r\\n        }\\r\\n\\r\\n        bytes4 fn_sig = router[lsd];\\r\\n        bool success;\\r\\n        bytes memory response;\\r\\n        if (hasArgs[lsd]) {\\r\\n            (success, response) = lsd.staticcall(abi.encodePacked(fn_sig, uint256(1e18)));\\r\\n        } else {\\r\\n            (success, response) = lsd.staticcall(abi.encodePacked(fn_sig));\\r\\n        }\\r\\n        require(success, \\\"Static call failed\\\");\\r\\n        uint256 price = abi.decode(response, (uint256));\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"src/ERC20/ERC20PermitPermissionedMint.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\r\\nimport \\\"communal/Owned.sol\\\";\\r\\n\\r\\n/// @title Parent contract for frxETH.sol\\r\\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \\r\\n    Also includes a list of authorized minters */\\r\\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\\r\\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\\r\\n    // Core\\r\\n    address public timelock_address;\\r\\n\\r\\n    // Minters\\r\\n    address[] public minters_array; // Allowed to mint\\r\\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    constructor(\\r\\n        address _creator_address,\\r\\n        address _timelock_address,\\r\\n        string memory _name,\\r\\n        string memory _symbol\\r\\n    ) \\r\\n    ERC20(_name, _symbol)\\r\\n    ERC20Permit(_name) \\r\\n    Owned(_creator_address)\\r\\n    {\\r\\n      timelock_address = _timelock_address;\\r\\n    }\\r\\n\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier onlyByOwnGov() {\\r\\n        require(msg.sender == timelock_address || msg.sender == owner, \\\"Not owner or timelock\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMinters() {\\r\\n       require(minters[msg.sender] == true, \\\"Only minters\\\");\\r\\n        _;\\r\\n    } \\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    // Used by minters when user redeems\\r\\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\\r\\n        super.burnFrom(b_address, b_amount);\\r\\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\\r\\n    }\\r\\n\\r\\n    // This function is what other minters will call to mint new tokens \\r\\n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\\r\\n        super._mint(m_address, m_amount);\\r\\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\\r\\n    }\\r\\n\\r\\n    // Adds whitelisted minters \\r\\n    function addMinter(address minter_address) public onlyByOwnGov {\\r\\n        require(minter_address != address(0), \\\"Zero address detected\\\");\\r\\n\\r\\n        require(minters[minter_address] == false, \\\"Address already exists\\\");\\r\\n        minters[minter_address] = true; \\r\\n        minters_array.push(minter_address);\\r\\n\\r\\n        emit MinterAdded(minter_address);\\r\\n    }\\r\\n\\r\\n    // Remove a minter \\r\\n    function removeMinter(address minter_address) public onlyByOwnGov {\\r\\n        require(minter_address != address(0), \\\"Zero address detected\\\");\\r\\n        require(minters[minter_address] == true, \\\"Address nonexistant\\\");\\r\\n        \\r\\n        // Delete from the mapping\\r\\n        delete minters[minter_address];\\r\\n\\r\\n        // 'Delete' from the array by setting the address to 0x0\\r\\n        for (uint i = 0; i < minters_array.length; i++){ \\r\\n            if (minters_array[i] == minter_address) {\\r\\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit MinterRemoved(minter_address);\\r\\n    }\\r\\n\\r\\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\\r\\n        require(_timelock_address != address(0), \\\"Zero address detected\\\"); \\r\\n        timelock_address = _timelock_address;\\r\\n        emit TimelockChanged(_timelock_address);\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n    \\r\\n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\\r\\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\\r\\n    event MinterAdded(address minter_address);\\r\\n    event MinterRemoved(address minter_address);\\r\\n    event TimelockChanged(address timelock_address);\\r\\n}\"\r\n    },\r\n    \"src/EthVdUshFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >0.8.10;\\r\\n\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"local/interfaces/IvdUSH.sol\\\";\\r\\nimport \\\"local/interfaces/IGovFarm.sol\\\";\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SignedSafeMath.sol\\\";\\r\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\r\\n\\r\\n// ================================================================\\r\\n// |\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\r\\n// |\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\r\\n// |\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\\r\\n// | \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\\r\\n// ================================================================\\r\\n// ======================= GovernorsFarm =+++======================\\r\\n// ================================================================\\r\\n// Allows vdUSH users to enter the matrix and receive USH rewards\\r\\n// Users can claim their rewards at any time\\r\\n// No staking needed, just enter the matrix and claim rewards\\r\\n// No user deposits held in this contract!\\r\\n//\\r\\n// Author: unshETH team (github.com/unsheth)\\r\\n// Heavily inspired by StakingRewards, MasterChef\\r\\n//\\r\\n\\r\\ncontract GovernorsFarm is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SignedSafeMath for int256;\\r\\n\\r\\n    IERC20 public immutable USH = IERC20(0xE60779CC1b2c1d0580611c526a8DF0E3f870EC48);\\r\\n    IvdUSH public immutable vdUsh = IvdUSH(0xd027Ef82dB658805C9Ba8053196cD6ED1Dd407E4);\\r\\n\\r\\n    uint public vdUshPercentage; //percentage of rewards to lock as vdUSH\\r\\n\\r\\n    //check if an address has entered the matrix\\r\\n    mapping(address => bool) public isInMatrix;\\r\\n    address[] public users; //array of users in the matrix\\r\\n\\r\\n    uint public ushPerSec;\\r\\n\\r\\n    mapping(address => uint) public lastClaimTimestamp;\\r\\n    mapping(address => uint) public lastClaimVdUshBalance;\\r\\n    mapping(address => uint) public lastClaimTotalSupply;\\r\\n    mapping(address => bool) public isBlocked; //if a user is blocked from claiming rewards\\r\\n\\r\\n    struct Point {\\r\\n        int128 bias;\\r\\n        int128 slope; // # -dweight / dt\\r\\n        uint ts;\\r\\n        uint blk; // block\\r\\n    }\\r\\n    uint internal constant WEEK = 1 weeks;\\r\\n\\r\\n    event MatrixEntered(address indexed _user);\\r\\n    event RewardsClaimed(address indexed _user, uint _ushClaimed, uint _vdUSHClaimed);\\r\\n    event RewardRateUpdated(uint _ushPerSec);\\r\\n    event LockPercentageUpdated(uint _vdUshLockPercentage);\\r\\n    event BlockListUpdated(address indexed _user, bool _isBlocked);\\r\\n\\r\\n    //Constructor\\r\\n    constructor(uint _ushPerSec, uint _vdUshPercentage, address _oldGovFarm) {\\r\\n        ushPerSec = _ushPerSec;\\r\\n        vdUshPercentage = _vdUshPercentage;\\r\\n        USH.approve(address(vdUsh), type(uint).max); //for locking on behalf of users\\r\\n\\r\\n        //Seed values from V1Farm for migration\\r\\n        IGovFarm oldGovFarm = IGovFarm(_oldGovFarm);\\r\\n        address[] memory v1Users = oldGovFarm.getAllUsers();\\r\\n        //Gas efficient method to migrate users in v1 farm with no require checks or events\\r\\n        for(uint i = 0; i < v1Users.length; ) {\\r\\n            address user = v1Users[i];\\r\\n            isInMatrix[user] = true;\\r\\n            users.push(user);\\r\\n            lastClaimTimestamp[user] = oldGovFarm.lastClaimTimestamp(user);\\r\\n        unchecked { ++i; }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows a user with non zero vdUSH balance to enter the matrix and start earning farm rewards.\\r\\n     * The user's address is registered in a mapping.\\r\\n     * The user's last claim timestamp is set to the current block timestamp (rewards start from the moment they enter).\\r\\n     * @param user The address of the user entering the matrix.\\r\\n     */\\r\\n    function enterMatrix(address user) external nonReentrant {\\r\\n        _enterMatrix(user);\\r\\n    }\\r\\n\\r\\n    function _enterMatrix(address user) internal {\\r\\n        require(!isInMatrix[user], \\\"Already in matrix\\\");\\r\\n        require(vdUsh.balanceOf(user) > 0, \\\"Cannot enter the matrix without vdUSH\\\");\\r\\n        isInMatrix[user] = true;\\r\\n        users.push(user);\\r\\n        lastClaimTimestamp[user] = block.timestamp;\\r\\n        emit MatrixEntered(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculate user's earned USH and vdUSH rewards since last claim.\\r\\n     * User earned rewards are proportional to their share of total vdUSH at the time of claim.\\r\\n     * @param user The address of the user entering the matrix.\\r\\n     */\\r\\n    function earned(address user) public view returns (uint, uint) {\\r\\n\\r\\n        require(isInMatrix[user], \\\"User not in matrix\\\");\\r\\n        //require(startTime!= 0 && block.timestamp > startTime, \\\"Farm not started\\\");\\r\\n        require(!isBlocked[user], \\\"User is blocked from claiming rewards\\\");\\r\\n\\r\\n        //calculate time from which to start accum rewards, max of (time user entered matrix, last claim time)\\r\\n        uint lastClaimTimeStamp = lastClaimTimestamp[user];\\r\\n\\r\\n        uint secsSinceLastClaim = block.timestamp - lastClaimTimeStamp;\\r\\n        uint lastEpoch = vdUsh.user_point_epoch(user);\\r\\n        uint lastEpochTimestamp = vdUsh.user_point_history__ts(user, lastEpoch);\\r\\n\\r\\n        uint userVdUsh;\\r\\n        uint totalVdUsh;\\r\\n\\r\\n        userVdUsh = lastClaimVdUshBalance[user];\\r\\n        totalVdUsh = lastClaimTotalSupply[user];\\r\\n\\r\\n        //sampling:\\r\\n        //fyi we start at i=1, bc i=0 is the lastClaim which is already stored\\r\\n        for(uint i = 1; i < 53;) {\\r\\n            uint timestamp = lastClaimTimeStamp + i * 1 weeks;\\r\\n            //if 1 wk after last claim is after current block timestamp, break\\r\\n            if(timestamp > block.timestamp) {\\r\\n                userVdUsh += vdUsh.balanceOf(user);\\r\\n                totalVdUsh += vdUsh.totalSupply();\\r\\n                break;\\r\\n            }\\r\\n            //round down to nearest week if needed\\r\\n            if(timestamp > lastEpochTimestamp) {\\r\\n                timestamp = lastEpochTimestamp;\\r\\n            }\\r\\n\\r\\n            userVdUsh += vdUsh.balanceOfAtT(user, timestamp);\\r\\n            //calculate totalSupplyAtT internally due to versioning issue in ve-contracts\\r\\n            totalVdUsh += _totalSupplyAtT(timestamp);\\r\\n\\r\\n            unchecked{ ++i; }\\r\\n        }\\r\\n\\r\\n        uint averageVdUshShare = userVdUsh * 1e18 / totalVdUsh;\\r\\n\\r\\n        //uint totalSupplyMultiplier = vdUsh.totalSupply() * 1e18 / getVdUshTotalSupplyInFarm();\\r\\n        uint totalSupplyMultiplier = 1e18; //for ETH, don't do full calculation to save gas.\\r\\n        uint totalWeight = averageVdUshShare * secsSinceLastClaim * totalSupplyMultiplier / 1e18;\\r\\n        uint ushEarned = totalWeight * ushPerSec / 1e18;\\r\\n\\r\\n        uint lockedUsh = ushEarned * vdUshPercentage / 100e18;\\r\\n        uint claimableUsh = ushEarned - lockedUsh;\\r\\n\\r\\n        return (claimableUsh, lockedUsh);\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Calculations to get correct total supply at historical point T\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function _get_point_history(uint _epoch) internal view returns (Point memory) {\\r\\n        (int128 bias, int128 slope, uint ts, uint blk) = vdUsh.point_history(_epoch);\\r\\n        return Point(bias, slope, ts, blk);\\r\\n    }\\r\\n\\r\\n    function _totalSupplyAtT(uint t) internal view returns (uint) {\\r\\n        uint _epoch = vdUsh.epoch();\\r\\n        Point memory last_point = _get_point_history(_epoch);\\r\\n        return _supply_at(last_point, t);\\r\\n    }\\r\\n\\r\\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\\r\\n        Point memory last_point = point;\\r\\n        uint t_i = (last_point.ts / WEEK) * WEEK;\\r\\n        for (uint i = 0; i < 255; ++i) {\\r\\n            t_i += WEEK;\\r\\n            int128 d_slope = 0;\\r\\n            if (t_i > t) {\\r\\n                t_i = t;\\r\\n            } else {\\r\\n                d_slope = vdUsh.slope_changes(t_i);\\r\\n            }\\r\\n            last_point.bias -= last_point.slope * int128(int(t_i) - int(last_point.ts));\\r\\n            if (t_i == t) {\\r\\n                break;\\r\\n            }\\r\\n            last_point.slope += d_slope;\\r\\n            last_point.ts = t_i;\\r\\n        }\\r\\n\\r\\n        if (last_point.bias < 0) {\\r\\n            last_point.bias = 0;\\r\\n        }\\r\\n        return uint(uint128(last_point.bias));\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Claim\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function passGoAndCollect(address user) external nonReentrant {\\r\\n        uint claimableUsh;\\r\\n        uint lockedUsh;\\r\\n\\r\\n        (claimableUsh, lockedUsh) = earned(user);\\r\\n\\r\\n        require(lockedUsh > 0 || claimableUsh > 0, \\\"Nothing to claim\\\");\\r\\n\\r\\n        lastClaimTimestamp[user] = block.timestamp;\\r\\n        lastClaimVdUshBalance[user] = vdUsh.balanceOf(user);\\r\\n        lastClaimTotalSupply[user] = vdUsh.totalSupply();\\r\\n\\r\\n        if(lockedUsh > 0) {\\r\\n            //add to user's vdUSH if their lock hasn't expired\\r\\n            if(vdUsh.balanceOf(user) != 0) {\\r\\n                vdUsh.deposit_for(user, 0, 0, lockedUsh);\\r\\n            } else {\\r\\n                lockedUsh = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        //transfer claimable USH to user if nonzero\\r\\n        if(claimableUsh > 0) {\\r\\n            USH.safeTransfer(user, claimableUsh);\\r\\n        }\\r\\n\\r\\n        emit RewardsClaimed(user, claimableUsh, lockedUsh);\\r\\n    }\\r\\n\\r\\n    //view funcs\\r\\n    function getAllUsers() public view returns (address[] memory) {\\r\\n        return users;\\r\\n    }\\r\\n\\r\\n    function getVdUshTotalSupply() public view returns (uint) {\\r\\n        return vdUsh.totalSupply();\\r\\n    }\\r\\n\\r\\n    function getVdUshTotalSupplyInFarm() public view returns (uint) {\\r\\n        uint totalVdUsh;\\r\\n        for(uint i = 0; i < users.length;) {\\r\\n            address user = users[i];\\r\\n            if(!isBlocked[user]) {\\r\\n                totalVdUsh += vdUsh.balanceOf(user);\\r\\n            }\\r\\n        unchecked{ ++i; }\\r\\n        }\\r\\n        return totalVdUsh;\\r\\n    }\\r\\n\\r\\n    //owner funcs\\r\\n    function updateRewardRate(uint _ushPerSec) external onlyOwner {\\r\\n        ushPerSec = _ushPerSec;\\r\\n        emit RewardRateUpdated(_ushPerSec);\\r\\n    }\\r\\n\\r\\n    function setLockPercentage(uint _vdUshPercentage) external onlyOwner {\\r\\n        require(_vdUshPercentage <= 100e18, \\\"Percentage too high\\\");\\r\\n        vdUshPercentage = _vdUshPercentage;\\r\\n        emit LockPercentageUpdated(_vdUshPercentage);\\r\\n    }\\r\\n\\r\\n    function updateBlockList(address _user, bool _isBlocked) external onlyOwner {\\r\\n        isBlocked[_user] = _isBlocked;\\r\\n        emit BlockListUpdated(_user, _isBlocked);\\r\\n    }\\r\\n\\r\\n    //emergency funcs\\r\\n    function recoverUSH(uint amount, address dst) external onlyOwner {\\r\\n        USH.safeTransfer(dst, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/EuclideanFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.8.13;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// \u252c \u252c\u250c\u2510\u250c\u250c\u2500\u2510\u252c \u252c\u2554\u2550\u2557\u2554\u2566\u2557\u2566 \u2566\\r\\n// \u2502 \u2502\u2502\u2502\u2502\u2514\u2500\u2510\u251c\u2500\u2524\u2551\u2563  \u2551 \u2560\u2550\u2563\\r\\n// \u2514\u2500\u2518\u2518\u2514\u2518\u2514\u2500\u2518\u2534 \u2534\u255a\u2550\u255d \u2569 \u2569 \u2569\\r\\n// =======================\\r\\n// EuclideanFarm.sol\\r\\n/// @title Modified StakingRewards from Frax/Synthetix with a \\\"coordination multiplier\\\"\\r\\n/// @author @EIP-A1tair\\r\\n/// @notice Allows users to stake unshETH and earn USH, with a multiplier \\r\\n///         based on how well the pool confirms to a target ratio of tokens\\r\\n/// @dev    Uses Euclidean distance to calculate the \\\"coordination ratio\\\"\\r\\n\\r\\nimport \\\"communal/Math.sol\\\";\\r\\nimport \\\"communal/SafeMath.sol\\\";\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport 'communal/TransferHelper.sol';\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\n\\r\\n// Inheritance\\r\\nimport \\\"communal/Owned.sol\\\";\\r\\nimport \\\"forge-std/console.sol\\\";\\r\\n\\r\\n\\r\\nimport { UD60x18, ud, fromUD60x18, unwrap, mulDiv18, add, sub, mul, div, mulDiv, inv, powu, exp } from \\\"@prb/math/UD60x18.sol\\\";\\r\\n\\r\\n// just do everything in signed, the casting ugliness isn't worth the aids\\r\\n// import { UD60x18, ud, fromUD60x18, mul, div, sqrt, inv, powu } from \\\"@prb/math/UD60x18.sol\\\";\\r\\n\\r\\ninterface ILSDRegistry {\\r\\n    function vaultAddress() external view returns (address);\\r\\n    //ratios should be in the form of [0.25e18, 0.25e18, 0.25e18, 0.25e18] for 4 LSDs\\r\\n    function targetRatio() external view returns (uint256[] calldata);\\r\\n    function lsdAddresses() external view returns (address[] calldata);\\r\\n    function shanghaiTime() external view returns (uint256);\\r\\n    function nonce() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface ILSDVault {\\r\\n    function balanceInUnderlying() external view returns (uint256);\\r\\n    function stakedETHperunshETH() external view returns (uint256);  \\r\\n}\\r\\ninterface IDarknet {\\r\\n    function checkPrice(address lsd) external view returns(uint256);\\r\\n}\\r\\n\\r\\ncontract EuclideanFarm is Owned, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    // Instances\\r\\n    IERC20 public stakingToken;\\r\\n    \\r\\n    // Constant for various precisions\\r\\n    uint256 private constant MULTIPLIER_PRECISION = 1e18;\\r\\n\\r\\n    // Time tracking\\r\\n    uint256 public periodFinish;\\r\\n    uint256 public lastUpdateTime;\\r\\n\\r\\n    // Lock time and multiplier settings\\r\\n    uint256 public lock_max_multiplier = uint256(3e18); // E18. 1x = e18\\r\\n    uint256 public lock_time_for_max_multiplier; //set this to rewardsDuration - 6 hours at initialization\\r\\n    uint256 public lock_time_min; //set this at initialization\\r\\n\\r\\n    // Coordination multipliers\\r\\n    uint256 public max_cord_multiplier = uint256(3e18);\\r\\n    uint256 public min_cord_multiplier = uint256(1e18); \\r\\n    uint256 public nonce = 0;\\r\\n    uint256 public max_nonce = 2; //no more than 2 changes to targetRatio\\r\\n    // uint256 public lastRatioUpdate;\\r\\n    // uint256 public min_cooldown = 21 days; \\r\\n    // uint256 public min_ratio_distance = 0.5e18;\\r\\n\\r\\n\\r\\n    //there is only one lockTime - needs to be equal to shanghaiTime\\r\\n    address public LSDRegistryAddress;\\r\\n    address public LSDVaultAddress;\\r\\n    uint256 public shanghaiTime;\\r\\n\\r\\n    // Reward addresses, rates, and managers\\r\\n    mapping(address => address) public rewardManagers; // token addr -> manager addr\\r\\n    address[] public rewardTokens;\\r\\n    uint256[] public rewardRates;\\r\\n    string[] public rewardSymbols;\\r\\n    mapping(address => uint256) public rewardTokenAddrToIdx; // token addr -> token index\\r\\n    \\r\\n    // Reward period\\r\\n    uint256 public rewardsDuration; // from now until Shanghai\\r\\n    \\r\\n    // Reward tracking\\r\\n    uint256[] private rewardsPerTokenStored;\\r\\n    mapping(address => mapping(uint256 => uint256)) private userRewardsPerTokenPaid; // staker addr -> token id -> paid amount\\r\\n    mapping(address => mapping(uint256 => uint256)) private rewards; // staker addr -> token id -> reward amount\\r\\n    mapping(address => uint256) private lastRewardClaimTime; // staker addr -> timestamp\\r\\n\\r\\n    // Balance tracking\\r\\n    uint256 private _total_liquidity_locked;\\r\\n    uint256 private _total_combined_weight;\\r\\n    mapping(address => uint256) private _locked_liquidity;\\r\\n    mapping(address => uint256) private _combined_weights;\\r\\n\\r\\n    // Stake tracking\\r\\n    mapping(address => LockedStake[]) private lockedStakes;\\r\\n\\r\\n    // Greylisting of bad addresses\\r\\n    mapping(address => bool) public greylist; //how long until this one is offensive too?\\r\\n\\r\\n    // Administrative booleans\\r\\n    bool public stakesUnlocked; // Release locked stakes in case of emergency\\r\\n    bool public withdrawalsPaused; // For emergencies\\r\\n    bool public rewardsCollectionPaused; // For emergencies\\r\\n    bool public stakingPaused; // For emergencies\\r\\n\\r\\n    //Price feed for LSDs for coordination multiplier calculations\\r\\n    address public darknetAddress;\\r\\n\\r\\n    /* ========== STRUCTS ========== */\\r\\n    \\r\\n    struct LockedStake {\\r\\n        bytes32 kek_id;\\r\\n        uint256 start_timestamp;\\r\\n        uint256 liquidity;\\r\\n        uint256 ending_timestamp;\\r\\n        uint256 lock_multiplier; // 6 decimals of precision. 1x = 1000000\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier onlyByOwner() {\\r\\n        require(msg.sender == owner, \\\"Not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTknMgrs(address reward_token_address) {\\r\\n        require(msg.sender == owner || isTokenManagerFor(msg.sender, reward_token_address), \\\"Not owner or tkn mgr\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notStakingPaused() {\\r\\n        require(stakingPaused == false, \\\"Staking paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateRewardAndBalance(address account, bool sync_too) {\\r\\n        _updateRewardAndBalance(account, sync_too);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    //this also needs to point to an LSDRegistry\\r\\n    constructor (\\r\\n        address _owner,\\r\\n        address _stakingToken,\\r\\n        address _LSDRegistry,\\r\\n        uint256 _shanghaiTime,\\r\\n        address _darknetAddress,\\r\\n        string[] memory _rewardSymbols,\\r\\n        address[] memory _rewardTokens,\\r\\n        address[] memory _rewardManagers,\\r\\n        uint256[] memory _rewardRates\\r\\n    ) Owned(_owner){\\r\\n        //check that LSDRegistry is not 0x0\\r\\n        require(_LSDRegistry != address(0), \\\"LSDRegistry is 0x0\\\");\\r\\n        LSDRegistryAddress = _LSDRegistry;\\r\\n        LSDVaultAddress = ILSDRegistry(LSDRegistryAddress).vaultAddress();\\r\\n        //check that LSDRegistry's shanghaiTime matches the given shanghaiTime\\r\\n        require(_shanghaiTime == ILSDRegistry(LSDRegistryAddress).shanghaiTime(), \\\"shanghaiTime mismatch\\\");\\r\\n        shanghaiTime = _shanghaiTime;\\r\\n        stakingToken = IERC20(_stakingToken);\\r\\n        darknetAddress = _darknetAddress;\\r\\n\\r\\n        rewardTokens = _rewardTokens;\\r\\n        rewardRates = _rewardRates;\\r\\n        rewardSymbols = _rewardSymbols;\\r\\n        rewardsDuration = shanghaiTime - block.timestamp;\\r\\n        lock_time_for_max_multiplier = rewardsDuration - 24 hours;\\r\\n\\r\\n        for (uint256 i = 0; i < _rewardTokens.length; i++){ \\r\\n            // For fast token address -> token ID lookups later\\r\\n            rewardTokenAddrToIdx[_rewardTokens[i]] = i;\\r\\n\\r\\n            // Initialize the stored rewards\\r\\n            rewardsPerTokenStored.push(0);\\r\\n\\r\\n            // Initialize the reward managers\\r\\n            rewardManagers[_rewardTokens[i]] = _rewardManagers[i];\\r\\n        }\\r\\n\\r\\n        // Other booleans\\r\\n        stakesUnlocked = false;\\r\\n\\r\\n        // Initialization\\r\\n        lastUpdateTime = block.timestamp;\\r\\n        periodFinish = block.timestamp.add(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    // Total locked liquidity tokens\\r\\n    function totalLiquidityLocked() external view returns (uint256) {\\r\\n        return _total_liquidity_locked;\\r\\n    }\\r\\n\\r\\n    // Locked liquidity for a given account\\r\\n    function lockedLiquidityOf(address account) external view returns (uint256) {\\r\\n        return _locked_liquidity[account];\\r\\n    }\\r\\n\\r\\n    // Total 'balance' used for calculating the percent of the pool the account owns\\r\\n    // Takes into account the locked stake time multiplier\\r\\n    function totalCombinedWeight() external view returns (uint256) {\\r\\n        return _total_combined_weight;\\r\\n    }\\r\\n\\r\\n    // Combined weight for a specific account\\r\\n    function combinedWeightOf(address account) external view returns (uint256) {\\r\\n        return _combined_weights[account];\\r\\n    }\\r\\n\\r\\n    // Calculated the combined weight for an account\\r\\n    function calcCurCombinedWeight(address account) public view\\r\\n        returns (\\r\\n            uint256 old_combined_weight,\\r\\n            uint256 new_combined_weight\\r\\n        )\\r\\n    {\\r\\n        // Get the old combined weight\\r\\n        old_combined_weight = _combined_weights[account];\\r\\n\\r\\n        // Loop through the locked stakes, first by getting the liquidity * lock_multiplier portion\\r\\n        new_combined_weight = 0;\\r\\n        for (uint256 i = 0; i < lockedStakes[account].length; i++) {\\r\\n            LockedStake memory thisStake = lockedStakes[account][i];\\r\\n            uint256 lock_multiplier = thisStake.lock_multiplier;\\r\\n            //add coordination multiplier here\\r\\n            uint256 cord_multiplier = coordinationMultiplier();\\r\\n            require(cord_multiplier != 0, \\\"Multiplier error\\\");\\r\\n            //set min_cord_multiplier < 1e18 if we want to shrink yield below base rate\\r\\n            if (cord_multiplier <= min_cord_multiplier){\\r\\n                cord_multiplier = min_cord_multiplier;\\r\\n            }\\r\\n\\r\\n            // If the lock is expired\\r\\n            if (thisStake.ending_timestamp <= block.timestamp) {\\r\\n                // If the lock expired in the time since the last claim, the weight needs to be proportionately averaged this time\\r\\n                if (lastRewardClaimTime[account] < thisStake.ending_timestamp){\\r\\n                    uint256 time_before_expiry = (thisStake.ending_timestamp).sub(lastRewardClaimTime[account]);\\r\\n                    uint256 time_after_expiry = (block.timestamp).sub(thisStake.ending_timestamp);\\r\\n\\r\\n                    // Get the weighted-average lock_multiplier\\r\\n                    uint256 numerator = ((lock_multiplier).mul(time_before_expiry)).add(((MULTIPLIER_PRECISION).mul(time_after_expiry)));\\r\\n                    lock_multiplier = numerator.div(time_before_expiry.add(time_after_expiry));\\r\\n                }\\r\\n                // Otherwise, it needs to just be 1x\\r\\n                else {\\r\\n                    lock_multiplier = MULTIPLIER_PRECISION;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            uint256 liquidity = thisStake.liquidity;\\r\\n            uint256 combined_boosted_amount = liquidity.mul(lock_multiplier).div(MULTIPLIER_PRECISION);\\r\\n            uint256 coordination_boosted_amount = combined_boosted_amount.mul(cord_multiplier).div(MULTIPLIER_PRECISION);\\r\\n            new_combined_weight = new_combined_weight.add(coordination_boosted_amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // All the locked stakes for a given account\\r\\n    function lockedStakesOf(address account) external view returns (LockedStake[] memory) {\\r\\n        return lockedStakes[account];\\r\\n    }\\r\\n\\r\\n    // All the locked stakes for a given account\\r\\n    function getRewardSymbols() external view returns (string[] memory) {\\r\\n        return rewardSymbols;\\r\\n    }\\r\\n\\r\\n    // All the reward tokens\\r\\n    function getAllRewardTokens() external view returns (address[] memory) {\\r\\n        return rewardTokens;\\r\\n    }\\r\\n\\r\\n    // All the reward rates\\r\\n    function getAllRewardRates() external view returns (uint256[] memory) {\\r\\n        return rewardRates;\\r\\n    }\\r\\n    \\r\\n    // Multiplier amount, given the length of the lock\\r\\n    function lockMultiplier(uint256 secs) public view returns (uint256) {\\r\\n        uint256 lock_multiplier =\\r\\n            uint256(MULTIPLIER_PRECISION).add(\\r\\n                secs\\r\\n                    .mul(lock_max_multiplier.sub(MULTIPLIER_PRECISION))\\r\\n                    .div(lock_time_for_max_multiplier)\\r\\n            );\\r\\n        if (lock_multiplier > lock_max_multiplier) lock_multiplier = lock_max_multiplier;\\r\\n        return lock_multiplier;\\r\\n    }\\r\\n\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n        // else z = 0 (default value)\\r\\n    }\\r\\n   \\r\\n    function euclideanDistance(uint256[] memory _a, uint256[] memory _b) internal pure returns (uint256) {\\r\\n            require(_a.length == _b.length, \\\"Array length mismatch\\\");\\r\\n            int256 a;\\r\\n            int256 b;\\r\\n            uint256 sumSqDiff;\\r\\n            uint256 diff;\\r\\n            for (uint256 i = 0; i < _a.length; i++) {\\r\\n                a = int256(_a[i]/1e15);\\r\\n                b = int256(_b[i]/1e15);\\r\\n                diff = uint256(a > b ? a - b : b - a);\\r\\n                uint256 squareDiff = diff**2;\\r\\n                sumSqDiff += squareDiff;\\r\\n            }\\r\\n            return sqrt(sumSqDiff)*1e15;\\r\\n    }\\r\\n\\r\\n    function coordinationMultiplier() public view returns(uint256) {\\r\\n        //get ratios\\r\\n        //fetch the current targetRatio locally\\r\\n        //ratios should be in the form of [0.25e18, 0.25e18, 0.25e18, 0.25e18] for 4 LSDs\\r\\n        uint256[] memory targetRatio = ILSDRegistry(LSDRegistryAddress).targetRatio();\\r\\n        address[] memory lsdAddresses = ILSDRegistry(LSDRegistryAddress).lsdAddresses();\\r\\n        //make sure the lengths match\\r\\n        require(targetRatio.length == lsdAddresses.length, \\\"targetRatio and lsdAddresses length mismatch\\\");\\r\\n        uint256 tabs = lsdAddresses.length;\\r\\n        console.log(tabs);\\r\\n        uint256[] memory currentRatio = new uint256[](tabs);\\r\\n        console.log(currentRatio.length);\\r\\n        console.log(LSDVaultAddress);\\r\\n        uint256 totalETHbalance = ILSDVault(LSDVaultAddress).balanceInUnderlying();\\r\\n        console.log(totalETHbalance);\\r\\n        //get the current balances of all LSDs in vault in terms of underlying ETH to compute ratio\\r\\n        for (uint256 i = 0; i < tabs; i++) {\\r\\n            uint256 balance = IERC20(lsdAddresses[i]).balanceOf(LSDVaultAddress);\\r\\n            //convert to actual underlying amounts\\r\\n            uint256 rate = IDarknet(darknetAddress).checkPrice(lsdAddresses[i]);\\r\\n            uint256 ratio = mulDiv(balance, rate, totalETHbalance);\\r\\n            currentRatio[i] = ratio;\\r\\n        }\\r\\n        //from here onwards these operations cost ~50k gas \\r\\n        uint256 _x = euclideanDistance(targetRatio, currentRatio);\\r\\n        uint256 L = mulDiv18(_x, 2.5e18);\\r\\n        UD60x18 l_scaled = div(ud(L), ud(1.0e18));\\r\\n        UD60x18 e_L = exp(l_scaled);\\r\\n        UD60x18 hell = ud(3.0e18).sub(inv(e_L)).sub(ud(L));\\r\\n        UD60x18 hella = div(powu(hell, 3),ud(4.0e18));\\r\\n        return unwrap(hella.add(ud(1.0e18)));\\r\\n    }\\r\\n\\r\\n    // Last time the reward was applicable\\r\\n    function lastTimeRewardApplicable() internal view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    // Amount of reward tokens per LP token\\r\\n    function rewardsPerToken() public view returns (uint256[] memory newRewardsPerTokenStored) {\\r\\n        if (_total_liquidity_locked == 0 || _total_combined_weight == 0) {\\r\\n            return rewardsPerTokenStored;\\r\\n        }\\r\\n        else {\\r\\n            newRewardsPerTokenStored = new uint256[](rewardTokens.length);\\r\\n            for (uint256 i = 0; i < rewardsPerTokenStored.length; i++){ \\r\\n                newRewardsPerTokenStored[i] = rewardsPerTokenStored[i].add(\\r\\n                    lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRates[i]).mul(1e18).div(_total_combined_weight)\\r\\n                );\\r\\n            }\\r\\n            return newRewardsPerTokenStored;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Amount of reward tokens an account has earned / accrued\\r\\n    // Note: In the edge-case of one of the account's stake expiring since the last claim, this will\\r\\n    // return a slightly inflated number\\r\\n    function earned(address account) public view returns (uint256[] memory new_earned) {\\r\\n        uint256[] memory reward_arr = rewardsPerToken();\\r\\n        new_earned = new uint256[](rewardTokens.length);\\r\\n\\r\\n        if (_combined_weights[account] == 0){\\r\\n            for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n                new_earned[i] = 0;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n                new_earned[i] = (_combined_weights[account])\\r\\n                    .mul(reward_arr[i].sub(userRewardsPerTokenPaid[account][i]))\\r\\n                    .div(1e18)\\r\\n                    .add(rewards[account][i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Total reward tokens emitted in the given period\\r\\n    function getRewardForDuration() external view returns (uint256[] memory rewards_per_duration_arr) {\\r\\n        rewards_per_duration_arr = new uint256[](rewardRates.length);\\r\\n\\r\\n        for (uint256 i = 0; i < rewardRates.length; i++){ \\r\\n            rewards_per_duration_arr[i] = rewardRates[i].mul(rewardsDuration);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // See if the caller_addr is a manager for the reward token \\r\\n    function isTokenManagerFor(address caller_addr, address reward_token_addr) public view returns (bool){\\r\\n        if (caller_addr == owner) return true; // Contract owner\\r\\n        else if (rewardManagers[reward_token_addr] == caller_addr) return true; // Reward manager\\r\\n        return false; \\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n    function synchronize() external {\\r\\n        uint256 proposedNonce = ILSDRegistry(LSDRegistryAddress).nonce();\\r\\n        require(nonce != proposedNonce, \\\"Already synchronized\\\");\\r\\n         _synchronize();\\r\\n    }\\r\\n\\r\\n    function _synchronize() internal {\\r\\n        //set current coordination-boosted rate to the new min\\r\\n        uint256 current_boosted_rate = coordinationMultiplier()*rewardRates[0]/1e18; //only for USH rewards, change later if needed\\r\\n        rewardRates[0] = current_boosted_rate;\\r\\n        //update to the new target ratio\\r\\n    }\\r\\n\\r\\n    function _updateRewardAndBalance(address account, bool sync_too) internal {\\r\\n        // Need to retro-adjust some things if the period hasn't been renewed, then start a new one\\r\\n        if (sync_too){\\r\\n            sync();\\r\\n        }\\r\\n        \\r\\n        if (account != address(0)) {\\r\\n            // To keep the math correct, the user's combined weight must be recomputed\\r\\n            (   \\r\\n                uint256 old_combined_weight,\\r\\n                uint256 new_combined_weight\\r\\n            ) = calcCurCombinedWeight(account);\\r\\n\\r\\n            // Calculate the earnings first\\r\\n            _syncEarned(account);\\r\\n\\r\\n            // Update the user's and the global combined weights\\r\\n            if (new_combined_weight >= old_combined_weight) {\\r\\n                uint256 weight_diff = new_combined_weight.sub(old_combined_weight);\\r\\n                _total_combined_weight = _total_combined_weight.add(weight_diff);\\r\\n                _combined_weights[account] = old_combined_weight.add(weight_diff);\\r\\n            } else {\\r\\n                uint256 weight_diff = old_combined_weight.sub(new_combined_weight);\\r\\n                _total_combined_weight = _total_combined_weight.sub(weight_diff);\\r\\n                _combined_weights[account] = old_combined_weight.sub(weight_diff);\\r\\n            }\\r\\n\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _syncEarned(address account) internal {\\r\\n        if (account != address(0)) {\\r\\n            // Calculate the earnings\\r\\n            uint256[] memory earned_arr = earned(account);\\r\\n\\r\\n            // Update the rewards array\\r\\n            for (uint256 i = 0; i < earned_arr.length; i++){ \\r\\n                rewards[account][i] = earned_arr[i];\\r\\n            }\\r\\n\\r\\n            // Update the rewards paid array\\r\\n            for (uint256 i = 0; i < earned_arr.length; i++){ \\r\\n                userRewardsPerTokenPaid[account][i] = rewardsPerTokenStored[i];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Two different stake functions are needed because of delegateCall and msg.sender issues\\r\\n    function stakeLocked(uint256 liquidity) nonReentrant public {\\r\\n\\r\\n        _stakeLocked(msg.sender, msg.sender, liquidity, block.timestamp);\\r\\n    }\\r\\n\\r\\n    // If this were not internal, and source_address had an infinite approve, this could be exploitable\\r\\n    // (pull funds from source_address and stake for an arbitrary staker_address)\\r\\n    function _stakeLocked(\\r\\n        address staker_address, \\r\\n        address source_address, \\r\\n        uint256 liquidity, \\r\\n        uint256 start_timestamp\\r\\n    ) internal updateRewardAndBalance(staker_address, true) {\\r\\n        require(!stakingPaused, \\\"Staking paused\\\");\\r\\n        require(liquidity > 0, \\\"Must stake more than zero\\\");\\r\\n        require(greylist[staker_address] == false, \\\"Address has been greylisted\\\");\\r\\n        // require(secs >= lock_time_min, \\\"Minimum stake time not met\\\");\\r\\n        // require(secs <= lock_time_for_max_multiplier,\\\"Trying to lock for too long\\\");\\r\\n        uint256 secs = shanghaiTime - block.timestamp;\\r\\n        uint256 lock_multiplier = lockMultiplier(secs);\\r\\n        bytes32 kek_id = keccak256(abi.encodePacked(staker_address, start_timestamp, liquidity, _locked_liquidity[staker_address]));\\r\\n        lockedStakes[staker_address].push(LockedStake(\\r\\n            kek_id,\\r\\n            start_timestamp,\\r\\n            liquidity,\\r\\n            shanghaiTime,//replaced start_timestamp.add(secs) w/ shanghaiTime\\r\\n            lock_multiplier\\r\\n        ));\\r\\n\\r\\n        // Pull the tokens from the source_address\\r\\n        TransferHelper.safeTransferFrom(address(stakingToken), source_address, address(this), liquidity);\\r\\n\\r\\n        // Update liquidities\\r\\n        _total_liquidity_locked = _total_liquidity_locked.add(liquidity);\\r\\n        _locked_liquidity[staker_address] = _locked_liquidity[staker_address].add(liquidity);\\r\\n\\r\\n        // Need to call to update the combined weights\\r\\n        _updateRewardAndBalance(staker_address, false);\\r\\n\\r\\n        // Needed for edge case if the staker only claims once, and after the lock expired\\r\\n        if (lastRewardClaimTime[staker_address] == 0) lastRewardClaimTime[staker_address] = block.timestamp;\\r\\n\\r\\n        emit StakeLocked(staker_address, liquidity, secs, kek_id, source_address);\\r\\n    }\\r\\n\\r\\n    // Two different withdrawLocked functions are needed because of delegateCall and msg.sender issues\\r\\n    function withdrawLocked(bytes32 kek_id) nonReentrant public {\\r\\n        require(withdrawalsPaused == false, \\\"Withdrawals paused\\\");\\r\\n        _withdrawLocked(msg.sender, msg.sender, kek_id);\\r\\n    }\\r\\n\\r\\n    // No withdrawer == msg.sender check needed since this is only internally callable and the checks are done in the wrapper\\r\\n    // functions like withdraw()\\r\\n    function _withdrawLocked(address staker_address, address destination_address, bytes32 kek_id) internal  {\\r\\n        // Collect rewards first and then update the balances\\r\\n        _getReward(staker_address, destination_address);\\r\\n\\r\\n        LockedStake memory thisStake;\\r\\n        thisStake.liquidity = 0;\\r\\n        uint theArrayIndex;\\r\\n        for (uint256 i = 0; i < lockedStakes[staker_address].length; i++){ \\r\\n            if (kek_id == lockedStakes[staker_address][i].kek_id){\\r\\n                thisStake = lockedStakes[staker_address][i];\\r\\n                theArrayIndex = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        require(thisStake.kek_id == kek_id, \\\"Stake not found\\\");\\r\\n        require(block.timestamp >= thisStake.ending_timestamp || stakesUnlocked == true, \\\"Stake is still locked!\\\");\\r\\n\\r\\n        uint256 liquidity = thisStake.liquidity;\\r\\n\\r\\n        if (liquidity > 0) {\\r\\n            // Update liquidities\\r\\n            _total_liquidity_locked = _total_liquidity_locked.sub(liquidity);\\r\\n            _locked_liquidity[staker_address] = _locked_liquidity[staker_address].sub(liquidity);\\r\\n\\r\\n            // Remove the stake from the array\\r\\n            delete lockedStakes[staker_address][theArrayIndex];\\r\\n\\r\\n            // Need to call to update the combined weights\\r\\n            _updateRewardAndBalance(staker_address, false);\\r\\n\\r\\n            // Give the tokens to the destination_address\\r\\n            // Should throw if insufficient balance\\r\\n            stakingToken.transfer(destination_address, liquidity);\\r\\n\\r\\n            emit WithdrawLocked(staker_address, liquidity, kek_id, destination_address);\\r\\n        }\\r\\n\\r\\n    }\\r\\n    \\r\\n    // Two different getReward functions are needed because of delegateCall and msg.sender issues\\r\\n    function getReward() external nonReentrant returns (uint256[] memory) {\\r\\n        require(rewardsCollectionPaused == false,\\\"Rewards collection paused\\\");\\r\\n        return _getReward(msg.sender, msg.sender);\\r\\n    }\\r\\n\\r\\n    // No withdrawer == msg.sender check needed since this is only internally callable\\r\\n    function _getReward(address rewardee, address destination_address) internal updateRewardAndBalance(rewardee, true) returns (uint256[] memory rewards_before) {\\r\\n        // Update the rewards array and distribute rewards\\r\\n        rewards_before = new uint256[](rewardTokens.length);\\r\\n\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n            rewards_before[i] = rewards[rewardee][i];\\r\\n            rewards[rewardee][i] = 0;\\r\\n            //use SafeERC20.transfer\\r\\n            IERC20(rewardTokens[i]).transfer(destination_address, rewards_before[i]);\\r\\n            emit RewardPaid(rewardee, rewards_before[i], rewardTokens[i], destination_address);\\r\\n        }\\r\\n\\r\\n        lastRewardClaimTime[rewardee] = block.timestamp;\\r\\n    }\\r\\n\\r\\n    // If the period expired, DON'T renew it\\r\\n    function retroCatchUp() internal {\\r\\n        // Failsafe check\\r\\n        require(block.timestamp > periodFinish, \\\"Period has not expired yet!\\\");\\r\\n\\r\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\r\\n        // This keeps the reward rate in the right range, preventing overflows due to\\r\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\r\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\r\\n        // uint256 num_periods_elapsed = uint256(block.timestamp.sub(periodFinish)) / rewardsDuration; // Floor division to the nearest period\\r\\n        \\r\\n        // // Make sure there are enough tokens to renew the reward period\\r\\n        // for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n        //     require(rewardRates[i].mul(rewardsDuration).mul(num_periods_elapsed + 1) <= IERC20(rewardTokens[i]).balanceOf(address(this)), string(abi.encodePacked(\\\"Not enough reward tokens available: \\\", rewardTokens[i])) );\\r\\n        // }\\r\\n        \\r\\n        // uint256 old_lastUpdateTime = lastUpdateTime;\\r\\n        // uint256 new_lastUpdateTime = block.timestamp;\\r\\n\\r\\n        // lastUpdateTime = periodFinish;\\r\\n        //periodFinish = periodFinish.add((num_periods_elapsed.add(1)).mul(rewardsDuration));\\r\\n\\r\\n        _updateStoredRewardsAndTime();\\r\\n\\r\\n        //emit RewardsPeriodRenewed(address(stakingToken));\\r\\n    }\\r\\n\\r\\n    function _updateStoredRewardsAndTime() internal {\\r\\n        // Get the rewards\\r\\n        uint256[] memory rewards_per_token = rewardsPerToken();\\r\\n\\r\\n        // Update the rewardsPerTokenStored\\r\\n        for (uint256 i = 0; i < rewardsPerTokenStored.length; i++){ \\r\\n            rewardsPerTokenStored[i] = rewards_per_token[i];\\r\\n        }\\r\\n\\r\\n        // Update the last stored time\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n    }\\r\\n\\r\\n    function sync() public {\\r\\n        if (block.timestamp > periodFinish) {\\r\\n            retroCatchUp();\\r\\n        }\\r\\n        else {\\r\\n            _updateStoredRewardsAndTime();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    // Added to support recovering LP Rewards and other mistaken tokens from other systems to be distributed to holders\\r\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyTknMgrs(tokenAddress) {\\r\\n        // Cannot rug the staking / LP tokens\\r\\n        require(tokenAddress != address(stakingToken), \\\"Cannot rug staking / LP tokens\\\");\\r\\n\\r\\n        // Check if the desired token is a reward token\\r\\n        bool isRewardToken = false;\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++){ \\r\\n            if (rewardTokens[i] == tokenAddress) {\\r\\n                isRewardToken = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Only the reward managers can take back their reward tokens\\r\\n        if (isRewardToken && rewardManagers[tokenAddress] == msg.sender){\\r\\n            IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\\r\\n            emit Recovered(msg.sender, tokenAddress, tokenAmount);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Other tokens, like airdrops or accidental deposits, can be withdrawn by the owner\\r\\n        else if (!isRewardToken && (msg.sender == owner)){\\r\\n            IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\\r\\n            emit Recovered(msg.sender, tokenAddress, tokenAmount);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // If none of the above conditions are true\\r\\n        else {\\r\\n            revert(\\\"No valid tokens to recover\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyByOwner {\\r\\n        require(_rewardsDuration >= 86400, \\\"Rewards duration too short\\\");\\r\\n        require(\\r\\n            periodFinish == 0 || block.timestamp > periodFinish,\\r\\n            \\\"Reward period incomplete\\\"\\r\\n        );\\r\\n        rewardsDuration = _rewardsDuration;\\r\\n        emit RewardsDurationUpdated(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    function setMultipliers(uint256 _lock_max_multiplier) external onlyByOwner {\\r\\n        require(_lock_max_multiplier >= uint256(1e18), \\\"Multiplier must be greater than or equal to 1e18\\\");\\r\\n        lock_max_multiplier = _lock_max_multiplier;\\r\\n        emit LockedStakeMaxMultiplierUpdated(lock_max_multiplier);\\r\\n    }\\r\\n\\r\\n    function setLockedStakeTimeForMinAndMaxMultiplier(uint256 _lock_time_for_max_multiplier, uint256 _lock_time_min) external onlyByOwner {\\r\\n        require(_lock_time_for_max_multiplier >= 1, \\\"Mul max time must be >= 1\\\");\\r\\n        require(_lock_time_min >= 1, \\\"Mul min time must be >= 1\\\");\\r\\n\\r\\n        lock_time_for_max_multiplier = _lock_time_for_max_multiplier;\\r\\n        lock_time_min = _lock_time_min;\\r\\n\\r\\n        emit LockedStakeTimeForMaxMultiplier(lock_time_for_max_multiplier);\\r\\n        emit LockedStakeMinTime(_lock_time_min);\\r\\n    }\\r\\n\\r\\n    function greylistAddress(address _address) external onlyByOwner {\\r\\n        greylist[_address] = !(greylist[_address]);\\r\\n    }\\r\\n\\r\\n    function unlockStakes() external onlyByOwner {\\r\\n        stakesUnlocked = !stakesUnlocked;\\r\\n    }\\r\\n\\r\\n    function toggleStaking() external onlyByOwner {\\r\\n        stakingPaused = !stakingPaused;\\r\\n    }\\r\\n\\r\\n    function toggleWithdrawals() external onlyByOwner {\\r\\n        withdrawalsPaused = !withdrawalsPaused;\\r\\n    }\\r\\n\\r\\n    function toggleRewardsCollection() external onlyByOwner {\\r\\n        rewardsCollectionPaused = !rewardsCollectionPaused;\\r\\n    }\\r\\n\\r\\n    // The owner or the reward token managers can set reward rates \\r\\n    function setRewardRate(address reward_token_address, uint256 new_rate, bool sync_too) external onlyTknMgrs(reward_token_address) {\\r\\n        rewardRates[rewardTokenAddrToIdx[reward_token_address]] = new_rate;\\r\\n        \\r\\n        if (sync_too){\\r\\n            sync();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // The owner or the reward token managers can change managers\\r\\n    function changeTokenManager(address reward_token_address, address new_manager_address) external onlyTknMgrs(reward_token_address) {\\r\\n        rewardManagers[reward_token_address] = new_manager_address;\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event StakeLocked(address indexed user, uint256 amount, uint256 secs, bytes32 kek_id, address source_address);\\r\\n    event WithdrawLocked(address indexed user, uint256 amount, bytes32 kek_id, address destination_address);\\r\\n    event RewardPaid(address indexed user, uint256 reward, address token_address, address destination_address);\\r\\n    event RewardsDurationUpdated(uint256 newDuration);\\r\\n    event Recovered(address destination_address, address token, uint256 amount);\\r\\n    event RewardsPeriodRenewed(address token);\\r\\n    event LockedStakeMaxMultiplierUpdated(uint256 multiplier);\\r\\n    event LockedStakeTimeForMaxMultiplier(uint256 secs);\\r\\n    event LockedStakeMinTime(uint256 secs);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface IERC20{\\r\\n\\r\\n    function transferFrom(address from, address to, uint amount) external view returns(bool);\\r\\n\\r\\n    function approve() external view returns(uint256);\\r\\n\\r\\n    function decimals() external view returns(uint256);\\r\\n\\r\\n    function totalSupply() external view returns(uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns(uint256);\\r\\n\\r\\n    function transfer(address to, uint amount) external ;\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"src/interfaces/IGovFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ninterface IGovFarm {\\r\\n    function getAllUsers() external returns (address[] memory);\\r\\n    function lastClaimTimestamp(address user) external returns (uint);\\r\\n}\"\r\n    },\r\n    \"src/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\n\\r\\n/// @title Router token swapping functionality\\r\\n/// @notice Functions for swapping tokens via Uniswap V3\\r\\ninterface ISwapRouter {\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\r\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\r\\n    /// @return amountOut The amount of the received token\\r\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\r\\n\\r\\n    struct ExactInputParams {\\r\\n        bytes path;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\r\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\r\\n    /// @return amountOut The amount of the received token\\r\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\r\\n\\r\\n    struct ExactOutputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountOut;\\r\\n        uint256 amountInMaximum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\r\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\r\\n    /// @return amountIn The amount of the input token\\r\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\r\\n\\r\\n    struct ExactOutputParams {\\r\\n        bytes path;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountOut;\\r\\n        uint256 amountInMaximum;\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\r\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\r\\n    /// @return amountIn The amount of the input token\\r\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\r\\n}\"\r\n    },\r\n    \"src/interfaces/IvdUSH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n\\r\\ninterface IvdUSH {\\r\\n\\r\\n    function totalSupply() external view returns(uint256);\\r\\n    function balanceOf(address account) external view returns(uint256);\\r\\n    function epoch() external view returns(uint256);\\r\\n\\r\\n    function locked(address account) external view returns(uint256);\\r\\n    function deposit_for(address _addr, uint _valueA, uint _valueB, uint _valueC) external;\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function balanceOfAtT(address account, uint256 ts) external view returns(uint256);\\r\\n\\r\\n    function point_history(uint256 _epoch) external view returns(int128 bias, int128 slope, uint ts, uint blk);\\r\\n    function user_point_epoch(address account) external view returns(uint256);\\r\\n    function user_point_history__ts(address _addr, uint _idx) external view returns (uint256);\\r\\n    function slope_changes(uint256 time) external view returns(int128);\\r\\n\\r\\n}\"\r\n    },\r\n    \"src/LSDVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.11;\\r\\n\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\nimport \\\"communal/Owned.sol\\\";\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"communal/TransferHelper.sol\\\";\\r\\n//import \\\"forge-std/console.sol\\\";\\r\\n\\r\\n/*\\r\\n* LSD Vault Contract:\\r\\n* This contract is responsible for holding and managing the deposited LSDs. It mints unshETH to depositors.\\r\\n*/\\r\\n\\r\\n//Access control hierarchy\\r\\n//owner = multisig: used for initial setup + admin functions + unlocking timelocked functions\\r\\n//admin = team eoa: used for emergency functions and low level configs\\r\\n//timelock = multisig can propose unlock + 72 hr delay: used for functions that affect user funds\\r\\n\\r\\ninterface IunshETH {\\r\\n    function minter_mint(address m_address, uint256 m_amount) external;\\r\\n    function minter_burn_from(address b_address, uint256 b_amount) external;\\r\\n    function timelock_address() external returns (address);\\r\\n    function addMinter(address minter_address) external;\\r\\n    function setTimelock(address _timelock_address) external;\\r\\n    function removeMinter(address minter_address) external;\\r\\n}\\r\\n\\r\\ninterface ILSDVault {\\r\\n    function balanceInUnderlying() external view returns (uint256);\\r\\n    function exit(uint256 amount) external;\\r\\n    function shanghaiTime() external returns(uint256);\\r\\n}\\r\\n\\r\\ninterface IDarknet {\\r\\n    function checkPrice(address lsd) external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract LSDVault is Owned, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n    /*\\r\\n    ============================================================================\\r\\n    State Variables\\r\\n    ============================================================================\\r\\n    */\\r\\n    // address public admin;\\r\\n    uint256 public shanghaiTime = 1682007600; //timestamp for April 20, 2023 4:20:00PM UTC (~1 wk after ETH network upgrade)\\r\\n    address public constant v1VaultAddress = address(0xE76Ffee8722c21b390eebe71b67D95602f58237F);\\r\\n    address public unshETHAddress;\\r\\n    address public unshethZapAddress;\\r\\n    address public swapperAddress;\\r\\n    address public admin;\\r\\n    address public darknetAddress;\\r\\n\\r\\n    address[] public supportedLSDs;\\r\\n    mapping(address => uint256) public lsdIndex; //keep track of reverse mapping of supportedLSDs indices for fast lookup\\r\\n\\r\\n    struct LSDConfig {\\r\\n        uint256 targetWeightBps;\\r\\n        uint256 weightCapBps;\\r\\n        uint256 absoluteCapEth;\\r\\n    }\\r\\n\\r\\n    mapping(address => LSDConfig) public lsdConfigs;\\r\\n    bool public useWeightCaps;\\r\\n    bool public useAbsoluteCaps;\\r\\n    bool public includeV1VaultAssets;\\r\\n    mapping(address => bool) public isEnabled;\\r\\n\\r\\n    uint256 public constant _TIMELOCK = 3 days;\\r\\n    enum TimelockFunctions { MIGRATE, AMM, DARKNET, ZAP }\\r\\n\\r\\n    struct TimelockProposal {\\r\\n        address proposedAddress;\\r\\n        uint256 unlockTime;\\r\\n    }\\r\\n\\r\\n    mapping(TimelockFunctions => TimelockProposal) public timelock;\\r\\n\\r\\n    //Redeem fees in basis points, configurable by multisig\\r\\n    uint256 public redeemFee = 0;\\r\\n    uint256 public constant maxRedeemFee = 200; //max 200 basis points = 2% fee\\r\\n\\r\\n    bool public depositsPaused;\\r\\n    bool public migrated = false;\\r\\n    bool public ammEnabled = false;\\r\\n\\r\\n    bool public withdrawalsPaused = false;\\r\\n    uint256 public withdrawalUnpauseTime;\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Events\\r\\n    ============================================================================\\r\\n    */\\r\\n    event DepositPauseToggled(bool paused);\\r\\n    event ShanghaiTimeUpdated(uint256 newTime);\\r\\n    event UnshethAddressSet(address unshethAddress);\\r\\n    event UnshethZapAddressSet(address unshethZapAddress);\\r\\n    event AdminSet(address admin);\\r\\n\\r\\n    event LSDAdded(address lsd);\\r\\n    event LSDConfigSet(address lsd, LSDConfig config);\\r\\n    event LSDDisabled(address lsd);\\r\\n    event LSDEnabled(address lsd);\\r\\n\\r\\n    event AbsoluteCapsToggled(bool useAbsoluteCaps);\\r\\n    event WeightCapsToggled(bool useWeightCaps);\\r\\n    event IncludeV1VaultAssetsToggled(bool includeV1Assets);\\r\\n    event RedeemFeeUpdated(uint256 redeemFee);\\r\\n\\r\\n    event TimelockUpdateProposed(TimelockFunctions _fn, address _newAddress, uint256 _unlockTime);\\r\\n    event TimelockUpdateCanceled(TimelockFunctions _fn);\\r\\n    event TimelockUpdateCompleted(TimelockFunctions _fn);\\r\\n\\r\\n    event VdAmmDisabled(address swapper);\\r\\n\\r\\n    event WithdrawalsPaused(uint256 withdrawalUnpauseTime);\\r\\n    event WithdrawalsUnpaused();\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Constructor\\r\\n    ============================================================================\\r\\n    */\\r\\n    constructor(address _owner, address _darknetAddress, address _unshethAddress, address[] memory _lsds) Owned(_owner){\\r\\n        darknetAddress = _darknetAddress;\\r\\n        unshETHAddress = _unshethAddress;\\r\\n        depositsPaused = true;\\r\\n        for(uint256 i=0; i < _lsds.length; i = unchkIncr(i)) {\\r\\n            addLSD(_lsds[i]);\\r\\n            setLSDConfigs(_lsds[i], 2500, 5000, 2500e18); //initialize with 25% target, 50% max, 2500ETH absolute max\\r\\n        }\\r\\n        useWeightCaps = false;\\r\\n        useAbsoluteCaps = false;\\r\\n        includeV1VaultAssets = false;\\r\\n    }\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Function Modifiers\\r\\n    ============================================================================\\r\\n    */\\r\\n    modifier onlyZap {\\r\\n        require(msg.sender == unshethZapAddress, \\\"Only the unsheth Zap contract may perform this action\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerOrAdmin {\\r\\n        require(msg.sender == owner || msg.sender == admin, \\\"Only the owner or admin may perform this action\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier postShanghai {\\r\\n        require(block.timestamp >= shanghaiTime + _TIMELOCK, \\\"ShanghaiTime + Timelock has not passed\\\" );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWhenPaused {\\r\\n        require(depositsPaused, \\\"Deposits must be paused before performing this action\\\" );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier timelockUnlocked(TimelockFunctions _fn) {\\r\\n        require(timelock[_fn].unlockTime != 0 && timelock[_fn].unlockTime <= block.timestamp, \\\"Function is timelocked\\\");\\r\\n        require(timelock[_fn].proposedAddress != address(0), \\\"Cannot set zero address\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //helper to perform lower gas unchecked increment in for loops\\r\\n    function unchkIncr(uint256 i) private pure returns(uint256) {\\r\\n        unchecked { return i+1; }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Setup functions\\r\\n    ============================================================================\\r\\n    */\\r\\n    function setUnshethZap(address _unshethZapAddress) external onlyOwner {\\r\\n        require(unshethZapAddress == address(0), \\\"UnshETH zap address already set\\\" );\\r\\n        unshethZapAddress = _unshethZapAddress;\\r\\n        emit UnshethZapAddressSet(unshethZapAddress);\\r\\n    }\\r\\n\\r\\n    function setAdmin(address _admin) external onlyOwner {\\r\\n        admin = _admin;\\r\\n        emit AdminSet(admin);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    LSD configuration functions\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    //Workflow to add new LSD: First addLSD, then setLSDConfigs, then configure it in darknet, then enableLSD\\r\\n    //New LSD is always added with zero weight and disabled\\r\\n    //Deposits must be paused before configuring, and should be enabled when done\\r\\n\\r\\n    function addLSD(address _lsd) public onlyOwner onlyWhenPaused {\\r\\n        require(lsdIndex[_lsd] == 0, \\\"Lsd has already been added\\\"); //fyi fails on the first lsd being duplicated since it has actual index 0\\r\\n        supportedLSDs.push(_lsd);\\r\\n        lsdIndex[_lsd] = supportedLSDs.length-1; //reverse mapping of supportedLSDs indices\\r\\n        isEnabled[_lsd] = false;\\r\\n        lsdConfigs[_lsd] = LSDConfig(0, 0, 0);\\r\\n        emit LSDAdded(_lsd);\\r\\n    }\\r\\n\\r\\n    function setLSDConfigs(address _lsd, uint256 _targetWeightBps, uint256 _maxWeightBps, uint256 _maxEthCap) public onlyOwner onlyWhenPaused {\\r\\n        require(_targetWeightBps <= _maxWeightBps, \\\"Cannot set target above max weight\\\");\\r\\n        require(_targetWeightBps <= 10000 && _maxWeightBps <= 10000, \\\"Cannot set weight above 1\\\");\\r\\n        lsdConfigs[_lsd] = LSDConfig(_targetWeightBps, _maxWeightBps, _maxEthCap);\\r\\n        emit LSDConfigSet(_lsd, lsdConfigs[_lsd]);\\r\\n    }\\r\\n\\r\\n    function enableLSD(address _lsd) public onlyOwner onlyWhenPaused {\\r\\n        require(IDarknet(darknetAddress).checkPrice(_lsd) > 0, \\\"Configure lsd in darknet before enabling\\\");\\r\\n        require(lsdConfigs[_lsd].targetWeightBps > 0 && lsdConfigs[_lsd].weightCapBps > 0 && lsdConfigs[_lsd].absoluteCapEth > 0, \\\"Set weights before enabling\\\");\\r\\n        isEnabled[_lsd] = true;\\r\\n        emit LSDEnabled(_lsd);\\r\\n    }\\r\\n\\r\\n    function enableAllLSDs() external onlyOwner onlyWhenPaused {\\r\\n        for(uint256 i=0; i<supportedLSDs.length; i=unchkIncr(i)) {\\r\\n            enableLSD(supportedLSDs[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Disabling resets configs to zero, need to set before re-enabling\\r\\n    function disableLSD(address _lsd) external onlyOwner onlyWhenPaused {\\r\\n        lsdConfigs[_lsd] = LSDConfig(0, 0, 0);\\r\\n        isEnabled[_lsd] = false;\\r\\n        emit LSDDisabled(_lsd);\\r\\n    }\\r\\n\\r\\n    function toggleWeightCaps() external onlyOwner {\\r\\n        useWeightCaps = !useWeightCaps;\\r\\n        emit WeightCapsToggled(useWeightCaps);\\r\\n    }\\r\\n\\r\\n    function toggleAbsoluteCaps() external onlyOwner {\\r\\n        useAbsoluteCaps = !useAbsoluteCaps;\\r\\n        emit AbsoluteCapsToggled(useAbsoluteCaps);\\r\\n    }\\r\\n\\r\\n    function toggleV1VaultAssetsForCaps() external onlyOwner {\\r\\n        includeV1VaultAssets = !includeV1VaultAssets;\\r\\n        emit IncludeV1VaultAssetsToggled(includeV1VaultAssets);\\r\\n    }\\r\\n\\r\\n    function unpauseDeposits() external onlyOwner onlyWhenPaused {\\r\\n        uint256 totalTargetWeightBps = 0;\\r\\n        for(uint256 i=0; i < supportedLSDs.length; i = unchkIncr(i)) {\\r\\n            uint256 targetWeightBps = lsdConfigs[supportedLSDs[i]].targetWeightBps;\\r\\n            if(targetWeightBps > 0) {\\r\\n                require(isEnabled[supportedLSDs[i]], \\\"Need to enable LSD with non-zero target weight\\\");\\r\\n            }\\r\\n            totalTargetWeightBps += targetWeightBps;\\r\\n        }\\r\\n        require(totalTargetWeightBps == 10000, \\\"Total target weight should equal 1\\\");\\r\\n        depositsPaused = false;\\r\\n        emit DepositPauseToggled(depositsPaused);\\r\\n    }\\r\\n\\r\\n    function isLsdEnabled(address lsd) public view returns(bool) {\\r\\n        return isEnabled[lsd];\\r\\n    }\\r\\n\\r\\n    function getLsdIndex(address lsd) public view returns(uint256) {\\r\\n        return lsdIndex[lsd];\\r\\n    }\\r\\n\\r\\n    //============================================================================\\r\\n    //Minting unshETH\\r\\n    //============================================================================\\r\\n\\r\\n    function deposit(address lsd, uint256 amount) external onlyZap nonReentrant {\\r\\n        _deposit(lsd, amount, true);\\r\\n    }\\r\\n\\r\\n    //Gas efficient function to mint unshETH while skipping cap checks\\r\\n    function depositNoCapCheck(address lsd, uint256 amount) external onlyZap nonReentrant {\\r\\n        _deposit(lsd, amount, false);\\r\\n    }\\r\\n\\r\\n    //takes a supported LSD and mints unshETH to the user in proportion\\r\\n    //this is an internal function, only callable by the approved ETH zap contract\\r\\n    function _deposit(address lsd, uint256 amount, bool checkAgainstCaps) private {\\r\\n        require(depositsPaused == false, \\\"Deposits are paused\\\");\\r\\n        require(migrated == false, \\\"Already migrated, deposit to new vault\\\");\\r\\n        require(isEnabled[lsd], \\\"LSD is disabled\\\");\\r\\n        if(checkAgainstCaps) {\\r\\n            uint256 balance = getCombinedVaultBalance(lsd);\\r\\n            if(useAbsoluteCaps) {\\r\\n                require(balance + amount <= getAbsoluteCap(lsd), \\\"Deposit exceeds absolute cap\\\");\\r\\n            }\\r\\n            if(useWeightCaps) {\\r\\n                require(balance + amount <= getWeightCap(lsd, amount), \\\"Deposit exceeds weight based cap\\\");\\r\\n            }\\r\\n        }\\r\\n        uint256 price = getPrice(lsd);\\r\\n        TransferHelper.safeTransferFrom(lsd, msg.sender, address(this), amount);\\r\\n        IunshETH(unshETHAddress).minter_mint(msg.sender, price*amount/1e18);\\r\\n    }\\r\\n\\r\\n    function getEthConversionRate(address lsd) public view returns(uint256) {\\r\\n        return IDarknet(darknetAddress).checkPrice(lsd);\\r\\n    }\\r\\n\\r\\n    function getPrice(address lsd) public view returns(uint256) {\\r\\n        uint256 rate = getEthConversionRate(lsd);\\r\\n        if(IERC20(unshETHAddress).totalSupply() == 0){\\r\\n            return rate;\\r\\n        }\\r\\n        else {\\r\\n            return 1e18* rate /stakedETHperunshETH();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function stakedETHperunshETH() public view returns (uint256) {\\r\\n        return 1e18*balanceInUnderlying()/IERC20(unshETHAddress).totalSupply();\\r\\n    }\\r\\n\\r\\n    function balanceInUnderlying() public view returns (uint256) {\\r\\n        uint256 underlyingBalance = 0;\\r\\n        for (uint256 i = 0; i < supportedLSDs.length; i = unchkIncr(i)) {\\r\\n            uint256 rate = getEthConversionRate(supportedLSDs[i]);\\r\\n            underlyingBalance += rate *IERC20(supportedLSDs[i]).balanceOf(address(this))/1e18;\\r\\n        }\\r\\n        return underlyingBalance;\\r\\n    }\\r\\n\\r\\n    function getAbsoluteCap(address lsd) public view returns(uint256) {\\r\\n        if(!useAbsoluteCaps) {\\r\\n            return type(uint256).max;\\r\\n        }\\r\\n        uint256 absoluteCap = 1e18*lsdConfigs[lsd].absoluteCapEth/getEthConversionRate(lsd);\\r\\n        return absoluteCap;\\r\\n    }\\r\\n\\r\\n    function getWeightCap(address lsd, uint256 marginalDeposit) public view returns(uint256) {\\r\\n        if(!useWeightCaps) {\\r\\n            return type(uint256).max;\\r\\n        }\\r\\n        uint256 weightCapBps = lsdConfigs[lsd].weightCapBps;\\r\\n        uint256 rate = getEthConversionRate(lsd);\\r\\n        uint256 marginalDepositInEth = marginalDeposit*rate/1e18;\\r\\n        uint256 v1VaultEthBalance = _getV1VaultEthBalance();\\r\\n        uint256 totalEthBalance = balanceInUnderlying() + v1VaultEthBalance + marginalDepositInEth;\\r\\n        uint256 weightCapInEth = totalEthBalance*weightCapBps/10000;\\r\\n        return 1e18*weightCapInEth/rate;\\r\\n    }\\r\\n\\r\\n    function getEffectiveCap(address lsd, uint256 marginalDeposit) public view returns(uint256) {\\r\\n        uint256 absoluteCap = getAbsoluteCap(lsd);\\r\\n        uint256 weightCap = getWeightCap(lsd, marginalDeposit);\\r\\n        if(weightCap < absoluteCap) {\\r\\n            return weightCap;\\r\\n        } else {\\r\\n            return absoluteCap;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTargetAmount(address lsd, uint256 marginalDeposit) public view returns(uint256) {\\r\\n        uint256 targetWeightBps = lsdConfigs[lsd].targetWeightBps;\\r\\n        uint256 rate = getEthConversionRate(lsd);\\r\\n        uint256 marginalDepositInEth = marginalDeposit*rate/1e18;\\r\\n        uint256 v1VaultEthBalance = _getV1VaultEthBalance();\\r\\n        uint256 totalEthBalance = balanceInUnderlying() + v1VaultEthBalance + marginalDepositInEth;\\r\\n        uint256 targetInEth = totalEthBalance* targetWeightBps /10000;\\r\\n        return 1e18*targetInEth/rate;\\r\\n    }\\r\\n\\r\\n    function _getV1VaultBalance(address lsd) internal view returns(uint256) {\\r\\n        uint256 v1VaultBalance = 0;\\r\\n        if(includeV1VaultAssets) {\\r\\n            v1VaultBalance = IERC20(lsd).balanceOf(v1VaultAddress);\\r\\n        }\\r\\n        return v1VaultBalance;\\r\\n    }\\r\\n\\r\\n    function _getV1VaultEthBalance() internal view returns(uint256) {\\r\\n        uint256 v1VaultEthBalance = 0;\\r\\n        if(includeV1VaultAssets) {\\r\\n            v1VaultEthBalance = ILSDVault(v1VaultAddress).balanceInUnderlying();\\r\\n        }\\r\\n        return v1VaultEthBalance;\\r\\n    }\\r\\n\\r\\n    function getCombinedVaultBalance(address lsd) public view returns(uint256) {\\r\\n        uint256 balance = IERC20(lsd).balanceOf(address(this));\\r\\n        return balance + _getV1VaultBalance(lsd);\\r\\n    }\\r\\n\\r\\n\\r\\n    //============================================================================\\r\\n    //Helper functions for UI / Zap / AMM\\r\\n    //============================================================================\\r\\n    function remainingRoomToCap(address lsd, uint256 marginalDeposit) public view returns(uint256) {\\r\\n        uint256 combinedBalance = getCombinedVaultBalance(lsd);\\r\\n        uint256 effectiveCap = getEffectiveCap(lsd, marginalDeposit);\\r\\n        if(combinedBalance > effectiveCap) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return (effectiveCap - combinedBalance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remainingRoomToCapInEthTerms(address lsd, uint256 marginalDepositEth) public view returns(uint256) {\\r\\n        uint256 rate = getEthConversionRate(lsd);\\r\\n        uint256 marginalDeposit = 1e18*marginalDepositEth/rate;\\r\\n        return remainingRoomToCap(lsd,marginalDeposit)*getEthConversionRate(lsd)/1e18;\\r\\n    }\\r\\n\\r\\n    function remainingRoomToTarget(address lsd, uint256 marginalDeposit) public view returns(uint256) {\\r\\n        uint256 combinedBalance = getCombinedVaultBalance(lsd);\\r\\n        uint256 target = getTargetAmount(lsd, marginalDeposit);\\r\\n        if(combinedBalance > target) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return (target - combinedBalance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remainingRoomToTargetInEthTerms(address lsd, uint256 marginalDepositEth) public view returns(uint256) {\\r\\n        uint256 rate = getEthConversionRate(lsd);\\r\\n        uint256 marginalDeposit = 1e18*marginalDepositEth/rate;\\r\\n        return remainingRoomToTarget(lsd,marginalDeposit)*rate/1e18;\\r\\n    }\\r\\n\\r\\n    //============================================================================\\r\\n    //Redeeming unshETH\\r\\n    //============================================================================\\r\\n    function setRedeemFee(uint256 _redeemFee) external onlyOwner {\\r\\n        require(_redeemFee <= maxRedeemFee, \\\"Redeem fee too high\\\");\\r\\n        redeemFee = _redeemFee;\\r\\n        emit RedeemFeeUpdated(redeemFee);\\r\\n    }\\r\\n\\r\\n    function exit(uint256 amount) external nonReentrant {\\r\\n        require(migrated == false, \\\"Already migrated, use new vault to exit\\\");\\r\\n        require(block.timestamp > shanghaiTime, \\\"Cannot exit until shanghaiTime\\\");\\r\\n        require(!withdrawalsPaused || block.timestamp > withdrawalUnpauseTime, \\\"Withdrawals are paused\\\");\\r\\n        require(IERC20(unshETHAddress).balanceOf(msg.sender) >= amount,  \\\"Insufficient unshETH\\\");\\r\\n        uint256 shareOfUnsheth = 1e18*amount/IERC20(unshETHAddress).totalSupply();\\r\\n        uint256 fee = shareOfUnsheth*redeemFee/10000; //redeem fees are 100% retained by remaining unshETH holders\\r\\n        IunshETH(unshETHAddress).minter_burn_from(msg.sender, amount);\\r\\n        for (uint256 i = 0; i < supportedLSDs.length; i = unchkIncr(i)) {\\r\\n            uint256 lsdBalance = IERC20(supportedLSDs[i]).balanceOf(address(this));\\r\\n            uint256 amountPerLsd = (shareOfUnsheth-fee)*lsdBalance/1e18;\\r\\n            IERC20(supportedLSDs[i]).safeTransfer(msg.sender, amountPerLsd);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //============================================================================\\r\\n    //Timelock functions\\r\\n    //============================================================================\\r\\n    function createTimelockProposal(TimelockFunctions _fn, address _proposedAddress) public onlyOwner {\\r\\n        require(_proposedAddress != address(0), \\\"Cannot propose zero address\\\");\\r\\n        uint256 unlockTime = block.timestamp + _TIMELOCK;\\r\\n        timelock[_fn] = TimelockProposal(_proposedAddress, unlockTime);\\r\\n        emit TimelockUpdateProposed(_fn, _proposedAddress, unlockTime);\\r\\n    }\\r\\n\\r\\n    function cancelTimelockProposal(TimelockFunctions _fn) public onlyOwner {\\r\\n        timelock[_fn] = TimelockProposal(address(0), 0);\\r\\n        emit TimelockUpdateCanceled(_fn);\\r\\n    }\\r\\n\\r\\n    function _completeTimelockProposal(TimelockFunctions _fn) internal onlyOwner {\\r\\n        timelock[_fn] = TimelockProposal(address(0), 0);\\r\\n        emit TimelockUpdateCompleted(_fn);\\r\\n    }\\r\\n\\r\\n    function updateUnshethZapAddress() external onlyOwner timelockUnlocked(TimelockFunctions.ZAP) {\\r\\n        unshethZapAddress = timelock[TimelockFunctions.ZAP].proposedAddress;\\r\\n        _completeTimelockProposal(TimelockFunctions.ZAP);\\r\\n    }\\r\\n\\r\\n    function updateDarknetAddress() external onlyOwner timelockUnlocked(TimelockFunctions.DARKNET) {\\r\\n        darknetAddress = timelock[TimelockFunctions.DARKNET].proposedAddress;\\r\\n        _completeTimelockProposal(TimelockFunctions.DARKNET);\\r\\n    }\\r\\n\\r\\n    function migrateVault() external onlyOwner postShanghai timelockUnlocked(TimelockFunctions.MIGRATE) {\\r\\n        require(IunshETH(unshETHAddress).timelock_address() == address(this), \\\"LSDVault cannot change unshETH minter\\\");\\r\\n        address proposedVaultAddress = timelock[TimelockFunctions.MIGRATE].proposedAddress;\\r\\n        for (uint256 i = 0; i < supportedLSDs.length; i = unchkIncr(i)) {\\r\\n            uint256 balance = IERC20(supportedLSDs[i]).balanceOf(address(this));\\r\\n            IERC20(supportedLSDs[i]).safeTransfer(proposedVaultAddress, balance);\\r\\n        }\\r\\n        IunshETH unshETH = IunshETH(unshETHAddress);\\r\\n        unshETH.addMinter(proposedVaultAddress);\\r\\n        unshETH.setTimelock(proposedVaultAddress);\\r\\n        unshETH.removeMinter(address(this));\\r\\n        migrated = true;\\r\\n        _completeTimelockProposal(TimelockFunctions.MIGRATE);\\r\\n    }\\r\\n\\r\\n    function setVdAmm() external onlyOwner postShanghai timelockUnlocked(TimelockFunctions.AMM) {\\r\\n        //revoke approvals to current swapper\\r\\n        if(swapperAddress != address(0)) {\\r\\n            _setApprovals(swapperAddress, 0);\\r\\n        }\\r\\n        //give max approvals to proposed swapper\\r\\n        address proposedSwapper = timelock[TimelockFunctions.AMM].proposedAddress;\\r\\n        _setApprovals(proposedSwapper, type(uint256).max);\\r\\n        swapperAddress = proposedSwapper;\\r\\n        ammEnabled = true;\\r\\n        _completeTimelockProposal(TimelockFunctions.AMM);\\r\\n    }\\r\\n\\r\\n    function _setApprovals(address spender, uint256 limit) internal {\\r\\n        for (uint256 i = 0; i < supportedLSDs.length; i = unchkIncr(i)) {\\r\\n            TransferHelper.safeApprove(supportedLSDs[i], spender, limit);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //============================================================================\\r\\n    //Admin and emergency functions\\r\\n    //============================================================================\\r\\n    function updateShanghaiTime(uint256 _newTime) external onlyOwnerOrAdmin {\\r\\n        require(_newTime < shanghaiTime + 4 weeks, \\\"Cannot extend more than 4 weeks\\\" );\\r\\n        require(_newTime > block.timestamp, \\\"Cannot set shanghaiTime in the past\\\" );\\r\\n        shanghaiTime = _newTime;\\r\\n        emit ShanghaiTimeUpdated(shanghaiTime);\\r\\n    }\\r\\n\\r\\n    function pauseDeposits() external onlyOwnerOrAdmin {\\r\\n        require(depositsPaused == false, \\\"Already paused\\\" );\\r\\n        depositsPaused = true;\\r\\n        emit DepositPauseToggled(depositsPaused);\\r\\n    }\\r\\n\\r\\n    function pauseWithdrawals(uint256 _unpauseTime) external onlyOwnerOrAdmin {\\r\\n        //Max admin withdrawal pause is 1 day less than timelock (2 days), can't unpause again for 1 day after prev pause ends\\r\\n        require(_unpauseTime <= block.timestamp + _TIMELOCK - 1 days, \\\"Cannot pause withdrawals too long\\\");\\r\\n        require(block.timestamp >= withdrawalUnpauseTime + 1 days, \\\"Need 1 day cooldown before pausing again\\\");\\r\\n        withdrawalUnpauseTime = _unpauseTime;\\r\\n        withdrawalsPaused = true;\\r\\n        emit WithdrawalsPaused(withdrawalUnpauseTime);\\r\\n    }\\r\\n\\r\\n    function unpauseWithdrawals() external onlyOwnerOrAdmin {\\r\\n        withdrawalsPaused = false;\\r\\n        emit WithdrawalsUnpaused();\\r\\n    }\\r\\n\\r\\n    function disableVdAmm() external onlyOwnerOrAdmin {\\r\\n        require(swapperAddress != address(0), \\\"Vdamm is not set\\\");\\r\\n        _setApprovals(swapperAddress, 0);\\r\\n        emit VdAmmDisabled(swapperAddress);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"src/RenouncedOwner.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.18;\\r\\n\\r\\ninterface IOwned {\\r\\n    function acceptOwnership() external;\\r\\n    function owner() external view returns (address);\\r\\n}\\r\\n\\r\\ncontract RenouncedOwner {\\r\\n    event OwnershipRenounced(address ownedContract);\\r\\n    function acceptAndRenounce(address _contract) external {\\r\\n        IOwned(_contract).acceptOwnership();\\r\\n        require(IOwned(_contract).owner() == address(this), \\\"Ownership not renounced\\\");\\r\\n        emit OwnershipRenounced(_contract);\\r\\n    }    \\r\\n}\\r\\n\"\r\n    },\r\n    \"src/sgReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"layerzerolabs/contracts/interfaces/IStargateReceiver.sol\\\";\\r\\nimport \\\"layerzerolabs/contracts/token/oft/IOFTCore.sol\\\";\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"communal/TransferHelper.sol\\\";\\r\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\r\\n\\r\\n\\r\\ninterface IunshethZap {\\r\\n    function mint_unsheth_with_eth(uint256 amountOutMin, uint256 pathId) external payable;\\r\\n}\\r\\n\\r\\ninterface IStargateRouter {\\r\\n    function clearCachedSwap(uint16 _srcChainId, bytes calldata _srcAddress, uint256 nonce) external;\\r\\n    function cachedSwapLookup(uint16 _srcChainId, bytes calldata _srcAddress, uint256 nonce) external view returns (address token, uint256 amountLD, address to, bytes memory payload);\\r\\n}\\r\\n\\r\\ncontract SGReceiver is IStargateReceiver, Ownable {\\r\\n\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    //Constants\\r\\n    address public constant unshethAddress = 0x0Ae38f7E10A43B5b2fB064B42a2f4514cbA909ef; //https://docs.unsheth.xyz/contract-addresses\\r\\n    address public constant proxyUnshethAddress = 0x35f899CE6cC304AeDFDB7835f623A30473b26457; //https://docs.unsheth.xyz/contract-addresses\\r\\n    address public constant stargateRouterAddress = 0x8731d54E9D02c286767d56ac03e8037C07e01e98; //https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet //TODO: Router.sol or RouterETH.sol?\\r\\n    address public constant sgethAddress = 0x72E2F4830b9E45d52F80aC08CB2bEC0FeF72eD9c; //https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\\r\\n\\r\\n    //Mutable variables\\r\\n    address public unshethZapAddress = 0xc258fF338322b6852C281936D4EdEff8AdfF23eE; //https://docs.unsheth.xyz/contract-addresses, can be updated by owner\\r\\n    address public zroAddress = address(0);\\r\\n\\r\\n    mapping(uint256 => mapping(uint256 => bool)) public nonceHandled;\\r\\n    mapping(uint16 => bool) public ethChainIds;\\r\\n\\r\\n    //adapter params\\r\\n    uint16 public adapter_version = 2;\\r\\n    uint public adapter_gasLimit = 200000;\\r\\n    uint public adapter_airdrop = 0;\\r\\n    uint256 public unsheth_gas_cost = 0.01 ether;\\r\\n\\r\\n\\r\\n    event SupportedChainIdUpdated(uint16 chainId, bool value);\\r\\n    event UnshethZapAddressUpdated(address unshethZapAddress);\\r\\n    event ZroAddressUpdated(address zroAddress);\\r\\n    event AdapterParamsUpdated(uint256 version, uint256 gasLimit, uint256 airdrop);\\r\\n    event UnshethGasCostUpdated(uint256 amount);\\r\\n    event EthRescued(uint256 amount);\\r\\n    event Erc20Rescued(address token, uint256 amount);\\r\\n    event CrossChainMint(uint256 chainId, address userAddress, uint256 ethAmount, uint256 unshethMinted);\\r\\n\\r\\n    constructor(\\r\\n        address _owner  //desired owner (e.g. multisig)\\r\\n    ) {\\r\\n        //set the chain ids that support ETH\\r\\n        ethChainIds[110] = true; //https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids //Arbitrum\\r\\n        //allow the unsheth proxy to spend my unsheth\\r\\n        TransferHelper.safeApprove(unshethAddress, proxyUnshethAddress, type(uint256).max);\\r\\n        //transfer ownership to the desired owner\\r\\n        transferOwnership(_owner);\\r\\n    }\\r\\n\\r\\n    //owner function to update ethChainIds with a chainId and a boolean\\r\\n    function update_ethChainIds(uint16 _chainId, bool _value) public onlyOwner {\\r\\n        ethChainIds[_chainId] = _value;\\r\\n        emit SupportedChainIdUpdated(_chainId, _value);\\r\\n    }\\r\\n\\r\\n    function updateAdapterParams(uint16 _version, uint256 _gasLimit, uint256 _airdrop) public onlyOwner {\\r\\n        adapter_version = _version;\\r\\n        adapter_gasLimit = _gasLimit;\\r\\n        adapter_airdrop = _airdrop;\\r\\n        emit AdapterParamsUpdated(_version, _gasLimit, _airdrop);\\r\\n    }\\r\\n\\r\\n    //owner function to set the zroAddress\\r\\n    function updateZroAddress(address _zroAddress) public onlyOwner {\\r\\n        zroAddress = _zroAddress;\\r\\n        emit ZroAddressUpdated(_zroAddress);\\r\\n    }\\r\\n\\r\\n    //owner function to set the amount of eth to spend per unsheth transfer\\r\\n    function set_unsheth_gas_cost(uint256 amount) public onlyOwner {\\r\\n        unsheth_gas_cost = amount;\\r\\n        emit UnshethGasCostUpdated(amount);\\r\\n    }\\r\\n\\r\\n    //sgReceive will receive ETH and then mint unshETH and send the unshETH back to the original sender\\r\\n    function sgReceive(uint16 _chainId, bytes memory /*_srcAddress*/, uint /*_nonce*/, address _token, uint amountLD, bytes memory _payload) override external {\\r\\n        require(msg.sender == address(stargateRouterAddress), \\\"only stargate router can call sgReceive!\\\");\\r\\n        require(ethChainIds[_chainId], \\\"chainId not supported\\\");\\r\\n        require(_token == sgethAddress, \\\"only sgeth is supported\\\");\\r\\n        require(unsheth_gas_cost <= address(this).balance, 'unsheth_gas_cost must be less than the eth balance in this contract');\\r\\n        require(amountLD <= address(this).balance, \\\"Contract eth balance is less than amountLD\\\");\\r\\n\\r\\n        //Extract the mint information\\r\\n        (address userAddress, uint256 min_amount_unshethZap, uint256 unsheth_path) = abi.decode(_payload, (address, uint256, uint256));\\r\\n\\r\\n        uint256 unshethMinted = _mint_unsheth_with_eth(amountLD, min_amount_unshethZap, unsheth_path);\\r\\n        _bridge_unsheth(_chainId, unshethMinted, unsheth_gas_cost, userAddress);\\r\\n        emit CrossChainMint(_chainId, userAddress, amountLD, unshethMinted);\\r\\n    }\\r\\n\\r\\n    function _mint_unsheth_with_eth(uint256 _ethAmount, uint256 _minAmountOut, uint256 _pathId) internal returns (uint256 unshethMinted){\\r\\n        //get balance of unshETH before minting\\r\\n        uint256 unshethBalBefore = IERC20(unshethAddress).balanceOf(address(this));\\r\\n        //Mint unshETH to this contract address\\r\\n        IunshethZap(unshethZapAddress).mint_unsheth_with_eth{value:_ethAmount}(_minAmountOut, _pathId);\\r\\n        //get the new balance of unshETH\\r\\n        uint256 unshethBal = IERC20(unshethAddress).balanceOf(address(this));\\r\\n        //return unshethMinted = the difference in balances\\r\\n        return (unshethBal - unshethBalBefore);\\r\\n    }\\r\\n\\r\\n    function _bridge_unsheth(uint16 srcChainId, uint256 _unshethAmount, uint256 _unsheth_gas_cost, address _userAddress) internal {\\r\\n        IOFTCore(proxyUnshethAddress).sendFrom{value:_unsheth_gas_cost}(\\r\\n            address(this), //current owner of the unsheth\\r\\n            srcChainId, //chain Id where the proxy of the unsheth exists\\r\\n            abi.encodePacked(_userAddress), //the address we want the unsheth to end up in\\r\\n            _unshethAmount, //the amount of unsheth to send\\r\\n            payable(address(this)), //the refund address if something goes wrong or excess\\r\\n            zroAddress, //the ZRO Payment Address\\r\\n            //Adapter params\\r\\n            abi.encodePacked( \\r\\n                adapter_version,\\r\\n                adapter_gasLimit,\\r\\n                adapter_airdrop,\\r\\n                _userAddress\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //function for user to rescue the eth bridged over in case initial bridge txn fails\\r\\n    function rescue_eth(uint16 srcChainId, bytes memory srcAddress, uint256 nonce) external {\\r\\n        require(ethChainIds[srcChainId], \\\"Only ETH sent from supported chains can be rescued\\\");\\r\\n        //Ensure this nonce hasn't already been handled\\r\\n        require(nonceHandled[srcChainId][nonce] == false, \\\"Nonce has already been handled\\\");\\r\\n        (address _token, uint256 amountLD, address to, bytes memory _payload) = IStargateRouter(stargateRouterAddress).cachedSwapLookup(srcChainId, srcAddress, nonce);\\r\\n        (address userAddress, , ) = abi.decode(_payload, (address, uint256, uint256));\\r\\n        //Check parameters are reasonable\\r\\n        require(to == address(this), \\\"to is not sgreceiver contract address\\\");\\r\\n        require(_token == sgethAddress, \\\"only SGETH can be sent to this contract!\\\");\\r\\n        require(msg.sender == userAddress || msg.sender == owner(), \\\"only owner or user can rescue their eth\\\");\\r\\n        require(amountLD > 0, \\\"No tokens to rescue\\\");\\r\\n        require(amountLD <= address(this).balance, \\\"Amount to rescue exceeds contract balance\\\");\\r\\n        Address.sendValue(payable(userAddress), amountLD);\\r\\n        nonceHandled[srcChainId][nonce] = true;\\r\\n    }\\r\\n\\r\\n    //owner function to clear the cache with same params as before in case initial bridge txn fails. Gas is paid by team\\r\\n    function retry_mint_clearCachedSwap(uint16 srcChainId, bytes memory srcAddress, uint256 nonce) external onlyOwner {\\r\\n        IStargateRouter(stargateRouterAddress).clearCachedSwap(srcChainId, srcAddress, nonce);\\r\\n        nonceHandled[srcChainId][nonce] = true;\\r\\n    }\\r\\n\\r\\n    //function for user to retry minting unsheth with ETH with new params in case initial bridge txn fails\\r\\n    //front-end should suggest min_amount_unshethZap and unsheth_path based on optimal path to mint unsheth with eth\\r\\n    //front-end should also suggest msg.value which corresponds to gas cost of bridging unsheth\\r\\n    function retry_mint_newParams(uint16 srcChainId, bytes memory srcAddress, uint256 nonce, uint256 min_amount_unshethZap, uint256 unsheth_path) external payable {\\r\\n        require(ethChainIds[srcChainId], \\\"chainId not supported\\\");\\r\\n        require(nonceHandled[srcChainId][nonce] == false, \\\"Nonce has already been handled\\\");\\r\\n        //Extract the stargate cachedswap information with the given nonce\\r\\n        (address _token, uint256 amountLD, address to, bytes memory _payload) = IStargateRouter(stargateRouterAddress).cachedSwapLookup(srcChainId, srcAddress, nonce);\\r\\n        (address userAddress, , ) = abi.decode(_payload, (address, uint256, uint256));\\r\\n        //Check parameters are reasonable\\r\\n        require(to == address(this), \\\"to is not sgreceiver contract address\\\");\\r\\n        require(_token == sgethAddress, \\\"only sgETH can be sent to this contract!\\\");\\r\\n        require(msg.sender == userAddress, \\\"only user can retry mint\\\");\\r\\n        require(amountLD > 0, \\\"No tokens to retry with\\\");\\r\\n        require(amountLD <= address(this).balance, \\\"Amount to retry with exceeds contract balance\\\");\\r\\n\\r\\n        uint256 unshethMinted = _mint_unsheth_with_eth(amountLD, min_amount_unshethZap, unsheth_path);\\r\\n        _bridge_unsheth(srcChainId, unshethMinted, msg.value, userAddress);\\r\\n        nonceHandled[srcChainId][nonce] = true;\\r\\n    }\\r\\n\\r\\n    function updateUnshethZapAddress(address _unshethZapAddress) external onlyOwner {\\r\\n        require(_unshethZapAddress != address(0), \\\"Invalid address\\\");\\r\\n        unshethZapAddress = _unshethZapAddress;\\r\\n        emit UnshethZapAddressUpdated(_unshethZapAddress);\\r\\n    }\\r\\n\\r\\n    //owner function that sends the remaining eth back to the owner\\r\\n    function rescue_eth_owner() external onlyOwner{\\r\\n        uint256 ethBal = address(this).balance;\\r\\n        Address.sendValue(payable(owner()), ethBal);\\r\\n        emit EthRescued(ethBal);\\r\\n    }\\r\\n\\r\\n    //owner function that sends remaining erc20 back to the owner\\r\\n    function rescue_erc20_owner(address _token) external onlyOwner{\\r\\n        uint256 tokenBal = IERC20(_token).balanceOf(address(this));\\r\\n        IERC20(_token).transfer(owner(), tokenBal);\\r\\n        emit Erc20Rescued(_token, tokenBal);\\r\\n    }\\r\\n\\r\\n    //Allow receiving eth to the contract\\r\\n    receive() external payable {}\\r\\n}\"\r\n    },\r\n    \"src/sgSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"layerzerolabs/contracts/token/oft/OFT.sol\\\";\\r\\nimport \\\"layerzerolabs/contracts/interfaces/IStargateRouter.sol\\\";\\r\\nimport \\\"communal/Owned.sol\\\";\\r\\nimport \\\"communal/TransferHelper.sol\\\";\\r\\n\\r\\n// PancakeSwap Router interface for token swaps\\r\\ninterface IUniswapV2Router02 {\\r\\n    function WETH() external pure returns (address);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts);\\r\\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\\r\\n}\\r\\n\\r\\ncontract BNBUnshethMinter is Owned {\\r\\n\\r\\n    address public immutable usdtAddress;                    // address of the binanced pegged usdt\\r\\n    address public immutable stargateRouterAddress;          // address of the stargate router\\r\\n    address public immutable ethAddress;                    // address for the binance pegged eth token\\r\\n    address public immutable pancakeSwapRouterAddress;       // address for the pancake swap router\\r\\n    uint16 public immutable dstChainId;                      // Stargate/LayerZero chainId\\r\\n    uint16 public immutable srcPoolId;                       // stargate poolId - *must* be the poolId for the qty asset\\r\\n    uint16 public immutable dstPoolId;                       // stargate destination poolId\\r\\n    address public sgReceiverAddress;                         // destination contract. it must implement sgReceive()\\r\\n    bool paused = false;\\r\\n    IUniswapV2Router02 public pancakeSwapRouter;\\r\\n\\r\\n    // Constructor sets up contract dependencies and initializes parent contract OFT\\r\\n    constructor(\\r\\n        address _owner, //address of the user deploying this contract\\r\\n        address _ethAddress, //address of ETH on BNB - 0x2170ed0880ac9a755fd29b2688956bd959f933f8\\r\\n        address _pancakeSwapRouterAddress, //0x10ED43C718714eb63d5aA57B78B54704E256024E as per https://docs.pancakeswap.finance/code/smart-contracts/pancakeswap-exchange/v2/router-v2\\r\\n        address _usdtAddress, //address of USDT on BNB - 0x55d398326f99059ff775485246999027b3197955\\r\\n        address _stargateRouterAddress, //address of the stargate router on BNB - 0x4a364f8c717cAAD9A442737Eb7b8A55cc6cf18D8 as per https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\\r\\n        uint16 _srcPoolId, // 2 as per https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\\r\\n        uint16 _dstPoolId, // 2 as per https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\\r\\n        address _sgReceiver, //address of the sgReceiver deployed on ETH\\r\\n        uint16 _dstChainId //101 - as per https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\\r\\n    ) Owned(_owner){\\r\\n        ethAddress = _ethAddress;\\r\\n        usdtAddress = _usdtAddress;\\r\\n\\r\\n        stargateRouterAddress = _stargateRouterAddress;\\r\\n\\r\\n        pancakeSwapRouterAddress = _pancakeSwapRouterAddress;\\r\\n        pancakeSwapRouter = IUniswapV2Router02(pancakeSwapRouterAddress);\\r\\n\\r\\n        srcPoolId = _srcPoolId;\\r\\n        dstPoolId = _dstPoolId;\\r\\n        sgReceiverAddress = _sgReceiver;\\r\\n        dstChainId = _dstChainId;\\r\\n\\r\\n        // Approve token allowances for router contracts\\r\\n        TransferHelper.safeApprove(usdtAddress, stargateRouterAddress, type(uint256).max);\\r\\n        TransferHelper.safeApprove(ethAddress, pancakeSwapRouterAddress, type(uint256).max);\\r\\n    }\\r\\n\\r\\n    modifier onlyWhenUnpaused {\\r\\n        require(paused == false, \\\"Contract is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // owner function that sets the pause parameter\\r\\n    function setPaused(bool _paused) public onlyOwner {\\r\\n        paused = _paused;\\r\\n    }\\r\\n\\r\\n    function _getDeadline() internal view returns(uint256) {\\r\\n        return block.timestamp + 300; //5 minutes\\r\\n    }\\r\\n\\r\\n    function changeSgReceiver(address _sgReceiver) public onlyOwner {\\r\\n        require(_sgReceiver!= address(0), \\\"sgReceiver cannot be zero address\\\");\\r\\n        sgReceiverAddress = _sgReceiver;\\r\\n    }\\r\\n\\r\\n    // mint_unsheth function that sends USDT to unshETH proxy contract to mint unshETH tokens\\r\\n    function mint_unsheth_with_usdt(\\r\\n        uint256 amount,                            // the amount of USDT\\r\\n        uint256 min_amount_stargate,               // the minimum amount of USDT to receive on stargate,\\r\\n        uint256 min_amount_unshethZap,          // the minimum amount of ETH to receive from the unshethZap\\r\\n        uint256 dstGasForCall,                  // the amount of gas to send to the sgReceive contract\\r\\n        uint256 dstNativeAmount,                // leftover eth that will get airdropped to the sgReceive contract\\r\\n        uint256 unsheth_path                    // the path that the unsheth Zap will take to mint unshETH\\r\\n    ) external payable onlyWhenUnpaused {\\r\\n        // Transfer USDT from sender to the contract\\r\\n        TransferHelper.safeTransferFrom(usdtAddress, msg.sender, address(this), amount);\\r\\n        // Mint unsheth with USDT\\r\\n        _mint_unsheth_with_usdt(amount, min_amount_stargate, min_amount_unshethZap, dstGasForCall, dstNativeAmount, unsheth_path, msg.value);\\r\\n    }\\r\\n\\r\\n    // mint_unsheth function converts ETH to USDT and sends USDT to unshETH proxy contract to mint unshETH tokens\\r\\n    function mint_unsheth_with_bnb(\\r\\n        uint256 amount,                            // the amount of BNB to convert to USDT\\r\\n        uint256 min_amount_pancake,                // the minimum amount of USDT to receive from pancake swap\\r\\n        uint256 min_amount_stargate,               // the minimum amount of USDT to receive on stargate,\\r\\n        uint256 min_amount_unshethZap,          // the minimum amount of ETH to receive from the unshethZap\\r\\n        uint256 dstGasForCall,                  // the amount of gas to send to the sgReceive contract\\r\\n        uint256 dstNativeAmount,                 // leftover eth that will get airdropped to the sgReceive contract\\r\\n        uint256 unsheth_path                    // the path that the unsheth Zap will take to mint unshETH\\r\\n    ) external payable onlyWhenUnpaused {\\r\\n        require(msg.value > amount, \\\"BNB amount must be greater than amount being used to buy usdt\\\");\\r\\n        // Calculate the stargate fee\\r\\n        uint256 stargateFee = msg.value - amount;\\r\\n        // Create a path: BNB -> USDT\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = pancakeSwapRouter.WETH();\\r\\n        path[1] = usdtAddress;\\r\\n        // Swap BNB for USDT\\r\\n        uint256[] memory amountsOut = pancakeSwapRouter.swapExactETHForTokens{value: amount}(\\r\\n            min_amount_pancake, path, address(this), _getDeadline()\\r\\n        );\\r\\n        uint256 usdtBalance = amountsOut[1];\\r\\n        // Mint unsheth with USDT\\r\\n        _mint_unsheth_with_usdt(usdtBalance, min_amount_stargate, min_amount_unshethZap, dstGasForCall, dstNativeAmount, unsheth_path, stargateFee);\\r\\n    }\\r\\n\\r\\n    // mint_unsheth function converts ETH to USDT and sends USDT to unshETH proxy contract to mint unshETH tokens\\r\\n    function mint_unsheth_with_eth(\\r\\n        uint256 amount,                            // the amount of ETH to convert to USDT\\r\\n        uint256 min_amount_pancake,                // the minimum amount of USDT to receive from pancake swap\\r\\n        uint256 min_amount_stargate,               // the minimum amount of USDT to receive on stargate,\\r\\n        uint256 min_amount_unshethZap,          // the minimum amount of ETH to receive from the unshethZap\\r\\n        uint256 dstGasForCall,                  // the amount of gas to send to the sgReceive contract\\r\\n        uint256 dstNativeAmount,                // leftover eth that will get airdropped to the sgReceive contract\\r\\n        uint256 unsheth_path                    // the path that the unsheth Zap will take to mint unshETH\\r\\n    ) external payable onlyWhenUnpaused {\\r\\n        // require(unsheth_path <=5, 'there are only 6 unsheth paths');\\r\\n        // Transfer ETH from sender to the contract\\r\\n        TransferHelper.safeTransferFrom(ethAddress, msg.sender, address(this), amount);\\r\\n        // Create a path: ETH -> USDT\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = ethAddress;\\r\\n        path[1] = usdtAddress;\\r\\n        //swap the eth for usdt\\r\\n        uint256[] memory amounts = pancakeSwapRouter.swapExactTokensForTokens(\\r\\n            amount, min_amount_pancake, path, address(this), _getDeadline()\\r\\n        );\\r\\n        uint256 usdtBalance = amounts[1];\\r\\n        // Mint unsheth with USDT\\r\\n        _mint_unsheth_with_usdt(usdtBalance, min_amount_stargate, min_amount_unshethZap, dstGasForCall, dstNativeAmount, unsheth_path, msg.value);\\r\\n    }\\r\\n\\r\\n    function _mint_unsheth_with_usdt(\\r\\n        uint256 amount,\\r\\n        uint256 min_amount_stargate,\\r\\n        uint256 min_amount_unshethZap,\\r\\n        uint256 dstGasForCall,\\r\\n        uint256 dstNativeAmount,\\r\\n        uint256 unsheth_path,\\r\\n        uint256 bnbAmount\\r\\n    ) internal {\\r\\n        require(amount <= IERC20(usdtAddress).balanceOf(address(this)), \\\"Not enough USDT in contract\\\");\\r\\n        // Encode payload data to send to destination contract, which it will handle with sgReceive()\\r\\n        bytes memory data = abi.encode(msg.sender, min_amount_unshethZap, unsheth_path);\\r\\n        // Send the USDT via the stargate router\\r\\n        IStargateRouter(stargateRouterAddress).swap{value:bnbAmount}( //call estimateGasFees to get the msg.value\\r\\n            dstChainId,                                               // the destination chain id - ETH\\r\\n            srcPoolId,                                                // the source Stargate poolId\\r\\n            dstPoolId,                                                // the destination Stargate poolId\\r\\n            payable(msg.sender),                                      // refund address. if msg.sender pays too much gas, return extra BNB\\r\\n            amount,                                                   // total tokens to send to destination chain\\r\\n            min_amount_stargate,                                      // min amount allowed out\\r\\n            IStargateRouter.lzTxObj(dstGasForCall, dstNativeAmount, abi.encodePacked(sgReceiverAddress)), // default lzTxObj\\r\\n            abi.encodePacked(sgReceiverAddress),                   // destination address, the sgReceive() implementer\\r\\n            data                                                      // bytes payload which sgReceive() will parse into an address that the unshETH will be sent too.\\r\\n        );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/unshETH-OFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"layerzerolabs/contracts/token/oft/OFT.sol\\\";\\r\\n\\r\\ncontract unshETHOFT is OFT {\\r\\n    constructor(address _lzEndpoint) OFT(\\\"unshETH Ether\\\", \\\"unshETH\\\", _lzEndpoint) {}\\r\\n}\"\r\n    },\r\n    \"src/unshETH-Proxy-ETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"layerzerolabs/contracts/token/oft/extension/ProxyOFT.sol\\\";\\r\\n\\r\\ncontract unshETHProxyOft is ProxyOFT {\\r\\n    constructor(\\r\\n        address _lzEndpoint, //0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675 as per https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\\r\\n        address _token // address of the unshETH token\\r\\n    ) ProxyOFT(_lzEndpoint, _token) {\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/unshETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { ERC20PermitPermissionedMint } from \\\"local/ERC20/ERC20PermitPermissionedMint.sol\\\";\\r\\n\\r\\ncontract unshETH is ERC20PermitPermissionedMint {\\r\\n\\r\\n    address public LSDRegistryAddress;\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n    constructor(\\r\\n      address _creator_address,\\r\\n      address _timelock_address\\r\\n    ) \\r\\n    ERC20PermitPermissionedMint(_creator_address, _timelock_address, \\\"unshETH Ether\\\", \\\"unshETH\\\") \\r\\n    {}\\r\\n}\"\r\n    },\r\n    \"src/unshETHRateProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IRateProvider {\\r\\n    function getRate() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface ILSDVault {\\r\\n    function stakedETHperunshETH() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IunshETH {\\r\\n    function timelock_address() external view returns (address);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title unshETH Rate Provider\\r\\n * @notice Returns the value of unshETH in terms of ETH\\r\\n */\\r\\ncontract unshETHRateProvider is IRateProvider {\\r\\n\\r\\n    address public constant unshethAddress = 0x0Ae38f7E10A43B5b2fB064B42a2f4514cbA909ef;\\r\\n\\r\\n    constructor() { }\\r\\n\\r\\n    /**\\r\\n     * @return the value of unshETH in terms of stETH\\r\\n     */\\r\\n    function getRate() external view override returns (uint256) {\\r\\n        address vaultAddress = IunshETH(unshethAddress).timelock_address();\\r\\n        ILSDVault vault = ILSDVault(vaultAddress);\\r\\n        return vault.stakedETHperunshETH();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/unshETHZap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.11;\\r\\n\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"local/interfaces/ISwapRouter.sol\\\";\\r\\nimport \\\"communal/TransferHelper.sol\\\";\\r\\n\\r\\n\\r\\ninterface ILSDVaultV2 {\\r\\n    function deposit(address lsd, uint256 amount) external;\\r\\n    function depositNoCapCheck(address lsd, uint256 amount) external;\\r\\n    function swapperAddress() external returns(address);\\r\\n}\\r\\n\\r\\ninterface IunshETH {\\r\\n    function timelock_address() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IVdAmm {\\r\\n    function getDepositFee(uint256 lsdAmountIn, address lsd) external returns(uint256, uint256);\\r\\n}\\r\\n\\r\\ninterface FRXETH {\\r\\n    function submitAndDeposit(address recipient) payable external;\\r\\n}\\r\\n\\r\\ninterface SFRXETH {\\r\\n    function deposit(uint256 assets, address receiver) external;\\r\\n}\\r\\n\\r\\ninterface RETH {\\r\\n    function swapTo(uint256 _uniswapPortion, uint256 _balancerPortion, uint256 _minTokensOut, uint256 _idealTokensOut) payable external;\\r\\n}\\r\\n\\r\\ninterface IANKRDeposits {\\r\\n    function stakeAndClaimAethC() payable external;\\r\\n}\\r\\n\\r\\ninterface ISWETH {\\r\\n    function deposit() payable external;\\r\\n}\\r\\n\\r\\ninterface IRocketDepositPool {\\r\\n    function deposit() external payable;\\r\\n}\\r\\n\\r\\ninterface IRocketSettings {\\r\\n    function getDepositEnabled() external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface IWETH is IERC20{\\r\\n    function deposit() payable external;\\r\\n    function withdraw(uint wad) external;\\r\\n}\\r\\n\\r\\ninterface IWStETH is IERC20{\\r\\n    function wrap(uint256 _stETHAmount) external;\\r\\n}\\r\\n\\r\\ncontract unshETHZapv2 is ReentrancyGuard  {\\r\\n    using SafeERC20 for IERC20;\\r\\n    uint256 public constant MAX_PATH_ID = 10;\\r\\n\\r\\n    address public constant wstETHAddress = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\r\\n    address public constant frxETHMinterAddress = 0xbAFA44EFE7901E04E39Dad13167D089C559c1138;\\r\\n    address public constant frxETHAddress = 0x5E8422345238F34275888049021821E8E08CAa1f;\\r\\n    address public constant sfrxETHAddress = 0xac3E018457B222d93114458476f3E3416Abbe38F;\\r\\n    address public constant rETHAddress = 0xae78736Cd615f374D3085123A210448E74Fc6393;\\r\\n    address public constant cbETHAddress = 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704;\\r\\n    address public constant usdtAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\r\\n    address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    address public constant stEthAddress = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\r\\n\\r\\n    address public constant ankrETHAddress = 0xE95A203B1a91a908F9B9CE46459d101078c2c3cb;\\r\\n    address public constant ankrDepositsAddress = 0x84db6eE82b7Cf3b47E8F19270abdE5718B936670;\\r\\n    address public constant swETHAddress = 0xf951E335afb289353dc249e82926178EaC7DEd78;\\r\\n\\r\\n    address public constant rocketDepositPoolAddress = 0xDD3f50F8A6CafbE9b31a427582963f465E745AF8;\\r\\n    address public constant rocketSettingsAddress = 0x781693a15E1fA7c743A299f4F0242cdF5489A0D9;\\r\\n\\r\\n    address public immutable lsdVaultAddressV2; // 0x00..;\\r\\n    address public immutable unshETHAddressV2; //0x00...;\\r\\n\\r\\n    ISwapRouter public uniswapRouterV3 = ISwapRouter(address(0xE592427A0AEce92De3Edee1F18E0157C05861564));\\r\\n    uint24 public constant POOLFEE = 500; // pool fee to use uniswapv3. for now its set to 0.05% as default\\r\\n\\r\\n    address public vdAmmAddress;\\r\\n\\r\\n    mapping (uint256 => address) public swapPathIdToAddress;\\r\\n\\r\\n    event DepositLsd(address indexed sender, address lsdAddress, uint256 depositAmount, uint256 depositFee, uint256 protocolFee, uint256 unshETHMinted);\\r\\n    event DepositEth(address indexed sender, uint256 ethAmount, uint256 pathId);\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Constructor\\r\\n    ============================================================================\\r\\n    */\\r\\n    constructor(address _unshETHAddressV2) {\\r\\n\\r\\n        unshETHAddressV2 = _unshETHAddressV2;\\r\\n\\r\\n        lsdVaultAddressV2 = IunshETH(unshETHAddressV2).timelock_address();\\r\\n        vdAmmAddress = ILSDVaultV2(lsdVaultAddressV2).swapperAddress();\\r\\n\\r\\n        //give infinite approval for the lsd vault to spend the wstETH, sfrxETH, rETH, and cbETH\\r\\n        TransferHelper.safeApprove(wstETHAddress, lsdVaultAddressV2, type(uint256).max);\\r\\n        TransferHelper.safeApprove(sfrxETHAddress, lsdVaultAddressV2, type(uint256).max);\\r\\n        TransferHelper.safeApprove(rETHAddress, lsdVaultAddressV2, type(uint256).max);\\r\\n        TransferHelper.safeApprove(cbETHAddress, lsdVaultAddressV2, type(uint256).max);\\r\\n        TransferHelper.safeApprove(wethAddress, lsdVaultAddressV2, type(uint256).max);\\r\\n\\r\\n        //give infinite approval for the lsd vault to spend the ankrETH and swETH\\r\\n        TransferHelper.safeApprove(ankrETHAddress, lsdVaultAddressV2, type(uint256).max);\\r\\n        TransferHelper.safeApprove(swETHAddress, lsdVaultAddressV2, type(uint256).max);\\r\\n\\r\\n        //approve weth and uniswap to facilitate swapping into lsds\\r\\n        TransferHelper.safeApprove(wethAddress, address(uniswapRouterV3), type(uint256).max);\\r\\n\\r\\n        //approvals to facilitate wrapping of frxETH and stETH\\r\\n        TransferHelper.safeApprove(frxETHAddress, sfrxETHAddress, type(uint256).max);\\r\\n        TransferHelper.safeApprove(wstETHAddress, stEthAddress, type(uint256).max);\\r\\n\\r\\n        //set up swap path ids\\r\\n        // pathIdToAddress[0] = wstETHAddress; // 0 -> mint wstETH\\r\\n        // pathIdToAddress[1] = sfrxETHAddress; // 1 -> mint sfrxETH\\r\\n        swapPathIdToAddress[2] = cbETHAddress; // 2 -> swap for cbETH\\r\\n        swapPathIdToAddress[3] = rETHAddress; // 3 -> swap for rETH\\r\\n        swapPathIdToAddress[4] = wstETHAddress;  // 4 -> swap for wstETH\\r\\n        swapPathIdToAddress[5] = frxETHAddress; // 5 -> swap for frxETH (sfrxETH not liquid)\\r\\n        // pathIdToAddress[6] = rETHAddress; // 6 -> mint rETH\\r\\n        // pathIdToAddress[7] = wethAddress; // 7 -> mint wETH\\r\\n        // pathIdToAddress[8] = ankrETHAddress; // 8 -> mint ankrETH\\r\\n        // pathIdToAddress[9] = swETHAddress; // 9 -> mint swETH\\r\\n        swapPathIdToAddress[10] = swETHAddress; // 10 -> swap for swETH.. //no swap path for ankrETH as limited liquidity on uniswap\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    ETH -> LSD deposit functions\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function _mint_sfrxETH(uint256 ethAmount) internal {\\r\\n        // Mint sfrxETH\\r\\n        FRXETH(frxETHMinterAddress).submitAndDeposit{value:ethAmount}(address(this));\\r\\n        // Get balance of sfrxETH minted\\r\\n        uint256 sfrxETHBalance = IERC20(sfrxETHAddress).balanceOf(address(this));\\r\\n        // Check to see that the balance minted is greater than 0\\r\\n        require(sfrxETHBalance > 0, 'sfrxETH minting failed');\\r\\n        // Call LSDVault to mint unshETH\\r\\n        _deposit_lsd(sfrxETHAddress, sfrxETHBalance);\\r\\n    }\\r\\n\\r\\n    function _mint_wstETH(uint256 ethAmount) internal {\\r\\n        // Mint wstETH\\r\\n        (bool success, )= address(wstETHAddress).call{value:ethAmount}(\\\"\\\");\\r\\n        // Check the success of the wstETH mint\\r\\n        require(success, \\\"wstETH minting failed\\\");\\r\\n        // Get balance of wstETH minted\\r\\n        uint256 wstETHBalance = IERC20(wstETHAddress).balanceOf(address(this));\\r\\n        // Call LSDVault to mint unshETH\\r\\n        _deposit_lsd(wstETHAddress, wstETHBalance);\\r\\n    }\\r\\n\\r\\n    function rETH_deposits_enabled() public view returns(bool) {\\r\\n        return IRocketSettings(rocketSettingsAddress).getDepositEnabled();\\r\\n    }\\r\\n\\r\\n    function _mint_rETH(uint256 ethAmount) internal {\\r\\n        //Check if deposits are open, then if yes (and under weight cap)  mint\\r\\n        require(rETH_deposits_enabled(), \\\"rETH deposit is not enabled\\\");\\r\\n        IRocketDepositPool(rocketDepositPoolAddress).deposit{value: ethAmount}();\\r\\n        // Get the balance of rETH minted\\r\\n        uint256 rETHBalance = IERC20(rETHAddress).balanceOf(address(this));\\r\\n        // Call LSDVault to mint unshETH\\r\\n        _deposit_lsd(rETHAddress, rETHBalance);\\r\\n    }\\r\\n\\r\\n    function _mint_wETH(uint256 ethAmount) internal {\\r\\n        IWETH(wethAddress).deposit{value: ethAmount}();\\r\\n        _deposit_lsd(wethAddress, ethAmount);\\r\\n    }\\r\\n\\r\\n    function _mint_ankrETH(uint256 ethAmount) internal {\\r\\n        // Mint ankrETH\\r\\n        IANKRDeposits(ankrDepositsAddress).stakeAndClaimAethC{value:ethAmount}();\\r\\n        // Get balance of ankrETH minted\\r\\n        uint256 ankrETHBalance = IERC20(ankrETHAddress).balanceOf(address(this));\\r\\n        // Call LSDVault to mint unshETH\\r\\n        _deposit_lsd(ankrETHAddress, ankrETHBalance);\\r\\n    }\\r\\n\\r\\n    function _mint_swETH(uint256 ethAmount) internal {\\r\\n        // Mint swETH\\r\\n        ISWETH(swETHAddress).deposit{value:ethAmount}();\\r\\n        // Get balance of swETH minted\\r\\n        uint256 swETHBalance = IERC20(swETHAddress).balanceOf(address(this));\\r\\n        // Call LSDVault to mint unshETH\\r\\n        _deposit_lsd(swETHAddress, swETHBalance);\\r\\n    }\\r\\n\\r\\n    function deposit_stEth(uint256 stETHAmount) external nonReentrant {\\r\\n        // Deposit stETH into wstETH\\r\\n        IWStETH(wstETHAddress).wrap(stETHAmount);\\r\\n        // Get the wrapped balance\\r\\n        uint256 wstETHAmount = IERC20(wstETHAddress).balanceOf(address(this));\\r\\n        // Deposit into lsd vault\\r\\n        _deposit_lsd(wstETHAddress, wstETHAmount);\\r\\n    }\\r\\n\\r\\n    function _deposit_frxEth(uint256 frxETHAmount) internal {\\r\\n        // Deposit frxETH into sfrxETH\\r\\n        SFRXETH(sfrxETHAddress).deposit(frxETHAmount, address(this));\\r\\n        // Get the wrapped balance\\r\\n        uint256 sfrxETHAmount = IERC20(sfrxETHAddress).balanceOf(address(this));\\r\\n        // Deposit into lsd vault\\r\\n        _deposit_lsd(sfrxETHAddress, sfrxETHAmount);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Direct LSD deposit functions\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function deposit_lsd(address lsdAddress, uint256 amount) external  {\\r\\n        // Assume user has approved token\\r\\n        TransferHelper.safeTransferFrom(lsdAddress, msg.sender, address(this), amount);\\r\\n        _deposit_lsd(lsdAddress, amount);\\r\\n    }\\r\\n\\r\\n    function _deposit_lsd(address lsdAddress, uint256 amount) internal {\\r\\n\\r\\n        uint256 depositFee;\\r\\n        uint256 protocolFee;\\r\\n        if(vdAmmAddress != address(0)) {\\r\\n            (depositFee, protocolFee) = IVdAmm(vdAmmAddress).getDepositFee(amount, lsdAddress);\\r\\n        }\\r\\n\\r\\n        uint256 amountToMint = amount - depositFee;\\r\\n        uint256 unshETHFee = depositFee - protocolFee;\\r\\n\\r\\n        if(protocolFee > 0) {\\r\\n            // Transfer protocol fee to vdAmmAddress\\r\\n            TransferHelper.safeTransfer(lsdAddress, vdAmmAddress, protocolFee);\\r\\n        }\\r\\n\\r\\n        if(depositFee > 0) {\\r\\n            // Transfer unshETH fee to lsdVault\\r\\n            TransferHelper.safeTransfer(lsdAddress, lsdVaultAddressV2, unshETHFee);\\r\\n        }\\r\\n\\r\\n        // Call LSDVault to mint unshETH\\r\\n        ILSDVaultV2(lsdVaultAddressV2).deposit(lsdAddress, amountToMint);\\r\\n        // Send unshETH to the msg.sender\\r\\n        uint256 unshETHMinted = IERC20(unshETHAddressV2).balanceOf(address(this));\\r\\n        TransferHelper.safeTransfer(unshETHAddressV2, msg.sender, unshETHMinted);\\r\\n\\r\\n        emit DepositLsd(msg.sender, lsdAddress, amountToMint, depositFee, protocolFee, unshETHMinted);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Mint with ETH - primary zap function\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function mint_unsheth_with_eth(uint256 amountOutMin, uint256 pathId) external payable nonReentrant {\\r\\n        // Validate the path\\r\\n        require(pathId <= MAX_PATH_ID, \\\"Invalid path\\\");\\r\\n        if (pathId <= 1 || (pathId >= 6 && pathId <= 9)) {\\r\\n            _ETH_to_unsheth_mintPaths(msg.value, pathId);\\r\\n        } else {\\r\\n            IWETH(wethAddress).deposit{value: msg.value}();\\r\\n            uint256 wethAmount = IERC20(wethAddress).balanceOf(address(this));\\r\\n            _weth_to_unsheth_swapPaths(wethAmount, amountOutMin, pathId);\\r\\n        }\\r\\n        emit DepositEth(msg.sender, msg.value, pathId);\\r\\n    }\\r\\n\\r\\n    function _ETH_to_unsheth_mintPaths(uint256 ethAmount, uint256 pathId) internal {\\r\\n        if(pathId == 0) {\\r\\n            _mint_wstETH(ethAmount);\\r\\n        } else if(pathId == 1) {\\r\\n            _mint_sfrxETH(ethAmount);\\r\\n        } else if(pathId == 6) {\\r\\n            _mint_rETH(ethAmount);\\r\\n        } else if(pathId == 7) {\\r\\n            _mint_wETH(ethAmount);\\r\\n        } else if (pathId == 8) {\\r\\n            _mint_ankrETH(ethAmount);\\r\\n        } else if (pathId == 9) {\\r\\n            _mint_swETH(ethAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _weth_to_unsheth_swapPaths(uint256 wethAmount, uint256 amountOutMin, uint256 pathId) internal {\\r\\n        require(swapPathIdToAddress[pathId] != address(0), \\\"swap path not supported\\\");\\r\\n        require(amountOutMin > 0, \\\"amountOutMin must be greater than 0\\\");\\r\\n        if (pathId == 5) {\\r\\n            //swap weth to frxETH (sfrxETH not liquid)\\r\\n            uint256 frxEthAmountOut = _swap_weth_lsd(wethAmount, amountOutMin, frxETHAddress);\\r\\n            //mint unshETH with frxETH->sfrxETH\\r\\n            _deposit_frxEth(frxEthAmountOut);\\r\\n        } else {\\r\\n            address lsdAddress = swapPathIdToAddress[pathId];\\r\\n            //swap weth to lsd\\r\\n            uint256 lsdAmountOut = _swap_weth_lsd(wethAmount, amountOutMin, lsdAddress);\\r\\n            //mint unshETH with lsd\\r\\n            _deposit_lsd(lsdAddress, lsdAmountOut);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _swap_weth_lsd(uint256 _wethAmount, uint256 _amountOutMin, address _lsdAddress) internal returns(uint256) {\\r\\n\\r\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\r\\n        tokenIn: wethAddress,\\r\\n        tokenOut: _lsdAddress,\\r\\n        fee: POOLFEE,\\r\\n        recipient: address(this),\\r\\n        deadline: block.timestamp + 3600,\\r\\n        amountIn: _wethAmount,\\r\\n        amountOutMinimum: _amountOutMin,\\r\\n        sqrtPriceLimitX96: 0\\r\\n        });\\r\\n\\r\\n        uint256 lsdAmountOut = uniswapRouterV3.exactInputSingle(params);\\r\\n        return(lsdAmountOut);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Other functions\\r\\n    ============================================================================\\r\\n    */\\r\\n    function updateVdAmmAddress() external {\\r\\n        vdAmmAddress = ILSDVaultV2(lsdVaultAddressV2).swapperAddress();\\r\\n    }\\r\\n\\r\\n    //Allow receiving eth to the contract\\r\\n    receive() external payable {}\\r\\n}\"\r\n    },\r\n    \"src/USH-OFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"layerzerolabs/contracts/token/oft/OFT.sol\\\";\\r\\n\\r\\ncontract USHOFT is OFT {\\r\\n    constructor(\\r\\n        address _lzEndpoint //0x3c2269811836af69497E5F486A85D7316753cf62 as per https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\\r\\n    ) OFT(\\\"unshETHing_Token\\\", \\\"USH\\\", _lzEndpoint){}\\r\\n}\"\r\n    },\r\n    \"src/USH-Proxy-ETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"layerzerolabs/contracts/token/oft/extension/ProxyOFT.sol\\\";\\r\\n\\r\\ncontract USHProxyOFT is ProxyOFT {\\r\\n    constructor(\\r\\n        address _lzEndpoint, //0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675 as per https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\\r\\n        address _token // address of the USH token - 0xe60779cc1b2c1d0580611c526a8df0e3f870ec48\\r\\n    ) ProxyOFT(_lzEndpoint, _token){}\\r\\n}\"\r\n    },\r\n    \"src/USH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// ====================================================================\\r\\n// |     ______                   _______                             |\\r\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\r\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\r\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\r\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\r\\n// |                                                                  |\\r\\n// ====================================================================\\r\\n// ========================= FRAXShares (FXS) =========================\\r\\n// ====================================================================\\r\\n// Frax Finance: https://github.com/FraxFinance\\r\\n\\r\\n// Primary Author(s)\\r\\n// Travis Moore: https://github.com/FortisFortuna\\r\\n// Jason Huan: https://github.com/jasonhuan\\r\\n// Sam Kazemian: https://github.com/samkazemian\\r\\n\\r\\n// Reviewer(s) / Contributor(s)\\r\\n// Sam Sun: https://github.com/samczsun\\r\\n\\r\\nimport \\\"../lib/Common/Context.sol\\\";\\r\\nimport \\\"../lib/ERC20/ERC20Custom.sol\\\";\\r\\nimport \\\"../lib/ERC20/IERC20.sol\\\";\\r\\n// import \\\"../Frax/Frax.sol\\\";\\r\\nimport \\\"../lib/Staking/Owned.sol\\\";\\r\\nimport \\\"../lib/Math/SafeMath.sol\\\";\\r\\nimport \\\"../lib/Governance/AccessControl.sol\\\";\\r\\n\\r\\ncontract USH is ERC20Custom, AccessControl, Owned {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    string public symbol;\\r\\n    string public name;\\r\\n    uint8 public constant decimals = 18;\\r\\n    //address public FRAXStablecoinAdd;\\r\\n    \\r\\n    uint256 public constant genesis_supply = 143500000e18; // 143.5M is printed upon genesis\\r\\n\\r\\n    address public timelock_address; // Governance timelock address\\r\\n    //FRAXStablecoin private FRAX;\\r\\n\\r\\n    bool public trackingVotes = true; // Tracking votes (only change if need to disable votes)\\r\\n\\r\\n    // A checkpoint for marking number of votes from a given block\\r\\n    struct Checkpoint {\\r\\n        uint32 fromBlock;\\r\\n        uint96 votes;\\r\\n    }\\r\\n\\r\\n    // A record of votes checkpoints for each account, by index\\r\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\r\\n\\r\\n    // The number of checkpoints for each account\\r\\n    mapping (address => uint32) public numCheckpoints;\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    // modifier onlyPools() {\\r\\n    //    require(FRAX.frax_pools(msg.sender) == true, \\\"Only frax pools can mint new FRAX\\\");\\r\\n    //     _;\\r\\n    // } \\r\\n    \\r\\n    modifier onlyByOwnGov() {\\r\\n        require(msg.sender == owner || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    constructor (\\r\\n        string memory _name,\\r\\n        string memory _symbol, \\r\\n        address _creator_address,\\r\\n        address _timelock_address\\r\\n    ) public Owned(_creator_address){\\r\\n        require((_timelock_address != address(0)), \\\"Zero address detected\\\"); \\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        timelock_address = _timelock_address;\\r\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\r\\n        _mint(_creator_address, genesis_supply);\\r\\n\\r\\n        // Do a checkpoint for the owner\\r\\n        _writeCheckpoint(_creator_address, 0, 0, uint96(genesis_supply));\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n    function setTimelock(address new_timelock) external onlyByOwnGov {\\r\\n        require(new_timelock != address(0), \\\"Timelock address cannot be 0\\\");\\r\\n        timelock_address = new_timelock;\\r\\n    }\\r\\n    \\r\\n    // function setFRAXAddress(address frax_contract_address) external onlyByOwnGov {\\r\\n    //     require(frax_contract_address != address(0), \\\"Zero address detected\\\");\\r\\n\\r\\n    //     FRAX = FRAXStablecoin(frax_contract_address);\\r\\n\\r\\n    //     emit FRAXAddressSet(frax_contract_address);\\r\\n    // }\\r\\n    \\r\\n    function mint(address to, uint256 amount) public onlyByOwnGov {\\r\\n        _mint(to, amount);\\r\\n    }\\r\\n    \\r\\n    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) \\r\\n    // function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \\r\\n    //     if(trackingVotes){\\r\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\r\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\r\\n    //         uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), \\\"pool_mint new votes overflows\\\");\\r\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes\\r\\n    //         trackVotes(address(this), m_address, uint96(m_amount));\\r\\n    //     }\\r\\n\\r\\n    //     super._mint(m_address, m_amount);\\r\\n    //     emit FXSMinted(address(this), m_address, m_amount);\\r\\n    // }\\r\\n\\r\\n    // // This function is what other frax pools will call to burn FXS \\r\\n    // function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\r\\n    //     if(trackingVotes){\\r\\n    //         trackVotes(b_address, address(this), uint96(b_amount));\\r\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\r\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\r\\n    //         uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), \\\"pool_burn_from new votes underflows\\\");\\r\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes\\r\\n    //     }\\r\\n\\r\\n    //     super._burnFrom(b_address, b_amount);\\r\\n    //     emit FXSBurned(b_address, address(this), b_amount);\\r\\n    // }\\r\\n\\r\\n    function toggleVotes() external onlyByOwnGov {\\r\\n        trackingVotes = !trackingVotes;\\r\\n    }\\r\\n\\r\\n    /* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        if(trackingVotes){\\r\\n            // Transfer votes\\r\\n            trackVotes(_msgSender(), recipient, uint96(amount));\\r\\n        }\\r\\n\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        if(trackingVotes){\\r\\n            // Transfer votes\\r\\n            trackVotes(sender, recipient, uint96(amount));\\r\\n        }\\r\\n\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /* ========== PUBLIC FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current votes balance for `account`\\r\\n     * @param account The address to get votes balance\\r\\n     * @return The number of current votes for `account`\\r\\n     */\\r\\n    function getCurrentVotes(address account) external view returns (uint96) {\\r\\n        uint32 nCheckpoints = numCheckpoints[account];\\r\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine the prior number of votes for an account as of a block number\\r\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\r\\n     * @param account The address of the account to check\\r\\n     * @param blockNumber The block number to get the vote balance at\\r\\n     * @return The number of votes the account had as of the given block\\r\\n     */\\r\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\r\\n        require(blockNumber < block.number, \\\"USH::getPriorVotes: not yet determined\\\");\\r\\n\\r\\n        uint32 nCheckpoints = numCheckpoints[account];\\r\\n        if (nCheckpoints == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // First check most recent balance\\r\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\r\\n            return checkpoints[account][nCheckpoints - 1].votes;\\r\\n        }\\r\\n\\r\\n        // Next check implicit zero balance\\r\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint32 lower = 0;\\r\\n        uint32 upper = nCheckpoints - 1;\\r\\n        while (upper > lower) {\\r\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\r\\n            Checkpoint memory cp = checkpoints[account][center];\\r\\n            if (cp.fromBlock == blockNumber) {\\r\\n                return cp.votes;\\r\\n            } else if (cp.fromBlock < blockNumber) {\\r\\n                lower = center;\\r\\n            } else {\\r\\n                upper = center - 1;\\r\\n            }\\r\\n        }\\r\\n        return checkpoints[account][lower].votes;\\r\\n    }\\r\\n\\r\\n    /* ========== INTERNAL FUNCTIONS ========== */\\r\\n\\r\\n    // From compound's _moveDelegates\\r\\n    // Keep track of votes. \\\"Delegates\\\" is a misnomer here\\r\\n    function trackVotes(address srcRep, address dstRep, uint96 amount) internal {\\r\\n        if (srcRep != dstRep && amount > 0) {\\r\\n            if (srcRep != address(0)) {\\r\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\r\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\r\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"USH::_moveVotes: vote amount underflows\\\");\\r\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\r\\n            }\\r\\n\\r\\n            if (dstRep != address(0)) {\\r\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\r\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\r\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"USH::_moveVotes: vote amount overflows\\\");\\r\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\r\\n      uint32 blockNumber = safe32(block.number, \\\"USH::_writeCheckpoint: block number exceeds 32 bits\\\");\\r\\n\\r\\n      if (nCheckpoints > 0 && checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\\r\\n          checkpoints[voter][nCheckpoints - 1].votes = newVotes;\\r\\n      } else {\\r\\n          checkpoints[voter][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\r\\n          numCheckpoints[voter] = nCheckpoints + 1;\\r\\n      }\\r\\n\\r\\n      emit VoterVotesChanged(voter, oldVotes, newVotes);\\r\\n    }\\r\\n\\r\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(n < 2**32, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\r\\n        require(n < 2**96, errorMessage);\\r\\n        return uint96(n);\\r\\n    }\\r\\n\\r\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\r\\n        uint96 c = a + b;\\r\\n        require(c >= a, errorMessage);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\r\\n        require(b <= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n    \\r\\n    /// @notice An event thats emitted when a voters account's vote balance changes\\r\\n    event VoterVotesChanged(address indexed voter, uint previousBalance, uint newBalance);\\r\\n\\r\\n    // // Track FXS burned\\r\\n    // event FXSBurned(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    // // Track FXS minted\\r\\n    // event FXSMinted(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    // event FRAXAddressSet(address addr);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/vdAMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"communal/ReentrancyGuard.sol\\\";\\r\\nimport \\\"communal/Owned.sol\\\";\\r\\nimport \\\"communal/SafeERC20.sol\\\";\\r\\nimport \\\"communal/TransferHelper.sol\\\";\\r\\n\\r\\n//import \\\"forge-std/console.sol\\\";\\r\\n\\r\\n/*\\r\\n * VDAMM Contract:\\r\\n *\\r\\n */\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n    function deposit() external payable;\\r\\n    function withdraw(uint wad) external;\\r\\n}\\r\\n\\r\\ninterface ILSDVault {\\r\\n    function darknetAddress() external view returns (address);\\r\\n    function redeemFee() external view returns (uint256);\\r\\n    function exit(uint256 amount) external;\\r\\n    function isEnabled(address lsd) external view returns (bool);\\r\\n    function remainingRoomToCap(address lsd, uint256 marginalDeposit) external view returns (uint256);\\r\\n    function getTargetAmount(address lsd, uint256 marginalDeposit) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IDarknet {\\r\\n    function checkPrice(address lsd) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IunshETH {\\r\\n    function timelock_address() external view returns (address);\\r\\n}\\r\\n\\r\\n/*\\r\\n * Fee Collector Contract:\\r\\n * This contract is responsible for managing fee curves and calculations\\r\\n * vdAMM swap and unshETH redemption fees are collected here after fee switch is turned on\\r\\n */\\r\\n\\r\\ncontract VDAMM is Owned, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n    /*\\r\\n    ============================================================================\\r\\n    State Variables\\r\\n    ============================================================================\\r\\n    */\\r\\n    address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    address public constant unshethAddress = 0x0Ae38f7E10A43B5b2fB064B42a2f4514cbA909ef;\\r\\n    address public immutable vaultAddress;\\r\\n    address public darknetAddress;\\r\\n\\r\\n    address[] public lsds;\\r\\n\\r\\n    ILSDVault public vault;\\r\\n\\r\\n    bool public ammPaused;\\r\\n\\r\\n    struct AmmFee {\\r\\n        uint256 baseFee;\\r\\n        uint256 dynamicFee;\\r\\n        uint256 instantRedemptionFee;\\r\\n    }\\r\\n\\r\\n    struct AMMFeeConfig {\\r\\n        uint256 baseFeeBps;\\r\\n        uint256 instantRedemptionFeeBps;\\r\\n        uint256 unshethFeeShareBps;\\r\\n        uint256 dynamicFeeSlope_x;\\r\\n        uint256 dynamicFeeSlope_x2;\\r\\n    }\\r\\n\\r\\n    //Mutable parameters, can be changed by governance\\r\\n    AMMFeeConfig ammFeeConfig = AMMFeeConfig(1, 20, 10000, 50, 1000);\\r\\n\\r\\n    bool public depositFeeEnabled = true;\\r\\n\\r\\n    //Immutable parameters, cannot be changed after deployment\\r\\n    uint256 public constant maxBaseFeeBps = 10;\\r\\n    uint256 public constant maxDynamicFeeBps = 200;\\r\\n    uint256 public constant minUnshethFeeShareBps = 5000; //At least half swap fees go to unshETH\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Events\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    //Fee curve parameters\\r\\n    event BaseFeeUpdated(uint256 _baseFeeBps);\\r\\n    event UnshethFeeShareUpdated(uint256 _unshethFeeShareBps);\\r\\n    event InstantRedemptionFeeUpdated(uint256 _instantRedemptionFeeBps);\\r\\n    event FeeSlopesUpdated(uint256 _dynamicFeeSlope_x, uint256 _dynamicFeeSlope_x2);\\r\\n    event DepositFeeToggled(bool depositFeeEnabled);\\r\\n\\r\\n    //Admin functions\\r\\n    event PauseToggled(bool ammPaused);\\r\\n    event TokensWithdrawn(address tokenAddress, uint256 amount);\\r\\n    event EthWithdrawn(uint256 amount);\\r\\n    event DarknetAddressUpdated(address darknetAddress);\\r\\n    event NewLsdApproved(address lsd);\\r\\n\\r\\n    //Swap\\r\\n    event SwapLsdToLsd(uint256 amountIn, address lsdIn, address lsdOut, uint256 lsdAmountOut, uint256 baseFee, uint256 dynamicFee, uint256 protocolFee);\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Constructor\\r\\n    ============================================================================\\r\\n    */\\r\\n    constructor(address _owner, address[] memory _lsds) Owned(_owner) {\\r\\n        vaultAddress = IunshETH(unshethAddress).timelock_address();\\r\\n        vault = ILSDVault(vaultAddress);\\r\\n        darknetAddress = vault.darknetAddress();\\r\\n        lsds = _lsds;\\r\\n        ammPaused = true;\\r\\n\\r\\n        //set approvals\\r\\n        for (uint256 i = 0; i < _lsds.length; i = unchkIncr(i)) {\\r\\n            TransferHelper.safeApprove(_lsds[i], vaultAddress, type(uint256).max);\\r\\n        }\\r\\n\\r\\n        TransferHelper.safeApprove(unshethAddress, vaultAddress, type(uint256).max);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Function Modifiers\\r\\n    ============================================================================\\r\\n    */\\r\\n    modifier onlyWhenUnpaused() {\\r\\n        require(ammPaused == false, \\\"AMM is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWhenPaused() {\\r\\n        require(ammPaused == true, \\\"AMM must be paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    vdAMM configuration functions (multisig only)\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function setBaseFee(uint256 _baseFeeBps) external onlyOwner {\\r\\n        require(_baseFeeBps <= maxBaseFeeBps, \\\"Base fee cannot be greater than max fee\\\");\\r\\n        ammFeeConfig.baseFeeBps = _baseFeeBps;\\r\\n        emit BaseFeeUpdated(_baseFeeBps);\\r\\n    }\\r\\n\\r\\n    function setDynamicFeeSlopes(uint256 _dynamicFeeSlope_x, uint256 _dynamicFeeSlope_x2) external onlyOwner {\\r\\n        ammFeeConfig.dynamicFeeSlope_x = _dynamicFeeSlope_x;\\r\\n        ammFeeConfig.dynamicFeeSlope_x2 = _dynamicFeeSlope_x2;\\r\\n        emit FeeSlopesUpdated(_dynamicFeeSlope_x, _dynamicFeeSlope_x2);\\r\\n    }\\r\\n\\r\\n    function setUnshethFeeShare(uint256 _unshethFeeShareBps) external onlyOwner {\\r\\n        require(_unshethFeeShareBps <= 10000, \\\"unshETH fee share cannot be greater than 100%\\\");\\r\\n        require(_unshethFeeShareBps >= minUnshethFeeShareBps, \\\"unshETH fee share must be greater than min\\\");\\r\\n        ammFeeConfig.unshethFeeShareBps = _unshethFeeShareBps;\\r\\n        emit UnshethFeeShareUpdated(_unshethFeeShareBps);\\r\\n    }\\r\\n\\r\\n    function setInstantRedemptionFee(uint256 _instantRedemptionFeeBps) external onlyOwner {\\r\\n        require(\\r\\n            _instantRedemptionFeeBps <= maxDynamicFeeBps,\\r\\n            \\\"Instant redemption fee cannot be greater than max fee\\\"\\r\\n        );\\r\\n        ammFeeConfig.instantRedemptionFeeBps = _instantRedemptionFeeBps;\\r\\n        emit InstantRedemptionFeeUpdated(_instantRedemptionFeeBps);\\r\\n    }\\r\\n\\r\\n    function toggleDepositFee() external onlyOwner {\\r\\n        depositFeeEnabled = !depositFeeEnabled;\\r\\n        emit DepositFeeToggled(depositFeeEnabled);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Admin functions (multisig only)\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function togglePaused() external onlyOwner {\\r\\n        ammPaused = !ammPaused;\\r\\n        emit PauseToggled(ammPaused);\\r\\n    }\\r\\n\\r\\n    function withdrawTokens(address tokenAddress) external onlyOwner {\\r\\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\\r\\n        require(balance > 0, \\\"No tokens to withdraw\\\");\\r\\n        TransferHelper.safeTransfer(tokenAddress, msg.sender, balance);\\r\\n        emit TokensWithdrawn(tokenAddress, balance);\\r\\n    }\\r\\n\\r\\n    function withdrawStuckEth() external onlyOwner {\\r\\n        uint256 ethBal = address(this).balance;\\r\\n        Address.sendValue(payable(owner), ethBal);\\r\\n        emit EthWithdrawn(ethBal);\\r\\n    }\\r\\n\\r\\n    function updateDarknetAddress() external onlyOwner {\\r\\n        darknetAddress = ILSDVault(vaultAddress).darknetAddress();\\r\\n        emit DarknetAddressUpdated(darknetAddress);\\r\\n    }\\r\\n\\r\\n    //Technically, full timelock proposal is needed to add a new LSD.  This function just ensures new vdAMM doesn't need to be re-deployed\\r\\n    function approveNewLsd(address lsdAddress) external onlyOwner {\\r\\n        lsds.push(lsdAddress);\\r\\n        TransferHelper.safeApprove(lsdAddress, vaultAddress, type(uint256).max);\\r\\n        emit NewLsdApproved(lsdAddress);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Fee curve logic\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function unshethFeeShareBps() public view returns (uint256) {\\r\\n        return ammFeeConfig.unshethFeeShareBps;\\r\\n    }\\r\\n\\r\\n    function getEthConversionRate(address lsd) public view returns (uint256) {\\r\\n        return IDarknet(darknetAddress).checkPrice(lsd);\\r\\n    }\\r\\n\\r\\n    //View function to get lsdAmountOut and fees for a swap. Does not deal with require checks if the swap is valid\\r\\n    function swapLsdToLsdCalcs(\\r\\n        uint256 amountIn,\\r\\n        address lsdIn,\\r\\n        address lsdOut\\r\\n    ) public view returns (uint256, uint256, uint256, uint256) {\\r\\n        //Sanity checks\\r\\n        require(lsdIn != lsdOut, \\\"Cannot swap same lsd\\\");\\r\\n        require(vault.isEnabled(lsdIn), \\\"lsdIn not enabled\\\");\\r\\n        require(vault.isEnabled(lsdOut), \\\"lsdOut is not enabled\\\");\\r\\n        require(amountIn > 0, \\\"Cannot swap 0 lsd\\\");\\r\\n\\r\\n        //In a swap, total amount of ETH in the vault is constant we're swapping on a 1:1 ETH basis\\r\\n        //To simplify and do a conservative first order approximation, we assume marginal deposit amount is 0\\r\\n        uint256 distanceToCap = vault.remainingRoomToCap(lsdIn, 0);\\r\\n        require(amountIn <= distanceToCap, \\\"Trade would exceed cap\\\");\\r\\n\\r\\n        uint256 ethAmountIn = (amountIn * getEthConversionRate(lsdIn)) / 1e18;\\r\\n        uint256 ethAmountOutBeforeFees = ethAmountIn;\\r\\n\\r\\n        //Calculate fees\\r\\n        (uint256 baseFee, uint256 dynamicFee, ) = getAmmFee(ethAmountIn, lsdIn, lsdOut); //in lsdOut terms\\r\\n\\r\\n        //Fees are paid in lsdOut terms\\r\\n        uint256 totalFee = baseFee + dynamicFee;\\r\\n        uint256 protocolFee = (totalFee * (10000 - ammFeeConfig.unshethFeeShareBps)) / 10000;\\r\\n\\r\\n        uint256 lsdAmountOutBeforeFees = (ethAmountOutBeforeFees * 1e18) / getEthConversionRate(lsdOut);\\r\\n        uint256 lsdAmountOut = lsdAmountOutBeforeFees - totalFee;\\r\\n\\r\\n        return (lsdAmountOut, baseFee, dynamicFee, protocolFee);\\r\\n    }\\r\\n\\r\\n    //returns amm fees in lsdOut terms\\r\\n    function getAmmFee(\\r\\n        uint256 ethAmountIn,\\r\\n        address lsdIn,\\r\\n        address lsdOut\\r\\n    ) public view returns (uint256, uint256, uint256) {\\r\\n        uint256 baseFeeInEthTerms = (ethAmountIn * ammFeeConfig.baseFeeBps) / 10000;\\r\\n\\r\\n        uint256 lsdInDynamicFeeBps = getLsdDynamicFeeBps(ethAmountIn, lsdIn, true);\\r\\n        uint256 lsdOutDynamicFeeBps = getLsdDynamicFeeBps(ethAmountIn, lsdOut, false);\\r\\n\\r\\n        if (lsdOut == wethAddress) {\\r\\n            lsdOutDynamicFeeBps = _min(maxDynamicFeeBps, lsdOutDynamicFeeBps + ammFeeConfig.instantRedemptionFeeBps);\\r\\n        }\\r\\n\\r\\n        //Take the higher of two and cap at maxDynamicFeeBps\\r\\n        uint256 dynamicFeeBps = _max(lsdInDynamicFeeBps, lsdOutDynamicFeeBps);\\r\\n        uint256 dynamicFeeInEthTerms = (ethAmountIn * dynamicFeeBps) / 10000;\\r\\n\\r\\n        uint256 baseFee = (baseFeeInEthTerms * 1e18) / getEthConversionRate(lsdOut);\\r\\n        uint256 dynamicFee = (dynamicFeeInEthTerms * 1e18) / getEthConversionRate(lsdOut);\\r\\n\\r\\n        return (baseFee, dynamicFee, dynamicFeeBps);\\r\\n    }\\r\\n\\r\\n    // Dynamic fee (inspired by GLP, with unshETH twist)\\r\\n    // Fees are 0 when swaps help rebalance the vault (i.e. when difference to target is reduced post-swap)\\r\\n    // When swaps worsen the distance to target, fees are applied\\r\\n    // Fees are proportional to the square of the % distance to target (taking the average before and after the swap)\\r\\n    // Small deviations are generally low fee\\r\\n    // Large deviations are quadratically higher penalty (since co-variance of unshETH is quadratically increasing)\\r\\n    // All deviations to target and normalized by the target weight (otherwise small LSDs won't be penalized at all)\\r\\n    // Fees are capped at maxDynamicFeeBps\\r\\n    function getLsdDynamicFeeBps(\\r\\n        uint256 ethDelta,\\r\\n        address lsd,\\r\\n        bool increment\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 lsdBalance = IERC20(lsd).balanceOf(vaultAddress);\\r\\n        uint256 initialAmount = (lsdBalance * getEthConversionRate(lsd)) / 1e18; //lsd balance in ETH terms\\r\\n        uint256 nextAmount;\\r\\n\\r\\n        if (increment) {\\r\\n            nextAmount = initialAmount + ethDelta;\\r\\n        } else {\\r\\n            nextAmount = initialAmount - _min(initialAmount, ethDelta);\\r\\n        }\\r\\n\\r\\n        uint256 targetAmount = (vault.getTargetAmount(lsd, 0) * getEthConversionRate(lsd)) / 1e18;\\r\\n        uint256 initialDiff = _absDiff(initialAmount, targetAmount);\\r\\n        uint256 nextDiff = _absDiff(nextAmount, targetAmount);\\r\\n\\r\\n        //If action improves the distance to target, zero fee\\r\\n        if (nextDiff < initialDiff) {\\r\\n            return 0; //no fee\\r\\n        }\\r\\n\\r\\n        //If target is zero and we are moving away from it, charge max fee\\r\\n        if (targetAmount == 0) {\\r\\n            return maxDynamicFeeBps;\\r\\n        }\\r\\n\\r\\n        //Otherwise Fee = a*x + b*x^2, where x = averageDiff / targetAmount\\r\\n        uint256 averageDiff = (initialDiff + nextDiff) / 2;\\r\\n        uint256 x = (averageDiff * 1e18) / targetAmount;\\r\\n        uint256 x2 = (x * x) / 1e18;\\r\\n\\r\\n        uint256 dynamicFeeBps_x = (ammFeeConfig.dynamicFeeSlope_x * x) / 1e18;\\r\\n        uint256 dynamicFeeBps_x2 = (ammFeeConfig.dynamicFeeSlope_x2 * x2) / 1e18;\\r\\n\\r\\n        return _min(maxDynamicFeeBps, dynamicFeeBps_x + dynamicFeeBps_x2);\\r\\n    }\\r\\n\\r\\n    function getDepositFee(uint256 lsdAmountIn, address lsd) public view returns (uint256, uint256) {\\r\\n        if (!depositFeeEnabled) {\\r\\n            return (0, 0);\\r\\n        }\\r\\n        uint256 ethAmountIn = (lsdAmountIn * getEthConversionRate(lsd)) / 1e18;\\r\\n        uint256 dynamicFeeBps = getLsdDynamicFeeBps(ethAmountIn, lsd, true);\\r\\n        uint256 redeemFeeBps = vault.redeemFee();\\r\\n\\r\\n        //If dynamic fee < redeem fee, then deposit fee = 0, otherwise deposit fee = dynamic fee - redeem fee\\r\\n        uint256 depositFeeBps = dynamicFeeBps - _min(dynamicFeeBps, redeemFeeBps);\\r\\n\\r\\n        uint256 depositFee = (lsdAmountIn * depositFeeBps) / 10000;\\r\\n        uint256 protocolFee = (depositFee * (10000 - ammFeeConfig.unshethFeeShareBps)) / 10000;\\r\\n        return (depositFee, protocolFee);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n   ============================================================================\\r\\n   Swapping\\r\\n   ============================================================================\\r\\n   */\\r\\n\\r\\n    function swapLsdToEth(\\r\\n        uint256 amountIn,\\r\\n        address lsdIn,\\r\\n        uint256 minAmountOut\\r\\n    ) external nonReentrant onlyWhenUnpaused returns (uint256, uint256, uint256) {\\r\\n        //Transfer lsdIn from user to vault\\r\\n        TransferHelper.safeTransferFrom(lsdIn, msg.sender, address(this), amountIn);\\r\\n        (uint256 wethAmountOut, uint256 baseFee, uint256 dynamicFee) = _swapLsdToLsd(\\r\\n            amountIn,\\r\\n            lsdIn,\\r\\n            wethAddress,\\r\\n            minAmountOut\\r\\n        );\\r\\n        //Convert weth to ETH and send to user\\r\\n        IWETH(wethAddress).withdraw(wethAmountOut);\\r\\n        Address.sendValue(payable(msg.sender), wethAmountOut);\\r\\n        return (wethAmountOut, baseFee, dynamicFee);\\r\\n    }\\r\\n\\r\\n    function swapEthToLsd(\\r\\n        address lsdOut,\\r\\n        uint256 minAmountOut\\r\\n    ) external payable nonReentrant onlyWhenUnpaused returns (uint256, uint256, uint256) {\\r\\n        //Convert ETH to weth and swap\\r\\n        IWETH(wethAddress).deposit{ value: msg.value }();\\r\\n        (uint256 lsdAmountOut, uint256 baseFee, uint256 dynamicFee) = _swapLsdToLsd(\\r\\n            msg.value,\\r\\n            wethAddress,\\r\\n            lsdOut,\\r\\n            minAmountOut\\r\\n        );\\r\\n        //Send lsdOut to user\\r\\n        TransferHelper.safeTransfer(lsdOut, msg.sender, lsdAmountOut);\\r\\n        return (lsdAmountOut, baseFee, dynamicFee);\\r\\n    }\\r\\n\\r\\n    function swapLsdToLsd(\\r\\n        uint256 amountIn,\\r\\n        address lsdIn,\\r\\n        address lsdOut,\\r\\n        uint256 minAmountOut\\r\\n    ) external nonReentrant onlyWhenUnpaused returns (uint256, uint256, uint256) {\\r\\n        //Transfer lsdIn from user to vdamm and swap\\r\\n        TransferHelper.safeTransferFrom(lsdIn, msg.sender, address(this), amountIn);\\r\\n        (uint256 lsdAmountOut, uint256 baseFee, uint256 dynamicFee) = _swapLsdToLsd(\\r\\n            amountIn,\\r\\n            lsdIn,\\r\\n            lsdOut,\\r\\n            minAmountOut\\r\\n        );\\r\\n        //Send lsdOut to user\\r\\n        TransferHelper.safeTransfer(lsdOut, msg.sender, lsdAmountOut);\\r\\n        return (lsdAmountOut, baseFee, dynamicFee);\\r\\n    }\\r\\n\\r\\n    // Converts lsd to another lsd.\\r\\n    // Collects protocol fees in vdAMM contract, and keeps unshETH share of fees for unshETH holders.\\r\\n    // Assumes lsdIn is already in vdamm contract, lsdAmountOut + protocol fees is kept in vdAMM contract\\r\\n    // Returns lsdAmountOut.\\r\\n    function _swapLsdToLsd(\\r\\n        uint256 amountIn,\\r\\n        address lsdIn,\\r\\n        address lsdOut,\\r\\n        uint256 minAmountOut\\r\\n    ) internal returns (uint256, uint256, uint256) {\\r\\n        (uint256 lsdAmountOut, uint256 baseFee, uint256 dynamicFee, uint256 protocolFee) = swapLsdToLsdCalcs(\\r\\n            amountIn,\\r\\n            lsdIn,\\r\\n            lsdOut\\r\\n        );\\r\\n        require(lsdAmountOut >= minAmountOut, \\\"Slippage limit reached\\\");\\r\\n\\r\\n        //Amount to take out from vault = amountOut + protocolFee from vault. unshETH share of fees are kept in the vault\\r\\n        uint256 lsdAmountOutFromVault = lsdAmountOut + protocolFee;\\r\\n        require(\\r\\n            lsdAmountOutFromVault <= IERC20(lsdOut).balanceOf(vaultAddress),\\r\\n            \\\"Not enough lsdOut in vault\\\"\\r\\n        );\\r\\n\\r\\n        //Transfer amountIn from vdAMM to the vault\\r\\n        TransferHelper.safeTransfer(lsdIn, vaultAddress, amountIn);\\r\\n\\r\\n        //Transfer lsdOut from vault to vdAMM\\r\\n        TransferHelper.safeTransferFrom(lsdOut, vaultAddress, address(this), lsdAmountOutFromVault);\\r\\n\\r\\n        emit SwapLsdToLsd(amountIn, lsdIn, lsdOut, lsdAmountOut, baseFee, dynamicFee, protocolFee);\\r\\n\\r\\n        //Return the lsdAmountOut (which subtracts protocolFee).  ProtocolFee is kept in vdAMM contract\\r\\n        return (lsdAmountOut, baseFee, dynamicFee);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    ============================================================================\\r\\n    Other functions\\r\\n    ============================================================================\\r\\n    */\\r\\n\\r\\n    function unchkIncr(uint256 i) private pure returns (uint256) {\\r\\n        unchecked {\\r\\n            return i + 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _min(uint256 _a, uint256 _b) private pure returns (uint256) {\\r\\n        if (_a < _b) {\\r\\n            return _a;\\r\\n        } else {\\r\\n            return _b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _max(uint256 _a, uint256 _b) private pure returns (uint256) {\\r\\n        if (_a > _b) {\\r\\n            return _a;\\r\\n        } else {\\r\\n            return _b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _absDiff(uint256 _a, uint256 _b) private pure returns (uint256) {\\r\\n        if (_a > _b) {\\r\\n            return _a - _b;\\r\\n        } else {\\r\\n            return _b - _a;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Allow receiving eth to the contract\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/VotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n//Modified Multiple Token VotingEscrow Contract\\r\\n//The following changes have been made:\\r\\n//1. Users can lock either 80-20 USH-unshETH BPT, Uniswapv2 style pool2 token, or single-sided USH\\r\\n//2. Make sure deposit() and withdraw() funcs are correctly updated for the multi token model\\r\\n//3. Give owner ability to update boost weight of BPT and Pool2 tokens\\r\\n//4. Price everything in USH terms - this means pricing the BPT and Pool2 tokens in USH terms\\r\\n//5. Make 1 USH = 1vdUSH max locked for single-sided.\\r\\n//6. Pool2 included for easy migration of existing liquidity + enable locking in chains where BPT is not supported\\r\\n\\r\\n/// basically, where tokenAmount is used, we need to use scaledtokenAmount1+weight*tokenAmount2\\r\\n/**\\r\\n@title Multi-Token Weighted Voting Escrow\\r\\n@author @EIP_Alta1r, Original: Curve Finance, Solidity Rewrite: Stargate Finance\\r\\n@license MIT\\r\\n@notice Votes have a weight depending on time, so that users are\\r\\n        committed to the future of (whatever they are voting for)\\r\\n@dev Vote weight decays linearly over time. Lock time cannot be\\r\\n     more than `MAXTIME` (1 years).\\r\\n\\r\\n# Voting escrow to have time-weighted votes\\r\\n# Votes have a weight depending on time, so that users are committed\\r\\n# to the future of (whatever they are voting for).\\r\\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\\r\\n# w ^\\r\\n# 1 +        /\\r\\n#   |      /\\r\\n#   |    /\\r\\n#   |  /\\r\\n#   |/\\r\\n# 0 +--------+------> time\\r\\n#       maxtime (1 years?)\\r\\n*/\\r\\n\\r\\nimport \\\"openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"forge-std/console.sol\\\";\\r\\n\\r\\nstruct Point {\\r\\n    int128 bias;\\r\\n    int128 slope; // # -dweight / dt\\r\\n    uint ts;\\r\\n    uint blk; // block\\r\\n}\\r\\n/* We cannot really do block numbers per se b/c slope is per time, not per block\\r\\n * and per block could be fairly bad b/c Ethereum changes blocktimes.\\r\\n * What we can do is to extrapolate ***At functions */\\r\\n\\r\\nstruct LockedBalance {\\r\\n    int128 amount; //weightedAmount\\r\\n    uint256 amountA;\\r\\n    uint256 amountB;\\r\\n    uint256 amountC;\\r\\n    uint end;\\r\\n}\\r\\n\\r\\ninterface IPool2 {\\r\\n    function getReserves() external view returns (uint112 _reserveA, uint112 _reserveB, uint32 _blockTimestampLast);\\r\\n    function getPoolId() external view returns (bytes32);\\r\\n}\\r\\n\\r\\ninterface IBPT {\\r\\n    function getVault() external view returns (address);\\r\\n    function getPoolId() external view returns (bytes32);\\r\\n}\\r\\n\\r\\ninterface IBPTVault {\\r\\n    function getPoolTokenInfo(\\r\\n        bytes32 poolId,\\r\\n        address token\\r\\n    ) external view returns (uint256, uint256, uint256, address);\\r\\n}\\r\\n\\r\\ncontract VotingEscrow is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    enum DepositType {\\r\\n        DEPOSIT_FOR_TYPE,\\r\\n        CREATE_LOCK_TYPE,\\r\\n        INCREASE_LOCK_AMOUNT,\\r\\n        INCREASE_UNLOCK_TIME\\r\\n    }\\r\\n\\r\\n    event Deposit(\\r\\n        address indexed provider,\\r\\n        uint valueA,\\r\\n        uint valueB,\\r\\n        uint valueC,\\r\\n        uint indexed locktime,\\r\\n        DepositType deposit_type,\\r\\n        uint ts\\r\\n    );\\r\\n    event Withdraw(address indexed provider, uint valueA, uint valueB, uint valueC, uint ts);\\r\\n    event Supply(uint prevSupply, uint supply);\\r\\n\\r\\n    uint internal constant WEEK = 1 weeks;\\r\\n    uint public constant MAXTIME = 53 weeks; //max lock 1 year\\r\\n    int128 internal constant iMAXTIME = 53 weeks;\\r\\n    uint public constant MINTIME = 4 weeks;\\r\\n    uint internal constant MULTIPLIER = 1 ether;\\r\\n\\r\\n    //a dynamic boost weight that is configurable\\r\\n    uint256 public bpt_boost_weight;\\r\\n    uint256 public pool2_boost_weight;\\r\\n\\r\\n    address public immutable tokenA; //BPT\\r\\n    address public immutable tokenB; //Pool2 LP Token\\r\\n    address public immutable tokenC; //Single-sided USH Token\\r\\n    uint public supply;\\r\\n    bool public unlocked;\\r\\n\\r\\n    mapping(address => LockedBalance) public locked; //weighted locked balance\\r\\n\\r\\n    uint public epoch;\\r\\n    mapping(uint => Point) public point_history; // epoch -> unsigned point\\r\\n    mapping(address => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\\r\\n    mapping(address => uint) public user_point_epoch;\\r\\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\\r\\n\\r\\n    // Aragon's view methods for compatibility\\r\\n    address public controller;\\r\\n    bool public transfersEnabled;\\r\\n\\r\\n    string public constant name = \\\"vdUSH\\\";\\r\\n    string public constant symbol = \\\"vdUSH\\\";\\r\\n    string public constant version = \\\"1.0.0\\\";\\r\\n    uint8 public constant decimals = 18;\\r\\n\\r\\n    // Whitelisted (smart contract) wallets which are allowed to deposit\\r\\n    // The goal is to prevent tokenizing the escrow\\r\\n    mapping(address => bool) public contracts_whitelist;\\r\\n\\r\\n    /// @notice Contract constructor\\r\\n    /// @param tokenA_addr BPT\\r\\n    /// @param tokenB_addr Pool2 LP token\\r\\n    /// @param tokenC_addr USH token\\r\\n    constructor(address tokenA_addr, address tokenB_addr, address tokenC_addr) {\\r\\n        tokenA = tokenA_addr;\\r\\n        tokenB = tokenB_addr;\\r\\n        tokenC = tokenC_addr;\\r\\n        bpt_boost_weight = 2.5 ether;\\r\\n        pool2_boost_weight = 3.5 ether;\\r\\n        point_history[0].blk = block.number;\\r\\n        point_history[0].ts = block.timestamp;\\r\\n        controller = msg.sender;\\r\\n        transfersEnabled = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyUserOrWhitelist() {\\r\\n        if (msg.sender != tx.origin) {\\r\\n            require(contracts_whitelist[msg.sender], \\\"Smart contract not allowed\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notUnlocked() {\\r\\n        require(!unlocked, \\\"unlocked globally\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //helper unit conversion funcs\\r\\n    function bpt_amount_to_ush_units(uint256 amount) internal view returns (uint256) {\\r\\n        //get the contract address of the BPT pool token\\r\\n        address bpt_address = tokenA;\\r\\n        //get vault and pool info\\r\\n        address balancer_vault = IBPT(bpt_address).getVault();\\r\\n        bytes32 pool_id = IBPT(bpt_address).getPoolId();\\r\\n        //get the balance of token A in the BPT pool\\r\\n        (uint256 ush_balance, , , ) = IBPTVault(balancer_vault).getPoolTokenInfo(pool_id, tokenC);\\r\\n        //get the total supply of the BPT pool\\r\\n        uint256 total_supply = IERC20(bpt_address).totalSupply();\\r\\n        //calculate the amount of token C units\\r\\n        return (amount * ush_balance) / total_supply;\\r\\n    }\\r\\n\\r\\n    function pool2_amount_to_ush_units(uint256 amount) internal view returns (uint256) {\\r\\n        //get the contract address of the BPT pool token\\r\\n        address pool2_address = tokenB;\\r\\n        //get vault and pool info\\r\\n        (uint256 ush_balance, , ) = IPool2(pool2_address).getReserves();\\r\\n\\r\\n        console.log(ush_balance);\\r\\n        //get the total supply of the pool2\\r\\n        uint256 total_supply = IERC20(pool2_address).totalSupply();\\r\\n        console.log(total_supply);\\r\\n        //calculate the amount of token C units\\r\\n        return (amount * ush_balance) / total_supply;\\r\\n    }\\r\\n\\r\\n    function update_bpt_boost_weight(uint256 weight) external onlyOwner {\\r\\n        require(weight > 0, \\\"Cannot set zero boost weight!\\\");\\r\\n        bpt_boost_weight = weight;\\r\\n    }\\r\\n\\r\\n    function update_pool2_boost_weight(uint256 weight) external onlyOwner {\\r\\n        require(weight > 0, \\\"Cannot set zero boost weight!\\\");\\r\\n        pool2_boost_weight = weight;\\r\\n    }\\r\\n\\r\\n    function weighted_amount(uint256 bptAmount, uint256 pool2Amount, uint256 tokenAmount) public view returns (uint256) {\\r\\n\\r\\n        uint256 scaled_bpt_amount = tokenA == address(0) ? 0 : bpt_amount_to_ush_units(bptAmount);\\r\\n\\r\\n        uint256 scaled_pool2_amount = pool2_amount_to_ush_units(pool2Amount);\\r\\n\\r\\n        return (scaled_bpt_amount * bpt_boost_weight) / 1e18 + (scaled_pool2_amount * pool2_boost_weight) / 1e18 + tokenAmount;\\r\\n    }\\r\\n\\r\\n    function int_weighted_amount(uint256 _valueA, uint256 _valueB, uint256 _valueC) internal view returns (int128) {\\r\\n        return int128(int(weighted_amount(_valueA, _valueB, _valueC)));\\r\\n    }\\r\\n\\r\\n    /// @notice Add address to whitelist smart contract depositors `addr`\\r\\n    /// @param addr Address to be whitelisted\\r\\n    function add_to_whitelist(address addr) external onlyOwner {\\r\\n        require(!contracts_whitelist[addr], \\\"Address already whitelisted\\\");\\r\\n        contracts_whitelist[addr] = true;\\r\\n    }\\r\\n\\r\\n    /// @notice Remove a smart contract address from whitelist\\r\\n    /// @param addr Address to be removed from whitelist\\r\\n    function remove_from_whitelist(address addr) external onlyOwner {\\r\\n        require(contracts_whitelist[addr], \\\"Address not whitelisted\\\");\\r\\n        contracts_whitelist[addr] = false;\\r\\n    }\\r\\n\\r\\n    /// @notice Unlock all locked balances\\r\\n    function unlock() external onlyOwner {\\r\\n        unlocked = true;\\r\\n    }\\r\\n\\r\\n    /// @notice Get the most recently recorded rate of voting power decrease for `_addr`\\r\\n    /// @param addr Address of the user wallet\\r\\n    /// @return Value of the slope\\r\\n    function get_last_user_slope(address addr) external view returns (int128) {\\r\\n        uint uepoch = user_point_epoch[addr];\\r\\n        return user_point_history[addr][uepoch].slope;\\r\\n    }\\r\\n\\r\\n    /// @notice Get the timestamp for checkpoint `_idx` for `_addr`\\r\\n    /// @param _addr User wallet address\\r\\n    /// @param _idx User epoch number\\r\\n    /// @return Epoch time of the checkpoint\\r\\n    function user_point_history__ts(address _addr, uint _idx) external view returns (uint) {\\r\\n        return user_point_history[_addr][_idx].ts;\\r\\n    }\\r\\n\\r\\n    /// @notice Get timestamp when `_addr`'s lock finishes\\r\\n    /// @param _addr User wallet address\\r\\n    /// @return Epoch time of the lock end\\r\\n    function locked__end(address _addr) external view returns (uint) {\\r\\n        return locked[_addr].end;\\r\\n    }\\r\\n\\r\\n    function locked__amountA(address user) external view returns (uint) {\\r\\n        return locked[user].amountA;\\r\\n    }\\r\\n\\r\\n    function locked__amountB(address user) external view returns (uint) {\\r\\n        return locked[user].amountB;\\r\\n    }\\r\\n\\r\\n    function locked__amountC(address user) external view returns (uint) {\\r\\n        return locked[user].amountC;\\r\\n    }\\r\\n\\r\\n    /// @notice Record global and per-user data to checkpoint\\r\\n    /// @param _addr User's wallet address. No user checkpoint if 0x0\\r\\n    /// @param old_locked Pevious locked amount / end lock time for the user\\r\\n    /// @param new_locked New locked amount / end lock time for the user\\r\\n    function _checkpoint(\\r\\n        address _addr,\\r\\n        LockedBalance memory old_locked,\\r\\n        LockedBalance memory new_locked\\r\\n    ) internal {\\r\\n        Point memory u_old;\\r\\n        Point memory u_new;\\r\\n        int128 old_dslope = 0;\\r\\n        int128 new_dslope = 0;\\r\\n        uint _epoch = epoch;\\r\\n\\r\\n        //make sure we are using the most current BPT boost weights\\r\\n        //and then make sure the new_locked that was passed in has had the most current boost weights applied (do that elsewhere)\\r\\n        old_locked.amount = int_weighted_amount(old_locked.amountA, old_locked.amountB, old_locked.amountC);\\r\\n\\r\\n        if (_addr != address(0x0)) {\\r\\n            // Calculate slopes and biases\\r\\n            // Kept at zero when they have to\\r\\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\\r\\n                u_old.slope = old_locked.amount / iMAXTIME;\\r\\n                u_old.bias = u_old.slope * int128(int(old_locked.end - block.timestamp));\\r\\n            }\\r\\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\\r\\n                u_new.slope = new_locked.amount / iMAXTIME;\\r\\n                u_new.bias = u_new.slope * int128(int(new_locked.end - block.timestamp));\\r\\n            }\\r\\n\\r\\n            // Read values of scheduled changes in the slope\\r\\n            // old_locked.end can be in the past and in the future\\r\\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\\r\\n            old_dslope = slope_changes[old_locked.end];\\r\\n            if (new_locked.end != 0) {\\r\\n                if (new_locked.end == old_locked.end) {\\r\\n                    new_dslope = old_dslope;\\r\\n                } else {\\r\\n                    new_dslope = slope_changes[new_locked.end];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Point memory last_point = Point({ bias: 0, slope: 0, ts: block.timestamp, blk: block.number });\\r\\n        if (_epoch > 0) {\\r\\n            last_point = point_history[_epoch];\\r\\n        }\\r\\n        uint last_checkpoint = last_point.ts;\\r\\n        // initial_last_point is used for extrapolation to calculate block number\\r\\n        // (approximately, for *At methods) and save them\\r\\n        // as we cannot figure that out exactly from inside the contract\\r\\n\\r\\n        uint initial_last_point_ts = last_point.ts;\\r\\n        uint initial_last_point_blk = last_point.blk;\\r\\n\\r\\n        uint block_slope = 0; // dblock/dt\\r\\n        if (block.timestamp > last_point.ts) {\\r\\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\\r\\n        }\\r\\n        // If last point is already recorded in this block, slope=0\\r\\n        // But that's ok b/c we know the block in such case\\r\\n\\r\\n        // Go over weeks to fill history and calculate what the current point is\\r\\n        uint t_i = (last_checkpoint / WEEK) * WEEK;\\r\\n        for (uint i = 0; i < 255; ++i) {\\r\\n            // Hopefully it won't happen that this won't get used in 5 years!\\r\\n            // If it does, users will be able to withdraw but vote weight will be broken\\r\\n            t_i += WEEK;\\r\\n            int128 d_slope = 0;\\r\\n            if (t_i > block.timestamp) {\\r\\n                t_i = block.timestamp;\\r\\n            } else {\\r\\n                d_slope = slope_changes[t_i];\\r\\n            }\\r\\n            last_point.bias -= last_point.slope * int128(int(t_i - last_checkpoint));\\r\\n            last_point.slope += d_slope;\\r\\n            if (last_point.bias < 0) {\\r\\n                // This can happen\\r\\n                last_point.bias = 0;\\r\\n            }\\r\\n            if (last_point.slope < 0) {\\r\\n                // This cannot happen - just in case\\r\\n                last_point.slope = 0;\\r\\n            }\\r\\n            last_checkpoint = t_i;\\r\\n            last_point.ts = t_i;\\r\\n            last_point.blk =\\r\\n                initial_last_point_blk +\\r\\n                (block_slope * (t_i - initial_last_point_ts)) /\\r\\n                MULTIPLIER;\\r\\n\\r\\n            _epoch += 1;\\r\\n            if (t_i == block.timestamp) {\\r\\n                last_point.blk = block.number;\\r\\n                break;\\r\\n            } else {\\r\\n                point_history[_epoch] = last_point;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        epoch = _epoch;\\r\\n        // Now point_history is filled until t=now\\r\\n\\r\\n        if (_addr != address(0x0)) {\\r\\n            // If last point was in this block, the slope change has been applied already\\r\\n            // But in such case we have 0 slope(s)\\r\\n            last_point.slope += (u_new.slope - u_old.slope);\\r\\n            last_point.bias += (u_new.bias - u_old.bias);\\r\\n            if (last_point.slope < 0) {\\r\\n                last_point.slope = 0;\\r\\n            }\\r\\n            if (last_point.bias < 0) {\\r\\n                last_point.bias = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Record the changed point into history\\r\\n        point_history[_epoch] = last_point;\\r\\n\\r\\n        if (_addr != address(0x0)) {\\r\\n            // Schedule the slope changes (slope is going down)\\r\\n            // We subtract new_user_slope from [new_locked.end]\\r\\n            // and add old_user_slope to [old_locked.end]\\r\\n            if (old_locked.end > block.timestamp) {\\r\\n                // old_dslope was <something> - u_old.slope, so we cancel that\\r\\n                old_dslope += u_old.slope;\\r\\n                if (new_locked.end == old_locked.end) {\\r\\n                    old_dslope -= u_new.slope; // It was a new deposit, not extension\\r\\n                }\\r\\n                slope_changes[old_locked.end] = old_dslope;\\r\\n            }\\r\\n\\r\\n            if (new_locked.end > block.timestamp) {\\r\\n                if (new_locked.end > old_locked.end) {\\r\\n                    new_dslope -= u_new.slope; // old slope disappeared at this point\\r\\n                    slope_changes[new_locked.end] = new_dslope;\\r\\n                }\\r\\n                // else: we recorded it already in old_dslope\\r\\n            }\\r\\n            // Now handle user history\\r\\n            address addr = _addr;\\r\\n            uint user_epoch = user_point_epoch[addr] + 1;\\r\\n\\r\\n            user_point_epoch[addr] = user_epoch;\\r\\n            u_new.ts = block.timestamp;\\r\\n            u_new.blk = block.number;\\r\\n            user_point_history[addr][user_epoch] = u_new;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Record global data to checkpoint\\r\\n    function checkpoint() external notUnlocked {\\r\\n        _checkpoint(\\r\\n            address(0x0),\\r\\n            LockedBalance(int_weighted_amount(0, 0, 0), 0, 0, 0, 0),\\r\\n            LockedBalance(int_weighted_amount(0, 0, 0), 0, 0, 0, 0)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deposit_for(address _addr, uint _valueA, uint _valueB, uint _valueC) external nonReentrant {\\r\\n        LockedBalance memory _locked = locked[_addr];\\r\\n\\r\\n        require(_valueA > 0 || _valueB > 0 || _valueC > 0); // dev: need non-zero value\\r\\n        require(_locked.amount > 0, \\\"No existing lock found\\\");\\r\\n        require(_locked.end > block.timestamp, \\\"Cannot add to expired lock. Withdraw\\\");\\r\\n        _deposit_for(_addr, _valueA, _valueB, _valueC, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\\r\\n    }\\r\\n\\r\\n    function _deposit_for(\\r\\n        address _addr,\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint unlock_time,\\r\\n        LockedBalance memory locked_balance,\\r\\n        DepositType deposit_type\\r\\n    ) internal {\\r\\n        LockedBalance memory _locked = locked_balance;\\r\\n        uint supply_before = supply;\\r\\n\\r\\n        supply = supply_before + weighted_amount(_valueA, _valueB, _valueC);\\r\\n        LockedBalance memory old_locked;\\r\\n        //NOTE: need to be checked\\r\\n        _locked.amount = int128(int(weighted_amount(_locked.amountA, _locked.amountB, _locked.amountC)));\\r\\n        // old_locked.amount = int128(int(weighted_amount(old_locked.amountA, old_locked.amountB)));\\r\\n        (old_locked.amount, old_locked.end) = (_locked.amount, _locked.end);\\r\\n        // Adding to existing lock, or if a lock is expired - creating a new one\\r\\n        _locked.amount += int128(int(weighted_amount(_valueA, _valueB, _valueC)));\\r\\n        _locked.amountA += _valueA;\\r\\n        _locked.amountB += _valueB;\\r\\n        _locked.amountC += _valueC;\\r\\n\\r\\n        if (unlock_time != 0) {\\r\\n            _locked.end = unlock_time;\\r\\n        }\\r\\n        locked[_addr] = _locked;\\r\\n\\r\\n        // Possibilities:\\r\\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\\r\\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\\r\\n        // _locked.end > block.timestamp (always)\\r\\n        _checkpoint(_addr, old_locked, _locked);\\r\\n\\r\\n        if (_valueA != 0) {\\r\\n            IERC20(tokenA).safeTransferFrom(msg.sender, address(this), _valueA);\\r\\n        }\\r\\n\\r\\n        if (_valueB != 0) {\\r\\n            IERC20(tokenB).safeTransferFrom(msg.sender, address(this), _valueB);\\r\\n        }\\r\\n\\r\\n        if (_valueC != 0) {\\r\\n            IERC20(tokenC).safeTransferFrom(msg.sender, address(this), _valueC);\\r\\n        }\\r\\n\\r\\n        emit Deposit(_addr, _valueA, _valueB, _valueC, _locked.end, deposit_type, block.timestamp);\\r\\n        emit Supply(supply_before, supply_before + weighted_amount(_valueA, _valueB, _valueC));\\r\\n    }\\r\\n\\r\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    /// @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\\r\\n    function _create_lock(uint _valueA, uint _valueB, uint _valueC, uint _unlock_time) internal {\\r\\n        require(_valueA > 0 || _valueB > 0 || _valueC > 0); // dev: need non-zero value\\r\\n\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n        require(_locked.amount == 0, \\\"Withdraw old tokens first\\\");\\r\\n\\r\\n        require(_unlock_time >= block.timestamp + MINTIME, \\\"Voting lock must be at least MINTIME\\\");\\r\\n        //NOTE:MAXTIME is set to 1 year, may be changed to 3 years\\r\\n        require(_unlock_time <= block.timestamp + MAXTIME, \\\"Voting lock can be 1 year max\\\");\\r\\n        //NOTE: calc only if valid time to save on gas\\r\\n        uint unlock_time = (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\\r\\n\\r\\n        _deposit_for(msg.sender, _valueA, _valueB, _valueC, unlock_time, _locked, DepositType.CREATE_LOCK_TYPE);\\r\\n    }\\r\\n\\r\\n    /// @notice External function for _create_lock\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    /// @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\\r\\n    function create_lock(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint _unlock_time\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _create_lock(_valueA, _valueB, _valueC, _unlock_time);\\r\\n    }\\r\\n\\r\\n    /// @notice Deposit `_value` additional tokens for `msg.sender` without modifying the unlock time\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    function increase_amount(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _increase_amount(_valueA, _valueB, _valueC);\\r\\n    }\\r\\n\\r\\n    function _increase_amount(uint _valueA, uint _valueB, uint _valueC) internal {\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n\\r\\n        require(_valueA > 0 || _valueB > 0 || _valueC > 0); // dev: need non-zero value\\r\\n        require(_locked.amount > 0, \\\"No existing lock found\\\");\\r\\n        require(_locked.end > block.timestamp, \\\"Cannot add to expired lock. Withdraw\\\");\\r\\n\\r\\n        _deposit_for(msg.sender, _valueA, _valueB, _valueC, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\\r\\n    }\\r\\n\\r\\n    /// @notice Extend the unlock time for `msg.sender` to `_unlock_time`\\r\\n    /// @param _unlock_time New epoch time for unlocking\\r\\n    function increase_unlock_time(uint _unlock_time) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _increase_unlock_time(_unlock_time);\\r\\n    }\\r\\n\\r\\n    function _increase_unlock_time(uint _unlock_time) internal {\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n        uint unlock_time = (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\\r\\n\\r\\n        require(_locked.end > block.timestamp, \\\"Lock expired\\\");\\r\\n        require(_locked.amount > 0, \\\"Nothing is locked\\\");\\r\\n        require(unlock_time > _locked.end, \\\"Can only increase lock duration\\\");\\r\\n        require(unlock_time <= block.timestamp + MAXTIME, \\\"Voting lock can be 3 years max\\\");\\r\\n\\r\\n        _deposit_for(msg.sender, 0, 0, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\\r\\n    }\\r\\n\\r\\n    /// @notice Extend the unlock time and/or for `msg.sender` to `_unlock_time`\\r\\n    /// @param _unlock_time New epoch time for unlocking\\r\\n    function increase_amount_and_time(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint _unlock_time\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        require((_valueA > 0 || _valueB > 0 || _valueC > 0) || _unlock_time > 0, \\\"Value and Unlock cannot both be 0\\\");\\r\\n        if ((_valueA > 0 || _valueB > 0 || _valueC > 0) && _unlock_time > 0) {\\r\\n            _increase_amount(_valueA, _valueB, _valueC);\\r\\n            _increase_unlock_time(_unlock_time);\\r\\n        } else if ((_valueA > 0 || _valueB > 0 || _valueC > 0) && _unlock_time == 0) {\\r\\n            _increase_amount(_valueA, _valueB, _valueC);\\r\\n        } else {\\r\\n            _increase_unlock_time(_unlock_time);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw all tokens for `msg.sender`\\r\\n    /// @dev Only possible if the lock has expired\\r\\n    function _withdraw() internal {\\r\\n        LockedBalance memory _locked = locked[msg.sender];\\r\\n        uint256 token_a_balance = _locked.amountA;\\r\\n        uint256 token_b_balance = _locked.amountB;\\r\\n        uint256 token_c_balance = _locked.amountC;\\r\\n        uint value = uint(int(_locked.amount));\\r\\n\\r\\n        if (!unlocked) {\\r\\n            require(block.timestamp >= _locked.end, \\\"The lock didn't expire\\\");\\r\\n        }\\r\\n\\r\\n        locked[msg.sender] = LockedBalance(0, 0, 0, 0, 0);\\r\\n        uint supply_before = supply;\\r\\n        supply = supply_before - value;\\r\\n\\r\\n        // old_locked can have either expired <= timestamp or zero end\\r\\n        // _locked has only 0 end\\r\\n        // Both can have >= 0 amount\\r\\n        _checkpoint(msg.sender, _locked, LockedBalance(0, 0, 0, 0, 0));\\r\\n\\r\\n        if(token_a_balance > 0) {\\r\\n            IERC20(tokenA).safeTransfer(msg.sender, token_a_balance);\\r\\n        }\\r\\n        if(token_b_balance > 0) {\\r\\n            IERC20(tokenB).safeTransfer(msg.sender, token_b_balance);\\r\\n        }\\r\\n        if(token_c_balance > 0) {\\r\\n            IERC20(tokenC).safeTransfer(msg.sender, token_c_balance);\\r\\n        }\\r\\n        emit Withdraw(msg.sender, token_a_balance, token_b_balance, token_c_balance, block.timestamp);\\r\\n        emit Supply(supply_before, supply_before - value);\\r\\n    }\\r\\n\\r\\n    function withdraw() external nonReentrant {\\r\\n        _withdraw();\\r\\n    }\\r\\n\\r\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\\r\\n    /// @param _valueA Amount to deposit of BPT\\r\\n    /// @param _valueB amount to deposit of pool2\\r\\n    /// @param _valueC amount to deposit of token\\r\\n    /// @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\\r\\n    function withdraw_and_create_lock(\\r\\n        uint _valueA,\\r\\n        uint _valueB,\\r\\n        uint _valueC,\\r\\n        uint _unlock_time\\r\\n    ) external nonReentrant onlyUserOrWhitelist notUnlocked {\\r\\n        _withdraw();\\r\\n        _create_lock(_valueA, _valueB, _valueC, _unlock_time);\\r\\n    }\\r\\n\\r\\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\\r\\n    // They measure the weights for the purpose of voting, so they don't represent\\r\\n    // real coins.\\r\\n\\r\\n    /// @notice Binary search to estimate timestamp for block number\\r\\n    /// @param _block Block to find\\r\\n    /// @param max_epoch Don't go beyond this epoch\\r\\n    /// @return Approximate timestamp for block\\r\\n    function _find_block_epoch(uint _block, uint max_epoch) internal view returns (uint) {\\r\\n        // Binary search\\r\\n        uint _min = 0;\\r\\n        uint _max = max_epoch;\\r\\n        for (uint i = 0; i < 128; ++i) {\\r\\n            // Will be always enough for 128-bit numbers\\r\\n            if (_min >= _max) {\\r\\n                break;\\r\\n            }\\r\\n            uint _mid = (_min + _max + 1) / 2;\\r\\n            if (point_history[_mid].blk <= _block) {\\r\\n                _min = _mid;\\r\\n            } else {\\r\\n                _max = _mid - 1;\\r\\n            }\\r\\n        }\\r\\n        return _min;\\r\\n    }\\r\\n\\r\\n    /// @notice Get the current voting power for `msg.sender`\\r\\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\r\\n    /// @param addr User wallet address\\r\\n    /// @param _t Epoch time to return voting power at\\r\\n    /// @return User voting power\\r\\n    function _balanceOf(address addr, uint _t) internal view returns (uint) {\\r\\n        uint _epoch = user_point_epoch[addr];\\r\\n        if (_epoch == 0) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            Point memory last_point = user_point_history[addr][_epoch];\\r\\n            last_point.bias -= last_point.slope * int128(int(_t) - int(last_point.ts));\\r\\n            if (last_point.bias < 0) {\\r\\n                last_point.bias = 0;\\r\\n            }\\r\\n            return uint(int(last_point.bias));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function balanceOfAtT(address addr, uint _t) external view returns (uint) {\\r\\n        return _balanceOf(addr, _t);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address addr) external view returns (uint) {\\r\\n        return _balanceOf(addr, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Measure voting power of `addr` at block height `_block`\\r\\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\\r\\n    /// @param addr User's wallet address\\r\\n    /// @param _block Block to calculate the voting power at\\r\\n    /// @return Voting power\\r\\n    function balanceOfAt(address addr, uint _block) external view returns (uint) {\\r\\n        // Copying and pasting totalSupply code because Vyper cannot pass by\\r\\n        // reference yet\\r\\n        require(_block <= block.number);\\r\\n\\r\\n        // Binary search\\r\\n        uint _min = 0;\\r\\n        uint _max = user_point_epoch[addr];\\r\\n        for (uint i = 0; i < 128; ++i) {\\r\\n            // Will be always enough for 128-bit numbers\\r\\n            if (_min >= _max) {\\r\\n                break;\\r\\n            }\\r\\n            uint _mid = (_min + _max + 1) / 2;\\r\\n            if (user_point_history[addr][_mid].blk <= _block) {\\r\\n                _min = _mid;\\r\\n            } else {\\r\\n                _max = _mid - 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Point memory upoint = user_point_history[addr][_min];\\r\\n\\r\\n        uint max_epoch = epoch;\\r\\n        uint _epoch = _find_block_epoch(_block, max_epoch);\\r\\n        Point memory point_0 = point_history[_epoch];\\r\\n        uint d_block = 0;\\r\\n        uint d_t = 0;\\r\\n        if (_epoch < max_epoch) {\\r\\n            Point memory point_1 = point_history[_epoch + 1];\\r\\n            d_block = point_1.blk - point_0.blk;\\r\\n            d_t = point_1.ts - point_0.ts;\\r\\n        } else {\\r\\n            d_block = block.number - point_0.blk;\\r\\n            d_t = block.timestamp - point_0.ts;\\r\\n        }\\r\\n        uint block_time = point_0.ts;\\r\\n        if (d_block != 0) {\\r\\n            block_time += (d_t * (_block - point_0.blk)) / d_block;\\r\\n        }\\r\\n\\r\\n        upoint.bias -= upoint.slope * int128(int(block_time - upoint.ts));\\r\\n        if (upoint.bias >= 0) {\\r\\n            return uint(uint128(upoint.bias));\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate total voting power at some point in the past\\r\\n    /// @param point The point (bias/slope) to start search from\\r\\n    /// @param t Time to calculate the total voting power at\\r\\n    /// @return Total voting power at that time\\r\\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\\r\\n        Point memory last_point = point;\\r\\n        uint t_i = (last_point.ts / WEEK) * WEEK;\\r\\n        for (uint i = 0; i < 255; ++i) {\\r\\n            t_i += WEEK;\\r\\n            int128 d_slope = 0;\\r\\n            if (t_i > t) {\\r\\n                t_i = t;\\r\\n            } else {\\r\\n                d_slope = slope_changes[t_i];\\r\\n            }\\r\\n            last_point.bias -= last_point.slope * int128(int(t_i - last_point.ts));\\r\\n            if (t_i == t) {\\r\\n                break;\\r\\n            }\\r\\n            last_point.slope += d_slope;\\r\\n            last_point.ts = t_i;\\r\\n        }\\r\\n\\r\\n        if (last_point.bias < 0) {\\r\\n            last_point.bias = 0;\\r\\n        }\\r\\n        return uint(uint128(last_point.bias));\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate total voting power\\r\\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\\r\\n    /// @return Total voting power\\r\\n    function _totalSupply(uint t) internal view returns (uint) {\\r\\n        uint _epoch = epoch;\\r\\n        Point memory last_point = point_history[_epoch];\\r\\n        return _supply_at(last_point, t);\\r\\n    }\\r\\n\\r\\n    function totalSupplyAtT(uint t) external view returns (uint) {\\r\\n        return _totalSupply(t);\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view returns (uint) {\\r\\n        return _totalSupply(block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate total voting power at some point in the past\\r\\n    /// @param _block Block to calculate the total voting power at\\r\\n    /// @return Total voting power at `_block`\\r\\n    function totalSupplyAt(uint _block) external view returns (uint) {\\r\\n        require(_block <= block.number);\\r\\n        uint _epoch = epoch;\\r\\n        uint target_epoch = _find_block_epoch(_block, _epoch);\\r\\n\\r\\n        Point memory point = point_history[target_epoch];\\r\\n        uint dt = 0;\\r\\n        if (target_epoch < _epoch) {\\r\\n            Point memory point_next = point_history[target_epoch + 1];\\r\\n            if (point.blk != point_next.blk) {\\r\\n                dt = ((_block - point.blk) * (point_next.ts - point.ts)) / (point_next.blk - point.blk);\\r\\n            }\\r\\n        } else {\\r\\n            if (point.blk != block.number) {\\r\\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\\r\\n            }\\r\\n        }\\r\\n        // Now dt contains info on how far are we beyond point\\r\\n        return _supply_at(point, point.ts + dt);\\r\\n    }\\r\\n\\r\\n    // Dummy methods for compatibility with Aragon\\r\\n    function changeController(address _newController) external {\\r\\n        require(msg.sender == controller);\\r\\n        controller = _newController;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": [\r\n      \"@prb/math/=lib/prb-math/src/\",\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"Common/=lib/Common/\",\r\n      \"ERC20/=lib/ERC20/\",\r\n      \"Governance/=lib/Governance/\",\r\n      \"Math/=lib/Math/\",\r\n      \"Staking/=lib/Staking/\",\r\n      \"Utils/=lib/Utils/\",\r\n      \"communal/=lib/communal/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"layerzerolabs/=lib/solidity-examples/\",\r\n      \"local/=src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin/\",\r\n      \"prb-math/=lib/prb-math/src/\",\r\n      \"prb-test/=lib/prb-math/lib/prb-test/src/\",\r\n      \"solidity-examples/=lib/solidity-examples/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=lib/prb-math/src/\"\r\n    ],\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ushPerSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vdUshPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oldGovFarm\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isBlocked\",\"type\":\"bool\"}],\"name\":\"BlockListUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vdUshLockPercentage\",\"type\":\"uint256\"}],\"name\":\"LockPercentageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"MatrixEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ushPerSec\",\"type\":\"uint256\"}],\"name\":\"RewardRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ushClaimed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vdUSHClaimed\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"enterMatrix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVdUshTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVdUshTotalSupplyInFarm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isInMatrix\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimVdUshBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"passGoAndCollect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"recoverUSH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vdUshPercentage\",\"type\":\"uint256\"}],\"name\":\"setLockPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBlocked\",\"type\":\"bool\"}],\"name\":\"updateBlockList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ushPerSec\",\"type\":\"uint256\"}],\"name\":\"updateRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ushPerSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vdUsh\",\"outputs\":[{\"internalType\":\"contract IvdUSH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vdUshPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GovernorsFarm", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000000000000000000000000000000066cc65bf6f6a00000000000000000000000000000000000000000000000004563918244f400000000000000000000000000000f04eab7928a24ff134b2e061e55c4844bd188017", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}