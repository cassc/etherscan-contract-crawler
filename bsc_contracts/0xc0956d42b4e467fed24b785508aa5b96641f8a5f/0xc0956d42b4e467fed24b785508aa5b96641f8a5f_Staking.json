{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWithdrawNFTByAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IWithdrawNFTByAdmin {\\n    function transferNftEmergency(address _receiver, uint256 _nftId) external;\\n\\n    function transferMultiNftsEmergency(address[] memory _receivers, uint256[] memory _nftIds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWithdrawTokenByAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IWithdrawTokenByAdmin {\\n    function recoverLostBNB() external;\\n\\n    function withdrawTokenEmergency(address _token, uint256 _amount) external;\\n\\n    function withdrawTokenEmergencyFrom(address _from, address _to, address _currency, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LowGasSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.0;\\n\\n/// @title Optimized overflow and underflow safe math operations\\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\\nlibrary LowGasSafeMath {\\n    /// @notice Returns x + y, reverts if sum overflows uint256\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x);\\n    }\\n\\n    /// @notice Returns x - y, reverts if underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x);\\n    }\\n\\n    /// @notice Returns x * y, reverts if overflows\\n    /// @param x The multiplicand\\n    /// @param y The multiplier\\n    /// @return z The product of x and y\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(x == 0 || (z = x * y) / x == y);\\n    }\\n\\n    /// @notice Returns x + y, reverts if overflows or underflows\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x + y) >= x == (y >= 0));\\n    }\\n\\n    /// @notice Returns x - y, reverts if overflows or underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x - y) <= x == (y >= 0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2 ** 255);\\n        z = int256(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/market/IMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IMarketplace {\\n    event Buy(address seller, address buyer, uint256 nftId);\\n    event Sell(address seller, address buyer, uint256 nftId);\\n    event ErrorLog(bytes message);\\n\\n    function buyByCurrency(uint256 _nftId, uint256 _refCode) external;\\n\\n    function buyByToken(uint256 _nftId, uint256 _refCode) external;\\n\\n    function getActiveMemberForAccount(address _wallet) external view returns (uint256);\\n\\n    function getReferredNftValueForAccount(address _wallet) external view returns (uint256);\\n\\n    function getNftCommissionEarnedForAccount(address _wallet) external view returns (uint256);\\n\\n    function getNftSaleValueForAccountInUsdDecimal(address _wallet) external view returns (uint256);\\n\\n    function getF1ListForAccount(address _wallet) external view returns (address[] memory);\\n\\n    function getTeamNftSaleValueForAccountInUsdDecimal(address _wallet) external view returns (uint256);\\n\\n    function updateReferralData(address _user, uint256 _refCode) external;\\n\\n    function possibleChangeReferralData(address _wallet) external returns (bool);\\n\\n    function checkValidRefCodeAdvance(address _user, uint256 _refCode) external view returns (bool);\\n\\n    function genReferralCodeForAccount() external returns (uint256);\\n\\n    function getReferralCodeForAccount(address _wallet) external view returns (uint256);\\n\\n    function getReferralAccountForAccount(address _user) external view returns (address);\\n\\n    function getReferralAccountForAccountExternal(address _user) external view returns (address);\\n\\n    function getAccountForReferralCode(uint256 _refCode) external view returns (address);\\n\\n    function getMaxEarnableCommission(address _user) external view returns (uint256);\\n\\n    function getTotalCommissionEarned(address _user) external view returns (uint256);\\n\\n    function getCommissionLimit(address _user) external view returns (uint256);\\n\\n    function getNftPaymentType(uint256 _nftId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/nft/IHREANFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IHREANFT is IERC721 {\\n    function getNftPriceUsd(uint256 _nftId) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function getNftTier(uint256 _nftId) external view returns (uint8);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IOracle {\\n    function convertUsdBalanceDecimalToTokenDecimal(uint256 _balanceUsdDecimal) external view returns (uint256);\\n\\n    function setUsdtAmount(uint256 _usdtAmount) external;\\n\\n    function setTokenAmount(uint256 _tokenAmount) external;\\n\\n    function setMinTokenAmount(uint256 _tokenAmount) external;\\n\\n    function setMaxTokenAmount(uint256 _tokenAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/stake/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IStaking {\\n    struct StakedNFT {\\n        address stakerAddress;\\n        uint256 startTime;\\n        uint256 unlockTime;\\n        uint256 lastClaimTime;\\n        uint256[] nftIds;\\n        uint256 totalValueStakeUsd;\\n        uint256 totalClaimedAmountUsdWithDecimal;\\n        uint256 totalRewardAmountUsdWithDecimal;\\n        uint32 apy;\\n        bool isUnstaked;\\n    }\\n\\n    event Staked(uint256 id, address indexed staker, uint256 indexed nftID, uint256 unlockTime, uint32 apy);\\n    event Unstaked(uint256 id, address indexed staker, uint256 indexed nftID);\\n    event Claimed(uint256 id, address indexed staker, uint256 claimAmount);\\n\\n    function getStakeApyForTier(uint8 _nftTier) external returns (uint32);\\n\\n    function getTotalCrewInvestment(address _wallet) external returns (uint256);\\n\\n    function getTeamStakingValue(address _wallet) external returns (uint256);\\n\\n    function getMaxEarnableCommission(address _user) external view returns (uint256);\\n\\n    function getTotalCommissionEarned(address _user) external view returns (uint256);\\n\\n    function getReferredStakedValue(address _wallet) external returns (uint256);\\n\\n    function getReferredStakedValueFull(address _wallet) external returns (uint256);\\n\\n    function getCurrentProfitLevel(address _wallet) external view returns (uint8);\\n\\n    function getProfitCommissionUnclaimed(address _wallet) external view returns (uint256);\\n\\n    function getProfitCommissionUnclaimedWithDeep(address _wallet, uint8 _deep) external view returns (uint256);\\n\\n    function getStakingCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getProfitCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getDirectCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getTotalStakingCommissionEarned(address _wallet) external view returns (uint256);\\n\\n    function getTotalStakeAmountUSD(address _staker) external view returns (uint256);\\n\\n    function getTotalStakeAmountUSDWithDecimal(address _staker) external view returns (uint256);\\n\\n    function getTotalStakeAmountUSDWithoutDecimal(address _staker) external view returns (uint256);\\n\\n    function stake(uint256[] memory _nftIds, uint256 _refCode) external;\\n\\n    function unstake(uint256 _stakeId) external;\\n\\n    function claim(uint256 _stakeId) external;\\n\\n    function claimAll(uint256[] memory _stakeIds) external;\\n\\n    function getDetailOfStake(uint256 _stakeId) external view returns (StakedNFT memory);\\n\\n    function possibleUnstake(uint256 _stakeId) external view returns (bool);\\n\\n    function claimableForStakeInUsdWithDecimal(uint256 _stakeId) external view returns (uint256);\\n\\n    function rewardUnstakeInTokenWithDecimal(uint256 _stakeId) external view returns (uint256);\\n\\n    function estimateValueUsdForListNft(uint256[] memory _nftIds) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/stake/IStakingMigrate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IStakingMigrate {\\n    function updateTotalStakingCommissionEarnedOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _values\\n    ) external;\\n\\n    function updateStakeExceptProfitOnlyOwner(uint256[] calldata _stakeIds, bool[] calldata _isExcepts) external;\\n\\n    function updateDirectCommissionEarnedOnlyOwner(address[] calldata _users, uint256[] calldata _values) external;\\n\\n    function updateStakingCommissionEarnedOnlyOwner(address[] calldata _users, uint256[] calldata _values) external;\\n\\n    function updateProfitCommissionEarnedOnlyOwner(address[] calldata _users, uint256[] calldata _values) external;\\n\\n    function updateTotalStakedAmountOnlyOwner(address[] calldata _users, uint256[] calldata _values) external;\\n\\n    function updateUserStakeIdListOnlyOwner(address _user, uint256[] calldata _value) external;\\n\\n    function createStakeOnlyOwner(\\n        address _stakerAddress,\\n        uint256 _startTime,\\n        uint256 _unlockTime,\\n        uint256 _lastClaimTime,\\n        uint256[] calldata _nftIds,\\n        uint256 _totalValueStakeUsd,\\n        uint256 _totalClaimedAmountUsdWithDecimal,\\n        uint256 _totalRewardAmountUsdWithDecimal,\\n        uint32 _apy,\\n        bool _isUnstaked\\n    ) external;\\n\\n    function updateStakeOnlyOwner(\\n        uint256 _stakeId,\\n        uint256 _lastClaimTime,\\n        uint256 _totalClaimedAmountUsdWithDecimal,\\n        bool _isUnstaked\\n    ) external;\\n\\n    function updateStakeInfoOnlyOwner(\\n        uint256 _stakeId,\\n        address _stakerAddress,\\n        uint256 _startTime,\\n        uint256 _unlockTime,\\n        uint256[] calldata _nftIds,\\n        uint256 _totalValueStakeUsd,\\n        uint256 _totalRewardAmountUsdWithDecimal,\\n        uint32 _apy\\n    ) external;\\n\\n    function removeStakeOnlyOwner(address _user, uint256[] memory _stakeIds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/stake/IStakingSetting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IStakingSetting {\\n    function setNftAddress(address _nft) external;\\n\\n    function setTokenAddress(address _token) external;\\n\\n    function setCurrencyAddress(address _currency) external;\\n\\n    function setMarketplaceContractAddress(address _marketplaceContract) external;\\n\\n    function setOracleAddress(address _oracleAddress) external;\\n\\n    function setContractOwner(address _newContractOwner) external;\\n\\n    function setTypePayDirectCom(uint8 _typePayDirectCom) external;\\n\\n    function setTypePayProfitCom(bool _typePayProfitCom) external;\\n\\n    function setTimeOpenStaking(uint256 _timeOpening) external;\\n\\n    function setStakingPeriod(uint256 _timeOpening) external;\\n\\n    function setStakeApyForTier(uint8 _nftTier, uint32 _apy) external;\\n\\n    function setDirectRewardCondition(uint8 _level, uint256 _valueInUsd, uint32 _percent) external;\\n\\n    function setProfitRewardCondition(uint8 _level, uint256 _valueInUsd, uint32 _percent) external;\\n\\n    function setStakeExceptProfit(uint256 _stakeId, bool _isExcept) external;\\n}\\n\"\r\n    },\r\n    \"contracts/stake/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport \\\"../libraries/LowGasSafeMath.sol\\\";\\nimport \\\"../libraries/SafeCast.sol\\\";\\nimport \\\"../interfaces/IWithdrawTokenByAdmin.sol\\\";\\nimport \\\"../interfaces/IWithdrawNFTByAdmin.sol\\\";\\nimport \\\"../oracle/IOracle.sol\\\";\\nimport \\\"../nft/IHREANFT.sol\\\";\\nimport \\\"../market/IMarketplace.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\nimport \\\"./IStakingMigrate.sol\\\";\\nimport \\\"./IStakingSetting.sol\\\";\\n\\ncontract Staking is\\n    IStaking,\\n    IStakingMigrate,\\n    IStakingSetting,\\n    Ownable,\\n    ERC721Holder,\\n    IWithdrawTokenByAdmin,\\n    IWithdrawNFTByAdmin\\n{\\n    using LowGasSafeMath for uint256;\\n    using SafeCast for uint256;\\n\\n    uint256 private constant TOKEN_DECIMAL = 1e18;\\n    uint256 private constant ONE_MONTH_SECONDS = 2592000;\\n    uint256 private constant ONE_YEAR_SECONDS = 31104000;\\n    bool private constant PAYMENT_TYPE_TOKEN = false;\\n    bool private constant PAYMENT_TYPE_USDT = true;\\n\\n    address private contractOwner;\\n\\n    address public nft;\\n    address public token;\\n    address public currency;\\n    address public marketplaceContract;\\n    address public oracleContract;\\n    uint256 public timeOpenStaking = 1693353600; // 2023-08-30\\n    uint256 public stakingPeriod = 24; // 24 month\\n    uint256 public profitRewardTime = 6; // 6 month\\n\\n    uint8 public typePayDirectCom = 2; // 0 is pay com by token, 1 is pay com by usdt, 2 is pay com by buy typePayCom\\n    bool public typePayProfitCom = false; // false is pay com by token, true is pay com by usdt\\n    bool private unlocked = true;\\n\\n    mapping(address => uint256) private totalStakingCommissionEarned; // With decimals\\n    mapping(address => uint256) private directCommissionEarned; // With decimals\\n    mapping(address => uint256) private stakingCommissionEarned; // With decimals\\n    mapping(address => uint256) private profitCommissionEarned; // With decimals\\n\\n    mapping(uint256 => StakedNFT) private stakedNFTs; // mapping to nftId to stake\\n    mapping(uint8 => uint32) private nftTierApys; // mapping to store commission percent, Percent * 100, ex: 100 = 1%\\n    mapping(uint8 => uint256) public directRewardConditions; // Without decimals\\n    mapping(uint8 => uint32) public directRewardPercents; // Percent * 100, ex: 100 = 1%\\n    mapping(uint8 => uint256) public profitRewardConditions; // Without decimals\\n    mapping(uint8 => uint32) public profitRewardPercents; // Percent * 100, ex: 100 = 1%\\n    mapping(uint256 => bool) public stakeExceptProfit;\\n\\n    mapping(address => uint256) private totalStakedAmount; // Without decimals\\n    mapping(address => uint256[]) private userStakeIdList;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private totalStakesCounter;\\n\\n    constructor(address _token, address _currency, address _nft, address _oracleContract, address _marketplace) {\\n        nft = _nft;\\n        token = _token;\\n        currency = _currency;\\n        contractOwner = _msgSender();\\n        oracleContract = _oracleContract;\\n        marketplaceContract = _marketplace;\\n        initStakeApy();\\n        initDirectRewardConditions();\\n        initDirectRewardPercents();\\n        initProfitRewardConditions();\\n        initProfitRewardPercents();\\n    }\\n\\n    modifier checkOwner() {\\n        require(owner() == _msgSender() || contractOwner == _msgSender(), \\\"STAKING: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier lock() {\\n        require(unlocked == true, \\\"STAKING: Locked\\\");\\n        unlocked = false;\\n        _;\\n        unlocked = true;\\n    }\\n\\n    modifier isTimeForStaking() {\\n        require(block.timestamp >= timeOpenStaking, \\\"STAKING: The staking has not yet started.\\\");\\n        _;\\n    }\\n\\n    function initStakeApy() internal {\\n        nftTierApys[1] = 10800;\\n        nftTierApys[2] = 10200;\\n        nftTierApys[3] = 9600;\\n        nftTierApys[4] = 9000;\\n        nftTierApys[5] = 8400;\\n        nftTierApys[6] = 7800;\\n        nftTierApys[7] = 7200;\\n        nftTierApys[8] = 6600;\\n        nftTierApys[9] = 3600;\\n        nftTierApys[10] = 3600;\\n    }\\n\\n    /**\\n     * @dev init condition to reward direct commission\\n     * level -> usdt max stake amount\\n     */\\n    function initDirectRewardConditions() internal {\\n        directRewardConditions[1] = 0;\\n        directRewardConditions[2] = 500;\\n        directRewardConditions[3] = 1000;\\n    }\\n\\n    /**\\n     * @dev init percent to reward direct commission\\n     * level -> percent to reward (percent * 10000)\\n     */\\n    function initDirectRewardPercents() internal {\\n        directRewardPercents[1] = 800;\\n        directRewardPercents[2] = 200;\\n        directRewardPercents[3] = 100;\\n    }\\n\\n    /**\\n     * @dev init commission level in the system\\n     */\\n    function initProfitRewardConditions() internal {\\n        profitRewardConditions[1] = 0;\\n        profitRewardConditions[2] = 500;\\n        profitRewardConditions[3] = 1000;\\n        profitRewardConditions[4] = 2000;\\n        profitRewardConditions[5] = 3000;\\n        profitRewardConditions[6] = 4000;\\n        profitRewardConditions[7] = 5000;\\n        profitRewardConditions[8] = 6000;\\n    }\\n\\n    /**\\n     * @dev init percent to reward profit commission\\n     * level -> percent to reward (percent * 10000)\\n     */\\n    function initProfitRewardPercents() internal {\\n        profitRewardPercents[1] = 1500;\\n        profitRewardPercents[2] = 1000;\\n        profitRewardPercents[3] = 500;\\n        profitRewardPercents[4] = 500;\\n        profitRewardPercents[5] = 400;\\n        profitRewardPercents[6] = 300;\\n        profitRewardPercents[7] = 200;\\n        profitRewardPercents[8] = 100;\\n    }\\n\\n    function getStakeApyForTier(uint8 _nftTier) external view override returns (uint32) {\\n        return nftTierApys[_nftTier];\\n    }\\n\\n    function getTotalStakeAmountUSD(address _staker) external view override returns (uint256) {\\n        return totalStakedAmount[_staker] * TOKEN_DECIMAL;\\n    }\\n\\n    function getTotalStakeAmountUSDWithDecimal(address _staker) external view override returns (uint256) {\\n        return totalStakedAmount[_staker] * TOKEN_DECIMAL;\\n    }\\n\\n    function getTotalStakeAmountUSDWithoutDecimal(address _staker) external view override returns (uint256) {\\n        return totalStakedAmount[_staker];\\n    }\\n\\n    function getDetailOfStake(uint256 _stakeId) external view returns (StakedNFT memory) {\\n        StakedNFT memory stakeInfo = stakedNFTs[_stakeId];\\n        return stakeInfo;\\n    }\\n\\n    function getTotalCrewInvestment(address _wallet) external view returns (uint256) {\\n        return getChildrenStakingValueInUsd(_wallet, 1, 100);\\n    }\\n\\n    function getTeamStakingValue(address _wallet) external view override returns (uint256) {\\n        uint256 teamStakingValue = getChildrenStakingValueInUsd(_wallet, 1, 10);\\n        return teamStakingValue;\\n    }\\n\\n    function getMaxEarnableCommission(address _user) public view override returns (uint256) {\\n        uint256 maxEarn = IMarketplace(marketplaceContract).getCommissionLimit(_user);\\n        uint256 earned = getTotalCommissionEarned(_user);\\n        if (maxEarn <= earned) {\\n            return 0;\\n        }\\n\\n        return maxEarn - earned;\\n    }\\n\\n    function getTotalCommissionEarned(address _user) public view override returns (uint256) {\\n        uint256 earned = IMarketplace(marketplaceContract).getNftCommissionEarnedForAccount(_user);\\n        earned += getTotalStakingCommissionEarned(_user);\\n\\n        return earned;\\n    }\\n\\n    function getReferredStakedValue(address _wallet) external view override returns (uint256) {\\n        address[] memory childrenUser = IMarketplace(marketplaceContract).getF1ListForAccount(_wallet);\\n        uint256 nftValue = 0;\\n        for (uint256 i = 0; i < childrenUser.length; i++) {\\n            address user = childrenUser[i];\\n            nftValue += totalStakedAmount[user];\\n        }\\n        return nftValue;\\n    }\\n\\n    function getReferredStakedValueFull(address _wallet) external view override returns (uint256) {\\n        uint256 teamStakingValue = getChildrenStakingValueInUsd(_wallet, 1, 5);\\n        return teamStakingValue;\\n    }\\n\\n    function getChildrenStakingValueInUsd(\\n        address _wallet,\\n        uint256 _deep,\\n        uint256 _maxDeep\\n    ) internal view returns (uint256) {\\n        if (_deep > _maxDeep) {\\n            return 0;\\n        }\\n\\n        uint256 nftValue = 0;\\n        address[] memory childrenUser = IMarketplace(marketplaceContract).getF1ListForAccount(_wallet);\\n\\n        if (childrenUser.length <= 0) {\\n            return 0;\\n        }\\n\\n        for (uint256 i = 0; i < childrenUser.length; i++) {\\n            address f1 = childrenUser[i];\\n            nftValue += totalStakedAmount[f1];\\n            nftValue += getChildrenStakingValueInUsd(f1, _deep + 1, _maxDeep);\\n        }\\n\\n        return nftValue;\\n    }\\n\\n    function getCurrentProfitLevel(address _wallet) public view override returns (uint8) {\\n        uint8 level = 1;\\n        for (; level <= 9; level++) {\\n            if (profitRewardConditions[level] > totalStakedAmount[_wallet]) {\\n                break;\\n            }\\n        }\\n\\n        return level - 1;\\n    }\\n\\n    function getProfitCommissionUnclaimed(address _wallet) external view override returns (uint256) {\\n        uint8 currentLevel = getCurrentProfitLevel(_wallet);\\n        if (currentLevel == 0) {\\n            return 0;\\n        }\\n\\n        return getProfitUnclaimed(_wallet, 1, currentLevel);\\n    }\\n\\n    function getProfitCommissionUnclaimedWithDeep(\\n        address _wallet,\\n        uint8 _deep\\n    ) external view override returns (uint256) {\\n        return getProfitUnclaimed(_wallet, 1, _deep);\\n    }\\n\\n    function getProfitUnclaimed(address _wallet, uint8 _deep, uint8 _maxDeep) internal view returns (uint256) {\\n        if (_deep > _maxDeep) {\\n            return 0;\\n        }\\n\\n        address[] memory childrenUser = IMarketplace(marketplaceContract).getF1ListForAccount(_wallet);\\n        uint256 totalCommissionUnclaim = 0;\\n        for (uint32 i = 0; i < childrenUser.length; i++) {\\n            uint256[] memory stakeIdList = userStakeIdList[childrenUser[i]];\\n            for (uint32 j = 0; j < stakeIdList.length; j++) {\\n                StakedNFT memory nftStake = stakedNFTs[stakeIdList[j]];\\n                if (nftStake.stakerAddress == childrenUser[i] && !nftStake.isUnstaked && !stakeExceptProfit[stakeIdList[j]]) {\\n                    totalCommissionUnclaim += calcClaimable(nftStake);\\n                }\\n            }\\n        }\\n\\n        uint32 profitRewardPercent = profitRewardPercents[_deep];\\n        uint256 totalProfitCommissionUnclaim = (totalCommissionUnclaim * profitRewardPercent) / 10000;\\n        if (_deep >= _maxDeep) {\\n            return totalProfitCommissionUnclaim;\\n        }\\n\\n        uint256 totalProfitCommissionUnclaimNextLevel = 0;\\n        for (uint32 i = 0; i < childrenUser.length; i++) {\\n            totalProfitCommissionUnclaimNextLevel += getProfitUnclaimed(childrenUser[i], _deep + 1, _maxDeep);\\n        }\\n\\n        return totalProfitCommissionUnclaim + totalProfitCommissionUnclaimNextLevel;\\n    }\\n\\n    function getStakingCommissionEarned(address _wallet) external view override returns (uint256) {\\n        return stakingCommissionEarned[_wallet];\\n    }\\n\\n    function getProfitCommissionEarned(address _wallet) external view override returns (uint256) {\\n        return profitCommissionEarned[_wallet];\\n    }\\n\\n    function getDirectCommissionEarned(address _wallet) external view override returns (uint256) {\\n        return directCommissionEarned[_wallet];\\n    }\\n\\n    function getTotalStakingCommissionEarned(address _wallet) public view override returns (uint256) {\\n        return totalStakingCommissionEarned[_wallet];\\n    }\\n\\n    /**\\n     * @dev Stake NFT function\\n     * @param _nftIds list NFT ID want to stake\\n     * @param _refCode referral code of ref account\\n     */\\n    function stake(uint256[] memory _nftIds, uint256 _refCode) public override isTimeForStaking lock {\\n        require(_nftIds.length > 0, \\\"STAKING: Invalid list NFT ID\\\");\\n        require(_nftIds.length <= 20, \\\"STAKING: Too many NFT in single stake action\\\");\\n        require(IHREANFT(nft).isApprovedForAll(msg.sender, address(this)), \\\"STAKING: Must approve first\\\");\\n        IMarketplace(marketplaceContract).updateReferralData(msg.sender, _refCode);\\n        uint32 baseApy = nftTierApys[IHREANFT(nft).getNftTier(_nftIds[0])];\\n        checkNftApySame(_nftIds, baseApy);\\n        stakeExecute(_nftIds, baseApy);\\n    }\\n\\n    function checkNftApySame(uint256[] memory _nftIds, uint32 baseApy) internal view {\\n        bool isValidNftArray = true;\\n        for (uint8 index = 1; index < _nftIds.length; index++) {\\n            uint8 nftTier = IHREANFT(nft).getNftTier(_nftIds[index]);\\n            uint32 currentApy = nftTierApys[nftTier];\\n            if (currentApy != baseApy) {\\n                isValidNftArray = false;\\n                break;\\n            }\\n        }\\n        require(isValidNftArray, \\\"STAKING: All NFT apy must be same\\\");\\n    }\\n\\n    function getTypePayComForNfts(uint256[] memory _nftIds) internal view returns (bool) {\\n        if (typePayDirectCom == 0) {\\n            return PAYMENT_TYPE_TOKEN;\\n        }\\n\\n        if (typePayDirectCom == 1) {\\n            return PAYMENT_TYPE_USDT;\\n        }\\n\\n        bool typePayCom = IMarketplace(marketplaceContract).getNftPaymentType(_nftIds[0]);\\n        for (uint8 index = 1; index < _nftIds.length; index++) {\\n            bool newTypePayCom = IMarketplace(marketplaceContract).getNftPaymentType(_nftIds[index]);\\n            require(typePayCom == newTypePayCom, \\\"STAKING: All NFT payment type must be same\\\");\\n        }\\n\\n        return typePayCom;\\n    }\\n\\n    function stakeExecute(uint256[] memory _nftIds, uint32 _apy) internal {\\n        uint256 nextCounter = nextStakeCounter();\\n        uint256 _stakingPeriod = stakingPeriod;\\n        uint256 totalAmountStakeUsd = estimateValueUsdForListNft(_nftIds);\\n        uint256 unlockTimeEstimate = block.timestamp + _stakingPeriod * ONE_MONTH_SECONDS;\\n        uint256 totalAmountStakeUsdWithDecimal = totalAmountStakeUsd * TOKEN_DECIMAL;\\n\\n        stakedNFTs[nextCounter].stakerAddress = msg.sender;\\n        stakedNFTs[nextCounter].startTime = block.timestamp;\\n        stakedNFTs[nextCounter].lastClaimTime = block.timestamp;\\n        stakedNFTs[nextCounter].unlockTime = unlockTimeEstimate;\\n        stakedNFTs[nextCounter].totalValueStakeUsd = totalAmountStakeUsd;\\n        stakedNFTs[nextCounter].nftIds = _nftIds;\\n        stakedNFTs[nextCounter].apy = _apy;\\n        stakedNFTs[nextCounter].totalRewardAmountUsdWithDecimal = calculateRewardInUsd(\\n            totalAmountStakeUsdWithDecimal,\\n            _stakingPeriod,\\n            _apy\\n        );\\n        totalStakedAmount[msg.sender] = totalStakedAmount[msg.sender] + totalAmountStakeUsd;\\n        userStakeIdList[msg.sender].push(nextCounter);\\n\\n        for (uint8 index = 0; index < _nftIds.length; index++) {\\n            IHREANFT(nft).safeTransferFrom(msg.sender, address(this), _nftIds[index], \\\"\\\");\\n            emit Staked(nextCounter, msg.sender, _nftIds[index], unlockTimeEstimate, _apy);\\n        }\\n\\n        bool typePayCom = getTypePayComForNfts(_nftIds);\\n        payDirectCommissionMultiLevels(totalAmountStakeUsdWithDecimal, typePayCom);\\n    }\\n\\n    /**\\n     * @param _totalAmountStakeUsdWithDecimal total amount stake in usd with decimal for this stake\\n     * @param _typePayCom token type pay commission: true = USDT, false = Token\\n     */\\n    function payDirectCommissionMultiLevels(uint256 _totalAmountStakeUsdWithDecimal, bool _typePayCom) internal {\\n        address currentRef = IMarketplace(marketplaceContract).getReferralAccountForAccountExternal(msg.sender);\\n        for (uint8 level = 1; level <= 3; level++) {\\n            if (currentRef == address(0)) {\\n                break;\\n            }\\n\\n            bool canReceive = canReceiveDirectCommission(currentRef, level);\\n            if (canReceive) {\\n                uint256 commissionInUsdWithDecimal = (_totalAmountStakeUsdWithDecimal * directRewardPercents[level]) /\\n                    10000;\\n                commissionInUsdWithDecimal = calcCommissionWithMaxEarn(currentRef, commissionInUsdWithDecimal);\\n                if (commissionInUsdWithDecimal > 0) {\\n                    directCommissionEarned[currentRef] += commissionInUsdWithDecimal;\\n                    payCommissions(currentRef, commissionInUsdWithDecimal, _typePayCom);\\n                    totalStakingCommissionEarned[currentRef] =\\n                        totalStakingCommissionEarned[currentRef] +\\n                        commissionInUsdWithDecimal;\\n                }\\n            }\\n            currentRef = IMarketplace(marketplaceContract).getReferralAccountForAccountExternal(currentRef);\\n        }\\n    }\\n\\n    /**\\n     * @dev unstake NFT function\\n     * @param _stakeId stake counter index\\n     */\\n    function unstake(uint256 _stakeId) public override {\\n        claim(_stakeId);\\n        handleUnstake(_stakeId);\\n    }\\n\\n    function handleUnstake(uint256 _stakeId) internal lock {\\n        require(possibleUnstake(_stakeId) == true, \\\"STAKING: STILL IN STAKING PERIOD\\\");\\n        require(stakedNFTs[_stakeId].stakerAddress == msg.sender, \\\"STAKING: You don't own this NFT\\\");\\n        StakedNFT memory stakeInfo = stakedNFTs[_stakeId];\\n        stakedNFTs[_stakeId].isUnstaked = true;\\n        totalStakedAmount[msg.sender] = totalStakedAmount[msg.sender] - stakeInfo.totalValueStakeUsd;\\n        for (uint8 index = 0; index < stakeInfo.nftIds.length; index++) {\\n            IHREANFT(nft).safeTransferFrom(address(this), stakeInfo.stakerAddress, stakeInfo.nftIds[index], \\\"\\\");\\n            emit Unstaked(_stakeId, stakeInfo.stakerAddress, stakeInfo.nftIds[index]);\\n        }\\n    }\\n\\n    /**\\n     * @dev claim reward function\\n     * @param _stakeId stake counter index\\n     */\\n    function claim(uint256 _stakeId) public override lock {\\n        StakedNFT memory stakeInfo = stakedNFTs[_stakeId];\\n        require(stakeInfo.stakerAddress == msg.sender, \\\"STAKING: Claim only your owner's stake\\\");\\n        require(block.timestamp > stakeInfo.startTime, \\\"STAKING: WRONG TIME TO CLAIM\\\");\\n        require(!stakeInfo.isUnstaked, \\\"STAKING: ALREADY UNSTAKED\\\");\\n\\n        uint256 claimableUsdtWithDecimal = calcClaimable(stakeInfo);\\n        if (claimableUsdtWithDecimal <= 0) {\\n            return;\\n        }\\n\\n        stakingCommissionEarned[msg.sender] += claimableUsdtWithDecimal;\\n        payCommissions(msg.sender, claimableUsdtWithDecimal, typePayProfitCom);\\n        emit Claimed(_stakeId, msg.sender, claimableUsdtWithDecimal);\\n        stakedNFTs[_stakeId].totalClaimedAmountUsdWithDecimal += claimableUsdtWithDecimal;\\n\\n        uint256 maxProfitRewardTime = stakeInfo.startTime + profitRewardTime * ONE_MONTH_SECONDS;\\n        if (stakeInfo.lastClaimTime < maxProfitRewardTime && !stakeExceptProfit[_stakeId]) {\\n            uint256 profitClaimTime = block.timestamp > maxProfitRewardTime ? maxProfitRewardTime : block.timestamp;\\n            uint256 profitClaimDuration = profitClaimTime - stakeInfo.lastClaimTime;\\n            uint256 totalDuration = stakeInfo.unlockTime - stakeInfo.startTime;\\n            uint256 profitUsdtWithDecimal = (profitClaimDuration * stakeInfo.totalRewardAmountUsdWithDecimal) /\\n                totalDuration;\\n            payProfitCommissionMultiLevels(profitUsdtWithDecimal);\\n        }\\n\\n        uint256 claimTime = block.timestamp > stakeInfo.unlockTime ? stakeInfo.unlockTime : block.timestamp;\\n        stakedNFTs[_stakeId].lastClaimTime = claimTime;\\n    }\\n\\n    /**\\n     * @dev function to pay commissions in 10 level\\n     * @param _totalAmountUsdWithDecimal total amount stake in usd with decimal for this stake\\n     */\\n    function payProfitCommissionMultiLevels(uint256 _totalAmountUsdWithDecimal) internal {\\n        address currentRef = IMarketplace(marketplaceContract).getReferralAccountForAccountExternal(msg.sender);\\n\\n        for (uint8 level = 1; level <= 8; level++) {\\n            if (currentRef == address(0)) {\\n                break;\\n            }\\n\\n            bool canReceive = canReceiveProfitCommission(currentRef, level);\\n            if (canReceive) {\\n                uint32 commissionPercent = profitRewardPercents[level];\\n                uint256 commissionInUsdWithDecimal = (_totalAmountUsdWithDecimal * commissionPercent) / 10000;\\n                commissionInUsdWithDecimal = calcCommissionWithMaxEarn(currentRef, commissionInUsdWithDecimal);\\n                if (commissionInUsdWithDecimal > 0) {\\n                    profitCommissionEarned[currentRef] += commissionInUsdWithDecimal;\\n                    payCommissions(currentRef, commissionInUsdWithDecimal, typePayProfitCom);\\n                    totalStakingCommissionEarned[currentRef] =\\n                        totalStakingCommissionEarned[currentRef] +\\n                        commissionInUsdWithDecimal;\\n                }\\n            }\\n            currentRef = IMarketplace(marketplaceContract).getReferralAccountForAccountExternal(currentRef);\\n        }\\n    }\\n\\n    /**\\n     * @dev claim reward function\\n     * @param _stakeIds stake counter index\\n     */\\n    function claimAll(uint256[] memory _stakeIds) public override {\\n        require(_stakeIds.length > 0, \\\"STAKING: INVALID STAKE LIST\\\");\\n        for (uint256 i = 0; i < _stakeIds.length; i++) {\\n            claim(_stakeIds[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev check unstake requesting is valid or not(still in locking)\\n     * @param _stakeId stake counter index\\n     */\\n    function possibleUnstake(uint256 _stakeId) public view returns (bool) {\\n        uint256 unlockTimestamp = stakedNFTs[_stakeId].unlockTime;\\n        return block.timestamp >= unlockTimestamp;\\n    }\\n\\n    /**\\n     * @dev function to calculate reward in USD based on staking time and period\\n     * @param _totalValueStakeUsd total value of stake (USD)\\n     * @param _stakingPeriod stake period\\n     * @param _apy apy\\n     */\\n    function calculateRewardInUsd(\\n        uint256 _totalValueStakeUsd,\\n        uint256 _stakingPeriod,\\n        uint32 _apy\\n    ) internal pure returns (uint256) {\\n        uint256 rewardInUsd = (_totalValueStakeUsd * _apy * _stakingPeriod) / (10000 * 12);\\n        return rewardInUsd;\\n    }\\n\\n    /**\\n     * @dev function to calculate claimable reward in Usd based on staking time and period\\n     */\\n    function claimableForStakeInUsdWithDecimal(uint256 _stakeId) public view override returns (uint256) {\\n        StakedNFT memory stakeInfo = stakedNFTs[_stakeId];\\n        uint256 rewardAmount = calcClaimable(stakeInfo);\\n        return rewardAmount;\\n    }\\n\\n    function calcClaimable(StakedNFT memory stakeInfo) internal view returns (uint256) {\\n        uint256 claimTime = block.timestamp > stakeInfo.unlockTime ? stakeInfo.unlockTime : block.timestamp;\\n        if (claimTime <= stakeInfo.lastClaimTime) {\\n            return 0;\\n        }\\n\\n        uint256 totalDuration = stakeInfo.unlockTime - stakeInfo.startTime;\\n        uint256 claimDuration = claimTime - stakeInfo.lastClaimTime;\\n        uint256 claimableUsdtWithDecimal = (claimDuration * stakeInfo.totalRewardAmountUsdWithDecimal) / totalDuration;\\n        return claimableUsdtWithDecimal;\\n    }\\n\\n    /**\\n     * @dev get & set stake counter\\n     */\\n    function nextStakeCounter() internal returns (uint256 _id) {\\n        totalStakesCounter.increment();\\n        return totalStakesCounter.current();\\n    }\\n\\n    /**\\n     * @dev function to calculate reward in Token based on staking time and period\\n     * @param _stakeId stake counter index\\n     */\\n    function rewardUnstakeInTokenWithDecimal(uint256 _stakeId) public view override returns (uint256) {\\n        uint256 rewardInUsdWithDecimal = stakedNFTs[_stakeId].totalRewardAmountUsdWithDecimal -\\n            stakedNFTs[_stakeId].totalClaimedAmountUsdWithDecimal;\\n        uint256 rewardInTokenWithDecimal = IOracle(oracleContract).convertUsdBalanceDecimalToTokenDecimal(\\n            rewardInUsdWithDecimal\\n        );\\n        return rewardInTokenWithDecimal;\\n    }\\n\\n    /**\\n     * @dev function to check the staked amount enough to get commission\\n     * @param _staker staker wallet address\\n     * @param _level commission level need to check condition\\n     */\\n    function canReceiveDirectCommission(address _staker, uint8 _level) internal view returns (bool) {\\n        return totalStakedAmount[_staker] >= directRewardConditions[_level];\\n    }\\n\\n    /**\\n     * @dev function to check the staked amount enough to get commission\\n     * @param _staker staker wallet address\\n     * @param _level commission level need to check condition\\n     */\\n    function canReceiveProfitCommission(address _staker, uint8 _level) internal view returns (bool) {\\n        return totalStakedAmount[_staker] >= profitRewardConditions[_level];\\n    }\\n\\n    function calcCommissionWithMaxEarn(address _receiver, uint256 _amountUsdDecimal) internal view returns (uint256) {\\n        uint256 maxEarnDecimal = getMaxEarnableCommission(_receiver);\\n        if (maxEarnDecimal < _amountUsdDecimal) {\\n            _amountUsdDecimal = maxEarnDecimal;\\n        }\\n\\n        return _amountUsdDecimal;\\n    }\\n\\n    function payCommissions(address _receiver, uint256 _amountUsdDecimal, bool _typePayCom) internal {\\n        if (_amountUsdDecimal <= 0) {\\n            return;\\n        }\\n\\n        if (_typePayCom == PAYMENT_TYPE_USDT) {\\n            safeTransferToken(_receiver, currency, _amountUsdDecimal);\\n        } else {\\n            uint256 commissionAmountInTokenDecimal = IOracle(oracleContract).convertUsdBalanceDecimalToTokenDecimal(\\n                _amountUsdDecimal\\n            );\\n            safeTransferToken(_receiver, token, commissionAmountInTokenDecimal);\\n        }\\n    }\\n\\n    function safeTransferToken(address _receiver, address _token, uint256 _amount) internal {\\n        require(IERC20(_token).balanceOf(address(this)) >= _amount, \\\"STAKING: Token balance not enough\\\");\\n        require(IERC20(_token).transfer(_receiver, _amount), \\\"STAKING: Unable transfer token to recipient\\\");\\n    }\\n\\n    /**\\n     * @dev estimate value in USD for a list of NFT\\n     * @param _nftIds user wallet address\\n     */\\n    function estimateValueUsdForListNft(uint256[] memory _nftIds) public view returns (uint256) {\\n        uint256 totalAmountStakeUsd = 0;\\n        for (uint8 index = 0; index < _nftIds.length; index++) {\\n            totalAmountStakeUsd += IHREANFT(nft).getNftPriceUsd(_nftIds[index]);\\n        }\\n        return totalAmountStakeUsd;\\n    }\\n\\n    // Config contract\\n    function setNftAddress(address _nft) external override checkOwner {\\n        nft = _nft;\\n    }\\n\\n    function setTokenAddress(address _token) external override checkOwner {\\n        token = _token;\\n    }\\n\\n    function setCurrencyAddress(address _currency) external override checkOwner {\\n        currency = _currency;\\n    }\\n\\n    function setMarketplaceContractAddress(address _marketplaceContract) external override checkOwner {\\n        marketplaceContract = _marketplaceContract;\\n    }\\n\\n    function setOracleAddress(address _oracleAddress) external override checkOwner {\\n        oracleContract = _oracleAddress;\\n    }\\n\\n    function setContractOwner(address _newContractOwner) external override checkOwner {\\n        contractOwner = _newContractOwner;\\n    }\\n\\n    // Setting\\n    function setTypePayDirectCom(uint8 _typePayDirectCom) external override checkOwner {\\n        typePayDirectCom = _typePayDirectCom;\\n    }\\n\\n    function setTypePayProfitCom(bool _typePayProfitCom) external override checkOwner {\\n        typePayProfitCom = _typePayProfitCom;\\n    }\\n\\n    function setTimeOpenStaking(uint256 _timeOpening) external override checkOwner {\\n        timeOpenStaking = _timeOpening;\\n    }\\n\\n    function setStakingPeriod(uint256 _stakingPeriod) external override checkOwner {\\n        stakingPeriod = _stakingPeriod;\\n    }\\n\\n    function setStakeApyForTier(uint8 _nftTier, uint32 _apy) external override checkOwner {\\n        nftTierApys[_nftTier] = _apy;\\n    }\\n\\n    function setDirectRewardCondition(uint8 _level, uint256 _valueInUsd, uint32 _percent) external override checkOwner {\\n        directRewardConditions[_level] = _valueInUsd;\\n        directRewardPercents[_level] = _percent;\\n    }\\n\\n    function setProfitRewardCondition(uint8 _level, uint256 _valueInUsd, uint32 _percent) external override checkOwner {\\n        profitRewardConditions[_level] = _valueInUsd;\\n        profitRewardPercents[_level] = _percent;\\n    }\\n\\n    function setStakeExceptProfit(uint256 _stakeId, bool _isExcept) external override checkOwner {\\n        stakeExceptProfit[_stakeId] = _isExcept;\\n    }\\n\\n    // Migrate\\n    function updateStakeExceptProfitOnlyOwner(uint256[] calldata _stakeIds, bool[] calldata _isExcepts) external override checkOwner {\\n        require(_stakeIds.length == _isExcepts.length, \\\"STAKING: _stakeIds and _isExcepts must be same size\\\");\\n        for (uint32 index = 0; index < _stakeIds.length; index++) {\\n            stakeExceptProfit[_stakeIds[index]] = _isExcepts[index];\\n        }\\n    }\\n\\n    function updateTotalStakingCommissionEarnedOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _values\\n    ) external override checkOwner {\\n        require(_users.length == _values.length, \\\"STAKING: _users and _values must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            totalStakingCommissionEarned[_users[index]] = _values[index];\\n        }\\n    }\\n\\n    function updateDirectCommissionEarnedOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _values\\n    ) external override checkOwner {\\n        require(_users.length == _values.length, \\\"STAKING: _users and _values must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            directCommissionEarned[_users[index]] = _values[index];\\n        }\\n    }\\n\\n    function updateStakingCommissionEarnedOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _values\\n    ) external override checkOwner {\\n        require(_users.length == _values.length, \\\"STAKING: _users and _values must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            stakingCommissionEarned[_users[index]] = _values[index];\\n        }\\n    }\\n\\n    function updateProfitCommissionEarnedOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _values\\n    ) external override checkOwner {\\n        require(_users.length == _values.length, \\\"STAKING: _users and _values must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            profitCommissionEarned[_users[index]] = _values[index];\\n        }\\n    }\\n\\n    function updateTotalStakedAmountOnlyOwner(\\n        address[] calldata _users,\\n        uint256[] calldata _values\\n    ) external override checkOwner {\\n        require(_users.length == _values.length, \\\"STAKING: _users and _values must be same size\\\");\\n        for (uint32 index = 0; index < _users.length; index++) {\\n            totalStakedAmount[_users[index]] = _values[index];\\n        }\\n    }\\n\\n    function updateUserStakeIdListOnlyOwner(address _user, uint256[] calldata _value) external override checkOwner {\\n        userStakeIdList[_user] = _value;\\n    }\\n\\n    function createStakeOnlyOwner(\\n        address _stakerAddress,\\n        uint256 _startTime,\\n        uint256 _unlockTime,\\n        uint256 _lastClaimTime,\\n        uint256[] calldata _nftIds,\\n        uint256 _totalValueStakeUsd,\\n        uint256 _totalClaimedAmountUsdWithDecimal,\\n        uint256 _totalRewardAmountUsdWithDecimal,\\n        uint32 _apy,\\n        bool _isUnstaked\\n    ) external override checkOwner lock {\\n        uint256 nextCounter = nextStakeCounter();\\n\\n        stakedNFTs[nextCounter].stakerAddress = _stakerAddress;\\n        stakedNFTs[nextCounter].startTime = _startTime;\\n        stakedNFTs[nextCounter].unlockTime = _unlockTime;\\n        stakedNFTs[nextCounter].lastClaimTime = _lastClaimTime;\\n        stakedNFTs[nextCounter].nftIds = _nftIds;\\n        stakedNFTs[nextCounter].totalValueStakeUsd = _totalValueStakeUsd;\\n        stakedNFTs[nextCounter].totalClaimedAmountUsdWithDecimal = _totalClaimedAmountUsdWithDecimal;\\n        stakedNFTs[nextCounter].totalRewardAmountUsdWithDecimal = _totalRewardAmountUsdWithDecimal;\\n        stakedNFTs[nextCounter].apy = _apy;\\n        stakedNFTs[nextCounter].isUnstaked = _isUnstaked;\\n\\n        totalStakedAmount[_stakerAddress] = totalStakedAmount[_stakerAddress] + _totalValueStakeUsd;\\n        userStakeIdList[_stakerAddress].push(nextCounter);\\n    }\\n\\n    function updateStakeOnlyOwner(\\n        uint256 _stakeId,\\n        uint256 _lastClaimTime,\\n        uint256 _totalClaimedAmountUsdWithDecimal,\\n        bool _isUnstaked\\n    ) external override checkOwner lock {\\n        stakedNFTs[_stakeId].lastClaimTime = _lastClaimTime;\\n        stakedNFTs[_stakeId].totalClaimedAmountUsdWithDecimal = _totalClaimedAmountUsdWithDecimal;\\n        stakedNFTs[_stakeId].isUnstaked = _isUnstaked;\\n    }\\n\\n    function updateStakeInfoOnlyOwner(\\n        uint256 _stakeId,\\n        address _stakerAddress,\\n        uint256 _startTime,\\n        uint256 _unlockTime,\\n        uint256[] calldata _nftIds,\\n        uint256 _totalValueStakeUsd,\\n        uint256 _totalRewardAmountUsdWithDecimal,\\n        uint32 _apy\\n    ) external override checkOwner lock {\\n        stakedNFTs[_stakeId].stakerAddress = _stakerAddress;\\n        stakedNFTs[_stakeId].startTime = _startTime;\\n        stakedNFTs[_stakeId].unlockTime = _unlockTime;\\n        stakedNFTs[_stakeId].nftIds = _nftIds;\\n        stakedNFTs[_stakeId].totalValueStakeUsd = _totalValueStakeUsd;\\n        stakedNFTs[_stakeId].totalRewardAmountUsdWithDecimal = _totalRewardAmountUsdWithDecimal;\\n        stakedNFTs[_stakeId].apy = _apy;\\n    }\\n\\n    function removeStakeOnlyOwner(address _user, uint256[] memory _stakeIds) external override checkOwner {\\n        require(_user != address(0), \\\"STAKING: Invalid staker\\\");\\n        require(_stakeIds.length > 0, \\\"STAKING: _stakeIds array must not be empty\\\");\\n        for (uint256 i = 0; i < _stakeIds.length; i++) {\\n            address staker = stakedNFTs[_stakeIds[i]].stakerAddress;\\n            require(staker == _user, \\\"STAKING: Mismatch staker\\\");\\n            delete stakedNFTs[_stakeIds[i]];\\n        }\\n    }\\n\\n    // Withdraw token\\n    function recoverLostBNB() external override checkOwner {\\n        address payable recipient = payable(msg.sender);\\n        recipient.transfer(address(this).balance);\\n    }\\n\\n    function withdrawTokenEmergency(address _token, uint256 _amount) external override checkOwner {\\n        require(_amount > 0, \\\"STAKING: INVALID AMOUNT\\\");\\n        require(IERC20(_token).balanceOf(address(this)) >= _amount, \\\"STAKING: TOKEN BALANCE NOT ENOUGH\\\");\\n        require(IERC20(_token).transfer(msg.sender, _amount), \\\"STAKING: CANNOT WITHDRAW TOKEN\\\");\\n    }\\n\\n    function withdrawTokenEmergencyFrom(\\n        address _from,\\n        address _to,\\n        address _token,\\n        uint256 _amount\\n    ) external override checkOwner {\\n        require(_amount > 0, \\\"STAKING: INVALID AMOUNT\\\");\\n        require(IERC20(_token).balanceOf(_from) >= _amount, \\\"STAKING: CURRENCY BALANCE NOT ENOUGH\\\");\\n        require(IERC20(_token).transferFrom(_from, _to, _amount), \\\"STAKING: CANNOT WITHDRAW CURRENCY\\\");\\n    }\\n\\n    function transferNftEmergency(address _receiver, uint256 _nftId) public override checkOwner {\\n        require(IHREANFT(nft).ownerOf(_nftId) == address(this), \\\"STAKING: NOT OWNER OF THIS NFT\\\");\\n        IHREANFT(nft).safeTransferFrom(address(this), _receiver, _nftId, \\\"\\\");\\n    }\\n\\n    function transferMultiNftsEmergency(\\n        address[] memory _receivers,\\n        uint256[] memory _nftIds\\n    ) external override checkOwner {\\n        require(_receivers.length == _nftIds.length, \\\"STAKING: MUST BE SAME SIZE\\\");\\n        for (uint256 index = 0; index < _nftIds.length; index++) {\\n            transferNftEmergency(_receivers[index], _nftIds[index]);\\n        }\\n    }\\n\\n    /**\\n     * @dev possible to receive any ERC20 tokens\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketplace\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_stakeIds\",\"type\":\"uint256[]\"}],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"claimableForStakeInUsdWithDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalValueStakeUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalClaimedAmountUsdWithDecimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalRewardAmountUsdWithDecimal\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_apy\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"_isUnstaked\",\"type\":\"bool\"}],\"name\":\"createStakeOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"directRewardConditions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"directRewardPercents\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"}],\"name\":\"estimateValueUsdForListNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getCurrentProfitLevel\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"getDetailOfStake\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalValueStakeUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedAmountUsdWithDecimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardAmountUsdWithDecimal\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isUnstaked\",\"type\":\"bool\"}],\"internalType\":\"struct IStaking.StakedNFT\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getDirectCommissionEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxEarnableCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getProfitCommissionEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getProfitCommissionUnclaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_deep\",\"type\":\"uint8\"}],\"name\":\"getProfitCommissionUnclaimedWithDeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getReferredStakedValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getReferredStakedValueFull\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_nftTier\",\"type\":\"uint8\"}],\"name\":\"getStakeApyForTier\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getStakingCommissionEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getTeamStakingValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTotalCommissionEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getTotalCrewInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getTotalStakeAmountUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getTotalStakeAmountUSDWithDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getTotalStakeAmountUSDWithoutDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getTotalStakingCommissionEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"possibleUnstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"profitRewardConditions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"profitRewardPercents\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverLostBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_stakeIds\",\"type\":\"uint256[]\"}],\"name\":\"removeStakeOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"rewardUnstakeInTokenWithDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContractOwner\",\"type\":\"address\"}],\"name\":\"setContractOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"setCurrencyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_valueInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_percent\",\"type\":\"uint32\"}],\"name\":\"setDirectRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketplaceContract\",\"type\":\"address\"}],\"name\":\"setMarketplaceContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"}],\"name\":\"setNftAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"name\":\"setOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_valueInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_percent\",\"type\":\"uint32\"}],\"name\":\"setProfitRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_nftTier\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_apy\",\"type\":\"uint32\"}],\"name\":\"setStakeApyForTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isExcept\",\"type\":\"bool\"}],\"name\":\"setStakeExceptProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingPeriod\",\"type\":\"uint256\"}],\"name\":\"setStakingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeOpening\",\"type\":\"uint256\"}],\"name\":\"setTimeOpenStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_typePayDirectCom\",\"type\":\"uint8\"}],\"name\":\"setTypePayDirectCom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_typePayProfitCom\",\"type\":\"bool\"}],\"name\":\"setTypePayProfitCom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_refCode\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeExceptProfit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeOpenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"}],\"name\":\"transferMultiNftsEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"transferNftEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typePayDirectCom\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typePayProfitCom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updateDirectCommissionEarnedOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updateProfitCommissionEarnedOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_stakeIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_isExcepts\",\"type\":\"bool[]\"}],\"name\":\"updateStakeExceptProfitOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalValueStakeUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalRewardAmountUsdWithDecimal\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_apy\",\"type\":\"uint32\"}],\"name\":\"updateStakeInfoOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalClaimedAmountUsdWithDecimal\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isUnstaked\",\"type\":\"bool\"}],\"name\":\"updateStakeOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updateStakingCommissionEarnedOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updateTotalStakedAmountOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updateTotalStakingCommissionEarnedOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"updateUserStakeIdListOnlyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenEmergencyFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e5e0ebb9982ccb9c6e46efee69cbe02ddeb6fcdd00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000eb5ac83d637c7c788ae5db5b42d274c6810c15b90000000000000000000000000a165c14e00ba2f5904e48cb7528dec363bb44ea000000000000000000000000d67e21d14c146d4d415abb4033c5f8ae5c8a7b53", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}