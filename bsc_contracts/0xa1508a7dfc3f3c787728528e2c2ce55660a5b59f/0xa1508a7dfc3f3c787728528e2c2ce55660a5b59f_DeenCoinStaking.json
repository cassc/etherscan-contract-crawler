{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.15;\r\n\r\nlibrary SafeMath {\r\n\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract DeenCoinStaking is Ownable, ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n    IERC20 public DeenCoin;\r\n\r\n    uint256 public SAPY = 1500;\r\n    uint256 public PoolStartTime;\r\n    uint256 public totalStaked;\r\n    uint256 public totalUnstaked;\r\n    uint256 public totalDistributed;\r\n    uint256 public totalAmountDistributed;\r\n    uint256 public StakersCount;\r\n\r\n    struct StakedRec {\r\n        uint256 _amount;\r\n        uint256 _apy;\r\n        uint256 _startTime;\r\n        uint256 _endTime;    //in seconds\r\n        uint256 _perSecReward;\r\n        uint256 _perSecAmount;\r\n        uint256 _claimedReward;\r\n        uint256 _claimedAmount;\r\n        uint256 _totalReward;\r\n    }\r\n\r\n    struct pool {\r\n        address _user;\r\n        uint256 _totalStaked;\r\n        uint256 _totalWithdraw;\r\n        uint256 _totalClaimed;\r\n        uint256 _totalAmounts;\r\n        StakedRec[] _Ledger;\r\n    }\r\n    mapping (address => pool) public _stakers;\r\n    bool public paused;\r\n    bool public wpaused;\r\n    bool public without_staked = true;\r\n\r\n    struct Account {\r\n        address referrer;\r\n        uint reward;\r\n        uint referredCount;\r\n    }\r\n\r\n    struct ReferralHistory{\r\n        address from;\r\n        uint256 depositAmount;\r\n        uint256 referralAmount;\r\n        uint256 timestamp;\r\n    }\r\n      \r\n    uint256[] levelRate = [1000,300,200];\r\n    uint public minReward = 1;\r\n    mapping(address => Account) public accounts;\r\n    mapping(address => mapping( uint256 => ReferralHistory[])) public userReferrals;\r\n    address public defaultRef =  0xcA1827068d04501bcFc6B4EcF2c9B8C30c316226;\r\n    mapping(address => mapping (address => bool)) private teamMember;\r\n    mapping(uint => mapping(address => uint)) public team;\r\n\r\n    constructor() {\r\n        PoolStartTime = block.timestamp;\r\n        DeenCoin = IERC20(0x532A252F457BB04127e01cEBe9bF394b93283999);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    event RegisteredReferer(address referee, address referrer);\r\n    event RegisteredRefererFailed(address referee, address referrer, string reason);\r\n    event PaidReferral(address from, address to, uint amount, uint level);\r\n    event Staked (\r\n        address indexed _user,\r\n        uint256 indexed _amount,\r\n        uint256 _timestamp,\r\n        uint256 _apy\r\n    );\r\n\r\n    event Claimed (\r\n        address indexed _user,\r\n        uint256 indexed _amount,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    function stake(uint _amount,uint _duration,address _referrer) public nonReentrant() {\r\n        require(!paused,\"Error: Staking is Currently Paused Now!!\");\r\n        address account = msg.sender;\r\n        DeenCoin.transferFrom(account, address(this), _amount);\r\n        uint staked = userTotalStaked(account);\r\n        if(staked == 0) {\r\n            _stakers[account]._user = account;\r\n            StakersCount++;\r\n        }\r\n        if(!hasReferrer(msg.sender)) {\r\n            uint ref_staked = userTotalStaked(_referrer);\r\n            if(_referrer == address(0)){ \r\n                addReferrer(defaultRef);\r\n            }\r\n            else if(ref_staked == 0 && without_staked){\r\n                addReferrer(_referrer);\r\n            }\r\n            else if(ref_staked > 0){\r\n                addReferrer(_referrer);\r\n            }\r\n            else{\r\n                addReferrer(defaultRef);\r\n            }\r\n        }\r\n\r\n        payReferral(_amount);\r\n        uint256 _runningApy = getApy();\r\n        uint endT = block.timestamp.add(_duration);\r\n        (uint aPersec , uint rPersec , uint _tr) = perSecR(_amount, _runningApy, _duration);\r\n        StakedRec memory _rec = \r\n                StakedRec(\r\n                    _amount,\r\n                    _runningApy,\r\n                    block.timestamp,\r\n                    endT,\r\n                    rPersec,\r\n                    aPersec,\r\n                    0,\r\n                    0,\r\n                    _tr\r\n                );\r\n        _stakers[account]._Ledger.push(_rec);\r\n        _stakers[account]._totalStaked += _amount;\r\n        totalStaked += _amount;\r\n        emit Staked(account,_amount,block.timestamp,_runningApy);\r\n    }\r\n\r\n    function claim(uint _index) public nonReentrant() {\r\n        require(!wpaused,\"Error: Staking is Currently Paused Now!!\");\r\n        address account = msg.sender;\r\n\r\n        errorCatch(account,_index);\r\n\r\n        uint length = _stakers[account]._Ledger.length;\r\n        StakedRec memory arr = _stakers[account]._Ledger[_index];\r\n\r\n        uint reward = 0;\r\n        uint amount = 0;\r\n        uint total = 0;\r\n        if(block.timestamp >= arr._endTime){\r\n            reward =  arr._totalReward.sub(arr._claimedReward);\r\n            amount = arr._amount.sub(arr._claimedAmount);\r\n            total = amount.add(reward);\r\n            totalUnstaked += amount;\r\n            _stakers[account]._totalAmounts += amount;\r\n            _stakers[account]._totalClaimed += reward;\r\n            _stakers[account]._totalWithdraw += arr._amount;\r\n            _stakers[account]._Ledger[_index] = _stakers[account]._Ledger[length - 1];\r\n            _stakers[account]._Ledger.pop();\r\n        }\r\n        else{\r\n            uint timeTill = calTime(arr._startTime);\r\n            reward =  (timeTill.mul(arr._perSecReward)).sub(arr._claimedReward);\r\n            amount =  (timeTill.mul(arr._perSecAmount)).sub(arr._claimedAmount);\r\n            uint minimumR = arr._amount.mul(minReward).div(10000);\r\n            total = amount.add(reward);\r\n            require( total >= minimumR , \"claim not allowed, minimum reward needed.\");\r\n            _stakers[account]._Ledger[_index]._claimedAmount += amount;\r\n            _stakers[account]._Ledger[_index]._claimedReward += reward;\r\n            _stakers[account]._totalAmounts += amount;\r\n            _stakers[account]._totalClaimed += reward;\r\n        }\r\n\r\n        totalAmountDistributed += amount;\r\n        totalDistributed += reward;\r\n\r\n        DeenCoin.transfer(account, total);\r\n        emit Claimed(account,total,block.timestamp);\r\n    }\r\n\r\n\r\n    function errorCatch(address account, uint _index) internal view {\r\n        uint length = _stakers[account]._Ledger.length;\r\n        if(_stakers[account]._totalStaked == 0) {\r\n            revert(\"Error: No Amount Staked at this time!!\");\r\n        }\r\n        if(_index > length - 1) {\r\n            revert(\"Error: Invalid Index!\");\r\n        }\r\n    }\r\n\r\n    function slotRevenue(address _adr, uint _index) external view returns (uint,bool) {\r\n        uint length = _stakers[_adr]._Ledger.length;\r\n        if(length == 0) revert(\"Error: No Record Found\");\r\n        StakedRec memory arr = _stakers[_adr]._Ledger[_index];\r\n        uint reward = 0;\r\n        uint amount = 0;\r\n        uint total = 0;\r\n        bool allowed = false;\r\n        if(block.timestamp >= arr._endTime){\r\n            reward =  arr._totalReward.sub(arr._claimedReward);\r\n            amount = arr._amount.sub(arr._claimedAmount);\r\n            total = amount.add(reward);\r\n            allowed = true;\r\n        }\r\n        else{\r\n            uint timeTill = calTime(arr._startTime);\r\n            reward =  (timeTill.mul(arr._perSecReward)).sub(arr._claimedReward);\r\n            amount =  (timeTill.mul(arr._perSecAmount)).sub(arr._claimedAmount);\r\n            uint minimumR = arr._amount.mul(minReward).div(10000);\r\n            total = amount.add(reward);\r\n            if(total >= minimumR){\r\n                allowed = true;\r\n            }\r\n        }\r\n\r\n        return (total,allowed);\r\n    }\r\n\r\n    function userTotalStaked(address _user) internal view returns (uint){\r\n        uint total =  _stakers[_user]._totalStaked - _stakers[_user]._totalWithdraw;\r\n        return total;\r\n    }\r\n\r\n    function userReferral(address _address , uint _level) external view returns(ReferralHistory[] memory){\r\n        uint length = userReferrals[_address][_level].length;\r\n        ReferralHistory[] memory rh = new ReferralHistory[](length);\r\n        for(uint i=0;i<length;i++){\r\n            rh[i] = userReferrals[_address][_level][i];\r\n        }\r\n\r\n        return rh;\r\n    } \r\n\r\n    function getList(address _account) external view returns (StakedRec[] memory _rec, uint _size) {\r\n        return (_stakers[_account]._Ledger, _stakers[_account]._Ledger.length);\r\n    }\r\n\r\n    function getLedgerIndex(address _account,uint _index) external view returns (StakedRec memory _rec) {\r\n        uint length = _stakers[_account]._Ledger.length;\r\n        if(length == 0) revert(\"Error: No Record Found\");\r\n        if(_index > length - 1) {\r\n            revert(\"Error: Invalid Index!\");\r\n        }\r\n        StakedRec memory arr = _stakers[_account]._Ledger[_index];\r\n        return arr;\r\n    }\r\n\r\n    function calTime(uint _timer) internal view returns (uint) {\r\n        return _timer == 0 ? 0 : block.timestamp.sub(_timer);\r\n    }\r\n\r\n    function perSecR(uint _amount, uint apy, uint _stakeTime) internal view returns (uint,uint,uint) {\r\n        uint totalReward = (_amount.mul(apy).mul(_stakeTime)).div(365*86400*10000);\r\n        uint aPersec = _amount.div(_stakeTime);\r\n        uint rPersec = totalReward.div(_stakeTime);\r\n        return (aPersec , rPersec , totalReward);\r\n    }\r\n\r\n    function getApy() public view returns (uint256) {\r\n        return SAPY;\r\n    }\r\n\r\n    function getBalance() external view returns (uint256) {\r\n        return DeenCoin.balanceOf(address(this));\r\n    }\r\n\r\n    function setDeenCoin(address _token) external onlyOwner {\r\n        DeenCoin = IERC20(_token);\r\n    }\r\n\r\n    function setWithoutstaked(bool _without_staked) external onlyOwner {\r\n        without_staked = _without_staked;\r\n    }\r\n\r\n    function setPauser(bool _status) external onlyOwner {\r\n        require(paused != _status,\"Error: Not Changed!\");\r\n        paused = _status;\r\n    }\r\n\r\n    function setWPauser(bool _status) external onlyOwner {\r\n        require(wpaused != _status,\"Error: Not Changed!\");\r\n        wpaused = _status;\r\n    }\r\n\r\n    function rescueFunds() external onlyOwner {\r\n        (bool os,) = payable(owner()).call{value: address(this).balance}(\"\");\r\n        require(os);\r\n    }\r\n\r\n    function rescueToken(address _token) external onlyOwner {\r\n        uint balance = IERC20(_token).balanceOf(address(this));\r\n        IERC20(_token).transfer(owner(),balance);\r\n    }\r\n\r\n    function setSAPY(uint256 _apy) public onlyOwner{\r\n        SAPY = _apy;\r\n    }\r\n\r\n    function setLevelRate(uint256[] memory _levelRate) public onlyOwner{\r\n        levelRate = _levelRate;\r\n    }\r\n\r\n    function setminReward(uint256 _minReward) public onlyOwner{\r\n        minReward = _minReward;\r\n    }\r\n\r\n    function setDefaultRef(address _refAddress) public onlyOwner{\r\n        defaultRef = _refAddress;\r\n    }\r\n\r\n    function sum(uint[] memory data) public pure returns (uint) {\r\n        uint S;\r\n        for(uint i;i < data.length;i++) {\r\n            S += data[i];\r\n        }\r\n        return S;\r\n    }\r\n\r\n    function hasReferrer(address addr) public view returns(bool){\r\n        return accounts[addr].referrer != address(0);\r\n    }\r\n\r\n    function getTime() public view returns(uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    function isCircularReference(address referrer, address referee) internal view returns(bool){\r\n        address parent = referrer;\r\n\r\n        for (uint i; i < levelRate.length; i++) {\r\n            if (parent == address(0)) {\r\n                break;\r\n            }\r\n\r\n            if (parent == referee) {\r\n                return true;\r\n            }\r\n\r\n            parent = accounts[parent].referrer;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function addReferrer(address referrer) internal returns(bool){\r\n        if (referrer == address(0)) {\r\n            emit RegisteredRefererFailed(msg.sender, referrer, \"Referrer cannot be 0x0 address\");\r\n            return false;\r\n        } else if (isCircularReference(referrer, msg.sender)) {\r\n            emit RegisteredRefererFailed(msg.sender, referrer, \"Referee cannot be one of referrer uplines\");\r\n            return false;\r\n        } else if (accounts[msg.sender].referrer != address(0)) {\r\n            emit RegisteredRefererFailed(msg.sender, referrer, \"Address have been registered upline\");\r\n            return false;\r\n        }\r\n\r\n        Account storage userAccount = accounts[msg.sender];\r\n        Account storage parentAccount = accounts[referrer];\r\n        userAccount.referrer = referrer;\r\n        parentAccount.referredCount = parentAccount.referredCount.add(1);\r\n\r\n        emit RegisteredReferer(msg.sender, referrer);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function payReferral(uint256 value) internal returns(uint256){\r\n       Account memory userAccount = accounts[msg.sender];\r\n        uint totalReferal;\r\n\r\n        for (uint i; i < levelRate.length; i++) {\r\n            address parent = userAccount.referrer;\r\n            Account storage parentAccount = accounts[userAccount.referrer];\r\n\r\n            if (parent == address(0)) {\r\n                break;\r\n            }\r\n\r\n            uint c = value.mul(levelRate[i]).div(10000);\r\n            totalReferal = totalReferal.add(c);\r\n            \r\n            parentAccount.reward = parentAccount.reward.add(c);\r\n            if(!teamMember[parent][msg.sender]){\r\n                team[i][parent] += 1; \r\n            }\r\n            userReferrals[parent][i].push(ReferralHistory(\r\n                msg.sender,\r\n                value,\r\n                c,\r\n                block.timestamp\r\n            ));\r\n            IERC20(DeenCoin).transfer(parent,c);\r\n            emit PaidReferral(msg.sender, parent, c, i + 1);\r\n            userAccount = parentAccount;\r\n        }\r\n        \r\n        return totalReferal;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"PaidReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegisteredReferer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"RegisteredRefererFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DeenCoin\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PoolStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StakersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalAmounts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referredCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLedgerIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perSecReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perSecAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"internalType\":\"struct DeenCoinStaking.StakedRec\",\"name\":\"_rec\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perSecReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perSecAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"internalType\":\"struct DeenCoinStaking.StakedRec[]\",\"name\":\"_rec\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasReferrer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setDeenCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refAddress\",\"type\":\"address\"}],\"name\":\"setDefaultRef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_levelRate\",\"type\":\"uint256[]\"}],\"name\":\"setLevelRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"}],\"name\":\"setSAPY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_without_staked\",\"type\":\"bool\"}],\"name\":\"setWithoutstaked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minReward\",\"type\":\"uint256\"}],\"name\":\"setminReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"slotRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"sum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"team\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmountDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUnstaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"userReferral\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DeenCoinStaking.ReferralHistory[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userReferrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"without_staked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wpaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DeenCoinStaking", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e60a5b92b3079a330d54a397e27309dd56217d70e7bc3f5a12335cbe9a729306"}