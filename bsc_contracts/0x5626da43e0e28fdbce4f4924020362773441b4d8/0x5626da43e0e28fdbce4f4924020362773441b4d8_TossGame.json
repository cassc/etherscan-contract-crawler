{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nabstract contract VRFConsumerBaseV2 {\r\n  error OnlyCoordinatorCanFulfill(address have, address want);\r\n  address private immutable vrfCoordinator;\r\n\r\n  constructor(address _vrfCoordinator) {\r\n    vrfCoordinator = _vrfCoordinator;\r\n  }\r\n\r\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\r\n\r\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\r\n    if (msg.sender != vrfCoordinator) {\r\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\r\n    }\r\n    fulfillRandomWords(requestId, randomWords);\r\n  }\r\n}\r\n\r\ninterface VRFCoordinatorV2Interface {\r\n\r\n    function getRequestConfig()\r\n      external\r\n      view\r\n      returns (\r\n        uint16,\r\n        uint32,\r\n        bytes32[] memory\r\n      );\r\n\r\n    function requestRandomWords(\r\n      bytes32 keyHash,\r\n      uint64 subId,\r\n      uint16 minimumRequestConfirmations,\r\n      uint32 callbackGasLimit,\r\n      uint32 numWords\r\n    ) external returns (uint256 requestId);\r\n  \r\n    function createSubscription() external returns (uint64 subId);\r\n  \r\n    function getSubscription(uint64 subId)\r\n      external\r\n      view\r\n      returns (\r\n        uint96 balance,\r\n        uint64 reqCount,\r\n        address owner,\r\n        address[] memory consumers\r\n      );\r\n  \r\n    function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\r\n  \r\n    function acceptSubscriptionOwnerTransfer(uint64 subId) external;\r\n  \r\n    function addConsumer(uint64 subId, address consumer) external;\r\n  \r\n    function removeConsumer(uint64 subId, address consumer) external;\r\n  \r\n    function cancelSubscription(uint64 subId, address to) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract Pausable is Context {\r\n\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\r\n        }\r\n        return results;\r\n    }\r\n}\r\n\r\nabstract contract Game is Ownable, Pausable, Multicall, VRFConsumerBaseV2 {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct Bet {\r\n        bool resolved;\r\n        address payable user;\r\n        address token;\r\n        uint256 randomNumber;\r\n        uint256 amount;\r\n        uint256 blockNumber;\r\n        uint256 rolled;\r\n        bool result;\r\n        uint256 payout;\r\n    }\r\n\r\n    struct ChainlinkConfig {\r\n        uint64 subId;\r\n        uint32 callbackGasLimit;\r\n        uint16 requestConfirmations;\r\n        bytes32 keyHash;\r\n    }\r\n\r\n    struct BetResult {\r\n        uint256 randomNumber;\r\n    }\r\n\r\n    BetResult[] public betResults;\r\n    mapping(address => uint256) public totalBetAmount;\r\n\r\n    ChainlinkConfig public chainlinkConfig;\r\n    VRFCoordinatorV2Interface public chainlinkCoordinator;\r\n    uint16 private immutable _numRandomWords;\r\n    mapping(uint256 => Bet) public bets;\r\n    mapping(address => uint256[]) internal _userBets;\r\n    mapping(address => uint256) public tokensMinBetAmount;\r\n    mapping(address => uint256) public tokensMaxBetAmount;\r\n\r\n    event SetTokenBetAmount(address indexed token, uint256 minBetAmount, uint256 maxBetAmount);\r\n    event BetRefunded(uint256 randomNumber, address user, uint256 amount);\r\n    error WrongBetAmount(address token, uint256 value);\r\n    error NotPendingBet(uint256 randomNumber);\r\n    error NotFulfilled(uint256 randomNumber);\r\n\r\n    constructor(address chainlinkCoordinatorAddress, uint16 numRandomWords) VRFConsumerBaseV2(chainlinkCoordinatorAddress) {\r\n        chainlinkCoordinator = VRFCoordinatorV2Interface(\r\n            chainlinkCoordinatorAddress\r\n        );\r\n        _numRandomWords = numRandomWords;\r\n    }\r\n\r\n    function getTotalBets() external view returns (uint256) {\r\n        return betResults.length;\r\n    }\r\n\r\n    function _newBet(address token,uint256 tokenAmount) internal whenNotPaused returns (Bet memory) {\r\n        \r\n        uint256 betAmount = tokenAmount;\r\n        if (betAmount < tokensMinBetAmount[token] || betAmount > tokensMaxBetAmount[token]) {\r\n            revert WrongBetAmount(token, betAmount);\r\n        }\r\n\r\n        // Create bet\r\n        address user = msg.sender;\r\n        uint256 randomNumber = chainlinkCoordinator.requestRandomWords(\r\n            chainlinkConfig.keyHash,\r\n            chainlinkConfig.subId,\r\n            chainlinkConfig.requestConfirmations,\r\n            chainlinkConfig.callbackGasLimit,\r\n            _numRandomWords\r\n        );\r\n        Bet memory newBet = Bet(false, payable(user), token, randomNumber, betAmount, block.number, 2, false, 0);\r\n        totalBetAmount[token] += betAmount;\r\n        _userBets[user].push(randomNumber);\r\n        betResults.push(BetResult({randomNumber: randomNumber}));\r\n        bets[randomNumber] = newBet;\r\n        IERC20(token).safeTransferFrom(user, address(this), betAmount);\r\n        return newBet;\r\n    }\r\n\r\n    function _resolveBet(Bet storage bet, bool wins, uint256 rolled, uint256 payout) internal returns (uint256) {\r\n        address payable user = bet.user;\r\n        if (bet.resolved == true || user == address(0)) {\r\n            revert NotPendingBet(bet.randomNumber);\r\n        }\r\n        address token = bet.token;\r\n\r\n        bet.resolved = true;\r\n        bet.rolled = rolled;\r\n        bet.result = wins;        \r\n\r\n        // Check for the result\r\n        if (wins) {\r\n            bet.payout = payout;\r\n            IERC20(token).transfer(user, payout);\r\n        }\r\n        \r\n        return payout;\r\n    }\r\n\r\n    function _getLastUserBets(address user, uint256 dataLength) internal view returns (Bet[] memory) {\r\n        uint256[] memory userBetsIds = _userBets[user];\r\n        uint256 betsLength = userBetsIds.length;\r\n\r\n        if (betsLength < dataLength) {\r\n            dataLength = betsLength;\r\n        }\r\n\r\n        Bet[] memory userBets = new Bet[](dataLength);\r\n        if (dataLength > 0) {\r\n            uint256 userBetsIndex = 0;\r\n            for (uint256 i = betsLength; i > betsLength - dataLength; i--) {\r\n                userBets[userBetsIndex] = bets[userBetsIds[i - 1]];\r\n                userBetsIndex++;\r\n            }\r\n        }\r\n\r\n        return userBets;\r\n    }\r\n\r\n    function setTokenBetAmount(address token, uint256 tokenMinBetAmount, uint256 tokenMaxBetAmount) external onlyOwner {\r\n        tokensMinBetAmount[token] = tokenMinBetAmount;\r\n        tokensMaxBetAmount[token] = tokenMaxBetAmount;\r\n        emit SetTokenBetAmount(token, tokenMinBetAmount, tokenMaxBetAmount);\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        if (paused()) {\r\n            _unpause();\r\n        } else {\r\n            _pause();\r\n        }\r\n    }\r\n\r\n    function setChainlinkConfig(uint64 subId, uint32 callbackGasLimit, uint16 requestConfirmations, bytes32 keyHash) external onlyOwner {\r\n        chainlinkConfig.subId = subId;\r\n        chainlinkConfig.callbackGasLimit = callbackGasLimit;\r\n        chainlinkConfig.requestConfirmations = requestConfirmations;\r\n        chainlinkConfig.keyHash = keyHash;\r\n    }\r\n\r\n    function refundBet(uint256 randomNumber) external {\r\n        Bet storage bet = bets[randomNumber];\r\n        if (bet.resolved == true) {\r\n            revert NotPendingBet(randomNumber);\r\n        } else if (block.number < bet.blockNumber + 30) {\r\n            revert NotFulfilled(randomNumber);\r\n        }\r\n\r\n        bet.resolved = true;\r\n        IERC20(bet.token).safeTransfer(bet.user, bet.amount);\r\n\r\n        emit BetRefunded(randomNumber, bet.user, bet.amount);\r\n    }\r\n\r\n}\r\n\r\ncontract TossGame is Game {\r\n    struct TossBet {\r\n        Bet bet;\r\n        uint8 cap;\r\n    }\r\n\r\n    mapping(uint256 => uint8) public diceBets;\r\n\r\n    uint256 public fee = 0; // receive bnb instead of using link token. Link token is used to get random number from vrf\r\n\r\n    event PlaceBet(uint256 id, address indexed user, address indexed token, uint8 cap);\r\n    event Toss(uint256 id, address indexed user, address indexed token, uint256 amount, uint8 cap, uint8 rolled, uint256 payout);\r\n\r\n    constructor(address chainlinkCoordinatorAddress) Game(chainlinkCoordinatorAddress, 1) {}\r\n\r\n    function wager(uint8 cap, address token, uint256 tokenAmount) external payable whenNotPaused {\r\n        require(msg.value >= fee, \"wager: You must send enough bnb amount than fee!\");\r\n        require(cap ==0 || cap == 1, \"wager: You must send tail or head!\");\r\n\r\n        Bet memory bet = _newBet(token, tokenAmount);\r\n        diceBets[bet.randomNumber] = cap;        \r\n        emit PlaceBet(bet.randomNumber, bet.user, bet.token, cap);\r\n    }\r\n\r\n    function fulfillRandomWords(uint256 randomNumber, uint256[] memory randomWords) internal override {\r\n        uint8 cap = diceBets[randomNumber];\r\n        Bet storage bet = bets[randomNumber];\r\n        uint256 rolled = randomWords[0] % 2;\r\n        bool wins;\r\n        if (rolled == cap) {\r\n            wins = true;\r\n        }\r\n        else {\r\n            wins = false;\r\n        }\r\n        uint256 payout = _resolveBet(bet, wins, rolled, getPayout(bet.amount));\r\n        emit Toss(bet.randomNumber, bet.user, bet.token, bet.amount, cap, uint8(rolled), payout);\r\n    }\r\n\r\n    function getLastUserBets(address user, uint256 dataLength) external view returns (TossBet[] memory) {\r\n        Bet[] memory lastBets = _getLastUserBets(user, dataLength);\r\n        TossBet[] memory lastTossBets = new TossBet[](lastBets.length);\r\n        for (uint256 i; i < lastBets.length; i++) {\r\n            lastTossBets[i] = TossBet(lastBets[i], diceBets[lastBets[i].randomNumber]);\r\n        }\r\n        return lastTossBets;\r\n    }\r\n\r\n    function getPayout(uint256 betAmount) public pure returns (uint256) {\r\n        return (betAmount * 198) / 100;\r\n    }\r\n\r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        require(_fee <= 1e16, \"fee: can't set bigger amount than 0.01BNB\");\r\n        fee = _fee;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function withdrawFee() external onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        payable(owner()).transfer(amount);\r\n    }\r\n\r\n    function withdrawToken(address token) external onlyOwner {\r\n        uint256 amount =  IERC20(token).balanceOf(address(this));\r\n        IERC20(token).transfer(owner(), amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chainlinkCoordinatorAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"NotFulfilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"NotPendingBet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WrongBetAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BetRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cap\",\"type\":\"uint8\"}],\"name\":\"PlaceBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minBetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBetAmount\",\"type\":\"uint256\"}],\"name\":\"SetTokenBetAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cap\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rolled\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"Toss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betResults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"resolved\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rolled\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkConfig\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkCoordinator\",\"outputs\":[{\"internalType\":\"contract VRFCoordinatorV2Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"diceBets\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"}],\"name\":\"getLastUserBets\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"resolved\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rolled\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"internalType\":\"struct Game.Bet\",\"name\":\"bet\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"cap\",\"type\":\"uint8\"}],\"internalType\":\"struct TossGame.TossBet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"getPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"setChainlinkConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenMinBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenMaxBetAmount\",\"type\":\"uint256\"}],\"name\":\"setTokenBetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensMaxBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensMinBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"cap\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"wager\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TossGame", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c587d9053cd1118f25f645f9e08bb98c9712a4ee", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0687ec23e18f6482ff8c3baad9f42224e8288f2ff94e28ebe74385e89817fcd5"}