{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers. \\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721Holder is IERC721Receiver {\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/commons/ContextMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\ncontract ContextMixin {\\n    function _msgSender() internal view returns (address sender) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(\\n                    mload(add(array, index)),\\n                    0xffffffffffffffffffffffffffffffffffffffff\\n                )\\n            }\\n        } else {\\n            sender = msg.sender;\\n        }\\n        return sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/commons/EIP712Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\ncontract EIP712Base {\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        address verifyingContract;\\n        bytes32 salt;\\n    }\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(\\n            bytes(\\n                \\\"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\\\"\\n            )\\n        );\\n    bytes32 public domainSeparator;\\n\\n    // supposed to be called once while initializing.\\n    // one of the contractsa that inherits this contract follows proxy pattern\\n    // so it is not possible to do this in a constructor\\n    function _initializeEIP712(string memory name, string memory version)\\n        internal\\n    {\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                address(this),\\n                bytes32(getChainId())\\n            )\\n        );\\n    }\\n\\n    function getChainId() public pure returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * Accept message hash and returns hash message in EIP712 compatible form\\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\\n     * https://eips.ethereum.org/EIPS/eip-712\\n     * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\n     * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\n     */\\n    function toTypedMessageHash(bytes32 messageHash)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, messageHash)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/commons/NativeMetaTransaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport {EIP712Base} from \\\"./EIP712Base.sol\\\";\\n\\ncontract NativeMetaTransaction is EIP712Base {\\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\\n        keccak256(\\n            bytes(\\n                \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\n            )\\n        );\\n    event MetaTransactionExecuted(\\n        address userAddress,\\n        address relayerAddress,\\n        bytes functionSignature\\n    );\\n    mapping(address => uint256) nonces;\\n\\n    /*\\n     * Meta transaction structure.\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\n     * He should call the desired function directly in that case.\\n     */\\n    struct MetaTransaction {\\n        uint256 nonce;\\n        address from;\\n        bytes functionSignature;\\n    }\\n\\n    function executeMetaTransaction(\\n        address userAddress,\\n        bytes memory functionSignature,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) public payable returns (bytes memory) {\\n        MetaTransaction memory metaTx =\\n            MetaTransaction({\\n                nonce: nonces[userAddress],\\n                from: userAddress,\\n                functionSignature: functionSignature\\n            });\\n\\n        require(\\n            verify(userAddress, metaTx, sigR, sigS, sigV),\\n            \\\"NMT#executeMetaTransaction: SIGNER_AND_SIGNATURE_DO_NOT_MATCH\\\"\\n        );\\n\\n        // increase nonce for user (to avoid re-use)\\n        nonces[userAddress] = nonces[userAddress] + 1;\\n\\n        emit MetaTransactionExecuted(\\n            userAddress,\\n            msg.sender,\\n            functionSignature\\n        );\\n\\n        // Append userAddress and relayer address at the end to extract it from calling context\\n        (bool success, bytes memory returnData) =\\n            address(this).call(\\n                abi.encodePacked(functionSignature, userAddress)\\n            );\\n        require(success, \\\"NMT#executeMetaTransaction: CALL_FAILED\\\");\\n\\n        return returnData;\\n    }\\n\\n    function hashMetaTransaction(MetaTransaction memory metaTx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    META_TRANSACTION_TYPEHASH,\\n                    metaTx.nonce,\\n                    metaTx.from,\\n                    keccak256(metaTx.functionSignature)\\n                )\\n            );\\n    }\\n\\n    function getNonce(address user) public view returns (uint256 nonce) {\\n        nonce = nonces[user];\\n    }\\n\\n    function verify(\\n        address signer,\\n        MetaTransaction memory metaTx,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) internal view returns (bool) {\\n        require(signer != address(0), \\\"NMT#verify: INVALID_SIGNER\\\");\\n        return\\n            signer ==\\n            ecrecover(\\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\\n                sigV,\\n                sigR,\\n                sigS\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/commons/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./ContextMixin.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is ContextMixin {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/commons/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./ContextMixin.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is ContextMixin {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/marketplace/Marketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\\\";\\n\\nimport \\\"./MarketplaceStorage.sol\\\";\\nimport \\\"../commons/Ownable.sol\\\";\\nimport \\\"../commons/Pausable.sol\\\";\\nimport \\\"../commons/ContextMixin.sol\\\";\\nimport \\\"../commons/NativeMetaTransaction.sol\\\";\\n\\ncontract Marketplace is\\n    Ownable,\\n    Pausable,\\n    MarketplaceStorage,\\n    NativeMetaTransaction,\\n    ERC721Holder\\n{\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    address public constant BNB = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    modifier isTokenContract(IERC20 _contract) {\\n        require(\\n            _contract.totalSupply() >= 0,\\n            \\\"The accepted token address must be a deployed contract\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier allowedCurrency(IERC20 _currency) {\\n        require(acceptedTokens[_currency], \\\"Currency not allowed\\\");\\n        _;\\n    }\\n\\n    modifier allowedListingNft(IERC721 _nftAddress) {\\n        require(allowedNft[_nftAddress], \\\"NFTs not allowed for listing\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Initialize this contract. Acts as a constructor\\n    * @param _acceptedToken - Address of the ERC20 accepted for this marketplace\\n    * @param _ownerCutPerMillion - owner cut per million\\n\\n    */\\n    constructor(\\n        IERC20 _acceptedToken,\\n        uint256 _ownerCutPerMillion,\\n        address _owner\\n    ) isTokenContract(_acceptedToken) {\\n        require(_owner != address(0), \\\"Invalid owner\\\");\\n        // EIP712 init\\n        _initializeEIP712(\\\"Elpis Battleground\\\", \\\"1\\\");\\n\\n        // Fee init\\n        setOwnerCutPerMillion(_ownerCutPerMillion);\\n\\n        enableTokens(_acceptedToken);\\n        acceptedTokens[IERC20(BNB)] = true;\\n\\n        transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @dev Owner can pause contract\\n     */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Owner can unpause contract\\n     */\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @dev Sets the publication fee that's charged to users to publish items\\n     * @param _publicationFeeRate - Rate of fee amount in wei this contract charges to publish an item\\n     */\\n    function setPublicationFee(uint256 _publicationFeeRate) external onlyOwner {\\n        require(\\n            _publicationFeeRate <= 100,\\n            \\\"The fee to publish should be 0% to 10%\\\"\\n        );\\n        publicationFeeRate = _publicationFeeRate;\\n        emit ChangedPublicationFeeRate(publicationFeeRate);\\n    }\\n\\n    /**\\n     * @dev Calculate publishing costs based on the item's pirce\\n     * @param _price - pirce of the item\\n     */\\n    function getPublicationFee(uint256 _price) public view returns (uint256) {\\n        //We want marketplace publishing fees to range from 0% - 10%\\n        return _price.mul(publicationFeeRate).div(10**publicationFeeDecimal);\\n    }\\n\\n    /**\\n     * @dev Enable listing NFTs by this token\\n     * @param _token - Token address\\n     */\\n    function disableTokens(IERC20 _token)\\n        external\\n        onlyOwner\\n        isTokenContract(_token)\\n    {\\n        acceptedTokens[_token] = false;\\n    }\\n\\n    /**\\n     * @dev Disable listing NFTs by this token\\n     * @param _token - Token address\\n     */\\n    function enableTokens(IERC20 _token)\\n        public\\n        onlyOwner\\n        isTokenContract(_token)\\n    {\\n        acceptedTokens[_token] = true;\\n    }\\n\\n    /**\\n     * @dev Enable listing this NFTs on marketplace\\n     * @param _nftAddress - Token address\\n     */\\n    function disableListingNFTs(IERC721 _nftAddress) external onlyOwner {\\n        allowedNft[_nftAddress] = false;\\n    }\\n\\n    /**\\n     * @dev Disable listing this NFTs on marketplace\\n     * @param _nftAddress - Token address\\n     */\\n    function enableListingNFTs(IERC721 _nftAddress) public onlyOwner {\\n        allowedNft[_nftAddress] = true;\\n    }\\n\\n    /**\\n     * @dev Sets the share cut for the owner of the contract that's\\n     *  charged to the seller on a successful sale\\n     * @param _ownerCutPerMillion - Share amount, from 0 to 999,999\\n     */\\n    function setOwnerCutPerMillion(uint256 _ownerCutPerMillion)\\n        public\\n        onlyOwner\\n    {\\n        require(\\n            _ownerCutPerMillion <= 100000,\\n            \\\"The owner cut should be between 0 and 100,000\\\"\\n        );\\n\\n        ownerCutPerMillion = _ownerCutPerMillion;\\n        emit ChangedOwnerCutPerMillion(ownerCutPerMillion);\\n    }\\n\\n    /**\\n     * @dev Creates a new order\\n     * @param nftAddress - Non fungible registry address\\n     * @param assetId - ID of the published NFT\\n     * @param priceInWei - Price in Wei for the supported coin\\n     */\\n    function createOrder(\\n        address nftAddress,\\n        uint256 assetId,\\n        uint256 priceInWei,\\n        IERC20 currency\\n    )\\n        public\\n        payable\\n        whenNotPaused\\n        allowedCurrency(currency)\\n        allowedListingNft(IERC721(nftAddress))\\n    {\\n        _createOrder(nftAddress, assetId, priceInWei, currency);\\n    }\\n\\n    /**\\n     * @dev Cancel an already published order\\n     *  can only be canceled by seller or the contract owner\\n     * @param nftAddress - Address of the NFT registry\\n     * @param assetId - ID of the published NFT\\n     */\\n    function cancelOrder(address nftAddress, uint256 assetId)\\n        public\\n        whenNotPaused\\n    {\\n        _cancelOrder(nftAddress, assetId);\\n    }\\n\\n    /**\\n     * @dev Executes the sale for a published NFT\\n     * @param nftAddress - Address of the NFT registry\\n     * @param assetId - ID of the published NFT\\n     * @param price - Order price\\n     */\\n    function executeOrder(\\n        address nftAddress,\\n        uint256 assetId,\\n        uint256 price\\n    ) public payable whenNotPaused {\\n        _executeOrder(nftAddress, assetId, price);\\n    }\\n\\n    /**\\n     * @dev Change the price of order\\n     * @param nftAddress - Address of the NFT registry\\n     * @param assetId - ID of the published NFT\\n     * @param priceInWei - Order price\\n     */\\n    function changePriceOfOrder(\\n        address nftAddress,\\n        uint256 assetId,\\n        uint256 priceInWei\\n    ) public whenNotPaused {\\n        _changePriceOfOrder(nftAddress, assetId, priceInWei);\\n    }\\n\\n    /**\\n     * @dev Creates a new order\\n     * @param nftAddress - Non fungible registry address\\n     * @param assetId - ID of the published NFT\\n     * @param priceInWei - Price in Wei for the supported coin\\n     */\\n    function _createOrder(\\n        address nftAddress,\\n        uint256 assetId,\\n        uint256 priceInWei,\\n        IERC20 currencyAddress\\n    ) internal {\\n        _requireERC721(nftAddress);\\n\\n        address sender = _msgSender();\\n\\n        IERC721 nftRegistry = IERC721(nftAddress);\\n\\n        require(\\n            nftRegistry.getApproved(assetId) == address(this) ||\\n                nftRegistry.isApprovedForAll(sender, address(this)),\\n            \\\"The contract is not authorized to manage the asset\\\"\\n        );\\n\\n        nftRegistry.safeTransferFrom(sender, address(this), assetId);\\n\\n        require(priceInWei > 0, \\\"Price should be bigger than 0\\\");\\n\\n        bytes32 orderId =\\n            keccak256(\\n                abi.encodePacked(\\n                    block.timestamp,\\n                    sender,\\n                    assetId,\\n                    nftAddress,\\n                    currencyAddress,\\n                    priceInWei\\n                )\\n            );\\n\\n        orderByAssetId[nftAddress][assetId] = Order({\\n            id: orderId,\\n            seller: sender,\\n            nftAddress: nftAddress,\\n            currency: currencyAddress,\\n            price: priceInWei\\n        });\\n\\n        // Check if there's a publication fee and\\n        // transfer the amount to marketplace owner\\n        uint256 publicationFeeInWei = getPublicationFee(priceInWei);\\n        if (publicationFeeInWei > 0) {\\n            if (address(currencyAddress) != BNB) {\\n                require(\\n                    currencyAddress.transferFrom(\\n                        sender,\\n                        owner(),\\n                        publicationFeeInWei\\n                    ),\\n                    \\\"Transfering the publication fee to the Marketplace owner failed\\\"\\n                );\\n            } else {\\n                require(\\n                    msg.value >= publicationFeeInWei,\\n                    \\\"Transfering value not enough to pay the publication fee\\\"\\n                );\\n                address owner = owner();\\n                payable(owner).transfer(publicationFeeInWei);\\n            }\\n        }\\n\\n        emit OrderCreated(\\n            orderId,\\n            assetId,\\n            sender,\\n            nftAddress,\\n            currencyAddress,\\n            priceInWei\\n        );\\n    }\\n\\n    /**\\n     * @dev Change the pirce of order\\n     * @param nftAddress - Address of the NFT registry\\n     * @param assetId - ID of the published NFT\\n     * @param priceInWei - Order price\\n     */\\n    function _changePriceOfOrder(\\n        address nftAddress,\\n        uint256 assetId,\\n        uint256 priceInWei\\n    ) internal {\\n        address sender = _msgSender();\\n        Order storage order = orderByAssetId[nftAddress][assetId];\\n        require(order.id != 0, \\\"Asset not published\\\");\\n        require(\\n            order.seller == sender || sender == owner(),\\n            \\\"Unauthorized user\\\"\\n        );\\n\\n        require(priceInWei > 0, \\\"Price should be bigger than 0\\\");\\n        require(priceInWei != order.price, \\\"The new price should be different from the old price\\\");\\n        order.price = priceInWei;\\n\\n        emit OrderPriceChanged(\\n            order.id,\\n            assetId,\\n            sender,\\n            nftAddress,\\n            priceInWei\\n        );\\n    }\\n\\n    /**\\n     * @dev Cancel an already published order\\n     *  can only be canceled by seller or the contract owner\\n     * @param nftAddress - Address of the NFT registry\\n     * @param assetId - ID of the published NFT\\n     */\\n    function _cancelOrder(address nftAddress, uint256 assetId)\\n        internal\\n        returns (Order memory)\\n    {\\n        address sender = _msgSender();\\n        Order memory order = orderByAssetId[nftAddress][assetId];\\n\\n        require(order.id != 0, \\\"Asset not published\\\");\\n        require(\\n            order.seller == sender || sender == owner(),\\n            \\\"Unauthorized user\\\"\\n        );\\n\\n        IERC721(order.nftAddress).safeTransferFrom(\\n            address(this),\\n            sender,\\n            assetId\\n        );\\n\\n        delete orderByAssetId[nftAddress][assetId];\\n\\n        emit OrderCancelled(\\n            order.id,\\n            assetId,\\n            order.seller,\\n            order.nftAddress,\\n            order.currency\\n        );\\n\\n        return order;\\n    }\\n\\n    /**\\n     * @dev Executes the sale for a published NFT\\n     * @param nftAddress - Address of the NFT registry\\n     * @param assetId - ID of the published NFT\\n     * @param price - Order price\\n     */\\n    function _executeOrder(\\n        address nftAddress,\\n        uint256 assetId,\\n        uint256 price\\n    ) internal returns (Order memory) {\\n        _requireERC721(nftAddress);\\n\\n        address sender = _msgSender();\\n        IERC721 nftRegistry = IERC721(nftAddress);\\n        Order memory order = orderByAssetId[nftAddress][assetId];\\n\\n        require(order.id != 0, \\\"Asset not published\\\");\\n\\n        address seller = order.seller;\\n\\n        require(seller != address(0), \\\"Invalid address\\\");\\n        require(seller != sender, \\\"Unauthorized user\\\");\\n\\n        IERC20 currency = order.currency;\\n        uint256 saleShareAmount = 0;\\n\\n        delete orderByAssetId[nftAddress][assetId];\\n\\n        if (ownerCutPerMillion > 0) {\\n            // Calculate sale share\\n            saleShareAmount = order.price.mul(ownerCutPerMillion).div(1000000);\\n        }\\n\\n        if (address(currency) != BNB) {\\n            require(price >= order.price, \\\"The price is not correct\\\");\\n            // Transfer share amount for marketplace Owner\\n            if (saleShareAmount > 0) {\\n                require(\\n                    currency.transferFrom(sender, owner(), saleShareAmount),\\n                    \\\"Transfering the cut to the Marketplace owner failed\\\"\\n                );\\n            }\\n            // Transfer sale amount to seller\\n            require(\\n                currency.transferFrom(\\n                    sender,\\n                    seller,\\n                    price.sub(saleShareAmount)\\n                ),\\n                \\\"Transfering the sale amount to the seller failed\\\"\\n            );\\n        } else {\\n            require(msg.value >= order.price, \\\"Transfering value not enough\\\");\\n            address owner = owner();\\n            // Transfer share amount for marketplace Owner\\n            if (saleShareAmount > 0) {\\n                payable(owner).transfer(saleShareAmount);\\n            }\\n            // Transfer sale amount to seller\\n            payable(seller).transfer(order.price.sub(saleShareAmount));\\n        }\\n\\n        // Transfer asset owner\\n        nftRegistry.safeTransferFrom(address(this), sender, assetId);\\n\\n        emit OrderSuccessful(\\n            order.id,\\n            assetId,\\n            seller,\\n            nftAddress,\\n            order.currency,\\n            price,\\n            sender\\n        );\\n\\n        return order;\\n    }\\n\\n    function _requireERC721(address nftAddress) internal view {\\n        require(\\n            nftAddress.isContract(),\\n            \\\"The NFT Address should be a contract\\\"\\n        );\\n\\n        IERC721 nftRegistry = IERC721(nftAddress);\\n        require(\\n            nftRegistry.supportsInterface(ERC721_Interface),\\n            \\\"The NFT contract has an invalid ERC721 implementation\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/marketplace/MarketplaceStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @title Interface for contracts conforming to ERC-20\\n */\\ninterface IERC20 {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\\n/**\\n * @title Interface for contracts conforming to ERC-721\\n */\\ninterface IERC721 {\\n    function ownerOf(uint256 _tokenId) external view returns (address _owner);\\n\\n    function approve(address _to, uint256 _tokenId) external;\\n\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    function isApprovedForAll(address _owner, address _operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) external;\\n\\n    function supportsInterface(bytes4) external view returns (bool);\\n}\\n\\ncontract MarketplaceStorage {\\n    mapping(IERC20 => bool) public acceptedTokens;\\n    mapping(IERC721 => bool) public allowedNft;\\n\\n    struct Order {\\n        // Order ID\\n        bytes32 id;\\n        // Owner of the NFT\\n        address seller;\\n        // NFT registry address\\n        address nftAddress;\\n        // Currency of listed NFT\\n        IERC20 currency;\\n        // Price (in wei) for the published item\\n        uint256 price;\\n    }\\n\\n    // From ERC721 registry assetId to Order (to avoid asset collision)\\n    mapping(address => mapping(uint256 => Order)) public orderByAssetId;\\n\\n    uint256 public ownerCutPerMillion;\\n    uint256 public constant publicationFeeDecimal = 3;\\n    uint256 public publicationFeeRate;\\n\\n    bytes4 public constant ERC721_Interface = bytes4(0x80ac58cd);\\n\\n    // EVENTS\\n    event OrderCreated(\\n        bytes32 id,\\n        uint256 indexed assetId,\\n        address indexed seller,\\n        address nftAddress,\\n        IERC20 currency,\\n        uint256 priceInWei\\n    );\\n\\n    event OrderPriceChanged(\\n        bytes32 id,\\n        uint256 indexed assetId,\\n        address indexed seller,\\n        address nftAddress,\\n        uint256 newPriceInWei\\n    );\\n\\n    event OrderSuccessful(\\n        bytes32 id,\\n        uint256 indexed assetId,\\n        address indexed seller,\\n        address nftAddress,\\n        IERC20 currency,\\n        uint256 totalPrice,\\n        address indexed buyer\\n    );\\n\\n    event OrderCancelled(\\n        bytes32 id,\\n        uint256 indexed assetId,\\n        address indexed seller,\\n        address nftAddress,\\n        IERC20 currency\\n    );\\n\\n    event ChangedPublicationFeeRate(uint256 publicationFee);\\n    event ChangedOwnerCutPerMillion(uint256 ownerCutPerMillion);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_acceptedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ownerCutPerMillion\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerCutPerMillion\",\"type\":\"uint256\"}],\"name\":\"ChangedOwnerCutPerMillion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"publicationFee\",\"type\":\"uint256\"}],\"name\":\"ChangedPublicationFeeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceInWei\",\"type\":\"uint256\"}],\"name\":\"OrderPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"OrderSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC721_Interface\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"acceptedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedNft\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"changePriceOfOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"createOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"disableListingNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"disableTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"enableListingNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"enableTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"executeOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"getPublicationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderByAssetId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCutPerMillion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicationFeeDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicationFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ownerCutPerMillion\",\"type\":\"uint256\"}],\"name\":\"setOwnerCutPerMillion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_publicationFeeRate\",\"type\":\"uint256\"}],\"name\":\"setPublicationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Marketplace", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000000000000000000000000000000000000000000000000000000000000000000000691829297ebc96ec2070b85203340aa21bcc5d01", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}