{"SourceCode": "{\"ARRBase.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\n    library SafeMath {//konwnsec//IERC20 \u63a5\u53e3\\r\\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n            if (a == 0) {\\r\\n                return 0; \\r\\n            }\\r\\n            uint256 c = a * b;\\r\\n            assert(c / a == b);\\r\\n            return c; \\r\\n        }\\r\\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n// assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n            uint256 c = a / b;\\r\\n// assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n            return c; \\r\\n        }\\r\\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n            assert(b \\u003c= a);\\r\\n            return a - b; \\r\\n        }\\r\\n\\r\\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n            uint256 c = a + b;\\r\\n            assert(c \\u003e= a);\\r\\n            return c; \\r\\n        }\\r\\n    }\\r\\n\\r\\n    interface Erc20Token {//konwnsec//ERC20 \u63a5\u53e3\\r\\n        function totalSupply() external view returns (uint256);\\r\\n        function balanceOf(address _who) external view returns (uint256);\\r\\n        function transfer(address _to, uint256 _value) external;\\r\\n        function allowance(address _owner, address _spender) external view returns (uint256);\\r\\n        function transferFrom(address _from, address _to, uint256 _value) external;\\r\\n        function approve(address _spender, uint256 _value) external; \\r\\n        function burnFrom(address _from, uint256 _value) external; \\r\\n        event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n        event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n        \\r\\n\\r\\n    }\\r\\n    \\r\\n    \\r\\n    interface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n    \\r\\n// \u57fa\u7c7b\u5408\u7ea6\\r\\n    contract ARRBase {\\r\\n        using SafeMath for uint;\\r\\n\\r\\n\\r\\n        Erc20Token constant internal _oldArrIns = Erc20Token(0x9EB1A4276dD826e8315C4FB044268CDB63a0D9A1); \\r\\n        Erc20Token constant internal _eptIns = Erc20Token(0xCDAbD94A40e25E80Cd4CE1D73C8f93e368BD1069); \\r\\n        Erc20Token constant internal _arrIns = Erc20Token(0xb37b866871882124C3E7E301d936C29089c43987); \\r\\n        Erc20Token constant  internal TPAddr = Erc20Token(0xaDf74c4eF1Eab7F2b38Be9CF05576D95F86B4edB);\\r\\n        Erc20Token constant  internal BNBTPAddr = Erc20Token(0x3aD5030201a0E4a7C5aFBF7bAF17e6316a3CDAcc);\\r\\n\\r\\n    mapping(address =\\u003e uint256) public _playerEPT; \\r\\n    mapping(address =\\u003e uint256) public _playerARR; \\r\\n\\r\\n        uint256 public _startTime;\\r\\n        address  _owner;\\r\\n\\r\\n        function EPT_Convert(uint256 value) internal pure returns(uint256) {\\r\\n            return value.mul(1000000000000000000);\\r\\n        }\\r\\n          function eptConvert(uint256 value) internal pure returns(uint256) {\\r\\n            return value.mul(1000000000000);\\r\\n        }\\r\\n        \\r\\n        modifier onlyOwner() {\\r\\n            require(msg.sender == _owner, \\\"Permission denied\\\"); _;\\r\\n        }\\r\\n        modifier isZeroAddr(address addr) {\\r\\n            require(addr != address(0), \\\"Cannot be a zero address\\\"); _; \\r\\n        }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0));\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    receive() external payable {}  \\r\\n}\"},\"ARRpledge.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\nimport \\\"./DataPlayer.sol\\\";\\r\\n\\r\\n\\r\\ncontract ARRpledge is DataPlayer {\\r\\n    uint256 private constant  ONE_Month = 30*24*60*60;\\r\\n  \\r\\n    constructor()\\r\\n  public {\\r\\n        _owner = msg.sender; \\r\\n        _startTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n     function investmentEPT(uint256 amount, address referrerAddr, uint256 Gear) public payable   {\\r\\n        require(amount \\u003e= EPT_Convert(1), \\\"Not enough input\\\");\\r\\n        _eptIns.transferFrom(msg.sender, address(this), amount);\\r\\n        registry(msg.sender,referrerAddr);\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 endTime =block.timestamp.add(Gear.mul(ONE_Month));\\r\\n        uint256 profitAmount = profitCalculation(amount,Gear);\\r\\n        uint256 ARRprofitAmount = profitCalculationARR(amount,Gear);\\r\\n        InvestInfo[] memory investList = _playerMap[id].list;\\r\\n  \\r\\n        uint256 index = 100;\\r\\n        for (uint256 i = 0; i \\u003c investList.length; i++) {\\r\\n            if (investList[i].id == 0){\\r\\n                    index = i;\\r\\n                    break;\\r\\n            }\\r\\n        }\\r\\n            if (index != 100){\\r\\n                _playerMap[id].list[index].id = id;\\r\\n                _playerMap[id].list[index].amount = amount;\\r\\n                _playerMap[id].list[index].time = block.timestamp;\\r\\n                _playerMap[id].list[index].blockHigh = block.number;\\r\\n                _playerMap[id].list[index].staticBalance = profitAmount;\\r\\n                _playerMap[id].list[index].staticARRBalance = ARRprofitAmount;\\r\\n                _playerMap[id].list[index].endTime = endTime;\\r\\n            }else{\\r\\n                InvestInfo memory info = InvestInfo(id, amount, block.timestamp, block.number,profitAmount,ARRprofitAmount,endTime);\\r\\n                _playerMap[id].list.push(info);\\r\\n            }\\r\\n    }\\r\\n\\r\\n    function profitCalculation(uint256 amount, uint256 Gear)internal    returns(uint256) {\\r\\n        uint256 profitAmount = 0;\\r\\n        uint256 proportadsion = Reduceproduction();\\r\\n        if(Gear == 3){\\r\\n            profitAmount = amount.mul(150).div(1000).mul(proportadsion).div(100);\\r\\n        }\\r\\n        else  if(Gear == 6){\\r\\n            profitAmount = amount.mul(324).div(1000).mul(proportadsion).div(100);\\r\\n        }\\r\\n        else  if(Gear == 12){\\r\\n            profitAmount = amount.mul(700).div(1000).mul(proportadsion).div(100);\\r\\n        }\\r\\n        else{\\r\\n            require(false, \\\"No \\\");\\r\\n        }\\r\\n        require(profitAmount != 0, \\\"No frequency\\\");\\r\\n        return profitAmount; \\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n function profitCalculationARR(uint256 amount, uint256 Gear)internal    returns(uint256) {\\r\\n        uint256 profitAmount = 0;\\r\\n        uint256 proportadsion = Reduceproduction();\\r\\n     \\r\\n         if(Gear == 3){\\r\\n            profitAmount = amount.mul(15).div(1000000).mul(proportadsion).div(100);\\r\\n        }\\r\\n        else  if(Gear == 6){\\r\\n            profitAmount = amount.mul(33).div(1000000).mul(proportadsion).div(100);\\r\\n        }else  if(Gear == 12){\\r\\n            profitAmount = amount.mul(726).div(10000000).mul(proportadsion).div(100);\\r\\n        }\\r\\n        else{\\r\\n            require(false, \\\"No \\\");\\r\\n        }\\r\\n        require(profitAmount != 0, \\\"No frequency\\\");\\r\\n        return profitAmount; \\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    function Reduceproduction()public  returns(uint256)  {\\r\\n        uint256 proportion = 100;\\r\\n        newtime = block.timestamp;\\r\\n        uint256 yearTime = 365 * 24*60*60;\\r\\n        uint256 timeDifference = newtime.sub(_startTime);\\r\\n        // 1\\r\\n        if(timeDifference \\u003e 0 \\u0026\\u0026 timeDifference \\u003c yearTime){\\r\\n            proportion = 100;\\r\\n        }  \\r\\n\\r\\n        // 2\\r\\n        else if(timeDifference \\u003e yearTime \\u0026\\u0026 timeDifference \\u003c yearTime*2){\\r\\n            proportion = 90;\\r\\n        }\\r\\n        // 3\\r\\n        else if(timeDifference \\u003e yearTime *2 \\u0026\\u0026 timeDifference \\u003c yearTime*3){\\r\\n            proportion = 80;\\r\\n        } \\r\\n        // 4\\r\\n        else if(timeDifference \\u003e yearTime *3 \\u0026\\u0026 timeDifference \\u003c yearTime*4){\\r\\n            proportion = 70;\\r\\n        } \\r\\n        // 5\\r\\n        else if(timeDifference \\u003e yearTime*4 \\u0026\\u0026 timeDifference \\u003c yearTime*5){\\r\\n            proportion = 60;\\r\\n        } \\r\\n        // 6\\r\\n        else if(timeDifference \\u003e yearTime*5 ){\\r\\n            proportion = 50;\\r\\n        }\\r\\n        return proportion; \\r\\n    }\\r\\n \\r\\n    modifier isRealPlayer() {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        require(id \\u003e 0, \\\"no this user\\\"); // \u7528\u6237\u4e0d\u5b58\u5728\\r\\n        _; \\r\\n    }\\r\\n\\r\\n    function registry(address playerAddr,address tAddr) internal isZeroAddr(playerAddr)   {\\r\\n        uint256 id = _playerAddrMap[playerAddr];\\r\\n        uint256 tid = getIdByAddr(tAddr);\\r\\n\\r\\n        if (id == 0) {\\r\\n            _playerCount++;\\r\\n            _playerAddrMap[playerAddr] = _playerCount; \\r\\n            _playerMap[_playerCount].id = _playerCount; \\r\\n            _playerMap[_playerCount].addr = playerAddr;\\r\\n            _playerotherMap[_playerCount].id = _playerCount; \\r\\n            _playerotherMap[_playerCount].addr = playerAddr;\\r\\n           \\r\\n        }\\r\\n\\r\\n        if (tid != 0){\\r\\n\\r\\n            if (id == 0) {\\r\\n                _playerMap[_playerCount].referrerId = getIdByAddr(tAddr); \\r\\n            }else{\\r\\n                 if (_playerMap[id].referrerId == 0 \\u0026\\u0026 tid != id) {\\r\\n                    _playerMap[id].referrerId = getIdByAddr(tAddr); \\r\\n                }\\r\\n            }\\r\\n        } \\r\\n    }\\r\\n\\r\\n\\r\\n    function binding(address tAddr) public isRealPlayer isZeroAddr(tAddr)   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 tid = getIdByAddr(tAddr);\\r\\n        if (tid != 0){\\r\\n                 if (_playerMap[id].referrerId == 0 \\u0026\\u0026 tid != id) {\\r\\n                _playerMap[id].referrerId = getIdByAddr(tAddr); \\r\\n            }\\r\\n        } \\r\\n    }\\r\\n    \\r\\n\\r\\n    function settleStatic() public  isRealPlayer   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        InvestInfo[] memory investList = _playerMap[id].list;\\r\\n        uint256 Tid = _playerMap[id].referrerId;\\r\\n        address referrerAddr = getAddrById(Tid);\\r\\n        uint256 staticaAmount = 0;\\r\\n        uint256 referrerAmount = 0;\\r\\n        uint256 ARRstaticaAmount = 0;\\r\\n        uint256 ARRreferrerAmount = 0;\\r\\n        newtime = block.timestamp;\\r\\n        for (uint256 i = 0; i \\u003c investList.length; i++) {\\r\\n            if(block.timestamp\\u003einvestList[i].endTime){\\r\\n              staticaAmount =  staticaAmount.add(investList[i].amount).add(investList[i].staticBalance);\\r\\n              referrerAmount =  referrerAmount.add(investList[i].staticBalance.div(10));\\r\\n              ARRstaticaAmount =  ARRstaticaAmount.add(investList[i].staticARRBalance);\\r\\n              ARRreferrerAmount =  ARRreferrerAmount.add(investList[i].staticARRBalance.div(10));\\r\\n                delete _playerMap[id].list[i];\\r\\n             }\\r\\n        }\\r\\n        require(staticaAmount \\u003e 0 || ARRstaticaAmount \\u003e 0 , \\\" this field\\\" ); \\r\\n        if(staticaAmount \\u003e 0){\\r\\n            _eptIns.transfer(msg.sender, staticaAmount);\\r\\n        }\\r\\n        if(referrerAmount \\u003e 0){\\r\\n            if(Tid \\u003e 0){\\r\\n                _eptIns.transfer(referrerAddr, referrerAmount);\\r\\n            }\\r\\n        }\\r\\n            if(ARRstaticaAmount \\u003e 0){\\r\\n                _arrIns.transfer(msg.sender, ARRstaticaAmount);\\r\\n            }\\r\\n            if(ARRreferrerAmount \\u003e 0){\\r\\n                if(Tid \\u003e 0){\\r\\n                    _arrIns.transfer(referrerAddr, ARRreferrerAmount);\\r\\n                }\\r\\n            }\\r\\n    }\\r\\n  function setLPreferrerYield(uint256  Yield ) public  onlyOwner  {\\r\\n        _Yield = Yield;\\r\\n    }\\r\\n   \\r\\n function setLPstaticRate(uint256  Rate ) public  onlyOwner  {\\r\\n            _staticRate = Rate;\\r\\n    }\\r\\n \\r\\n   function setLPreferrerotherYield(uint256  Rate ) public  onlyOwner  {\\r\\n        _Yieldother = Rate;\\r\\n    }\\r\\n   \\r\\n function setLPstaticotherRate(uint256  Rate ) public  onlyOwner  {\\r\\n            _staticRateother = Rate;\\r\\n    }\\r\\n\\r\\n    function WithdrawalLP() public isRealPlayer   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 LPamount = _playerMap[id].LP_Amount;\\r\\n        uint256 Tid = _playerMap[id].referrerId;\\r\\n        address referrerAddr = getAddrById(Tid);\\r\\n\\r\\n        if(LPamount \\u003e 0){\\r\\n            if(_playerMap[id].LPEndTime != 0){\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(_playerMap[id].LPEndTime);\\r\\n                require(LPsettlementTime \\u003e 60, \\\" time field\\\" ); \\r\\n                LPsettlementTime = LPsettlementTime.div(60);\\r\\n                uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(10000000000000);\\r\\n                dynamicLP_Amount = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\\r\\n                require(dynamicLP_Amount \\u003e 0, \\\" Amount field\\\" ); \\r\\n                _playerMap[id].dynamicBalance = 0;\\r\\n                _playerMap[id].LPEndTime = block.timestamp;\\r\\n                _arrIns.transfer(msg.sender, dynamicLP_Amount);\\r\\n        if(Tid \\u003e 0){\\r\\n            uint256  referrerAmount =  dynamicLP_Amount.mul(_Yield).div(1000);\\r\\n            _arrIns.transfer(referrerAddr, referrerAmount);                \\r\\n        }\\r\\n              }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function redeemLP() public isRealPlayer   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 LPamount = _playerMap[id].LP_Amount;\\r\\n        uint256 Tid = _playerMap[id].referrerId;\\r\\n        address referrerAddr = getAddrById(Tid);\\r\\n        if(LPamount \\u003e 0){\\r\\n            if(_playerMap[id].LPEndTime != 0){\\r\\n                uint256  time = _playerMap[id].LPEndTime;\\r\\n                newtime = block.timestamp;\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(time);\\r\\n                if(LPsettlementTime \\u003e 60){\\r\\n                    LPsettlementTime = LPsettlementTime.div(60);\\r\\n                    uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(10000000000000);\\r\\n                    _arrIns.transfer(msg.sender, _playerMap[id].dynamicBalance.add(dynamicLP_Amount));\\r\\n                    if(Tid \\u003e 0){\\r\\n                        uint256  referrerAmount =  dynamicLP_Amount.mul(_Yield).div(1000);\\r\\n                        _arrIns.transfer(referrerAddr, referrerAmount);\\r\\n                    }\\r\\n    \\r\\n                }\\r\\n                _playerMap[id].dynamicBalance = 0;\\r\\n                _playerMap[id].LPEndTime = 0;\\r\\n                _playerMap[id].LP_Amount = 0;\\r\\n                TPAddr.transfer( msg.sender, LPamount);\\r\\n             }\\r\\n        }\\r\\n    }\\r\\n                  \\r\\n\\r\\nfunction investmentEPTARRLP(uint256 amount, address referrerAddr) public payable  {\\r\\n        // require(amount \\u003e= eptConvert(1), \\\"Not enough input\\\");\\r\\n        registry(msg.sender,referrerAddr);\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        TPAddr.transferFrom(msg.sender, address(this), amount);\\r\\n        settlementLP(id,amount);\\r\\n    }\\r\\n\\r\\nfunction settlementLP(uint256 id,uint256 Amount) internal {\\r\\n        uint256 LPamount = _playerMap[id].LP_Amount;\\r\\n        if(LPamount \\u003e 0){\\r\\n  \\r\\n            uint256  LPsettlementTime = block.timestamp.sub(_playerMap[id].LPEndTime);\\r\\n            LPsettlementTime = LPsettlementTime.div(60);\\r\\n            uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(10000000000000);\\r\\n            _playerMap[id].dynamicBalance = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\\r\\n            _playerMap[id].LPEndTime = block.timestamp;\\r\\n            _playerMap[id].LP_Amount = _playerMap[id].LP_Amount.add(Amount);\\r\\n\\r\\n      \\r\\n        }else{\\r\\n                _playerMap[id].LPEndTime = block.timestamp;\\r\\n                _playerMap[id].LPTime= block.timestamp;\\r\\n                _playerMap[id].LP_Amount = Amount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function WithdrawalEPTBNBLP() public isRealPlayer   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 LPamount = _playerotherMap[id].LP_Amount;\\r\\n        uint256 Tid = _playerMap[id].referrerId;\\r\\n        address referrerAddr = getAddrById(Tid);\\r\\n\\r\\n        if(LPamount \\u003e 0){\\r\\n            if(_playerotherMap[id].LPEndTime != 0){\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(_playerotherMap[id].LPEndTime);\\r\\n                require(LPsettlementTime \\u003e 60, \\\" time field\\\" ); \\r\\n                LPsettlementTime = LPsettlementTime.div(60);\\r\\n\\r\\n                uint256  dynamicLP_Amount = LPamount.mul(_staticRateother).mul(LPsettlementTime).div(10000000000000);\\r\\n\\r\\n                dynamicLP_Amount = _playerotherMap[id].dynamicBalance.add(dynamicLP_Amount);\\r\\n                require(dynamicLP_Amount \\u003e 0, \\\" Amount field\\\" ); \\r\\n                _playerotherMap[id].dynamicBalance = 0;\\r\\n                _playerotherMap[id].LPEndTime = block.timestamp;\\r\\n                _arrIns.transfer(msg.sender, dynamicLP_Amount);\\r\\n            if(Tid \\u003e 0){\\r\\n                uint256  referrerAmount =  dynamicLP_Amount.mul(_Yieldother).div(1000);\\r\\n                _arrIns.transfer(referrerAddr, referrerAmount);                }\\r\\n              }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function redeemEPTBNBLP() public isRealPlayer   {\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        uint256 LPamount = _playerotherMap[id].LP_Amount;\\r\\n\\r\\n        uint256 Tid = _playerMap[id].referrerId;\\r\\n        address referrerAddr = getAddrById(Tid);\\r\\n\\r\\n        if(LPamount \\u003e 0){\\r\\n            if(_playerotherMap[id].LPEndTime != 0){\\r\\n                uint256  time = _playerotherMap[id].LPEndTime;\\r\\n                newtime = block.timestamp;\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(time);\\r\\n                if(LPsettlementTime \\u003e 60){\\r\\n\\r\\n                    LPsettlementTime = LPsettlementTime.div(60);\\r\\n                    uint256  dynamicLP_Amount = LPamount.mul(_staticRateother).mul(LPsettlementTime).div(10000000000000);\\r\\n                    _arrIns.transfer(msg.sender, _playerotherMap[id].dynamicBalance.add(dynamicLP_Amount));\\r\\n                    if(Tid \\u003e 0){\\r\\n                        uint256  referrerAmount =  dynamicLP_Amount.mul(_Yield).div(1000);\\r\\n                        _arrIns.transfer(referrerAddr, referrerAmount);\\r\\n                    }\\r\\n    \\r\\n                }\\r\\n                _playerotherMap[id].dynamicBalance = 0;\\r\\n                _playerotherMap[id].LPEndTime = 0;\\r\\n                _playerotherMap[id].LP_Amount = 0;\\r\\n                BNBTPAddr.transfer( msg.sender, LPamount);\\r\\n             }\\r\\n        }\\r\\n    }\\r\\n                  \\r\\n\\r\\nfunction investmentEPTBNBLP(uint256 amount, address referrerAddr) public payable  {\\r\\n        // require(amount \\u003e= eptConvert(1), \\\"Not enough input\\\");\\r\\n        registry(msg.sender,referrerAddr);\\r\\n        uint256 id = _playerAddrMap[msg.sender];\\r\\n        BNBTPAddr.transferFrom(msg.sender, address(this), amount);\\r\\n        settlementEPTBNBLP(id,amount);\\r\\n    }\\r\\n\\r\\nfunction settlementEPTBNBLP(uint256 id,uint256 Amount) internal {\\r\\n        uint256 LPamount = _playerotherMap[id].LP_Amount;\\r\\n        if(LPamount \\u003e 0){\\r\\n                uint256  LPsettlementTime = block.timestamp.sub(_playerotherMap[id].LPEndTime);\\r\\n                LPsettlementTime = LPsettlementTime.div(60);\\r\\n                uint256  dynamicLP_Amount = LPamount.mul(_staticRateother).mul(LPsettlementTime).div(10000000000000);\\r\\n                _playerotherMap[id].dynamicBalance = _playerotherMap[id].dynamicBalance.add(dynamicLP_Amount);\\r\\n                _playerotherMap[id].LPEndTime = block.timestamp;\\r\\n                _playerotherMap[id].LP_Amount = _playerotherMap[id].LP_Amount.add(Amount);\\r\\n     \\r\\n        }else{\\r\\n                _playerotherMap[id].LPEndTime = block.timestamp;\\r\\n                _playerotherMap[id].LPTime= block.timestamp;\\r\\n                _playerotherMap[id].LP_Amount = Amount;\\r\\n        }\\r\\n    }\\r\\n  \\r\\n     function WithdrawalAirdrop() public     {\\r\\n        uint256 EPTAirdrop = _playerEPT[msg.sender];\\r\\n        uint256 ARRAirdrop = _playerARR[msg.sender];\\r\\n         if(EPTAirdrop \\u003e 0){\\r\\n            _eptIns.transfer(msg.sender, EPTAirdrop);\\r\\n            _playerEPT[msg.sender] = 0;\\r\\n        }\\r\\n          if(ARRAirdrop \\u003e 0){\\r\\n            _arrIns.transfer(msg.sender, ARRAirdrop);\\r\\n            _playerARR[msg.sender] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function OldARRexchangeARR() public   {\\r\\n        uint256 Balance = _oldArrIns.balanceOf(address(msg.sender));\\r\\n        _oldArrIns.transferFrom(msg.sender, address(0x0000000000000000000000000000000000000001), Balance);\\r\\n        _arrIns.transfer(msg.sender, Balance);\\r\\n    }\\r\\n\\r\\n     function WithdrawalAirdropARR() public {\\r\\n         uint256 airARRdrop =_playerARR[msg.sender];\\r\\n          if(airARRdrop \\u003e 0){\\r\\n            _arrIns.transfer(msg.sender, airARRdrop);\\r\\n            _playerARR[msg.sender] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n  function WithdrawalAirdropEPT() public  {\\r\\n         uint256 Airdrop = _playerEPT[msg.sender];\\r\\n          if(Airdrop \\u003e 0){\\r\\n            _eptIns.transfer(msg.sender, Airdrop);\\r\\n            _playerEPT[msg.sender] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function AirdropARR(address[] calldata ARRAddrs,uint256[] calldata PlayerARR) public onlyOwner {\\r\\n        for (uint256 i=0; i\\u003cARRAddrs.length; i++) {\\r\\n            address add = ARRAddrs[i];\\r\\n            uint256 amount = eptConvert(PlayerARR[i]);\\r\\n            _playerARR[add] = _playerARR[add].add(amount);\\r\\n \\r\\n        }   \\r\\n    }           \\r\\n function AirdropEPT(address[] calldata EPTAddrs,uint256[] calldata _PlayerEPT) public onlyOwner {\\r\\n        for (uint256 i=0; i\\u003cEPTAddrs.length; i++) {\\r\\n            address add = EPTAddrs[i];\\r\\n             uint256 amount = eptConvert(_PlayerEPT[i]);\\r\\n            _playerEPT[add] = _playerEPT[add].add(amount);\\r\\n\\r\\n        }   \\r\\n }\\r\\n\\r\\n\\r\\n function AirdropLP(address[] calldata LPAddrs,uint256[] calldata LPNum) public onlyOwner {\\r\\n        for (uint256 i=0; i\\u003cLPAddrs.length; i++) {\\r\\n            address add = LPAddrs[i];\\r\\n            uint256 amount = eptConvert(LPNum[i]);\\r\\n            TPAddr.transfer(add, amount);\\r\\n        }   \\r\\n }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n  \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n   \\r\\n}\"},\"DataPlayer.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\nimport \\\"./ARRBase.sol\\\";\\r\\n\\r\\n  \\r\\ncontract DataPlayer is ARRBase{\\r\\n        struct InvestInfo {\\r\\n            uint256 id; \\r\\n            uint256 amount; \\r\\n            uint256 time; \\r\\n            uint256 blockHigh; \\r\\n            uint256 staticBalance; \\r\\n            uint256 staticARRBalance; \\r\\n            uint256 endTime;\\r\\n        }\\r\\n\\r\\n        struct Player{\\r\\n            uint256 id; \\r\\n            address addr; \\r\\n            uint256 LPTime; \\r\\n            uint256 dynamicBalance; \\r\\n            InvestInfo[] list; \\r\\n            uint256 LP_Amount; \\r\\n            uint256 referrerId; \\r\\n            uint256 LPEndTime; \\r\\n            uint256 airEPTdrop;\\r\\n            uint256 airARRdrop;\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n          struct Playerother{\\r\\n            uint256 id; \\r\\n            address addr; \\r\\n            uint256 LPTime; \\r\\n            uint256 dynamicBalance; \\r\\n            uint256 LP_Amount; \\r\\n            uint256 LPEndTime; \\r\\n        }\\r\\n \\r\\n    mapping(uint256 =\\u003e Player) public _playerMap; \\r\\n    mapping(uint256 =\\u003e Playerother) public _playerotherMap; \\r\\n    mapping(address =\\u003e uint256) public _playerAddrMap; \\r\\n    uint256 public _playerCount; \\r\\n    uint256 public _staticRate = 140000; \\r\\n    uint256 public _staticRateother = 111120; \\r\\n    uint256 public newtime;\\r\\n\\r\\n    uint256 public _Yield = 100; \\r\\n    uint256 public _Yieldother = 100; \\r\\n\\r\\n    function getPlayerByAddr(address playerAddr) public view returns(uint256[] memory) { \\r\\n        uint256 id = _playerAddrMap[playerAddr];\\r\\n\\r\\n         uint256[] memory temp = new uint256[](12);\\r\\n\\r\\n        if(id \\u003e 0 ){\\r\\n        Player memory player = _playerMap[id];\\r\\n        temp[0] = player.id;  \\r\\n        temp[1] = player.LPTime;  \\r\\n        temp[2] = player.airEPTdrop; \\r\\n        temp[3] = player.dynamicBalance;  \\r\\n        temp[4] = player.LP_Amount;         \\r\\n        temp[5] = player.referrerId;           \\r\\n        temp[6] = player.LPEndTime;            \\r\\n        temp[7] = player.airARRdrop;             \\r\\n        Playerother memory playerother = _playerotherMap[id];\\r\\n        temp[8] = playerother.LPTime;        \\r\\n        temp[9] = playerother.dynamicBalance; \\r\\n        temp[10] = playerother.LP_Amount;  \\r\\n        temp[11] = playerother.LPEndTime;      \\r\\n        }\\r\\n        return temp; \\r\\n    }\\r\\n\\r\\n\\r\\n    function getlistByAddr(address playerAddr, uint256 indexid) public view returns(uint256[] memory) { \\r\\n        uint256 id = _playerAddrMap[playerAddr];\\r\\n        Player memory player = _playerMap[id];\\r\\n        uint256[] memory temp = new uint256[](4);\\r\\n        temp[0] = player.list[indexid].amount;\\r\\n        temp[1] = player.list[indexid].endTime;\\r\\n        temp[2] = player.list[indexid].staticBalance;\\r\\n        temp[3] = player.list[indexid].time;\\r\\n        return temp; \\r\\n    }\\r\\n\\r\\n    function getAddrById(uint256 id) public view returns(address) { \\r\\n        return _playerMap[id].addr; \\r\\n    }\\r\\n    function getIdByAddr(address addr) public view returns(uint256) { \\r\\n        return _playerAddrMap[addr]; \\r\\n    }\\r\\n \\r\\n   function getTAddr(address playerAddr) public view returns(address) { \\r\\n        uint256 id = _playerAddrMap[playerAddr];\\r\\n        if(id \\u003e 0){\\r\\n            uint256 Tid = _playerMap[id].referrerId;\\r\\n            return _playerMap[Tid].addr;      \\r\\n        }\\r\\n        return address(0); \\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ARRAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"PlayerARR\",\"type\":\"uint256[]\"}],\"name\":\"AirdropARR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"EPTAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_PlayerEPT\",\"type\":\"uint256[]\"}],\"name\":\"AirdropEPT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"LPAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"LPNum\",\"type\":\"uint256[]\"}],\"name\":\"AirdropLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OldARRexchangeARR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Reduceproduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalAirdropARR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalAirdropEPT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalEPTBNBLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawalLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Yield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Yieldother\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_playerARR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_playerAddrMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_playerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_playerEPT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_playerMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"LPTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dynamicBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LP_Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LPEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airEPTdrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airARRdrop\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_playerotherMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"LPTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dynamicBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LP_Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LPEndTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_staticRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_staticRateother\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tAddr\",\"type\":\"address\"}],\"name\":\"binding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAddrById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getIdByAddr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getPlayerByAddr\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getTAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"indexid\",\"type\":\"uint256\"}],\"name\":\"getlistByAddr\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrerAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Gear\",\"type\":\"uint256\"}],\"name\":\"investmentEPT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"investmentEPTARRLP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"investmentEPTBNBLP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemEPTBNBLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Yield\",\"type\":\"uint256\"}],\"name\":\"setLPreferrerYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"}],\"name\":\"setLPreferrerotherYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"}],\"name\":\"setLPstaticRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"}],\"name\":\"setLPstaticotherRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleStatic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ARRpledge", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://13f3ca2336bf426d75cd72366508b35b8af894a09e414ddd176e3fb21f4442e5"}