{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: contracts/libs/IBEP20.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract IBEP20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token decimals.\r\n   */\r\n  function decimals() external view virtual returns (uint8);\r\n\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() external view virtual returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the token name.\r\n   */\r\n  function name() external view virtual returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(\r\n    address recipient,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address spender\r\n  ) external view virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(\r\n    address spender,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/libs/IMinter.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract IMinter {\r\n  function setMinter(address uid, uint256 level) external virtual;\r\n\r\n  function updateTime() external virtual;\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/libs/Context.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view returns (address payable) {\r\n    return payable(msg.sender);\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this;\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File: contracts/libs/Ownable.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  using SafeMath for uint256;\r\n\r\n  address internal _owner;\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _owner = _msgSender();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/libs/ICakePool.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract ICakePool {\r\n  function balanceOf(address account) external view virtual returns (uint256);\r\n\r\n  function mint(uint256 mintAmount) external virtual returns (uint256);\r\n\r\n  function redeem(uint256 redeemTokens) external virtual returns (uint256);\r\n\r\n  function redeemUnderlying(\r\n    uint256 redeemAmount\r\n  ) external virtual returns (uint256);\r\n}\r\n\r\n// File: contracts/libs/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n  bool private constant ENTERED = true;\r\n  bool private constant NOT_ENTERED = false;\r\n\r\n  bool private _REGISTER;\r\n  bool private _INVEST;\r\n\r\n  constructor() {\r\n    _REGISTER = NOT_ENTERED;\r\n  }\r\n\r\n  modifier nonReentrantRegister() {\r\n    require(!_REGISTER, \"ReentrancyGuard: reentrant call\");\r\n    _REGISTER = ENTERED;\r\n    _;\r\n    _REGISTER = NOT_ENTERED;\r\n  }\r\n\r\n  modifier nonReentrantInvest() {\r\n    require(!_INVEST, \"ReentrancyGuard: reentrant call\");\r\n    _INVEST = ENTERED;\r\n    _;\r\n    _INVEST = NOT_ENTERED;\r\n  }\r\n}\r\n\r\n// File: contracts/MMMM.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\ncontract MMMM is Ownable, ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n\r\n  struct UserInfo {\r\n    uint256 amount;\r\n    uint256 teamPV;\r\n    uint256 level;\r\n    uint256 energy;\r\n    uint256 ladder;\r\n    uint256 ladderNext;\r\n    uint256 settleTime;\r\n    uint256 income;\r\n    uint256 incomeDynamic;\r\n    uint256 incomeStatic;\r\n  }\r\n\r\n  struct User {\r\n    address uid;\r\n    address pid;\r\n    UserInfo info;\r\n    uint256 isPartner;\r\n    uint256 inviteNum;\r\n    uint256 inviteCode;\r\n    uint256 inviterCode;\r\n    uint256 time;\r\n  }\r\n\r\n  struct Level {\r\n    uint256 id;\r\n    uint256 teamPV;\r\n    uint256 num;\r\n    uint256 rate;\r\n  }\r\n\r\n  struct Rate {\r\n    uint256 helper;\r\n    uint256 funds;\r\n    uint256 market;\r\n    uint256 mining;\r\n    uint256 comp_1;\r\n    uint256 comp_2;\r\n  }\r\n\r\n  struct Order {\r\n    uint256 key;\r\n    uint256 amount;\r\n    bool isWithdraw;\r\n    bool pledge;\r\n    uint256 rate;\r\n    uint256 income;\r\n    uint256 unlockIncome;\r\n    uint256 settleTime;\r\n    uint256 unlockTime;\r\n    uint256 unlockDate;\r\n    uint256 time;\r\n  }\r\n\r\n  struct Ladder {\r\n    uint256 min;\r\n    uint256 max;\r\n    uint256 day;\r\n  }\r\n\r\n  struct SwapPrice {\r\n    uint256 price;\r\n    uint256 time;\r\n  }\r\n\r\n  struct Pools {\r\n    uint256 helper;\r\n    uint256 funds;\r\n    uint256 market;\r\n    uint256 swap;\r\n    uint256 comp_1;\r\n    uint256 comp_2;\r\n    uint256 bonus;\r\n  }\r\n\r\n  struct Compensate {\r\n    address uid;\r\n    uint256 amount;\r\n  }\r\n\r\n  mapping(address => User) internal _users;\r\n  mapping(uint256 => mapping(address => UserInfo)) internal _userInfo;\r\n  mapping(uint256 => address) internal _inviter;\r\n  mapping(address => address[]) internal _inviters;\r\n  mapping(uint256 => mapping(address => Order[])) internal _orders;\r\n  mapping(uint256 => mapping(address => uint256[])) internal _lockOrders;\r\n  mapping(uint256 => mapping(uint256 => mapping(address => uint256[])))\r\n    internal _unlockOrders;\r\n  mapping(uint256 => mapping(address => uint256)) internal _withdrawIndex;\r\n  mapping(address => mapping(address => bool)) internal _inviteRecord;\r\n  mapping(uint256 => Pools) internal _fundPools;\r\n  mapping(uint256 => Compensate[]) internal _compensates;\r\n  mapping(address => uint256) internal _incomeTotal;\r\n  mapping(uint256 => uint256) internal _investTotalDay;\r\n\r\n  uint256[4] internal _leaderNum = [0, 0, 0, 0];\r\n\r\n  Ladder[5] internal _ladders;\r\n  Level[4] internal _levels;\r\n\r\n  ICakePool internal _vUSDT;\r\n  IBEP20 internal _USDT;\r\n  IBEP20 internal _USDM;\r\n\r\n  IMinter internal _MINTER;\r\n  Rate internal _rate;\r\n\r\n  uint256 internal _inviterCode = 81256;\r\n  uint256 internal RBASE = 10000;\r\n  uint256 internal _investTotal;\r\n  uint256 internal _burnTotal = 0;\r\n\r\n  uint256 internal _time;\r\n  uint256 internal _deployTime;\r\n\r\n  bool internal _countdown_enable = false;\r\n  uint256 internal _countdown;\r\n  uint256 internal _lastTime;\r\n  uint256 internal _ver = 0;\r\n\r\n  uint256 internal _rate_USDM = 200;\r\n  uint256 internal _price_USDM = 1e18;\r\n  uint256 internal compensateMax = 100;\r\n  uint256 internal _pv_level = 16;\r\n  uint256 internal _cycle = 1 days;\r\n\r\n  constructor(\r\n    address invite,\r\n    address usdt,\r\n    address usdm,\r\n    address minter,\r\n    address pool,\r\n    uint256 time\r\n  ) {\r\n    _USDT = IBEP20(usdt);\r\n    _vUSDT = ICakePool(pool);\r\n    _USDM = IBEP20(usdm);\r\n\r\n    _MINTER = IMinter(minter);\r\n    _time = time;\r\n    _deployTime = time;\r\n\r\n    _rate = Rate(9700, 100, 50, 50, 30, 70);\r\n\r\n    _ladders[0] = Ladder(100e18, 1000e18, 10);\r\n    _ladders[1] = Ladder(100e18, 2000e18, 10);\r\n    _ladders[2] = Ladder(100e18, 3000e18, 10);\r\n    _ladders[3] = Ladder(100e18, 4000e18, 10);\r\n    _ladders[4] = Ladder(100e18, 5000e18, 10);\r\n\r\n    _levels[0] = Level(0, 0, 0, 0);\r\n    _levels[1] = Level(1, 100000e18, 6, 1000);\r\n    _levels[2] = Level(2, 600000e18, 10, 2000);\r\n    _levels[3] = Level(3, 2000000e18, 16, 3000);\r\n\r\n    _register(invite, address(0));\r\n  }\r\n\r\n  modifier check4MStatus(bool is_invest) {\r\n    updateTime();\r\n    if (!_countdown_enable) {\r\n      if (_lastTime > 0 && _lastTime.add(3 days) < block.timestamp) {\r\n        _countdown_enable = true;\r\n        _countdown = block.timestamp.add(72 hours);\r\n      }\r\n      _;\r\n    } else {\r\n      if (is_invest) {\r\n        _countdown += 1 hours;\r\n        if (_countdown > block.timestamp.add(72 hours)) {\r\n          _countdown = block.timestamp.add(72 hours);\r\n        }\r\n      }\r\n      if (block.timestamp > _countdown) {\r\n        _compensate();\r\n        _restart();\r\n      } else {\r\n        _;\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateTime() public {\r\n    uint256 time = _time;\r\n    if (time.add(_cycle) > block.timestamp) return;\r\n    do {\r\n      time = time.add(_cycle);\r\n    } while (time.add(_cycle) < block.timestamp);\r\n    _time = time;\r\n    _MINTER.updateTime();\r\n  }\r\n\r\n  function transfer(\r\n    address token,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public onlyOwner {\r\n    IBEP20(token).transfer(recipient, amount);\r\n  }\r\n\r\n  function register(uint256 code) public {\r\n    address pid = _inviter[code];\r\n    require(_users[pid].uid != address(0), \"invalid invite code\");\r\n    require(!isUser(msg.sender), \"registered\");\r\n    _register(msg.sender, pid);\r\n  }\r\n\r\n  function _register(\r\n    address uid,\r\n    address pid\r\n  ) internal nonReentrantRegister check4MStatus(false) {\r\n    User memory user;\r\n    user.uid = uid;\r\n    user.pid = pid;\r\n    user.inviteCode = _inviterCode;\r\n    user.inviterCode = _users[pid].inviteCode;\r\n    user.time = block.timestamp;\r\n\r\n    _users[uid] = user;\r\n    _inviters[pid].push(uid);\r\n    _inviter[_inviterCode] = uid;\r\n    _inviterCode++;\r\n\r\n    _leaderNum[0]++;\r\n  }\r\n\r\n  function buyTickets(uint256 amount) external check4MStatus(false) {\r\n    address uid = msg.sender;\r\n    require(amount > 0, \"invalid amount\");\r\n    require(isUser(uid), \"unregistered\");\r\n\r\n    uint256 usdtAmount = amount.mul(_price_USDM).div(1e18);\r\n    _USDT.transferFrom(uid, address(this), usdtAmount);\r\n\r\n    if (block.chainid != 1337) {\r\n      _deposit();\r\n    }\r\n\r\n    _fundPools[_ver].bonus += usdtAmount.div(2);\r\n    _fundPools[_ver].swap += usdtAmount.div(2);\r\n\r\n    _USDM.transfer(uid, amount);\r\n  }\r\n\r\n  modifier validateLadder(uint256 amount) {\r\n    address uid = msg.sender;\r\n    UserInfo storage userInfo = _userInfo[_ver][uid];\r\n    uint256 ladder = userInfo.ladder;\r\n    uint256 ladderNext = userInfo.ladderNext;\r\n    uint256 amountMin = _ladders[ladder].min;\r\n    uint256 amountMax = _ladders[ladder].max;\r\n\r\n    if (ladderNext > 0) {\r\n      if (amount > amountMax) {\r\n        if (ladderNext > _time) {\r\n          revert(\"the next step time has not been reached\");\r\n        } else if (userInfo.ladder < 4) {\r\n          userInfo.ladder++;\r\n          userInfo.ladderNext = 0;\r\n        }\r\n      }\r\n    } else if (amount > amountMax) {\r\n      revert(\"unable to proceed to the next level of investment\");\r\n    }\r\n\r\n    ladder = userInfo.ladder;\r\n    amountMin = _ladders[ladder].min;\r\n    amountMax = _ladders[ladder].max;\r\n\r\n    if (\r\n      amount == amountMax && userInfo.ladderNext == 0 && userInfo.ladder < 4\r\n    ) {\r\n      userInfo.ladderNext = _time.add(_ladders[userInfo.ladder].day * _cycle);\r\n    }\r\n\r\n    if (amount < amountMin) {\r\n      revert(\"the minimum investment amount is not reached\");\r\n    }\r\n    if (amount > amountMax) {\r\n      revert(\"the investment amount cannot exceed the current stage\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  function staticIncomeParams(\r\n    address uid\r\n  ) internal view returns (uint256 rate, uint256 day) {\r\n    UserInfo memory userInfo = _userInfo[_ver][uid];\r\n    if (userInfo.amount == 0) {\r\n      return (120, 7 * _cycle);\r\n    } else if (userInfo.income < userInfo.amount) {\r\n      return (120, 7 * _cycle);\r\n    } else if (userInfo.income.div(userInfo.amount) < 2) {\r\n      return (100, 10 * _cycle);\r\n    } else if (userInfo.income.div(userInfo.amount) < 3) {\r\n      return (80, 15 * _cycle);\r\n    } else if (userInfo.income.div(userInfo.amount) < 4) {\r\n      return (60, 20 * _cycle);\r\n    } else if (userInfo.income.div(userInfo.amount) >= 4) {\r\n      return (30, 30 * _cycle);\r\n    }\r\n  }\r\n\r\n  function _deposit() private {\r\n    uint256 amount = _USDT.balanceOf(address(this));\r\n    _USDT.approve(address(_vUSDT), amount);\r\n    _vUSDT.mint(amount);\r\n  }\r\n\r\n  function invest(\r\n    uint256 amount\r\n  ) public nonReentrantInvest check4MStatus(true) validateLadder(amount) {\r\n    address uid = msg.sender;\r\n    require(isUser(uid), \"unregistered\");\r\n    require(amount % 50 == 0, \"the investment amount is a multiple of 50\");\r\n\r\n    _incomeStatic(uid);\r\n\r\n    uint256 ticketAmount = amount.mul(_rate_USDM).div(RBASE);\r\n\r\n    _USDM.transferFrom(uid, address(this), ticketAmount);\r\n    _USDT.transferFrom(uid, address(this), amount);\r\n\r\n    if (block.chainid != 1337) {\r\n      _deposit();\r\n    }\r\n\r\n    Compensate memory compensate;\r\n    compensate.uid = uid;\r\n    compensate.amount = amount;\r\n    _compensates[_ver].push(compensate);\r\n\r\n    if (!_inviteRecord[_users[uid].pid][uid]) {\r\n      _inviteRecord[_users[uid].pid][uid] = true;\r\n      _users[_users[uid].pid].inviteNum++;\r\n    }\r\n\r\n    if (_userInfo[_ver][uid].settleTime == 0) {\r\n      _userInfo[_ver][uid].settleTime = _time;\r\n    }\r\n\r\n    {\r\n      _fundPools[_ver].helper += amount.mul(_rate.helper).div(RBASE);\r\n      _fundPools[_ver].funds += amount.mul(_rate.funds).div(RBASE);\r\n      _fundPools[_ver].market += amount.mul(_rate.market).div(RBASE);\r\n      _fundPools[_ver].swap += amount.mul(_rate.mining).div(RBASE);\r\n      _fundPools[_ver].comp_1 += amount.mul(_rate.comp_1).div(RBASE);\r\n      _fundPools[_ver].comp_2 += amount.mul(_rate.comp_2).div(RBASE);\r\n\r\n      _saveOrder(uid, amount);\r\n    }\r\n\r\n    _lastTime = block.timestamp;\r\n    _userInfo[_ver][uid].amount += amount;\r\n    _investTotal += amount;\r\n    _investTotalDay[_time] += amount;\r\n    _burnTotal += ticketAmount;\r\n  }\r\n\r\n  function _saveOrder(address uid, uint256 amount) private {\r\n    (uint256 rate, uint256 time) = staticIncomeParams(uid);\r\n    Order memory order;\r\n\r\n    order.key = _orders[_ver][uid].length;\r\n    order.amount = amount;\r\n    order.rate = rate;\r\n    order.settleTime = _time;\r\n    order.unlockDate = _time.add(time);\r\n    order.unlockTime = block.timestamp.add(time);\r\n    order.time = block.timestamp;\r\n\r\n    _orders[_ver][uid].push(order);\r\n    _unlockOrder(order);\r\n  }\r\n\r\n  function _unlockOrder(Order memory _order) private {\r\n    address uid = msg.sender;\r\n    uint256 amount = _order.amount;\r\n\r\n    bool pledge = false;\r\n    uint256 ind = _withdrawIndex[_ver][uid];\r\n    for (uint256 i = 0; i < _lockOrders[_ver][uid].length; i++) {\r\n      uint256 key = _lockOrders[_ver][uid][i];\r\n      Order storage order = _orders[_ver][uid][key];\r\n      if (order.unlockTime <= block.timestamp && amount >= order.amount) {\r\n        pledge = true;\r\n        order.pledge = true;\r\n        _lockOrders[_ver][uid][i] = _order.key;\r\n        _unlockOrders[_ver][ind][uid].push(key);\r\n        _userInfo[_ver][uid].energy += amount.sub(order.amount).mul(3);\r\n        _setParentPV(uid, amount.sub(order.amount));\r\n        break;\r\n      }\r\n    }\r\n    if (!pledge) {\r\n      _lockOrders[_ver][uid].push(_order.key);\r\n      _userInfo[_ver][uid].energy += amount.mul(3);\r\n      _setParentPV(uid, amount);\r\n    }\r\n  }\r\n\r\n  function _setParentPV(address uid, uint256 amount) private {\r\n    if (amount == 0) return;\r\n    uint256 ind = 1;\r\n    address pid = _users[uid].pid;\r\n    while (pid != address(0) && ind <= _pv_level) {\r\n      _userInfo[_ver][pid].teamPV += amount;\r\n      _setUserLevel(pid);\r\n      pid = _users[pid].pid;\r\n      ind++;\r\n    }\r\n  }\r\n\r\n  function _setUserLevel(address uid) private {\r\n    uint256 teamPV = _userInfo[_ver][uid].teamPV;\r\n    uint256 inviteNum = _users[uid].inviteNum;\r\n    Level memory level;\r\n    for (uint256 i = 3; i > 0; i--) {\r\n      level = _levels[i];\r\n      if (teamPV >= level.teamPV && inviteNum >= level.num) {\r\n        if (_userInfo[_ver][uid].level >= level.id) break;\r\n        _leaderNum[_userInfo[_ver][uid].level]--;\r\n        _userInfo[_ver][uid].level = level.id;\r\n        _leaderNum[_userInfo[_ver][uid].level]++;\r\n        _MINTER.setMinter(uid, level.id);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function incomeStatic() public check4MStatus(false) {\r\n    address uid = msg.sender;\r\n\r\n    require(_lockOrders[_ver][uid].length > 0, \"invalid order\");\r\n    require(_userInfo[_ver][uid].settleTime < _time, \"invalid settle time\");\r\n\r\n    _incomeStatic(uid);\r\n  }\r\n\r\n  function _incomeStatic(address uid) private {\r\n    if (_lockOrders[_ver][uid].length == 0) return;\r\n    if (_userInfo[_ver][uid].settleTime == _time) return;\r\n\r\n    _userInfo[_ver][uid].settleTime = _time;\r\n\r\n    uint256 base;\r\n    for (uint256 i = 0; i < _lockOrders[_ver][uid].length; i++) {\r\n      uint256 key = _lockOrders[_ver][uid][i];\r\n      Order storage _order = _orders[_ver][uid][key];\r\n      if (_order.unlockDate < _time) {\r\n        base = _order.unlockDate.sub(_order.settleTime).div(_cycle);\r\n      } else {\r\n        base = _time.sub(_order.settleTime).div(_cycle);\r\n      }\r\n      uint256 amount = _order.amount;\r\n      uint256 income = amount.mul(_order.rate).mul(base).div(RBASE);\r\n      if (income > 0) {\r\n        _withdraw(uid, income);\r\n\r\n        _userInfo[_ver][uid].income += income;\r\n        _userInfo[_ver][uid].incomeStatic += income;\r\n        _order.income += income;\r\n        _order.settleTime = _time > _order.unlockDate\r\n          ? _order.unlockDate\r\n          : _time;\r\n        _fundPools[_ver].helper -= income;\r\n\r\n        _incomeInvite(uid, income);\r\n        _incomeTeam(uid, income);\r\n      }\r\n    }\r\n  }\r\n\r\n  function inviteRate(uint256 level) private pure returns (uint256) {\r\n    if (level == 1) {\r\n      return 1000;\r\n    } else if (level == 2) {\r\n      return 500;\r\n    } else if (level == 3) {\r\n      return 400;\r\n    } else if (level == 4) {\r\n      return 300;\r\n    } else if (level == 5) {\r\n      return 200;\r\n    } else if (level == 6) {\r\n      return 100;\r\n    } else if (level == 7) {\r\n      return 200;\r\n    } else if (level == 8) {\r\n      return 300;\r\n    } else if (level == 9) {\r\n      return 400;\r\n    } else if (level == 10) {\r\n      return 500;\r\n    } else if (level >= 11 && level <= 15) {\r\n      return 200;\r\n    } else if (level == 16) {\r\n      return 100;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function _incomeInvite(address uid, uint256 amount) private {\r\n    address pid = _users[uid].pid;\r\n    uint256 level = 1;\r\n    uint256 rate;\r\n    uint256 income;\r\n    User memory user;\r\n    while (pid != address(0) && level <= _pv_level) {\r\n      user = _users[pid];\r\n      if (user.inviteNum >= level || user.isPartner >= level) {\r\n        rate = inviteRate(level);\r\n        income = amount.mul(rate).div(RBASE);\r\n        if (income < _userInfo[_ver][pid].energy) {\r\n          _userInfo[_ver][pid].energy -= income;\r\n        } else {\r\n          income = _userInfo[_ver][pid].energy;\r\n          _userInfo[_ver][pid].energy = 0;\r\n        }\r\n        if (income > 0) {\r\n          _withdraw(pid, income);\r\n          _userInfo[_ver][pid].income += income;\r\n          _userInfo[_ver][pid].incomeDynamic += income;\r\n          _fundPools[_ver].helper -= income;\r\n          _incomeTotal[pid] += income;\r\n        }\r\n      }\r\n      level++;\r\n      pid = _users[pid].pid;\r\n    }\r\n  }\r\n\r\n  function _incomeTeam(address uid, uint256 amount) private {\r\n    address pid = _users[uid].pid;\r\n    uint256 old_level;\r\n    uint256 old_rate;\r\n    uint256 rate;\r\n    uint256 income;\r\n    UserInfo storage userInfo;\r\n    while (pid != address(0)) {\r\n      userInfo = _userInfo[_ver][pid];\r\n      if (userInfo.level > old_level) {\r\n        rate = _levels[userInfo.level].rate - old_rate;\r\n        income = amount.mul(rate).div(RBASE);\r\n        if (income < _userInfo[_ver][pid].energy) {\r\n          _userInfo[_ver][pid].energy -= income;\r\n        } else {\r\n          income = _userInfo[_ver][pid].energy;\r\n          _userInfo[_ver][pid].energy = 0;\r\n        }\r\n        if (income > 0) {\r\n          _withdraw(pid, income);\r\n          userInfo.income += income;\r\n          userInfo.incomeDynamic += income;\r\n          _fundPools[_ver].helper -= income;\r\n          _incomeTotal[pid] += income;\r\n        }\r\n        old_rate = _levels[userInfo.level].rate;\r\n        old_level = userInfo.level;\r\n        if (old_level == 3) break;\r\n      }\r\n      pid = _users[pid].pid;\r\n    }\r\n  }\r\n\r\n  function withdraw() public check4MStatus(false) {\r\n    address uid = msg.sender;\r\n    uint256 ind = _withdrawIndex[_ver][uid];\r\n\r\n    require(_unlockOrders[_ver][ind][uid].length > 0, \"invalid order\");\r\n\r\n    _incomeStatic(uid);\r\n\r\n    for (uint256 i = 0; i < _unlockOrders[_ver][ind][uid].length; i++) {\r\n      Order storage _order = _orders[_ver][uid][\r\n        _unlockOrders[_ver][ind][uid][i]\r\n      ];\r\n      if (_order.isWithdraw) continue;\r\n      _withdraw(uid, _order.amount);\r\n      _order.isWithdraw = true;\r\n      _fundPools[_ver].helper -= _order.amount;\r\n    }\r\n    _withdrawIndex[_ver][uid]++;\r\n  }\r\n\r\n  function withdrawPool(\r\n    address to,\r\n    uint256 amount,\r\n    string memory _type\r\n  ) external onlyOwner {\r\n    updateTime();\r\n    _withdraw(to, amount);\r\n    if (bytes(_type).length == bytes(\"helper\").length) {\r\n      _fundPools[_ver].helper -= amount;\r\n    } else if (bytes(_type).length == bytes(\"funds\").length) {\r\n      _fundPools[_ver].funds -= amount;\r\n    } else if (bytes(_type).length == bytes(\"market\").length) {\r\n      _fundPools[_ver].market -= amount;\r\n    } else if (bytes(_type).length == bytes(\"swap\").length) {\r\n      _fundPools[_ver].swap -= amount;\r\n    } else if (bytes(_type).length == bytes(\"comp_1\").length) {\r\n      _fundPools[_ver].comp_1 -= amount;\r\n    } else if (bytes(_type).length == bytes(\"comp_2\").length) {\r\n      _fundPools[_ver].comp_2 -= amount;\r\n    } else if (bytes(_type).length == bytes(\"bonus\").length) {\r\n      _fundPools[_ver].bonus -= amount;\r\n    } else {\r\n      revert(\"fail type\");\r\n    }\r\n  }\r\n\r\n  function withdrawAll(address to) external onlyOwner {\r\n    _vUSDT.redeem(_vUSDT.balanceOf(address(this)));\r\n    _USDT.transfer(to, _USDT.balanceOf(address(this)));\r\n  }\r\n\r\n  function _withdraw(address uid, uint256 amount) private {\r\n    if (block.chainid != 1337) {\r\n      uint256 amount_1 = _USDT.balanceOf(address(this));\r\n      _vUSDT.redeemUnderlying(amount);\r\n      uint256 amount_2 = _USDT.balanceOf(address(this));\r\n      amount = amount_2.sub(amount_1);\r\n    }\r\n    require(_USDT.transfer(uid, amount), \"transfer fail\");\r\n  }\r\n\r\n  function _restart() private {\r\n    _ver++;\r\n    _countdown_enable = false;\r\n    _countdown = 0;\r\n    _investTotal = 0;\r\n    _deployTime = block.timestamp;\r\n  }\r\n\r\n  function _compensate() private {\r\n    Compensate[] memory compensates = _compensates[_ver];\r\n    uint256 length = compensates.length;\r\n    if (length == 0) return;\r\n\r\n    if (block.chainid != 1337) {\r\n      _withdraw(address(this), _fundPools[_ver].comp_1);\r\n    }\r\n\r\n    uint256 level = 1;\r\n    uint256 multiple;\r\n    uint256 usdtBalance;\r\n    uint256 amount;\r\n\r\n    for (uint256 i = length.sub(1); i >= 0; i--) {\r\n      if (level == 1) {\r\n        multiple = 5;\r\n      } else if (level >= 2 && level <= 4) {\r\n        multiple = 3;\r\n      } else {\r\n        multiple = 2;\r\n      }\r\n      amount = compensates[i].amount.mul(multiple);\r\n      usdtBalance = _USDT.balanceOf(address(this));\r\n      if (amount < usdtBalance) {\r\n        _USDT.transfer(compensates[i].uid, amount);\r\n      } else {\r\n        _USDT.transfer(compensates[i].uid, usdtBalance);\r\n        break;\r\n      }\r\n\r\n      if (level == compensateMax) break;\r\n      level++;\r\n    }\r\n  }\r\n\r\n  function setTicketPrice(uint256 price) external onlyOwner {\r\n    require(price > 0, \"invalid price\");\r\n    _price_USDM = price;\r\n  }\r\n\r\n  function setTicketRate(uint256 rate) external onlyOwner {\r\n    require(rate > 0, \"invalid rate\");\r\n    _rate_USDM = rate;\r\n  }\r\n\r\n  function setPartner(\r\n    address uid,\r\n    uint256 level,\r\n    uint256 minter\r\n  ) external onlyOwner {\r\n    require(isUser(uid), \"unregistered\");\r\n    require(level >= 0 && level <= _pv_level, \"invalid level\");\r\n    require(minter >= 1 && minter <= 3, \"invalid minter\");\r\n\r\n    _users[uid].isPartner = level;\r\n    _MINTER.setMinter(uid, minter);\r\n  }\r\n\r\n  function setCompensateMax(uint256 max) external onlyOwner {\r\n    require(max > 0, \"invalid max\");\r\n    compensateMax = max;\r\n  }\r\n\r\n  function setPVLevel(uint256 level) external onlyOwner {\r\n    require(level > 0, \"invalid level\");\r\n    _pv_level = level;\r\n  }\r\n\r\n  function inviter(address uid) external view returns (address) {\r\n    return _users[uid].pid;\r\n  }\r\n\r\n  function getUser(address uid) external view returns (User memory) {\r\n    User memory user = _users[uid];\r\n    user.info = _userInfo[_ver][uid];\r\n    return user;\r\n  }\r\n\r\n  function isUser(address uid) public view returns (bool) {\r\n    return _users[uid].uid != address(0);\r\n  }\r\n\r\n  function isActiveUser(address uid) external view returns (bool) {\r\n    return _userInfo[_ver][uid].amount > 0;\r\n  }\r\n\r\n  function isPartner(address uid) external view returns (bool) {\r\n    return _users[uid].isPartner > 0;\r\n  }\r\n\r\n  function leaderNum() external view returns (uint256[4] memory) {\r\n    return _leaderNum;\r\n  }\r\n\r\n  function params()\r\n    external\r\n    view\r\n    returns (\r\n      uint256 version,\r\n      uint256 bonus_funds,\r\n      uint256 burn_total,\r\n      uint256 invest_total,\r\n      uint256 invest_total_day,\r\n      uint256 deployTime,\r\n      uint256 countdown_time,\r\n      uint256 time,\r\n      uint256 lastTime,\r\n      uint256 currentTime,\r\n      bool countdown_enable\r\n    )\r\n  {\r\n    uint256 _bonus_funds = _fundPools[_ver].comp_1;\r\n\r\n    version = _ver;\r\n    bonus_funds = _bonus_funds;\r\n    burn_total = _burnTotal;\r\n    invest_total = _investTotal;\r\n    invest_total_day = _investTotalDay[_time];\r\n    deployTime = _deployTime;\r\n    countdown_time = _countdown > block.timestamp\r\n      ? _countdown.sub(block.timestamp)\r\n      : 0;\r\n    time = _time;\r\n    lastTime = _lastTime;\r\n    currentTime = block.timestamp;\r\n    countdown_enable = _countdown_enable;\r\n  }\r\n\r\n  function fundPools()\r\n    external\r\n    view\r\n    returns (\r\n      uint256 helper,\r\n      uint256 funds,\r\n      uint256 market,\r\n      uint256 comp_1,\r\n      uint256 comp_2,\r\n      uint256 bonus,\r\n      uint256 swap\r\n    )\r\n  {\r\n    return (\r\n      _fundPools[_ver].helper,\r\n      _fundPools[_ver].funds,\r\n      _fundPools[_ver].market,\r\n      _fundPools[_ver].comp_1,\r\n      _fundPools[_ver].comp_2,\r\n      _fundPools[_ver].bonus,\r\n      _fundPools[_ver].swap\r\n    );\r\n  }\r\n\r\n  function getLastOrder(\r\n    address uid\r\n  ) external view returns (Order memory order) {\r\n    return _orders[_ver][uid][_orders[_ver][uid].length.sub(1)];\r\n  }\r\n\r\n  function unlockOrderList(\r\n    address uid\r\n  ) external view returns (Order[] memory order, uint256 total) {\r\n    uint256 ind = _withdrawIndex[_ver][uid];\r\n    total = _unlockOrders[_ver][ind][uid].length;\r\n    if (total == 0) return (order, total);\r\n    order = new Order[](total);\r\n    uint256 key;\r\n    for (uint256 i = 0; i < total; i++) {\r\n      key = _unlockOrders[_ver][ind][uid][i];\r\n      order[i] = _orders[_ver][uid][key];\r\n    }\r\n  }\r\n\r\n  function orderList(\r\n    address uid,\r\n    uint256 page,\r\n    uint256 size\r\n  ) external view returns (Order[] memory order, uint256 total) {\r\n    total = _orders[_ver][uid].length;\r\n    if (total == 0) return (order, total);\r\n    page = page < 1 ? 1 : page;\r\n    size = size > total ? total : size;\r\n\r\n    uint256 end = total.sub(1).sub(page.sub(1).mul(size));\r\n    uint256 start = end.sub(size.sub(1));\r\n\r\n    order = new Order[](size);\r\n    uint256 key;\r\n    uint256 base;\r\n    for (uint256 i = start; i <= end; i++) {\r\n      order[key] = _orders[_ver][uid][end - key];\r\n      if (order[key].unlockDate < _time) {\r\n        base = order[key].unlockDate.sub(order[key].settleTime).div(_cycle);\r\n      } else {\r\n        base = _time.sub(order[key].settleTime).div(_cycle);\r\n      }\r\n      uint256 amount = order[key].amount;\r\n      order[key].unlockIncome = amount.mul(order[key].rate).mul(base).div(\r\n        RBASE\r\n      );\r\n      key++;\r\n    }\r\n  }\r\n\r\n  function inviteList(\r\n    address uid,\r\n    uint256 page,\r\n    uint256 size\r\n  ) external view returns (User[] memory user, uint256 total) {\r\n    total = _inviters[uid].length;\r\n    if (total == 0) return (user, total);\r\n    page = page < 1 ? 1 : page;\r\n    size = size > total ? total : size;\r\n\r\n    uint256 end = total.sub(1).sub(page.sub(1).mul(size));\r\n    uint256 start = end.sub(size.sub(1));\r\n\r\n    user = new User[](size);\r\n    uint256 key;\r\n    for (uint256 i = start; i <= end; i++) {\r\n      user[key] = _users[_inviters[uid][end - key]];\r\n      user[key].info = _userInfo[_ver][user[key].uid];\r\n      key++;\r\n    }\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invite\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"helper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"funds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"market\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"comp_1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"comp_2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"getLastOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pledge\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct MMMM.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pid\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamPV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"energy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ladder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ladderNext\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeDynamic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeStatic\",\"type\":\"uint256\"}],\"internalType\":\"struct MMMM.UserInfo\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"isPartner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteCode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviterCode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct MMMM.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incomeStatic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"inviteList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pid\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamPV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"energy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ladder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ladderNext\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeDynamic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeStatic\",\"type\":\"uint256\"}],\"internalType\":\"struct MMMM.UserInfo\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"isPartner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteCode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviterCode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct MMMM.User[]\",\"name\":\"user\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"isActiveUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"isPartner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"isUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderNum\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"orderList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pledge\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct MMMM.Order[]\",\"name\":\"order\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"params\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus_funds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invest_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invest_total_day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deployTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countdown_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"countdown_enable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setCompensateMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setPVLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minter\",\"type\":\"uint256\"}],\"name\":\"setPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setTicketRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"unlockOrderList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pledge\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct MMMM.Order[]\",\"name\":\"order\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"}],\"name\":\"withdrawPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MMMM", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000024c85baf4e40c0d91b261572b656713bb198d93500000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000001eb4df16b3d1eece5a6feaf5f8bad001693b9b990000000000000000000000007bae0ab94f9ddeed5e3afe8f2e15aaf9914a3f77000000000000000000000000fd5840cd36d94d7229439859c0112a4185bc02550000000000000000000000000000000000000000000000000000000065a01080", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b39b154b949ffe4bc442948be21d15b2c85275073d05fa7d5e37e21ec5708508"}