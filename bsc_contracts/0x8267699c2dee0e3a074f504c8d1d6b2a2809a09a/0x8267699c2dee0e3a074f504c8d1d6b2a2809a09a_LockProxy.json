{"SourceCode": "// File: contracts/contracts/core/cross_chain_manager/interface/IEthCrossChainManagerProxy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the EthCrossChainManagerProxy for business contract like LockProxy to obtain the reliable EthCrossChainManager contract hash.\r\n */\r\ninterface IEthCrossChainManagerProxy {\r\n    function getEthCrossChainManager() external view returns (address);\r\n}\r\n\r\n// File: contracts/contracts/core/cross_chain_manager/interface/IEthCrossChainManager.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the EthCrossChainManager contract for business contract like LockProxy to request cross chain transaction\r\n */\r\ninterface IEthCrossChainManager {\r\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\r\n}\r\n\r\n// File: contracts/contracts/libs/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/contracts/libs/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/contracts/libs/utils/Utils.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary Utils {\r\n\r\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\r\n    *  @param _bs   Source bytes array\r\n    *  @return      bytes32\r\n    */\r\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to uint256\r\n    *  @param _b    Source bytes should have length of 32\r\n    *  @return      uint256\r\n    */\r\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 32\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n    }\r\n\r\n    /* @notice      Convert uint256 to bytes\r\n    *  @param _b    uint256 that needs to be converted\r\n    *  @return      bytes\r\n    */\r\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\r\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 0x20 at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x20)\r\n            //In the next word, put value in bytes format to the next 32 bytes\r\n            mstore(add(bs, 0x20), _value)\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to address\r\n    *  @param _bs   Source bytes: bytes length must be 20\r\n    *  @return      Converted address from source bytes\r\n    */\r\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\r\n    {\r\n        require(_bs.length == 20, \"bytes length does not match address\");\r\n        assembly {\r\n            // for _bs, first word store _bs.length, second word store _bs.value\r\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\r\n            addr := mload(add(_bs, 0x14))\r\n        }\r\n\r\n    }\r\n    \r\n    /* @notice      Convert address to bytes\r\n    *  @param _addr Address need to be converted\r\n    *  @return      Converted bytes from address\r\n    */\r\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x14)\r\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\r\n            mstore(add(bs, 0x20), shl(96, _addr))\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n       }\r\n    }\r\n\r\n    /* @notice          Do hash leaf as the multi-chain does\r\n    *  @param _data     Data in bytes format\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(byte(0x0), _data));\r\n    }\r\n\r\n    /* @notice          Do hash children as the multi-chain does\r\n    *  @param _l        Left node\r\n    *  @param _r        Right node\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\r\n    }\r\n\r\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\r\n    *  @param _preBytes     The bytes stored in storage\r\n    *  @param _postBytes    The bytes stored in memory\r\n    *  @return              Bool type indicating if they are equal\r\n    */\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // fslot can contain both the length and contents of the array\r\n                // if slength < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                // slength != 0\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\r\n    *  @param _bytes        The original bytes needs to be sliced\r\n    *  @param _start        The index of _bytes for the start of sliced bytes\r\n    *  @param _length       The index of _bytes for the end of sliced bytes\r\n    *  @return              The sliced bytes\r\n    */\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                // lengthmod <= _length % 32\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m\r\n    *  @param _keepers      The array consists of serveral address\r\n    *  @param _signers      Some specific addresses to be looked into\r\n    *  @param _m            The number requirement paramter\r\n    *  @return              True means containment, false meansdo do not contain.\r\n    */\r\n    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\r\n        uint m = 0;\r\n        for(uint i = 0; i < _signers.length; i++){\r\n            for (uint j = 0; j < _keepers.length; j++) {\r\n                if (_signers[i] == _keepers[j]) {\r\n                    m++;\r\n                    // delete _keepers[j];\r\n                    _keepers[j] = 0x7777777777777777777777777777777777777777;\r\n                }\r\n            }\r\n        }\r\n        return m >= _m;\r\n    }\r\n\r\n    /* @notice              TODO\r\n    *  @param key\r\n    *  @return\r\n    */\r\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\r\n         require(key.length >= 67, \"key lenggh is too short\");\r\n         newkey = slice(key, 0, 35);\r\n         if (uint8(key[66]) % 2 == 0){\r\n             newkey[2] = byte(0x02);\r\n         } else {\r\n             newkey[2] = byte(0x03);\r\n         }\r\n         return newkey;\r\n    }\r\n    \r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n// File: contracts/contracts/libs/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n// File: contracts/contracts/libs/common/ZeroCopySink.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.\r\n *\r\n * Encode basic types in Solidity into bytes easily. It's designed to be used \r\n * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain \r\n * and the decoding rules on other chains should be consistent. Here we  \r\n * follow the underlying serialization rule with implementation found here: \r\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go\r\n *\r\n * Using this library instead of the unchecked serialization method can help reduce\r\n * the risk of serious bugs and handfule, so it's recommended to use it.\r\n *\r\n * Please note that risk can be minimized, yet not eliminated.\r\n */\r\nlibrary ZeroCopySink {\r\n    /* @notice          Convert boolean value into bytes\r\n    *  @param b         The boolean value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteBool(bool b) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            switch iszero(b)\r\n            case 1 {\r\n                mstore(add(buff, 0x20), shl(248, 0x00))\r\n                // mstore8(add(buff, 0x20), 0x00)\r\n            }\r\n            default {\r\n                mstore(add(buff, 0x20), shl(248, 0x01))\r\n                // mstore8(add(buff, 0x20), 0x01)\r\n            }\r\n            mstore(0x40, add(buff, 0x21))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert byte value into bytes\r\n    *  @param b         The byte value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteByte(byte b) internal pure returns (bytes memory) {\r\n        return WriteUint8(uint8(b));\r\n    }\r\n\r\n    /* @notice          Convert uint8 value into bytes\r\n    *  @param v         The uint8 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            mstore(add(buff, 0x20), shl(248, v))\r\n            // mstore(add(buff, 0x20), byte(0x1f, v))\r\n            mstore(0x40, add(buff, 0x21))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint16 value into bytes\r\n    *  @param v         The uint16 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x02\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x22))\r\n        }\r\n        return buff;\r\n    }\r\n    \r\n    /* @notice          Convert uint32 value into bytes\r\n    *  @param v         The uint32 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x04\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x24))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint64 value into bytes\r\n    *  @param v         The uint64 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x08\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x28))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert limited uint256 value into bytes\r\n    *  @param v         The uint256 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\r\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x20\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Encode bytes format data into bytes\r\n    *  @param data      The bytes array data\r\n    *  @return          Encoded bytes array\r\n    */\r\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\r\n        uint64 l = uint64(data.length);\r\n        return abi.encodePacked(WriteVarUint(l), data);\r\n    }\r\n\r\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\r\n        if (v < 0xFD){\r\n    \t\treturn WriteUint8(uint8(v));\r\n    \t} else if (v <= 0xFFFF) {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\r\n    \t} else if (v <= 0xFFFFFFFF) {\r\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\r\n    \t} else {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\r\n    \t}\r\n    }\r\n}\r\n// File: contracts/contracts/libs/common/ZeroCopySource.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.\r\n *\r\n * Decode into basic types in Solidity from bytes easily. It's designed to be used \r\n * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain \r\n * and the encoding rule on other chains should be consistent, and . Here we\r\n * follow the underlying deserialization rule with implementation found here: \r\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go\r\n *\r\n * Using this library instead of the unchecked serialization method can help reduce\r\n * the risk of serious bugs and handfule, so it's recommended to use it.\r\n *\r\n * Please note that risk can be minimized, yet not eliminated.\r\n */\r\nlibrary ZeroCopySource {\r\n    /* @notice              Read next byte as boolean type starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the boolean value\r\n    *  @return              The the read boolean value and new offset\r\n    */\r\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\r\n        // byte === bytes1\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        bool value;\r\n        if (v == 0x01) {\r\n\t\t    value = true;\r\n    \t} else if (v == 0x00) {\r\n            value = false;\r\n        } else {\r\n            revert(\"NextBool value error\");\r\n        }\r\n        return (value, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read byte value and new offset\r\n    */\r\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte as uint8 starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read uint8 value and new offset\r\n    */\r\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\r\n        uint8 v;\r\n        assembly{\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x01))\r\n            v := mload(sub(tmpbytes, 0x1f))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next two bytes as uint16 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint16 value\r\n    *  @return              The read uint16 value and updated offset\r\n    */\r\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\r\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\r\n        \r\n        uint16 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0x01, bvalue))\r\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x02))\r\n            v := mload(sub(tmpbytes, 0x1e))\r\n        }\r\n        return (v, offset + 2);\r\n    }\r\n\r\n\r\n    /* @notice              Read next four bytes as uint32 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint32 value\r\n    *  @return              The read uint32 value and updated offset\r\n    */\r\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\r\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\r\n        uint32 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x04\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 4);\r\n    }\r\n\r\n    /* @notice              Read next eight bytes as uint64 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint64 value\r\n    *  @return              The read uint64 value and updated offset\r\n    */\r\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\r\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\r\n        uint64 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x08\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 8);\r\n    }\r\n\r\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\r\n                            there are limits considering the numerical limits in multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint256 value\r\n    *  @return              The read uint256 value and updated offset\r\n    */\r\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\r\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\r\n        uint256 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x20\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(tmpbytes)\r\n        }\r\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        return (v, offset + 32);\r\n    }\r\n    /* @notice              Read next variable bytes starting from offset,\r\n                            the decoding rule coming from multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read variable bytes array value and updated offset\r\n    */\r\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\r\n        uint len;\r\n        (len, offset) = NextVarUint(buff, offset);\r\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\r\n        bytes memory tempBytes;\r\n        assembly{\r\n            switch iszero(len)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(len, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, len)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, len)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return (tempBytes, offset + len);\r\n    }\r\n    /* @notice              Read next 32 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes32 value and updated offset\r\n    */\r\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\r\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\r\n        bytes32 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 32);\r\n    }\r\n\r\n    /* @notice              Read next 20 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes20 value and updated offset\r\n    */\r\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\r\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\r\n        bytes20 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 20);\r\n    }\r\n    \r\n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\r\n        byte v;\r\n        (v, offset) = NextByte(buff, offset);\r\n\r\n        uint value;\r\n        if (v == 0xFD) {\r\n            // return NextUint16(buff, offset);\r\n            (value, offset) = NextUint16(buff, offset);\r\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\r\n            return (value, offset);\r\n        } else if (v == 0xFE) {\r\n            // return NextUint32(buff, offset);\r\n            (value, offset) = NextUint32(buff, offset);\r\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        } else if (v == 0xFF) {\r\n            // return NextUint64(buff, offset);\r\n            (value, offset) = NextUint64(buff, offset);\r\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        } else{\r\n            // return (uint8(v), offset);\r\n            value = uint8(v);\r\n            require(value < 0xFD, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        }\r\n    }\r\n}\r\n// File: contracts/contracts/libs/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/contracts/libs/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public  onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/contracts/core/lock_proxy/LockProxy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LockProxy is Ownable {\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct TxArgs {\r\n        bytes toAssetHash;\r\n        bytes toAddress;\r\n        uint256 amount;\r\n    }\r\n    address public managerProxyContract;\r\n    mapping(uint64 => bytes) public proxyHashMap;\r\n    mapping(address => mapping(uint64 => bytes)) public assetHashMap;\r\n    mapping(address => bool) safeTransfer;\r\n\r\n    event SetManagerProxyEvent(address manager);\r\n    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);\r\n    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash, uint initialAmount);\r\n    event UnlockEvent(address toAssetHash, address toAddress, uint256 amount);\r\n    event LockEvent(address fromAssetHash, address fromAddress, uint64 toChainId, bytes toAssetHash, bytes toAddress, uint256 amount);\r\n    \r\n    modifier onlyManagerContract() {\r\n        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);\r\n        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\r\n        _;\r\n    }\r\n    \r\n    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {\r\n        managerProxyContract = ethCCMProxyAddr;\r\n        emit SetManagerProxyEvent(managerProxyContract);\r\n    }\r\n    \r\n    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {\r\n        proxyHashMap[toChainId] = targetProxyHash;\r\n        emit BindProxyEvent(toChainId, targetProxyHash);\r\n        return true;\r\n    }\r\n    \r\n    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {\r\n        assetHashMap[fromAssetHash][toChainId] = toAssetHash;\r\n        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash));\r\n        return true;\r\n    }\r\n    \r\n    /* @notice                  This function is meant to be invoked by the user,\r\n    *                           a certin amount teokens will be locked in the proxy contract the invoker/msg.sender immediately.\r\n    *                           Then the same amount of tokens will be unloked from target chain proxy contract at the target chain with chainId later.\r\n    *  @param fromAssetHash     The asset address in current chain, uniformly named as `fromAssetHash`\r\n    *  @param toChainId         The target chain id\r\n    *                           \r\n    *  @param toAddress         The address in bytes format to receive same amount of tokens in target chain \r\n    *  @param amount            The amount of tokens to be crossed from ethereum to the chain with chainId\r\n    */\r\n    function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) {\r\n        require(amount != 0, \"amount cannot be zero!\");\r\n        \r\n        \r\n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\r\n        \r\n        bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];\r\n        require(toAssetHash.length != 0, \"empty illegal toAssetHash\");\r\n\r\n        TxArgs memory txArgs = TxArgs({\r\n            toAssetHash: toAssetHash,\r\n            toAddress: toAddress,\r\n            amount: amount\r\n        });\r\n        bytes memory txData = _serializeTxArgs(txArgs);\r\n        \r\n        IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);\r\n        address eccmAddr = eccmp.getEthCrossChainManager();\r\n        IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\r\n        \r\n        bytes memory toProxyHash = proxyHashMap[toChainId];\r\n        require(toProxyHash.length != 0, \"empty illegal toProxyHash\");\r\n        require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\r\n\r\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount);\r\n        \r\n        return true;\r\n\r\n    }\r\n    \r\n    // /* @notice                  This function is meant to be invoked by the ETH crosschain management contract,\r\n    // *                           then mint a certin amount of tokens to the designated address since a certain amount \r\n    // *                           was burnt from the source chain invoker.\r\n    // *  @param argsBs            The argument bytes recevied by the ethereum lock proxy contract, need to be deserialized.\r\n    // *                           based on the way of serialization in the source chain proxy contract.\r\n    // *  @param fromContractAddr  The source chain contract address\r\n    // *  @param fromChainId       The source chain id\r\n    // */\r\n    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\r\n        TxArgs memory args = _deserializeTxArgs(argsBs);\r\n\r\n        require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\");\r\n        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\");\r\n        \r\n        require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\");\r\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\r\n\r\n        require(args.toAddress.length != 0, \"toAddress cannot be empty\");\r\n        address toAddress = Utils.bytesToAddress(args.toAddress);\r\n        \r\n        \r\n        require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\");\r\n        \r\n        emit UnlockEvent(toAssetHash, toAddress, args.amount);\r\n        return true;\r\n    }\r\n    \r\n    function getBalanceFor(address fromAssetHash) public view returns (uint256) {\r\n        if (fromAssetHash == address(0)) {\r\n            // return address(this).balance; // this expression would result in error: Failed to decode output: Error: insufficient data for uint256 type\r\n            address selfAddr = address(this);\r\n            return selfAddr.balance;\r\n        } else {\r\n            IERC20 erc20Token = IERC20(fromAssetHash);\r\n            return erc20Token.balanceOf(address(this));\r\n        }\r\n    }\r\n    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {\r\n        if (fromAssetHash == address(0)) {\r\n            // fromAssetHash === address(0) denotes user choose to lock ether\r\n            // passively check if the received msg.value equals amount\r\n            require(msg.value != 0, \"transferred ether cannot be zero!\");\r\n            require(msg.value == amount, \"transferred ether is not equal to amount!\");\r\n        } else {\r\n            // make sure lockproxy contract will decline any received ether\r\n            require(msg.value == 0, \"there should be no ether transfer!\");\r\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\r\n            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\r\n        }\r\n        return true;\r\n    }\r\n    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\r\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\r\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\r\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\r\n            address(uint160(toAddress)).transfer(amount);\r\n        } else {\r\n            // actively transfer amount of asset from lock_proxy contract to toAddress\r\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset from lock_proxy contract to toAddress failed!\");\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {\r\n         IERC20 erc20Token = IERC20(fromAssetHash);\r\n        //  require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\r\n         erc20Token.safeTransferFrom(fromAddress, toAddress, amount);\r\n         return true;\r\n    }\r\n    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\r\n         IERC20 erc20Token = IERC20(toAssetHash);\r\n        //  require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\r\n         erc20Token.safeTransfer(toAddress, amount);\r\n         return true;\r\n    }\r\n    \r\n    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        buff = abi.encodePacked(\r\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\r\n            ZeroCopySink.WriteVarBytes(args.toAddress),\r\n            ZeroCopySink.WriteUint255(args.amount)\r\n            );\r\n        return buff;\r\n    }\r\n\r\n    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\r\n        TxArgs memory args;\r\n        uint256 off = 0;\r\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\r\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\r\n        (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off);\r\n        return args;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"targetProxyHash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialAmount\",\"type\":\"uint256\"}],\"name\":\"BindAssetEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"targetProxyHash\",\"type\":\"bytes\"}],\"name\":\"BindProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"SetManagerProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockEvent\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"assetHashMap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"}],\"name\":\"bindAssetHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"targetProxyHash\",\"type\":\"bytes\"}],\"name\":\"bindProxyHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"}],\"name\":\"getBalanceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerProxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"proxyHashMap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethCCMProxyAddr\",\"type\":\"address\"}],\"name\":\"setManagerProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"argsBs\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"fromChainId\",\"type\":\"uint64\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LockProxy", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://07b0573bbea55c618bcebda0dea15d1aa4251998e5d99dc12c17a7c2d371e65e"}