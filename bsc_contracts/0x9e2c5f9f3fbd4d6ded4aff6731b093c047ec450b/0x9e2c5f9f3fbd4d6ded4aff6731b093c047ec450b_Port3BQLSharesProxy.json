{"SourceCode": "{\"Port3BQLSharesProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0;\\n\\nimport \\\"Proxy.sol\\\";\\n\\ncontract Port3BQLSharesProxy is Proxy {\\n    address private immutable _impl;\\n\\n    constructor(address _logic, bytes memory _data) {\\n        (bool success, ) = _logic.delegatecall(_data);\\n        require(success, \\\"Token failed to initialize\\\");\\n        _impl = _logic;\\n    }\\n\\n    function _implementation() internal view override returns (address) {\\n        return _impl;\\n    }\\n\\n    function implementation() external view returns (address) {\\n        return _impl;\\n    }\\n}\\n\"},\"Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don\\u0027t know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Port3BQLSharesProxy", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005cb3c19243d46a4cd821472c6e8c713572e449bb000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001e4ea2b331600000000000000000000000012458f85a2f5edba82d9c4abe66db3c6803443a900000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000a34891d7e2e4a4dfbf4b20e55f36ca4f6c7e91aa00000000000000000000000066dee2e54892ffbf50b95f80040ab9adc006f9ed00000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000001c424e42434841494e5f424e425f43414b455f42514c5f53686172657300000000000000000000000000000000000000000000000000000000000000000000001c424e42434841494e5f424e425f43414b455f42514c5f53686172657300000000000000000000000000000000000000000000000000000000000000000000005068747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f516d516b6e68385138443667654b47544145677361744d664a50544d58663374676e41366a5a6761314c557831580000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x5cb3c19243d46a4cd821472c6e8c713572e449bb", "SwarmSource": "ipfs://8104430d7a4e67892216987ef1f131b4efe65a884ffbd2ffcbc1e37607c8b205"}