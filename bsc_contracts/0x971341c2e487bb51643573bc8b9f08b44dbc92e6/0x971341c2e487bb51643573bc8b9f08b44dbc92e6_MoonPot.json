{"SourceCode": "/*  \r\n \r\n * SPDX-License-Identifier: None\r\n*/\r\npragma solidity 0.8.17;\r\n\r\ninterface ICCVRF {\r\n    function requestRandomness(uint256 requestID, uint256 howManyNumbers) external payable;\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n   function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\r\n    \r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function getAmountsOut(\r\n            uint256 amountIn,\r\n            address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IDEXPair {\r\n    function sync() external;\r\n}\r\n\r\ncontract MoonPot is IBEP20 {\r\n    string constant _name = \"MoonPot\";\r\n    string constant _symbol = \"$MOONPOT\";\r\n    uint8 constant _decimals = 9;\r\n    uint256 _totalSupply = 100_000_000 * (10**_decimals);\r\n    uint256 circulatingSupplyLimit = 21_000_000 * (10**_decimals); \r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public addressWithoutLimits;\r\n    mapping(address => bool) public buyerRegistered;\r\n    mapping(address => bool) private _blacklist;\r\n\r\n    bool public enabled = false;\r\n    uint256 public enabledCounter = 1;\r\n    \r\n    uint256 public tax = 2;\r\n    uint256 public liq = 1;\r\n    uint256 public marketing = 0;\r\n    uint256 public jackpot = 1;\r\n\r\n    uint256 public jackpotBalance;   \r\n    uint256 public maxJackpotBalanceBeforeDistribute = 1000 ether;\r\n    address public lastBuyer;\r\n    uint256 public lastBuy;\r\n    uint256 public jackpotTimer = 5 minutes;\r\n    uint256 public minBuy = 0.1 ether;\r\n\r\n    uint256 public launchTime = type(uint256).max;\r\n    bool public happyHour;\r\n    uint256 public happyHourEnd;\r\n    \r\n    bool public jackpotWillBeDistributed;\r\n    bool public winnersHaveBeenChosen;\r\n\r\n    bool public payJackpotInToken = true;\r\n    IBEP20 public jackpotToken = IBEP20(0xbA2aE424d960c26247Dd6c32edC70B295c744C43);\r\n    uint256 public totalDogePaidFromJackpot;\r\n    uint256 public totalJackpotPayouts;\r\n\r\n    bool private isSwapping;\r\n    uint256 public swapTokensAtAmount = 50_000 * (10**_decimals);\r\n    uint256 public maxWallet = 2_000_000 * (10**_decimals);\r\n    \r\n    ICCVRF public randomnessSupplier = ICCVRF(0xC0de0aB6E25cc34FB26dE4617313ca559f78C0dE);\r\n    mapping (uint256 => bool) public nonceProcessed;\r\n    uint256 public vrfCost = 0.002 ether;\r\n    uint256 public nonce;\r\n\r\n    IDEXRouter public router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address public constant CEO = 0xe9D0b1Db1b3Cd9180631AEEE283f9B01adb43326;\r\n    address public marketingWallet = 0x7299336E094dd0f5a74f6bdCbfE7fECc401b81C4;\r\n    address public buyBackWallet = 0x7299336E094dd0f5a74f6bdCbfE7fECc401b81C4;\r\n    uint256 public buyBackPercentage = 0;\r\n\r\n    address public pair;\r\n    address public constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address public constant ZERO = 0x0000000000000000000000000000000000000000;\r\n    \r\n    address[] public allBuyers;\r\n    address[] public allBuysSinceLastJackpot;\r\n    address[] private pathForBuyingJackpot = new address[](2);\r\n    address[] private pathForSelling = new address[](2);\r\n    address[] private pathForBuying = new address[](2);\r\n    address[] private pathFromBNBToBUSD = new address[](2);\r\n\r\n    struct Winners{\r\n        uint256 round;\r\n        address winner;\r\n        uint256 prize;\r\n    }\r\n\r\n    Winners[] public winners;\r\n    address[] public winnersOfCurrent;\r\n\r\n    modifier onlyOwner() {if(msg.sender != CEO) return; _;}\r\n    modifier contractSelling() {isSwapping = true; _; isSwapping = false;}\r\n    modifier onlyVRF() {if(msg.sender != address(randomnessSupplier)) return; _;}\r\n\r\n    event Winner(address winner, uint256 tokensWon);\r\n    event Blacklisted(address account, bool status);\r\n\r\n    constructor() {\r\n        pathForBuyingJackpot[0] = WETH;\r\n        pathForBuyingJackpot[1] = address(jackpotToken);\r\n        \r\n        pathForSelling[0] = address(this);\r\n        pathForSelling[1] = WETH;\r\n        \r\n        pathForBuying[0] = WETH;\r\n        pathForBuying[1] = address(this);\r\n\r\n        pathFromBNBToBUSD[0] = WETH;\r\n        pathFromBNBToBUSD[1] = BUSD;\r\n        \r\n        pair = IDEXFactory(IDEXRouter(router).factory()).createPair(WETH, address(this));\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n        addressWithoutLimits[CEO] = true;\r\n        addressWithoutLimits[address(this)] = true;\r\n        lastBuyer = marketingWallet;     \r\n        \r\n        _balances[CEO] = _totalSupply;\r\n        emit Transfer(address(0), CEO, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n    function name() public pure override returns (string memory) {return _name;}\r\n    function totalSupply() public view override returns (uint256) {return _totalSupply;}\r\n    function decimals() public pure override returns (uint8) {return _decimals;}\r\n    function symbol() public pure override returns (string memory) {return _symbol;}\r\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\r\n    function allowance(address holder, address spender) public view override returns (uint256) {return _allowances[holder][spender];}\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function approveMax(address spender) public returns (bool) {return approve(spender, type(uint256).max);}\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {return _transferFrom(msg.sender, recipient, amount);}\r\n    function circulatingSupply() public view returns(uint256) {return _totalSupply - _balances[DEAD] - _balances[ZERO];}\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            require(_allowances[sender][msg.sender] >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n        }\r\n        \r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function conditionsToSwapAreMet(address sender) internal view returns (bool) {\r\n        return sender != pair && _balances[address(this)] > swapTokensAtAmount;\r\n    }\r\n    \r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if(addressWithoutLimits[sender]|| addressWithoutLimits[recipient]) return _basicTransfer(sender, recipient, amount);\r\n\r\n        if(recipient != address(this) &&  recipient != address(router) && recipient != address(pair) && recipient != address(CEO)) {\r\n            uint256 balanceReciver = balanceOf(recipient);\r\n            require(balanceReciver + amount <= maxWallet, \"Exceeds maximum wallet token amount.\" );\r\n        }\r\n        if(isSwapping == true) return _lowGasTransfer(sender, recipient, amount);\r\n        \r\n        require(enabled, \"Trading not live yet\");\r\n        require(!blacklisted(sender) && !blacklisted(recipient), \"Error: Blacklisted sender or recipient\");\r\n\r\n        // last buyer won: let's pay him\r\n        if(block.timestamp - lastBuy > jackpotTimer && !jackpotWillBeDistributed) payOutJackpot();\r\n\r\n        // jackpot is too big, let's distribute it    \r\n        if(winnersHaveBeenChosen && jackpotWillBeDistributed) distributeJackpot();\r\n        \r\n        if(sender == pair && bigEnoughBuy(amount)){\r\n            lastBuyer = recipient; \r\n            lastBuy = block.timestamp;\r\n            allBuysSinceLastJackpot.push(recipient);\r\n            if(!buyerRegistered[recipient]) {\r\n                buyerRegistered[recipient] = true;\r\n                allBuyers.push(recipient);\r\n            }\r\n        }\r\n\r\n        // if we have enough tokens, let's sell them for jackpot, marketing and liquidity\r\n        if (conditionsToSwapAreMet(sender)) letTheContractSell();\r\n       \r\n       \r\n        \r\n        // calculate effective amount that get's transferred\r\n        uint256 finalamount = takeTax(sender, recipient, amount);\r\n            \r\n             \r\n\r\n        // do the transfer\r\n        return _basicTransfer(sender, recipient, finalamount);\r\n    }\r\n\r\n    function takeTax(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        // tax free for wallet to wallet\r\n        if(sender != pair && recipient != pair) return amount;\r\n\r\n        if(happyHour && happyHourEnd < block.timestamp) happyHour = false;\r\n        \r\n        uint256 taxAmount = amount * tax / 100;\r\n\r\n        if(recipient == pair){\r\n            if(happyHour) taxAmount *= 2;\r\n\r\n        } else {\r\n            if(happyHour) taxAmount /= 2;\r\n        }\r\n\r\n        if (taxAmount > 0) _lowGasTransfer(sender, address(this), taxAmount);\r\n        return amount - taxAmount;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if(recipient == DEAD && circulatingSupply() - amount < circulatingSupplyLimit) amount = circulatingSupply() - circulatingSupplyLimit;\r\n        \r\n        return _lowGasTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _lowGasTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function letTheContractSell() internal {\r\n        uint256 tokensThatTheContractWillSell = _balances[address(this)] * (tax - liq) / tax;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokensThatTheContractWillSell,\r\n            0,\r\n            pathForSelling,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        // adding tokens to liquidity pool\r\n        if(_balances[address(this)] > 0){\r\n            _lowGasTransfer(address(this), pair, _balances[address(this)]);\r\n            IDEXPair(pair).sync();\r\n        }\r\n       \r\n        // dividing the BNB between marketing and jackpot\r\n        uint256 contractBalanceWithoutJackpot = address(this).balance - jackpotBalance;\r\n        payable(marketingWallet).transfer(contractBalanceWithoutJackpot * marketing / tax);\r\n        jackpotBalance += contractBalanceWithoutJackpot * jackpot / tax;\r\n\r\n        if(jackpotBalanceInBUSD() > maxJackpotBalanceBeforeDistribute) drawWinnersOfJackpotDistribution();\r\n    }\r\n\r\n    function bigEnoughBuy(uint256 amount) public view returns (bool) {\r\n        if (minBuy == 0) return true;\r\n        uint256 tokensOut = router.getAmountsOut(minBuy, pathForBuying)[1] * 9975 / 10000; \r\n        return amount >= tokensOut;\r\n    }\r\n\r\n    function jackpotBalanceInBUSD() public view returns (uint256) {\r\n        if(jackpotBalance == 0) return 0;\r\n        return router.getAmountsOut(jackpotBalance, pathFromBNBToBUSD)[1];\r\n    }\r\n\r\n    function sendHalfToMarketingAndBuyBack() internal {\r\n        if(circulatingSupply() <= circulatingSupplyLimit) {\r\n            payable(marketingWallet).transfer(jackpotBalance * 4 / 10);\r\n            jackpotBalance =  jackpotBalance * 6 / 10;\r\n            return;\r\n        }\r\n        \r\n        if(buyBackPercentage == 0) {\r\n            payable(marketingWallet).transfer(jackpotBalance/2);\r\n            jackpotBalance /= 2;\r\n            return;\r\n        }\r\n\r\n        if(buyBackPercentage == 100) {\r\n            payable(buyBackWallet).transfer(jackpotBalance/2);\r\n            jackpotBalance /= 2;\r\n            return;\r\n        }\r\n\r\n        payable(marketingWallet).transfer(jackpotBalance / 2 * (100 - buyBackPercentage) / 100);\r\n        payable(buyBackWallet).transfer(jackpotBalance / 2 * buyBackPercentage / 100);\r\n        jackpotBalance /= 2;\r\n    }\r\n\r\n/////////////////// ADMIN FUNCTIONS ///////////////////////////////////////////////////////////////////////\r\n    function launch() external onlyOwner {\r\n        require(enabled == false, \"Already Live\");\r\n        enabled = !enabled;\r\n        launchTime = block.timestamp;\r\n        lastBuy = block.timestamp;\r\n    }\r\n\r\n    // one time thing for managing the list\r\n    function oneTimePause() external onlyOwner {\r\n        require(launchTime < block.timestamp, \"Trading timer not live\");\r\n        require(enabledCounter < 2, \"Cannot disable traiding again!\"); // this will kill the possibility to disabled it again\r\n        if(enabledCounter <=2 && enabledCounter >= 1) {\r\n            enabled = !enabled; \r\n            enabledCounter+= 1;\r\n        }\r\n    }\r\n\r\n    // set max wallet, can not be lower than 0.1% of supply\r\n    function setmaxWallet(uint256 value) external onlyOwner {\r\n        value = value * (10**9);\r\n        require(value >= _totalSupply / 1000, \"max wallet cannot be set to less than 0.1%\");\r\n        maxWallet = value;\r\n    }    \r\n    \r\n    function toggleBlacklist(address account) external onlyOwner {\r\n        _blacklist[account] = !_blacklist[account];\r\n        emit Blacklisted(account, _blacklist[account]);\r\n    }    \r\n    \r\n    function blacklisted(address account) public view returns(bool) {\r\n        return _blacklist[account];\r\n    }    \r\n    \r\n    function makeContractSell() external onlyOwner {\r\n        letTheContractSell();\r\n    }\r\n\r\n    function addBNBToJackpotManually() external payable {\r\n        if (msg.value > 0) jackpotBalance += msg.value;\r\n    }\r\n\r\n    function airdropToWallets(address[] memory airdropWallets, uint256[] memory amount) external onlyOwner {\r\n        for (uint256 i = 0; i < airdropWallets.length; i++) {\r\n            _basicTransfer(msg.sender, airdropWallets[i], amount[i] * (10**_decimals));\r\n        }\r\n    }\r\n\r\n    function setJackpotSettings(\r\n        uint256 _jackpotTimerInMinutes,\r\n        uint256 _maxJackpotBalanceBeforeDistribute\r\n    ) external onlyOwner {\r\n        maxJackpotBalanceBeforeDistribute = _maxJackpotBalanceBeforeDistribute * 1 ether;\r\n        jackpotTimer = _jackpotTimerInMinutes * 1 minutes;\r\n        require(jackpotTimer >= 2 minutes && jackpotTimer < 1 days, \"JackpotTimer can only be between 2 minutes and 1 day\");\r\n    }\r\n\r\n    function startHappyHour(uint256 howManyHours) external onlyOwner{\r\n        happyHour = true;\r\n        happyHourEnd = block.timestamp + howManyHours * 1 hours;\r\n    }\r\n\r\n    function setContractSells(uint256 minAmountOfTokensToSell) external onlyOwner{\r\n        swapTokensAtAmount = minAmountOfTokensToSell * (10 ** _decimals);\r\n    }\r\n\r\n    function setWallets(address marketingAddress, address buyBackAddress, uint256 _buyBackPercentage) external onlyOwner {\r\n        marketingWallet = marketingAddress;\r\n        buyBackWallet = buyBackAddress;\r\n        buyBackPercentage = _buyBackPercentage;\r\n        require(buyBackPercentage <= 100 && buyBackPercentage >= 0, \"buyBackPercentage has to be between 0% and 100%\");\r\n    }\r\n\r\n    function setJackpotToken(address newJackpotToken) external onlyOwner {\r\n        jackpotToken = IBEP20(newJackpotToken);\r\n        pathForBuyingJackpot[1] = newJackpotToken;\r\n        address jackpotPair = IDEXFactory(IDEXRouter(router).factory()).getPair(WETH, newJackpotToken);\r\n        uint256 wbnbBalanceOfJackpotPair = IBEP20(WETH).balanceOf(jackpotPair);\r\n        require(wbnbBalanceOfJackpotPair > 10 ether, \"Can't choose token with small liquidity as jackpotToken\");\r\n    }\r\n\r\n    function setTax(uint256 newLiq, uint256 newMarketing, uint256 newJackpot) external onlyOwner {\r\n        liq = newLiq;\r\n        marketing = newMarketing;\r\n        jackpot = newJackpot;\r\n        tax = liq + marketing + jackpot;\r\n        require(tax <= 11, \"Tax limited to max 11%\");\r\n    }\r\n\r\n    function setAddressWithoutLimits(address unlimitedAddress, bool status) external onlyOwner {\r\n        addressWithoutLimits[unlimitedAddress] = status;\r\n    }\r\n\r\n    function rescueAnyToken(address token) external onlyOwner {\r\n        require(token != address(this), \"Can't rescue MoonPot\");\r\n        IBEP20(token).transfer(msg.sender, IBEP20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function drawWinnersOfJackpotDistribution() internal {\r\n        jackpotWillBeDistributed = true;\r\n        randomnessSupplier.requestRandomness{value: vrfCost}(nonce, 2);\r\n        jackpotBalance -= vrfCost;\r\n    }\r\n\r\n    function supplyRandomness(uint256 _nonce, uint256[] memory randomNumbers) external onlyVRF {\r\n        if(nonceProcessed[_nonce]) {\r\n            if(winnersOfCurrent[0] == address(0)) winnersOfCurrent[0] = allBuysSinceLastJackpot[(randomNumbers[0] % allBuysSinceLastJackpot.length)];\r\n            if(winnersOfCurrent[1] == address(0)) winnersOfCurrent[1] = allBuyers[(randomNumbers[1] % allBuyers.length)];\r\n        } else{\r\n            nonceProcessed[_nonce] = true;\r\n            winnersOfCurrent.push(allBuysSinceLastJackpot[(randomNumbers[0] % allBuysSinceLastJackpot.length)]);\r\n            winnersOfCurrent.push(allBuyers[(randomNumbers[1] % allBuyers.length)]);\r\n        }\r\n\r\n        if(!bigEnoughBuy(_balances[winnersOfCurrent[0]])) winnersOfCurrent[0] = address(0);\r\n        if(!bigEnoughBuy(_balances[winnersOfCurrent[1]])) winnersOfCurrent[1] = address(0);\r\n        \r\n        if(winnersOfCurrent[0] == address(0) || winnersOfCurrent[1] == address(0)) {\r\n            randomnessSupplier.requestRandomness{value: vrfCost}(_nonce, 2);\r\n            jackpotBalance -= vrfCost;\r\n        } else {\r\n            winnersHaveBeenChosen = true;\r\n            delete allBuysSinceLastJackpot;\r\n        }\r\n    }\r\n\r\n    function payOutJackpot() internal {\r\n        if (jackpotBalance == 0) return;\r\n        uint256 carryOver = jackpotBalance / 100;\r\n        jackpotBalance = jackpotBalance - carryOver;\r\n        sendHalfToMarketingAndBuyBack();\r\n        \r\n        if(!payJackpotInToken) {\r\n            payable(lastBuyer).transfer(jackpotBalance);\r\n        } else { \r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: jackpotBalance}(\r\n                0,\r\n                pathForBuyingJackpot,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n            uint256 dogeBalance = jackpotToken.balanceOf(address(this));\r\n            jackpotToken.transfer(lastBuyer,dogeBalance);\r\n            \r\n            emit Winner(lastBuyer, dogeBalance);\r\n            totalDogePaidFromJackpot += dogeBalance;\r\n            Winners memory currentWinner;\r\n            currentWinner.round = totalJackpotPayouts;\r\n            currentWinner.winner = lastBuyer;\r\n            currentWinner.prize = dogeBalance;\r\n            winners.push(currentWinner);\r\n            totalJackpotPayouts++;\r\n        }\r\n            \r\n        jackpotBalance = carryOver;\r\n    }\r\n\r\n    function distributeJackpot() internal {\r\n        uint256 carryOver = jackpotBalance / 100;\r\n        jackpotBalance = jackpotBalance - carryOver;\r\n        sendHalfToMarketingAndBuyBack();\r\n        \r\n        if(!payJackpotInToken) {\r\n            payable(winnersOfCurrent[0]).transfer(jackpotBalance * 3 / 4);\r\n            payable(winnersOfCurrent[1]).transfer(jackpotBalance / 4);\r\n            jackpotBalance = 0;\r\n            jackpotWillBeDistributed = false;\r\n            winnersHaveBeenChosen = false;\r\n        } else {\r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: jackpotBalance}(\r\n                0,\r\n                pathForBuyingJackpot,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n            uint256 dogeBalance = jackpotToken.balanceOf(address(this));\r\n            totalDogePaidFromJackpot += dogeBalance;\r\n            jackpotToken.transfer(winnersOfCurrent[0],dogeBalance * 3 / 4);\r\n            Winners memory currentWinner;\r\n            currentWinner.round = totalJackpotPayouts;\r\n            currentWinner.winner = winnersOfCurrent[0];\r\n            currentWinner.prize = dogeBalance * 3 / 4;\r\n            winners.push(currentWinner);\r\n            emit Winner(winnersOfCurrent[0], dogeBalance * 3 / 4);\r\n\r\n            dogeBalance = jackpotToken.balanceOf(address(this));\r\n            jackpotToken.transfer(winnersOfCurrent[1],dogeBalance);\r\n            currentWinner.round = totalJackpotPayouts;\r\n            currentWinner.winner = winnersOfCurrent[1];\r\n            currentWinner.prize = dogeBalance;\r\n            winners.push(currentWinner);\r\n            emit Winner(winnersOfCurrent[0], dogeBalance);\r\n\r\n            totalJackpotPayouts++;\r\n            }\r\n        delete winnersOfCurrent;\r\n        jackpotBalance = carryOver;\r\n        jackpotWillBeDistributed = false;\r\n        winnersHaveBeenChosen = false;\r\n        nonce++;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensWon\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CEO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addBNBToJackpotManually\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressWithoutLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"airdropWallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"airdropToWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBuyers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBuysSinceLastJackpot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bigEnoughBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyerRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabledCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"happyHour\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"happyHourEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBalanceInBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotWillBeDistributed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBuyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeContractSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxJackpotBalanceBeforeDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneTimePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payJackpotInToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomnessSupplier\",\"outputs\":[{\"internalType\":\"contract ICCVRF\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueAnyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unlimitedAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAddressWithoutLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmountOfTokensToSell\",\"type\":\"uint256\"}],\"name\":\"setContractSells\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_jackpotTimerInMinutes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxJackpotBalanceBeforeDistribute\",\"type\":\"uint256\"}],\"name\":\"setJackpotSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newJackpotToken\",\"type\":\"address\"}],\"name\":\"setJackpotToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMarketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newJackpot\",\"type\":\"uint256\"}],\"name\":\"setTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyBackAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackPercentage\",\"type\":\"uint256\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setmaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"howManyHours\",\"type\":\"uint256\"}],\"name\":\"startHappyHour\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomNumbers\",\"type\":\"uint256[]\"}],\"name\":\"supplyRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"toggleBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDogePaidFromJackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalJackpotPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrfCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winnersHaveBeenChosen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winnersOfCurrent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MoonPot", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://886109bcd9bf3ec4c05c9dfb985ee54f2a0a28d9ace24aa0396c75c45379bdcc"}