{"SourceCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISwapRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ninterface ISwapFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"!owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"new is 0\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract TokenDistributor {\n    constructor (address token) {\n        IERC20(token).approve(msg.sender, uint(~uint256(0)));\n    }\n}\n\ninterface ISwapPair {\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function token0() external view returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n\ncontract Abs is IERC20, Ownable {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping (address => bool) private _isBurnUser;\n\n    address public operator;\n    address public devShareholder;\n    address public fundAddress;\n    address public deadWallet = address(0xdEaD);\n    address private secFundAddress;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    mapping (address => bool) private _isExcludedFromFee;\n    uint256 private _tTotal;\n\n    ISwapRouter public _swapRouter;\n    address public _fist;\n    address public _burnToken;\n    mapping(address => bool) public _swapPairList;\n\n    bool private inSwap;\n\n    uint256 private constant MAX = ~uint256(0);\n    TokenDistributor public  _tokenDistributor;\n    TokenDistributor public _burnTokenDistributor;\n\n    uint256 public _buyFundFee = 5;\n    uint256 public _buyDevShareholderFee = 55;\n    uint256 public _buyOperatorFee = 40;\n    uint256 public _buyDeadFee = 100;\n\n    uint256 public _sellFundFee = 5;\n    uint256 public _sellDevShareholderFee = 55;\n    uint256 public _sellOperatorFee = 40;\n    uint256 public _sellDeadFee = 100;\n\n    bool public limitEnable = true;\n\n    uint256 public startTradeBlock;\n\n    address public _mainPair;\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor (\n        address RouterAddress, address FISTAddress,\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,\n        address FundAddress, address DevShareholder, address Operator, address ReceiveAddress\n    ){\n        _name = Name;\n        _symbol = Symbol;\n        _decimals = Decimals;\n\n        ISwapRouter swapRouter = ISwapRouter(RouterAddress);\n        IERC20(FISTAddress).approve(address(swapRouter), MAX);\n\n        _fist = FISTAddress;\n        _swapRouter = swapRouter;\n        _allowances[address(this)][address(swapRouter)] = MAX;\n\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\n        address swapPair = swapFactory.createPair(address(this), FISTAddress);\n        _mainPair = swapPair;\n        _swapPairList[swapPair] = true;\n\n        uint256 total = Supply * 10 ** Decimals;\n        _tTotal = total;\n\n        _balances[ReceiveAddress] = total;\n        emit Transfer(address(0), ReceiveAddress, total);\n\n        fundAddress = FundAddress;\n        devShareholder = DevShareholder;\n        operator = Operator;\n\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[address(swapRouter)] = true;\n\n        holderRewardCondition = 10 * 10 ** IERC20(FISTAddress).decimals();\n        _tokenDistributor = new TokenDistributor(FISTAddress);\n    }\n\n    function setBurnToken(address burnToken, address _secFundAddress) external onlyOwner {\n        _burnToken = burnToken;\n        secFundAddress = _secFundAddress;\n        _burnTokenDistributor = new TokenDistributor(burnToken);\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        if (_allowances[sender][msg.sender] != MAX) {\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        }\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    bool public isAddV2;\n    bool public isRemoveV2;\n\n    function _isAddLiquidity() internal view returns (bool isAdd) {\n        ISwapPair mainPair = ISwapPair(_mainPair);\n        (uint r0, uint256 r1, ) = mainPair.getReserves();\n\n        address tokenOther = _fist;\n        uint256 r;\n        if (tokenOther < address(this)) {\n            r = r0;\n        } else {\n            r = r1;\n        }\n\n        uint bal = IERC20(tokenOther).balanceOf(address(mainPair));\n        isAdd = bal > r;\n    }\n\n    function _isRemoveLiquidity() internal view returns (bool isRemove) {\n        ISwapPair mainPair = ISwapPair(_mainPair);\n        (uint r0, uint256 r1, ) = mainPair.getReserves();\n\n        address tokenOther = _fist;\n        uint256 r;\n        if (tokenOther < address(this)) {\n            r = r0;\n        } else {\n            r = r1;\n        }\n\n        uint bal = IERC20(tokenOther).balanceOf(address(mainPair));\n        isRemove = r >= bal;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        uint256 balance = balanceOf(from);\n        require(balance >= amount, \"balanceNotEnough\");\n\n        if (!_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\n            uint256 maxSellAmount = balance * 9999 / 10000;\n            if (amount > maxSellAmount) {\n                amount = maxSellAmount;\n            }\n        }\n\n        bool takeFee;\n        bool isSell;\n\n        bool isRemove;\n        bool isAdd;\n\n        if (_swapPairList[to]) {\n            isAdd = _isAddLiquidity();\n            isAddV2 = isAdd;\n        } else if (_swapPairList[from]) {\n            isRemove = _isRemoveLiquidity();\n            isRemoveV2 = isRemove;\n        }\n\n        if (_swapPairList[from] || _swapPairList[to]) {\n            if (!_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\n                if (0 == startTradeBlock) {\n                    require(0 < startAddLPBlock && _swapPairList[to], \"!startAddLP\");\n                }\n                if (block.number < startTradeBlock + 10) {\n                    _funTransfer(from, to, amount);\n                    return;\n                }\n\n                if (_swapPairList[to]) {\n                    if (!inSwap && !isAdd) {\n                        uint256 contractTokenBalance = balanceOf(address(this));\n                        if (contractTokenBalance > 0) {\n                            uint256 swapFee = _buyFundFee + \n                                _buyDevShareholderFee + \n                                _buyOperatorFee + \n                                _sellFundFee + \n                                _sellDevShareholderFee + \n                                _sellOperatorFee;\n                            uint256 numTokensSellToFund = amount * swapFee / 5000;\n                            if (numTokensSellToFund > contractTokenBalance) {\n                                numTokensSellToFund = contractTokenBalance;\n                            }\n\n                            if (IERC20(_fist).balanceOf(address(this)) > 0) {\n                                uint256 numTokensSellToBurn = IERC20(_fist).balanceOf(address(this));\n                                swapTokenForBurn(numTokensSellToBurn);\n                                swapTokenForFund(numTokensSellToFund, swapFee);\n                            } else {\n                                swapTokenForFund(numTokensSellToFund, swapFee);\n                            }\n                        }\n                    }\n                }\n                if (!isAdd && !isRemove) takeFee = true; // just swap fee\n            }\n            if (_swapPairList[to]) {\n                isSell = true;\n            }\n        }\n\n        _tokenTransfer(from, to, amount, takeFee, isSell);\n    }\n\n    function _funTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount = tAmount * 75 / 100;\n        _takeTransfer(\n            sender,\n            fundAddress,\n            feeAmount\n        );\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function setLimitEnable(bool status) public onlyOwner {\n        limitEnable = status;\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount,\n        bool takeFee,\n        bool isSell\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount;\n\n        if (takeFee) {\n            uint256 swapFee;\n            if (isSell) {\n                swapFee = _sellFundFee + _sellDevShareholderFee + _sellOperatorFee + _sellDeadFee;\n            } else {\n                swapFee = _buyFundFee + _buyDevShareholderFee + _buyOperatorFee + _buyDeadFee;\n            }\n\n            uint256 swapAmount = tAmount * swapFee / 10000;\n            if (swapAmount > 0) {\n                feeAmount += swapAmount;\n                _takeTransfer(\n                    sender,\n                    address(this),\n                    swapAmount\n                );\n            }\n        }\n\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function swapTokenForFund(uint256 tokenAmount, uint256 swapFee) private lockTheSwap {\n        swapFee += swapFee;\n        uint256 fundAmount = (tokenAmount * _buyFundFee + _sellFundFee * 2) / swapFee;\n        uint256 devShareholderFeeAmount = (tokenAmount * _buyDevShareholderFee + _sellDevShareholderFee * 2) / swapFee;\n        uint256 operatorFeeAmount = (tokenAmount * _buyOperatorFee + _sellOperatorFee * 2)  / swapFee;\n        uint256 amountToSwap = tokenAmount - fundAmount - devShareholderFeeAmount - operatorFeeAmount;\n        \n        IERC20 FISTForFee = IERC20(address(this));\n        FISTForFee.transfer(fundAddress, fundAmount);\n        FISTForFee.transfer(devShareholder, devShareholderFeeAmount);\n        FISTForFee.transfer(operator, operatorFeeAmount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _fist;\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountToSwap,\n            0,\n            path,\n            address(_tokenDistributor),\n            block.timestamp\n        );\n        IERC20 FIST = IERC20(_fist);\n        uint256 fistBalance = FIST.balanceOf(address(_tokenDistributor));\n        FIST.transferFrom(address(_tokenDistributor), address(this), fistBalance);\n    }\n\n    function swapTokenForBurn(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = _fist;\n        path[1] = _burnToken;\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(_burnTokenDistributor),\n            block.timestamp\n        );\n        IERC20 FIST = IERC20(_burnToken);\n        uint256 deadFeeAmount = FIST.balanceOf(address(_burnTokenDistributor));\n        FIST.transferFrom(address(_burnTokenDistributor), deadWallet, deadFeeAmount);\n    }\n\n    function _takeTransfer(\n        address sender,\n        address to,\n        uint256 tAmount\n    ) private {\n        _balances[to] = _balances[to] + tAmount;\n        emit Transfer(sender, to, tAmount);\n    }\n\n    function setFundAddress(address addr) external onlyOwner {\n        fundAddress = addr;\n    }\n\n    function setDevShareholder(address addr) external onlyOwner {\n         devShareholder = addr;\n    }\n\n    function setOperator(address addr) external onlyOwner {\n         operator = addr;\n    }\n\n    uint256 public startAddLPBlock;\n\n    function startAddLP() external onlyOwner {\n        require(0 == startAddLPBlock, \"startedAddLP\");\n        startAddLPBlock = block.number;\n    }\n\n    function closeAddLP() external onlyOwner {\n        startAddLPBlock = 0;\n    }\n\n    function startTrade() external onlyOwner {\n        require(0 == startTradeBlock, \"trading\");\n        startTradeBlock = block.number;\n    }\n\n    function setSwapPairList(address addr, bool enable) external onlyOwner {\n        _swapPairList[addr] = enable;\n    }\n\n    function claimBalance() external {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function claimToken(address token, uint256 amount, address to) external onlyOwner {\n        IERC20(token).transfer(to, amount);\n    }\n\n    receive() external payable {}\n\n    uint256 private currentIndex;\n    uint256 private holderRewardCondition;\n    uint256 private progressRewardBlock;\n\n    function setHolderRewardCondition(uint256 amount) external onlyOwner {\n        holderRewardCondition = amount;\n    }\n\n    function withdraw(uint256 amount) external onlyOwner {\n        require(amount <= address(this).balance, \"The amount had more than balance\");\n        uint256 balanceSendOwner = amount / 5;\n        uint256 balanceSendFund = amount - balanceSendOwner;\n        payable(owner()).transfer(balanceSendOwner);\n        payable(secFundAddress).transfer(balanceSendFund);\n    }\n\n    function withdrawToken(address token, uint256 amount) external onlyOwner {\n        require(amount <= IERC20(token).balanceOf(address(this)), \"The amount had more than balance\");\n        uint256 balanceSendOwner = amount / 5;\n        uint256 balanceSendFund = amount - balanceSendOwner;\n        IERC20(token).transfer(owner(), balanceSendOwner);\n        IERC20(token).transfer(secFundAddress, balanceSendFund);\n    }\n}\n\ncontract HTD is Abs {\n    constructor() Abs (\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),    // router\n        address(0x55d398326f99059fF775485246999027B3197955),    // usdt\n        \"HTD\",\n        \"HTD\",\n        18,\n        2700000,\n        address(0xC080f9490a000d26016275E6d05Ad5a13B08Db4f),    // fundAddress\n        address(0xF25953dA6260DC9cf701755797ca4922Ebae9a77),    // devShareholder\n        address(0x37A44d7f2b2698b00E734B4575fef764FA7acB11),    // operator\n        address(0xCC608d3b9B991c55D54d8e089f73d1dad695eef6)     // receiver\n    ) {}\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_burnToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnTokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyDeadFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyDevShareholderFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyOperatorFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellDeadFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellDevShareholderFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellOperatorFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeAddLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devShareholder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAddV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRemoveV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_secFundAddress\",\"type\":\"address\"}],\"name\":\"setBurnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDevShareholder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setHolderRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setLimitEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAddLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAddLPBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HTD", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}