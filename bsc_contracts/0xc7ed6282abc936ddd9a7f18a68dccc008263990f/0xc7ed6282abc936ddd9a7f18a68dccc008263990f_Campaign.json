{"SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\n\r\n// File: Interfaces.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IFactoryGetters {\r\n    function getLpRouter() external view returns(address);\r\n    function getFeeAddress() external view returns(address);\r\n    function getLauncherToken() external view returns(address);\r\n}\r\n\r\n// Uniswap v2\r\ninterface IUniswapV2Router02 {\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: Campaign.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Campaign {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    address public factory;\r\n    address public campaignOwner;\r\n    address public token;\r\n    uint256 public softCap;            \r\n    uint256 public hardCap;  \r\n    uint256 public tokenSalesQty;\r\n    uint256 public feePcnt;\r\n    uint256 public startDate;\r\n    uint256 public endDate;\r\n    uint256 public midDate;    \r\n    uint256 public svLaunchL1;\r\n    uint256 public svLaunchL2;\r\n    uint256 public svLaunchCapped;  \r\n    uint256 public allocationFactor;\r\n\r\n    // Liquidity\r\n    uint256 public lpBnbQty;    \r\n    uint256 public lpTokenQty;\r\n    uint256 public lpLockDuration; \r\n    uint256[2] private lpInPool; // This is the actual LP provided in pool.\r\n    bool private recoveredUnspentLP;\r\n    \r\n    // Config\r\n    bool public burnUnSold;    \r\n   \r\n    // Misc variables //\r\n    uint256 public unlockDate;\r\n    uint256 public collectedBNB;\r\n    uint256 public lpTokenAmount;\r\n\r\n    // States\r\n    bool public tokenFunded;        \r\n    bool public finishUpSuccess; \r\n    bool public liquidityCreated;\r\n    bool public cancelled;          \r\n\r\n   // Token claiming by users\r\n    mapping(address => bool) public claimedRecords; \r\n    bool public tokenReadyToClaim;    \r\n\r\n    // Map user address to amount invested in BNB //\r\n    mapping(address => uint256) public participants; \r\n    uint256 public numOfParticipants;\r\n\r\n    address public constant BURN_ADDRESS = address(0x000000000000000000000000000000000000dEaD);\r\n\r\n    // Whitelisting support\r\n    enum Accessibility {\r\n        Everyone, \r\n        WhitelistedOnly, \r\n        WhitelistedFirstThenEveryone\r\n    }\r\n    Accessibility public accessibility;\r\n\r\n    // Vesting Feature Support\r\n    uint256 private constant PERCENT100 = 1e6;\r\n    uint256 private constant E18 = 1e18;\r\n\r\n    struct VestingInfo {\r\n        uint256[]  times;\r\n        uint256[]  percents;\r\n        uint256 totalVestedBnb;\r\n        bool enabled;\r\n    }\r\n    VestingInfo public vestInfo;\r\n    mapping(address=>mapping(uint256=>bool)) investorsClaimMap;\r\n    mapping(uint256=>bool) campaignOwnerClaimMap;\r\n\r\n    // History\r\n    enum Action {\r\n        Buy,\r\n        Refund\r\n    }\r\n    \r\n    struct History {\r\n        uint128 timeStamp;\r\n        uint128 action;\r\n        uint amount;\r\n    }\r\n\r\n    mapping(address => History[]) private _history; \r\n\r\n    // Events\r\n    event Purchased(\r\n        address indexed user,\r\n        uint256 timeStamp,\r\n        uint256 amountBnb,\r\n        uint256 amountToken\r\n    );\r\n\r\n    event LiquidityAdded(\r\n        uint256 amountBnb,\r\n        uint256 amountToken,\r\n        uint256 amountLPToken\r\n    );\r\n\r\n    event LiquidityLocked(\r\n        uint256 timeStampStart,\r\n        uint256 timeStampExpiry\r\n    );\r\n\r\n    event LiquidityWithdrawn(\r\n        uint256 amount\r\n    );\r\n\r\n    event TokenClaimed(\r\n        address indexed user,\r\n        uint256 timeStamp,\r\n        uint256 amountToken\r\n    );\r\n\r\n    event Refund(\r\n        address indexed user,\r\n        uint256 timeStamp,\r\n        uint256 amountBnb\r\n    );\r\n\r\n    modifier onlyFactory() {\r\n        require(msg.sender == factory, \"Only factory can call\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCampaignOwner() {\r\n        require(msg.sender == campaignOwner, \"Only campaign owner can call\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOrCampaignOwner() {\r\n        require(msg.sender == factory || msg.sender == campaignOwner, \"Only factory or campaign owner can call\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        factory = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * @dev Initialize  a new campaign.\r\n     * @notice - Access control: External. Can only be called by the factory contract.\r\n     */\r\n    function initialize\r\n    (\r\n        address _token,\r\n        address _campaignOwner,\r\n        uint256[4] calldata _stats,  \r\n        uint256[3] calldata _dates, \r\n        uint256[4] calldata _buyFactors,    \r\n        Campaign.Accessibility _access,  \r\n        uint256[3] calldata _liquidity, \r\n        bool _burnUnSold\r\n    ) external\r\n    {\r\n        require(msg.sender == factory,'Only factory allowed to initialize');\r\n        token = _token;\r\n        campaignOwner = _campaignOwner; \r\n        softCap = _stats[0];\r\n        hardCap = _stats[1];\r\n        tokenSalesQty = _stats[2];\r\n        feePcnt = _stats[3];\r\n        startDate = _dates[0];\r\n        endDate = _dates[1];\r\n        midDate = _dates[2];\r\n\r\n        svLaunchL1 = _buyFactors[0];\r\n        svLaunchL2 = _buyFactors[1];\r\n        svLaunchCapped = _buyFactors[2];\r\n        allocationFactor = _buyFactors[3];\r\n\r\n        accessibility = _access;\r\n        lpBnbQty = _liquidity[0];\r\n        lpTokenQty = _liquidity[1];\r\n        lpLockDuration = _liquidity[2];\r\n        burnUnSold = _burnUnSold;\r\n    }\r\n    \r\n    /**\r\n     * @dev Allows campaign owner to fund in his token.\r\n     * @notice - Access control: External, OnlyCampaignOwner\r\n     */\r\n    function fundIn() external onlyCampaignOwner {\r\n        require(!tokenFunded, \"Campaign is already funded\");\r\n        uint256 amt = getCampaignFundInTokensRequired();\r\n        require(amt > 0, \"Invalid fund in amount\");\r\n\r\n        tokenFunded = true;\r\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amt);  \r\n    }\r\n\r\n    // In case of a \"cancelled\" campaign, or softCap not reached, \r\n    // the campaign owner can retrieve back his funded tokens.\r\n    function fundOut() external onlyCampaignOwner {\r\n        require(failedOrCancelled(), \"Only failed or cancelled campaign can un-fund\");\r\n\r\n        ERC20 ercToken = ERC20(token);\r\n        uint256 totalTokens = ercToken.balanceOf(address(this));\r\n        sendTokensTo(campaignOwner, totalTokens);\r\n        tokenFunded = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows user to buy token.\r\n     * @notice - Access control: Public\r\n     */\r\n    function buyTokens() public payable {\r\n        \r\n        require(isLive(), \"Campaign is not live\");\r\n        \r\n        // If in private round, we check the svLaunch qualification\r\n        if (block.timestamp < midDate) {\r\n            require(checkQualifyingTokens(msg.sender), \"Insufficient SVLAUNCH tokens to qualify\"); \r\n        } \r\n\r\n        require(msg.value <= getRemaining(),\"Insufficent token left\");\r\n\r\n        // Check for min purchase amount\r\n        (uint256 min, uint256 max) = getMinMaxPurchasable(msg.sender);\r\n\r\n        require(msg.value >= min, \"Less than minimum purchase amount\");\r\n        require(msg.value <= max, \"More than maximum purchase amount\");\r\n\r\n        uint256 buyAmt = calculateTokenAmount(msg.value);\r\n        \r\n        uint256 invested = participants[msg.sender];\r\n        if (invested == 0) {\r\n            numOfParticipants = numOfParticipants.add(1);\r\n        }\r\n\r\n        participants[msg.sender] = participants[msg.sender].add(msg.value);\r\n        collectedBNB = collectedBNB.add(msg.value);\r\n\r\n        _recordHistory(msg.sender, Action.Buy, msg.value);\r\n\r\n        emit Purchased(msg.sender, block.timestamp, msg.value, buyAmt);\r\n    }\r\n\r\n    /**\r\n     * @dev Add liquidity and lock it up. Called after a campaign has ended successfully.\r\n     * @notice - Access control: Public. onlyFactoryOrCampaignOwner. This allows the admin or campaignOwner to\r\n     * coordinate the adding of LP when all campaigns are completed. This ensure a fairer arrangement, esp\r\n     * when multiple campaigns are running in parallel.\r\n     */\r\n    function addAndLockLP() external onlyFactoryOrCampaignOwner {\r\n\r\n        require(!isLive(), \"Presale is still live\");\r\n        require(!failedOrCancelled(), \"Presale failed or cancelled , can't provide LP\");\r\n        require(softCap <= collectedBNB, \"Did not reach soft cap\");\r\n\r\n        if ((lpBnbQty > 0 && lpTokenQty > 0) && !liquidityCreated) {\r\n        \r\n            liquidityCreated = true;\r\n\r\n            IFactoryGetters fact = IFactoryGetters(factory);\r\n            address lpRouterAddress = fact.getLpRouter();\r\n            require(ERC20(address(token)).approve(lpRouterAddress, lpTokenQty)); // Uniswap doc says this is required //\r\n \r\n            (uint256 retTokenAmt, uint256 retBNBAmt, uint256 retLpTokenAmt) = IUniswapV2Router02(lpRouterAddress).addLiquidityETH\r\n                {value : lpBnbQty}\r\n                (address(token),\r\n                lpTokenQty,\r\n                0,\r\n                0,\r\n                address(this),\r\n                block.timestamp + 100000000);\r\n            \r\n            lpTokenAmount = retLpTokenAmt;\r\n            lpInPool[0] = retBNBAmt;\r\n            lpInPool[1] = retTokenAmt;\r\n\r\n            emit LiquidityAdded(retBNBAmt, retTokenAmt, retLpTokenAmt);\r\n            \r\n            unlockDate = (block.timestamp).add(lpLockDuration);\r\n            emit LiquidityLocked(block.timestamp, unlockDate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the actual liquidity added to LP Pool\r\n     * @return - uint256[2] consist of BNB amount, Token amount.\r\n     * @notice - Access control: Public, View\r\n     */\r\n    function getPoolLP() external view returns (uint256, uint256) {\r\n        return (lpInPool[0], lpInPool[1]);\r\n    }\r\n\r\n    /**\r\n     * @dev There are situations that the campaign owner might call this.\r\n     * @dev 1: Pancakeswap pool SC failure when we call addAndLockLP().\r\n     * @dev 2: Pancakeswap pool already exist. After we provide LP, thee's some excess bnb/tokens\r\n     * @dev 3: Campaign owner decided to change LP arrangement after campaign is successful.\r\n     * @dev In that case, campaign owner might recover it and provide LP manually.\r\n     * @dev Note: This function can only be called once by factory, as this is not a normal workflow.\r\n     * @notice - Access control: External, onlyFactory\r\n     */\r\n    function recoverUnspentLp() external onlyFactory {\r\n        \r\n        require(!recoveredUnspentLP, \"You have already recovered unspent LP\");\r\n        recoveredUnspentLP = true;\r\n\r\n        uint256 bnbAmt;\r\n        uint256 tokenAmt;\r\n\r\n        if (liquidityCreated) {\r\n            // Find out any excess bnb/tokens after LP provision is completed.\r\n            bnbAmt = lpBnbQty.sub(lpInPool[0]);\r\n            tokenAmt = lpTokenQty.sub(lpInPool[1]);\r\n        } else {\r\n            // liquidity not created yet. Just returns the full portion of the planned LP\r\n            // Only finished success campaign can recover Unspent LP\r\n            require(finishUpSuccess, \"Campaign not finished successfully yet\");\r\n            bnbAmt = lpBnbQty;\r\n            tokenAmt = lpTokenQty;\r\n        }\r\n\r\n        // Return bnb, token if any\r\n        if (bnbAmt > 0) {\r\n            (bool ok, ) = campaignOwner.call{value: bnbAmt}(\"\");\r\n            require(ok, \"Failed to return BNB Lp\");\r\n        }\r\n\r\n        if (tokenAmt > 0) {\r\n            ERC20(token).safeTransfer(campaignOwner, tokenAmt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev When a campaign reached the endDate, this function is called.\r\n     * @dev Add liquidity to uniswap and burn the remaining tokens.\r\n     * @dev Can be only executed when the campaign completes.\r\n     * @dev Anyone can call. Only called once.\r\n     * @notice - Access control: Public\r\n     */\r\n    function finishUp() external {\r\n       \r\n        require(!finishUpSuccess, \"finishUp is already called\");\r\n        require(!isLive(), \"Presale is still live\");\r\n        require(!failedOrCancelled(), \"Presale failed or cancelled , can't call finishUp\");\r\n        require(softCap <= collectedBNB, \"Did not reach soft cap\");\r\n        finishUpSuccess = true;\r\n\r\n        uint256 feeAmt = getFeeAmt(collectedBNB);\r\n        uint256 unSoldAmtBnb = getRemaining();\r\n        uint256 remainBNB = collectedBNB.sub(feeAmt);\r\n        \r\n        // If lpBnbQty, lpTokenQty is 0, we won't provide LP.\r\n        if ((lpBnbQty > 0 && lpTokenQty > 0)) {\r\n            remainBNB = remainBNB.sub(lpBnbQty);\r\n        }\r\n        \r\n        // Send fee to fee address\r\n        if (feeAmt > 0) {\r\n            (bool sentFee, ) = getFeeAddress().call{value: feeAmt}(\"\");\r\n            require(sentFee, \"Failed to send Fee to platform\");\r\n        }\r\n\r\n        // Send remain bnb to campaign owner if not in vested Mode\r\n        if (!vestInfo.enabled) {\r\n            (bool sentBnb, ) = campaignOwner.call{value: remainBNB}(\"\");\r\n            require(sentBnb, \"Failed to send remain BNB to campaign owner\");\r\n        } else {\r\n            vestInfo.totalVestedBnb = remainBNB;\r\n        }\r\n\r\n        // Calculate the unsold amount //\r\n        if (unSoldAmtBnb > 0) {\r\n            uint256 unsoldAmtToken = calculateTokenAmount(unSoldAmtBnb);\r\n            // Burn or return UnSold token to owner \r\n            sendTokensTo(burnUnSold ? BURN_ADDRESS : campaignOwner, unsoldAmtToken);  \r\n        }     \r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allow Factory owner to call this to set the flag to\r\n     * @dev enable token claiming.\r\n     * @dev This is useful when 1 project has multiple campaigns that need\r\n     * @dev to sync up the timing of token claiming After LP provision.\r\n     * @notice - Access control: External,  onlyFactory\r\n     */\r\n    function setTokenClaimable() external onlyFactory {\r\n        \r\n        require(finishUpSuccess, \"Campaign not finished successfully yet\");\r\n\r\n        // Token is only claimable in non-vested mode\r\n        require(!vestInfo.enabled, \"Not applicable to vested mode\");\r\n\r\n        tokenReadyToClaim = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow users to claim their tokens. \r\n     * @notice - Access control: External\r\n     */\r\n    function claimTokens() external {\r\n\r\n        require(tokenReadyToClaim, \"Tokens not ready to claim yet\");\r\n        require( claimedRecords[msg.sender] == false, \"You have already claimed\");\r\n        \r\n        uint256 amtBought = getTotalTokenPurchased(msg.sender);\r\n        if (amtBought > 0) {\r\n            claimedRecords[msg.sender] = true;\r\n            ERC20(token).safeTransfer(msg.sender, amtBought);\r\n            emit TokenClaimed(msg.sender, block.timestamp, amtBought);\r\n        }\r\n    }\r\n\r\n     /**\r\n     * @dev Allows campaign owner to withdraw LP after the lock duration.\r\n     * @dev Only able to withdraw LP if lockActivated and lock duration has expired.\r\n     * @dev Can call multiple times to withdraw a portion of the total lp.\r\n     * @param _lpToken - The LP token address\r\n     * @notice - Access control: Internal, OnlyCampaignOwner\r\n     */\r\n    function withdrawLP(address _lpToken,uint256 _amount) external onlyCampaignOwner \r\n    {\r\n        require(liquidityCreated, \"liquidity is not yet created\");\r\n        require(block.timestamp >= unlockDate ,\"Unlock date not reached\");\r\n        \r\n        ERC20(_lpToken).safeTransfer(msg.sender, _amount);\r\n        emit LiquidityWithdrawn( _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows Participants to withdraw/refunds when campaign fails\r\n     * @notice - Access control: Public\r\n     */\r\n    function refund() external {\r\n        require(failedOrCancelled(),\"Can refund for failed or cancelled campaign only\");\r\n\r\n        uint256 investAmt = participants[msg.sender];\r\n        require(investAmt > 0 ,\"You didn't participate in the campaign\");\r\n\r\n        participants[msg.sender] = 0;\r\n        (bool ok, ) = msg.sender.call{value: investAmt}(\"\");\r\n        require(ok, \"Failed to refund BNB to user\");\r\n\r\n        if (numOfParticipants > 0) {\r\n            numOfParticipants -= 1;\r\n        }\r\n\r\n        _recordHistory(msg.sender, Action.Refund, investAmt);\r\n        emit Refund(msg.sender, block.timestamp, investAmt);\r\n    }\r\n\r\n    /**\r\n     * @dev To calculate the total token amount based on user's total invested BNB\r\n     * @param _user - The user's wallet address\r\n     * @return - The total amount of token\r\n     * @notice - Access control: Public\r\n     */\r\n     function getTotalTokenPurchased(address _user) public view returns (uint256) {\r\n        uint256 investAmt = participants[_user];\r\n        return calculateTokenAmount(investAmt);\r\n    }\r\n  \r\n    // Helpers //\r\n    /**\r\n     * @dev To send all XYZ token to either campaign owner or burn address when campaign finishes or cancelled.\r\n     * @param _to - The destination address\r\n     * @param _amount - The amount to send\r\n     * @notice - Access control: Internal\r\n     */\r\n    function sendTokensTo(address _to, uint256 _amount) internal {\r\n\r\n        // Security: Can only be sent back to campaign owner or burned //\r\n        require((_to == campaignOwner)||(_to == BURN_ADDRESS), \"Can only be sent to campaign owner or burn address\");\r\n\r\n         // Burn or return UnSold token to owner \r\n        ERC20 ercToken = ERC20(token);\r\n        ercToken.safeTransfer(_to, _amount);\r\n    } \r\n     \r\n    /**\r\n     * @dev To calculate the amount of fee in BNB\r\n     * @param _amt - The amount in BNB\r\n     * @return - The amount of fee in BNB\r\n     * @notice - Access control: Internal\r\n     */\r\n    function getFeeAmt(uint256 _amt) internal view returns (uint256) {\r\n        return _amt.mul(feePcnt).div(1e6);\r\n    }\r\n\r\n    /**\r\n     * @dev To get the fee address\r\n     * @return - The fee address\r\n     * @notice - Access control: Internal\r\n     */\r\n    function getFeeAddress() internal view returns (address) {\r\n        IFactoryGetters fact = IFactoryGetters(factory);\r\n        return fact.getFeeAddress();\r\n    }\r\n\r\n    /**\r\n     * @dev To check whether the campaign failed (softcap not met) or cancelled\r\n     * @return - Bool value\r\n     * @notice - Access control: Public\r\n     */\r\n    function failedOrCancelled() public view returns(bool) {\r\n        if (cancelled) return true;\r\n        \r\n        return (block.timestamp >= endDate) && (softCap > collectedBNB) ;\r\n    }\r\n\r\n    /**\r\n     * @dev To check whether the campaign is isLive? isLive means a user can still invest in the project.\r\n     * @return - Bool value\r\n     * @notice - Access control: Public\r\n     */\r\n    function isLive() public view returns(bool) {\r\n        if (!tokenFunded || cancelled) return false;\r\n        if((block.timestamp < startDate)) return false;\r\n        if((block.timestamp >= endDate)) return false;\r\n        if((collectedBNB >= hardCap)) return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate amount of token receivable.\r\n     * @param _bnbInvestment - Amount of BNB invested\r\n     * @return - The amount of token\r\n     * @notice - Access control: Public\r\n     */\r\n    function calculateTokenAmount(uint256 _bnbInvestment) public view returns(uint256) {\r\n        return _bnbInvestment.mul(tokenSalesQty).div(hardCap);\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Gets remaining BNB to reach hardCap.\r\n     * @return - The amount of BNB.\r\n     * @notice - Access control: Public\r\n     */\r\n    function getRemaining() public view returns (uint256){\r\n        return (hardCap).sub(collectedBNB);\r\n    }\r\n\r\n    /**\r\n     * @dev Set a campaign as cancelled.\r\n     * @dev This can only be set before tokenReadyToClaim, finishUpSuccess, liquidityCreated .\r\n     * @dev ie, the users can either claim tokens or get refund, but Not both.\r\n     * @notice - Access control: Public, OnlyFactory\r\n     */\r\n    function setCancelled() onlyFactory external {\r\n\r\n        // If we are in VestingMode, then we should be able to cancel even if finishUp() is called \r\n        if (vestInfo.enabled && block.timestamp < vestInfo.times[0])\r\n        {\r\n            cancelled = true;\r\n            return;\r\n        }\r\n\r\n        require(!tokenReadyToClaim, \"Too late, tokens are claimable\");\r\n        require(!finishUpSuccess, \"Too late, finishUp called\");\r\n        require(!liquidityCreated, \"Too late, Lp created\");\r\n\r\n        cancelled = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate and return the Token amount need to be deposit by the project owner.\r\n     * @return - The amount of token required\r\n     * @notice - Access control: Public\r\n     */\r\n    function getCampaignFundInTokensRequired() public view returns(uint256) {\r\n        return tokenSalesQty.add(lpTokenQty);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Check whether the user address has enough svLaunch Tokens to participate in project.\r\n     * @param _user - The address of user\r\n     * @return - Bool result\r\n     * @notice - Access control: External\r\n     */  \r\n    function checkQualifyingTokens(address _user) public  view returns(bool) {\r\n\r\n        IFactoryGetters fact = IFactoryGetters(factory);\r\n        address svLaunchToken = fact.getLauncherToken();\r\n    \r\n        // get svLaunch Balance\r\n        uint256 sv = ERC20(svLaunchToken).balanceOf(_user);\r\n        return (sv >= svLaunchL1 && (sv <= svLaunchL2 || svLaunchL2==0)); // svLaunchL2 (0) means infinity.\r\n    }\r\n\r\n    function getMinMaxPurchasable(address _user) public view returns (uint256 min, uint256 max) {\r\n        \r\n        if (isLive()) {\r\n            return getMinMaxPurchasableByPeriod(_user, isPrivatePeriod());\r\n        }\r\n    }\r\n    \r\n    function getMinMaxPurchasableByPeriod(address _user, bool _privatePeriod) public view returns (uint256 min, uint256 max) {\r\n          \r\n        uint256 left = getRemaining();\r\n        (min, max) = _getAmountPurchasable(_user, _privatePeriod);\r\n        max = _min(max, left);\r\n        min = _min(min, left);\r\n    }\r\n\r\n    function isQualifiedSubscriber(address user) external view returns (bool) {\r\n        (uint min, uint max) =  _getAllocation(user);\r\n        return (min > 0 && max > 0);\r\n    }\r\n    \r\n    \r\n    function getHistoryCount(address user) external view returns (uint) {\r\n        return _history[user].length;\r\n    }\r\n    \r\n    function getHistoryItem(address user, uint index) external view returns (History memory) {\r\n        return _history[user][index];\r\n    }\r\n    \r\n    function getHistoryList(address user) external view returns (History[] memory) {\r\n        return _history[user];\r\n    }\r\n\r\n\r\n    function isPrivatePeriod() public view returns (bool) {\r\n        return  (block.timestamp >= startDate && block.timestamp <= midDate);\r\n    }\r\n \r\n\r\n    // Vesting feature support\r\n    /**\r\n     * @dev Setup and turn on the vesting feature\r\n     * @param _times - Array of period of the vesting.\r\n     * @param _percents - Array of percents release of the vesting.\r\n     * @notice - Access control: External. onlyFactory.\r\n     */  \r\n    function setupVestingMode(uint256[] calldata _times, uint256[] calldata _percents) external onlyFactory {\r\n        uint256 len = _times.length;\r\n        require(len>0, \"Invalid length\");\r\n        require(len == _percents.length, \"Wrong ranges\");\r\n\r\n        // check that all percentages should add up to 100% //\r\n        // 100% is 1e6\r\n        uint256 totalPcnt;\r\n        for (uint256 n=0; n<len; n++) {\r\n            totalPcnt = totalPcnt.add(_percents[n]);\r\n        }\r\n        require(totalPcnt == PERCENT100, \"Percentages add up should be 100%\");\r\n\r\n        vestInfo = VestingInfo({ times:_times, percents:_percents, totalVestedBnb:0, enabled:true});\r\n    }\r\n        \r\n\r\n    /**\r\n     * @dev Check whether vesting feature is enabled\r\n     * @return - Bool result\r\n     * @notice - Access control: External. onlyFactory.\r\n     */  \r\n    function isVestingEnabled() external view returns(bool) {\r\n        return vestInfo.enabled;\r\n    }\r\n\r\n    /**\r\n     * @dev Check whether a particular vesting index has elapsed and claimable\r\n     * @return - Bool: Claimable, uint256: If started and not claimable, returns the time needed to be claimable.\r\n     * @notice - Access control: Public.\r\n     */  \r\n    function isVestingClaimable(uint256 _index) public view returns(bool, uint256) {\r\n\r\n        if ( _index >= vestInfo.times.length) {\r\n            return (false,0);\r\n        }\r\n\r\n        bool claimable = (block.timestamp >= vestInfo.times[_index]);\r\n        uint256 remainTime;\r\n        if (!claimable) {\r\n            remainTime = vestInfo.times[_index].sub(block.timestamp); \r\n        }\r\n        return (claimable, remainTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow users to claim their vested token, according to the index of the vested period.\r\n     * @param _index - The index of the vesting period.\r\n     * @notice - Access control: External.\r\n     */  \r\n    function claimVestedTokens(uint256 _index) external {\r\n\r\n        (bool claimable, ) = isVestingClaimable(_index);\r\n        require(claimable, \"Not claimable at this time\");\r\n\r\n        uint256 amtTotalToken = getTotalTokenPurchased(msg.sender);\r\n\r\n        require(amtTotalToken > 0, \"You have not purchased the tokens\");\r\n\r\n        bool claimed = investorsClaimMap[msg.sender][_index];\r\n        require(!claimed, \"This vest amount is already claimed\");\r\n\r\n        investorsClaimMap[msg.sender][_index] = true;\r\n        uint256 amtTokens = vestInfo.percents[_index].mul(amtTotalToken).div(PERCENT100);\r\n            \r\n        ERC20(token).safeTransfer(msg.sender, amtTokens);\r\n        emit TokenClaimed(msg.sender, block.timestamp, amtTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow campaign owner to claim their bnb, according to the index of the vested period.\r\n     * @param _index - The index of the vesting period.\r\n     * @notice - Access control: External. onlyCampaignOwner.\r\n     */  \r\n    function claimVestedBnb(uint256 _index) external onlyCampaignOwner {\r\n\r\n        require(finishUpSuccess, \"finishUp has to be called\");\r\n\r\n        (bool claimable, ) = isVestingClaimable(_index);\r\n        require(claimable, \"Not claimable at this time\");\r\n\r\n        require(!campaignOwnerClaimMap[_index], \"This vest amount is already claimed\");\r\n        campaignOwnerClaimMap[_index] = true;\r\n\r\n        uint256 amtBnb = vestInfo.percents[_index].mul(vestInfo.totalVestedBnb).div(PERCENT100);\r\n\r\n        (bool sentBnb, ) = campaignOwner.call{value: amtBnb}(\"\");\r\n        require(sentBnb, \"Failed to send remain BNB to campaign owner\");\r\n    }\r\n\r\n     /**\r\n     * @dev To get the next vesting claim for a user.\r\n     * @param _user - The user's address.\r\n     * @return - int256 : the next period. -1 to indicate none found.\r\n     * @return - uint256 : the amount of token claimable\r\n     * @return - uint256 : time left to claim. If 0 (and next claim period is valid), it is currently claimable.\r\n     * @notice - Access control: External. View.\r\n     */  \r\n    function getNextVestingClaim(address _user) external view returns(int256, uint256, uint256) {\r\n\r\n        if (!vestInfo.enabled) {\r\n            return (-1,0,0);\r\n        }\r\n\r\n        uint256 amtTotalToken = getTotalTokenPurchased(_user);\r\n        if (amtTotalToken==0) {\r\n            return (-1,0,0);\r\n        }\r\n\r\n        uint256 len = vestInfo.times.length;\r\n        for (uint256 n=0; n<len; n++) {\r\n            (bool claimable, uint256 time) = isVestingClaimable(n);\r\n            uint256 amtTokens = vestInfo.percents[n].mul(amtTotalToken).div(PERCENT100);\r\n            bool claimed = investorsClaimMap[_user][n];\r\n           \r\n            if (!claimable) {\r\n                return (int256(n), amtTokens, time);\r\n            } else {\r\n                if (!claimed) {\r\n                    return ( int256(n), amtTokens, 0);\r\n                }\r\n            }\r\n        }\r\n        // All claimed \r\n        return (-1,0,0);\r\n    }\r\n\r\n    // Privates\r\n    function _getAmountPurchasable(address _user, bool _privateSale) private view returns (uint256 min, uint256 max) {\r\n        \r\n        if (_privateSale) {\r\n            (min, max) = _getAllocation(_user);\r\n            max = max.sub(participants[_user]);\r\n        } else {\r\n\r\n            min = _allocForSvLaunch(svLaunchL1);\r\n            max = _allocForSvLaunch(svLaunchCapped);\r\n            max = max.sub(participants[_user]);\r\n        }\r\n    }\r\n\r\n    function _recordHistory(address user, Action action, uint amount) private {\r\n        History memory item = History(uint128(block.timestamp), uint128(action), amount);\r\n        _history[user].push(item);\r\n    }\r\n\r\n    function _min(uint256 _a, uint256 _b) private pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n\r\n    function _getAllocation(address _user) private view returns (uint256, uint256) {\r\n        \r\n         IFactoryGetters fact = IFactoryGetters(factory);\r\n        address svLaunchToken = fact.getLauncherToken();\r\n        uint256 sv = ERC20(svLaunchToken).balanceOf(_user);\r\n        \r\n        if (sv < svLaunchL1 || (sv > svLaunchL2 && svLaunchL2!=0)) {\r\n            return (0,0);\r\n        } \r\n\r\n        if (sv >= svLaunchCapped) {\r\n            sv = svLaunchCapped;\r\n        }\r\n\r\n        uint256 allocMin = _allocForSvLaunch(svLaunchL1);\r\n        uint256 allocMax = _allocForSvLaunch(sv);\r\n        return (allocMin, allocMax); \r\n    }\r\n\r\n    function _allocForSvLaunch(uint256 _sv) private view returns (uint256) {\r\n        return (_sv.mul(allocationFactor)).div(E18);\r\n    }\r\n\r\n}\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: Factory.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract Factory is IFactoryGetters, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable svLaunchAddress;\r\n    \r\n    struct CampaignInfo {\r\n        address contractAddress;\r\n        address owner;\r\n    }\r\n    // List of campaign and their project owner address. \r\n    // For security, only project owner can provide fund.\r\n    mapping(uint256 => CampaignInfo) public allCampaigns;\r\n    uint256 count;\r\n    \r\n    address private feeAddress;\r\n    address private lpRouter; // Uniswap or PancakeSwap\r\n\r\n    constructor(\r\n        address _svLaunchAddress,\r\n        address _feeAddress,\r\n        address _lpRouter\r\n    )  Ownable() \r\n    {\r\n        svLaunchAddress = _svLaunchAddress;\r\n        feeAddress = _feeAddress;\r\n        lpRouter = _lpRouter;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new campaign\r\n     * @param _token - The token address\r\n     * @param _subIndex - The fund raising round Id\r\n     * @param _campaignOwner - Campaign owner address\r\n     * @param _stats - Array of 4 uint256 values.\r\n     * @notice - [0] Softcap. 1e18 = 1 BNB.\r\n     * @notice - [1] Hardcap. 1e18 = 1 BNB.\r\n     * @notice - [2] TokenSalesQty. The amount of tokens for sale. Example: 1e8 for 1 token with 8 decimals.\r\n     * @notice - [3] feePcnt. 100% is 1e6.\r\n     * @param _dates - Array of 3 uint256 dates.\r\n     * @notice - [0] Start date.\r\n     * @notice - [1] End date.\r\n     * @notice - [2] Mid date. For Accessibility.WhitelistedFirstThenEveryone only.\r\n     * @param _buyFactors - Array of 3 uint256 values.\r\n     * @notice - [0] svLaunchL1: Lower bound of svLaunch requirement. Eg 40e18\r\n     * @notice - [1] svLaunchL2: Upper bound of svLaunch requirement (0 means infinite, no bounds). Eg 1000e18\r\n     * @notice - [2] svLaunchCapped: The capped value of svLaunch used for allocation calculation. Eg 1000e18\r\n     * @notice - [3] allocationFactor: The amount of BNB purchasable per qualifying svLaunch.\r\n     * @param _access - Everyone, Whitelisted-only, or hybrid.\r\n     * @param _liquidity - Array of 3 uint256 values.\r\n     * @notice - [0] BNB amount to use (from token sales) to be used to provide LP.\r\n     * @notice - [1] Token amount to be used to provide LP.\r\n     * @notice - [2] LockDuration of the LP tokens.\r\n     * @param _burnUnSold - Indicate to burn un-sold tokens or not. For successful campaign only.\r\n     * @return campaignAddress - The address of the new campaign smart contract created\r\n     * @notice - Access control: Public, OnlyOwner\r\n     */\r\n\r\n    function createCampaign(\r\n        address _token,\r\n        uint256 _subIndex,             \r\n        address _campaignOwner,     \r\n        uint256[4] calldata _stats,  \r\n        uint256[3] calldata _dates, \r\n        uint256[4] calldata _buyFactors,    \r\n        Campaign.Accessibility _access,  \r\n        uint256[3] calldata _liquidity, \r\n        bool _burnUnSold  \r\n    ) external onlyOwner returns (address campaignAddress)\r\n    {\r\n        require(_stats[0] < _stats[1],\"Soft cap can't be higher than hard cap\" );\r\n        require(_stats[2] > 0,\"Token for sales can't be 0\");\r\n        require(_stats[3] <= 10e6, \"Invalid fees value\");\r\n        require(_dates[0] < _dates[1] ,\"Start date can't be higher than end date\" );\r\n        require(block.timestamp < _dates[1] ,\"End date must be higher than current date \");\r\n       \r\n        require(_buyFactors[0] > 0, \"Lower bound svLaunch must be > 0\" );\r\n        require(_buyFactors[2] >= _buyFactors[0], \"Invalid capped svLaunch\");\r\n        require(_buyFactors[3] > 0, \"Allocation factor must be greater than 0.\" );\r\n        \r\n        if (_liquidity[0] > 0) { // Liquidity provision check //\r\n            require(_liquidity[0] <= _stats[0], \"BNB for liquidity cannot be greater than softcap\");\r\n            require(_liquidity[1] > 0, \"Token for liquidity cannot be 0\");\r\n        } else {\r\n            require(_liquidity[1] == 0, \"Both liquidity BNB and token must be 0\");\r\n        }\r\n\r\n        // Boundary check: After deducting for fee, the Softcap amt left is enough to create the LP\r\n        uint256 feeAmt = _stats[0].mul(_stats[3]).div(1e6);\r\n        require(_stats[0].sub(feeAmt) >= _liquidity[0], \"Liquidity BNB amount is too high\");\r\n\r\n        if (_access == Campaign.Accessibility.WhitelistedFirstThenEveryone) {\r\n            require((_dates[2] > _dates[0]) && (_dates[2] < _dates[1]) , \"Invalid dates setup\");\r\n        }\r\n        \r\n        bytes memory bytecode = type(Campaign).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(_token, _subIndex, msg.sender));\r\n        assembly {\r\n            campaignAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        \r\n        Campaign(campaignAddress).initialize \r\n        (\r\n            _token,\r\n            _campaignOwner,\r\n            _stats,\r\n            _dates,\r\n            _buyFactors,\r\n            _access,\r\n            _liquidity,\r\n            _burnUnSold\r\n        );\r\n        \r\n        allCampaigns[count] = CampaignInfo(campaignAddress, _campaignOwner);\r\n        count = count.add(1);\r\n        \r\n        return campaignAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel a campaign\r\n     * @param _campaignID - The campaign ID\r\n     * @notice - Access control: External, OnlyOwner\r\n     */    \r\n    function cancelCampaign(uint256 _campaignID) external onlyOwner {\r\n\r\n        require(_campaignID < count, \"Invalid ID\");\r\n\r\n        CampaignInfo memory info = allCampaigns[_campaignID];\r\n        require(info.contractAddress != address(0), \"Invalid Campaign contract\");\r\n        \r\n        Campaign camp = Campaign(info.contractAddress);\r\n        camp.setCancelled();\r\n    }\r\n\r\n    /**\r\n     * @dev Allow Factory owner to call this to set the flag to\r\n     * @dev enable token claiming.\r\n     * @dev This is useful when 1 project has multiple campaigns that need\r\n     * @dev to sync up the timing of token claiming After LP provision.\r\n     * @notice - Access control: External,  onlyFactory\r\n     */\r\n    function setTokenClaimable(uint256 _campaignID) external onlyOwner {\r\n\r\n        require(_campaignID < count, \"Invalid ID\");\r\n\r\n        CampaignInfo memory info = allCampaigns[_campaignID];\r\n        require(info.contractAddress != address(0), \"Invalid Campaign contract\");\r\n        \r\n        Campaign camp = Campaign(info.contractAddress);\r\n        camp.setTokenClaimable();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Add liquidity and lock it up. Called after a campaign has ended successfully.\r\n     * @notice - Access control: External. OnlyOwner.\r\n     */\r\n    function addAndLockLP(uint256 _campaignID) external onlyOwner {\r\n        require(_campaignID < count, \"Invalid ID\");\r\n\r\n        CampaignInfo memory info = allCampaigns[_campaignID];\r\n        require(info.contractAddress != address(0), \"Invalid Campaign contract\");\r\n        \r\n        Campaign camp = Campaign(info.contractAddress);\r\n        camp.addAndLockLP();\r\n    }\r\n\r\n    /**\r\n     * @dev Recover Unspent LP for a campaign\r\n     * @param _campaignID - The campaign ID\r\n     * @notice - Access control: External, OnlyOwner\r\n     */    \r\n    function recoverUnspentLp(uint256 _campaignID, address _campaignOwnerForCheck) external onlyOwner {\r\n\r\n        require(_campaignID < count, \"Invalid ID\");\r\n\r\n        CampaignInfo memory info = allCampaigns[_campaignID];\r\n        require(info.contractAddress != address(0), \"Invalid Campaign contract\");\r\n        require(info.owner == _campaignOwnerForCheck, \"Invalid campaign owner\"); // additional check\r\n        \r\n        Campaign camp = Campaign(info.contractAddress);\r\n        camp.recoverUnspentLp();\r\n    }\r\n\r\n    /**\r\n     * @dev Setup and turn on the vesting feature\r\n     * @param _campaignID - The campaign ID\r\n     * @param _times - Array of period of the vesting.\r\n     * @param _percents - Array of percents release of the vesting.\r\n     * @notice - Access control: External. onlyFactory.\r\n     */  \r\n    function setupVestingMode(uint256 _campaignID, uint256[] calldata _times, uint256[] calldata _percents) external onlyOwner {\r\n\r\n        require(_campaignID < count, \"Invalid ID\");\r\n\r\n        CampaignInfo memory info = allCampaigns[_campaignID];\r\n        require(info.contractAddress != address(0), \"Invalid Campaign contract\");\r\n\r\n        Campaign camp = Campaign(info.contractAddress);\r\n        camp.setupVestingMode(_times, _percents);\r\n    }\r\n\r\n\r\n    // IFactoryGetters\r\n    /**\r\n     * @dev Get the LP router address\r\n     * @return - Return the LP router address\r\n     * @notice - Access control: External\r\n     */  \r\n    function getLpRouter() external override view returns(address) {\r\n        return lpRouter;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the fee address\r\n     * @return - Return the fee address\r\n     * @notice - Access control: External\r\n     */  \r\n    function getFeeAddress() external override view returns(address) {\r\n        return feeAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the svLauncher token address\r\n     * @return - Return the address\r\n     * @notice - Access control: External\r\n     */ \r\n    function getLauncherToken() external override view returns(address) {\r\n        return svLaunchAddress;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLPToken\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStampStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStampExpiry\",\"type\":\"uint256\"}],\"name\":\"LiquidityLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LiquidityWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessibility\",\"outputs\":[{\"internalType\":\"enum Campaign.Accessibility\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addAndLockLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocationFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnUnSold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnbInvestment\",\"type\":\"uint256\"}],\"name\":\"calculateTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"campaignOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkQualifyingTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claimVestedBnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claimVestedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedRecords\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failedOrCancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePcnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishUpSuccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCampaignFundInTokensRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getHistoryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getHistoryItem\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"timeStamp\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"action\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Campaign.History\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getHistoryList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"timeStamp\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"action\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Campaign.History[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMinMaxPurchasable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_privatePeriod\",\"type\":\"bool\"}],\"name\":\"getMinMaxPurchasableByPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNextVestingClaim\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTotalTokenPurchased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_campaignOwner\",\"type\":\"address\"},{\"internalType\":\"uint256[4]\",\"name\":\"_stats\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256[3]\",\"name\":\"_dates\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_buyFactors\",\"type\":\"uint256[4]\"},{\"internalType\":\"enum Campaign.Accessibility\",\"name\":\"_access\",\"type\":\"uint8\"},{\"internalType\":\"uint256[3]\",\"name\":\"_liquidity\",\"type\":\"uint256[3]\"},{\"internalType\":\"bool\",\"name\":\"_burnUnSold\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPrivatePeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isQualifiedSubscriber\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"isVestingClaimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVestingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityCreated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpBnbQty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTokenQty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"midDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverUnspentLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setCancelled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setTokenClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_times\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percents\",\"type\":\"uint256[]\"}],\"name\":\"setupVestingMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"svLaunchCapped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"svLaunchL1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"svLaunchL2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenFunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenReadyToClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSalesQty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalVestedBnb\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Campaign", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0b34e1df5063491276698b33272684b5cef89a23c09c5fdea4007b6f6c8f23fd"}