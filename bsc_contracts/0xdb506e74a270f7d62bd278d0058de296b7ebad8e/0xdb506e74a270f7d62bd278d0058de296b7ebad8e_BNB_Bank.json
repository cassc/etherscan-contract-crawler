{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bnbBank/BNB_Bank_State.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IBNB_Bank.sol\\\";\\n\\ncontract BNB_Bank_State is Ownable, IBNB_Bank {\\n    using SafeMath for uint;\\n    // 1000 == 100%, 100 == 10%, 10 == 1%, 1 == 0.1%\\n    uint internal constant REFERRAL_LEGNTH = 3;\\n    uint[REFERRAL_LEGNTH] internal REFERRAL_PERCENTS = [100, 30, 20];\\n    uint internal INVEST_MIN_AMOUNT = 0.01 ether;\\n    // uint constant internal INVEST_FEE = 120;\\n    // uint internal constant WITHDRAW_FEE_PERCENT = 100;\\n    uint internal constant MIN_WITHDRAW = 1;\\n    uint internal constant PERCENTS_DIVIDER = 1_000;\\n    uint internal constant TIME_STEP = 1 days;\\n    uint internal constant CYCLE_STEP = 1 * TIME_STEP;\\n    // 2000 == 200%\\n    uint internal constant MAX_PROFIT = 2_000;\\n    // uint constant internal MARKET_FEE = 400;\\n    uint internal constant FORCE_WITHDRAW_PERCENT = 500;\\n    // 200 == 20%\\n    uint internal constant ROI_BASE = 200;\\n\\n    uint internal constant DEFAULT_INVEST_FEE = 100;\\n\\n    uint internal initDate;\\n\\n    uint internal totalUsers;\\n    uint internal totalInvested;\\n    // uint internal totalInvestedUsd;\\n    uint internal totalWithdrawn;\\n    // uint internal totalWithdrawnTokens;\\n    uint internal totalDeposits;\\n    // uint internal totalReinvested;\\n\\n    FeeData public fees;\\n\\n    address public defaultWallet;\\n    address public feeWallet;\\n    address public feeDev;\\n\\n    Plan public plan;\\n\\n    mapping(address => User) public users;\\n    mapping(address => uint) public lastBlock;\\n    mapping(uint => address) public addressByIndex;\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    modifier tenBlocks() {\\n        require(block.number.sub(lastBlock[msg.sender]) > 10, \\\"wait 10 blocks\\\");\\n        _;\\n        lastBlock[msg.sender] = block.number;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(initDate > 0, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(initDate == 0, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    function setFeeWallet(address _feeWallet) external onlyOwner {\\n        feeWallet = _feeWallet;\\n    }\\n\\n    function setMinInvest(uint _amount) external onlyOwner {\\n        INVEST_MIN_AMOUNT = _amount;\\n    }\\n\\n    function setFees(uint invest, uint withdraw) external onlyOwner {\\n        fees = FeeData(invest, withdraw);\\n    }\\n\\n    function setReferralPercents(\\n        uint[REFERRAL_LEGNTH] memory _referralPercents\\n    ) external onlyOwner {\\n        uint sum;\\n        for (uint i = 0; i < REFERRAL_LEGNTH; i++) {\\n            sum = sum.add(_referralPercents[i]);\\n        }\\n        require(sum == PERCENTS_DIVIDER, \\\"wrong percents sum\\\");\\n        REFERRAL_PERCENTS = _referralPercents;\\n    }\\n\\n    function getConstans()\\n        external\\n        view\\n        returns (\\n            uint _refLenght,\\n            uint _investMinAmount,\\n            uint _minWithdraw,\\n            uint _percentsDivider,\\n            uint _timeStep,\\n            uint _forceWithdrawPercent,\\n            uint _maxProfit\\n        )\\n    {\\n        return (\\n            REFERRAL_LEGNTH,\\n            INVEST_MIN_AMOUNT,\\n            MIN_WITHDRAW,\\n            PERCENTS_DIVIDER,\\n            TIME_STEP,\\n            FORCE_WITHDRAW_PERCENT,\\n            MAX_PROFIT\\n        );\\n    }\\n\\n    function unpause() external whenPaused onlyOwner {\\n        initDate = block.timestamp;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    function isPaused() external view returns (bool) {\\n        return (initDate == 0);\\n    }\\n\\n    function getUser(address _user) public view override returns (User memory) {\\n        return users[_user];\\n    }\\n\\n    function getUserByindex(\\n        uint _index\\n    ) external view override returns (User memory) {\\n        return users[addressByIndex[_index]];\\n    }\\n\\n    function getAllUsers() external view override returns (User[] memory) {\\n        User[] memory _users = new User[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            _users[i] = users[addressByIndex[i]];\\n        }\\n        return _users;\\n    }\\n\\n    function getAllInvestors()\\n        external\\n        view\\n        override\\n        returns (address[] memory)\\n    {\\n        address[] memory _users = new address[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            _users[i] = addressByIndex[i];\\n        }\\n        return _users;\\n    }\\n\\n    function getUsersByRange(\\n        uint _init,\\n        uint end\\n    ) external view override returns (User[] memory) {\\n        User[] memory _users = new User[](end - _init);\\n        for (uint i = _init; i < end; i++) {\\n            _users[i] = users[addressByIndex[i]];\\n        }\\n        return _users;\\n    }\\n\\n    function getDepsitStartDate(\\n        Deposit memory ndeposit\\n    ) internal view returns (uint) {\\n        uint _date = getContracDate();\\n        if (_date > ndeposit.start) {\\n            return _date;\\n        } else {\\n            return ndeposit.start;\\n        }\\n    }\\n\\n    function getUserDepositInfo(\\n        address userAddress,\\n        uint index\\n    )\\n        external\\n        view\\n        returns (uint amount_, uint withdrawn_, uint timeStart_, uint maxProfit)\\n    {\\n        Deposit memory deposit = users[userAddress].deposits[index];\\n        amount_ = deposit.amount;\\n        withdrawn_ = deposit.withdrawn;\\n        timeStart_ = getDepsitStartDate(deposit);\\n        maxProfit = getMaxprofit(deposit);\\n    }\\n\\n    function getMaxprofit(\\n        Deposit memory ndeposit\\n    ) internal view returns (uint) {\\n        if (ndeposit.force) {\\n            return\\n                (ndeposit.amount.mul(FORCE_WITHDRAW_PERCENT)).div(\\n                    PERCENTS_DIVIDER\\n                );\\n        }\\n        return (ndeposit.amount.mul(plan.MAX_PROFIT)).div(PERCENTS_DIVIDER);\\n    }\\n\\n    function getDeposit(\\n        address _user,\\n        uint _index\\n    ) external view override returns (Deposit memory) {\\n        return users[_user].deposits[_index];\\n    }\\n\\n    function getAllDeposits(\\n        address _user\\n    ) external view override returns (Deposit[] memory) {\\n        return users[_user].deposits;\\n    }\\n\\n    function getUserPlans(\\n        address _user\\n    ) external view returns (Deposit[] memory) {\\n        User storage user = users[_user];\\n        Deposit[] memory result = new Deposit[](user.depositsLength);\\n        for (uint i; i < user.depositsLength; i++) {\\n            result[i] = user.deposits[i];\\n        }\\n        return result;\\n    }\\n\\n    // function getUserTotalDeposits(\\n    //     address userAddress\\n    // ) internal view returns (uint) {\\n    //     User storage user = users[userAddress];\\n    //     uint amount;\\n    //     for (uint i; i < user.depositsLength; i++) {\\n    //         amount += users[userAddress].deposits[i].amount;\\n    //     }\\n    //     return amount;\\n    // }\\n\\n    // function getUserTotalWithdrawn(\\n    //     address userAddress\\n    // ) internal view returns (uint) {\\n    //     User storage user = users[userAddress];\\n\\n    //     uint amount;\\n\\n    //     for (uint i; i < user.depositsLength; i++) {\\n    //         amount += users[userAddress].deposits[i].withdrawn;\\n    //     }\\n    //     return amount;\\n    // }\\n\\n    function getDAte() public view returns (uint) {\\n        return block.timestamp;\\n    }\\n\\n    function getReferrerBonus(\\n        address _user\\n    ) external view returns (uint[REFERRAL_LEGNTH] memory) {\\n        return users[_user].referrerBonus;\\n    }\\n\\n    function getContracDate() public view returns (uint) {\\n        if (initDate == 0) {\\n            return block.timestamp;\\n        }\\n        return initDate;\\n    }\\n\\n    function getPublicData()\\n        external\\n        view\\n        returns (\\n            uint totalUsers_,\\n            uint totalInvested_,\\n            // uint totalInvestedUsd_,\\n            // uint totalReinvested_,\\n            uint totalWithdrawn_,\\n            uint totalDeposits_,\\n            uint balance_,\\n            uint roiBase,\\n            // uint _totalWithdrawnTokens,\\n            // uint maxProfit,\\n            uint minDeposit,\\n            uint daysFormdeploy\\n        )\\n    {\\n        totalUsers_ = totalUsers;\\n        totalInvested_ = totalInvested;\\n        // totalInvestedUsd_ = totalInvestedUsd;\\n        // totalReinvested_ = totalReinvested;\\n        totalWithdrawn_ = totalWithdrawn;\\n        totalDeposits_ = totalDeposits;\\n        balance_ = getContractBalance();\\n        roiBase = ROI_BASE;\\n        // maxProfit = MAX_PROFIT;\\n        minDeposit = INVEST_MIN_AMOUNT;\\n        daysFormdeploy = (block.timestamp.sub(getContracDate())).div(TIME_STEP);\\n        // _totalWithdrawnTokens = totalWithdrawnTokens;\\n    }\\n\\n    function getContractBalance() public view returns (uint) {\\n        return address(this).balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bnbBank/BNB_Bank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./BNB_Bank_State.sol\\\";\\n\\ncontract BNB_Bank is BNB_Bank_State, ReentrancyGuard  {\\n    using SafeMath for uint;\\n    bool public reinvestIsActive = true;\\n    event Newbie(address user);\\n    event NewDeposit(address indexed user, uint amount);\\n    event Withdrawn(address indexed user, uint amount);\\n    event RefBonus(\\n        address indexed referrer,\\n        address indexed referral,\\n        uint indexed level,\\n        uint amount\\n    );\\n    event FeePayed(address indexed user, uint totalAmount);\\n    event Reinvestment(address indexed user, uint amount);\\n    event ForceWithdraw(address indexed user, uint amount);\\n\\n    constructor(address _feeWallet, address _defaultWallet) {\\n        User memory _user;\\n        require(\\n            _user.referrerCount.length == REFERRAL_LEGNTH &&\\n                _user.referrerBonus.length == REFERRAL_LEGNTH,\\n            \\\"invalid referral length\\\"\\n        );\\n        feeWallet = _feeWallet;\\n        feeDev = msg.sender;\\n        defaultWallet = _defaultWallet;\\n        plan = Plan(CYCLE_STEP, ROI_BASE, MAX_PROFIT);\\n        fees = FeeData(DEFAULT_INVEST_FEE, DEFAULT_INVEST_FEE);\\n        emit Paused(msg.sender);\\n    }\\n\\n    modifier checkUser_() {\\n        uint check = block.timestamp.sub(\\n            getlastActionDate(users[msg.sender].checkpoint)\\n        );\\n        require(check > TIME_STEP, \\\"try again later\\\");\\n        _;\\n    }\\n\\n    function checkUser() external view returns (bool) {\\n        uint check = block.timestamp.sub(\\n            getlastActionDate(users[msg.sender].checkpoint)\\n        );\\n        if (check > TIME_STEP) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function invest(\\n        address referrer\\n    ) external payable nonReentrant whenNotPaused tenBlocks {\\n        uint _amount = msg.value;\\n        payFeeInvest(_amount);\\n        investHandler(_amount, referrer, msg.sender);\\n    }\\n\\n    function investHandler(\\n        uint investAmt,\\n        address referrer,\\n        address _user\\n    ) internal {\\n        require(investAmt >= INVEST_MIN_AMOUNT, \\\"insufficient deposit\\\");\\n\\n        User storage user = users[_user];\\n\\n        if (user.user == address(0)) {\\n            if (\\n                user.referrer == address(0) &&\\n                users[referrer].depositsLength > 0 &&\\n                referrer != _user &&\\n                users[referrer].referrer != _user\\n            ) {\\n                user.referrer = referrer;\\n            }\\n        }\\n\\n        address upline;\\n\\n        if (user.referrer != address(0)) {\\n            upline = user.referrer;\\n        } else {\\n            upline = defaultWallet;\\n        }\\n\\n        bool isFirst = false;\\n        if (user.depositsLength == 0) {\\n            isFirst = true;\\n        }\\n        uint toDefault = 0;\\n        for (uint i; i < REFERRAL_PERCENTS.length; i++) {\\n            if (upline != address(0)) {\\n                uint amount = (investAmt.mul(REFERRAL_PERCENTS[i])).div(\\n                    PERCENTS_DIVIDER\\n                );\\n\\n                if (upline == defaultWallet) {\\n                    toDefault += amount;\\n                } else {\\n                    users[upline].bonus += amount;\\n                }\\n                users[upline].totalBonus += investAmt;\\n                if (isFirst) {\\n                    users[upline].referrerCount[i] += 1;\\n                    if (i == 0) {\\n                        users[upline].referralsv0.push(_user);\\n                    } else if (i == 1) {\\n                        users[upline].referralsv1.push(_user);\\n                    } else if (i == 2) {\\n                        users[upline].referralsv2.push(_user);\\n                    } else if (i == 3) {\\n                        users[upline].referralsv3.push(_user);\\n                    } else if (i == 4) {\\n                        users[upline].referralsv4.push(_user);\\n                    }\\n                }\\n                users[upline].referrerBonus[i] += amount;\\n                emit RefBonus(upline, _user, i, amount);\\n                upline = users[upline].referrer;\\n                if (upline == address(0)) {\\n                    upline = defaultWallet;\\n                }\\n            } else break;\\n        }\\n        if (toDefault > 0) {\\n            transferHandler(defaultWallet, toDefault);\\n        }\\n        if (isFirst) {\\n            user.user = _user;\\n            user.checkpoint = block.timestamp;\\n            user.id = totalUsers;\\n            addressByIndex[totalUsers] = _user;\\n            totalUsers++;\\n            emit Newbie(_user);\\n        }\\n\\n        Deposit memory newDeposit;\\n        // uint usdAmount = contractsLibrary.getBnbToUsd(investAmt);\\n        newDeposit.amount = investAmt;\\n        newDeposit.start = block.timestamp;\\n        // newDeposit.amountBnb = investAmt;\\n        newDeposit.id = user.depositsLength; // user.deposits[user.depositsLength] = newDeposit;\\n        user.deposits.push(newDeposit);\\n        user.depositsLength++;\\n        user.totalInvested += investAmt;\\n        // user.totalInvestedBnb += investAmt;\\n\\n        totalInvested += investAmt;\\n        // totalInvestedUsd += usdAmount;\\n        totalDeposits += 1;\\n        emit NewDeposit(_user, investAmt);\\n    }\\n\\n    function withdraw()\\n        external\\n        whenNotPaused\\n        checkUser_\\n        tenBlocks\\n    returns (bool) {\\n        return withdrawInternal(false);\\n    }\\n\\n    function withdrawInternal(bool isReinvest) internal returns (bool) {\\n        if(isReinvest) {\\n            require(reinvestIsActive, \\\"reinvest is not active\\\");\\n        }\\n        User storage user = users[msg.sender];\\n\\n        uint totalAmount;\\n\\n        for (uint i; i < user.depositsLength; i++) {\\n            uint dividends;\\n            Deposit memory deposit = user.deposits[i];\\n            if (\\n                deposit.withdrawn < getMaxprofit(deposit) &&\\n                deposit.force == false\\n            ) {\\n                dividends = calculateDividents(deposit, user.checkpoint);\\n\\n                if (dividends > 0) {\\n                    //changing of storage data\\n                    user.deposits[i].withdrawn += dividends;\\n                    delete user.deposits[i].acumulated;\\n                    totalAmount += dividends;\\n                }\\n            }\\n        }\\n\\n        uint referralBonus = user.bonus;\\n        if (referralBonus > 0) {\\n            totalAmount += referralBonus;\\n            delete user.bonus;\\n        }\\n\\n        require(totalAmount >= MIN_WITHDRAW, \\\"User has no dividends\\\");\\n\\n        uint contractBalance = getContractBalance();\\n        if (contractBalance < totalAmount) {\\n            totalAmount = contractBalance;\\n        }\\n\\n\\n        user.checkpoint = block.timestamp;\\n        uint256 fee = payFees(totalAmount);\\n        emit FeePayed(msg.sender, fee);\\n        uint256 toTransfer = totalAmount.sub(fee);\\n        if(!isReinvest) {\\n            user.totalWithdrawn += totalAmount;\\n            totalWithdrawn += totalAmount;\\n            transferHandler(msg.sender, toTransfer);\\n            emit Withdrawn(msg.sender, totalAmount);\\n        } else {\\n            user.reinvest += totalAmount;\\n            emit Reinvestment(msg.sender, totalAmount);\\n            investHandler(toTransfer, user.referrer, msg.sender);\\n        }\\n\\n\\n        return true;\\n    }\\n\\n    function reinvestment()\\n        external\\n        whenNotPaused\\n        checkUser_\\n        nonReentrant\\n        returns (bool)\\n    {\\n        return withdrawInternal(true);\\n    }\\n\\n    function setReinvestStatus(bool _status) external onlyOwner {\\n        reinvestIsActive = _status;\\n    }\\n\\n    function forceWithdraw() external whenNotPaused nonReentrant tenBlocks {\\n        User storage user = users[msg.sender];\\n        uint totalDividends;\\n        uint toFee;\\n        for (uint256 i; i < user.depositsLength; i++) {\\n            Deposit storage deposit = user.deposits[i];\\n            if (deposit.force == false) {\\n                deposit.force = true;\\n                uint maxProfit = getMaxprofit(deposit);\\n                if (deposit.withdrawn < maxProfit) {\\n                    uint profit = maxProfit.sub(deposit.withdrawn);\\n                    deposit.withdrawn = deposit.withdrawn.add(profit);\\n                    totalDividends += profit;\\n                    toFee += deposit.amount.sub(maxProfit, \\\"sub error\\\");\\n                }\\n            }\\n        }\\n\\n        // uint referralBonus = user.bonus;\\n        // if (referralBonus > 0) {\\n        //     delete user.bonus;\\n        //     uint bonusToFee = referralBonus.mul(FORCE_WITHDRAW_PERCENT).div(\\n        //         PERCENTS_DIVIDER\\n        //     );\\n        //     totalDividends += referralBonus.sub(bonusToFee, \\\"sub error 1\\\");\\n        //     toFee += bonusToFee;\\n        // }\\n\\n        require(totalDividends > 0, \\\"User has no dividends\\\");\\n        uint256 contractBalance = getContractBalance();\\n        if (contractBalance < totalDividends + toFee) {\\n            totalDividends = contractBalance.mul(FORCE_WITHDRAW_PERCENT).div(\\n                PERCENTS_DIVIDER\\n            );\\n            toFee = contractBalance.sub(totalDividends, \\\"sub error 2\\\");\\n        }\\n        user.checkpoint = block.timestamp;\\n        // payFees(toFee);\\n        transferHandler(feeWallet, toFee);\\n        transferHandler(msg.sender, totalDividends);\\n        emit FeePayed(msg.sender, toFee);\\n        emit ForceWithdraw(msg.sender, totalDividends);\\n    }\\n\\n    function getNextUserAssignment(\\n        address userAddress\\n    ) public view returns (uint) {\\n        uint checkpoint = getlastActionDate(users[userAddress].checkpoint);\\n        uint _date = getContracDate();\\n        if (_date > checkpoint) checkpoint = _date;\\n        return checkpoint.add(TIME_STEP);\\n    }\\n\\n    function getUserData(\\n        address userAddress\\n    )\\n        external\\n        view\\n        returns (\\n            uint totalWithdrawn_,\\n            uint totalDeposits_,\\n            uint _currentRefBonus,\\n            // uint totalRefBonus_,\\n            uint totalReinvest_,\\n            uint balance_,\\n            uint nextAssignment_,\\n            uint amountOfDeposits,\\n            uint checkpoint,\\n            uint id,\\n            address referrer_,\\n            uint[REFERRAL_LEGNTH] memory referrerCount_,\\n            uint[REFERRAL_LEGNTH] memory referrerBonus_\\n        )\\n    {\\n        User storage user = users[userAddress];\\n        totalWithdrawn_ = user.totalWithdrawn;\\n        totalDeposits_ = user.totalInvested;\\n        nextAssignment_ = getNextUserAssignment(userAddress);\\n        balance_ = getUserDividends(userAddress);\\n        _currentRefBonus = user.bonus;\\n        // totalRefBonus_ = user.totalBonus;\\n        totalReinvest_ = user.reinvest;\\n        amountOfDeposits = user.depositsLength;\\n\\n        checkpoint = getlastActionDate(user.checkpoint);\\n        referrer_ = user.referrer;\\n        referrerCount_ = user.referrerCount;\\n        referrerBonus_ = user.referrerBonus;\\n        id = user.id;\\n    }\\n\\n    function getUserDividends(\\n        address userAddress\\n    ) internal view returns (uint) {\\n        User storage user = users[userAddress];\\n\\n        uint totalDividends;\\n\\n        for (uint i; i < user.depositsLength; i++) {\\n            Deposit memory deposit = users[userAddress].deposits[i];\\n\\n            if (\\n                deposit.withdrawn < getMaxprofit(deposit) &&\\n                deposit.force == false\\n            ) {\\n                uint dividends = calculateDividents(deposit, user.checkpoint);\\n                totalDividends += dividends;\\n            }\\n        }\\n\\n        totalDividends += user.bonus;\\n\\n        return totalDividends;\\n    }\\n\\n    function calculateDividents(\\n        Deposit memory deposit,\\n        uint _userCheckpoint\\n    ) internal view returns (uint) {\\n        uint dividends;\\n        uint depositPercentRate = plan.percent;\\n\\n        uint checkDate = getDepsitStartDate(deposit);\\n\\n        if (checkDate < getlastActionDate(_userCheckpoint)) {\\n            checkDate = getlastActionDate(_userCheckpoint);\\n        }\\n        if (checkDate < deposit.checkpoint) {\\n            checkDate = deposit.checkpoint;\\n        }\\n\\n        dividends = (\\n            deposit.amount.mul(\\n                depositPercentRate.mul(block.timestamp.sub(checkDate))\\n            )\\n        ).div((PERCENTS_DIVIDER).mul(plan.cycle));\\n\\n        if (\\n            checkDate <= deposit.bonusEnd &&\\n            block.timestamp >= deposit.bonusStart\\n        ) {\\n            uint startBonus = deposit.bonusStart > checkDate\\n                ? deposit.bonusStart\\n                : checkDate;\\n            uint endBonus = deposit.bonusEnd < block.timestamp\\n                ? deposit.bonusEnd\\n                : block.timestamp;\\n            if (startBonus > endBonus) {\\n                startBonus = endBonus;\\n            }\\n            dividends += (\\n                deposit.amount.mul(\\n                    deposit.bonusRoi.mul(endBonus.sub(startBonus))\\n                )\\n            ).div((PERCENTS_DIVIDER).mul(plan.cycle));\\n        }\\n\\n        dividends += deposit.acumulated;\\n\\n        /*\\n\\t\\tif(dividends + _current > userMaxProfit) {\\n\\t\\t\\tdividends = userMaxProfit.sub(_current, \\\"max dividends\\\");\\n\\t\\t}\\n\\t\\t*/\\n\\n        if (deposit.withdrawn.add(dividends) > getMaxprofit(deposit)) {\\n            dividends = getMaxprofit(deposit).sub(deposit.withdrawn);\\n        }\\n\\n        return dividends;\\n    }\\n\\n    function updateDeposit(\\n        Deposit storage deposit,\\n        uint _userCheckpoint\\n    ) internal {\\n        require(\\n            deposit.withdrawn < getMaxprofit(deposit) && deposit.force == false,\\n            \\\"deposit is closed\\\"\\n        );\\n\\n        deposit.acumulated = calculateDividents(deposit, _userCheckpoint);\\n        deposit.checkpoint = block.timestamp;\\n    }\\n\\n    function getlastActionDate(\\n        uint _userCheckpoint\\n    ) internal view returns (uint) {\\n        uint checkpoint = _userCheckpoint;\\n        uint _date = getContracDate();\\n        if (_date > checkpoint) checkpoint = _date;\\n        return checkpoint;\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        uint size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function transferHandler(address to, uint amount) internal {\\n        if (amount > getContractBalance()) {\\n            amount = getContractBalance();\\n        }\\n        // if (to != feeWallet) {\\n        payable(to).transfer(amount);\\n        // }\\n        // else {\\n        //     uint toDev = amount.mul(defaultDevFee).div(PERCENTS_DIVIDER);\\n        //     payable(dAddress).transfer(toDev);\\n        //     payable(feeWallet).transfer(amount.sub(toDev));\\n        // }\\n    }\\n\\n    //1_000\\n    function payFeeInvest(uint amount) internal {\\n        uint toFee = amount.mul(fees.investFee).div(PERCENTS_DIVIDER);\\n        uint toDev = toFee.mul(30).div(100);\\n        transferHandler(feeDev, toDev);\\n        transferHandler(feeWallet, toFee - toDev);\\n        emit FeePayed(msg.sender, toFee);\\n    }\\n\\n    function payFees(uint amount) internal returns (uint) {\\n        uint toFee = amount.mul(fees.withdrawFee).div(PERCENTS_DIVIDER);\\n        uint toDev = toFee.mul(30).div(100);\\n        transferHandler(feeDev, toDev);\\n        transferHandler(feeWallet, toFee - toDev);\\n        emit FeePayed(msg.sender, toFee);\\n        return toFee;\\n    }\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/bnbBank/IBNB_Bank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\ninterface IBNB_Bank {\\n    struct Deposit {\\n        uint id;\\n        uint amount;\\n        uint acumulated;\\n        // uint amountBnb;\\n        uint withdrawn;\\n        uint start;\\n        uint checkpoint;\\n        uint bonusStart;\\n        uint bonusEnd;\\n        uint bonusRoi;\\n        bool force;\\n    }\\n\\n    struct FeeData {\\n        uint investFee;\\n        uint withdrawFee;\\n    }\\n\\n    struct Plan {\\n        uint cycle;\\n        uint percent;\\n        uint MAX_PROFIT;\\n    }\\n\\n    struct User {\\n        address user;\\n        address referrer;\\n        uint totalInvested;\\n        // uint totalInvestedBnb;\\n        uint totalWithdrawn;\\n        // uint tokenWithdrawn;\\n        uint depositsLength;\\n        uint bonus;\\n        uint reinvest;\\n        uint totalBonus;\\n        uint checkpoint;\\n        uint id;\\n        Deposit[] deposits;\\n        address[] referralsv0;\\n        address[] referralsv1;\\n        address[] referralsv2;\\n        address[] referralsv3;\\n        address[] referralsv4;\\n        uint[3] referrerCount;\\n        uint[3] referrerBonus;\\n    }\\n\\n    function getUser(address _user) external view returns (User memory);\\n\\n    function getDeposit(\\n        address _user,\\n        uint _index\\n    ) external view returns (Deposit memory);\\n\\n    function getAllDeposits(\\n        address _user\\n    ) external view returns (Deposit[] memory);\\n\\n    function getUserByindex(uint _index) external view returns (User memory);\\n\\n    function getAllUsers() external view returns (User[] memory);\\n\\n    function getAllInvestors() external view returns (address[] memory);\\n\\n    function getUsersByRange(\\n        uint _init,\\n        uint end\\n    ) external view returns (User[] memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ForceWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"investFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBNB_Bank.Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBNB_Bank.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerCount\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerBonus\",\"type\":\"uint256[3]\"}],\"internalType\":\"struct IBNB_Bank.User[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConstans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_refLenght\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_investMinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentsDivider\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_forceWithdrawPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContracDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBNB_Bank.Deposit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getNextUserAssignment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUsers_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daysFormdeploy\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReferrerBonus\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBNB_Bank.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerCount\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerBonus\",\"type\":\"uint256[3]\"}],\"internalType\":\"struct IBNB_Bank.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserByindex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBNB_Bank.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerCount\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerBonus\",\"type\":\"uint256[3]\"}],\"internalType\":\"struct IBNB_Bank.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentRefBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvest_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextAssignment_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOfDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer_\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerCount_\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerBonus_\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserDepositInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStart_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserPlans\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBNB_Bank.Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_init\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getUsersByRange\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBNB_Bank.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerCount\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrerBonus\",\"type\":\"uint256[3]\"}],\"internalType\":\"struct IBNB_Bank.User[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MAX_PROFIT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeWallet\",\"type\":\"address\"}],\"name\":\"setFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"invest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMinInvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"_referralPercents\",\"type\":\"uint256[3]\"}],\"name\":\"setReferralPercents\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setReinvestStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BNB_Bank", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000ce3b0fdfcdc46d6f3545d1d171a604b511903dbc000000000000000000000000ea9ad84ce6982d68be6bd7f12c75e5bfbb88ec5a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}