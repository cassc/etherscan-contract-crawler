{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.16;\r\n\r\ninterface IERC20Token {\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV // Deprecated in v4.8\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n    }\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    ) internal pure returns (address, RecoverError) {\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs &\r\n            bytes32(\r\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n            );\r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        if (\r\n            uint256(s) >\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n        ) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function toEthSignedMessageHash(\r\n        bytes32 hash\r\n    ) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n            );\r\n    }\r\n}\r\n\r\ncontract Managed {\r\n  mapping(address => bool) public managers;\r\n  modifier onlyManagers() {\r\n    require(managers[msg.sender] == true, \"Caller is not manager\");\r\n    _;\r\n  }\r\n  constructor() {\r\n    managers[msg.sender] = true;\r\n  }\r\n  function setManager(address _wallet, bool _manager) public onlyManagers {\r\n    require(_wallet != msg.sender, \"Not allowed\");\r\n    managers[_wallet] = _manager;\r\n  }\r\n}\r\n\r\ncontract LiquidityBalancer is Managed {\r\n  bool multiSign;\r\n  IERC20Token token;\r\n  address lWallet;\r\n\r\n  struct LiquidityP {\r\n    uint256 timeStamp;\r\n    uint256 serviceId;\r\n    uint256 amount;\r\n    address executer;\r\n    address approver;\r\n    address receiver;\r\n  }\r\n\r\n  struct LiquidityR {\r\n    uint256 timeStamp;\r\n    uint256 serviceId;\r\n    uint256 amount;\r\n    address sender;\r\n  }\r\n\r\n  LiquidityP[] public providedLiquidity;\r\n  LiquidityR[] public receivedLiquidity;\r\n\r\n  constructor () {\r\n    managers[0x00d6E1038564047244Ad37080E2d695924F8515B] = true;\r\n    token = IERC20Token(0x6Ae9701B9c423F40d54556C9a443409D79cE170a);\r\n    lWallet = 0xf7A9F6001ff8b499149569C54852226d719f2D76;\r\n  }\r\n\r\n  function provideLiquidity(uint256 _serviceId, uint256 _amount, address _receiver) public onlyManagers {\r\n    require(!multiSign, \"Multisignature is enabled\");\r\n    _provideLiquidity(_serviceId, _amount, _receiver, msg.sender);\r\n  }\r\n\r\n  function verifySignature(bytes32 _taskHash, bytes memory _sig) private view returns(address) {\r\n    address mSigner = ECDSA.recover(ECDSA.toEthSignedMessageHash(_taskHash), _sig);\r\n    require(managers[mSigner] == true, \"Invalid signer\");\r\n    return mSigner;\r\n  }\r\n  function provideLiquidityMS(uint256 _serviceId, uint256 _amount, address _receiver, bytes memory signature) public onlyManagers {\r\n    bytes32 taskHash = keccak256(abi.encode(_serviceId, _amount, _receiver));\r\n    address a = verifySignature(taskHash, signature);\r\n    require (a!=msg.sender, \"Signature must be from another wallet\");\r\n    _provideLiquidity(_serviceId, _amount, _receiver, a);\r\n  }\r\n\r\n  function _provideLiquidity(uint256 _serviceId, uint256 _amount, address _receiver, address _approver) private {\r\n    require(token.transferFrom(lWallet, _receiver, _amount), \"ERC20 Transfer error\");\r\n    LiquidityP memory l = LiquidityP(block.timestamp, _serviceId, _amount, msg.sender, _approver, _receiver);\r\n    providedLiquidity.push(l);\r\n  }\r\n   \r\n  function receiveLiquidity(uint256 _serviceId, uint256 _amount, uint256 _txTimeStamp, address _sender) public onlyManagers {\r\n    LiquidityR memory l = LiquidityR(_txTimeStamp, _serviceId, _amount, _sender);\r\n    receivedLiquidity.push(l);\r\n  }\r\n\r\n  function pCount() public view returns(uint256) {\r\n    return providedLiquidity.length;\r\n  }\r\n\r\n  function rCount() public view returns(uint256) {\r\n    return receivedLiquidity.length;\r\n  }\r\n\r\n  function changeLWallet(address _wallet) public onlyManagers {\r\n    lWallet = _wallet;\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"changeLWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_serviceId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"provideLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_serviceId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"provideLiquidityMS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"providedLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"executer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_serviceId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_txTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"receiveLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"receivedLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_manager\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LiquidityBalancer", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cee5d72555ed6e100c39e89963f7b083267ec5422838f6340879f6868ebac4bb"}