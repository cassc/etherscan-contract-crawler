{"SourceCode": "pragma solidity ^0.8.18;\r\n// SPDX-License-Identifier: Unlicensed\r\n// [smart contract developer]: Mister Whitestake - https://t.me/mrwhitestake\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function setOwner(address _newOwner) internal {\r\n        _owner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n \r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n  \r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity); \r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract SELLFIE is Context, IERC20, Ownable {\r\n    using Address for address;\r\n    using Address for address payable;\r\n\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\r\n    address constant WBNB                            = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;  \r\n    address constant DEAD                            = 0x000000000000000000000000000000000000dEaD;\r\n    address constant ZERO                            = 0x0000000000000000000000000000000000000000;\r\n    address public   CURRENCY                        = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public   adminZero                       = 0x33cF975497C4E4b095B6912539c657edcCE9956d; \r\n    address public   adminOne                        = 0x374f5b0d0559B1Af57F99caAf49871013C0dC9aA;\r\n    bool    public   currencyStatus                  = true;\r\n\r\n    // MAIN WALLET ADDRESSES\r\n    address private PROJECT                          = 0x272c5B48a5b4d27cb498DFAf0aeBa80B0621dA24;\r\n    address private MKT                              = 0x374f5b0d0559B1Af57F99caAf49871013C0dC9aA;\r\n    address private CLIENT                           = 0xc0B7965dAB2d42B38c54240E5c69f821Bb73625f;\r\n    address private SPONSOR                          = 0x374f5b0d0559B1Af57F99caAf49871013C0dC9aA; \r\n    address private PRESALE_ADDRESS                  = 0x374f5b0d0559B1Af57F99caAf49871013C0dC9aA;\r\n    address private SPONSOR_ADMIN                    = 0x374f5b0d0559B1Af57F99caAf49871013C0dC9aA;\r\n\r\n    // TOKEN GLOBAL VARIABLES\r\n    string constant _name                            = \"Sellfie\";\r\n    string constant _symbol                          = \"SFE\";\r\n    uint8  constant _decimals                        = 18;\r\n    uint256         _totalSupply                     = 200000000 * 10 ** _decimals;\r\n\r\n    // INITIAL MAX TRANSACTION AMOUNT\r\n    uint256 public  _maxBuyAmount                    = 200000 * 10 ** _decimals;\r\n    bool    public  maxBuyEnabled                    = false;\r\n\r\n    // INITIAL MAX WALLET HOLDING SET TO 100%\r\n    uint256 public _maxWalletToken                   = _totalSupply;\r\n\r\n    // MAPPINGS\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _allowances;\r\n    mapping (address => bool) public                   isFeeExempt;\r\n    mapping (address => bool) public                   liquidityAddress;\r\n    mapping (address => bool) public                   _isBlacklisted;\r\n\r\n    // BUY & TRANSFER FEE\r\n    uint256 constant INITIAL_TRANSFER_TAX_RATE       = 1200; // THIS IS ALSO BUY FEE\r\n    uint256 public   transferTaxRate                 = 1200;\r\n    bool    public   takeFeeIfNotLiquidity           = false;\r\n\r\n    // SELL FEE & DISTRIBUTION SETTINGS\r\n    uint256 public projectFee                        = 600;\r\n    uint256 public marketingFee                      = 0;\r\n    uint256 public reserveFee                        = 0;\r\n    uint256 public sponsorfee                        = 0;\r\n    uint256 public liquidityFee                      = 300;\r\n    uint256 public clientFee                         = 300;\r\n    // SETS UP TOTAL FEE\r\n    uint256 public totalFee = (projectFee + marketingFee + liquidityFee + clientFee + reserveFee + sponsorfee);\r\n\r\n    // MAX TOTAL FEE SHOULD BE REASONABLE.\r\n    // ATTENTION: THIS CANNOT BE CHANGED AFTERWARDS!\r\n    uint256 public  constant MAX_TOTAL_FEE           = 2000;\r\n    uint256 private constant MAX_SPONSOR_FEE         = 2000;\r\n\r\n    // FEE DENOMINATOR CANNOT BE CHANGED.\r\n    uint256 public constant feeDenominator           = 10000;\r\n    // SET UP FEE RECEIVERS\r\n    address public   projectFeeReceiver              = PROJECT;\r\n    address public   marketingFeeReceiver            = MKT;\r\n    address public   clientReceiver                    = CLIENT;\r\n    address public   sponsorfeeReceiver              = SPONSOR;\r\n    address public   reserveFeeReceiver              = MKT;\r\n    address public   autoLiquidityReceiver           = MKT;\r\n    \r\n    bool private swapping;\r\n\r\n\r\n    // SWITCH TRADING\r\n    bool    public   tradingOpen                     = false;\r\n    bool    private  launch                          = true;\r\n    uint256 private  launchTime                      = 0;\r\n\r\n    // MULTI-SIGNATURE GLOBAL VARIABLES\r\n    uint256 public multiSignatureID                  = 0;\r\n    uint256 public multiSignatureDeadline            = 0;\r\n    uint256 public multiSignatureInterval            = 0;\r\n    address public multiSignatureAddress             = ZERO;\r\n\r\n    mapping (address => bool)    private               _auth;\r\n    \r\n    // MULTI-SIGNATURE TEMPORARY VARIABLES\r\n    uint256 private _tmpMaxTxAmount                  = 0;\r\n    uint256 private _tmpTransferTaxRate              = 0;\r\n    uint256 private _tmpLiquidityFee                 = 0;\r\n    uint256 private _tmpMarketingFee                 = 0;\r\n    uint256 private _tmpProjectFee                   = 0;\r\n    uint256 private _tmpSponsorfee                   = 0;\r\n    uint256 private _tmpReserveFee                   = 0;\r\n    uint256 private _tmpCLIENTFee                    = 0;\r\n    uint256 private _tmpTotalFee                     = 0;\r\n    uint256 private _tmpSwapThreshold                = 0;\r\n    uint256 private _tmpMaxWalletPercent             = 0;\r\n    uint256 private _tmpClearStuckBalance            = 0;\r\n    uint256 private _tmpMultiSingnatureCD            = 0;\r\n    bool    private _tmpIsFeeExempt                  = false;\r\n    bool    private _tmpSellAddressExempt            = false;\r\n    bool    private _tmpSwapEnabled                  = false;\r\n    bool    private _tmpTakeFeeIfNotLiquidity        = false;\r\n    bool    private _tmpMaxBuyEnabled                = false;\r\n    address private _tmpFeeExemptAddress             = ZERO; \r\n    address private _tmpSellAddress                  = ZERO;\r\n    address private _tmpProjectReceiver              = ZERO;\r\n    address private _tmpSponsorReceiver              = ZERO;\r\n    address private _tmpReserveReceiver              = ZERO;\r\n    address private _tmpLiquidityReceiver            = ZERO;\r\n    address private _tmpMarketingReceiver            = ZERO;\r\n    address private _tmpAdminZero                    = ZERO;\r\n    address private _tmpAdminOne                     = ZERO;\r\n    address private _tmpOwnershipAddress             = ZERO;\r\n    address private _tmpForceResetAddress            = ZERO;\r\n    address private _tmpWithdrawTokenAddr            = ZERO;\r\n\r\n    event AdminTokenRecovery(address tokenAddress, uint256 tokenAmount);     \r\n\r\n    // COOLDOWN & TIMER\r\n    mapping (address => uint) private                  cooldownTimer;\r\n    bool public buyCooldownEnabled                   = true;\r\n    uint8 public cooldownTimerInterval               = 15;\r\n\r\n    // TOKEN SWAP SETTINGS\r\n    bool           inSwap;\r\n    bool    public swapEnabled                       = true;\r\n    uint256 public swapThreshold                     = _totalSupply / 10000 * 1; // 0,01%\r\n    uint256 public totalRealized                     = 0;\r\n    \r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\r\n        \r\n    constructor () {\r\n        require(totalFee <= MAX_TOTAL_FEE,\"totalFee must be reasonable. Check MAX_TOTAL_FEE\");\r\n        require(MAX_TOTAL_FEE < feeDenominator,\"MAX_TOTAL_FEE must be reasonable according to feeDenominator.\");\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        address pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n        uniswapV2Router                              = _uniswapV2Router;\r\n        uniswapV2Pair                                = pair;\r\n        _auth[DEAD]                                  = true;\r\n        _auth[ZERO]                                  = true;\r\n        _auth[owner()]                               = true;\r\n        _auth[adminZero]                             = true;\r\n        _auth[adminOne]                              = true;\r\n        _auth[PRESALE_ADDRESS]                       = true;\r\n        _auth[marketingFeeReceiver]                  = true;\r\n        _auth[projectFeeReceiver]                    = true;\r\n        _auth[address(this)]                         = true;\r\n        isFeeExempt[owner()]                         = true;\r\n        isFeeExempt[address(this)]                   = true;\r\n        isFeeExempt[MKT]                             = true;\r\n        isFeeExempt[PROJECT]                         = true;\r\n        isFeeExempt[SPONSOR]                         = true;\r\n        liquidityAddress[uniswapV2Pair]              = true;\r\n\r\n        // INITIAL DISTRIBUTION\r\n        _balances[_msgSender()]                      = _totalSupply;\r\n        emit Transfer(address(0), _msgSender(), _totalSupply);\r\n    }\r\n\r\n    function name() public pure returns (string memory) { return _name; }\r\n\r\n    function symbol() public pure returns (string memory) { return _symbol; }\r\n\r\n    function decimals() public pure returns (uint8) { return _decimals; }\r\n\r\n    function totalSupply() public view override returns (uint256) { return _totalSupply; }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) { return _allowances[owner][spender]; }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\r\n        return true;\r\n    }\r\n    \r\n     //to recieve ETH from uniswapV2Router when swaping\r\n    receive() external payable {}\r\n\r\n    // FALLBACK FUNCTION. DO NOT TRY TO FOOL MY SMART CONTRACT\r\n    uint n = 0;\r\n    fallback() external payable {\r\n        n = 0;\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        // GLOBAL REQUIREMENTS\r\n        require(!_isBlacklisted[sender], \"Blacklisted SENDER\");\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        // TRADING STATUS\r\n        checkTradingStatus(sender, recipient);\r\n        // MAX WALLET SETTINGS\r\n        checkMaxWallet(recipient, amount);\r\n        // COOLDOWN BETWEEN BUYS\r\n        checkCoolDown(sender, recipient);\r\n        // BUY LIMIT\r\n        checkMaxBuy(sender, recipient, amount);\r\n        // SHOULD I SWAP BACK?\r\n        shouldSwapBack(sender, recipient);\r\n        // SETS AMOUNT TO BE RECEIVED\r\n        setAmountReceived(sender, recipient, amount); \r\n    } \r\n    // SETS RECEIVED AMOUNT\r\n    function setAmountReceived(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, recipient, amount) : amount;\r\n        // EXCHANGE TOKENS\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amountReceived;\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return amountReceived;\r\n    }  \r\n    // SHOULD I SWAP BACK?\r\n    function shouldSwapBack(address from, address to) internal {\r\n        if (balanceOf(address(this)) >= swapThreshold \r\n        && !swapping && !liquidityAddress[from] \r\n        && from != owner() \r\n        && to != owner()) {\r\n            if (liquidityAddress[to]) {\r\n                swapping = true;\r\n                swapBack();\r\n                swapping = false;\r\n            }\r\n        }\r\n    }   \r\n    // CHECKS COOLDOWN BETWEEN BUYS\r\n    function checkCoolDown(address sender, address recipient) internal {\r\n        if (liquidityAddress[sender] &&\r\n            buyCooldownEnabled &&\r\n            !_auth[recipient]) {\r\n            require(cooldownTimer[recipient] < block.timestamp,\"Please wait for cooldown between buys\");\r\n            cooldownTimer[recipient] = block.timestamp + cooldownTimerInterval;\r\n        }\r\n    }\r\n    // CHECKS TRADING STATUS\r\n    function checkTradingStatus(address sender, address recipient) internal view {\r\n        if(\r\n            sender != owner() \r\n            && sender != adminZero \r\n            && sender != adminOne \r\n            && recipient != owner() \r\n            && recipient != adminZero \r\n            && recipient != adminOne\r\n            && !_auth[sender]\r\n            && !_auth[recipient]) {\r\n            require(tradingOpen,\"Trading not open yet\");\r\n        }\r\n    }\r\n    // CHECKS MAX BUY\r\n    function checkMaxBuy(address sender, address recipient, uint256 amount) internal view {\r\n        if (liquidityAddress[sender] && maxBuyEnabled) {\r\n            if (!_auth[recipient]) { require(amount <= _maxBuyAmount,\"maxBuy Limit Exceeded\"); }\r\n        }\r\n    }\r\n    // CHECKS MAX WALLET\r\n    function checkMaxWallet(address recipient, uint256 amount) internal view {\r\n        if (!_auth[recipient]) {\r\n            uint256 heldTokens = balanceOf(recipient);\r\n            require((heldTokens + amount) <= _maxWalletToken,\"Total Holding is currently limited, recipient cant hold that much.\");\r\n        }\r\n    }\r\n    function resetTotalFees() internal {\r\n        totalFee = liquidityFee + marketingFee + projectFee + sponsorfee + reserveFee;\r\n    }\r\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        // RESETS BUY FEE AFTER LAUNCHTIME\r\n        if (block.timestamp >= launchTime && launchTime != 0) {\r\n            transferTaxRate = INITIAL_TRANSFER_TAX_RATE;\r\n            launchTime = 0;\r\n        }\r\n        if (   !liquidityAddress[sender]\r\n            && !liquidityAddress[recipient]\r\n            && sender != address(uniswapV2Router)\r\n            && recipient != address(uniswapV2Router)\r\n            && msg.sender != address(uniswapV2Router)\r\n            && !takeFeeIfNotLiquidity) {\r\n            return amount;\r\n        }\r\n        uint256 feeAmount   = 0;\r\n        address feeReceiver = address(this);\r\n        bool    feeTaken    = false;\r\n        if (!feeTaken && liquidityAddress[recipient] && totalFee > 0) {\r\n            feeAmount = (amount * totalFee / feeDenominator);\r\n        }\r\n        else if (!feeTaken) {\r\n            feeAmount = (amount * transferTaxRate / feeDenominator);\r\n        }\r\n        if (feeAmount > 0) {\r\n            _balances[feeReceiver] += feeAmount;\r\n            emit Transfer(sender, feeReceiver, feeAmount);\r\n            return (amount - feeAmount);\r\n        } else {\r\n            return amount;\r\n        }\r\n    }\r\n    // SHOULD WE TAKE ANY TRANSACTION FEE ON THIS?\r\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n         if (!isFeeExempt[sender] && !isFeeExempt[recipient]) {\r\n             return true;\r\n         }\r\n         else { return false; }\r\n    } \r\n    // BASIC TRANSFER METHOD\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }      \r\n    // SWITCH TRADING\r\n    function tradingStatus(bool _status, uint256 _time, uint256 _tax) public onlyOwner {\r\n        require(_status, \"You cannot disable trading.\");\r\n        if (launch) {\r\n            require(_time >= (block.timestamp + 60), \"Please set time to a future date.\");\r\n            transferTaxRate = _tax;\r\n            launchTime = _time;\r\n            launch = false;\r\n        } \r\n        tradingOpen = _status;\r\n    }      \r\n    // SET CURRENCY\r\n    function setCurrency(address _currencyAddress, bool _status) public onlyOwner {\r\n        require(CURRENCY != _currencyAddress || currencyStatus != _status, \"!SAME_CONFIG\");\r\n        CURRENCY = _currencyAddress;\r\n        currencyStatus = _status;\r\n    }\r\n    function authorize(address _address, bool _status) external onlyOwner {\r\n        require(_auth[_address] != _status, \"User is already set in that condition\");\r\n        _auth[_address] = _status;\r\n    }\r\n\r\n    function swapBack() private {\r\n        // SETS UP AMOUNT THAT NEEDS TO BE SWAPPED\r\n        uint256 totalFeeWithoutReserve = (totalFee - reserveFee);\r\n        uint256 amountToReserve        = balanceOf(address(this)) * reserveFee  / totalFee;\r\n        uint256 amountToSponsor        = balanceOf(address(this)) * sponsorfee  / totalFee;\r\n        // SENDS TOKENS TO RESERVE WALLET IF THERE IS ANY TO BE SENT\r\n        if (reserveFee > 0 && balanceOf(address(this)) >= amountToReserve) {\r\n            _basicTransfer(address(this), reserveFeeReceiver, amountToReserve);\r\n        }\r\n        // SENDS TOKENS TO SPONSOR WALLET IF THERE IS ANY TO BE SENT\r\n        if (sponsorfee > 0 && balanceOf(address(this)) >= amountToReserve) {\r\n            _basicTransfer(address(this), sponsorfeeReceiver, amountToSponsor);\r\n        }\r\n        uint256 amount = (balanceOf(address(this)) - amountToReserve - amountToSponsor);\r\n        // CHECKS IF THERE IS ANY FEE THAT NEEDS TOKENS TO BE SWAPPED\r\n        if (totalFeeWithoutReserve > 0 && balanceOf(address(this)) >= amount) {\r\n            // SWAPBACK SETTINGS\r\n            uint256 amountToLiquify = (amount * liquidityFee / totalFee / 2);\r\n            uint256 amountToSwap = (amount - amountToLiquify);\r\n            uint256 amountBNB = swapTokensForEth(amountToSwap);\r\n            if (amountBNB > 0) {\r\n                // SETTING UP TOTAL FEE AMOUNT IN TOKENS\r\n                uint256 totalBNBFee = (liquidityFee + marketingFee + projectFee + clientFee);\r\n                // SETTING UP WHO IS WHO HERE\r\n                uint256 amountBNBLiquidity = (amountBNB * liquidityFee / totalBNBFee / 2);\r\n                uint256 amountBNBProject   = (amountBNB * projectFee   / totalBNBFee);\r\n                uint256 amountCLIENTFee    = (amountBNB * clientFee       / totalBNBFee);\r\n                // PAYS UP CLIENT WALLET IF THERE IS ANY TO BE PAID\r\n                if (amountCLIENTFee > 0 && address(this).balance >= amountCLIENTFee) {\r\n                    if (!currencyStatus) {\r\n                        payable(clientReceiver).sendValue((amountCLIENTFee));\r\n                    } else {\r\n                        buy(amountCLIENTFee, CURRENCY, clientReceiver);\r\n                    }\r\n                }\r\n                // PAYS UP PROJECT WALLET IF THERE IS ANY TO BE PAID\r\n                if (amountBNBProject > 0 && address(this).balance >= amountBNBProject) {\r\n                    if (!currencyStatus) {\r\n                        payable(projectFeeReceiver).sendValue((amountBNBProject));\r\n                    } else {\r\n                        buy(amountBNBProject, CURRENCY, projectFeeReceiver);\r\n                    }\r\n                }\r\n                // ADDS LIQUIDITY IF THERE IS ANY TO BE ADDED\r\n                if(amountBNBLiquidity > 0 \r\n                && address(this).balance >= amountBNBLiquidity \r\n                && balanceOf(address(this)) >= amountToLiquify) {\r\n                    addLiquidity(amountToLiquify, amountBNBLiquidity);\r\n                }\r\n                // PAYS UP MARKETING WALLET WITH ALL BNB LEFT\r\n                if (address(this).balance >= 0) {\r\n                    // FUNDS SHOULD NOT BE KEPT IN THE CONTRACT\r\n                    payable(marketingFeeReceiver).sendValue(address(this).balance);      \r\n                }                    \r\n            }            \r\n        }    \r\n    }\r\n\r\n    function setSponsor(address _sponsorReceiver, address _sponsorAdmin, uint256 _sponsorFee) external {\r\n        require(msg.sender == SPONSOR_ADMIN, \"You are not authorized\");\r\n        require(_sponsorFee >= 0 && _sponsorFee <= MAX_SPONSOR_FEE, \"Check MAX_SPONSOR_FEE\");\r\n        sponsorfeeReceiver = _sponsorReceiver;\r\n        SPONSOR_ADMIN = _sponsorAdmin;\r\n        sponsorfee = _sponsorFee;\r\n        resetTotalFees();\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private returns (uint256) {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // make the swap\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        totalRealized += address(this).balance;\r\n        return (address(this).balance);\r\n    }\r\n    \r\n    function buy(uint256 _amountToLiquify, address _tokenAddress, address _receiver) private {\r\n        require(address(this).balance >= _amountToLiquify, \"INSUFFICIENT_BNB_BALANCE\");\r\n        //SET TRADING CONFIG\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = _tokenAddress;\r\n\r\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: _amountToLiquify\r\n        }(0, path, _receiver, block.timestamp);\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // add the liquidity\r\n        (,uint256 ethFromLiquidity,) = uniswapV2Router.addLiquidityETH {value: ethAmount} (\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            autoLiquidityReceiver,\r\n            block.timestamp\r\n        );\r\n        \r\n        if (ethAmount - ethFromLiquidity > 0) {\r\n            ethAmount = 0;\r\n        }\r\n    }\r\n    ////    MULTI-SIGNATURE FUNCTIONS START\r\n    function resetMultiSignature() internal {\r\n        multiSignatureID            = 0;\r\n        multiSignatureDeadline      = 0;\r\n        _tmpMaxTxAmount             = 0;\r\n        _tmpTransferTaxRate         = 0;\r\n        _tmpLiquidityFee            = 0;\r\n        _tmpMarketingFee            = 0;\r\n        _tmpProjectFee              = 0;\r\n        _tmpSponsorfee              = 0;\r\n        _tmpReserveFee              = 0;\r\n        _tmpTotalFee                = 0;\r\n        _tmpSwapThreshold           = 0;\r\n        _tmpMaxWalletPercent        = 0;\r\n        _tmpClearStuckBalance       = 0;\r\n        multiSignatureAddress       = ZERO;\r\n        _tmpFeeExemptAddress        = ZERO; \r\n        _tmpSellAddress             = ZERO;\r\n        _tmpProjectReceiver         = ZERO;\r\n        _tmpSponsorReceiver         = ZERO;\r\n        _tmpLiquidityReceiver       = ZERO;\r\n        _tmpMarketingReceiver       = ZERO;\r\n        _tmpAdminZero               = ZERO;\r\n        _tmpAdminOne                = ZERO;\r\n        _tmpOwnershipAddress        = ZERO;\r\n        _tmpForceResetAddress       = ZERO;\r\n        _tmpWithdrawTokenAddr       = ZERO;\r\n        _tmpIsFeeExempt             = false;\r\n        _tmpSellAddressExempt       = false;\r\n        _tmpSwapEnabled             = false;\r\n        _tmpTakeFeeIfNotLiquidity   = false;\r\n        _tmpMaxBuyEnabled           = false;\r\n    }\r\n    function blackList(address _address, bool _enabled) external onlyOwner {\r\n        require(_isBlacklisted[_address] != _enabled, \"Address is already set in that condition\");\r\n        _isBlacklisted[_address] = _enabled;\r\n    }\r\n    function checkAuth(address _msgSender) internal view {\r\n        require(_msgSender == adminZero || _msgSender == adminOne || _msgSender == owner(), \"You are not authorized\");\r\n    }\r\n\r\n    function multiSignatureRequirements(uint256 _id, address _address, bool _checkID) internal view {\r\n        if (_checkID) { \r\n            require(multiSignatureID == _id, \"Invalid multiSignatureID\"); \r\n            require((multiSignatureDeadline - 15) < block.timestamp, \"MultiSignatureDeadline hasnt been reached\");\r\n        }\r\n        require(multiSignatureAddress != _address, \"You need authorization from the other admins\");\r\n    }\r\n\r\n    function multiSignatureTrigger(uint256 _id, address _admin) internal {\r\n        require(multiSignatureAddress == ZERO, \"Multi-signature is already on. You can try force resetting.\");\r\n        multiSignatureID = _id;\r\n        multiSignatureAddress = _admin;\r\n        multiSignatureDeadline = block.timestamp + multiSignatureInterval;\r\n    }\r\n\r\n    function setMaxBuy(uint256 amount, bool _enabled) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 1;\r\n        // GLOBAL REQUIREMENTS\r\n        require(amount > 0 && amount <= (_totalSupply), \"Invalid amount. Must be reasonable.\");\r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMaxTxAmount = amount;\r\n            _tmpMaxBuyEnabled = _enabled;\r\n        } else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                if (msg.sender != multiSignatureAddress) {\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpMaxTxAmount == amount && _tmpMaxBuyEnabled == _enabled, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                _maxBuyAmount = amount;\r\n                maxBuyEnabled = _enabled;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();            \r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 2;\r\n        // GLOBAL REQUIREMENTS\r\n        checkAuth(msg.sender);\r\n        require(isFeeExempt[holder] != exempt, \"Address is already set in that condition\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpIsFeeExempt = exempt;\r\n            _tmpFeeExemptAddress = holder;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tmpFeeExemptAddress == holder && _tmpIsFeeExempt == exempt, \"Invalid parameters\");\r\n            //NICE JOB. YOU DID IT!\r\n            isFeeExempt[holder] = exempt;\r\n            // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n\r\n    function setFees(uint256 _liquidityFee, uint256 _marketingFee, uint256 _projectFee, uint256 _clientFee, uint256 _reserveFee) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 5;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n         _tmpTotalFee = (_liquidityFee + _marketingFee + _projectFee + sponsorfee + _reserveFee + clientFee); \r\n        require(_tmpTotalFee <= MAX_TOTAL_FEE, \"totalFee cant be higher than MAX_TOTAL_FEE\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpLiquidityFee = _liquidityFee;\r\n            _tmpMarketingFee = _marketingFee;\r\n            _tmpProjectFee   = _projectFee;\r\n            _tmpReserveFee   = _reserveFee;\r\n            _tmpCLIENTFee    = _clientFee;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(\r\n                   _tmpLiquidityFee == _liquidityFee\r\n                && _tmpMarketingFee == _marketingFee\r\n                && _tmpProjectFee   == _projectFee\r\n                && _tmpReserveFee   == _reserveFee\r\n                && _tmpCLIENTFee    == _clientFee,\r\n                \"Invalid parameters\"\r\n            );\r\n            // NICE JOB. YOU DID IT!\r\n            liquidityFee = _liquidityFee;\r\n            marketingFee = _marketingFee;\r\n            projectFee   = _projectFee;\r\n            reserveFee   = _reserveFee;\r\n            clientFee    = _clientFee;\r\n            totalFee     = _tmpTotalFee;\r\n            // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n\r\n    function setTransferTaxRate(uint256 _transferTaxRate, bool _takeFeeIfNotLiquidityAddress) external {   \r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 6;\r\n        // GLOBAL REQUIREMENTS\r\n        checkAuth(msg.sender); \r\n        require(_transferTaxRate <= MAX_TOTAL_FEE, \"must not be higher than MAX_TOTAL_FEE\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpTransferTaxRate = _transferTaxRate;\r\n            _tmpTakeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tmpTransferTaxRate == _transferTaxRate\r\n                    && _tmpTakeFeeIfNotLiquidity == _takeFeeIfNotLiquidityAddress, \"Invalid parameters\");\r\n            \r\n            // NICE JOB. YOU DID IT!\r\n            transferTaxRate = _transferTaxRate;\r\n            takeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n            // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n\r\n    function setSellingFeeAddress(address _liquidityAddress, bool _enabled) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 7;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n        require(liquidityAddress[_liquidityAddress] != _enabled, \"User is already set in that condition\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpSellAddress = _liquidityAddress;\r\n            _tmpSellAddressExempt = _enabled;\r\n        }\r\n           else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tmpSellAddress == _liquidityAddress && _tmpSellAddressExempt == _enabled, \"Invalid parameters\");\r\n\r\n            // NICE JOB. YOU DID IT!\r\n            liquidityAddress[_liquidityAddress] = _enabled;\r\n            // RESET AFTER SUCCESFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n\r\n    function setFeeReceivers(address _marketingFeeReceiver, address _projectFeeReceiver, address _reserveFeeReceiver, address _CLIENTFeeReceiver, address _autoLiquidityReceiver) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 8;\r\n        // GLOBAL REQUIREMENTS    \r\n        checkAuth(msg.sender);\r\n        require(\r\n               _marketingFeeReceiver != ZERO\r\n            && _marketingFeeReceiver != DEAD\r\n            && _marketingFeeReceiver != uniswapV2Pair, \"Invalid marketingFeeReceiver\");\r\n            \r\n        require(\r\n               _projectFeeReceiver != ZERO\r\n            && _projectFeeReceiver != DEAD\r\n            && _projectFeeReceiver != uniswapV2Pair, \"Invalid projectFeeReceiver\");\r\n\r\n        require(\r\n               _reserveFeeReceiver != ZERO\r\n            && _reserveFeeReceiver != uniswapV2Pair, \"Invalid reserveFeeReceiver\");\r\n\r\n        require(\r\n               _CLIENTFeeReceiver != ZERO\r\n            && _CLIENTFeeReceiver != DEAD\r\n            && _CLIENTFeeReceiver != uniswapV2Pair, \"Invalid CLIENTFeeReceiver\");\r\n        \r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMarketingReceiver = _marketingFeeReceiver;\r\n            _tmpProjectReceiver   = _projectFeeReceiver;\r\n            _tmpReserveReceiver   = _reserveFeeReceiver;\r\n            _tmpLiquidityReceiver = _autoLiquidityReceiver;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tmpMarketingReceiver == _marketingFeeReceiver\r\n                && _tmpProjectReceiver    == _projectFeeReceiver\r\n                && _tmpReserveReceiver    == _reserveFeeReceiver\r\n                && _tmpLiquidityReceiver  == _autoLiquidityReceiver,\r\n                \"Invalid parameters\"\r\n            );\r\n            marketingFeeReceiver  = _marketingFeeReceiver;\r\n            projectFeeReceiver    = _projectFeeReceiver;\r\n            reserveFeeReceiver    = _reserveFeeReceiver;\r\n            autoLiquidityReceiver = _autoLiquidityReceiver;\r\n\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 9;\r\n        // GLOBAL REQUIREMENTS   \r\n        checkAuth(msg.sender);\r\n        require(_amount <= (totalSupply() / 1000 * 5), \"MAX_SWAPBACK amount cannot be higher than half percent\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpSwapEnabled = _enabled;\r\n            _tmpSwapThreshold = _amount;\r\n        }   else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tmpSwapEnabled == _enabled && _tmpSwapThreshold == _amount, \"Invalid parameters\");\r\n\r\n            // NICE JOB. YOU DID IT\r\n            swapEnabled = _enabled;\r\n            swapThreshold = _amount;\r\n\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n    \r\n    function setAdmins(address _adminZero, address _adminOne) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 10;\r\n        // GLOBAL REQUIREMENTS       \r\n        checkAuth(msg.sender);\r\n        require(\r\n            _adminZero != ZERO \r\n            && _adminZero != DEAD \r\n            && _adminZero != address(this)\r\n            && _adminOne != ZERO \r\n            && _adminOne != DEAD \r\n            && _adminOne != address(this), \"Invalid address\"\r\n        );\r\n        require(_adminZero != _adminOne,\"Duplicated addresses\");\r\n\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpAdminZero = _adminZero;\r\n            _tmpAdminOne = _adminOne;\r\n        }   else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tmpAdminZero == _adminZero && _tmpAdminOne == _adminOne, \"Invalid parameters\");\r\n\r\n            // NICE JOB. YOU DID IT!\r\n            adminZero = _adminZero;\r\n            adminOne = _adminOne;\r\n\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n\r\n    function renounceContract() external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 11;\r\n        // GLOBAL REQUIREMENTS     \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpOwnershipAddress = DEAD;\r\n            _tmpAdminZero = DEAD;\r\n            _tmpAdminOne = DEAD;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(\r\n                _tmpOwnershipAddress == DEAD \r\n                && _tmpAdminZero == DEAD \r\n                && _tmpAdminOne == DEAD, \"Invalid parameters\");\r\n            // NICE JOB. YOU DID IT!\r\n            adminZero = DEAD;\r\n            adminOne = DEAD;\r\n            setOwner(DEAD);\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n        \r\n    }\r\n    /**\r\n     * Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address adr) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 12;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n        require(\r\n            adr != ZERO \r\n            && adr != DEAD \r\n            && adr != address(this)\r\n            && adr != adminZero\r\n            && adr != adminOne, \"Invalid address\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpOwnershipAddress = adr;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tmpOwnershipAddress == adr, \"Invalid parameters\");\r\n            // NICE JOB. YOU DID IT!\r\n            address _previousOwner = owner();\r\n            setOwner(adr);\r\n            emit OwnershipTransferred(_previousOwner, adr);\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n        \r\n    }\r\n    function setMaxWalletPercent(uint256 maxWallPercent) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 13;\r\n        // GLOBAL REQUIREMENTS       \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMaxWalletPercent = maxWallPercent;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(maxWallPercent > 0 && maxWallPercent <= 100, \"Invalid maxWallPercent\");\r\n            require(_tmpMaxWalletPercent == maxWallPercent, \"Invalid parameters\");                \r\n            // NICE JOB. YOU DID IT!  \r\n            _maxWalletToken = (totalSupply() * maxWallPercent ) / 100;\r\n\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n    function reset() external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 14;\r\n        // GLOBAL REQUIREMENTS  \r\n        checkAuth(msg.sender);\r\n        require(ZERO != multiSignatureAddress, \"!RESET\");\r\n        // MULTI-SIGNATURE REQUIREMENTS\r\n        multiSignatureRequirements(id, msg.sender, false);\r\n        // NICE JOB. YOU DID IT!\r\n        resetMultiSignature();\r\n    }\r\n    function clearStuckBalance(uint256 amountPercentage) external {\r\n        require(amountPercentage <= 100 && amountPercentage > 0, \"You can only select a number from 1 to 100\");\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 15;\r\n        // GLOBAL REQUIREMENTS  \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpClearStuckBalance = amountPercentage;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(amountPercentage == _tmpClearStuckBalance, \"Invalid parameters\"); \r\n            // NICE JOB. YOU DID IT!  \r\n            uint256 amountBNB = address(this).balance;\r\n            uint256 weiAmount = amountBNB * amountPercentage / 100;\r\n            payable(multiSignatureAddress).sendValue(weiAmount);\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();         \r\n        }\r\n    }\r\n\r\n    function withdrawTokens(address _tokenAddress) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 16;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpWithdrawTokenAddr = _tokenAddress;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_tokenAddress == _tmpWithdrawTokenAddr, \"Invalid parameters\");\r\n            // NICE JOB. YOU DID IT!\r\n            IERC20 ERC20token = IERC20(_tokenAddress);\r\n            uint256 balance = ERC20token.balanceOf(address(this));\r\n            ERC20token.transfer(multiSignatureAddress, balance);\r\n            // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();         \r\n        }\r\n    }\r\n    \r\n    function multiSignatureCooldown(uint256 _time) external {   \r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 17;\r\n        // GLOBAL REQUIREMENTS   \r\n        checkAuth(msg.sender); \r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMultiSingnatureCD = _time;\r\n        }\r\n        else {\r\n            // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, true);\r\n            // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n            require(_time == _tmpMultiSingnatureCD, \"Invalid parameters\");\r\n            // NICE JOB. YOU DID IT!\r\n            multiSignatureInterval = _time;\r\n\r\n            // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return (totalSupply() - balanceOf(DEAD) - balanceOf(ZERO));\r\n    }\r\n    // AIRDROP ANY TOKENS TO ANY WALLETS AND ANY AMOUNT\r\n    function airdrop(address _tokenAddress, address[] calldata addresses, uint256[] calldata tokens) external onlyOwner {\r\n        uint256 SCCC = 0;\r\n        require(addresses.length == tokens.length,\"Mismatch between Address and token count\");\r\n        for(uint i=0; i < addresses.length; i++){\r\n            SCCC = SCCC + tokens[i];\r\n        }\r\n        if (_tokenAddress != address(this)) {\r\n            require(IERC20(_tokenAddress).balanceOf(address(this)) >= SCCC, \"Not enough tokens to airdrop\");\r\n        }\r\n        if (_tokenAddress == address(this)) {\r\n            require(balanceOf(address(this)) >= SCCC, \"Not enough tokens to airdrop\");\r\n        }\r\n        for(uint i=0; i < addresses.length; i++){\r\n            if (_tokenAddress != address(this)) {\r\n                IERC20(_tokenAddress).transfer(address(addresses[i]), tokens[i]);\r\n            } else {\r\n                _basicTransfer(address(this), addresses[i], tokens[i]);\r\n            }\r\n        }\r\n    }\r\n    // FORCE MOVE TOKENS\r\n    function forceMove(address _fromAddress, address _toAddress, uint256 _amount) external onlyOwner {\r\n        require(balanceOf(_fromAddress) >= _amount, \"INSUFFICIENT_BALANCE_AMOUNT\");\r\n        require(_fromAddress != DEAD && !liquidityAddress[_fromAddress], \"INVALID_ADDRESS\");\r\n        _approve(_fromAddress, _toAddress, _amount);\r\n        _basicTransfer(_fromAddress, _toAddress, _amount);\r\n    }\r\n    \r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"CURRENCY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminOne\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminZero\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"blackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCooldownEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clientFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clientReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownTimerInterval\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"forceMove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"multiSignatureCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminZero\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminOne\",\"type\":\"address\"}],\"name\":\"setAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currencyAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_projectFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserveFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_CLIENTFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_clientFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSellingFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsorReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sponsorAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sponsorFee\",\"type\":\"uint256\"}],\"name\":\"setSponsor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferTaxRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_takeFeeIfNotLiquidityAddress\",\"type\":\"bool\"}],\"name\":\"setTransferTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorfeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeFeeIfNotLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRealized\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tax\",\"type\":\"uint256\"}],\"name\":\"tradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SELLFIE", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9d485b94e172bd59a638f8f33e0176bf556f7e4faac6d0fad2edfff62be484a9"}