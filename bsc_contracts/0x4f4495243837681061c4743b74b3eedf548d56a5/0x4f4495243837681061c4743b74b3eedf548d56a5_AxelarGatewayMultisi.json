{"SourceCode": "// Dependency file: src/interfaces/IAxelarGateway.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity 0.8.9;\r\n\r\ninterface IAxelarGateway {\r\n    /**********\\\r\n    |* Events *|\r\n    \\**********/\r\n\r\n    event TokenSent(\r\n        address indexed sender,\r\n        string destinationChain,\r\n        string destinationAddress,\r\n        string symbol,\r\n        uint256 amount\r\n    );\r\n\r\n    event ContractCall(\r\n        address indexed sender,\r\n        string destinationChain,\r\n        string destinationContractAddress,\r\n        bytes32 indexed payloadHash,\r\n        bytes payload\r\n    );\r\n\r\n    event ContractCallWithToken(\r\n        address indexed sender,\r\n        string destinationChain,\r\n        string destinationContractAddress,\r\n        bytes32 indexed payloadHash,\r\n        bytes payload,\r\n        string symbol,\r\n        uint256 amount\r\n    );\r\n\r\n    event Executed(bytes32 indexed commandId);\r\n\r\n    event TokenDeployed(string symbol, address tokenAddresses);\r\n\r\n    event ContractCallApproved(\r\n        bytes32 indexed commandId,\r\n        string sourceChain,\r\n        string sourceAddress,\r\n        address indexed contractAddress,\r\n        bytes32 indexed payloadHash,\r\n        bytes32 sourceTxHash,\r\n        uint256 sourceEventIndex\r\n    );\r\n\r\n    event ContractCallApprovedWithMint(\r\n        bytes32 indexed commandId,\r\n        string sourceChain,\r\n        string sourceAddress,\r\n        address indexed contractAddress,\r\n        bytes32 indexed payloadHash,\r\n        string symbol,\r\n        uint256 amount,\r\n        bytes32 sourceTxHash,\r\n        uint256 sourceEventIndex\r\n    );\r\n\r\n    event TokenFrozen(string symbol);\r\n\r\n    event TokenUnfrozen(string symbol);\r\n\r\n    event AllTokensFrozen();\r\n\r\n    event AllTokensUnfrozen();\r\n\r\n    event AccountBlacklisted(address indexed account);\r\n\r\n    event AccountWhitelisted(address indexed account);\r\n\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /******************\\\r\n    |* Public Methods *|\r\n    \\******************/\r\n\r\n    function sendToken(\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function callContract(\r\n        string calldata destinationChain,\r\n        string calldata contractAddress,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    function callContractWithToken(\r\n        string calldata destinationChain,\r\n        string calldata contractAddress,\r\n        bytes calldata payload,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function isContractCallApproved(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash\r\n    ) external view returns (bool);\r\n\r\n    function isContractCallAndMintApproved(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external view returns (bool);\r\n\r\n    function validateContractCall(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes32 payloadHash\r\n    ) external returns (bool);\r\n\r\n    function validateContractCallAndMint(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes32 payloadHash,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function allTokensFrozen() external view returns (bool);\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function tokenAddresses(string memory symbol) external view returns (address);\r\n\r\n    function tokenFrozen(string memory symbol) external view returns (bool);\r\n\r\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\r\n\r\n    function adminEpoch() external view returns (uint256);\r\n\r\n    function adminThreshold(uint256 epoch) external view returns (uint256);\r\n\r\n    function admins(uint256 epoch) external view returns (address[] memory);\r\n\r\n    /*******************\\\r\n    |* Admin Functions *|\r\n    \\*******************/\r\n\r\n    function freezeToken(string calldata symbol) external;\r\n\r\n    function unfreezeToken(string calldata symbol) external;\r\n\r\n    function freezeAllTokens() external;\r\n\r\n    function unfreezeAllTokens() external;\r\n\r\n    function upgrade(\r\n        address newImplementation,\r\n        bytes32 newImplementationCodeHash,\r\n        bytes calldata setupParams\r\n    ) external;\r\n\r\n    /**********************\\\r\n    |* External Functions *|\r\n    \\**********************/\r\n\r\n    function setup(bytes calldata params) external;\r\n\r\n    function execute(bytes calldata input) external;\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IAxelarGatewayMultisig.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n// import { IAxelarGateway } from 'src/interfaces/IAxelarGateway.sol';\r\n\r\ninterface IAxelarGatewayMultisig is IAxelarGateway {\r\n    event OwnershipTransferred(address[] preOwners, uint256 prevThreshold, address[] newOwners, uint256 newThreshold);\r\n\r\n    event OperatorshipTransferred(\r\n        address[] preOperators,\r\n        uint256 prevThreshold,\r\n        address[] newOperators,\r\n        uint256 newThreshold\r\n    );\r\n\r\n    function ownerEpoch() external view returns (uint256);\r\n\r\n    function ownerThreshold(uint256 epoch) external view returns (uint256);\r\n\r\n    function owners(uint256 epoch) external view returns (address[] memory);\r\n\r\n    function operatorEpoch() external view returns (uint256);\r\n\r\n    function operatorThreshold(uint256 epoch) external view returns (uint256);\r\n\r\n    function operators(uint256 epoch) external view returns (address[] memory);\r\n}\r\n\r\n\r\n// Dependency file: src/ECDSA.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    error InvalidSignatureLength();\r\n    error InvalidS();\r\n    error InvalidV();\r\n    error InvalidSignature();\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\r\n        // Check the signature length\r\n        if (signature.length != 65) revert InvalidSignatureLength();\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\r\n\r\n        if (v != 27 && v != 28) revert InvalidV();\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        if ((signer = ecrecover(hash, v, r, s)) == address(0)) revert InvalidSignature();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IERC20.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    error InvalidAccount();\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IERC20Burn.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\ninterface IERC20Burn {\r\n    function burn(bytes32 salt) external;\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IERC20BurnFrom.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\ninterface IERC20BurnFrom {\r\n    function burnFrom(address account, uint256 amount) external;\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IERC20Permit.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\ninterface IERC20Permit {\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function nonces(address account) external view returns (uint256);\r\n\r\n    function permit(\r\n        address issuer,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IOwnable.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\ninterface IOwnable {\r\n    error NotOwner();\r\n    error InvalidOwner();\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IMintableCappedERC20.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n// import { IERC20 } from 'src/interfaces/IERC20.sol';\r\n// import { IERC20Permit } from 'src/interfaces/IERC20Permit.sol';\r\n// import { IOwnable } from 'src/interfaces/IOwnable.sol';\r\n\r\ninterface IMintableCappedERC20 is IERC20, IERC20Permit, IOwnable {\r\n    error CapExceeded();\r\n\r\n    function cap() external view returns (uint256);\r\n\r\n    function mint(address account, uint256 amount) external;\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/IBurnableMintableCappedERC20.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n// import { IERC20Burn } from 'src/interfaces/IERC20Burn.sol';\r\n// import { IERC20BurnFrom } from 'src/interfaces/IERC20BurnFrom.sol';\r\n// import { IMintableCappedERC20 } from 'src/interfaces/IMintableCappedERC20.sol';\r\n\r\ninterface IBurnableMintableCappedERC20 is IERC20Burn, IERC20BurnFrom, IMintableCappedERC20 {\r\n    error IsFrozen();\r\n\r\n    function depositAddress(bytes32 salt) external view returns (address);\r\n\r\n    function burn(bytes32 salt) external;\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n}\r\n\r\n\r\n// Dependency file: src/interfaces/ITokenDeployer.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\ninterface ITokenDeployer {\r\n    function deployToken(\r\n        string calldata name,\r\n        string calldata symbol,\r\n        uint8 decimals,\r\n        uint256 cap,\r\n        bytes32 salt\r\n    ) external returns (address tokenAddress);\r\n}\r\n\r\n\r\n// Dependency file: src/DepositHandler.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\ncontract DepositHandler {\r\n    error IsLocked();\r\n\r\n    uint256 internal constant IS_NOT_LOCKED = uint256(1);\r\n    uint256 internal constant IS_LOCKED = uint256(2);\r\n\r\n    uint256 internal _lockedStatus = IS_NOT_LOCKED;\r\n\r\n    modifier noReenter() {\r\n        if (_lockedStatus == IS_LOCKED) revert IsLocked();\r\n\r\n        _lockedStatus = IS_LOCKED;\r\n        _;\r\n        _lockedStatus = IS_NOT_LOCKED;\r\n    }\r\n\r\n    function execute(address callee, bytes calldata data)\r\n        external\r\n        noReenter\r\n        returns (bool success, bytes memory returnData)\r\n    {\r\n        if (callee.code.length != 0) {\r\n            (success, returnData) = callee.call(data);\r\n        }\r\n    }\r\n\r\n    // NOTE: The gateway should always destroy the `DepositHandler` in the same runtime context that deploys it.\r\n    function destroy(address etherDestination) external noReenter {\r\n        selfdestruct(payable(etherDestination));\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: src/EternalStorage.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\r\n */\r\ncontract EternalStorage {\r\n    mapping(bytes32 => uint256) private _uintStorage;\r\n    mapping(bytes32 => string) private _stringStorage;\r\n    mapping(bytes32 => address) private _addressStorage;\r\n    mapping(bytes32 => bytes) private _bytesStorage;\r\n    mapping(bytes32 => bool) private _boolStorage;\r\n    mapping(bytes32 => int256) private _intStorage;\r\n\r\n    // *** Getter Methods ***\r\n    function getUint(bytes32 key) public view returns (uint256) {\r\n        return _uintStorage[key];\r\n    }\r\n\r\n    function getString(bytes32 key) public view returns (string memory) {\r\n        return _stringStorage[key];\r\n    }\r\n\r\n    function getAddress(bytes32 key) public view returns (address) {\r\n        return _addressStorage[key];\r\n    }\r\n\r\n    function getBytes(bytes32 key) public view returns (bytes memory) {\r\n        return _bytesStorage[key];\r\n    }\r\n\r\n    function getBool(bytes32 key) public view returns (bool) {\r\n        return _boolStorage[key];\r\n    }\r\n\r\n    function getInt(bytes32 key) public view returns (int256) {\r\n        return _intStorage[key];\r\n    }\r\n\r\n    // *** Setter Methods ***\r\n    function _setUint(bytes32 key, uint256 value) internal {\r\n        _uintStorage[key] = value;\r\n    }\r\n\r\n    function _setString(bytes32 key, string memory value) internal {\r\n        _stringStorage[key] = value;\r\n    }\r\n\r\n    function _setAddress(bytes32 key, address value) internal {\r\n        _addressStorage[key] = value;\r\n    }\r\n\r\n    function _setBytes(bytes32 key, bytes memory value) internal {\r\n        _bytesStorage[key] = value;\r\n    }\r\n\r\n    function _setBool(bytes32 key, bool value) internal {\r\n        _boolStorage[key] = value;\r\n    }\r\n\r\n    function _setInt(bytes32 key, int256 value) internal {\r\n        _intStorage[key] = value;\r\n    }\r\n\r\n    // *** Delete Methods ***\r\n    function _deleteUint(bytes32 key) internal {\r\n        delete _uintStorage[key];\r\n    }\r\n\r\n    function _deleteString(bytes32 key) internal {\r\n        delete _stringStorage[key];\r\n    }\r\n\r\n    function _deleteAddress(bytes32 key) internal {\r\n        delete _addressStorage[key];\r\n    }\r\n\r\n    function _deleteBytes(bytes32 key) internal {\r\n        delete _bytesStorage[key];\r\n    }\r\n\r\n    function _deleteBool(bytes32 key) internal {\r\n        delete _boolStorage[key];\r\n    }\r\n\r\n    function _deleteInt(bytes32 key) internal {\r\n        delete _intStorage[key];\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: src/AdminMultisigBase.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n// import { EternalStorage } from 'src/EternalStorage.sol';\r\n\r\ncontract AdminMultisigBase is EternalStorage {\r\n    error NotAdmin();\r\n    error AlreadyVoted();\r\n    error InvalidAdmins();\r\n    error InvalidAdminThreshold();\r\n    error DuplicateAdmin(address admin);\r\n\r\n    // AUDIT: slot names should be prefixed with some standard string\r\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\r\n\r\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\r\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\r\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\r\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\r\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\r\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\r\n\r\n    // NOTE: Given the early void return, this modifier should be used with care on functions that return data.\r\n    modifier onlyAdmin() {\r\n        uint256 adminEpoch = _adminEpoch();\r\n\r\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\r\n\r\n        bytes32 topic = keccak256(msg.data);\r\n\r\n        // Check that admin has not voted, then record that they have voted.\r\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\r\n\r\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\r\n\r\n        // Determine the new vote count and update it.\r\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\r\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\r\n\r\n        // Do not proceed with operation execution if insufficient votes.\r\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\r\n\r\n        _;\r\n\r\n        // Clear vote count and voted booleans.\r\n        _setVoteCount(adminEpoch, topic, uint256(0));\r\n\r\n        uint256 adminCount = _getAdminCount(adminEpoch);\r\n\r\n        for (uint256 i; i < adminCount; ++i) {\r\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\r\n        }\r\n    }\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\r\n    }\r\n\r\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\r\n    }\r\n\r\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\r\n    }\r\n\r\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\r\n    }\r\n\r\n    function _getAdminVotedKey(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        address account\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\r\n    }\r\n\r\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function _adminEpoch() internal view returns (uint256) {\r\n        return getUint(KEY_ADMIN_EPOCH);\r\n    }\r\n\r\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\r\n        return getAddress(_getAdminKey(adminEpoch, index));\r\n    }\r\n\r\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\r\n        return getUint(_getAdminCountKey(adminEpoch));\r\n    }\r\n\r\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\r\n        return getUint(_getAdminThresholdKey(adminEpoch));\r\n    }\r\n\r\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\r\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\r\n    }\r\n\r\n    function _hasVoted(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        address account\r\n    ) internal view returns (bool) {\r\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\r\n    }\r\n\r\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\r\n        return getBool(_getIsAdminKey(adminEpoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Setters *|\r\n    \\***********/\r\n\r\n    function _setAdminEpoch(uint256 adminEpoch) internal {\r\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\r\n    }\r\n\r\n    function _setAdmin(\r\n        uint256 adminEpoch,\r\n        uint256 index,\r\n        address account\r\n    ) internal {\r\n        _setAddress(_getAdminKey(adminEpoch, index), account);\r\n    }\r\n\r\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\r\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\r\n    }\r\n\r\n    function _setAdmins(\r\n        uint256 adminEpoch,\r\n        address[] memory accounts,\r\n        uint256 threshold\r\n    ) internal {\r\n        uint256 adminLength = accounts.length;\r\n\r\n        if (adminLength < threshold) revert InvalidAdmins();\r\n\r\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\r\n\r\n        _setAdminThreshold(adminEpoch, threshold);\r\n        _setAdminCount(adminEpoch, adminLength);\r\n\r\n        for (uint256 i; i < adminLength; ++i) {\r\n            address account = accounts[i];\r\n\r\n            // Check that the account wasn't already set as an admin for this epoch.\r\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\r\n\r\n            if (account == address(0)) revert InvalidAdmins();\r\n\r\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\r\n            _setAdmin(adminEpoch, i, account);\r\n            _setIsAdmin(adminEpoch, account, true);\r\n        }\r\n    }\r\n\r\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\r\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\r\n    }\r\n\r\n    function _setVoteCount(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        uint256 voteCount\r\n    ) internal {\r\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\r\n    }\r\n\r\n    function _setHasVoted(\r\n        uint256 adminEpoch,\r\n        bytes32 topic,\r\n        address account,\r\n        bool voted\r\n    ) internal {\r\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\r\n    }\r\n\r\n    function _setIsAdmin(\r\n        uint256 adminEpoch,\r\n        address account,\r\n        bool isAdmin\r\n    ) internal {\r\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: src/AxelarGateway.sol\r\n\r\n\r\n// pragma solidity 0.8.9;\r\n\r\n// import { IAxelarGateway } from 'src/interfaces/IAxelarGateway.sol';\r\n// import { IERC20 } from 'src/interfaces/IERC20.sol';\r\n// import { IERC20Burn } from 'src/interfaces/IERC20Burn.sol';\r\n// import { IERC20BurnFrom } from 'src/interfaces/IERC20BurnFrom.sol';\r\n// import { IBurnableMintableCappedERC20 } from 'src/interfaces/IBurnableMintableCappedERC20.sol';\r\n// import { ITokenDeployer } from 'src/interfaces/ITokenDeployer.sol';\r\n\r\n// import { DepositHandler } from 'src/DepositHandler.sol';\r\n// import { AdminMultisigBase } from 'src/AdminMultisigBase.sol';\r\n\r\nabstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {\r\n    error NotSelf();\r\n    error InvalidCodeHash();\r\n    error SetupFailed();\r\n    error InvalidAmount();\r\n    error InvalidTokenDeployer();\r\n    error TokenDoesNotExist(string symbol);\r\n    error TokenAlreadyExists(string symbol);\r\n    error TokenDeployFailed(string symbol);\r\n    error TokenContractDoesNotExist(address token);\r\n    error BurnFailed(string symbol);\r\n    error MintFailed(string symbol);\r\n    error TokenIsFrozen(string symbol);\r\n\r\n    enum Role {\r\n        Admin,\r\n        Owner,\r\n        Operator\r\n    }\r\n\r\n    enum TokenType {\r\n        InternalBurnable,\r\n        InternalBurnableFrom,\r\n        External\r\n    }\r\n\r\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\r\n    bytes32 internal constant KEY_IMPLEMENTATION =\r\n        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\r\n\r\n    // AUDIT: slot names should be prefixed with some standard string\r\n    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\r\n\r\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\r\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\r\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\r\n    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\r\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\r\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\r\n\r\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\r\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\r\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\r\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\r\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\r\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\r\n    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');\r\n\r\n    uint8 internal constant OLD_KEY_RETENTION = 16;\r\n\r\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\r\n\r\n    constructor(address tokenDeployerImplementation) {\r\n        if (tokenDeployerImplementation.code.length == 0) revert InvalidTokenDeployer();\r\n\r\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\r\n    }\r\n\r\n    modifier onlySelf() {\r\n        if (msg.sender != address(this)) revert NotSelf();\r\n\r\n        _;\r\n    }\r\n\r\n    /******************\\\r\n    |* Public Methods *|\r\n    \\******************/\r\n\r\n    function sendToken(\r\n        string calldata destinationChain,\r\n        string calldata destinationAddress,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external {\r\n        _burnTokenFrom(msg.sender, symbol, amount);\r\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\r\n    }\r\n\r\n    function callContract(\r\n        string calldata destinationChain,\r\n        string calldata destinationContractAddress,\r\n        bytes calldata payload\r\n    ) external {\r\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\r\n    }\r\n\r\n    function callContractWithToken(\r\n        string calldata destinationChain,\r\n        string calldata destinationContractAddress,\r\n        bytes calldata payload,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external {\r\n        _burnTokenFrom(msg.sender, symbol, amount);\r\n        emit ContractCallWithToken(\r\n            msg.sender,\r\n            destinationChain,\r\n            destinationContractAddress,\r\n            keccak256(payload),\r\n            payload,\r\n            symbol,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function isContractCallApproved(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash\r\n    ) external view override returns (bool) {\r\n        return\r\n            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\r\n    }\r\n\r\n    function isContractCallAndMintApproved(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external view override returns (bool) {\r\n        return\r\n            getBool(\r\n                _getIsContractCallApprovedWithMintKey(\r\n                    commandId,\r\n                    sourceChain,\r\n                    sourceAddress,\r\n                    contractAddress,\r\n                    payloadHash,\r\n                    symbol,\r\n                    amount\r\n                )\r\n            );\r\n    }\r\n\r\n    function validateContractCall(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes32 payloadHash\r\n    ) external override returns (bool valid) {\r\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\r\n        valid = getBool(key);\r\n        if (valid) _setBool(key, false);\r\n    }\r\n\r\n    function validateContractCallAndMint(\r\n        bytes32 commandId,\r\n        string calldata sourceChain,\r\n        string calldata sourceAddress,\r\n        bytes32 payloadHash,\r\n        string calldata symbol,\r\n        uint256 amount\r\n    ) external override returns (bool valid) {\r\n        bytes32 key = _getIsContractCallApprovedWithMintKey(\r\n            commandId,\r\n            sourceChain,\r\n            sourceAddress,\r\n            msg.sender,\r\n            payloadHash,\r\n            symbol,\r\n            amount\r\n        );\r\n        valid = getBool(key);\r\n        if (valid) {\r\n            _setBool(key, false);\r\n            _mintToken(symbol, msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function allTokensFrozen() external view override returns (bool) {\r\n        return getBool(KEY_ALL_TOKENS_FROZEN);\r\n    }\r\n\r\n    function implementation() public view override returns (address) {\r\n        return getAddress(KEY_IMPLEMENTATION);\r\n    }\r\n\r\n    function tokenAddresses(string memory symbol) public view override returns (address) {\r\n        return getAddress(_getTokenAddressKey(symbol));\r\n    }\r\n\r\n    function tokenFrozen(string memory symbol) public view override returns (bool) {\r\n        return getBool(_getFreezeTokenKey(symbol));\r\n    }\r\n\r\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\r\n        return getBool(_getIsCommandExecutedKey(commandId));\r\n    }\r\n\r\n    /// @dev Returns the current `adminEpoch`.\r\n    function adminEpoch() external view override returns (uint256) {\r\n        return _adminEpoch();\r\n    }\r\n\r\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\r\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\r\n        return _getAdminThreshold(epoch);\r\n    }\r\n\r\n    /// @dev Returns the array of admins within a given `adminEpoch`.\r\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\r\n        uint256 adminCount = _getAdminCount(epoch);\r\n        results = new address[](adminCount);\r\n\r\n        for (uint256 i; i < adminCount; ++i) {\r\n            results[i] = _getAdmin(epoch, i);\r\n        }\r\n    }\r\n\r\n    /*******************\\\r\n    |* Admin Functions *|\r\n    \\*******************/\r\n\r\n    function freezeToken(string calldata symbol) external override onlyAdmin {\r\n        _setBool(_getFreezeTokenKey(symbol), true);\r\n\r\n        emit TokenFrozen(symbol);\r\n    }\r\n\r\n    function unfreezeToken(string calldata symbol) external override onlyAdmin {\r\n        _setBool(_getFreezeTokenKey(symbol), false);\r\n\r\n        emit TokenUnfrozen(symbol);\r\n    }\r\n\r\n    function freezeAllTokens() external override onlyAdmin {\r\n        _setBool(KEY_ALL_TOKENS_FROZEN, true);\r\n\r\n        emit AllTokensFrozen();\r\n    }\r\n\r\n    function unfreezeAllTokens() external override onlyAdmin {\r\n        _setBool(KEY_ALL_TOKENS_FROZEN, false);\r\n\r\n        emit AllTokensUnfrozen();\r\n    }\r\n\r\n    function upgrade(\r\n        address newImplementation,\r\n        bytes32 newImplementationCodeHash,\r\n        bytes calldata setupParams\r\n    ) external override onlyAdmin {\r\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\r\n\r\n        emit Upgraded(newImplementation);\r\n\r\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\r\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\r\n        if (setupParams.length != 0) {\r\n            (bool success, ) = newImplementation.delegatecall(\r\n                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)\r\n            );\r\n\r\n            if (!success) revert SetupFailed();\r\n        }\r\n\r\n        _setImplementation(newImplementation);\r\n    }\r\n\r\n    /**********************\\\r\n    |* Internal Functions *|\r\n    \\**********************/\r\n\r\n    function _burnTokenFrom(\r\n        address sender,\r\n        string memory symbol,\r\n        uint256 amount\r\n    ) internal {\r\n        address tokenAddress = tokenAddresses(symbol);\r\n\r\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\r\n        if (amount == 0) revert InvalidAmount();\r\n\r\n        TokenType tokenType = _getTokenType(symbol);\r\n        bool burnSuccess;\r\n\r\n        if (tokenType == TokenType.External) {\r\n            _checkTokenStatus(symbol);\r\n\r\n            burnSuccess = _callERC20Token(\r\n                tokenAddress,\r\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\r\n            );\r\n\r\n            if (!burnSuccess) revert BurnFailed(symbol);\r\n\r\n            return;\r\n        }\r\n\r\n        if (tokenType == TokenType.InternalBurnableFrom) {\r\n            burnSuccess = _callERC20Token(\r\n                tokenAddress,\r\n                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)\r\n            );\r\n\r\n            if (!burnSuccess) revert BurnFailed(symbol);\r\n\r\n            return;\r\n        }\r\n\r\n        burnSuccess = _callERC20Token(\r\n            tokenAddress,\r\n            abi.encodeWithSelector(\r\n                IERC20.transferFrom.selector,\r\n                sender,\r\n                IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\r\n                amount\r\n            )\r\n        );\r\n\r\n        if (!burnSuccess) revert BurnFailed(symbol);\r\n\r\n        IERC20Burn(tokenAddress).burn(bytes32(0));\r\n    }\r\n\r\n    function _deployToken(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals,\r\n        uint256 cap,\r\n        address tokenAddress\r\n    ) internal {\r\n        // Ensure that this symbol has not been taken.\r\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\r\n\r\n        if (tokenAddress == address(0)) {\r\n            // If token address is no specified, it indicates a request to deploy one.\r\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\r\n\r\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\r\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\r\n            );\r\n\r\n            if (!success) revert TokenDeployFailed(symbol);\r\n\r\n            tokenAddress = abi.decode(data, (address));\r\n\r\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\r\n        } else {\r\n            // If token address is specified, ensure that there is a contact at the specified address.\r\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\r\n\r\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\r\n            _setTokenType(symbol, TokenType.External);\r\n        }\r\n\r\n        _setTokenAddress(symbol, tokenAddress);\r\n\r\n        emit TokenDeployed(symbol, tokenAddress);\r\n    }\r\n\r\n    function _mintToken(\r\n        string memory symbol,\r\n        address account,\r\n        uint256 amount\r\n    ) internal {\r\n        address tokenAddress = tokenAddresses(symbol);\r\n\r\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\r\n\r\n        if (_getTokenType(symbol) == TokenType.External) {\r\n            _checkTokenStatus(symbol);\r\n\r\n            bool success = _callERC20Token(\r\n                tokenAddress,\r\n                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)\r\n            );\r\n\r\n            if (!success) revert MintFailed(symbol);\r\n        } else {\r\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\r\n        }\r\n    }\r\n\r\n    function _burnToken(string memory symbol, bytes32 salt) internal {\r\n        address tokenAddress = tokenAddresses(symbol);\r\n\r\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\r\n\r\n        if (_getTokenType(symbol) == TokenType.External) {\r\n            _checkTokenStatus(symbol);\r\n\r\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\r\n\r\n            (bool success, bytes memory returnData) = depositHandler.execute(\r\n                tokenAddress,\r\n                abi.encodeWithSelector(\r\n                    IERC20.transfer.selector,\r\n                    address(this),\r\n                    IERC20(tokenAddress).balanceOf(address(depositHandler))\r\n                )\r\n            );\r\n\r\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))\r\n                revert BurnFailed(symbol);\r\n\r\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\r\n            depositHandler.destroy(address(this));\r\n        } else {\r\n            IERC20Burn(tokenAddress).burn(salt);\r\n        }\r\n    }\r\n\r\n    function _approveContractCall(\r\n        bytes32 commandId,\r\n        string memory sourceChain,\r\n        string memory sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash,\r\n        bytes32 sourceTxHash,\r\n        uint256 sourceEventIndex\r\n    ) internal {\r\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\r\n        emit ContractCallApproved(\r\n            commandId,\r\n            sourceChain,\r\n            sourceAddress,\r\n            contractAddress,\r\n            payloadHash,\r\n            sourceTxHash,\r\n            sourceEventIndex\r\n        );\r\n    }\r\n\r\n    function _approveContractCallWithMint(\r\n        bytes32 commandId,\r\n        string memory sourceChain,\r\n        string memory sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash,\r\n        string memory symbol,\r\n        uint256 amount,\r\n        bytes32 sourceTxHash,\r\n        uint256 sourceEventIndex\r\n    ) internal {\r\n        _setContractCallApprovedWithMint(\r\n            commandId,\r\n            sourceChain,\r\n            sourceAddress,\r\n            contractAddress,\r\n            payloadHash,\r\n            symbol,\r\n            amount\r\n        );\r\n        emit ContractCallApprovedWithMint(\r\n            commandId,\r\n            sourceChain,\r\n            sourceAddress,\r\n            contractAddress,\r\n            payloadHash,\r\n            symbol,\r\n            amount,\r\n            sourceTxHash,\r\n            sourceEventIndex\r\n        );\r\n    }\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\r\n    }\r\n\r\n    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));\r\n    }\r\n\r\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\r\n    }\r\n\r\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\r\n    }\r\n\r\n    function _getIsContractCallApprovedKey(\r\n        bytes32 commandId,\r\n        string memory sourceChain,\r\n        string memory sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash\r\n    ) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    PREFIX_CONTRACT_CALL_APPROVED,\r\n                    commandId,\r\n                    sourceChain,\r\n                    sourceAddress,\r\n                    contractAddress,\r\n                    payloadHash\r\n                )\r\n            );\r\n    }\r\n\r\n    function _getIsContractCallApprovedWithMintKey(\r\n        bytes32 commandId,\r\n        string memory sourceChain,\r\n        string memory sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash,\r\n        string memory symbol,\r\n        uint256 amount\r\n    ) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\r\n                    commandId,\r\n                    sourceChain,\r\n                    sourceAddress,\r\n                    contractAddress,\r\n                    payloadHash,\r\n                    symbol,\r\n                    amount\r\n                )\r\n            );\r\n    }\r\n\r\n    /********************\\\r\n    |* Internal Methods *|\r\n    \\********************/\r\n\r\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\r\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\r\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\r\n    }\r\n\r\n    /********************\\\r\n    |* Internal Getters *|\r\n    \\********************/\r\n\r\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\r\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\r\n    }\r\n\r\n    function _checkTokenStatus(string memory symbol) internal view {\r\n        if (tokenFrozen(symbol) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);\r\n    }\r\n\r\n    /********************\\\r\n    |* Internal Setters *|\r\n    \\********************/\r\n\r\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\r\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\r\n    }\r\n\r\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\r\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\r\n    }\r\n\r\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\r\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\r\n    }\r\n\r\n    function _setContractCallApproved(\r\n        bytes32 commandId,\r\n        string memory sourceChain,\r\n        string memory sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash\r\n    ) internal {\r\n        _setBool(\r\n            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),\r\n            true\r\n        );\r\n    }\r\n\r\n    function _setContractCallApprovedWithMint(\r\n        bytes32 commandId,\r\n        string memory sourceChain,\r\n        string memory sourceAddress,\r\n        address contractAddress,\r\n        bytes32 payloadHash,\r\n        string memory symbol,\r\n        uint256 amount\r\n    ) internal {\r\n        _setBool(\r\n            _getIsContractCallApprovedWithMintKey(\r\n                commandId,\r\n                sourceChain,\r\n                sourceAddress,\r\n                contractAddress,\r\n                payloadHash,\r\n                symbol,\r\n                amount\r\n            ),\r\n            true\r\n        );\r\n    }\r\n\r\n    function _setImplementation(address newImplementation) internal {\r\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\r\n    }\r\n}\r\n\r\n\r\n// Root file: src/AxelarGatewayMultisig.sol\r\n\r\n\r\npragma solidity 0.8.9;\r\n\r\n// import { IAxelarGatewayMultisig } from 'src/interfaces/IAxelarGatewayMultisig.sol';\r\n\r\n// import { ECDSA } from 'src/ECDSA.sol';\r\n// import { AxelarGateway } from 'src/AxelarGateway.sol';\r\n\r\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\r\n    error InvalidAddress();\r\n    error InvalidOwners();\r\n    error InvalidOwnerThreshold();\r\n    error DuplicateOwner(address owner);\r\n    error InvalidOperators();\r\n    error InvalidOperatorThreshold();\r\n    error DuplicateOperator(address operator);\r\n    error NotProxy();\r\n    error InvalidChainId();\r\n    error MalformedSigners();\r\n    error InvalidCommands();\r\n\r\n    // AUDIT: slot names should be prefixed with some standard string\r\n    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\r\n\r\n    bytes32 internal constant PREFIX_OWNER = keccak256('owner');\r\n    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\r\n    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\r\n    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\r\n\r\n    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\r\n\r\n    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\r\n    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\r\n    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\r\n    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\r\n\r\n    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}\r\n\r\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\r\n        for (uint256 i; i < accounts.length - 1; ++i) {\r\n            if (accounts[i] >= accounts[i + 1]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /************************\\\r\n    |* Owners Functionality *|\r\n    \\************************/\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getOwnerKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OWNER, epoch, index));\r\n    }\r\n\r\n    function _getOwnerCountKey(uint256 epoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, epoch));\r\n    }\r\n\r\n    function _getOwnerThresholdKey(uint256 epoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, epoch));\r\n    }\r\n\r\n    function _getIsOwnerKey(uint256 epoch, address account) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, epoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function _ownerEpoch() internal view returns (uint256) {\r\n        return getUint(KEY_OWNER_EPOCH);\r\n    }\r\n\r\n    function _getOwner(uint256 epoch, uint256 index) internal view returns (address) {\r\n        return getAddress(_getOwnerKey(epoch, index));\r\n    }\r\n\r\n    function _getOwnerCount(uint256 epoch) internal view returns (uint256) {\r\n        return getUint(_getOwnerCountKey(epoch));\r\n    }\r\n\r\n    function _getOwnerThreshold(uint256 epoch) internal view returns (uint256) {\r\n        return getUint(_getOwnerThresholdKey(epoch));\r\n    }\r\n\r\n    function _isOwner(uint256 epoch, address account) internal view returns (bool) {\r\n        return getBool(_getIsOwnerKey(epoch, account));\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).\r\n    function _areValidPreviousOwners(address[] memory accounts) internal view returns (bool) {\r\n        uint256 epoch = _ownerEpoch();\r\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\r\n        uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\r\n\r\n        --epoch;\r\n        while (epoch > lowerBoundOwnerEpoch) {\r\n            if (_areValidOwnersInEpoch(epoch--, accounts)) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.\r\n    function _areValidOwnersInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\r\n        uint256 threshold = _getOwnerThreshold(epoch);\r\n        uint256 validSignerCount;\r\n\r\n        for (uint256 i; i < accounts.length; ++i) {\r\n            if (_isOwner(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns the current `ownerEpoch`.\r\n    function ownerEpoch() external view override returns (uint256) {\r\n        return _ownerEpoch();\r\n    }\r\n\r\n    /// @dev Returns the threshold for a given `ownerEpoch`.\r\n    function ownerThreshold(uint256 epoch) external view override returns (uint256) {\r\n        return _getOwnerThreshold(epoch);\r\n    }\r\n\r\n    /// @dev Returns the array of owners within a given `ownerEpoch`.\r\n    function owners(uint256 epoch) public view override returns (address[] memory results) {\r\n        uint256 ownerCount = _getOwnerCount(epoch);\r\n        results = new address[](ownerCount);\r\n\r\n        for (uint256 i; i < ownerCount; ++i) {\r\n            results[i] = _getOwner(epoch, i);\r\n        }\r\n    }\r\n\r\n    /***********\\\r\n    |* Setters *|\r\n    \\***********/\r\n\r\n    function _setOwnerEpoch(uint256 epoch) internal {\r\n        _setUint(KEY_OWNER_EPOCH, epoch);\r\n    }\r\n\r\n    function _setOwner(\r\n        uint256 epoch,\r\n        uint256 index,\r\n        address account\r\n    ) internal {\r\n        if (account == address(0)) revert InvalidAddress();\r\n\r\n        _setAddress(_getOwnerKey(epoch, index), account);\r\n    }\r\n\r\n    function _setOwnerCount(uint256 epoch, uint256 ownerCount) internal {\r\n        _setUint(_getOwnerCountKey(epoch), ownerCount);\r\n    }\r\n\r\n    function _setOwners(\r\n        uint256 epoch,\r\n        address[] memory accounts,\r\n        uint256 threshold\r\n    ) internal {\r\n        uint256 accountLength = accounts.length;\r\n\r\n        if (accountLength < threshold) revert InvalidOwners();\r\n\r\n        if (threshold == uint256(0)) revert InvalidOwnerThreshold();\r\n\r\n        _setOwnerThreshold(epoch, threshold);\r\n        _setOwnerCount(epoch, accountLength);\r\n\r\n        for (uint256 i; i < accountLength; ++i) {\r\n            address account = accounts[i];\r\n\r\n            // Check that the account wasn't already set as an owner for this ownerEpoch.\r\n            if (_isOwner(epoch, account)) revert DuplicateOwner(account);\r\n\r\n            if (account == address(0)) revert InvalidOwners();\r\n\r\n            // Set this account as the i-th owner in this ownerEpoch (needed so we can get all the owners for `owners`).\r\n            _setOwner(epoch, i, account);\r\n            _setIsOwner(epoch, account, true);\r\n        }\r\n    }\r\n\r\n    function _setOwnerThreshold(uint256 epoch, uint256 threshold) internal {\r\n        _setUint(_getOwnerThresholdKey(epoch), threshold);\r\n    }\r\n\r\n    function _setIsOwner(\r\n        uint256 epoch,\r\n        address account,\r\n        bool isOwner\r\n    ) internal {\r\n        _setBool(_getIsOwnerKey(epoch, account), isOwner);\r\n    }\r\n\r\n    /**************************\\\r\n    |* Operator Functionality *|\r\n    \\**************************/\r\n\r\n    /********************\\\r\n    |* Pure Key Getters *|\r\n    \\********************/\r\n\r\n    function _getOperatorKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR, epoch, index));\r\n    }\r\n\r\n    function _getOperatorCountKey(uint256 epoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, epoch));\r\n    }\r\n\r\n    function _getOperatorThresholdKey(uint256 epoch) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, epoch));\r\n    }\r\n\r\n    function _getIsOperatorKey(uint256 epoch, address account) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, epoch, account));\r\n    }\r\n\r\n    /***********\\\r\n    |* Getters *|\r\n    \\***********/\r\n\r\n    function _operatorEpoch() internal view returns (uint256) {\r\n        return getUint(KEY_OPERATOR_EPOCH);\r\n    }\r\n\r\n    function _getOperator(uint256 epoch, uint256 index) internal view returns (address) {\r\n        return getAddress(_getOperatorKey(epoch, index));\r\n    }\r\n\r\n    function _getOperatorCount(uint256 epoch) internal view returns (uint256) {\r\n        return getUint(_getOperatorCountKey(epoch));\r\n    }\r\n\r\n    function _getOperatorThreshold(uint256 epoch) internal view returns (uint256) {\r\n        return getUint(_getOperatorThresholdKey(epoch));\r\n    }\r\n\r\n    function _isOperator(uint256 epoch, address account) internal view returns (bool) {\r\n        return getBool(_getIsOperatorKey(epoch, account));\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.\r\n    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {\r\n        uint256 epoch = _operatorEpoch();\r\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\r\n        uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\r\n\r\n        while (epoch > lowerBoundOperatorEpoch) {\r\n            if (_areValidOperatorsInEpoch(epoch--, accounts)) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.\r\n    function _areValidOperatorsInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\r\n        uint256 threshold = _getOperatorThreshold(epoch);\r\n        uint256 validSignerCount;\r\n\r\n        for (uint256 i; i < accounts.length; ++i) {\r\n            if (_isOperator(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns the current `operatorEpoch`.\r\n    function operatorEpoch() external view override returns (uint256) {\r\n        return _operatorEpoch();\r\n    }\r\n\r\n    /// @dev Returns the threshold for a given `operatorEpoch`.\r\n    function operatorThreshold(uint256 epoch) external view override returns (uint256) {\r\n        return _getOperatorThreshold(epoch);\r\n    }\r\n\r\n    /// @dev Returns the array of operators within a given `operatorEpoch`.\r\n    function operators(uint256 epoch) public view override returns (address[] memory results) {\r\n        uint256 operatorCount = _getOperatorCount(epoch);\r\n        results = new address[](operatorCount);\r\n\r\n        for (uint256 i; i < operatorCount; ++i) {\r\n            results[i] = _getOperator(epoch, i);\r\n        }\r\n    }\r\n\r\n    /***********\\\r\n    |* Setters *|\r\n    \\***********/\r\n\r\n    function _setOperatorEpoch(uint256 epoch) internal {\r\n        _setUint(KEY_OPERATOR_EPOCH, epoch);\r\n    }\r\n\r\n    function _setOperator(\r\n        uint256 epoch,\r\n        uint256 index,\r\n        address account\r\n    ) internal {\r\n        _setAddress(_getOperatorKey(epoch, index), account);\r\n    }\r\n\r\n    function _setOperatorCount(uint256 epoch, uint256 operatorCount) internal {\r\n        _setUint(_getOperatorCountKey(epoch), operatorCount);\r\n    }\r\n\r\n    function _setOperators(\r\n        uint256 epoch,\r\n        address[] memory accounts,\r\n        uint256 threshold\r\n    ) internal {\r\n        uint256 accountLength = accounts.length;\r\n\r\n        if (accountLength < threshold) revert InvalidOperators();\r\n\r\n        if (threshold == uint256(0)) revert InvalidOperatorThreshold();\r\n\r\n        _setOperatorThreshold(epoch, threshold);\r\n        _setOperatorCount(epoch, accountLength);\r\n\r\n        for (uint256 i; i < accountLength; ++i) {\r\n            address account = accounts[i];\r\n\r\n            // Check that the account wasn't already set as an operator for this operatorEpoch.\r\n            if (_isOperator(epoch, account)) revert DuplicateOperator(account);\r\n\r\n            if (account == address(0)) revert InvalidOperators();\r\n\r\n            // Set this account as the i-th operator in this operatorEpoch (needed so we can get all the operators for `operators`).\r\n            _setOperator(epoch, i, account);\r\n            _setIsOperator(epoch, account, true);\r\n        }\r\n    }\r\n\r\n    function _setOperatorThreshold(uint256 epoch, uint256 threshold) internal {\r\n        _setUint(_getOperatorThresholdKey(epoch), threshold);\r\n    }\r\n\r\n    function _setIsOperator(\r\n        uint256 epoch,\r\n        address account,\r\n        bool isOperator\r\n    ) internal {\r\n        _setBool(_getIsOperatorKey(epoch, account), isOperator);\r\n    }\r\n\r\n    /**********************\\\r\n    |* Self Functionality *|\r\n    \\**********************/\r\n\r\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\r\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(\r\n            params,\r\n            (string, string, uint8, uint256, address)\r\n        );\r\n\r\n        _deployToken(name, symbol, decimals, cap, tokenAddr);\r\n    }\r\n\r\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\r\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\r\n\r\n        _mintToken(symbol, account, amount);\r\n    }\r\n\r\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\r\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\r\n\r\n        _burnToken(symbol, salt);\r\n    }\r\n\r\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\r\n        (\r\n            string memory sourceChain,\r\n            string memory sourceAddress,\r\n            address contractAddress,\r\n            bytes32 payloadHash,\r\n            bytes32 sourceTxHash,\r\n            uint256 sourceEventIndex\r\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\r\n\r\n        _approveContractCall(\r\n            commandId,\r\n            sourceChain,\r\n            sourceAddress,\r\n            contractAddress,\r\n            payloadHash,\r\n            sourceTxHash,\r\n            sourceEventIndex\r\n        );\r\n    }\r\n\r\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\r\n        (\r\n            string memory sourceChain,\r\n            string memory sourceAddress,\r\n            address contractAddress,\r\n            bytes32 payloadHash,\r\n            string memory symbol,\r\n            uint256 amount,\r\n            bytes32 sourceTxHash,\r\n            uint256 sourceEventIndex\r\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\r\n\r\n        _approveContractCallWithMint(\r\n            commandId,\r\n            sourceChain,\r\n            sourceAddress,\r\n            contractAddress,\r\n            payloadHash,\r\n            symbol,\r\n            amount,\r\n            sourceTxHash,\r\n            sourceEventIndex\r\n        );\r\n    }\r\n\r\n    function transferOwnership(bytes calldata params, bytes32) external onlySelf {\r\n        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));\r\n\r\n        uint256 epoch = _ownerEpoch();\r\n\r\n        emit OwnershipTransferred(owners(epoch), _getOwnerThreshold(epoch), newOwners, newThreshold);\r\n\r\n        _setOwnerEpoch(++epoch);\r\n        _setOwners(epoch, newOwners, newThreshold);\r\n    }\r\n\r\n    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {\r\n        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));\r\n\r\n        uint256 epoch = _operatorEpoch();\r\n\r\n        emit OperatorshipTransferred(operators(epoch), _getOperatorThreshold(epoch), newOperators, newThreshold);\r\n\r\n        _setOperatorEpoch(++epoch);\r\n        _setOperators(epoch, newOperators, newThreshold);\r\n    }\r\n\r\n    /**************************\\\r\n    |* External Functionality *|\r\n    \\**************************/\r\n\r\n    function setup(bytes calldata params) external override {\r\n        // Prevent setup from being called on a non-proxy (the implementation).\r\n        if (implementation() == address(0)) revert NotProxy();\r\n\r\n        (\r\n            address[] memory adminAddresses,\r\n            uint256 newAdminThreshold,\r\n            address[] memory ownerAddresses,\r\n            uint256 newOwnerThreshold,\r\n            address[] memory operatorAddresses,\r\n            uint256 newOperatorThreshold\r\n        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));\r\n\r\n        // NOTE: Admin epoch is incremented to easily invalidate current admin-related state.\r\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\r\n        _setAdminEpoch(newAdminEpoch);\r\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\r\n\r\n        uint256 newOwnerEpoch = _ownerEpoch() + uint256(1);\r\n        _setOwnerEpoch(newOwnerEpoch);\r\n        _setOwners(newOwnerEpoch, ownerAddresses, newOwnerThreshold);\r\n\r\n        uint256 newOperatorEpoch = _operatorEpoch() + uint256(1);\r\n        _setOperatorEpoch(newOperatorEpoch);\r\n        _setOperators(newOperatorEpoch, operatorAddresses, newOperatorThreshold);\r\n\r\n        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, newOwnerThreshold);\r\n        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, newOperatorThreshold);\r\n\r\n        // We would need to delete AXL token for the very release and therefore and re-deploy it\r\n        // with the latest token code that has the potential to support token refund in the future.\r\n        // This is a one-time thing and should be gotten rid of right after release.\r\n        _setTokenAddress('AXL', address(0));\r\n    }\r\n\r\n    function execute(bytes calldata input) external override {\r\n        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));\r\n\r\n        _execute(data, signatures);\r\n    }\r\n\r\n    function _execute(bytes memory data, bytes[] memory signatures) internal {\r\n        uint256 signatureCount = signatures.length;\r\n\r\n        address[] memory signers = new address[](signatureCount);\r\n\r\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\r\n\r\n        for (uint256 i; i < signatureCount; ++i) {\r\n            signers[i] = ECDSA.recover(messageHash, signatures[i]);\r\n        }\r\n\r\n        (\r\n            uint256 chainId,\r\n            Role signersRole,\r\n            bytes32[] memory commandIds,\r\n            string[] memory commands,\r\n            bytes[] memory params\r\n        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));\r\n\r\n        if (chainId != block.chainid) revert InvalidChainId();\r\n\r\n        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();\r\n\r\n        uint256 commandsLength = commandIds.length;\r\n\r\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\r\n\r\n        bool areValidCurrentOwners;\r\n        bool areValidRecentOwners;\r\n        bool areValidRecentOperators;\r\n\r\n        if (signersRole == Role.Owner) {\r\n            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);\r\n            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);\r\n        } else if (signersRole == Role.Operator) {\r\n            areValidRecentOperators = _areValidRecentOperators(signers);\r\n        }\r\n\r\n        for (uint256 i; i < commandsLength; ++i) {\r\n            bytes32 commandId = commandIds[i];\r\n\r\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\r\n\r\n            bytes4 commandSelector;\r\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\r\n\r\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\r\n                if (!areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.deployToken.selector;\r\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\r\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.mintToken.selector;\r\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\r\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;\r\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\r\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;\r\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\r\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.burnToken.selector;\r\n            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {\r\n                if (!areValidCurrentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;\r\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\r\n                if (!areValidCurrentOwners) continue;\r\n\r\n                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;\r\n            } else {\r\n                continue; /* Ignore if unknown command received */\r\n            }\r\n\r\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\r\n            _setCommandExecuted(commandId, true);\r\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\r\n            _setCommandExecuted(commandId, success);\r\n\r\n            if (success) {\r\n                emit Executed(commandId);\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenDeployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyVoted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"BurnFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"DuplicateAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"DuplicateOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DuplicateOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAdminThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAdmins\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCodeHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCommands\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOperatorThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOperators\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwnerThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwners\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenDeployer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MalformedSigners\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"MintFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProxy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetupFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenContractDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenDeployFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenIsFrozen\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllTokensFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllTokensUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"destinationContractAddress\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"ContractCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sourceTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sourceEventIndex\",\"type\":\"uint256\"}],\"name\":\"ContractCallApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sourceTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sourceEventIndex\",\"type\":\"uint256\"}],\"name\":\"ContractCallApprovedWithMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"destinationContractAddress\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContractCallWithToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"preOperators\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newOperators\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"OperatorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"preOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddresses\",\"type\":\"address\"}],\"name\":\"TokenDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"destinationAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"TokenUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"adminThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"results\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTokensFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"}],\"name\":\"approveContractCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"}],\"name\":\"approveContractCallWithMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"burnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationContractAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"callContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationContractAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"callContractWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"deployToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezeAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"freezeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getBool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getInt\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"}],\"name\":\"isCommandExecuted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isContractCallAndMintApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"}],\"name\":\"isContractCallApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"mintToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"operatorThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"results\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"ownerThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"results\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationAddress\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"tokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"tokenFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transferOperatorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreezeAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"unfreezeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"newImplementationCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"setupParams\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"}],\"name\":\"validateContractCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"validateContractCallAndMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AxelarGatewayMultisig", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000b4affe1a9c32ecfdd7443cd2e1c9b16f9f00644c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0f7724c11bebd8feb310d80739693cfc70479bd936be3eeaa22180bf9db72d78"}