{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IMYCStakingFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IMYCStakingFactory {\\n    function treasury() external view returns (address);\\n\\n    function signer() external view returns (address);\\n\\n    function mycStakingManager() external view returns (address);\\n\\n    function owner() external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/staking/IMYCStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IMYCStakingPool {\\n    function factory() external returns (address);\\n}\"\r\n    },\r\n    \"contracts/staking/LockedStaking/LockedStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../IMYCStakingFactory.sol\\\";\\nimport \\\"../IMYCStakingPool.sol\\\";\\n\\nstruct StakingPool {\\n    address tokenAddress; // staking token address\\n    address owner; // owner of pool\\n    uint256 dateStart; // start date for all pools\\n    uint256 dateEnd; // end date for all pools\\n    bool rescued; // if unused rewards are withdrawn by owner\\n    uint256 mycFeesWithdrawn; // withdrawn myc fees\\n}\\n\\nstruct StakingPlan {\\n    uint256 duration; // for how long user cannot unstake (seconds)\\n    uint256 maxTokensBeStaked; // maximum amount that can be staked amoung all stakers\\n    uint256 availableTokensBeStaked; // available tokens amount can be staked by user\\n    uint256 rewardsPool; // reward pool\\n    uint256 rewardsWithdrawn; // how many rewards withdrawn by stakers\\n    uint256 mycFeesPool; //myc fees pools\\n    uint256 maxStakingAmount; //max staking amount\\n}\\n\\nstruct UserStake {\\n    uint256 stakeDate;\\n    uint256 amount;\\n}\\n\\n/// @title Locked Staking by MyCointainer\\n/// @notice Stake ERC20 tokens for rewards\\ncontract LockedStaking is IMYCStakingPool {\\n    /**\\n     * @dev Emitted when `staker` stakes tokens for `stakingPlanId`\\n     */\\n    event Staked(\\n        address indexed staker,\\n        uint256 indexed stakingPlanId,\\n        uint256 amount,\\n        uint256 unstakeDate\\n    );\\n\\n    /**\\n     * @dev Emitted when `staker` unstakes tokens for `stakingPlanId`\\n     */\\n    event Unstaked(\\n        address indexed staker,\\n        uint256 indexed stakingPlanId,\\n        uint256 amount,\\n        uint256 reward\\n    );\\n\\n    /**\\n     * @dev Emitted when `staker` unstakes tokens wtih penalty(before staking period ends)\\n     */\\n    event UnstakedWithPenalty(\\n        address indexed staker,\\n        uint256 indexed stakingPlanId,\\n        uint256 staked,\\n        uint256 withdrawn\\n    );\\n\\n    error OnlyFactory();\\n    error StakeAlreadyExists();\\n    error NoSlotsAvailable();\\n    error StakeNotFound();\\n    error EndOfStakeNotReached();\\n    error StakingPeriodNotEnded();\\n    error NothingToWithdraw();\\n    error DateInFuture();\\n    error DateInPast();\\n    error NoTokensAvailableToStake();\\n    error AmountCantBeZero();\\n    error AlreadyRescued();\\n    error MaxStakingAmountExceed();\\n\\n    StakingPool internal _stakePool;\\n    mapping(address => mapping(uint256 => UserStake)) internal _userStake;\\n    StakingPlan[] internal _plans;\\n    IMYCStakingFactory internal _factory;\\n    uint256 internal _withdrawnMYCSlots;\\n\\n    /**\\n     * @dev Plans length\\n     */\\n    function getPlansLength() external view returns (uint256) {\\n        return _plans.length;\\n    }\\n\\n    /**\\n     * @dev Returns factory address\\n     */\\n    function factory() external view returns (address) {\\n        return address(_factory);\\n    }\\n\\n    /**\\n     * @dev Returns plans\\n     */\\n    function getPlans() external view returns (StakingPlan[] memory) {\\n        StakingPlan[] memory plans = new StakingPlan[](_plans.length);\\n        plans = _plans;\\n        return plans;\\n    }\\n\\n    /**\\n     * @dev Returns `planId` plan\\n     */\\n    function getPlan(\\n        uint256 planId\\n    ) external view returns (StakingPlan memory) {\\n        return _plans[planId];\\n    }\\n\\n    /**\\n     * @dev Returns {StakingPool} info\\n     */\\n    function stakingPool() external view returns (StakingPool memory) {\\n        return _stakePool;\\n    }\\n\\n    /**\\n     * @dev Returns stake info for each plan for staker\\n     */\\n    function stakesInfoOf(\\n        address staker\\n    ) external view returns (UserStake[] memory) {\\n        uint256 len = _plans.length;\\n        UserStake[] memory stakes = new UserStake[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            stakes[i] = _userStake[staker][i];\\n        }\\n        return stakes;\\n    }\\n\\n    /**\\n     * @dev Returns stake info for `staker` and `planId`\\n     */\\n    function stakeInfoOf(\\n        address staker,\\n        uint256 planId\\n    ) external view returns (UserStake memory) {\\n        return _userStake[staker][planId];\\n    }\\n\\n    constructor(\\n        address tokenAddress, // staking token address\\n        address owner, // owner of pool\\n        uint256[] memory durations, // for how long user cannot unstake\\n        uint256[] memory maxTokensBeStaked, // maximum amount that can be staked amoung all stakers for each duration\\n        uint256[] memory rewardsPool, // reward pool for each duration\\n        uint256[] memory mycFeesPool, //myc fees pools for each duration\\n        uint256[] memory maxStakingAmount, //max staking amount\\n        uint256 dateStart, // start date for all pools\\n        uint256 dateEnd // end date for all pools\\n    ) {\\n        //saving pool info\\n        StakingPool memory newConfig = StakingPool({\\n            tokenAddress: tokenAddress,\\n            owner: owner,\\n            dateStart: dateStart,\\n            dateEnd: dateEnd,\\n            rescued: false,\\n            mycFeesWithdrawn: 0\\n        });\\n        _stakePool = newConfig;\\n\\n        //saving _plans\\n        uint256 len = durations.length;\\n        for (uint256 i = 0; i < len; i++) {\\n            StakingPlan memory newStakingPlan = StakingPlan({\\n                duration: durations[i],\\n                maxTokensBeStaked: maxTokensBeStaked[i],\\n                availableTokensBeStaked: maxTokensBeStaked[i],\\n                rewardsPool: rewardsPool[i],\\n                rewardsWithdrawn: 0,\\n                mycFeesPool: mycFeesPool[i],\\n                maxStakingAmount: maxStakingAmount[i]\\n            });\\n            _plans.push(newStakingPlan);\\n        }\\n\\n        _factory = IMYCStakingFactory(msg.sender);\\n    }\\n\\n    function _checkDateInFutureOrZero(uint256 date) internal view {\\n        if (date == 0) {\\n            return;\\n        }\\n        if (date < block.timestamp) revert DateInPast();\\n    }\\n\\n    function _checkDateInPastOrZero(uint256 date) internal view {\\n        if (date == 0) {\\n            return;\\n        }\\n        if (date > block.timestamp) revert DateInFuture();\\n    }\\n\\n    function _checkPlanAvailability(\\n        StakingPlan memory plan,\\n        uint256 amountToStake\\n    ) internal pure returns (uint256) {\\n        if (plan.availableTokensBeStaked == 0) {\\n            revert NoTokensAvailableToStake();\\n        } else if (plan.availableTokensBeStaked < amountToStake) {\\n            return plan.availableTokensBeStaked;\\n        } else {\\n            return amountToStake;\\n        }\\n    }\\n\\n    /**\\n     * @dev Stakes tokens\\n     */\\n    function stake(uint256 amount, uint256 stakingPlanId) external {\\n        if (amount == 0) {\\n            revert AmountCantBeZero();\\n        }\\n        UserStake memory uStake = _userStake[msg.sender][stakingPlanId];\\n\\n        //only one active stake for each plan per staker\\n        if (uStake.stakeDate != 0) revert StakeAlreadyExists();\\n\\n        StakingPool memory sp = _stakePool;\\n\\n        //check start and end date\\n        _checkDateInPastOrZero(sp.dateStart);\\n        _checkDateInFutureOrZero(sp.dateEnd);\\n\\n        //check availability to stake such amount, decreasing amount to max available\\n        StakingPlan memory plan = _plans[stakingPlanId];\\n        amount = _checkPlanAvailability(plan, amount);\\n\\n        //check max staking amount\\n        if (amount > plan.maxStakingAmount) {\\n            revert MaxStakingAmountExceed();\\n        }\\n\\n        //transfering tokens to smart contract - allowance needed\\n        IERC20(sp.tokenAddress).transferFrom(msg.sender, address(this), amount);\\n\\n        //store stake data for user\\n        _userStake[msg.sender][stakingPlanId] = UserStake({\\n            stakeDate: block.timestamp,\\n            amount: amount\\n        });\\n\\n        //decreasing available amount to stake for plan\\n        _plans[stakingPlanId].availableTokensBeStaked -= amount;\\n\\n        //emit event\\n        emit Staked(\\n            msg.sender,\\n            stakingPlanId,\\n            amount,\\n            block.timestamp + plan.duration\\n        );\\n    }\\n\\n    function _calculateReward(\\n        StakingPlan memory plan,\\n        uint256 stakedOnPlan\\n    ) internal pure returns (uint256) {\\n        return (plan.rewardsPool * stakedOnPlan) / plan.maxTokensBeStaked;\\n    }\\n\\n    /**\\n     * @dev Unstakes tokens on selected `poolIndex`\\n     */\\n    function unstake(uint256 stakingPlanId) public {\\n        UserStake memory uStake = _userStake[msg.sender][stakingPlanId];\\n\\n        // checking is stake exist\\n        if (uStake.stakeDate == 0) revert StakeNotFound();\\n\\n        // check end staking date\\n        StakingPlan memory plan = _plans[stakingPlanId];\\n        if (uStake.stakeDate + plan.duration > block.timestamp)\\n            revert EndOfStakeNotReached();\\n\\n        // reset stake values for user\\n        _userStake[msg.sender][stakingPlanId] = UserStake({\\n            stakeDate: 0,\\n            amount: 0\\n        });\\n\\n        // update withrawn rewards\\n        uint256 rewardToWithdraw = _calculateReward(plan, uStake.amount);\\n        _plans[stakingPlanId].rewardsWithdrawn += rewardToWithdraw;\\n\\n        // transfer tokens\\n        StakingPool memory sc = _stakePool;\\n        IERC20(sc.tokenAddress).transfer(\\n            msg.sender,\\n            uStake.amount + rewardToWithdraw\\n        );\\n\\n        // emit event\\n        emit Unstaked(\\n            msg.sender,\\n            stakingPlanId,\\n            uStake.amount,\\n            rewardToWithdraw\\n        );\\n    }\\n\\n    /**\\n     * @dev Unstakes tokens on selected `poolIndex` before end of staking period\\n     * Takes 10% fee\\n     */\\n    function unstakeWithPenalty(uint256 stakingPlanId) external {\\n        UserStake memory uStake = _userStake[msg.sender][stakingPlanId];\\n\\n        // checking is stake exist\\n        if (uStake.stakeDate == 0) revert StakeNotFound();\\n\\n        // if after locked period - do normal unstake\\n        StakingPlan memory plan = _plans[stakingPlanId];\\n        if (uStake.stakeDate + plan.duration < block.timestamp) {\\n            unstake(stakingPlanId);\\n            return ();\\n        }\\n\\n        StakingPool memory sc = _stakePool;\\n        uint256 feeAmount = (uStake.amount * 5) / 100;\\n        uint256 toWithdraw = uStake.amount - 2 * feeAmount;\\n\\n        // reset stake values for user\\n        _userStake[msg.sender][stakingPlanId] = UserStake({\\n            stakeDate: 0,\\n            amount: 0\\n        });\\n\\n        // calculate and transfer tokens\\n        uint256 rescuedRewards = 0;\\n        if (sc.dateEnd > block.timestamp || sc.dateEnd == 0) {\\n            _plans[stakingPlanId].availableTokensBeStaked += uStake.amount;\\n        } else {\\n            rescuedRewards = _calculateReward(plan, uStake.amount);\\n            _plans[stakingPlanId].rewardsWithdrawn += rescuedRewards;\\n        }\\n        IERC20(sc.tokenAddress).transfer(sc.owner, feeAmount + rescuedRewards);\\n        IERC20(sc.tokenAddress).transfer(_factory.treasury(), feeAmount);\\n        IERC20(sc.tokenAddress).transfer(msg.sender, toWithdraw);\\n        emit UnstakedWithPenalty(\\n            msg.sender,\\n            stakingPlanId,\\n            uStake.amount,\\n            toWithdraw\\n        );\\n    }\\n\\n    /**\\n     * @dev Sends unused reward tokens back to owner\\n     *\\n     * Note: Can be used only after stake period end\\n     */\\n    function claimUnusedRewards() external {\\n        StakingPool memory sc = _stakePool;\\n        if (sc.dateEnd >= block.timestamp || sc.dateEnd == 0) {\\n            revert StakingPeriodNotEnded();\\n        }\\n\\n        if (sc.rescued) {\\n            revert AlreadyRescued();\\n        }\\n\\n        uint256 sumToRescue;\\n        for (uint256 i = 0; i < _plans.length; i++) {\\n            StakingPlan memory plan = _plans[i];\\n            sumToRescue +=\\n                (plan.availableTokensBeStaked * plan.rewardsPool) /\\n                plan.maxTokensBeStaked;\\n        }\\n        if (sumToRescue == 0) revert NothingToWithdraw();\\n        _stakePool.rescued = true;\\n        IERC20(sc.tokenAddress).transfer(sc.owner, sumToRescue);\\n    }\\n\\n    /**\\n     * @dev Withdraws collected fees\\n     *\\n     * Note: Only factory contract can execute this function\\n     */\\n    function claimFee() external returns (uint256) {\\n        if (msg.sender != address(_factory)) {\\n            revert OnlyFactory();\\n        }\\n        StakingPool memory sc = _stakePool;\\n        if (sc.dateEnd >= block.timestamp && sc.dateEnd != 0)\\n            revert StakingPeriodNotEnded();\\n\\n        uint256 sumRewards;\\n        for (uint256 i = 0; i < _plans.length; i++) {\\n            StakingPlan memory plan = _plans[i];\\n            sumRewards +=\\n                (plan.rewardsWithdrawn * plan.mycFeesPool) /\\n                plan.rewardsPool;\\n        }\\n\\n        if (sc.mycFeesWithdrawn >= sumRewards) {\\n            revert NothingToWithdraw();\\n        }\\n\\n        uint256 toWithdraw = sumRewards - sc.mycFeesWithdrawn;\\n        IERC20(sc.tokenAddress).transfer(_factory.treasury(), toWithdraw);\\n        sc.mycFeesWithdrawn += toWithdraw;\\n        return (toWithdraw);\\n    }\\n    \\n    /**\\n     * @notice Used to withdraw the amount of tokens from contract to protocol owner address. Unsafe function, please, use only with emergency\\n     * @param _tokenAddress Token address\\n     * @param _amount Amount to withdraw\\n     */\\n    function emergencyWithdraw(address _tokenAddress, uint256 _amount) external {\\n        address owner = _factory.owner();\\n        require(msg.sender == owner, \\\"Only protocol owner\\\");\\n        IERC20(_tokenAddress).transfer(owner, _amount);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"durations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxTokensBeStaked\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardsPool\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mycFeesPool\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxStakingAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyRescued\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AmountCantBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DateInFuture\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DateInPast\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EndOfStakeNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxStakingAmountExceed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSlotsAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokensAvailableToStake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakeAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakeNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakingPeriodNotEnded\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingPlanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakeDate\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingPlanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingPlanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"name\":\"UnstakedWithPenalty\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUnusedRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"getPlan\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensBeStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableTokensBeStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mycFeesPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakingAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingPlan\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlans\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensBeStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableTokensBeStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mycFeesPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakingAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingPlan[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlansLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPlanId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"stakeInfoOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct UserStake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"stakesInfoOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct UserStake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPool\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"rescued\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"mycFeesWithdrawn\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingPool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingPlanId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingPlanId\",\"type\":\"uint256\"}],\"name\":\"unstakeWithPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LockedStaking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ba2ae424d960c26247dd6c32edc70b295c744c43000000000000000000000000b10f19ba978c351da298ff5b4807a64c5e0e51f4000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000645187e000000000000000000000000000000000000000000000000000000000665ceb600000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000000000000000000000000000000000000000278d0000000000000000000000000000000000000000000000000000000000003b53800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000066ef600b5a4b00000000000000000000000000000000000000000000000000001b1967214a7200000000000000000000000000000000000000000000000000000c3a22bedf96000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000045d073e68000000000000000000000000000000000000000000000000000000045d073e68000000000000000000000000000000000000000000000000000000045d073e68000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000008f0d1800000000000000000000000000000000000000000000000000000000008f0d1800000000000000000000000000000000000000000000000000000000008f0d18000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000005d21dba00000000000000000000000000000000000000000000000000000000045d964b8000000000000000000000000000000000000000000000000000000003a35294400", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}