{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/zero-ex/src/features/interfaces/IBasicERC721OrdersFeature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Copyright 2022 Element.Market Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\n\\ninterface IBasicERC721OrdersFeature {\\n\\n    /// @param data1 [96 bits(ethAmount) + 160 bits(maker)]\\n    /// @param data2 [32 bits(listingTime) + 32 bits(expiryTime) + 32 bits(unused) + 160 bits(taker)]\\n    /// @param data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n    /// @param fee1 [96 bits(ethAmount) + 160 bits(recipient)]\\n    /// @param fee2 [96 bits(ethAmount) + 160 bits(recipient)]\\n    struct BasicOrderParameter {\\n        uint256 data1;\\n        uint256 data2;\\n        uint256 data3;\\n        uint256 nftId;\\n        uint256 fee1;\\n        uint256 fee2;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function fillBasicERC721Order(BasicOrderParameter calldata parameter) external payable;\\n\\n    /// @param parameter1 [8 bits(revertIfIncomplete) + 88 bits(unused) + 160 bits(nftAddress)]\\n    /// @param parameter2 [80 bits(taker part1) + 16 bits(feePercentage1) + 160 bits(feeRecipient1)]\\n    /// @param parameter3 [80 bits(taker part2) + 16 bits(feePercentage2) + 160 bits(feeRecipient2)]\\n    struct BasicOrderParameters {\\n        uint256 parameter1;\\n        uint256 parameter2;\\n        uint256 parameter3;\\n    }\\n\\n    /// @param extra [96 bits(ethAmount) + 64 bits(nonce) + 8 bits(v) + 24 bits(unused)\\n    ///               + 32 bits(listingTime) + 32 bits(expiryTime)]\\n    struct BasicOrderItem {\\n        address maker;\\n        uint256 extra;\\n        uint256 nftId;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function fillBasicERC721Orders(BasicOrderParameters calldata parameters, BasicOrderItem[] calldata orders) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/features/nft_orders/BasicERC721OrdersFeature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Copyright 2022 Element.Market Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"../../storage/LibCommonNftOrdersStorage.sol\\\";\\nimport \\\"../../storage/LibERC721OrdersStorage.sol\\\";\\nimport \\\"../interfaces/IBasicERC721OrdersFeature.sol\\\";\\n\\n\\n/// @dev Feature for interacting with ERC721 orders.\\ncontract BasicERC721OrdersFeature is IBasicERC721OrdersFeature {\\n\\n    uint256 internal constant MASK_176 = (1 << 176) - 1;\\n    uint256 internal constant MASK_160 = (1 << 160) - 1;\\n    uint256 internal constant MASK_72 = (1 << 72) - 1;\\n    uint256 internal constant MASK_64 = (1 << 64) - 1;\\n    uint256 internal constant MASK_32 = (1 << 32) - 1;\\n    uint256 internal constant MASK_16 = (1 << 16) - 1;\\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // Storage ID.\\n    uint256 constant STORAGE_ID_COMMON_NFT_ORDERS = 4 << 128;\\n    uint256 constant STORAGE_ID_ERC721_ORDERS = 5 << 128;\\n\\n    // Topic for ERC721SellOrderFilled.\\n    bytes32 internal constant _TOPIC_SELL_ORDER_FILLED = 0x9c248aa1a265aa616f707b979d57f4529bb63a4fc34dc7fc61fdddc18410f74e;\\n\\n    // keccak256(\\\"\\\"));\\n    bytes32 internal constant _EMPTY_ARRAY_KECCAK256 = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    bytes32 internal constant _NFT_SELL_ORDER_TYPE_HASH = 0xed676c7f3e8232a311454799b1cf26e75b4abc90c9bf06c9f7e8e79fcc7fe14d;\\n    bytes32 internal constant _FEE_TYPE_HASH = 0xe68c29f1b4e8cce0bbcac76eb1334bdc1dc1f293a517c90e9e532340e1e94115;\\n\\n    // keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 internal constant DOMAIN = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    // keccak256(\\\"ElementEx\\\")\\n    bytes32 internal constant NAME = 0x27b14c20196091d9cd90ca9c473d3ad1523b00ddf487a9b7452a8a119a16b98c;\\n    // keccak256(\\\"1.0.0\\\")\\n    bytes32 internal constant VERSION = 0x06c015bd22b4c69690933c1058878ebdfef31f9aaae40bbe86d8a09fe1b2972c;\\n\\n    /// @dev The implementation address of this feature.\\n    address internal immutable _IMPL;\\n\\n    constructor() {\\n        _IMPL = address(this);\\n    }\\n\\n    function fillBasicERC721Order(BasicOrderParameter calldata parameter) external override payable {\\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\\n        address maker;\\n        address taker;\\n        assembly {\\n            // data1 [96 bits(ethAmount) + 160 bits(maker)]\\n            // maker = data1 & MASK_160\\n            maker := and(calldataload(0x4), MASK_160)\\n\\n            // data2 [32 bits(listingTime) + 32 bits(expiryTime) + 32 bits(unused) + 160 bits(taker)]\\n            // taker = data2 & MASK_160\\n            taker := and(calldataload(0x24), MASK_160)\\n            if iszero(taker) {\\n                taker := caller()\\n            }\\n        }\\n\\n        // Check order and update order status.\\n        _checkOrderAndUpdateOrderStatus(maker, parameter.data2, parameter.data3);\\n\\n        // Validate order signature.\\n        bytes32 orderHash = _validateOrderSignature(maker, parameter);\\n\\n        // Transfer the NFT asset to taker.\\n        _transferERC721AssetFrom(parameter.data3, maker, taker, parameter.nftId);\\n\\n        // Transfer ETH to the maker.\\n        _transferEth(parameter.data1);\\n\\n        // The taker pays fees.\\n        if (parameter.fee1 > 0) {\\n            _transferEth(parameter.fee1);\\n        }\\n        if (parameter.fee2 > 0) {\\n            _transferEth(parameter.fee2);\\n        }\\n\\n        // Emit event.\\n        _emitEventSellOrderFilled(taker, orderHash);\\n\\n        // Refund ETH.\\n        assembly {\\n            if eq(selfbalance(), ethBalanceBefore) {\\n                return(0, 0)\\n            }\\n            if gt(selfbalance(), ethBalanceBefore) {\\n                if iszero(call(gas(), caller(), sub(selfbalance(), ethBalanceBefore), 0, 0, 0, 0)) {\\n                    _revertRefundETHFailed()\\n                }\\n                return(0, 0)\\n            }\\n            _revertRefundETHFailed()\\n\\n            function _revertRefundETHFailed() {\\n                // revert(\\\"fillBasicERC721Order: failed to refund ETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002b66696c6c42617369634552433732314f726465723a206661696c6564)\\n                mstore(0x60, 0x20746f20726566756e64204554482e0000000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n        }\\n    }\\n\\n    /// parameter1 [8 bits(revertIfIncomplete) + 88 bits(unused) + 160 bits(nftAddress)]\\n    /// parameter2 [80 bits(taker part1) + 16 bits(feePercentage1) + 160 bits(feeRecipient1)]\\n    /// parameter3 [80 bits(taker part2) + 16 bits(feePercentage2) + 160 bits(feeRecipient2)]\\n    function fillBasicERC721Orders(BasicOrderParameters calldata /* parameters */, BasicOrderItem[] calldata orders) external override payable {\\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\\n        address _impl = _IMPL;\\n        assembly {\\n            // taker = ((parameter2 >> 176) << 80) | (parameter3 >> 176)\\n            let taker := or(shl(80, shr(176, calldataload(0x24))), shr(176, calldataload(0x44)))\\n\\n            // Check fees.\\n            let feePercentage1 := and(shr(160, calldataload(0x24)), MASK_16)\\n            let feePercentage2 := and(shr(160, calldataload(0x44)), MASK_16)\\n            if gt(add(feePercentage1, feePercentage2), 10000) {\\n                _revertFeesPercentageExceedsLimit()\\n            }\\n\\n            // Initialize the someSuccess flag.\\n            mstore(0x120, 0)\\n\\n            // Total fee amount.\\n            let totalFee1\\n            let totalFee2\\n\\n            // selector for delegateCallFillBasicERC721Order(BasicOrderParameter)\\n            mstore(0, 0xcb750fd800000000000000000000000000000000000000000000000000000000)\\n\\n            for {\\n                let offset := orders.offset\\n                let ptrEnd := add(offset, mul(orders.length, 0xa0))\\n            } lt(offset, ptrEnd) {\\n                offset := add(offset, 0xa0 /* 5 * 32 */)\\n            } {\\n                // BasicOrderItem {\\n                //    0x0 address maker;\\n                //    0x20 uint256 extra;\\n                //    0x40 uint256 nftId;\\n                //    0x60 bytes32 r;\\n                //    0x80 bytes32 s;\\n                // }\\n                // extra [96 bits(ethAmount) + 64 bits(nonce) + 8 bits(v) + 24 bits(unused)\\n                //        + 32 bits(listingTime) + 32 bits(expiryTime)]\\n                let extra := calldataload(add(offset, 0x20))\\n\\n                let ethAmount := shr(160, extra)\\n                let feeAmount1 := div(mul(ethAmount, feePercentage1), 10000)\\n                let feeAmount2 := div(mul(ethAmount, feePercentage2), 10000)\\n                ethAmount := sub(ethAmount, add(feeAmount1, feeAmount2))\\n\\n                // data1 [96 bits(ethAmount) + 160 bits(maker)]\\n                // data1 = (ethAmount << 160) | maker\\n                mstore(0x4, or(shl(160, ethAmount), calldataload(offset)))\\n\\n                // data2 [32 bits(listingTime) + 32 bits(expiryTime) + 32 bits(unused) + 160 bits(taker)]\\n                // data2 = ((extra & MASK_64) << 192) | taker\\n                mstore(0x24, or(shl(192, and(extra, MASK_64)), taker))\\n\\n                // data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n                // data3 = (((extra >> 88) & MASK_72) << 184) | (parameters.parameter1 & MASK_160)\\n                mstore(0x44, or(shl(184, and(shr(88, extra), MASK_72)), and(calldataload(0x4), MASK_160)))\\n\\n                // nftId\\n                mstore(0x64, calldataload(add(offset, 0x40)))\\n\\n                // fee1 [96 bits(ethAmount) + 160 bits(recipient)]\\n                // fee1 = (feeAmount1 << 160) | (parameters.parameter2 & MASK_160)\\n                mstore(0x84, or(shl(160, feeAmount1), and(calldataload(0x24), MASK_160)))\\n\\n                // fee2 [96 bits(ethAmount) + 160 bits(recipient)]\\n                // fee2 = (feeAmount2 << 160) | (parameters.parameter3 & MASK_160)\\n                mstore(0xa4, or(shl(160, feeAmount2), and(calldataload(0x44), MASK_160)))\\n\\n                // r\\n                mstore(0xc4, calldataload(add(offset, 0x60)))\\n\\n                // s\\n                mstore(0xe4, calldataload(add(offset, 0x80)))\\n\\n                switch delegatecall(gas(), _impl, 0, 0x104, 0, 0)\\n                case 0 {\\n                    // If failed, check the revertIfIncomplete flag.\\n                    if byte(0, calldataload(0x4)) {\\n                        returndatacopy(0, 0, returndatasize())\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n                default {\\n                    // Success.\\n                    // someSuccess = 1\\n                    mstore(0x120, 1)\\n\\n                    // Update total payable amount.\\n                    totalFee1 := add(totalFee1, feeAmount1)\\n                    totalFee2 := add(totalFee2, feeAmount2)\\n                }\\n            }\\n\\n            // Pay fee1 at one time.\\n            if totalFee1 {\\n                if iszero(call(gas(), and(calldataload(0x24), MASK_160), totalFee1, 0, 0, 0, 0)) {\\n                    _revertTransferETHFailed()\\n                }\\n            }\\n            // Pay fee2 at one time.\\n            if totalFee2 {\\n                if iszero(call(gas(), and(calldataload(0x44), MASK_160), totalFee2, 0, 0, 0, 0)) {\\n                    _revertTransferETHFailed()\\n                }\\n            }\\n\\n            // if (!someSuccess) _revertNoOrderFilled()\\n            if iszero(mload(0x120)) {\\n                _revertNoOrderFilled()\\n            }\\n\\n            // Refund ETH.\\n            if eq(selfbalance(), ethBalanceBefore) {\\n                return(0, 0)\\n            }\\n            if gt(selfbalance(), ethBalanceBefore) {\\n                if iszero(call(gas(), caller(), sub(selfbalance(), ethBalanceBefore), 0, 0, 0, 0)) {\\n                    _revertRefundETHFailed()\\n                }\\n                return(0, 0)\\n            }\\n            _revertRefundETHFailed()\\n\\n            function _revertFeesPercentageExceedsLimit() {\\n                // revert(\\\"fillBasicERC721Orders: total fees percentage exceeds the limit.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000003f66696c6c42617369634552433732314f72646572733a20746f74616c)\\n                mstore(0x60, 0x20666565732070657263656e74616765206578636565647320746865206c696d)\\n                mstore(0x80, 0x69742e0000000000000000000000000000000000000000000000000000000000)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertTransferETHFailed() {\\n                // revert(\\\"fillBasicERC721Orders: failed to transferETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002d66696c6c42617369634552433732314f72646572733a206661696c65)\\n                mstore(0x60, 0x6420746f207472616e736665724554482e000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertNoOrderFilled() {\\n                // revert(\\\"fillBasicERC721Orders: no order filled.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002766696c6c42617369634552433732314f72646572733a206e6f206f72)\\n                mstore(0x60, 0x6465722066696c6c65642e000000000000000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n\\n            function _revertRefundETHFailed() {\\n                // revert(\\\"fillBasicERC721Orders: failed to refund ETH.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000002c66696c6c42617369634552433732314f72646572733a206661696c65)\\n                mstore(0x60, 0x6420746f20726566756e64204554482e00000000000000000000000000000000)\\n                mstore(0x80, 0)\\n                revert(0, 0x84)\\n            }\\n        }\\n    }\\n\\n    // @Note `delegateCallFillBasicERC721Order` is a external function, but must delegatecall from an external exchange,\\n    //        and should not be registered in the external exchange.\\n    function delegateCallFillBasicERC721Order(BasicOrderParameter calldata parameter) external payable {\\n        require(_IMPL != address(this), \\\"BasicOrder: must delegatecall from an external exchange.\\\");\\n\\n        address maker;\\n        address taker;\\n        assembly {\\n            // data1 [96 bits(ethAmount) + 160 bits(maker)]\\n            // maker = data1 & MASK_160\\n            maker := and(calldataload(0x4), MASK_160)\\n\\n            // data2 [32 bits(listingTime) + 32 bits(expiryTime) + 32 bits(unused) + 160 bits(taker)]\\n            // taker = data2 & MASK_160\\n            taker := and(calldataload(0x24), MASK_160)\\n            if iszero(taker) {\\n                taker := caller()\\n            }\\n        }\\n\\n        // Check order and update order status.\\n        _checkOrderAndUpdateOrderStatus(maker, parameter.data2, parameter.data3);\\n\\n        // Validate order signature.\\n        bytes32 orderHash = _validateOrderSignature(maker, parameter);\\n\\n        // Transfer the NFT asset to taker.\\n        _transferERC721AssetFrom(parameter.data3, maker, taker, parameter.nftId);\\n\\n        // Transfer ETH to the maker.\\n        _transferEth(parameter.data1);\\n\\n        // Emit event.\\n        _emitEventSellOrderFilled(taker, orderHash);\\n    }\\n\\n    function _emitEventSellOrderFilled(address taker, bytes32 orderHash) internal {\\n        //struct Fee {\\n        //    address recipient;\\n        //    uint256 amount;\\n        //}\\n        //event ERC721SellOrderFilled(\\n        //    bytes32 orderHash,\\n        //    address maker,\\n        //    address taker,\\n        //    uint256 nonce,\\n        //    address erc20Token,\\n        //    uint256 erc20TokenAmount,\\n        //    Fee[] fees,\\n        //    address erc721Token,\\n        //    uint256 erc721TokenId\\n        //)\\n        assembly {\\n            let data1 := calldataload(0x4)\\n            let data3 := calldataload(0x44)\\n\\n            // orderHash\\n            mstore(0, orderHash)\\n\\n            // data1 [96 bits(ethAmount) + 160 bits(maker)]\\n            // maker = data1 & MASK_160\\n            mstore(0x20, and(data1, MASK_160))\\n\\n            // taker\\n            mstore(0x40, taker)\\n\\n            // data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n            // nonce = data3 >> 192\\n            mstore(0x60, shr(192, data3))\\n\\n            // erc20Token = NATIVE_TOKEN_ADDRESS\\n            mstore(0x80, NATIVE_TOKEN_ADDRESS)\\n\\n            // fees.offset\\n            mstore(0xc0, 0x120 /* 9 * 32 */)\\n\\n            // data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n            // erc721Token = data3 & MASK_160\\n            mstore(0xe0, and(data3, MASK_160))\\n\\n            // erc721TokenId = parameter.nftId\\n            // parameter.nftId.offset = 0x64\\n            calldatacopy(0x100, 0x64, 0x20)\\n\\n            // data1 [96 bits(ethAmount) + 160 bits(maker)]\\n            // erc20TokenAmount = data1 >> 160\\n            let erc20TokenAmount := shr(160, data1)\\n\\n            let fee1 := calldataload(0x84)\\n            switch fee1\\n            case 0 {\\n                let fee2 := calldataload(0xa4)\\n                switch fee2\\n                case 0 {\\n                    // No fees.\\n                    // erc20TokenAmount\\n                    mstore(0xa0, erc20TokenAmount)\\n                    // fees.length = 0\\n                    mstore(0x120, 0)\\n                    // emit event\\n                    log1(0, 0x140, _TOPIC_SELL_ORDER_FILLED)\\n                }\\n                default {\\n                    // Only fee2.\\n                    // erc20TokenAmount\\n                    mstore(0xa0, add(erc20TokenAmount, shr(160, fee2)))\\n                    // fees.length = 1\\n                    mstore(0x120, 1)\\n                    // fee2.recipient\\n                    mstore(0x140, and(fee2, MASK_160))\\n                    // fee2.amount\\n                    mstore(0x160, shr(160, fee2))\\n                    // emit event\\n                    log1(0, 0x180, _TOPIC_SELL_ORDER_FILLED)\\n                }\\n            }\\n            default {\\n                // fee1.recipient\\n                mstore(0x140, and(fee1, MASK_160))\\n                // fee1.amount\\n                mstore(0x160, shr(160, fee1))\\n                // erc20TokenAmount += fee1.amount\\n                erc20TokenAmount := add(erc20TokenAmount, mload(0x160))\\n\\n                let fee2 := calldataload(0xa4)\\n                switch fee2\\n                case 0 {\\n                    // Only fee1.\\n                    // Store erc20TokenAmount to memory.\\n                    mstore(0xa0, erc20TokenAmount)\\n                    // fees.length = 1\\n                    mstore(0x120, 1)\\n                    // emit event\\n                    log1(0, 0x180, _TOPIC_SELL_ORDER_FILLED)\\n                }\\n                default {\\n                    // Fee1 and fee2.\\n                    // fee2.recipient\\n                    mstore(0x180, and(fee2, MASK_160))\\n                    // fee2.amount\\n                    mstore(0x1a0, shr(160, fee2))\\n                    // erc20TokenAmount\\n                    mstore(0xa0, add(erc20TokenAmount, mload(0x1a0)))\\n                    // fees.length = 2\\n                    mstore(0x120, 2)\\n                    // emit event\\n                    log1(0, 0x1c0, _TOPIC_SELL_ORDER_FILLED)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @param data2 [32 bits(listingTime) + 32 bits(expiryTime) + 32 bits(unused) + 160 bits(taker)]\\n    /// @param data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n    function _checkOrderAndUpdateOrderStatus(address maker, uint256 data2, uint256 data3) internal {\\n        assembly {\\n            // Check for listingTime.\\n            // require((data2 >> 224) <= block.timestamp)\\n            if gt(shr(224, data2), timestamp()) {\\n                // revert(\\\"Failed to check for listingTime.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x000000204661696c656420746f20636865636b20666f72206c697374696e6754)\\n                mstore(0x60, 0x696d652e00000000000000000000000000000000000000000000000000000000)\\n                revert(0, 0x64)\\n            }\\n\\n            // Check for expiryTime.\\n            // require((data2 >> 192) & MASK_32 > block.timestamp)\\n            if iszero(gt(and(shr(192, data2), MASK_32), timestamp())) {\\n                // revert(\\\"Failed to check for expiryTime.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000001f4661696c656420746f20636865636b20666f72206578706972795469)\\n                mstore(0x60, 0x6d652e0000000000000000000000000000000000000000000000000000000000)\\n                revert(0, 0x64)\\n            }\\n\\n            // Note: nonceRange = nonce >> 8\\n            // Note: nonceVector = LibERC721OrdersStorage.orderStatusByMaker[maker][nonceRange]\\n            // Note: nonceVector.slot = keccak256(nonceRange, keccak256(maker, STORAGE_ID_ERC721_ORDERS))\\n\\n            // memory[0x20 - 0x40] keccak256(maker, STORAGE_ID_ERC721_ORDERS)\\n            mstore(0, maker)\\n            mstore(0x20, STORAGE_ID_ERC721_ORDERS)\\n            mstore(0x20, keccak256(0, 0x40))\\n\\n            // memory[0 - 0x20] nonceRange\\n            // nonceRange = nonce >> 8 = data3 >> 200\\n            mstore(0, shr(200, data3))\\n\\n            // nonceVector.slot = keccak256(nonceRange, keccak256(maker, STORAGE_ID_ERC721_ORDERS))\\n            let nonceVectorSlot := keccak256(0, 0x40)\\n\\n            // Load nonceVector from storage.\\n            let nonceVector := sload(nonceVectorSlot)\\n\\n            // data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n            // nonceMask = 1 << (nonce & 0xff) = 1 << byte(7, data3)\\n            let nonceMask := shl(byte(7, data3), 1)\\n\\n            // Check `nonceVector` state variable to see if the order has been cancelled or previously filled.\\n            if and(nonceVector, nonceMask) {\\n                // revert(\\\"Failed to check order status.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000001d4661696c656420746f20636865636b206f7264657220737461747573)\\n                mstore(0x60, 0x2e00000000000000000000000000000000000000000000000000000000000000)\\n                revert(0, 0x64)\\n            }\\n\\n            // Update order status bit vector to indicate that the given order has been cancelled/filled by setting the designated bit to 1.\\n            sstore(nonceVectorSlot, or(nonceVector, nonceMask))\\n        }\\n    }\\n\\n    function _validateOrderSignature(address maker, BasicOrderParameter calldata parameter) internal view returns(bytes32 orderHash) {\\n        // hashNonce = LibCommonNftOrdersStorage.getStorage().hashNonces[maker]\\n        // hashNonce.slot = keccak256(abi.encode(maker, STORAGE_ID_COMMON_NFT_ORDERS))\\n        uint256 hashNonce;\\n        assembly {\\n            mstore(0, maker)\\n            mstore(0x20, STORAGE_ID_COMMON_NFT_ORDERS)\\n            hashNonce := sload(keccak256(0, 0x40))\\n        }\\n\\n        // Get order hash.\\n        orderHash = _getEIP712Hash(\\n            _getStructHash(\\n                _getFeesHash(\\n                    parameter.fee1,\\n                    parameter.fee2\\n                ),\\n                hashNonce\\n            )\\n        );\\n\\n        // Must reset memory status before the `require` sentence.\\n        assembly {\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0)\\n        }\\n\\n        // Check for the order maker.\\n        require(maker != address(0), \\\"Invalid maker: order.maker should not be address(0).\\\");\\n\\n        // Validate order signature.\\n        // data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n        // v = uint8(parameter.data3 >> 184)\\n        require(maker == ecrecover(orderHash, uint8(parameter.data3 >> 184), parameter.r, parameter.s), \\\"Failed to validate signature.\\\");\\n    }\\n\\n    function _getEIP712Hash(bytes32 structHash) internal view returns (bytes32 eip712Hash) {\\n        assembly {\\n            // EIP712_DOMAIN_SEPARATOR = keccak256(abi.encode(\\n            //     DOMAIN,\\n            //     NAME,\\n            //     VERSION,\\n            //     block.chainid,\\n            //     address(this)\\n            // ));\\n            mstore(0, DOMAIN)\\n            mstore(0x20, NAME)\\n            mstore(0x40, VERSION)\\n            mstore(0x60, chainid())\\n            mstore(0x80, address())\\n\\n            // eip712Hash = keccak256(abi.encodePacked(\\n            //     hex\\\"1901\\\",\\n            //     EIP712_DOMAIN_SEPARATOR,\\n            //     structHash\\n            // ));\\n            mstore(0xa0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n            mstore(0xa2, keccak256(0, 0xa0))\\n            mstore(0xc2, structHash)\\n            eip712Hash := keccak256(0xa0, 0x42)\\n        }\\n    }\\n\\n    function _getStructHash(bytes32 feesHash, uint256 hashNonce) internal pure returns (bytes32 structHash) {\\n        // Hash in place, equivalent to:\\n        // structHash = keccak256(abi.encode(\\n        //     _NFT_SELL_ORDER_TYPE_HASH,\\n        //     order.maker,\\n        //     order.taker,\\n        //     order.expiry,\\n        //     order.nonce,\\n        //     order.erc20Token,\\n        //     order.erc20TokenAmount,\\n        //     feesHash,\\n        //     order.nft,\\n        //     order.nftId,\\n        //     hashNonce\\n        // ));\\n        assembly {\\n            let data1 := calldataload(0x4)\\n            let data3 := calldataload(0x44)\\n\\n            // _NFT_SELL_ORDER_TYPE_HASH\\n            mstore(0, _NFT_SELL_ORDER_TYPE_HASH)\\n\\n            // data1 [96 bits(ethAmount) + 160 bits(maker)]\\n            // order.maker = (data1 & MASK_160)\\n            mstore(0x20, and(data1, MASK_160))\\n\\n            // order.taker = address(0)\\n            mstore(0x40, 0)\\n\\n            // data2 [32 bits(listingTime) + 32 bits(expiryTime) + 32 bits(unused) + 160 bits(taker)]\\n            // order.expiry = [32 bits(listingTime) + 32 bits(expiryTime)] = data2 >> 192\\n            mstore(0x60, shr(192, calldataload(0x24)))\\n\\n            // data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n            // order.nonce = data3 >> 192\\n            mstore(0x80, shr(192, data3))\\n\\n            // order.erc20Token = NATIVE_TOKEN_ADDRESS\\n            mstore(0xa0, NATIVE_TOKEN_ADDRESS)\\n\\n            // data1 [96 bits(ethAmount) + 160 bits(maker)]\\n            // order.erc20TokenAmount = data1 >> 160\\n            mstore(0xc0, shr(160, data1))\\n\\n            // feesHash\\n            mstore(0xe0, feesHash)\\n\\n            // data3 [64 bits(nonce) + 8 bits(v) + 24 bits(unused) + 160 bits(nftAddress)]\\n            // order.nft = data3 & MASK_160\\n            mstore(0x100, and(data3, MASK_160))\\n\\n            // order.nftId = parameter.nftId\\n            // parameter.nftId.offset = 0x64\\n            calldatacopy(0x120, 0x64, 0x20)\\n\\n            // hashNonce\\n            mstore(0x140, hashNonce)\\n\\n            // Get structHash\\n            structHash := keccak256(0, 0x160 /* 11 * 32 */ )\\n        }\\n    }\\n\\n    function _getFeesHash(uint256 fee1, uint256 fee2) internal pure returns (bytes32 feesHash) {\\n        assembly {\\n            switch fee1\\n            case 0 {\\n                switch fee2\\n                case 0 {\\n                    // No fees.\\n                    feesHash := _EMPTY_ARRAY_KECCAK256\\n                }\\n                default {\\n                    // Only fee2.\\n                    mstore(0, _FEE_TYPE_HASH)\\n                    // fee2.recipient\\n                    mstore(0x20, and(MASK_160, fee2))\\n                    // fee2.amount\\n                    mstore(0x40, shr(160, fee2))\\n                    // fee2.feeData\\n                    mstore(0x60, _EMPTY_ARRAY_KECCAK256)\\n                    // Calculate and store feeStructHash2\\n                    mstore(0x80, keccak256(0, 0x80))\\n                    // feesHash = keccak256(feeStructHash2)\\n                    feesHash := keccak256(0x80, 0x20)\\n                }\\n            }\\n            default {\\n                mstore(0, _FEE_TYPE_HASH)\\n                // fee1.recipient\\n                mstore(0x20, and(MASK_160, fee1))\\n                // fee1.amount\\n                mstore(0x40, shr(160, fee1))\\n                // fee1.feeData\\n                mstore(0x60, _EMPTY_ARRAY_KECCAK256)\\n                // Calculate and store feeStructHash1\\n                mstore(0x80, keccak256(0, 0x80))\\n\\n                switch fee2\\n                case 0 {\\n                    // Only fee1.\\n                    // feesHash = keccak256(feeStructHash1)\\n                    feesHash := keccak256(0x80, 0x20)\\n                }\\n                default {\\n                    // Fee1 and fee2.\\n                    // fee2.recipient\\n                    mstore(0x20, and(MASK_160, fee2))\\n                    // fee2.amount\\n                    mstore(0x40, shr(160, fee2))\\n                    // Calculate and store feeStructHash2\\n                    mstore(0xa0, keccak256(0, 0x80))\\n                    // feesHash = keccak256(feeStructHash1 + feeStructHash2)\\n                    feesHash := keccak256(0x80, 0x40)\\n                }\\n            }\\n        }\\n    }\\n\\n    function _transferERC721AssetFrom(uint256 nftAddress, address from, address to, uint256 nftId) internal {\\n        assembly {\\n            let token := and(nftAddress, MASK_160)\\n            if iszero(extcodesize(token)) {\\n                // revert(\\\"invalid erc721 address\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x00000016696e76616c6964206572633732312061646472657373000000000000)\\n                mstore(0x60, 0)\\n                revert(0, 0x64)\\n            }\\n\\n            // selector for transferFrom(address,address,uint256)\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(0x04, from)\\n            mstore(0x24, to)\\n            mstore(0x44, nftId)\\n            if iszero(call(gas(), token, 0, 0, 0x64, 0, 0)) {\\n                // revert(\\\"Failed to transfer ERC721.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x0000001a4661696c656420746f207472616e73666572204552433732312e0000)\\n                mstore(0x60, 0)\\n                revert(0, 0x64)\\n            }\\n        }\\n    }\\n\\n    /// @param data [96 bits(ethAmount) + 160 bits(recipient)]\\n    function _transferEth(uint256 data) internal {\\n        assembly {\\n            if shr(160, data) {\\n                if iszero(call(gas(), and(data, MASK_160), shr(160, data), 0, 0, 0, 0)) {\\n                    // revert(\\\"Failed to transfer ETH.\\\")\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x40, 0x000000174661696c656420746f207472616e73666572204554482e0000000000)\\n                    mstore(0x60, 0)\\n                    revert(0, 0x64)\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/storage/LibCommonNftOrdersStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Copyright 2022 Element.Market\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"./LibStorage.sol\\\";\\n\\n\\nlibrary LibCommonNftOrdersStorage {\\n\\n    /// @dev Storage bucket for this feature.\\n    struct Storage {\\n        /* Track per-maker nonces that can be incremented by the maker to cancel orders in bulk. */\\n        // The current nonce for the maker represents the only valid nonce that can be signed by the maker\\n        // If a signature was signed with a nonce that's different from the one stored in nonces, it\\n        // will fail validation.\\n        mapping(address => uint256) hashNonces;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        uint256 storageSlot = LibStorage.STORAGE_ID_COMMON_NFT_ORDERS;\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor.slot := storageSlot }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/storage/LibERC721OrdersStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Modifications Copyright 2022 Element.Market\\n  Copyright 2020 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"./LibStorage.sol\\\";\\n\\n\\n/// @dev Storage helpers for `ERC721OrdersFeature`.\\nlibrary LibERC721OrdersStorage {\\n\\n    /// @dev Storage bucket for this feature.\\n    struct Storage {\\n        // maker => nonce range => order status bit vector\\n        mapping(address => mapping(uint248 => uint256)) orderStatusByMaker;\\n        // order hash => preSigned\\n        mapping(bytes32 => uint256) preSigned;\\n        // order hash => filledAmount\\n        mapping(bytes32 => uint128) filledAmount;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        uint256 storageSlot = LibStorage.STORAGE_ID_ERC721_ORDERS;\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor.slot := storageSlot }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zero-ex/src/storage/LibStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n/*\\n\\n  Modifications Copyright 2022 Element.Market\\n  Copyright 2020 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.8.17;\\n\\n\\n/// @dev Common storage helpers\\nlibrary LibStorage {\\n\\n    /// @dev What to bit-shift a storage ID by to get its slot.\\n    ///      This gives us a maximum of 2**128 inline fields in each bucket.\\n    uint256 constant STORAGE_ID_PROXY = 1 << 128;\\n    uint256 constant STORAGE_ID_SIMPLE_FUNCTION_REGISTRY = 2 << 128;\\n    uint256 constant STORAGE_ID_OWNABLE = 3 << 128;\\n    uint256 constant STORAGE_ID_COMMON_NFT_ORDERS = 4 << 128;\\n    uint256 constant STORAGE_ID_ERC721_ORDERS = 5 << 128;\\n    uint256 constant STORAGE_ID_ERC1155_ORDERS = 6 << 128;\\n    uint256 constant STORAGE_ID_REENTRANCY_GUARD = 7 << 128;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee2\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IBasicERC721OrdersFeature.BasicOrderParameter\",\"name\":\"parameter\",\"type\":\"tuple\"}],\"name\":\"delegateCallFillBasicERC721Order\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee2\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IBasicERC721OrdersFeature.BasicOrderParameter\",\"name\":\"parameter\",\"type\":\"tuple\"}],\"name\":\"fillBasicERC721Order\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"parameter1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parameter2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parameter3\",\"type\":\"uint256\"}],\"internalType\":\"struct IBasicERC721OrdersFeature.BasicOrderParameters\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"extra\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IBasicERC721OrdersFeature.BasicOrderItem[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"fillBasicERC721Orders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "BasicERC721OrdersFeature", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}