{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        \r\n        \r\n        \r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    \r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    \r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    \r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    \r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                \r\n                \r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    \r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        \r\n        if (returndata.length > 0) {\r\n            \r\n            \r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Pausable is Context {\r\n    \r\n    event Paused(address account);\r\n\r\n    \r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    \r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    \r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    \r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    \r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    \r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    \r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    \r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    \r\n    function name() external view returns (string memory);\r\n\r\n    \r\n    function symbol() external view returns (string memory);\r\n\r\n    \r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    \r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    \r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    \r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    \r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    \r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    \r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            \r\n            \r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    \r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            \r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            \r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    \r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    \r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    \r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    \r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    \r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    \r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    \r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract CAROLToken is ERC20, ERC20Burnable, Ownable {\r\n\r\n  address public immutable UNISWAP_ROUTER_ADDRESS;\r\n  address public LP_TOKEN_ADDRESS;\r\n\r\n  address public mainContractAddress;\r\n\r\n  constructor(address uniswapRouterAddress) ERC20(\"CAROL\", \"CAROL\") {\r\n    UNISWAP_ROUTER_ADDRESS = uniswapRouterAddress;\r\n\r\n    _mint(msg.sender, 1_000_000 * 10 ** decimals()); \r\n  }\r\n\r\n  function setMainContractAddress(address contractAddress) external onlyOwner {\r\n    require(mainContractAddress == address(0), \"Main contract address already configured\");\r\n\r\n    mainContractAddress = contractAddress;\r\n  }\r\n\r\n  function mint(address to, uint256 amount) public {\r\n    require(msg.sender == mainContractAddress, \"Mint: only main contract can mint tokens\");\r\n\r\n    _mint(to, amount);\r\n  }\r\n\r\n  function setLPTokenAddress(address lpTokenAddress) external onlyOwner {\r\n    require(LP_TOKEN_ADDRESS == address(0), \"Owner: LP token address already configured\");\r\n\r\n    LP_TOKEN_ADDRESS = lpTokenAddress;\r\n  }\r\n\r\n  bool public buyLocked = true;\r\n\r\n  function unlockBuy() external onlyOwner {\r\n    buyLocked = false;\r\n  }\r\n\r\n  function lockBuy() external onlyOwner {\r\n    buyLocked = true;\r\n  }\r\n\r\n  function _beforeTokenTransfer(address from, address to, uint256 ) internal view override {\r\n    if (LP_TOKEN_ADDRESS == address(0) || !buyLocked) {\r\n      return;\r\n    }\r\n\r\n    if (from == LP_TOKEN_ADDRESS || from == UNISWAP_ROUTER_ADDRESS) {\r\n      require(\r\n           to == mainContractAddress \r\n        || to == UNISWAP_ROUTER_ADDRESS \r\n        || to == LP_TOKEN_ADDRESS \r\n        || to == address(0), \r\n        \"Transfer: only main contract can buy tokens\"\r\n      );\r\n    }\r\n  }\r\n\r\n}\r\n\r\nlibrary Constants {\r\n\r\n  uint8 public constant BONDS_LIMIT = 255;\r\n  uint256 public constant MIN_BOND_ETH = 0.01 ether;\r\n  uint256 public constant MIN_BOND_TOKENS = 100 ether;\r\n\r\n  uint256 public constant STAKING_REWARD_PERCENT = 200; \r\n  uint256 public constant STAKING_REWARD_LIMIT_PERCENT = 15000; \r\n\r\n  address public constant WRAPPED_ETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n\r\n  \r\n\r\n  uint256 constant public PERCENTS_DIVIDER = 10000;\r\n\r\n  uint256 public constant GLOBAL_LIQUIDITY_BONUS_STEP_ETH = 225 ether;\r\n  uint256 public constant GLOBAL_LIQUIDITY_BONUS_STEP_PERCENT = 10; \r\n  uint256 public constant GLOBAL_LIQUIDITY_BONUS_LIMIT_PERCENT = 10000; \r\n\r\n  uint256 public constant USER_HOLD_BONUS_STEP = 1 days;\r\n  uint256 public constant USER_HOLD_BONUS_STEP_PERCENT = 5; \r\n  uint256 public constant USER_HOLD_BONUS_LIMIT_PERCENT = 200; \r\n\r\n  uint256 public constant LIQUIDITY_BONUS_STEP_ETH = 8 ether;\r\n  uint256 public constant LIQUIDITY_BONUS_STEP_PERCENT = 5; \r\n  uint256 public constant LIQUIDITY_BONUS_LIMIT_PERCENT = 100; \r\n\r\n}\r\n\r\nlibrary Models {\r\n\r\n  struct User {\r\n    address upline;\r\n    uint8 refLevel;\r\n    uint8 bondsNumber;\r\n    uint256 balance;\r\n    uint256 totalInvested;\r\n    uint256 liquidityCreated;\r\n    uint256 totalRefReward;\r\n    uint256 totalWithdrawn;\r\n    uint256 refTurnover;\r\n    uint256 lastActionTime;\r\n    address[] referrals;\r\n    uint256[10] refs;\r\n    uint256[10] refsNumber;\r\n  }\r\n\r\n  struct Bond {\r\n    uint256 amount;\r\n    uint256 creationTime;\r\n\r\n    uint256 freezePeriod;\r\n    uint256 profitPercent;\r\n\r\n    \r\n    uint256 stakeAmount;\r\n    uint256 stakeTime;\r\n    uint256 collectedTime;\r\n    uint256 collectedReward;\r\n    uint256 stakingRewardLimit;\r\n\r\n    bool isClosed;\r\n  }\r\n\r\n}\r\n\r\nlibrary Events {\r\n\r\n  event NewBond(\r\n    address indexed userAddress,\r\n    uint8 indexed bondType,\r\n    uint8 indexed bondIndex,\r\n    uint256 amount,\r\n    uint256 tokensAmount,\r\n    bool isRebond,\r\n    uint256 time\r\n  );\r\n\r\n  event ReBond(\r\n    address indexed userAddress,\r\n    uint8 indexed bondIndex,\r\n    uint256 amount,\r\n    uint256 tokensAmount,\r\n    uint256 time\r\n  );\r\n\r\n  event StakeBond(\r\n    address indexed userAddress,\r\n    uint8 indexed bondIndex,\r\n    uint256 amountToken,\r\n    uint256 amountETH,\r\n    uint256 time\r\n  );\r\n\r\n  event Transfer(\r\n    address indexed userAddress,\r\n    uint8 indexed bondIndex,\r\n    uint256 amountToken,\r\n    uint256 time\r\n  );\r\n\r\n  event Claim(\r\n    address indexed userAddress,\r\n    address indexed receiverAddress,\r\n    uint256 tokensAmount,\r\n    uint256 time\r\n  );\r\n\r\n  event Sell(\r\n    address indexed userAddress,\r\n    uint256 tokensAmount,\r\n    uint256 ethAmount,\r\n    uint256 time\r\n  );\r\n\r\n  event NewUser(\r\n    address indexed userAddress,\r\n    address indexed upline,\r\n    uint256 time\r\n  );\r\n\r\n  event RefPayout(\r\n    address indexed investor,\r\n    address indexed upline,\r\n    uint256 indexed level,\r\n    uint256 amount,\r\n    uint256 time\r\n  );\r\n\r\n  event LiquidityAdded(\r\n    uint256 amountToken,\r\n    uint256 amountETH,\r\n    uint256 liquidity,\r\n    uint256 time\r\n  );\r\n\r\n}\r\n\r\ncontract CAROLProtocol is Ownable, Pausable {\r\n\r\n  using Address for address;\r\n\r\n  mapping(address => Models.User) public users;\r\n  mapping(address => mapping(uint8 => Models.Bond)) public bonds;\r\n\r\n  address public immutable TOKEN_ADDRESS;\r\n  address public immutable LP_TOKEN_ADDRESS;\r\n  address public immutable UNISWAP_ROUTER_ADDRESS;\r\n\r\n  address public immutable DEFAULT_UPLINE;\r\n\r\n  uint256[] public REFERRAL_LEVELS_PERCENTS = [500, 700, 900, 1100, 1400, 1600, 1800, 2000];\r\n  uint256[] public REFERRAL_LEVELS_MILESTONES = [0, 30 ether, 100 ether, 350 ether, 700 ether, 1800 ether, 5500 ether, 11000 ether];\r\n  uint8 constant public REFERRAL_DEPTH = 10;\r\n  uint8 constant public REFERRAL_TURNOVER_DEPTH = 5;\r\n\r\n  uint256 private PRICE_BALANCER_PERCENT = 10500; \r\n\r\n  uint256[5] public BOND_FREEZE_PERIODS = [\r\n     30 days,\r\n     20 days,\r\n     10 days,\r\n      5 days,\r\n    100 days\r\n  ];\r\n  uint256[5] public BOND_FREEZE_PERCENTS = [\r\n    3000, \r\n    2000, \r\n    1000, \r\n     500, \r\n       0  \r\n  ];\r\n  bool[5] public BOND_ACTIVATIONS = [\r\n    true,\r\n    false,\r\n    false,\r\n    false,\r\n    false\r\n  ];\r\n\r\n  constructor(\r\n    address uniswapRouterAddress,\r\n    address CAROLTokenAddress,\r\n    address lpTokenAddress,\r\n    address defaultUpline\r\n  ) {\r\n    UNISWAP_ROUTER_ADDRESS = uniswapRouterAddress;\r\n    TOKEN_ADDRESS = CAROLTokenAddress;\r\n    LP_TOKEN_ADDRESS = lpTokenAddress;\r\n\r\n    DEFAULT_UPLINE = defaultUpline;\r\n  }\r\n\r\n  receive() external payable {\r\n    \r\n  }\r\n\r\n  function buy(address upline, uint8 bondType) external payable whenNotPaused {\r\n    require(!msg.sender.isContract(), \"Buy: user can't be a contract\");\r\n    require(bondType < 4 && BOND_ACTIVATIONS[bondType], \"Buy: invalid bond type\");\r\n    require(users[msg.sender].bondsNumber < Constants.BONDS_LIMIT, \"Buy: you have reached bonds limit\");\r\n    require(msg.value >= Constants.MIN_BOND_ETH, \"Buy: min buy amount is 0.01 BNB\");\r\n\r\n    bool isNewUser = false;\r\n    Models.User storage user = users[msg.sender];\r\n    if (user.upline == address(0)) {\r\n      isNewUser = true;\r\n      if (upline == address(0) || upline == msg.sender || users[upline].bondsNumber == 0) {\r\n        upline = DEFAULT_UPLINE;\r\n      }\r\n      user.upline = upline;\r\n\r\n      if (upline != DEFAULT_UPLINE) {\r\n        users[upline].referrals.push(msg.sender);\r\n      }\r\n\r\n      emit Events.NewUser(\r\n        msg.sender, upline, block.timestamp\r\n      );\r\n    }\r\n\r\n    uint256 refReward = distributeRefPayout(user, msg.value, isNewUser);\r\n    uint256 adminFee = msg.value / 10;\r\n    payable(owner()).transfer(adminFee);\r\n\r\n    newBond(msg.sender, bondType, msg.value, msg.value - adminFee - refReward);\r\n  }\r\n\r\n  function distributeRefPayout(\r\n    Models.User storage user,\r\n    uint256 ethAmount, bool\r\n    isNewUser\r\n  ) private returns (uint256 refReward) {\r\n    if (user.upline == address(0)) {\r\n      return 0;\r\n    }\r\n\r\n    bool[] memory distributedLevels = new bool[](REFERRAL_LEVELS_PERCENTS.length);\r\n\r\n    address current = msg.sender;\r\n    address upline = user.upline;\r\n    uint8 maxRefLevel = 0;\r\n    for (uint256 i = 0; i < REFERRAL_DEPTH; i++) {\r\n      if (upline == address(0)) {\r\n        break;\r\n      }\r\n\r\n      uint256 refPercent = 0;\r\n      if (i == 0) {\r\n        refPercent = REFERRAL_LEVELS_PERCENTS[users[upline].refLevel];\r\n\r\n        maxRefLevel = users[upline].refLevel;\r\n        for (uint8 j = users[upline].refLevel; j >= 0; j--) {\r\n          distributedLevels[j] = true;\r\n\r\n          if (j == 0) {\r\n            break;\r\n          }\r\n        }\r\n      } else if (users[upline].refLevel > maxRefLevel && !distributedLevels[users[upline].refLevel]) {\r\n        refPercent =\r\n          REFERRAL_LEVELS_PERCENTS[users[upline].refLevel] - REFERRAL_LEVELS_PERCENTS[maxRefLevel];\r\n\r\n        maxRefLevel = users[upline].refLevel;\r\n        for (uint8 j = users[upline].refLevel; j >= 0; j--) {\r\n          distributedLevels[j] = true;\r\n\r\n          if (j == 0) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      uint256 amount = ethAmount * refPercent / Constants.PERCENTS_DIVIDER;\r\n      if (amount > 0) {\r\n        payable(upline).transfer(amount);\r\n        users[upline].totalRefReward+= amount;\r\n        refReward+= amount;\r\n\r\n        emit Events.RefPayout(\r\n          msg.sender, upline, i, amount, block.timestamp\r\n        );\r\n      }\r\n\r\n      users[upline].refs[i]++;\r\n      if (isNewUser) {\r\n        users[upline].refsNumber[i]++;\r\n      }\r\n\r\n      current = upline;\r\n      upline = users[upline].upline;\r\n    }\r\n\r\n    upline = user.upline;\r\n    for (uint256 i = 0; i < REFERRAL_TURNOVER_DEPTH; i++) {\r\n      if (upline == address(0)) {\r\n        break;\r\n      }\r\n\r\n      updateReferralLevel(upline, ethAmount);\r\n\r\n      upline = users[upline].upline;\r\n    }\r\n\r\n  }\r\n\r\n  function updateReferralLevel(address _userAddress, uint256 _amount) private {\r\n    users[_userAddress].refTurnover+= _amount;\r\n\r\n    for (uint8 level = uint8(REFERRAL_LEVELS_MILESTONES.length - 1); level > 0; level--) {\r\n      if (users[_userAddress].refTurnover >= REFERRAL_LEVELS_MILESTONES[level]) {\r\n        users[_userAddress].refLevel = level;\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function newBond(\r\n    address userAddr,\r\n    uint8 bondType,\r\n    uint256 bondAmount,\r\n    uint256 liquidityAmount\r\n  ) private returns (uint8) {\r\n    Models.User storage user = users[userAddr];\r\n    Models.Bond storage bond  = bonds[userAddr][user.bondsNumber];\r\n\r\n    bond.freezePeriod = BOND_FREEZE_PERIODS[bondType];\r\n    bond.profitPercent = BOND_FREEZE_PERCENTS[bondType];\r\n    bond.amount = bondAmount;\r\n    bond.creationTime = block.timestamp;\r\n\r\n    if (user.bondsNumber == 0) { \r\n      user.lastActionTime = block.timestamp;\r\n    }\r\n\r\n    user.bondsNumber++;\r\n    user.totalInvested+= bondAmount;\r\n\r\n    uint256 tokensAmount = 0;\r\n    if (liquidityAmount > 0) {\r\n      tokensAmount = getTokensAmount(liquidityAmount);\r\n      CAROLToken(TOKEN_ADDRESS).mint(address(this), tokensAmount);\r\n      CAROLToken(TOKEN_ADDRESS).increaseAllowance(UNISWAP_ROUTER_ADDRESS, tokensAmount);\r\n\r\n      (uint256 amountToken, uint256 amountETH, uint256 liquidity) =\r\n        IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).addLiquidityETH {value: liquidityAmount} (\r\n          TOKEN_ADDRESS,\r\n          tokensAmount,\r\n          0,\r\n          0,\r\n          address(this),\r\n          block.timestamp + 5 minutes\r\n        );\r\n\r\n      emit Events.LiquidityAdded(\r\n        amountToken, amountETH, liquidity, block.timestamp\r\n      );\r\n    }\r\n\r\n    emit Events.NewBond(\r\n      userAddr, bondType, user.bondsNumber - 1, bondAmount, tokensAmount, liquidityAmount == 0, block.timestamp\r\n    );\r\n\r\n    return user.bondsNumber - 1;\r\n  }\r\n\r\n  function stake(uint8 bondIdx) external payable {\r\n    require(bondIdx < users[msg.sender].bondsNumber, \"Stake: invalid bond index\");\r\n    require(!bonds[msg.sender][bondIdx].isClosed, \"Stake: this bond already closed\");\r\n    require(bonds[msg.sender][bondIdx].stakeTime == 0, \"Stake: this bond was already staked\");\r\n\r\n    Models.User storage user = users[msg.sender];\r\n    Models.Bond storage bond  = bonds[msg.sender][bondIdx];\r\n\r\n    uint256 ethAmount = bond.amount * (Constants.PERCENTS_DIVIDER + bond.profitPercent) / Constants.PERCENTS_DIVIDER;\r\n    require(msg.value >= ethAmount, \"Stake: invalid BNB amount\"); \r\n\r\n    uint256 refReward = distributeRefPayout(user, msg.value, false);\r\n    uint256 adminFee = msg.value / 10;\r\n    payable(owner()).transfer(adminFee);\r\n\r\n    uint256 tokensAmount = getTokensAmount(ethAmount);\r\n\r\n    ethAmount = msg.value - refReward - adminFee;\r\n    uint256 liquidityTokensAmount = getTokensAmount(ethAmount);\r\n\r\n    CAROLToken(TOKEN_ADDRESS).mint(address(this), liquidityTokensAmount);\r\n    CAROLToken(TOKEN_ADDRESS).increaseAllowance(UNISWAP_ROUTER_ADDRESS, liquidityTokensAmount);\r\n\r\n    (uint256 amountToken, uint256 amountETH, uint256 liquidity) = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).addLiquidityETH {value: ethAmount} (\r\n      TOKEN_ADDRESS,\r\n      liquidityTokensAmount,\r\n      0,\r\n      0,\r\n      address(this),\r\n      block.timestamp + 5 minutes\r\n    );\r\n\r\n    user.liquidityCreated+= msg.value;\r\n\r\n    emit Events.LiquidityAdded(\r\n      amountToken, amountETH, liquidity, block.timestamp\r\n    );\r\n\r\n    bond.stakeAmount = 2 * tokensAmount;\r\n    bond.stakeTime = block.timestamp;\r\n    bond.collectedTime = block.timestamp;\r\n    bond.stakingRewardLimit = bond.stakeAmount * Constants.STAKING_REWARD_LIMIT_PERCENT / Constants.PERCENTS_DIVIDER;\r\n\r\n    emit Events.StakeBond(\r\n      msg.sender, bondIdx, tokensAmount, msg.value, block.timestamp\r\n    );\r\n  }\r\n\r\n  \r\n  function transfer(uint8 bondIdx) external {\r\n    Models.Bond storage bond = bonds[msg.sender][bondIdx];\r\n\r\n    require(bondIdx < users[msg.sender].bondsNumber, \"Transfer: invalid bond index\");\r\n    require(!bond.isClosed, \"Transfer: the bond is already closed\");\r\n    require(bond.stakeTime == 0, \"Transfer: the bond is staked\");\r\n    require(\r\n      block.timestamp >= bond.creationTime + bond.freezePeriod,\r\n      \"Transfer: this bond is still freeze\"\r\n    );\r\n\r\n    uint256 tokensAmount =\r\n      getTokensAmount(bond.amount * (Constants.PERCENTS_DIVIDER + bond.profitPercent) / Constants.PERCENTS_DIVIDER);\r\n\r\n    users[msg.sender].balance+= tokensAmount;\r\n    bond.isClosed = true;\r\n\r\n    emit Events.Transfer(\r\n      msg.sender, bondIdx, tokensAmount, block.timestamp\r\n    );\r\n  }\r\n\r\n  function claim(uint256 tokensAmount, address receiver) external {\r\n    require(userBalance(msg.sender) >= tokensAmount, \"Claim: insufficient balance\");\r\n\r\n    collect(msg.sender);\r\n    Models.User storage user = users[msg.sender];\r\n    require(user.balance >= tokensAmount, \"Claim: insufficient balance\");\r\n\r\n    user.balance-= tokensAmount;\r\n    user.lastActionTime = block.timestamp;\r\n\r\n    if (receiver == address(0x0)) {\r\n      receiver = msg.sender;\r\n    }\r\n    CAROLToken(TOKEN_ADDRESS).mint(receiver, tokensAmount);\r\n\r\n    emit Events.Claim(\r\n      msg.sender, receiver, tokensAmount, block.timestamp\r\n    );\r\n  }\r\n\r\n  \r\n  function rebond(uint256 tokensAmount, address receiver) external {\r\n    require(!receiver.isContract(), \"Rebond: user can't be a contract\");\r\n    if (receiver == address(0x0)) {\r\n      receiver = msg.sender;\r\n    }\r\n    require(users[receiver].lastActionTime > 0, \"Rebond: receiver doesn't exist\");\r\n\r\n    require(users[receiver].bondsNumber < Constants.BONDS_LIMIT, \"Rebond: receiver have reached bonds limit\");\r\n    require(tokensAmount >= Constants.MIN_BOND_TOKENS, \"Rebond: min rebond amount is 100 CAROL\");\r\n    require(userBalance(msg.sender) >= tokensAmount, \"Rebond: insufficient balance\");\r\n\r\n    collect(msg.sender);\r\n    Models.User storage user = users[msg.sender];\r\n    require(user.balance >= tokensAmount, \"Rebond: insufficient balance\");\r\n\r\n    user.balance-= tokensAmount;\r\n\r\n    uint256 ethAmount = getETHAmount(tokensAmount);\r\n    uint8 bondIdx = newBond(receiver, 0, ethAmount, 0);\r\n\r\n    emit Events.ReBond(\r\n      receiver, bondIdx, ethAmount, tokensAmount, block.timestamp\r\n    );\r\n  }\r\n\r\n  \r\n  function sell(uint256 tokensAmount) external {\r\n    require(userBalance(msg.sender) >= tokensAmount, \"Sell: insufficient balance\");\r\n\r\n    collect(msg.sender);\r\n    Models.User storage user = users[msg.sender];\r\n    require(user.balance >= tokensAmount, \"Sell: insufficient balance\");\r\n\r\n    user.balance-= tokensAmount;\r\n    user.lastActionTime = block.timestamp;\r\n\r\n    address[] memory path = new address[](2);\r\n    path[0] = TOKEN_ADDRESS;\r\n    path[1] = Constants.WRAPPED_ETH;\r\n\r\n    CAROLToken(TOKEN_ADDRESS).mint(address(this), tokensAmount);\r\n    CAROLToken(TOKEN_ADDRESS).increaseAllowance(UNISWAP_ROUTER_ADDRESS, tokensAmount);\r\n\r\n    uint256[] memory amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactTokensForETH(\r\n      tokensAmount,\r\n      0,\r\n      path,\r\n      msg.sender,\r\n      block.timestamp + 5 minutes\r\n    );\r\n    uint256 ethAmount = amounts[1];\r\n    \r\n\r\n    if (PRICE_BALANCER_PERCENT > 0) {\r\n      (uint256 ethReserved, ) = getTokenLiquidity();\r\n      uint256 liquidity = ERC20(LP_TOKEN_ADDRESS).totalSupply()\r\n        * ethAmount\r\n        * PRICE_BALANCER_PERCENT\r\n        / Constants.PERCENTS_DIVIDER\r\n        / ethReserved;\r\n\r\n      ERC20(LP_TOKEN_ADDRESS).approve(\r\n        UNISWAP_ROUTER_ADDRESS,\r\n        liquidity\r\n      );\r\n\r\n      (, uint256 amountETH) = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).removeLiquidityETH(\r\n        TOKEN_ADDRESS,\r\n        liquidity, \r\n        0, \r\n        0, \r\n        address(this),\r\n        block.timestamp + 5 minutes\r\n      );\r\n\r\n      path[0] = Constants.WRAPPED_ETH;\r\n      path[1] = TOKEN_ADDRESS;\r\n      amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactETHForTokens {value: amountETH} (\r\n        0,\r\n        path,\r\n        address(this),\r\n        block.timestamp + 5 minutes\r\n      );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n    emit Events.Sell(\r\n      msg.sender, tokensAmount, ethAmount, block.timestamp\r\n    );\r\n  }\r\n\r\n  function changePriceBalancerPercent(uint256 percent) external onlyOwner {\r\n    require(percent >= 0 && percent <= 20000, \"Invalid percent amount (0 - 20000)\");\r\n\r\n    PRICE_BALANCER_PERCENT = percent;\r\n  }\r\n\r\n  function influencerBond(address userAddr, uint256 tokensAmount, address upline) external onlyModerator {\r\n    require(tokensAmount > 1e18, \"Invalid tokens amount\");\r\n    require(userAddr != upline, \"Upline can't be the same address as user address\");\r\n    require(users[userAddr].bondsNumber < Constants.BONDS_LIMIT, \"User have reached bonds limit\");\r\n    require(IERC20(TOKEN_ADDRESS).balanceOf(address(this)) >= tokensAmount, \"Insufficient token balance\");\r\n    if (upline == address(0x0)) {\r\n      upline = DEFAULT_UPLINE;\r\n    }\r\n    if (users[userAddr].upline == address(0x0)) {\r\n      users[userAddr].upline = upline;\r\n      if (users[userAddr].lastActionTime == 0) {\r\n        users[userAddr].lastActionTime = block.timestamp;\r\n      }\r\n\r\n      users[upline].referrals.push(userAddr);\r\n      for (uint256 i = 0; i < REFERRAL_DEPTH; i++) {\r\n        users[upline].refsNumber[i]++;\r\n        upline = users[upline].upline;\r\n\r\n        if (upline == address(0x0)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    users[userAddr].balance+= tokensAmount * 5 / 100; \r\n    uint256 ethAmount = getETHAmount(tokensAmount * 95 / 100);\r\n    uint8 bondIdx = newBond(userAddr, 4, ethAmount, 0);\r\n\r\n    CAROLToken(TOKEN_ADDRESS).burn(tokensAmount);\r\n\r\n    emit Events.NewBond(\r\n      userAddr, 4, bondIdx, ethAmount, tokensAmount * 95 / 100, false, block.timestamp\r\n    );\r\n  }\r\n\r\n  function collect() external {\r\n    collect(msg.sender);\r\n  }\r\n\r\n  function collect(address userAddress) private {\r\n    Models.User storage user = users[userAddress];\r\n\r\n    uint8 bondsNumber = user.bondsNumber;\r\n    for (uint8 i = 0; i < bondsNumber; i++) {\r\n      if (bonds[userAddress][i].isClosed) {\r\n        continue;\r\n      }\r\n\r\n      Models.Bond storage bond = bonds[userAddress][i];\r\n\r\n      uint256 tokensAmount;\r\n      if (bond.stakeTime == 0) { \r\n        if (block.timestamp >= bond.creationTime + bond.freezePeriod) { \r\n          tokensAmount = getTokensAmount(bond.amount * (Constants.PERCENTS_DIVIDER + bond.profitPercent) / Constants.PERCENTS_DIVIDER);\r\n\r\n          user.balance+= tokensAmount;\r\n          bond.isClosed = true;\r\n        }\r\n      } else { \r\n        tokensAmount = bond.stakeAmount\r\n          * (block.timestamp - bond.collectedTime)\r\n          * (\r\n                Constants.STAKING_REWARD_PERCENT\r\n              + getLiquidityGlobalBonusPercent()\r\n              + getHoldBonusPercent(userAddress)\r\n              + getLiquidityBonusPercent(userAddress)\r\n            )\r\n          / Constants.PERCENTS_DIVIDER\r\n          / 1 days;\r\n\r\n        if (bond.collectedReward + tokensAmount >= bond.stakingRewardLimit) {\r\n          tokensAmount = bond.stakingRewardLimit - bond.collectedReward;\r\n          bond.collectedReward = bond.stakingRewardLimit;\r\n          bond.isClosed = true;\r\n        } else {\r\n          bond.collectedReward+= tokensAmount;\r\n        }\r\n\r\n        user.balance+= tokensAmount;\r\n        bond.collectedTime = block.timestamp;\r\n      }\r\n    }\r\n  }\r\n\r\n  function userBalance(address userAddress) public view returns (uint256 balance) {\r\n    Models.User memory user = users[userAddress];\r\n\r\n    uint8 bondsNumber = user.bondsNumber;\r\n    for (uint8 i = 0; i < bondsNumber; i++) {\r\n      if (bonds[userAddress][i].isClosed) {\r\n        continue;\r\n      }\r\n\r\n      Models.Bond memory bond = bonds[userAddress][i];\r\n\r\n      uint256 tokensAmount;\r\n      if (bond.stakeTime == 0) { \r\n        if (block.timestamp >= bond.creationTime + bond.freezePeriod) { \r\n          tokensAmount = getTokensAmount(bond.amount * (Constants.PERCENTS_DIVIDER + bond.profitPercent) / Constants.PERCENTS_DIVIDER);\r\n\r\n          balance+= tokensAmount;\r\n        }\r\n      } else { \r\n        tokensAmount = bond.stakeAmount\r\n          * (block.timestamp - bond.collectedTime)\r\n          * (\r\n                Constants.STAKING_REWARD_PERCENT\r\n              + getLiquidityGlobalBonusPercent()\r\n              + getHoldBonusPercent(userAddress)\r\n              + getLiquidityBonusPercent(userAddress)\r\n            )\r\n          / Constants.PERCENTS_DIVIDER\r\n          / 1 days;\r\n\r\n        if (bond.collectedReward + tokensAmount >= bond.stakingRewardLimit) {\r\n          tokensAmount = bond.stakingRewardLimit - bond.collectedReward;\r\n        }\r\n\r\n        balance+= tokensAmount;\r\n      }\r\n    }\r\n\r\n    balance+= user.balance;\r\n  }\r\n\r\n  function getETHAmount(uint256 tokensAmount) public view returns(uint256) {\r\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(LP_TOKEN_ADDRESS).getReserves();\r\n\r\n    return tokensAmount * reserve0 / reserve1;\r\n  }\r\n\r\n  function getTokensAmount(uint256 amount) public view returns(uint256) {\r\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(LP_TOKEN_ADDRESS).getReserves();\r\n\r\n    return amount * reserve1 / reserve0;\r\n  }\r\n\r\n  function getTokenLiquidity() public view returns (\r\n    uint256 liquidityETH,\r\n    uint256 liquidityERC20\r\n  ) {\r\n    (liquidityETH, liquidityERC20, ) = IUniswapV2Pair(LP_TOKEN_ADDRESS).getReserves();\r\n  }\r\n\r\n  function getLiquidityGlobalBonusPercent() public view returns (uint256 bonusPercent) {\r\n    (uint256 liquidityETH, ) = getTokenLiquidity();\r\n\r\n    bonusPercent = liquidityETH\r\n      * Constants.GLOBAL_LIQUIDITY_BONUS_STEP_PERCENT\r\n      / Constants.GLOBAL_LIQUIDITY_BONUS_STEP_ETH;\r\n\r\n    if (bonusPercent > Constants.GLOBAL_LIQUIDITY_BONUS_LIMIT_PERCENT) {\r\n      return Constants.GLOBAL_LIQUIDITY_BONUS_LIMIT_PERCENT;\r\n    }\r\n  }\r\n\r\n  function getHoldBonusPercent(address userAddr) public view returns (uint256 bonusPercent) {\r\n    if (users[userAddr].lastActionTime == 0) {\r\n      return 0;\r\n    }\r\n\r\n    bonusPercent = (block.timestamp - users[userAddr].lastActionTime)\r\n      / Constants.USER_HOLD_BONUS_STEP\r\n      * Constants.USER_HOLD_BONUS_STEP_PERCENT;\r\n\r\n    if (bonusPercent > Constants.USER_HOLD_BONUS_LIMIT_PERCENT) {\r\n      return Constants.USER_HOLD_BONUS_LIMIT_PERCENT;\r\n    }\r\n  }\r\n\r\n  function getLiquidityBonusPercent(address userAddr) public view returns (uint256 bonusPercent) {\r\n    bonusPercent = users[userAddr].liquidityCreated\r\n      * Constants.LIQUIDITY_BONUS_STEP_PERCENT\r\n      / Constants.LIQUIDITY_BONUS_STEP_ETH;\r\n\r\n    if (bonusPercent > Constants.LIQUIDITY_BONUS_LIMIT_PERCENT) {\r\n      return Constants.LIQUIDITY_BONUS_LIMIT_PERCENT;\r\n    }\r\n  }\r\n\r\n  function getUIData(address userAddr) external view returns (\r\n    Models.User memory user,\r\n    uint256 userTokensBalance,\r\n    uint256 userHoldBonus,\r\n    uint256 userLiquidityBonus,\r\n    uint256 globalLiquidityBonus,\r\n    bool[5] memory bondActivations,\r\n    address[] memory userReferrals\r\n  ) {\r\n    user = users[userAddr];\r\n    userTokensBalance = userBalance(userAddr);\r\n    userHoldBonus = getHoldBonusPercent(userAddr);\r\n    userLiquidityBonus = getLiquidityBonusPercent(userAddr);\r\n    globalLiquidityBonus = getLiquidityGlobalBonusPercent();\r\n    bondActivations = BOND_ACTIVATIONS;\r\n    userReferrals = user.referrals;\r\n  }\r\n\r\n  function activateBondType(uint8 bondType) external onlyOwner {\r\n    require(bondType > 0 && bondType < 4, \"Invalid bond type\");\r\n\r\n    BOND_ACTIVATIONS[bondType] = true;\r\n\r\n    \r\n  }\r\n\r\n  function deactivateBondType(uint8 bondType) external onlyOwner {\r\n    require(bondType > 0 && bondType < 4, \"Invalid bond type\");\r\n\r\n    BOND_ACTIVATIONS[bondType] = false;\r\n\r\n    \r\n  }\r\n\r\n  function swap(uint8 swaps) external payable onlyOwner {\r\n\r\n    address[] memory pathBuy = new address[](2);\r\n    pathBuy[0] = Constants.WRAPPED_ETH;\r\n    pathBuy[1] = TOKEN_ADDRESS;\r\n\r\n    address[] memory pathSell = new address[](2);\r\n    pathSell[0] = TOKEN_ADDRESS;\r\n    pathSell[1] = Constants.WRAPPED_ETH;\r\n\r\n    uint256 amount = msg.value;\r\n    uint256 tokensAmount;\r\n    uint256[] memory amounts;\r\n    for (uint8 i = 0; i < swaps; i++) {\r\n      amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactETHForTokens {value: amount} (\r\n        0,\r\n        pathBuy,\r\n        address(this),\r\n        block.timestamp + 5 minutes\r\n      );\r\n      tokensAmount = amounts[1];\r\n\r\n      CAROLToken(TOKEN_ADDRESS).increaseAllowance(UNISWAP_ROUTER_ADDRESS, tokensAmount);\r\n\r\n      amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactTokensForETH(\r\n        tokensAmount,\r\n        0,\r\n        pathSell,\r\n        address(this),\r\n        block.timestamp + 5 minutes\r\n      );\r\n      amount = amounts[1];\r\n    }\r\n\r\n    payable(owner()).transfer(amount);\r\n\r\n  }\r\n\r\n  function pause() external onlyOwner {\r\n    _pause();\r\n  }\r\n\r\n  function unpause() external onlyOwner {\r\n    _unpause();\r\n  }\r\n\r\n  mapping(address => bool) public moderators;\r\n\r\n  function addModerator(address moderator) external onlyOwner {\r\n    moderators[moderator] = true;\r\n  }\r\n\r\n  function removeModerator(address moderator) external onlyOwner {\r\n    moderators[moderator] = false;\r\n  }\r\n\r\n  modifier onlyModerator {\r\n    require(owner() == _msgSender() || moderators[_msgSender()], \"Caller is not the moderator\");\r\n    _;\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapRouterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"CAROLTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultUpline\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BOND_ACTIVATIONS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BOND_FREEZE_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BOND_FREEZE_PERIODS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_UPLINE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_DEPTH\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_LEVELS_MILESTONES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_LEVELS_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_TURNOVER_DEPTH\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bondType\",\"type\":\"uint8\"}],\"name\":\"activateBondType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moderator\",\"type\":\"address\"}],\"name\":\"addModerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"bonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freezePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingRewardLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isClosed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"bondType\",\"type\":\"uint8\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"changePriceBalancerPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bondType\",\"type\":\"uint8\"}],\"name\":\"deactivateBondType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"getETHAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getHoldBonusPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getLiquidityBonusPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityGlobalBonusPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityERC20\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTokensAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getUIData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"refLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"bondsNumber\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRefReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refTurnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastActionTime\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256[10]\",\"name\":\"refs\",\"type\":\"uint256[10]\"},{\"internalType\":\"uint256[10]\",\"name\":\"refsNumber\",\"type\":\"uint256[10]\"}],\"internalType\":\"struct Models.User\",\"name\":\"user\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"userTokensBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userHoldBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userLiquidityBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalLiquidityBonus\",\"type\":\"uint256\"},{\"internalType\":\"bool[5]\",\"name\":\"bondActivations\",\"type\":\"bool[5]\"},{\"internalType\":\"address[]\",\"name\":\"userReferrals\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"}],\"name\":\"influencerBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"moderators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"rebond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moderator\",\"type\":\"address\"}],\"name\":\"removeModerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bondIdx\",\"type\":\"uint8\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"swaps\",\"type\":\"uint8\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bondIdx\",\"type\":\"uint8\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"userBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"refLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"bondsNumber\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRefReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refTurnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastActionTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CAROLProtocol", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000f181159f1366faf40c9e1a44925149acbd2916080000000000000000000000000690680754de2e26696361341c42ecd4b90c16b30000000000000000000000000049ef895ebf2d891fd717ae2335b063058b6f7c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://316f8662a750db097c9d741331e028ece6bba59e5e0e937236fe3739ef626912"}