{"SourceCode": "pragma solidity >=0.5.0;\r\n\r\nlibrary AddressStringUtil {\r\n    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)\r\n    function toAsciiString(address addr, uint256 len) internal pure returns (string memory) {\r\n        require(len % 2 == 0 && len > 0 && len <= 40, 'AddressStringUtil: INVALID_LEN');\r\n\r\n        bytes memory s = new bytes(len);\r\n        uint256 addrNum = uint256(addr);\r\n        for (uint256 i = 0; i < len / 2; i++) {\r\n            // shift right and truncate all but the least significant byte to extract the byte at position 19-i\r\n            uint8 b = uint8(addrNum >> (8 * (19 - i)));\r\n            // first hex character is the most significant 4 bits\r\n            uint8 hi = b >> 4;\r\n            // second hex character is the least significant 4 bits\r\n            uint8 lo = b - (hi << 4);\r\n            s[2 * i] = char(hi);\r\n            s[2 * i + 1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    // hi and lo are only 4 bits and between 0 and 16\r\n    // this method converts those values to the unicode/ascii code point for the hex representation\r\n    // uses upper case for the characters\r\n    function char(uint8 b) private pure returns (bytes1 c) {\r\n        if (b < 10) {\r\n            return bytes1(b + 0x30);\r\n        } else {\r\n            return bytes1(b + 0x37);\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity >=0.5.0;\r\n\r\n// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32\r\n// this library will always produce a string symbol to represent the token\r\nlibrary SafeERC20Namer {\r\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint256 charCount = 0;\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            bytes1 char = x[j];\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    // assumes the data is in position 2\r\n    function parseStringData(bytes memory b) private pure returns (string memory) {\r\n        uint256 charCount = 0;\r\n        // first parse the charCount out of the data\r\n        for (uint256 i = 32; i < 64; i++) {\r\n            charCount <<= 8;\r\n            charCount += uint8(b[i]);\r\n        }\r\n\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 i = 0; i < charCount; i++) {\r\n            bytesStringTrimmed[i] = b[i + 64];\r\n        }\r\n\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    // uses a heuristic to produce a token name from the address\r\n    // the heuristic returns the full hex of the address string in upper case\r\n    function addressToName(address token) private pure returns (string memory) {\r\n        return AddressStringUtil.toAsciiString(token, 40);\r\n    }\r\n\r\n    // uses a heuristic to produce a token symbol from the address\r\n    // the heuristic returns the first 6 hex of the address string in upper case\r\n    function addressToSymbol(address token) private pure returns (string memory) {\r\n        return AddressStringUtil.toAsciiString(token, 6);\r\n    }\r\n\r\n    // calls an external view token contract method that returns a symbol or name, and parses the output into a string\r\n    function callAndParseStringReturn(address token, bytes4 selector) private view returns (string memory) {\r\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));\r\n        // if not implemented, or returns empty data, return empty string\r\n        if (!success || data.length == 0) {\r\n            return '';\r\n        }\r\n        // bytes32 data always has length 32\r\n        if (data.length == 32) {\r\n            bytes32 decoded = abi.decode(data, (bytes32));\r\n            return bytes32ToString(decoded);\r\n        } else if (data.length > 64) {\r\n            return abi.decode(data, (string));\r\n        }\r\n        return '';\r\n    }\r\n\r\n    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address\r\n    function tokenSymbol(address token) internal view returns (string memory) {\r\n        // 0x95d89b41 = bytes4(keccak256(\"symbol()\"))\r\n        string memory symbol = callAndParseStringReturn(token, 0x95d89b41);\r\n        if (bytes(symbol).length == 0) {\r\n            // fallback to 6 uppercase hex of address\r\n            return addressToSymbol(token);\r\n        }\r\n        return symbol;\r\n    }\r\n\r\n    // attempts to extract the token name. if it does not implement name, returns a name derived from the address\r\n    function tokenName(address token) internal view returns (string memory) {\r\n        // 0x06fdde03 = bytes4(keccak256(\"name()\"))\r\n        string memory name = callAndParseStringReturn(token, 0x06fdde03);\r\n        if (bytes(name).length == 0) {\r\n            // fallback to full hex of address\r\n            return addressToName(token);\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\npragma solidity >=0.5.0;\r\n\r\n// produces names for rewards pools using InfinityRewards's naming scheme\r\nlibrary InfinityRewardsNamer {\r\n    string private constant TOKEN_PREFIX = 'Infinity Staking ';\r\n    string private constant TOKEN_SEPARATOR = ' for ';\r\n    string private constant TOKEN_SYMBOL_PREFIX = 'IR[';\r\n    string private constant TOKEN_SYMBOL_SUFFIX = ']';\r\n\r\n    // produces a pool descriptor in the format of `${prefix}${symbol0}${separator}${symbol1}`\r\n    function poolName(\r\n        address token0,\r\n        address token1\r\n    ) internal view returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    TOKEN_PREFIX,\r\n                    SafeERC20Namer.tokenSymbol(token0),\r\n                    TOKEN_SEPARATOR,\r\n                    SafeERC20Namer.tokenSymbol(token1)\r\n                )\r\n            );\r\n    }\r\n\r\n    // produces a pool symbol in the format of `${prefix}${symbol}${suffix}`\r\n    function poolSymbol(\r\n        address token\r\n    ) internal view returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    TOKEN_SYMBOL_PREFIX,\r\n                    SafeERC20Namer.tokenSymbol(token),\r\n                    TOKEN_SYMBOL_SUFFIX\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\npragma solidity ^0.6.7;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        require((c = a + b) >= a, \"Addition overflow\");\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require((c = a - b) <= a, \"Subtraction underflow\");\r\n    }\r\n    \r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"Multiplication overflow\");\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        require(b > 0, \"Division by zero\");\r\n        return a / b;\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"transfer failed\");\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"transferFrom failed\");\r\n    }\r\n}\r\n\r\ninterface IToken {\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\ncontract InfinityRewards {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public immutable factory;\r\n    address public rewardsToken;\r\n    address public stakingToken;\r\n    uint public constant minRewardsDuration = 14 days;\r\n    uint public periodFinish;\r\n    uint public rewardRate;\r\n    uint public lastUpdateTime;\r\n    uint public rewardPerTokenStored;\r\n    uint public rewardsOwed;\r\n\r\n    mapping(address => uint) public userRewardPerTokenPaid;\r\n    mapping(address => uint) public rewards;\r\n\r\n    uint public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, \"locked\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    // update pool rewards, rewards owed and specified account rewards\r\n    modifier updateReward(address account) {\r\n        uint _rewardPerToken = rewardPerTokenStored; // gas saving\r\n        uint _lastTimeRewardApplicable = lastTimeRewardApplicable();\r\n        uint _totalSupply = totalSupply;\r\n        if (_totalSupply > 0) {\r\n            uint extraRewardPerToken = _lastTimeRewardApplicable.sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply);\r\n            if (extraRewardPerToken > 0) {\r\n                _rewardPerToken = _rewardPerToken.add(extraRewardPerToken);\r\n                rewardPerTokenStored = _rewardPerToken;\r\n                rewardsOwed = rewardsOwed.add(extraRewardPerToken.mul(_totalSupply));\r\n            }\r\n        }\r\n        lastUpdateTime = _lastTimeRewardApplicable;\r\n        if (account != address(0)) {\r\n            uint extraEarnings = balanceOf[account].mul(_rewardPerToken.sub(userRewardPerTokenPaid[account]));\r\n            if (extraEarnings > 0) {\r\n                rewards[account] = rewards[account].add(extraEarnings / 1e18);\r\n                rewardsOwed = rewardsOwed.sub(extraEarnings % 1e18); // free any remainder\r\n            }\r\n            userRewardPerTokenPaid[account] = _rewardPerToken;\r\n        }\r\n        _;\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event RewardUpdated(uint rewardRate, uint periodFinish);\r\n    event Staked(address indexed user, uint amount);\r\n    event Withdrawn(address indexed user, uint amount);\r\n    event RewardPaid(address indexed user, uint reward);\r\n\r\n    constructor() public {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // initialize tokens only when pool is created\r\n    function initialize(address rewardsToken_, address stakingToken_) external {\r\n        require(msg.sender == factory, 'Forbidden');\r\n        IToken(rewardsToken_).balanceOf(address(this)); // check token\r\n        rewardsToken = rewardsToken_;\r\n        stakingToken = stakingToken_;\r\n        name = InfinityRewardsNamer.poolName(stakingToken_, rewardsToken_);\r\n        symbol = InfinityRewardsNamer.poolSymbol(stakingToken_);\r\n        decimals = IToken(stakingToken_).decimals();\r\n    }\r\n\r\n    // **** VIEW FUNCTIONS ****\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint) {\r\n        uint _periodFinish = periodFinish;\r\n        return block.timestamp < _periodFinish ? block.timestamp : _periodFinish;\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint) {\r\n        uint _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) return rewardPerTokenStored;\r\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply));\r\n    }\r\n\r\n    function earned(address account) external view returns (uint) {\r\n        return balanceOf[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\r\n    }\r\n\r\n    function currentRewardsOwed() public view returns (uint) {\r\n        uint _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) return rewardsOwed;\r\n        uint extraRewardPerToken = lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply);\r\n        return rewardsOwed.add(extraRewardPerToken.mul(_totalSupply));\r\n    }\r\n\r\n    function rewardsAvailable() public view returns (uint) {\r\n        address _rewardsToken = rewardsToken;\r\n        uint rewardsBalance = IToken(_rewardsToken).balanceOf(address(this));\r\n        if (_rewardsToken == stakingToken) rewardsBalance = rewardsBalance.sub(totalSupply);\r\n        uint _rewardsOwed = currentRewardsOwed();\r\n        _rewardsOwed = _rewardsOwed % 1e18 == 0 ? _rewardsOwed / 1e18 : (_rewardsOwed / 1e18) + 1;\r\n        return rewardsBalance.sub(_rewardsOwed);\r\n    }\r\n\r\n    // **** STAKING FUNCTIONS ****\r\n    \r\n    function stakeWithPermit(uint amount, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external {\r\n        uint approval = approveMax ? uint(-1) : amount;\r\n        IToken(stakingToken).permit(msg.sender, address(this), approval, deadline, v, r, s);\r\n        stake(amount);\r\n    }\r\n\r\n    function stake(uint amount) public lock updateReward(msg.sender) {\r\n        address _stakingToken = stakingToken;\r\n        uint balanceBefore = IToken(_stakingToken).balanceOf(address(this));\r\n        TransferHelper.safeTransferFrom(_stakingToken, msg.sender, address(this), amount);\r\n        uint amountReceived = IToken(_stakingToken).balanceOf(address(this)).sub(balanceBefore);\r\n        require(amountReceived > 0, \"Cannot stake 0\");\r\n        totalSupply = totalSupply.add(amountReceived);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(amountReceived);\r\n        emit Transfer(address(0), msg.sender, amountReceived);\r\n        emit Staked(msg.sender, amountReceived);\r\n    }\r\n\r\n    function withdraw(uint amount) public lock updateReward(msg.sender) {\r\n        require(amount > 0, \"Cannot withdraw 0\");\r\n        totalSupply = totalSupply.sub(amount);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\r\n        TransferHelper.safeTransfer(stakingToken, msg.sender, amount);\r\n        emit Transfer(msg.sender, address(0), amount);\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    function getReward() public lock updateReward(msg.sender) {\r\n        uint reward = rewards[msg.sender];\r\n        if (reward > 0) {\r\n            rewards[msg.sender] = 0;\r\n            rewardsOwed = rewardsOwed.sub(reward.mul(1e18));\r\n            TransferHelper.safeTransfer(rewardsToken, msg.sender, reward);\r\n            emit RewardPaid(msg.sender, reward);\r\n        }\r\n    }\r\n\r\n    function exit() external {\r\n        withdraw(balanceOf[msg.sender]);\r\n        getReward();\r\n    }\r\n\r\n    // distribute available rewardsToken balance over the desired duration\r\n    function updateRewardAmount(uint duration) external lock updateReward(address(0)) {\r\n        require (duration >= minRewardsDuration, \"Duration less than minRewardsDuration\");\r\n        uint reward = rewardsAvailable();\r\n        uint newRewardRate = reward.div(duration);\r\n        require (newRewardRate > 0, \"No reward to distribute\");\r\n        \r\n        uint _periodFinish = periodFinish;\r\n        if (block.timestamp < _periodFinish) {\r\n            uint _rewardRate = rewardRate;\r\n            require(newRewardRate >= _rewardRate, \"Insufficient rewardRate\");\r\n            uint periodRemaining = _periodFinish.sub(block.timestamp);\r\n            if (duration < periodRemaining) {\r\n                uint rewardRemaining = periodRemaining.mul(_rewardRate);\r\n                require(reward >= rewardRemaining.mul(3), \"Insufficient reward to decrease duration\");\r\n            }\r\n        }\r\n        \r\n        rewardRate = newRewardRate;\r\n        lastUpdateTime = block.timestamp;\r\n        uint newPeriodFinish = block.timestamp.add(duration);\r\n        periodFinish = newPeriodFinish;\r\n        emit RewardUpdated(newRewardRate, newPeriodFinish);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodFinish\",\"type\":\"uint256\"}],\"name\":\"RewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardsOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingToken_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRewardsDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"updateRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InfinityRewards", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6c2ee26cb56feca33b4765fd4defb41d5a61b8541eaa41ebc1b1657e63c4a6fd"}