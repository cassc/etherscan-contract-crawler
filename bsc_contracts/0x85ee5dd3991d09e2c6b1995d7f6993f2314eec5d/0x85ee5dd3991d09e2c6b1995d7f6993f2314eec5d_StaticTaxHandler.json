{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue\\u0027s index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\"},\"ExchangePoolProcessor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @title Exchange pool processor abstract contract.\\n * @dev Keeps an enumerable set of designated exchange addresses as well as a single primary pool address.\\n */\\nabstract contract ExchangePoolProcessor is Ownable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /// @dev Set of exchange pool addresses.\\n    EnumerableSet.AddressSet internal _exchangePools;\\n\\n    /// @notice Primary exchange pool address.\\n    address public primaryPool;\\n\\n    /// @notice Emitted when an exchange pool address is added to the set of tracked pool addresses.\\n    event ExchangePoolAdded(address exchangePool);\\n\\n    /// @notice Emitted when an exchange pool address is removed from the set of tracked pool addresses.\\n    event ExchangePoolRemoved(address exchangePool);\\n\\n    /// @notice Emitted when the primary pool address is updated.\\n    event PrimaryPoolUpdated(address oldPrimaryPool, address newPrimaryPool);\\n\\n    /**\\n     * @notice Get list of addresses designated as exchange pools.\\n     * @return An array of exchange pool addresses.\\n     */\\n    function getExchangePoolAddresses() external view returns (address[] memory) {\\n        return _exchangePools.values();\\n    }\\n\\n    /**\\n     * @notice Add an address to the set of exchange pool addresses.\\n     * @dev Nothing happens if the pool already exists in the set.\\n     * @param exchangePool Address of exchange pool to add.\\n     */\\n    function addExchangePool(address exchangePool) external onlyOwner {\\n        if (_exchangePools.add(exchangePool)) {\\n            emit ExchangePoolAdded(exchangePool);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove an address from the set of exchange pool addresses.\\n     * @dev Nothing happens if the pool doesn\\u0027t exist in the set..\\n     * @param exchangePool Address of exchange pool to remove.\\n     */\\n    function removeExchangePool(address exchangePool) external onlyOwner {\\n        if (_exchangePools.remove(exchangePool)) {\\n            emit ExchangePoolRemoved(exchangePool);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set exchange pool address as primary pool.\\n     * @dev To prevent issues, only addresses inside the set of exchange pool addresses can be selected as primary pool.\\n     * @param exchangePool Address of exchange pool to set as primary pool.\\n     */\\n    function setPrimaryPool(address exchangePool) external onlyOwner {\\n        require(\\n            _exchangePools.contains(exchangePool),\\n            \\\"ExchangePoolProcessor:setPrimaryPool:INVALID_POOL: Given address is not registered as exchange pool.\\\"\\n        );\\n        require(\\n            primaryPool != exchangePool,\\n            \\\"ExchangePoolProcessor:setPrimaryPool:ALREADY_SET: This address is already the primary pool address.\\\"\\n        );\\n\\n        address oldPrimaryPool = primaryPool;\\n        primaryPool = exchangePool;\\n\\n        emit PrimaryPoolUpdated(oldPrimaryPool, exchangePool);\\n    }\\n}\"},\"ITaxHandler.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Tax handler interface\\n * @dev Any class that implements this interface can be used for protocol-specific tax calculations.\\n */\\ninterface ITaxHandler {\\n    /**\\n     * @notice Get number of tokens to pay as tax.\\n     * @param benefactor Address of the benefactor.\\n     * @param beneficiary Address of the beneficiary.\\n     * @param amount Number of tokens in the transfer.\\n     * @return Number of tokens to pay as tax.\\n     */\\n    function getTax(\\n        address benefactor,\\n        address beneficiary,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    function isExempted(\\n        address wallet\\n    ) external view returns (bool);\\n\\n    function isExchangePool(\\n        address addr\\n    ) external view returns (bool);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"TaxHandler.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../ITaxHandler.sol\\\";\\nimport \\\"../ExchangePoolProcessor.sol\\\";\\nimport \\\"../EnumerableSet.sol\\\";\\n\\n/**\\n * @title Static tax handler contract\\n * @dev This contract allows protocols to collect tax on transactions that count as either sells or liquidity additions\\n * to exchange pools. Addresses can be exempted from tax collection, and addresses designated as exchange pools can be\\n * added and removed by the owner of this contract. The owner of the contract should be set to a DAO-controlled timelock\\n * or at the very least a multisig wallet.\\n */\\ncontract StaticTaxHandler is ITaxHandler, ExchangePoolProcessor {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /// @notice How much tax to collect in basis points. 10,000 basis points is 100%.\\n    uint256 public taxBasisPointsBuy;\\n    uint256 public taxBasisPointsSell;\\n\\n    /// @dev The set of addresses exempt from tax.\\n    EnumerableSet.AddressSet private _exempted;\\n\\n    /// @notice Emitted when the tax basis points number is updated.\\n    event TaxBasisPointsUpdated(uint256 oldBasisPointsBuy, uint256 oldBasisPointsSell, uint256 newBasisPointsBuy, uint256 newBasisPointsSell);\\n\\n    /// @notice Emitted when an address is added to or removed from the exempted addresses set.\\n    event TaxExemptionUpdated(address indexed wallet, bool exempted);\\n\\n    /**\\n     * @param initialTaxBasisPointsBuy The number of tax basis points on buy to start out with for tax calculations.\\n     * @param initialTaxBasisPointsSell The number of tax basis points on sell to start out with for tax calculations.\\n     */\\n    constructor(uint256 initialTaxBasisPointsBuy, uint256 initialTaxBasisPointsSell) {\\n        taxBasisPointsBuy = initialTaxBasisPointsBuy;\\n        taxBasisPointsSell = initialTaxBasisPointsSell;\\n    }\\n\\n    // Restrict amount transfer based on buy, sell or transfer\\n    // function limitTx(\\n    //     address from,\\n    //     address to\\n    // ) external view returns (bool) {\\n    //     if (_exempted.contains(from) || _exempted.contains(to)) {\\n    //         return false;\\n    //     }\\n\\n    //     require(\\n    //         _exchangePools.length() \\u003e 0,\\n    //         \\\"StaticTaxHandler:getTax:INACTIVE: No exchange pools have been added yet.\\\"\\n    //     );\\n\\n    //     // Transactions between regular users (this includes contracts) aren\\u0027t taxed.\\n    //     if (!_exchangePools.contains(from) \\u0026\\u0026 !_exchangePools.contains(to)) {\\n    //         return false;\\n    //     }\\n    //     // Buy transactions have different tax\\n    //     if (_exchangePools.contains(from) \\u0026\\u0026 !_exempted.contains(to)){\\n    //         return true;\\n    //     } else if (_exchangePools.contains(to) \\u0026\\u0026 !_exempted.contains(from)){\\n    //         return true;\\n    //     } else {\\n    //         return false;\\n    //     }\\n    // }\\n\\n    /**\\n     * @notice Get number of tokens to pay as tax. This method specifically only check for sell-type transfers to\\n     * designated exchange pool addresses.\\n     * @dev There is no easy way to differentiate between a user selling tokens and a user adding liquidity to the pool.\\n     * In both cases tokens are transferred to the pool. This is an unfortunate case where users have to accept being\\n     * taxed on liquidity additions. To get around this issue, a separate liquidity addition contract can be deployed.\\n     * This contract can be exempt from taxes if its functionality is verified to only add liquidity.\\n     * @param benefactor Address of the benefactor.\\n     * @param beneficiary Address of the beneficiary.\\n     * @param amount Number of tokens in the transfer.\\n     * @return Number of tokens to pay as tax.\\n     */\\n    function getTax(\\n        address benefactor,\\n        address beneficiary,\\n        uint256 amount\\n    ) external view override returns (uint256) {\\n        if (_exempted.contains(benefactor) || _exempted.contains(beneficiary)) {\\n            return 0;\\n        }\\n\\n        require(\\n            _exchangePools.length() \\u003e 0,\\n            \\\"StaticTaxHandler:getTax:INACTIVE: No exchange pools have been added yet.\\\"\\n        );\\n\\n        // Transactions between regular users (this includes contracts) aren\\u0027t taxed.\\n        if (!_exchangePools.contains(benefactor) \\u0026\\u0026 !_exchangePools.contains(beneficiary)) {\\n            return 0;\\n        }\\n        // Buy transactions have different tax\\n        if (_exchangePools.contains(benefactor) \\u0026\\u0026 !_exempted.contains(beneficiary)){\\n            return (amount * taxBasisPointsBuy) / 10000;\\n        } else if (_exchangePools.contains(beneficiary) \\u0026\\u0026 !_exempted.contains(benefactor)){\\n            return (amount * taxBasisPointsSell) / 10000;\\n        }\\n        return 0;\\n    }\\n\\n    function isExempted(address addr) public view returns (bool) {\\n        return _exempted.contains(addr);\\n    }\\n\\n    function isExchangePool(address addr) public view returns (bool) {\\n        return _exchangePools.contains(addr);\\n    }\\n\\n    /**\\n     * @notice Set new number for tax basis points.\\n     * @param newBasisPointsBuy New tax basis points number on buy to set for calculations.\\n     * @param newBasisPointsSell New tax basis points number on sell to set for calculations.\\n     */\\n    function setTaxBasisPoints(uint256 newBasisPointsBuy, uint256 newBasisPointsSell) external onlyOwner {\\n        require(\\n            newBasisPointsBuy + newBasisPointsSell \\u003c= 5000,\\n            \\\"StaticTaxHandler:setTaxBasisPoints:HIGHER_VALUE: Basis points cannot exceed 5,000.\\\"\\n        );\\n\\n        uint256 oldBasisPointsBuy = taxBasisPointsBuy;\\n        uint256 oldBasisPointsSell = taxBasisPointsSell;\\n        taxBasisPointsBuy = newBasisPointsBuy;\\n        taxBasisPointsSell = newBasisPointsSell;\\n\\n        emit TaxBasisPointsUpdated(oldBasisPointsBuy, oldBasisPointsSell, newBasisPointsBuy, newBasisPointsSell);\\n    }\\n\\n    /**\\n     * @notice Add address to set of tax-exempted addresses.\\n     * @param exemption Address to add to set of tax-exempted addresses.\\n     */\\n    function addExemptedWallet(address exemption) external onlyOwner {\\n        if (_exempted.add(exemption)) {\\n            emit TaxExemptionUpdated(exemption, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove address from set of tax-exempted addresses.\\n     * @param exemption Address to remove from set of tax-exempted addresses.\\n     */\\n    function removeExemptedWallet(address exemption) external onlyOwner {\\n        if (_exempted.remove(exemption)) {\\n            emit TaxExemptionUpdated(exemption, false);\\n        }\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialTaxBasisPointsBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialTaxBasisPointsSell\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"ExchangePoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"ExchangePoolRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPrimaryPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPrimaryPool\",\"type\":\"address\"}],\"name\":\"PrimaryPoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBasisPointsBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBasisPointsSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBasisPointsBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBasisPointsSell\",\"type\":\"uint256\"}],\"name\":\"TaxBasisPointsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exempted\",\"type\":\"bool\"}],\"name\":\"TaxExemptionUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"addExchangePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exemption\",\"type\":\"address\"}],\"name\":\"addExemptedWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangePoolAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isExchangePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isExempted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"primaryPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"removeExchangePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exemption\",\"type\":\"address\"}],\"name\":\"removeExemptedWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"setPrimaryPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBasisPointsBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBasisPointsSell\",\"type\":\"uint256\"}],\"name\":\"setTaxBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxBasisPointsBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxBasisPointsSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StaticTaxHandler", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000fa0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://47f1c6776d8102991401b812780251a45f9e7ef8c23e6c202b1647049f793019"}