{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.8.11;\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IFactory.sol\r\n\r\ninterface IFactory\r\n{\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n// File: contracts/interfaces/IRouter.sol\r\n\r\ninterface IUniRouterV1\r\n{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniRouterV2 is IUniRouterV1\r\n{\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IDividendDistributor.sol\r\n\r\ninterface IDividendDistributor\r\n{\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\r\n    function setShare(address _shareholder, uint256 _amount) external;\r\n\r\n    function claimDividend() external;\r\n    function claimDividend(address _shareholder) external;\r\n\r\n    function deposit() external payable;\r\n    function process(uint256 _gas) external;\r\n\r\n    function rewardToken() external returns (IERC20);\r\n    function getUnpaidEarnings(address _shareholder) external returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IDividendToken.sol\r\n\r\ninterface IDividendToken is IERC20\r\n{\r\n    function owner() external returns (address);\r\n}\r\n\r\n// File: contracts/DividendDistributor.sol\r\n\r\ncontract DividendDistributor is IDividendDistributor\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n\r\n    struct Share\r\n    {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n    \r\n    //general\r\n    IDividendToken public dividendToken;\r\n    IUniRouterV2 public router;\r\n    IERC20 public override rewardToken;\r\n    uint256 public currentIndex;   \r\n    \r\n    //shareholders\r\n    address[] private shareholders;\r\n    mapping (address => uint256) private shareholderIndexes;\r\n    mapping (address => uint256) private shareholderClaims;\r\n    mapping (address => Share) public shares;    \r\n\r\n    //shares\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n\r\n    //settings\r\n    uint256 public minPeriod = 1 hours;\r\n    uint256 public minDistribution = 0.1 ether;    \r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(\r\n        IUniRouterV2 _router,\r\n        IERC20 _rewardToken)\r\n    {\r\n        router = _router;\r\n        rewardToken = _rewardToken;\r\n        dividendToken = IDividendToken(msg.sender);\r\n    }\r\n\r\n    //========================\r\n    // CONFIG FUNCTIONS\r\n    //========================\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external override onlyToken\r\n    {\r\n        minPeriod = _minPeriod;\r\n        minDistribution = _minDistribution;\r\n    }\r\n\r\n    //========================\r\n    // PROCESS & DEPOSIT FUNCTIONS\r\n    //========================\r\n\r\n    function deposit() external payable override\r\n    {\r\n        uint256 addedReward = msg.value;\r\n        if (address(rewardToken) != address(0))\r\n        {\r\n            //make swap path\r\n            address[] memory swapPath = new address[](2);\r\n            swapPath[0] = router.WETH();\r\n            swapPath[1] = address(rewardToken);\r\n\r\n            //swap to reward token\r\n            uint256 rewardBefore = rewardToken.balanceOf(address(this));\r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: msg.value }(\r\n                0,\r\n                swapPath,\r\n                address(this),\r\n                block.timestamp);\r\n            uint256 rewardAfter = rewardToken.balanceOf(address(this));\r\n            addedReward = rewardAfter.sub(rewardBefore);\r\n        }\r\n\r\n        totalDividends = totalDividends.add(addedReward);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(addedReward).div(totalShares));\r\n    }\r\n\r\n    function manualProcess(uint256 _gas) external onlyOwner\r\n    {\r\n        _process(_gas);\r\n    }\r\n\r\n    function process(uint256 _gas) external override onlyToken\r\n    {\r\n        _process(_gas);\r\n    }\r\n\r\n    function _process(uint256 _gas) private\r\n    {\r\n        //check shareholders\r\n        uint256 shareholderCount = shareholders.length;\r\n        if (shareholderCount == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        uint256 iterations = 0;\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n        while (gasUsed < _gas\r\n            && iterations < shareholderCount)\r\n        {\r\n            if (currentIndex >= shareholderCount)\r\n            {\r\n                //start at 0 again\r\n                currentIndex = 0;\r\n            }\r\n\r\n            //distribute\r\n            if (shouldDistribute(shareholders[currentIndex]))\r\n            {\r\n                distributeDividend(shareholders[currentIndex]);\r\n            }\r\n\r\n            //update gas / index\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n    //========================\r\n    // SHAREHOLDER FUNCTIONS\r\n    //========================\r\n\r\n    function setShare(address _shareholder, uint256 _amount) external override onlyToken\r\n    {\r\n        //distribute dividende\r\n        if (shares[_shareholder].amount > 0)\r\n        {\r\n            distributeDividend(_shareholder);\r\n        }\r\n\r\n        //add / remove shareholder\r\n        if (_amount > 0\r\n            && shares[_shareholder].amount == 0)\r\n        {\r\n            addShareholder(_shareholder);\r\n        }\r\n        else if (_amount == 0\r\n            && shares[_shareholder].amount > 0)\r\n        {\r\n            removeShareholder(_shareholder);\r\n        }\r\n\r\n        //updates shares\r\n        totalShares = totalShares.sub(shares[_shareholder].amount).add(_amount);\r\n        shares[_shareholder].amount = _amount;\r\n        shares[_shareholder].totalExcluded = getCumulativeDividends(shares[_shareholder].amount);\r\n    }    \r\n\r\n    function addShareholder(address _shareholder) internal\r\n    {\r\n        shareholderIndexes[_shareholder] = shareholders.length;\r\n        shareholders.push(_shareholder);\r\n    }\r\n\r\n    function removeShareholder(address _shareholder) internal\r\n    {\r\n        shareholders[shareholderIndexes[_shareholder]] = shareholders[shareholders.length - 1];\r\n        shareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[_shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    //========================\r\n    // DISTRIBUTE FUNCTIONS\r\n    //========================\r\n    \r\n    function shouldDistribute(address _shareholder) internal view returns (bool)\r\n    {\r\n        return (shareholderClaims[_shareholder] + minPeriod < block.timestamp\r\n            && getUnpaidEarnings(_shareholder) > minDistribution);\r\n    }\r\n\r\n    function distributeDividend(address _shareholder) internal\r\n    {\r\n        //check shares\r\n        if (shares[_shareholder].amount == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        uint256 amount = getUnpaidEarnings(_shareholder);\r\n        if (amount > 0)\r\n        {\r\n            totalDistributed = totalDistributed.add(amount);\r\n\r\n            //distribute\r\n            if (address(rewardToken) != address(0))\r\n            {\r\n                //token\r\n                rewardToken.safeTransfer(_shareholder, amount);\r\n            }\r\n            else\r\n            {\r\n                //ETH\r\n                (bool success, ) = payable(_shareholder).call{ value: amount, gas: 30000 }(\"\");\r\n                success = false;\r\n            }\r\n\r\n            //update\r\n            shareholderClaims[_shareholder] = block.timestamp;\r\n            shares[_shareholder].totalRealised = shares[_shareholder].totalRealised.add(amount);\r\n            shares[_shareholder].totalExcluded = getCumulativeDividends(shares[_shareholder].amount);\r\n        }\r\n    }\r\n    \r\n    function claimDividend() external override\r\n    {\r\n        claimDividend(msg.sender);\r\n    }\r\n\r\n    function claimDividend(address _shareholder) public override\r\n    {\r\n        require(shouldDistribute(_shareholder), \"Too soon. Need to wait!\");\r\n        distributeDividend(_shareholder);\r\n    }\r\n\r\n    function getUnpaidEarnings(address _shareholder) public override view returns (uint256)\r\n    {\r\n        if (shares[_shareholder].amount == 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[_shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[_shareholder].totalExcluded;\r\n        if (shareholderTotalDividends <= shareholderTotalExcluded)\r\n        {\r\n            return 0;\r\n        }\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 _share) internal view returns (uint256)\r\n    {\r\n        return _share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    //========================\r\n    // MODIFIERS\r\n    //========================\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        require(dividendToken.owner() == msg.sender, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyToken()\r\n    {\r\n        require(msg.sender == address(dividendToken));\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/DividendToken.sol\r\n\r\ncontract DividendToken is IDividendToken, Ownable\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    //========================\r\n    // STRUCT\r\n    //========================\r\n\r\n    struct FeeInfo\r\n    {\r\n        uint256 liquidityFee;\r\n        uint256 rewardFee;\r\n        uint256 marketingFee;\r\n        uint256 teamFee;\r\n    }\r\n\r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n    \r\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant ZERO = 0x0000000000000000000000000000000000000000;    \r\n    uint256 private constant FEE_DENOMINATOR = 10000;\r\n    uint256 private constant ANTI_SNIPER_FEE = 9900;\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    //ERC20\r\n    string _name;\r\n    string _symbol;\r\n    uint8 immutable _decimals;\r\n    uint256 _totalSupply;\r\n    mapping(address => uint256) _balances;\r\n    mapping(address => mapping(address => uint256)) _allowances;\r\n\r\n    //limits\r\n    uint256 public _maxTxAmount;\r\n    uint256 public _walletMax;    \r\n    bool public restrictWhales = false;\r\n\r\n    //exempt\r\n    mapping(address => bool) public isFeeExempt;\r\n    mapping(address => bool) public isTxLimitExempt;\r\n    mapping(address => bool) public isDividendExempt;\r\n    mapping(address => bool) public isBlacklisted;\r\n\r\n    //fees\r\n    FeeInfo public buyFee;\r\n    FeeInfo public sellFee;\r\n    FeeInfo public p2pFee;\r\n    FeeInfo public feeBalance;\r\n\r\n    //wallets\r\n    address public autoLiquidityReceiver;\r\n    address public marketingWallet;\r\n    address public teamWallet;    \r\n\r\n    //vested liquidity\r\n    uint256 public vestedUntil;\r\n    uint256 public vestingPeriod;   \r\n\r\n    //router + pair\r\n    IUniRouterV2 public router;\r\n    address public pair;\r\n\r\n    //dividend distributor\r\n    DividendDistributor public immutable dividendDistributor;\r\n    uint256 distributorGas = 500000;\r\n\r\n    //settings\r\n    uint256 public launchedAt;\r\n    bool public tradingOpen;    \r\n\r\n    //liquify\r\n    bool inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = true;\r\n    bool public swapAndLiquifyByLimitOnly;\r\n    uint256 public swapTokensAtHigh; //liquify trigger high\r\n    uint256 public swapTokensAtLow; //liquify trigger high\r\n\r\n    //misc    \r\n    uint256 private immutable antiSniperDuration;    \r\n    uint256 private immutable maxFee;\r\n    uint256 private nonce;\r\n\r\n    //========================\r\n    // EVENTS\r\n    //========================\r\n\r\n    event AutoLiquify(uint256 amountETH, uint256 amountBOG);\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(\r\n        address _router,\r\n        address _rewardToken,\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        uint256 _tokenTotalSupply,\r\n        address _owner,\r\n        uint256 _antiSniperDuration,\r\n        uint256 _maxFee)\r\n    {   \r\n        //ERC20 (change)\r\n        _name = _tokenName;\r\n        _symbol = _tokenSymbol;\r\n        _decimals = _tokenDecimals;\r\n        _totalSupply = _tokenTotalSupply; \r\n\r\n        //limits (change)        \r\n        swapTokensAtHigh = _totalSupply.mul(1).div(1000);\r\n        swapTokensAtLow = swapTokensAtHigh.mul(200).div(1000);\r\n        _maxTxAmount = _totalSupply.mul(10).div(100); \r\n        _walletMax = _totalSupply.mul(10).div(100);    \r\n\r\n        //vesting (change)\r\n        vestingPeriod = 90 days;\r\n        vestedUntil = block.timestamp + vestingPeriod;\r\n\r\n        //misc (change)\r\n        antiSniperDuration = _antiSniperDuration;\r\n        maxFee = _maxFee;\r\n\r\n        //router + pair + dividende distributor\r\n        router = IUniRouterV2(_router);\r\n        pair = IFactory(router.factory()).createPair(router.WETH(), address(this));\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n        dividendDistributor = new DividendDistributor(router, IERC20(_rewardToken));\r\n\r\n        //exempt fee\r\n        isFeeExempt[_owner] = true;\r\n        isFeeExempt[address(this)] = true;\r\n\r\n        //exempt tx limit\r\n        isTxLimitExempt[_owner] = true;\r\n        isTxLimitExempt[pair] = true;\r\n\r\n        //exempt dividend\r\n        isDividendExempt[pair] = true;\r\n        isDividendExempt[_owner] = true;        \r\n        isDividendExempt[DEAD] = true;\r\n        isDividendExempt[ZERO] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isDividendExempt[marketingWallet] = true;\r\n        isDividendExempt[teamWallet] = true;       \r\n\r\n        //set owner and send initial supply to owner\r\n        _balances[_owner] = _totalSupply;\r\n        emit Transfer(address(0), _owner, _totalSupply);\r\n    }\r\n\r\n    function owner() public view override(Ownable, IDividendToken) returns (address)\r\n    {\r\n        return Ownable.owner();\r\n    }\r\n\r\n    //========================\r\n    // CONFIG FUNCTIONS\r\n    //========================\r\n\r\n    function setTxLimit(uint256 _limit) public onlyOwner\r\n    {\r\n        _maxTxAmount = _limit;\r\n    }\r\n\r\n    function setWalletLimit(uint256 _limit) public onlyOwner\r\n    {\r\n        _walletMax  = _limit;\r\n    }\r\n\r\n    function setRestrictWhales(bool _value) public onlyOwner\r\n    {\r\n       restrictWhales = _value;\r\n    }\r\n    \r\n    function setIsFeeExempt(address _holder, bool _exempt) public onlyOwner\r\n    {\r\n        isFeeExempt[_holder] = _exempt;\r\n    }\r\n\r\n    function setIsTxLimitExempt(address _holder, bool _exempt) public onlyOwner\r\n    {\r\n        isTxLimitExempt[_holder] = _exempt;\r\n    }\r\n\r\n    function setIsBlacklisted(address _holder, bool _blacklisted) public onlyOwner\r\n    {\r\n        require(\r\n            (_holder != DEAD\r\n                && _holder != ZERO\r\n                && _holder != address(this)\r\n                && _holder != address(router)\r\n                && _holder != address(pair))\r\n            , \"Invalid Holder\");\r\n        isBlacklisted[_holder] = _blacklisted;\r\n    }\r\n\r\n    function setIsDividendExempt(address _holder, bool _exempt) public onlyOwner\r\n    {\r\n        require(_holder != address(this) && _holder != pair, \"Invalid Holder\");\r\n\r\n        //set\r\n        isDividendExempt[_holder] = _exempt;\r\n        \r\n        //set share\r\n        if (_exempt)\r\n        {\r\n            dividendDistributor.setShare(_holder, 0);\r\n        }\r\n        else\r\n        {\r\n            dividendDistributor.setShare(_holder, _balances[_holder]);\r\n        }\r\n    }\r\n\r\n    function setSwapTokensAtAmount(uint256 _low, uint256 _high) public onlyOwner\r\n    {\r\n        require(_high > _low, \"High must be more than low\");\r\n        swapTokensAtLow = _low;\r\n        swapTokensAtHigh = _high;\r\n    }\r\n\r\n    function setLiquidityFee(int8 _feeType, uint256 _fee) external onlyOwner\r\n    {\r\n        FeeInfo memory fees = getFee(_feeType);\r\n        _setFees(_feeType, _fee, fees.rewardFee, fees.teamFee, fees.marketingFee);\r\n    }   \r\n\r\n    function setRewardFee(int8 _feeType, uint256 _fee) external onlyOwner\r\n    {\r\n        FeeInfo memory fees = getFee(_feeType);\r\n        _setFees(_feeType, fees.liquidityFee, _fee, fees.teamFee, fees.marketingFee);\r\n    }    \r\n\r\n    function setTeamFee(int8 _feeType, uint256 _fee) external onlyOwner\r\n    {\r\n        FeeInfo memory fees = getFee(_feeType);\r\n        _setFees(_feeType, fees.liquidityFee, fees.liquidityFee, _fee, fees.marketingFee);\r\n    }    \r\n\r\n    function setMarketingFee(int8 _feeType, uint256 _fee) external onlyOwner\r\n    {\r\n        FeeInfo memory fees = getFee(_feeType);\r\n        _setFees(_feeType, fees.liquidityFee, fees.liquidityFee, fees.teamFee, _fee);\r\n    }    \r\n\r\n    function setFees(int8 _feeType, uint256 _liquidityFee, uint256 _rewardFee, uint256 _teamFee, uint256 _marketingFee) public onlyOwner\r\n    {\r\n        _setFees(_feeType, _liquidityFee, _rewardFee, _teamFee, _marketingFee);\r\n    }    \r\n\r\n    function setFeeReceivers(address _liquidityReceiver, address _marketingWallet, address _teamWallet) public onlyOwner\r\n    {\r\n        autoLiquidityReceiver = _liquidityReceiver;\r\n        marketingWallet = _marketingWallet;\r\n        teamWallet = _teamWallet;\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enableSwapBack, bool _swapByLimitOnly) public onlyOwner\r\n    {\r\n        swapAndLiquifyEnabled  = _enableSwapBack;\r\n        swapAndLiquifyByLimitOnly = _swapByLimitOnly;\r\n    }\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) public onlyOwner\r\n    {\r\n        dividendDistributor.setDistributionCriteria(_minPeriod, _minDistribution);\r\n    }\r\n\r\n    function setDistributorSettings(uint256 _gas) public onlyOwner\r\n    {\r\n        require(_gas < 750000, \"Gas to high\");\r\n        distributorGas = _gas;\r\n    }        \r\n\r\n    function setTradingStatus(bool _status) public onlyOwner\r\n    {\r\n        tradingOpen = _status;\r\n    }\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\r\n    function claimDividend() external\r\n    {\r\n        dividendDistributor.claimDividend(msg.sender);\r\n    }\r\n\r\n    function getUnpaidEarnings(address _shareholder) external view returns (uint256)\r\n    {\r\n        return dividendDistributor.getUnpaidEarnings(_shareholder);\r\n    }\r\n\r\n    //========================\r\n    // FEE FUNCTIONS\r\n    //========================\r\n\r\n    function _setFees(int8 _feeType, uint256 _liquidityFee, uint256 _rewardFee, uint256 _teamFee, uint256 _marketingFee) private\r\n    {\r\n        if (_feeType < 0)\r\n        {\r\n            //sell\r\n            sellFee.liquidityFee    = _liquidityFee;\r\n            sellFee.rewardFee       = _rewardFee;\r\n            sellFee.teamFee         = _teamFee;\r\n            sellFee.marketingFee    = _marketingFee;\r\n        }\r\n        else if (_feeType > 0)\r\n        {\r\n            //buy\r\n            buyFee.liquidityFee     = _liquidityFee;\r\n            buyFee.rewardFee        = _rewardFee;\r\n            buyFee.teamFee          = _teamFee;\r\n            buyFee.marketingFee     = _marketingFee;\r\n        }\r\n        else\r\n        {\r\n            //p2p\r\n            p2pFee.liquidityFee     = _liquidityFee;\r\n            p2pFee.rewardFee        = _rewardFee;\r\n            p2pFee.teamFee          = _teamFee;\r\n            p2pFee.marketingFee     = _marketingFee;\r\n        }        \r\n\r\n        //check\r\n        require(getTotalFee(getFee(_feeType)) <= maxFee, \"Fees to high\");\r\n    }\r\n\r\n    function getFee(int8 _feeType) private view returns (FeeInfo memory)\r\n    {\r\n        if (_feeType < 0)\r\n        {\r\n            return sellFee;\r\n        }\r\n        else if (_feeType > 0)\r\n        {\r\n            return buyFee;\r\n        }\r\n\r\n        return p2pFee;\r\n    }\r\n\r\n    function getFeeBalanceShares(uint256 _amount, uint256 _total) private view returns (FeeInfo memory)\r\n    {\r\n        return FeeInfo(\r\n        {\r\n            liquidityFee: feeBalance.liquidityFee.mul(_amount).div(_total),\r\n            rewardFee: feeBalance.rewardFee.mul(_amount).div(_total),\r\n            marketingFee: feeBalance.marketingFee.mul(_amount).div(_total),\r\n            teamFee: feeBalance.teamFee.mul(_amount).div(_total)\r\n        });\r\n    }\r\n\r\n    function getTotalFee(FeeInfo memory _fee) private pure returns (uint256)\r\n    {\r\n        return _fee.liquidityFee\r\n            .add(_fee.rewardFee)\r\n            .add(_fee.teamFee)\r\n            .add(_fee.marketingFee);\r\n    }\r\n\r\n    function getDynamicFee(address _from, address _to) public view returns (FeeInfo memory)\r\n    {\r\n        bool useAntiSniperFee;\r\n        FeeInfo memory fee;\r\n        if (_from == pair)\r\n        {\r\n            //buy\r\n            fee = getFee(1);\r\n            useAntiSniperFee = true;\r\n        }\r\n        else if (_to == pair)\r\n        {\r\n            //sell\r\n            fee = getFee(-1);\r\n            useAntiSniperFee = true;\r\n        }\r\n        else\r\n        {\r\n            //p2p\r\n            fee = getFee(0);\r\n        }\r\n\r\n        if (useAntiSniperFee)\r\n        {           \r\n            //anti sniper fee\r\n            uint256 endingTime = launchedAt.add(antiSniperDuration);\r\n            if (endingTime > block.timestamp)\r\n            {\r\n                uint256 remainingTime = endingTime.sub(block.timestamp);     \r\n                uint256 totalFee = getTotalFee(fee);\r\n                uint256 maxAntiSniper = ANTI_SNIPER_FEE.sub(totalFee);\r\n                fee = FeeInfo(\r\n                {\r\n                    marketingFee: fee.marketingFee\r\n                        .add(\r\n                            maxAntiSniper\r\n                                .mul(remainingTime)\r\n                                .div(antiSniperDuration)),\r\n                    teamFee: fee.teamFee,\r\n                    rewardFee: fee.rewardFee,\r\n                    liquidityFee: fee.liquidityFee\r\n                });\r\n            }\r\n        }\r\n\r\n        return fee;\r\n    }\r\n\r\n    function takeFee(address _from, address _to, uint256 _amount) private returns (uint256)\r\n    {   \r\n        if (isFeeExempt[_from]\r\n            || isFeeExempt[_to])\r\n        {\r\n            return _amount;\r\n        }\r\n\r\n        FeeInfo memory fee = getDynamicFee(_from, _to);\r\n        uint256 totalFee = getTotalFee(fee);\r\n        uint256 feeAmount = _amount.mul(totalFee).div(FEE_DENOMINATOR);\r\n\r\n        //transfer\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(_from, address(this), feeAmount);\r\n\r\n        //get fee shares\r\n        uint256 marketingShare = feeAmount.mul(fee.marketingFee).div(totalFee);\r\n        uint256 teamShare = feeAmount.mul(fee.teamFee).div(totalFee);\r\n        uint256 rewardShare = feeAmount.mul(fee.rewardFee).div(totalFee);\r\n        uint256 liquidityShare = feeAmount.sub(marketingShare).sub(teamShare).sub(rewardShare);\r\n\r\n        //adjust fee balances\r\n        feeBalance.marketingFee = feeBalance.marketingFee.add(marketingShare);\r\n        feeBalance.teamFee = feeBalance.teamFee.add(teamShare);\r\n        feeBalance.rewardFee = feeBalance.rewardFee.add(rewardShare);\r\n        feeBalance.liquidityFee = feeBalance.liquidityFee.add(liquidityShare);\r\n\r\n        return _amount.sub(feeAmount);\r\n    }\r\n\r\n    //========================\r\n    // SWAP FUNCTIONS\r\n    //========================    \r\n\r\n    receive() external payable {}\r\n\r\n    function getSwapAmount() private returns (uint256)\r\n    {\r\n        if (!swapAndLiquifyByLimitOnly)\r\n        {\r\n            return _balances[address(this)];\r\n        }\r\n        uint256 pr = uint256(keccak256(abi.encodePacked(tx.origin, block.timestamp, nonce++)));\r\n        return swapTokensAtLow.add(pr.mod(swapTokensAtHigh.sub(swapTokensAtLow)));\r\n    }\r\n\r\n    function manualSwapBack(uint256 _amount) external onlyOwner\r\n    {\r\n        swapBack(_amount);\r\n    }\r\n\r\n    function swapBack() private\r\n    {        \r\n        uint256 tokensToLiquify = getSwapAmount();\r\n        swapBack(tokensToLiquify);\r\n    }\r\n\r\n    function swapBack(uint256 _amount) private lockTheSwap\r\n    {\r\n        require(_amount <= _balances[address(this)], \"Insufficient balance for swap\");\r\n        FeeInfo memory swapAmounts = getFeeBalanceShares(_amount, _balances[address(this)]);\r\n        uint256 amountToLiquify = swapAmounts.liquidityFee.div(2);\r\n        uint256 amountToSwap = _amount.sub(amountToLiquify);\r\n\r\n        //make swap path from token to ETH\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        //swap to ETH\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        //reduce fee balances\r\n        feeBalance.liquidityFee = feeBalance.liquidityFee.sub(swapAmounts.liquidityFee);\r\n        feeBalance.rewardFee = feeBalance.rewardFee.sub(swapAmounts.rewardFee);\r\n        feeBalance.teamFee = feeBalance.teamFee.sub(swapAmounts.teamFee);\r\n        feeBalance.marketingFee = feeBalance.marketingFee.sub(swapAmounts.marketingFee);\r\n\r\n        //swap\r\n        swapBackFees(swapAmounts, amountToLiquify);        \r\n    }\r\n\r\n    function swapBackFees(FeeInfo memory _swapAmounts, uint256 _tokensToLiquify) private\r\n    {\r\n        //get shares\r\n        _swapAmounts.liquidityFee = _swapAmounts.liquidityFee.sub(_tokensToLiquify);\r\n        uint256 totalAmount = getTotalFee(_swapAmounts);\r\n\r\n        //calcute payout shares\r\n        uint256 amountETH = address(this).balance;           \r\n        uint256 amountETHReward = amountETH.mul(_swapAmounts.rewardFee).div(totalAmount);           \r\n        uint256 amountETHTeam = amountETH.mul(_swapAmounts.teamFee).div(totalAmount);     \r\n        uint256 amountETHMarketing = amountETH.mul(_swapAmounts.marketingFee).div(totalAmount);\r\n        uint256 amountETHLiquidity = amountETH.sub(amountETHReward).sub(amountETHTeam).sub(amountETHMarketing);\r\n\r\n        //distribute to wallets       \r\n        bool success;\r\n        if (amountETHMarketing > 0)\r\n        {\r\n            (success, ) = payable(marketingWallet).call{ value: amountETHMarketing, gas: 30000 }(\"\");\r\n        }\r\n        if (amountETHTeam > 0)\r\n        {\r\n            (success, ) = payable(teamWallet).call{ value: amountETHTeam, gas: 30000 }(\"\");\r\n        }        \r\n        success; //to prevent warning\r\n\r\n        //add liquidity\r\n        if (_tokensToLiquify > 0\r\n            && amountETHLiquidity > 0)\r\n        {\r\n            router.addLiquidityETH{ value: amountETHLiquidity }(\r\n                address(this),\r\n                _tokensToLiquify,\r\n                0,\r\n                0,\r\n                autoLiquidityReceiver,\r\n                block.timestamp\r\n            );\r\n            emit AutoLiquify(amountETHLiquidity, _tokensToLiquify);\r\n        }\r\n\r\n        //dividends\r\n        if (address(this).balance > 0)\r\n        {\r\n            try dividendDistributor.deposit{ value: amountETHReward }() {} catch {}\r\n        }\r\n    }\r\n\r\n    //========================\r\n    // ERC20 FUNCTIONS\r\n    //========================\r\n\r\n    function name() external view returns (string memory)\r\n    {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory)\r\n    {\r\n        return _symbol;    \r\n    }\r\n\r\n    function decimals() external view returns (uint8)\r\n    {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256)\r\n    {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    function balanceOf(address _account) public view override returns (uint256)\r\n    {\r\n        return _balances[_account];\r\n    }\r\n\r\n    function allowance(address _holder, address _spender) external view override returns (uint256)\r\n    {\r\n        return _allowances[_holder][_spender];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public override returns (bool)\r\n    {\r\n        _allowances[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address _spender) external returns (bool)\r\n    {\r\n        return approve(_spender, type(uint256).max);\r\n    }\r\n\r\n    //========================\r\n    // TRANSFER FUNCTIONS\r\n    //========================    \r\n    \r\n    function transfer(address _recipient, uint256 _amount) external override returns (bool)\r\n    {\r\n        return _transferFrom(msg.sender, _recipient, _amount);\r\n    }\r\n\r\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool)\r\n    {        \r\n        if (_allowances[_sender][msg.sender] != type(uint256).max)\r\n        {\r\n            _allowances[_sender][msg.sender] = _allowances[_sender][msg.sender].sub(_amount, \"Insufficient Allowance\");\r\n        }\r\n        return _transferFrom(_sender, _recipient, _amount);\r\n    }\r\n\r\n    function _transferFrom(address _sender, address _recipient, uint256 _amount) internal returns (bool)\r\n    {\r\n        require(!isBlacklisted[_sender], \"Sender is blacklisted\");\r\n        require(!isBlacklisted[_recipient], \"Recipient is blacklisted\");\r\n\r\n        //check if in liquify\r\n        if (inSwapAndLiquify)\r\n        {\r\n            return _basicTransfer(_sender, _recipient, _amount);\r\n        }\r\n\r\n        //check\r\n        if (_sender != owner()\r\n            && _recipient != owner())\r\n        {\r\n            require(tradingOpen, \"Trading not open yet\");\r\n        }\r\n        require(_amount <= _maxTxAmount || isTxLimitExempt[_sender], \"TX Limit Exceeded\");\r\n\r\n        //swap & liquify\r\n        if (msg.sender != pair\r\n            && !inSwapAndLiquify\r\n            && swapAndLiquifyEnabled\r\n            && _balances[address(this)] >= swapTokensAtHigh)\r\n        {\r\n            swapBack();\r\n        }\r\n\r\n        //check if launched\r\n        if (!launched()\r\n            && _recipient == pair)\r\n        {\r\n            require(_balances[_sender] > 0);\r\n            launch();\r\n        }\r\n\r\n        //exchange tokens\r\n        _balances[_sender] = _balances[_sender].sub(_amount, \"Insufficient Balance\");                \r\n        uint256 finalAmount = takeFee(_sender, _recipient, _amount);        \r\n        if (!isTxLimitExempt[_recipient]\r\n            && restrictWhales)\r\n        {\r\n            require(_balances[_recipient].add(finalAmount) <= _walletMax, \"Wallet is at whale limit\");\r\n        }\r\n        _balances[_recipient] = _balances[_recipient].add(finalAmount);\r\n\r\n        //track dividends & process\r\n        if (!isDividendExempt[_sender])\r\n        {\r\n            try dividendDistributor.setShare(_sender, _balances[_sender]) {} catch {}\r\n        }\r\n        if (!isDividendExempt[_recipient])\r\n        {\r\n            try dividendDistributor.setShare(_recipient, _balances[_recipient]) {} catch {} \r\n        }\r\n        try dividendDistributor.process(distributorGas) {} catch {}\r\n\r\n        //event\r\n        emit Transfer(_sender, _recipient, finalAmount);\r\n        return true;\r\n    }\r\n    \r\n    function _basicTransfer(address _sender, address _recipient, uint256 _amount) internal returns (bool)\r\n    {\r\n        _balances[_sender] = _balances[_sender].sub(_amount, \"Insufficient Balance\");\r\n        _balances[_recipient] = _balances[_recipient].add(_amount);\r\n        emit Transfer(_sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    //========================\r\n    // MODIFIERS\r\n    //========================\r\n\r\n    modifier lockTheSwap\r\n    {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n    //========================\r\n    // HELPER FUNCTIONS\r\n    //========================\r\n    \r\n    function launched() internal view returns (bool)\r\n    {\r\n        return (launchedAt != 0);\r\n    }\r\n\r\n    function launch() internal\r\n    {\r\n        launchedAt = block.timestamp;        \r\n        tradingOpen = true;\r\n    }\r\n    \r\n    //========================\r\n    // VESTING FUNCTIONS\r\n    //======================== \r\n\r\n    function withdrawVestedLiquidity() external onlyOwner\r\n    {\r\n        require(block.timestamp >= vestedUntil, \"Liquidity still locked\");\r\n        IERC20(pair).safeTransfer(msg.sender, IERC20(pair).balanceOf(address(this)));\r\n    }\r\n\r\n    function increaseVesting() external onlyOwner\r\n    {\r\n        vestedUntil += vestingPeriod;\r\n    }\r\n\r\n    //========================\r\n    // EMERGENCY FUNCTIONS\r\n    //======================== \r\n\r\n    function adminEmergencyWithdrawETH() external onlyOwner\r\n    {\r\n        uint256 balance = address(this).balance;\r\n        (bool success, ) = payable(msg.sender).call{ value: balance, gas: 30000 }(\"\");\r\n        success; //prevent warning\r\n    }\r\n\r\n    function adminEmergencyWithdrawToken(IERC20 _token) external onlyOwner\r\n    {\r\n        require(address(_token) != address(pair), \"Use withdrawVestedLiquidity for LP\");\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        _token.safeTransfer(msg.sender, balance);\r\n    }   \r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\ninterface IToken is IERC20\r\n{\r\n\tfunction decimals() external view returns (uint8);\t\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n}\r\n\r\n// File: contracts/Customers/MetaBomb.sol\r\n\r\ncontract MetaBomber is DividendToken\r\n{\r\n    constructor()\r\n    DividendToken(\r\n        0x10ED43C718714eb63d5aA57B78B54704E256024E, //PCS router\r\n        0x55d398326f99059fF775485246999027B3197955, //USDT reward\r\n        \"Meta Bomber\", //name\r\n        \"MBOMB\", //symbol\r\n        18, //decimals\r\n        (10 ** 12) * 1 ether, //total supply\r\n        0x3935e0c0e745D540977Af3FD556bD967F1F11Cc2, //owner\r\n        5 minutes, //anti sniper\r\n        2500 //max fee\r\n    )\r\n    {\r\n        //fees & wallet\r\n        setFees(\r\n            1, //buy\r\n            200, //liquidity\r\n            200, //reward\r\n            0, //team\r\n            300 //marketing            \r\n        );\r\n        setFees(\r\n            -1, //sell\r\n            200, //liquidity\r\n            400, //reward\r\n            0, //team\r\n            400 //marketing\r\n        );\r\n        setFees(\r\n            0, //p2p\r\n            0, //liquidity\r\n            0, //reward\r\n            0, //team\r\n            1000 //marketing\r\n        );\r\n        setFeeReceivers(\r\n            address(this), //auto liquidity\r\n            0xB87aaf6c05a07B76034026e89831Db78Ab67dBD1, //marketing\r\n            address(0) //team\r\n        );        \r\n\r\n        //dividends\r\n        setDistributionCriteria(\r\n            24 hours,\r\n            (10 ** IToken(address(dividendDistributor.rewardToken())).decimals()) * 5 / 10 //50 cent\r\n        );\r\n\r\n        vestingPeriod = 90;\r\n        setSwapTokensAtAmount(_totalSupply / 10000, _totalSupply / 1000); \r\n        setSwapBackSettings(true, true);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_walletMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminEmergencyWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"adminEmergencyWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendDistributor\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"getDynamicFee\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamFee\",\"type\":\"uint256\"}],\"internalType\":\"struct DividendToken.FeeInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shareholder\",\"type\":\"address\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"increaseVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDividendExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"manualSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"p2pFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restrictWhales\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"setDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"_feeType\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_blacklisted\",\"type\":\"bool\"}],\"name\":\"setIsBlacklisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"_feeType\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"_feeType\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setMarketingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setRestrictWhales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"_feeType\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setRewardFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enableSwapBack\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_swapByLimitOnly\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_low\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_high\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"_feeType\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setTeamFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setTradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyByLimitOnly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtHigh\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtLow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawVestedLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MetaBomber", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6dcf6618c9fcc4587534fdea7b629529060bd7972a94e8d690121ae89ae47576"}