{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract EvuStaking {\r\n    using SafeMath for uint;\r\n    //Estableces contrato del token para Staking\r\n    IERC20 public stakingToken;\r\n    //Estrutura de variable deposito de staking\r\n    //Amount : monto depositados del usuario\r\n    //initTime ; Fecha de deposito del token\r\n    //endLock: Fecha de debloqueo de token\r\n    //status: Estado de la wallet para ganar o no\r\n    //wrewars: Token Retirado de gancia\r\n    //rewars: Token Ganado\r\n    struct Staking{\r\n        uint amount;\r\n        uint rewards;\r\n        uint initTime;\r\n        uint endLock;\r\n        uint wreward;\r\n        uint lastrewards;\r\n        uint initpcent;\r\n    }\r\n    /////POR CIENTO DEL API %/////////////////\r\n    uint private Percent = 250;\r\n    \r\n    //Establecer porcentaje de ganacias por mes\r\n    //Cada nuemero representa un % y un mes desde la posicion 0\r\n\r\n    uint[] private Meses = [350,400,480,560,650,800,940,1040,1100,1150,1240,1290];\r\n \r\n    address[] public qwallets;\r\n\r\n    //Bonos wallet\r\n    mapping(address => uint) public _bonos;\r\n\r\n    mapping(address => bool) private _existe;\r\n    /////Estableces Variables Necesarias/////\r\n    // 14 DIAS, 30 DIAS, 90 DIAS, 180 DIAS, 180 DIAS\r\n    uint private undia = 1 days;\r\n    uint public currentTime = block.timestamp;\r\n    mapping(address => Staking[]) public qTokenStake;\r\n    uint public _totalSupply;\r\n    uint public _balances;\r\n    ///Declarar owen\r\n    address public owen;\r\n   //VARIABLE DE ESTADO True and False\r\n    bool private active = true;\r\n    \r\n    constructor(address _addresToken,address _addressOwen){\r\n        stakingToken = IERC20(_addresToken);\r\n        owen = _addressOwen;\r\n    }\r\n\r\n    ///porcentages por meces\r\n    function getTotalRewards(address _addr, uint _index) public view returns(uint) {\r\n        ///  require(qTokenStake[_addr][_index].amount > 0,\"getTotalRewards: No tienes fondos suficientes...\");\r\n        //Multiplicar monto  de stake por el porciento del mes =  renta mensual / 30 dias\r\n        ///PROBLEMA SE RECIBE UN DECIMAL POR TANTO NO ES SOLUCION\r\n       // uint _tamount = qTokenStake[_addr][_index].amount.div(100);\r\n        uint _tamount = qTokenStake[_addr][_index].amount;\r\n        uint _result = 0;\r\n        uint endLock = 0;\r\n         _result+=(qTokenStake[_addr][_index].rewards);\r\n         if(qTokenStake[_addr][_index].endLock > qTokenStake[_addr][_index].lastrewards){\r\n           endLock = qTokenStake[_addr][_index].endLock.sub(qTokenStake[_addr][_index].lastrewards);\r\n        \r\n        uint _rewardSec = block.timestamp.sub(qTokenStake[_addr][_index].lastrewards);\r\n\r\n        uint qmes = 1;\r\n        if(_rewardSec > 30 days){\r\n            qmes = (_rewardSec / 30 days) +1;\r\n        }\r\n        \r\n        if(_rewardSec > endLock && endLock > 30 days){\r\n            qmes = endLock / 30 days;\r\n        }\r\n        if(_rewardSec < 30 days){\r\n            qmes = 1;\r\n        }\r\n  \r\n       // uint tsegundos = _totalSec;\r\n        if(_rewardSec > endLock){\r\n            _rewardSec = endLock;\r\n        }\r\n  \r\n        uint totals;\r\n        uint _c = qTokenStake[_addr][_index].initpcent;\r\n       \r\n         totals = _rewardSec;//gs.sub(_mdias);\r\n        for(uint i = 1; i<=qmes; i++){      \r\n             if(_c >= 11 ){\r\n                _c = 11;\r\n               }\r\n                if(i<2){\r\n                  if(_rewardSec < 30 days){\r\n                    _result  += _rewardSec * getPaymonSec(_tamount,_c);  \r\n                    \r\n                  }else{\r\n                    _result  += 30 days * getPaymonSec(_tamount,_c);  \r\n                    totals -= 30 days;\r\n                  }\r\n                }else{\r\n                    \r\n                    if(totals >= 30 days){\r\n                      _result += 30 days * getPaymonSec(_tamount,_c);  \r\n                      totals -= 30 days;\r\n                    }else{\r\n                      _result += totals * getPaymonSec(_tamount,_c);  \r\n                    }\r\n                }\r\n        \r\n             _c++;\r\n        }\r\n\r\n           \r\n           // _result-=qTokenStake[_addr][_index].wreward;\r\n         }\r\n       \r\n            return _result;\r\n        \r\n    } \r\n    //////////////OPTENER POR CIENTO/////////////////////\r\n    function getPercent(uint _mes) public view returns(uint){\r\n      ///  uint _pg = Percent / 100;\r\n       return  Percent * Meses[_mes];\r\n    }\r\n    ////////////Optener Monto pagado por segundo////////////////\r\n    function getPaymonSec(uint _amount,uint _mes) public view returns(uint){ \r\n       return ((_amount * getPercent(_mes)) / 1000000) / 30 days;\r\n       // 1000,000,000,000 * (250 * 350) / 1000000 / 30 = 60*60*24*30\r\n    }\r\n      /////////modificador administrador///////////\r\n       /////////Para bonos ICO///////////\r\n    modifier BonosAllow(address _addr) {\r\n            require(_bonos[_addr] < 4,\"This wallet has no authorization\");\r\n        _;\r\n    }\r\n    /////////Desposito al contrato de Staking//////////////\r\n    /////////Bloqueando wallet/////////\r\n    function stake(uint _amount,uint _dias) external BonosAllow(msg.sender) {\r\n        uint bb = 0;\r\n        if(_bonos[msg.sender] == 1){\r\n           //Empezar con dos meses - Option 1\r\n            bb = 2;\r\n        }else if(_bonos[msg.sender] == 2){\r\n          //Empezar con un mes - Option 2\r\n            bb = 1;\r\n         }\r\n         uint qdias = _dias.mul(undia) + block.timestamp;\r\n         qTokenStake[msg.sender].push(Staking(_amount,0,block.timestamp,qdias,0,block.timestamp,bb)); \r\n        _totalSupply += _amount;\r\n         stakingToken.transferFrom(msg.sender, address(this), _amount);\r\n          if (!_existe[msg.sender]) {\r\n            qwallets.push(msg.sender);\r\n        }\r\n         _existe[msg.sender] = true;\r\n    }\r\n    /////////ReStaking: luego de terminar el tiempo de staking agregarlo de nuevo///////////////\r\n    function restaking(uint _dias,uint _index) public returns(bool){\r\n         require(qTokenStake[msg.sender][_index].amount > 0,\"restaking: Insufficient funds\");\r\n         require(block.timestamp > qTokenStake[msg.sender][_index].endLock,\"restaking: funds still locked...\");\r\n         uint qdias = _dias.mul(undia) + block.timestamp;\r\n         qTokenStake[msg.sender][_index].rewards = getTotalRewards(msg.sender, _index);\r\n         qTokenStake[msg.sender][_index].endLock = qdias;\r\n         qTokenStake[msg.sender][_index].lastrewards = block.timestamp;\r\n         qTokenStake[msg.sender][_index].initpcent = (block.timestamp.sub(qTokenStake[msg.sender][_index].initTime) / 30 days)+1;\r\n         return true;\r\n    }\r\n    //////////Retirar Dinero del Staking//////////////////\r\n    function unStaking(uint _index) public returns(bool) {\r\n       require(qTokenStake[msg.sender][_index].amount > 0,\"unStaking: Insufficient funds\");\r\n       require(block.timestamp > qTokenStake[msg.sender][_index].endLock,\"unStaking: funds still locked...\");\r\n        _totalSupply -= qTokenStake[msg.sender][_index].amount;\r\n         uint reward2 = getTotalRewards(msg.sender, _index);\r\n         uint totalg = reward2 + qTokenStake[msg.sender][_index].amount;\r\n         stakingToken.transfer(msg.sender,totalg);\r\n         qTokenStake[msg.sender][_index].amount = 0;\r\n         qTokenStake[msg.sender][_index].rewards = 0;\r\n         qTokenStake[msg.sender][_index].initTime = 0;\r\n         qTokenStake[msg.sender][_index].endLock = 0;\r\n         qTokenStake[msg.sender][_index].lastrewards = 0;\r\n        return true;\r\n    }\r\n    ////////Reclamar recompensas ganadas por Staking/////////////////////\r\n    function ClaimReward(uint _index) public returns(bool) {\r\n        uint reward = getTotalRewards(msg.sender, _index);\r\n        require(reward > 0,\"ClaimReward: You have no rewards...\");\r\n        require(_balances > 0,\"ClaimReward: Insufficient funds...\");\r\n        _balances -= reward;\r\n        stakingToken.transfer(msg.sender, reward);\r\n        qTokenStake[msg.sender][_index].wreward += reward;\r\n        qTokenStake[msg.sender][_index].rewards = 0;\r\n        qTokenStake[msg.sender][_index].lastrewards = block.timestamp;\r\n        qTokenStake[msg.sender][_index].initpcent = (block.timestamp.sub(qTokenStake[msg.sender][_index].initTime) / 30 days)+1;\r\n        return true;\r\n    }\r\n    /////////modificador administrador///////////\r\n    modifier AdminOwen(address _admin) {\r\n            require(_admin == owen,\"You do not have authorization\");\r\n        _;\r\n    }\r\n    //////PORCENTAJE PUBLICO////////\r\n   function ShowPercent() public  view returns(uint) {\r\n          return Percent;\r\n    }\r\n \r\n     //////MODIFICAR POR CIENTO ANUAL - SOLO ADMIN////////\r\n    function UpdatePercentRewards(uint _pcent) public AdminOwen(msg.sender) {\r\n         Percent = _pcent;\r\n        ///////Parsea todas las walllet/////////\r\n        for (uint256 i = 0; i < qwallets.length; i++) {\r\n            address _recipient = qwallets[i];\r\n            uint _cadr = qTokenStake[_recipient].length;\r\n            //////parseas las wallet por usuarios//////////\r\n            for(uint _index = 0; _index < _cadr; _index++){\r\n                uint reward = getTotalRewards(_recipient, _index);\r\n                if(reward > 0){ \r\n                    qTokenStake[_recipient][_index].rewards += reward;\r\n                    qTokenStake[_recipient][_index].lastrewards = block.timestamp;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ///////Contar lista de inversion//////\r\n     function getCount(address _addr) public view returns(uint){\r\n        return qTokenStake[_addr].length;\r\n    }\r\n    /////////DEPOSITO DE BALANCE///////////////\r\n     function deposit(uint _amount) public\r\n      {\r\n         stakingToken.transferFrom(msg.sender, address(this), _amount);\r\n         _balances += _amount;\r\n      }\r\n    //////Get lista de inversion////////\r\n    function getAccounts(address _addr, uint _index) public view returns(uint,uint,uint,uint,uint,uint){\r\n       return (\r\n              qTokenStake[_addr][_index].amount,\r\n              qTokenStake[_addr][_index].rewards,\r\n              qTokenStake[_addr][_index].initTime,\r\n              qTokenStake[_addr][_index].endLock,\r\n              qTokenStake[_addr][_index].wreward,\r\n              qTokenStake[_addr][_index].lastrewards\r\n              );\r\n    }\r\n\r\n    function AddBonos(\r\n        address[] memory _targets,\r\n        uint[] memory _option\r\n    )\r\n    external\r\n    returns (bool) {\r\n       require(msg.sender == owen,\"You do not have authorization\");\r\n        uint len = _targets.length;\r\n        require(len > 0); \r\n        for (uint i = 0; i < len; i = i.add(1)) {\r\n            address _target = _targets[i];\r\n            uint option = _option[i];\r\n            _bonos[_target] = option;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n}\r\n  ////INTERFACE NECESARIA PARA LAS RELAIZACION DE TRANZACIONES EN EL STAKING\r\n  interface IERC20 {\r\n      function totalSupply() external view returns (uint);\r\n\r\n      function balanceOf(address account) external view returns (uint);\r\n\r\n      function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n      function allowance(address owner, address spender) external view returns (uint);\r\n\r\n      function approve(address spender, uint amount) external returns (bool);\r\n\r\n      function transferFrom(\r\n          address sender,\r\n          address recipient,\r\n          uint amount\r\n      ) external returns (bool);\r\n\r\n      event Transfer(address indexed from, address indexed to, uint value);\r\n      event Approval(address indexed owner, address indexed spender, uint value);\r\n  }", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addresToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressOwen\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_option\",\"type\":\"uint256[]\"}],\"name\":\"AddBonos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ShowPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pcent\",\"type\":\"uint256\"}],\"name\":\"UpdatePercentRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_bonos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mes\",\"type\":\"uint256\"}],\"name\":\"getPaymonSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mes\",\"type\":\"uint256\"}],\"name\":\"getPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owen\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"qTokenStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endLock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastrewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initpcent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"qwallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dias\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"restaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dias\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"unStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EvuStaking", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000018b5f22266343ccd180c6285a66cc9a23dc262e90000000000000000000000002c620e855cb81e727adf35c858d5a493d7fad859", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://877b830973f8f136a750992382805c0753acf10055c3b553bd2434689b042448"}