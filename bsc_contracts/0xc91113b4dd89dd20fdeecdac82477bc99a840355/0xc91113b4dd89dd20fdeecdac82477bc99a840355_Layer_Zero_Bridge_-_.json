{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title Layer Zero Bridge - Curve DAO Token\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\n\r\ninterface ERC20:\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def transfer(_to: address, _value: uint256): nonpayable\r\n    def burn(_value: uint256) -> bool: nonpayable\r\n\r\ninterface LZEndpoint:\r\n    def send(\r\n        _dst_chain_id: uint16,\r\n        _destination: Bytes[40],\r\n        _payload: Bytes[64],\r\n        _refund_address: address,\r\n        _zro_payment_address: address,\r\n        _adapter_params: Bytes[34]\r\n    ): payable\r\n    def estimateFees(\r\n        _dst_chain_id: uint16,\r\n        _user_application: address,\r\n        _payload: Bytes[64],\r\n        _pay_in_zro: bool,\r\n        _adapter_params: Bytes[34]\r\n    ) -> uint256: view\r\n\r\ninterface Minter:\r\n    def mint(_gauge: address): nonpayable\r\n\r\n\r\nevent BridgeSent:\r\n    receiver: indexed(address)\r\n    amount: uint256\r\n\r\nevent BridgeReceived:\r\n    receiver: indexed(address)\r\n    amount: uint256\r\n\r\nevent Delayed:\r\n    nonce: indexed(uint64)\r\n    receiver: indexed(address)\r\n    amount: uint256\r\n\r\nevent SetPeriod:\r\n    period: uint256\r\n\r\nevent SetLimit:\r\n    limit: uint256\r\n\r\nevent SetGasLimit:\r\n    gas_limit: uint256\r\n\r\nevent SetKilled:\r\n    killed: bool\r\n\r\nevent TransferOwnership:\r\n    owner: address\r\n\r\n\r\nTOKEN: public(immutable(address))\r\nMINTER: public(immutable(address))\r\nLZ_ENDPOINT: public(immutable(address))\r\n\r\nTOKEN_MIRROR: immutable(address)  # token address on the other side of the bridge\r\nLZ_CHAIN_ID: immutable(uint16)\r\nLZ_ADDRESS: immutable(Bytes[40])\r\nKECCAK_LZ_ADDRESS: immutable(bytes32)\r\n\r\n\r\nintegrate_fraction: public(HashMap[address, uint256])\r\n\r\ncache: uint256  # [last timestamp uint64][last available uint192]\r\nlimit: public(uint256)\r\nperiod: public(uint256)\r\n\r\ndelayed: public(HashMap[uint64, bytes32])\r\n\r\ngas_limit: public(uint256)\r\nis_killed: public(bool)\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _period: uint256,\r\n    _limit: uint256,\r\n    _gas_limit: uint256,\r\n    _token: address,\r\n    _minter: address,\r\n    _lz_endpoint: address,\r\n    _token_mirror: address,\r\n    _lz_chain_id: uint16\r\n):\r\n    assert _period != 0\r\n\r\n    self.period = _period\r\n    log SetPeriod(_period)\r\n\r\n    self.limit = _limit\r\n    log SetLimit(_limit)\r\n\r\n    self.gas_limit = _gas_limit\r\n    log SetGasLimit(_gas_limit)\r\n\r\n    self.owner = msg.sender\r\n    log TransferOwnership(msg.sender)\r\n\r\n    TOKEN = _token\r\n    MINTER = _minter\r\n    LZ_ENDPOINT = _lz_endpoint\r\n\r\n    TOKEN_MIRROR = _token_mirror\r\n    LZ_CHAIN_ID = _lz_chain_id\r\n    LZ_ADDRESS = concat(\r\n        slice(convert(self, bytes32), 12, 20), slice(convert(self, bytes32), 12, 20)\r\n    )\r\n    KECCAK_LZ_ADDRESS = keccak256(LZ_ADDRESS)\r\n\r\n\r\n@payable\r\n@external\r\ndef bridge(_receiver: address, _amount: uint256, _refund: address = msg.sender):\r\n    \"\"\"\r\n    @notice Bridge tokens.\r\n    \"\"\"\r\n    assert not self.is_killed\r\n    assert _receiver not in [empty(address), TOKEN_MIRROR] and _amount != 0\r\n\r\n    assert ERC20(TOKEN).transferFrom(msg.sender, self, _amount)\r\n    assert ERC20(TOKEN).burn(_amount)\r\n\r\n    LZEndpoint(LZ_ENDPOINT).send(\r\n        LZ_CHAIN_ID,\r\n        LZ_ADDRESS,\r\n        _abi_encode(_receiver, _amount),\r\n        _refund,\r\n        empty(address),\r\n        concat(b\"\\x00\\x01\", convert(self.gas_limit, bytes32)),\r\n        value=msg.value\r\n    )\r\n\r\n    log BridgeSent(_receiver, _amount)\r\n\r\n\r\n@external\r\ndef lzReceive(_lz_chain_id: uint16, _lz_address: Bytes[40], _nonce: uint64, _payload: Bytes[64]):\r\n    assert msg.sender == LZ_ENDPOINT\r\n\r\n    assert _lz_chain_id == LZ_CHAIN_ID\r\n    assert keccak256(_lz_address) == KECCAK_LZ_ADDRESS\r\n\r\n    receiver: address = empty(address)\r\n    amount: uint256 = empty(uint256)\r\n    receiver, amount = _abi_decode(_payload, (address, uint256))\r\n\r\n    if receiver in [empty(address), TOKEN] or amount == 0:\r\n        # safeguard\r\n        return\r\n\r\n    limit: uint256 = self.limit\r\n\r\n    if self.is_killed or amount > limit:\r\n        self.delayed[_nonce] = keccak256(_abi_encode(block.timestamp, receiver, amount))\r\n        log Delayed(_nonce, receiver, amount)\r\n        return\r\n\r\n    cache: uint256 = self.cache\r\n    ts: uint256 = cache >> 192\r\n    available: uint256 = cache & convert(max_value(uint192), uint256)\r\n\r\n    period: uint256 = self.period\r\n\r\n    if period <= (block.timestamp - ts):\r\n        available = limit\r\n    else:\r\n        # regenerate amount which is available to mint at a rate of (limit / period)\r\n        available = min(available + (limit * (block.timestamp - ts) / period), limit)\r\n\r\n    if amount > available:\r\n        remainder: uint256 = amount - available\r\n        amount = available\r\n        available = 0\r\n\r\n        # delay the remainder\r\n        self.delayed[_nonce] = keccak256(_abi_encode(block.timestamp, receiver, remainder))\r\n        log Delayed(_nonce, receiver, remainder)\r\n    else:\r\n        available -= amount\r\n\r\n    self.cache = (block.timestamp << 192) + available\r\n\r\n    if amount != 0:\r\n        self.integrate_fraction[self] += amount\r\n\r\n        Minter(MINTER).mint(self)\r\n        ERC20(TOKEN).transfer(receiver, amount)\r\n        log BridgeReceived(receiver, amount)\r\n\r\n\r\n@external\r\ndef retry(_nonce: uint64, _timestamp: uint256, _receiver: address, _amount: uint256):\r\n    \"\"\"\r\n    @notice Retry a delayed bridge attempt.\r\n    \"\"\"\r\n    assert not self.is_killed or msg.sender == self.owner\r\n    assert self.delayed[_nonce] == keccak256(_abi_encode(_timestamp, _receiver, _amount))\r\n\r\n    self.delayed[_nonce] = empty(bytes32)\r\n\r\n    period: uint256 = self.period\r\n    assert block.timestamp >= _timestamp + period\r\n\r\n    cache: uint256 = self.cache\r\n    ts: uint256 = cache >> 192\r\n    available: uint256 = cache & convert(max_value(uint192), uint256)\r\n\r\n    limit: uint256 = self.limit\r\n\r\n    if period <= (block.timestamp - ts):\r\n        available = limit\r\n    else:\r\n        available = min(available + (limit * (block.timestamp - ts) / period), limit)\r\n\r\n    amount: uint256 = _amount\r\n    if amount > available:\r\n        remainder: uint256 = amount - available\r\n        amount = available\r\n        available = 0\r\n\r\n        # delay the remainder with the waiting period removed\r\n        self.delayed[_nonce] = keccak256(_abi_encode(_timestamp, _receiver, remainder))\r\n        log Delayed(_nonce, _receiver, remainder)\r\n    else:\r\n        available -= amount\r\n\r\n    self.cache = (block.timestamp << 192) + available\r\n\r\n    if amount != 0:\r\n        self.integrate_fraction[self] += amount\r\n\r\n        Minter(MINTER).mint(self)\r\n        ERC20(TOKEN).transfer(_receiver, amount)\r\n        log BridgeReceived(_receiver, amount)\r\n\r\n\r\n@view\r\n@external\r\ndef quote() -> uint256:\r\n    \"\"\"\r\n    @notice Quote the cost to bridge tokens.\r\n    \"\"\"\r\n    return LZEndpoint(LZ_ENDPOINT).estimateFees(\r\n        LZ_CHAIN_ID,\r\n        self,\r\n        _abi_encode(self, block.timestamp),\r\n        False,\r\n        concat(b\"\\x00\\x01\", convert(self.gas_limit, bytes32)),\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef available() -> uint256:\r\n    \"\"\"\r\n    @notice Query the available amount this bridge can currently mint.\r\n    \"\"\"\r\n    cache: uint256 = self.cache\r\n    ts: uint256 = cache >> 192\r\n    available: uint256 = cache & convert(max_value(uint192), uint256)\r\n\r\n    limit: uint256 = self.limit\r\n    period: uint256 = self.period\r\n\r\n    if period <= (block.timestamp - ts):\r\n        available = limit\r\n    else:\r\n        # regenerate amount which is available to mint at a rate of (limit / period)\r\n        available = min(available + (limit * (block.timestamp - ts) / period), limit)\r\n\r\n    return available\r\n\r\n\r\n@external\r\ndef user_checkpoint(_user: address) -> bool:\r\n    return True\r\n\r\n\r\n@external\r\ndef set_period(_period: uint256):\r\n    \"\"\"\r\n    @notice Set the bridge limit period.\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert _period != 0\r\n\r\n    self.period = _period\r\n    log SetPeriod(_period)\r\n\r\n\r\n@external\r\ndef set_limit(_limit: uint256):\r\n    \"\"\"\r\n    @notice Set the bridge limit.\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    self.limit = _limit\r\n    log SetLimit(_limit)\r\n\r\n\r\n@external\r\ndef set_gas_limit(_gas_limit: uint256):\r\n    \"\"\"\r\n    @notice Set the gas limit for bridge execution.\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    self.gas_limit = _gas_limit\r\n    log SetGasLimit(_gas_limit)\r\n\r\n\r\n@external\r\ndef set_killed(_killed: bool):\r\n    assert msg.sender == self.owner\r\n\r\n    self.is_killed = _killed\r\n    log SetKilled(_killed)\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_future_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership to `_future_owner`\r\n    @param _future_owner The account to commit as the future owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.future_owner = _future_owner\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept the transfer of ownership\r\n    @dev Only the committed future owner can call this function\r\n    \"\"\"\r\n    assert msg.sender == self.future_owner  # dev: only future owner\r\n\r\n    self.owner = msg.sender\r\n    log TransferOwnership(msg.sender)", "ABI": "[{\"name\":\"BridgeSent\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BridgeReceived\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Delayed\",\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint64\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPeriod\",\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetLimit\",\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetGasLimit\",\"inputs\":[{\"name\":\"gas_limit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetKilled\",\"inputs\":[{\"name\":\"killed\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"},{\"name\":\"_gas_limit\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_minter\",\"type\":\"address\"},{\"name\":\"_lz_endpoint\",\"type\":\"address\"},{\"name\":\"_token_mirror\",\"type\":\"address\"},{\"name\":\"_lz_chain_id\",\"type\":\"uint16\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"bridge\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"bridge\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_refund\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"lzReceive\",\"inputs\":[{\"name\":\"_lz_chain_id\",\"type\":\"uint16\"},{\"name\":\"_lz_address\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint64\"},{\"name\":\"_payload\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"retry\",\"inputs\":[{\"name\":\"_nonce\",\"type\":\"uint64\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"quote\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"available\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_period\",\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_limit\",\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_gas_limit\",\"inputs\":[{\"name\":\"_gas_limit\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_killed\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"TOKEN\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"MINTER\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"LZ_ENDPOINT\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"limit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delayed\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint64\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gas_limit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Layer Zero Bridge - Curve DAO Token", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007a1200000000000000000000000009996d0276612d23b35f90c51ee935520b3d7355b000000000000000000000000458599f83764ae9d0528301c1b6cb18de63726bf0000000000000000000000003c2269811836af69497e5f486a85d7316753cf62000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd520000000000000000000000000000000000000000000000000000000000000065", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}