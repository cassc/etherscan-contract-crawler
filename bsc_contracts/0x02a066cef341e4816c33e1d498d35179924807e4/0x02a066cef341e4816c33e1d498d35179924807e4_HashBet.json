{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/HashBetV.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract HashBet is Ownable, ReentrancyGuard {\r\n    // Modulo is the number of equiprobable outcomes in a game:\r\n    //  2 for coin flip\r\n    //  6 for dice roll\r\n    //  6*6 = 36 for double dice\r\n    //  37 for roulette\r\n    //  100 for hashroll\r\n    uint constant MAX_MODULO = 100;\r\n\r\n    // Modulos below MAX_MASK_MODULO are checked against a bit mask, allowing betting on specific outcomes. \r\n    // For example in a dice roll (modolo = 6), \r\n    // 000001 mask means betting on 1. 000001 converted from binary to decimal becomes 1.\r\n    // 101000 mask means betting on 4 and 6. 101000 converted from binary to decimal becomes 40.\r\n    // The specific value is dictated by the fact that 256-bit intermediate\r\n    // multiplication result allows implementing population count efficiently\r\n    // for numbers that are up to 42 bits, and 40 is the highest multiple of\r\n    // eight below 42.\r\n    uint constant MAX_MASK_MODULO = 40;\r\n    \r\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\r\n    // past. Given that settleBet uses block hash of placeBet as one of\r\n    // complementary entropy sources, we cannot process bets older than this\r\n    // threshold. On rare occasions dice2.win croupier may fail to invoke\r\n    // settleBet in this timespan due to technical issues or extreme Ethereum\r\n    // congestion; such bets can be refunded via invoking refundBet.\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n    // Some deliberately invalid address to initialize the secret signer with.\r\n    // Forces maintainers to invoke setSecretSigner before processing any bets.\r\n    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n     // This is a check on bet mask overflow. Maximum mask is equivalent to number of possible binary outcomes for maximum modulo.\r\n    uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\r\n\r\n    // These are constants taht make O(1) population count in placeBet possible.\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F;\r\n\r\n    // Sum of all historical deposits and withdrawals. Used for calculating profitability. Profit = Balance - cumulativeDeposit + cumulativeWithdrawal\r\n    uint public cumulativeDeposit;\r\n    uint public cumulativeWithdrawal;\r\n\r\n    // In addition to house edge, wealth tax is added every time the bet amount exceeds a multiple of a threshold.\r\n    // For example, if wealthTaxIncrementThreshold = 3000 ether,\r\n    // A bet amount of 3000 ether will have a wealth tax of 1% in addition to house edge.\r\n    // A bet amount of 6000 ether will have a wealth tax of 2% in addition to house edge.\r\n    uint public wealthTaxIncrementThreshold = 3000 ether;\r\n    uint public wealthTaxIncrementPercent = 1;\r\n\r\n    // The minimum and maximum bets.\r\n    uint public minBetAmount = 0.01 ether;\r\n    uint public maxBetAmount = 10000 ether;\r\n\r\n    // max bet profit. Used to cap bets against dynamic odds.\r\n    uint public maxProfit = 300000 ether;\r\n\r\n    // Funds that are locked in potentially winning bets. Prevents contract from committing to new bets that it cannot pay out.\r\n    uint public lockedInBets;\r\n\r\n    // The minimum larger comparison value.\r\n    uint public minOverValue = 1;\r\n\r\n    // The maximum smaller comparison value.\r\n    uint public maxUnderValue = 98;\r\n\r\n    // The address corresponding to a private key used to sign placeBet commits.\r\n    address public secretSigner;\r\n\r\n    // Croupier account.\r\n    address public croupier;\r\n\r\n    // Info of each bet.\r\n    struct Bet {\r\n        // Wager amount in wei.\r\n        uint amount;\r\n        // Modulo of a game.\r\n        uint8 modulo;\r\n        // Number of winning outcomes, used to compute winning payment (* modulo/rollEdge),\r\n        // and used instead of mask for games with modulo > MAX_MASK_MODULO.\r\n        uint8 rollEdge;\r\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\r\n        uint40 mask;\r\n        // Block number of placeBet tx.\r\n        uint placeBlockNumber;\r\n        // Address of a gambler, used to pay out winning bets.\r\n        address payable gambler;\r\n        // Status of bet settlement.\r\n        bool isSettled;\r\n        // Outcome of bet.\r\n        uint outcome;\r\n        // Win amount.\r\n        uint winAmount;\r\n        // Random number used to settle bet.\r\n        uint randomNumber;\r\n        // Keccak256 hash of some secret \"reveal\" random number.\r\n        uint commit;\r\n        // Comparison method.\r\n        bool isLarger;\r\n    }\r\n    \r\n    // Each bet is deducted dynamic\r\n    uint public defaultHouseEdgePercent = 2;\r\n\r\n    // Mapping from commits to all currently active & processed bets.\r\n    mapping (uint => Bet) public bets;\r\n\r\n    mapping(uint32 => uint32) public houseEdgePercents;\r\n\r\n    // Events\r\n    event BetPlaced(address indexed gambler, uint amount, uint8 indexed modulo, uint8 rollEdge, uint40 mask, uint commit, bool isLarger);\r\n    event BetSettled(address indexed gambler, uint amount, uint8 indexed modulo, uint8 rollEdge, uint40 mask, uint commit, uint outcome, uint winAmount);\r\n    event BetRefunded(address indexed gambler, uint amount);\r\n\r\n    constructor () Ownable() {\r\n        secretSigner = DUMMY_ADDRESS;\r\n        croupier = DUMMY_ADDRESS;\r\n        houseEdgePercents[2] = 1;\r\n        houseEdgePercents[6] = 1;\r\n        houseEdgePercents[36] = 1;\r\n        houseEdgePercents[37] = 3;\r\n        houseEdgePercents[100] = 5;\r\n    }\r\n\r\n     // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyCroupier {\r\n        require (msg.sender == croupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n    // Fallback payable function used to top up the bank roll.\r\n    fallback() external payable {\r\n        cumulativeDeposit += msg.value;\r\n    }\r\n    receive() external payable {\r\n        cumulativeDeposit += msg.value;\r\n    }\r\n\r\n    // See comment for \"secretSigner\" variable.\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    // Change the croupier address.\r\n    function setCroupier(address newCroupier) external onlyOwner {\r\n        croupier = newCroupier;\r\n    }\r\n\r\n    // See ETH balance.\r\n    function getBalance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n        // Set default house edge percent\r\n    function setDefaultHouseEdgePercent(uint _houseEdgePercent) external onlyOwner {\r\n        require(\r\n            _houseEdgePercent >= 1 && _houseEdgePercent <= 100,\r\n            \"houseEdgePercent must be a sane number\"\r\n        );\r\n        defaultHouseEdgePercent = _houseEdgePercent;\r\n    }\r\n\r\n    // Set modulo house edge percent\r\n    function setModuloHouseEdgePercent(uint32 _houseEdgePercent, uint32 modulo) external onlyOwner {\r\n        require(\r\n            _houseEdgePercent >= 1 && _houseEdgePercent <= 100,\r\n            \"houseEdgePercent must be a sane number\"\r\n        );\r\n        houseEdgePercents[modulo] = _houseEdgePercent;\r\n    }\r\n\r\n    // Set min bet amount. minBetAmount should be large enough such that its house edge fee can cover the Chainlink oracle fee.\r\n    function setMinBetAmount(uint _minBetAmount) external onlyOwner {\r\n        minBetAmount = _minBetAmount * 1 gwei;\r\n    }\r\n\r\n    // Set max bet amount.\r\n    function setMaxBetAmount(uint _maxBetAmount) external onlyOwner {\r\n        require (_maxBetAmount < 5000000 ether, \"maxBetAmount must be a sane number\");\r\n        maxBetAmount = _maxBetAmount;\r\n    }\r\n\r\n    // Set max bet reward. Setting this to zero effectively disables betting.\r\n    function setMaxProfit(uint _maxProfit) external onlyOwner {\r\n        require (_maxProfit < 50000000 ether, \"maxProfit must be a sane number\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    // Set wealth tax percentage to be added to house edge percent. Setting this to zero effectively disables wealth tax.\r\n    function setWealthTaxIncrementPercent(uint _wealthTaxIncrementPercent) external onlyOwner {\r\n        wealthTaxIncrementPercent = _wealthTaxIncrementPercent;\r\n    }\r\n\r\n    // Set threshold to trigger wealth tax.\r\n    function setWealthTaxIncrementThreshold(uint _wealthTaxIncrementThreshold) external onlyOwner {\r\n        wealthTaxIncrementThreshold = _wealthTaxIncrementThreshold;\r\n    }\r\n\r\n    // Owner can withdraw funds not exceeding balance minus potential win prizes by open bets\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Withdrawal amount larger than balance.\");\r\n        require (withdrawAmount <= address(this).balance - lockedInBets, \"Withdrawal amount larger than balance minus lockedInBets\");\r\n        beneficiary.transfer(withdrawAmount);\r\n        cumulativeWithdrawal += withdrawAmount;\r\n    }\r\n\r\n    function emitBetPlacedEvent(address gambler, uint amount, uint8 modulo, uint8 rollEdge, uint40 mask, uint commit, bool isLarger) private\r\n    {\r\n        // Record bet in event logs\r\n        emit BetPlaced(gambler, amount, uint8(modulo), uint8(rollEdge), uint40(mask), commit, isLarger);\r\n    }\r\n\r\n    // Place bet\r\n    function placeBet(uint betMask, uint modulo, uint commitLastBlock, uint commit, bool isLarger, bytes32 r, bytes32 s) external payable nonReentrant {\r\n\r\n        Bet storage bet = bets[commit];\r\n        require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        uint amount = msg.value;\r\n\r\n        validateArguments(amount, betMask, modulo, commitLastBlock, commit, isLarger, r, s);\r\n\r\n        uint rollEdge;\r\n        uint mask;\r\n\r\n        if (modulo <= MAX_MASK_MODULO) {\r\n            // Small modulo games can specify exact bet outcomes via bit mask.\r\n            // rollEdge is a number of 1 bits in this mask (population count).\r\n            // This magic looking formula is an efficient way to compute population\r\n            // count on EVM for numbers below 2**40. \r\n            rollEdge = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n            mask = betMask;\r\n        } else {\r\n            // Larger modulos games specify the right edge of half-open interval of winning bet outcomes.\r\n            require (betMask > 0 && betMask <= modulo, \"High modulo range, betMask larger than modulo.\");\r\n            rollEdge = betMask;\r\n        }\r\n\r\n        // Winning amount.\r\n        uint possibleWinAmount = getDiceWinAmount(amount, modulo, rollEdge, isLarger);\r\n\r\n        // Check whether contract has enough funds to accept this bet.\r\n        require (lockedInBets + possibleWinAmount <= address(this).balance, \"Unable to accept bet due to insufficient funds\");\r\n\r\n        // Update lock funds.\r\n        lockedInBets += possibleWinAmount;\r\n\r\n        // Store bet\r\n        bet.amount=amount;\r\n        bet.modulo=uint8(modulo);\r\n        bet.rollEdge=uint8(rollEdge);\r\n        bet.mask=uint40(mask);\r\n        bet.placeBlockNumber=block.number;\r\n        bet.gambler=payable(msg.sender);\r\n        bet.isSettled=false;\r\n        bet.outcome=0;\r\n        bet.winAmount=possibleWinAmount;\r\n        bet.randomNumber=0;\r\n        bet.commit=commit;\r\n        bet.isLarger=isLarger;\r\n\r\n        // Record bet in event logs\r\n        emitBetPlacedEvent(bet.gambler, amount, uint8(modulo), uint8(rollEdge), uint40(mask), commit, isLarger);\r\n    }\r\n\r\n    // Get the expected win amount after house edge is subtracted.\r\n    function getDiceWinAmount(uint amount, uint modulo, uint rollEdge, bool isLarger) private view returns (uint winAmount) {\r\n        require (0 < rollEdge && rollEdge <= modulo, \"Win probability out of range.\");\r\n        uint houseEdge = amount * (getModuloHouseEdgePercent(uint32(modulo)) + getWealthTax(amount)) / 100;\r\n        uint realRollEdge = rollEdge;\r\n        if (modulo == MAX_MODULO && isLarger) {\r\n            realRollEdge = MAX_MODULO - rollEdge - 1;\r\n        }\r\n        winAmount = (amount - houseEdge) * modulo / realRollEdge;\r\n\r\n        // round down to multiple 1000Gweis\r\n        winAmount = (winAmount / 1e12) * 1e12;\r\n\r\n        uint maxWinAmount = amount + maxProfit;\r\n\r\n        if(winAmount > maxWinAmount) {\r\n            winAmount = maxWinAmount;\r\n        }\r\n    }\r\n\r\n    // Get wealth tax \r\n    function getWealthTax(uint amount) private view returns (uint wealthTax) {\r\n        wealthTax = amount / wealthTaxIncrementThreshold * wealthTaxIncrementPercent;\r\n    }\r\n    \r\n    // This is the method used to settle 99% of bets. To process a bet with a specific\r\n    // \"commit\", settleBet should supply a \"reveal\" number that would Keccak256-hash to\r\n    // \"commit\". \"blockHash\" is the block hash of placeBet block as seen by croupier; it\r\n    // is additionally asserted to prevent changing the bet outcomes on Ethereum reorgs.\r\n    function settleBet(uint reveal, bytes32 blockHash) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        require (bet.gambler != address(0), \"Bet should be in a 'bet' state.\");\r\n\r\n        // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\r\n        require (block.number > placeBlockNumber, \"settleBet before placeBet\");\r\n\r\n        // Settle bet using reveal and blockHash as entropy sources.\r\n        settleBetCommon(bet, reveal, blockHash);\r\n    }\r\n\r\n    // Common settlement code for settleBet & settleBetUncleMerkleProof.\r\n    function settleBetCommon(Bet storage bet, uint reveal, bytes32 entropyBlockHash) private {\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint amount = bet.amount;\r\n        \r\n        // Validation check\r\n        require (amount > 0, \"Bet does not exist.\"); // Check that bet exists\r\n        require(bet.isSettled == false, \"Bet is settled already\"); // Check that bet is not settled yet\r\n\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint modulo = bet.modulo;\r\n        uint rollEdge = bet.rollEdge;\r\n        address payable gambler = bet.gambler;\r\n        bool isLarger = bet.isLarger;\r\n        \r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\r\n\r\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\r\n        uint outcome = uint(entropy) % modulo;\r\n\r\n        // Win amount if gambler wins this bet\r\n        uint possibleWinAmount = bet.winAmount;\r\n\r\n        // Actual win amount by gambler\r\n        uint winAmount = 0;\r\n\r\n        // Determine dice outcome.\r\n        if (modulo <= MAX_MASK_MODULO) {\r\n            // For small modulo games, check the outcome against a bit mask.\r\n            if ((2 ** outcome) & bet.mask != 0) {\r\n                winAmount = possibleWinAmount;\r\n            }\r\n        } else {\r\n            // For larger modulos, check inclusion into half-open interval.\r\n            if (isLarger){\r\n                if (outcome > rollEdge) {\r\n                    winAmount = possibleWinAmount;\r\n                }\r\n            }\r\n            else{\r\n                if (outcome < rollEdge) {\r\n                    winAmount = possibleWinAmount;\r\n                }\r\n            }\r\n            \r\n        }\r\n\r\n        // Unlock possibleWinAmount from lockedInBets, regardless of the outcome.\r\n        lockedInBets -= possibleWinAmount;\r\n\r\n        // Update bet records\r\n        bet.isSettled = true;\r\n        bet.winAmount = winAmount;\r\n        bet.randomNumber = uint(entropy);\r\n        bet.outcome = outcome;\r\n\r\n        // Send win amount to gambler.\r\n        if (bet.winAmount > 0) {\r\n            gambler.transfer(bet.winAmount);\r\n        }\r\n\r\n        emitSettledEvent(bet);\r\n    }\r\n\r\n    function emitSettledEvent(Bet storage bet) private\r\n    {\r\n        uint amount = bet.amount;\r\n        uint outcome = bet.outcome;\r\n        uint winAmount = bet.winAmount;\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint modulo = bet.modulo;\r\n        uint rollEdge = bet.rollEdge;\r\n        address payable gambler = bet.gambler;\r\n        // Record bet settlement in event log.\r\n        emit BetSettled(gambler, amount, uint8(modulo), uint8(rollEdge), bet.mask, bet.commit, outcome, winAmount);\r\n    }\r\n\r\n    // Return the bet in extremely unlikely scenario it was not settled by Chainlink VRF. \r\n    // In case you ever find yourself in a situation like this, just contact hashbet support.\r\n    // However, nothing precludes you from calling this method yourself.\r\n    function refundBet(uint commit) external nonReentrant payable {\r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.amount;\r\n\r\n        // Validation check\r\n        require (amount > 0, \"Bet does not exist.\"); // Check that bet exists\r\n        require (bet.isSettled == false, \"Bet is settled already.\"); // Check that bet is still open\r\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Wait after placing bet before requesting refund.\");\r\n\r\n        uint possibleWinAmount = bet.winAmount;\r\n\r\n        // Unlock possibleWinAmount from lockedInBets, regardless of the outcome.\r\n        lockedInBets -= possibleWinAmount;\r\n\r\n        // Update bet records\r\n        bet.isSettled = true;\r\n        bet.winAmount = amount;\r\n\r\n        // Send the refund.\r\n        bet.gambler.transfer(amount);\r\n\r\n        // Record refund in event logs\r\n        emit BetRefunded(bet.gambler, amount);\r\n    }\r\n\r\n    // Check arguments\r\n    function validateArguments(uint amount, uint betMask, uint modulo, uint commitLastBlock, uint commit, bool isLarger, bytes32 r, bytes32 s) view private {\r\n        // Validate input data.\r\n        require (modulo == 2 || modulo == 6  || modulo == 36 || modulo == 37  || modulo == 100, \"Modulo should be valid value.\");\r\n        require (amount >= minBetAmount && amount <= maxBetAmount, \"Bet amount should be within range.\");\r\n        require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\r\n        \r\n        // Check that commit is valid - it has not expired and its signature is valid.\r\n        require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(betMask, modulo, commitLastBlock, commit, isLarger));\r\n        require (secretSigner == ecrecover(signatureHash, 27, r, s), \"ECDSA signature is not valid.\");\r\n\r\n        if (modulo > MAX_MASK_MODULO) {\r\n            if (isLarger){\r\n                require (betMask >= minOverValue && betMask <= modulo, \"High modulo range, betMask must larger than minimum larger comparison value.\");\r\n            }\r\n            else{\r\n                require (betMask > 0 && betMask <= maxUnderValue, \"High modulo range, betMask must smaller than maximum smaller comparison value.\");\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getModuloHouseEdgePercent(uint32 modulo) internal view returns (uint32 houseEdgePercent)  {\r\n        houseEdgePercent = houseEdgePercents[modulo];\r\n        if(houseEdgePercent == 0){\r\n            houseEdgePercent = uint32(defaultHouseEdgePercent);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"modulo\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rollEdge\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"mask\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLarger\",\"type\":\"bool\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BetRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"modulo\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rollEdge\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"mask\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winAmount\",\"type\":\"uint256\"}],\"name\":\"BetSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"modulo\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rollEdge\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"mask\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"placeBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"gambler\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLarger\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"croupier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cumulativeDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cumulativeWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultHouseEdgePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"houseEdgePercents\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUnderValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOverValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betMask\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"modulo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLarger\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"setCroupier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_houseEdgePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultHouseEdgePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBetAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxBetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBetAmount\",\"type\":\"uint256\"}],\"name\":\"setMinBetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_houseEdgePercent\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"modulo\",\"type\":\"uint32\"}],\"name\":\"setModuloHouseEdgePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wealthTaxIncrementPercent\",\"type\":\"uint256\"}],\"name\":\"setWealthTaxIncrementPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wealthTaxIncrementThreshold\",\"type\":\"uint256\"}],\"name\":\"setWealthTaxIncrementThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reveal\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wealthTaxIncrementPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wealthTaxIncrementThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HashBet", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cc20149ea36a4eb37b043d1bcc34606f45f36d3bfca6eb5a6eb77604645cac0a"}