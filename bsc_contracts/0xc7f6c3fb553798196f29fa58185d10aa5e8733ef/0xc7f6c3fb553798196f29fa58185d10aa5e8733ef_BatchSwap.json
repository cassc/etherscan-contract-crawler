{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/batch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// dffaadg\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IBEP20 {\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter02 {\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\r\\n     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);    \\r\\n    function WETH() external pure returns (address);\\r\\n}\\r\\n\\r\\ncontract BatchSwap {\\r\\n    address private pancakeRouterAddress = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\r\\n    address private owner = msg.sender;\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Only owner can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setPancakeRouterAddress(address _routerAddress) external onlyOwner {\\r\\n        pancakeRouterAddress = _routerAddress;\\r\\n    }\\r\\n\\r\\n    function TokenSwap(\\r\\n        address tokenAddress,\\r\\n        uint256[] calldata amounts,\\r\\n        address[] calldata recipientAddresses\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(amounts.length == recipientAddresses.length, \\\"Arrays length mismatch\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < amounts.length; i++) {\\r\\n            // \u8c03\u7528PancakeSwap\u5408\u7ea6\u8fdb\u884c\u4ea4\u6362\\r\\n            IPancakeRouter02 pancakeRouter = IPancakeRouter02(pancakeRouterAddress);\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = pancakeRouter.WETH();\\r\\n            path[1] = tokenAddress;\\r\\n\\r\\n            uint256 ethAmount = amounts[i];\\r\\n\\r\\n            // \u8bbe\u7f6e\u6700\u5c0f\u63a5\u6536\u4ee3\u5e01\u6570\u91cf\u4e3a\u671f\u671b\u6570\u91cf\u768490%\\r\\n            uint256 amountOutMin = getMinTokenAmount(ethAmount, path, pancakeRouter);\\r\\n\\r\\n            // \u8c03\u7528\u4ea4\u6362\u51fd\u6570\\r\\n            (bool success, ) = address(pancakeRouterAddress).call{value: ethAmount}(\\r\\n                abi.encodeWithSignature(\\\"swapExactETHForTokens(uint256,address[],address,uint256)\\\", amountOutMin, path, address(this), block.timestamp)\\r\\n            );\\r\\n\\r\\n            require(success, \\\"Swap failed\\\");\\r\\n\\r\\n            // \u5c06\u4ee3\u5e01\u53d1\u9001\u5230\u6307\u5b9a\u5730\u5740\\r\\n            uint256 boughtTokenAmount = getTokenBalance(tokenAddress);\\r\\n            \\r\\n            IBEP20(tokenAddress).transfer(recipientAddresses[i], boughtTokenAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function getMinTokenAmount(uint256 ethAmount, address[] memory path, IPancakeRouter02 router) private view returns (uint256) {\\r\\n        uint[] memory amountsOut = router.getAmountsOut(ethAmount, path);\\r\\n        return amountsOut[1] - (amountsOut[1] / 10); // \u8bbe\u7f6e\u6700\u5c0f\u63a5\u6536\u4ee3\u5e01\u6570\u91cf\u4e3a\u671f\u671b\u6570\u91cf\u768490%\\r\\n    }\\r\\n\\r\\n    function getTokenBalance(address tokenAddress) private view returns (uint256) {\\r\\n        (bool success, bytes memory data) = tokenAddress.staticcall(abi.encodeWithSignature(\\\"balanceOf(address)\\\", address(this)));\\r\\n        require(success, \\\"Balance check failed\\\");\\r\\n        return abi.decode(data, (uint256));\\r\\n    }\\r\\n\\r\\n    // Wbnb\u5151\u6362\u7cbe\u786e\u7684token\u6570\u91cf\\r\\n    function ExactTokenSwap(\\r\\n        address tokenAddress,\\r\\n        uint256[] calldata amounts,\\r\\n        address[] calldata recipientAddresses\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(amounts.length == recipientAddresses.length, \\\"Arrays length mismatch\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < amounts.length; i++) {\\r\\n            // \u8c03\u7528PancakeSwap\u5408\u7ea6\u8fdb\u884c\u4ea4\u6362\\r\\n            IPancakeRouter02 pancakeRouter = IPancakeRouter02(pancakeRouterAddress);\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = pancakeRouter.WETH();\\r\\n            path[1] = tokenAddress;\\r\\n\\r\\n            uint256 ethAmount = amounts[i];\\r\\n\\r\\n            // \u8bbe\u7f6e\u671f\u671b\u63a5\u6536\u4ee3\u5e01\u6570\u91cf\\r\\n            uint256 amountOut = getExpectedTokenAmount(ethAmount, path, pancakeRouter);\\r\\n\\r\\n            // \u8c03\u7528\u4ea4\u6362\u51fd\u6570\\r\\n            (bool success, ) = address(pancakeRouterAddress).call{value: ethAmount}(\\r\\n                abi.encodeWithSignature(\\\"swapETHForExactTokens(uint256,address[],address,uint256)\\\", amountOut, path, recipientAddresses[i], block.timestamp)\\r\\n            );\\r\\n\\r\\n            require(success, \\\"Swap failed\\\");\\r\\n\\r\\n            // \u5c06\u4ee3\u5e01\u53d1\u9001\u5230\u6307\u5b9a\u5730\u5740\\r\\n            uint256 boughtTokenAmount = getTokenBalance(tokenAddress);\\r\\n            \\r\\n            IBEP20(tokenAddress).transfer(recipientAddresses[i], boughtTokenAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getExpectedTokenAmount(uint256 ethAmount, address[] memory path, IPancakeRouter02 router) private view returns (uint256) {\\r\\n        uint[] memory amountsOut = router.getAmountsOut(ethAmount, path);\\r\\n        return amountsOut[1]; // \u8fd4\u56de\u671f\u671b\u63a5\u6536\u4ee3\u5e01\u6570\u91cf\\r\\n    }\\r\\n\\r\\n    // \u63d0\u53d6\u5408\u7ea6\u4e0a\u7684BNB\u4f59\u989d\\r\\n    function withdrawBNB() external onlyOwner {\\r\\n        payable(owner).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function getPathForETHtoToken(address token) private view returns (address[] memory) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = IPancakeRouter02(pancakeRouterAddress).WETH();\\r\\n        path[1] = token;\\r\\n        return path;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipientAddresses\",\"type\":\"address[]\"}],\"name\":\"ExactTokenSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipientAddresses\",\"type\":\"address[]\"}],\"name\":\"TokenSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"}],\"name\":\"setPancakeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BatchSwap", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}