{"SourceCode": "pragma solidity 0.5.8;\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath\r\n{\r\n  /**\r\n   * List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   * @param _factor1 Factor number.\r\n   * @param _factor2 Factor number.\r\n   * @return product The product of the two factors.\r\n   */\r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\r\n   * @param _dividend Dividend number.\r\n   * @param _divisor Divisor number.\r\n   * @return quotient The quotient.\r\n   */\r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    // Solidity automatically asserts when dividing by 0, using all gas.\r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _minuend Minuend number.\r\n   * @param _subtrahend Subtrahend number.\r\n   * @return difference Difference.\r\n   */\r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, reverts on overflow.\r\n   * @param _addend1 Number.\r\n   * @param _addend2 Number.\r\n   * @return sum Sum.\r\n   */\r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\r\n    * dividing by zero.\r\n    * @param _dividend Number.\r\n    * @param _divisor Number.\r\n    * @return remainder Remainder.\r\n    */\r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder)\r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\nlibrary AddressUtils\r\n{\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   * @return addressCheck True if _addr is a contract, false if not.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\ninterface ERC721\r\n{\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n    \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n    \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n    \r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\ninterface ERC721TokenReceiver{\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n}\r\ncontract Ownable\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n  string public constant NOT_CURRENT_MANAGER = \"018003\";\r\n\r\n  address public owner;\r\n  mapping(address=>bool) public Manager;\r\n\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  event AddManager(\r\n    address indexed newManager\r\n  );\r\n\r\n  event DelManager(\r\n    address indexed delManager\r\n  );\r\n\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner()\r\n  {\r\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\r\n    _;\r\n  }\r\n  \r\n  modifier onlyManager()    \r\n  {\r\n    require(Manager[msg.sender], NOT_CURRENT_MANAGER);\r\n    _;\r\n  }\r\n\r\n  function addManager(address _maddr) external onlyOwner{\r\n      Manager[_maddr] = true;\r\n      emit AddManager(_maddr);\r\n  }\r\n  \r\n  function delManager(address _maddr) external onlyOwner{\r\n      Manager[_maddr] = false;\r\n      emit DelManager(_maddr);\r\n  }\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract NFToken is\r\n  ERC721\r\n{\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n  using SafeERC20 for IERC20;\r\n\r\n//   address public consumeToken = 0x55d398326f99059fF775485246999027B3197955;     //todo\r\n//   address public destoryAddr = 0x3DA3fF1AD97587343f877444C12c0A4D2Da2AcC2;  //0x000000000000000000000000000000000000dEaD;      //todo\r\n//   uint public consumeNum = 1*1e16;                                              //todo\r\n \r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n\r\n\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  \r\n  mapping (uint256 => address) public idToOwner;\r\n\r\n  uint256 internal tokenID;\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n   \r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n\r\n  \r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  \r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n \r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  \r\n\r\n \r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], NOT_OWNER_OR_OPERATOR);\r\n    _;\r\n  }\r\n\r\n\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_APPROWED_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    //supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n  \r\n  function viewTokenID() view external returns(uint256 ){\r\n      return tokenID;\r\n  }\r\n  \r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    //override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n  \r\n\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    //override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n \r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    //override\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(msg.sender,_to, _tokenId);\r\n  }\r\n  \r\n  function transferList(address _to,uint256[] calldata _tokenIdList) external{\r\n        uint256 len = _tokenIdList.length;\r\n        address tokenOwner;// = idToOwner[_tokenId];\r\n        uint256 _tokenId;\r\n        \r\n        for(uint256 i=0;i<len;i++){\r\n            _tokenId = _tokenIdList[i];\r\n            tokenOwner = idToOwner[_tokenId];\r\n            require(tokenOwner != address(0), NOT_VALID_NFT);\r\n            require(\r\n                tokenOwner == msg.sender\r\n                || idToApproval[_tokenId] == msg.sender\r\n                || ownerToOperators[tokenOwner][msg.sender],\r\n                NOT_OWNER_APPROWED_OR_OPERATOR\r\n            );\r\n            _transfer(msg.sender,_to, _tokenId);\r\n        }\r\n  }\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    //override\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n \r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    //override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n \r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    //override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n\r\n \r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    //override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    //override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    //override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  function _transfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    //virtual\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n    //require(_tokenId == tokenID+1,NFT_ALREADY_EXISTS);\r\n    tokenID++;\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n\r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    //virtual\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n    _removeNFToken(tokenOwner, _tokenId);\r\n    emit Transfer(tokenOwner, address(0), _tokenId);\r\n  }\r\n\r\n \r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    //virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  \r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    //virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\r\n  }\r\n\r\n\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    //virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    private\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(msg.sender,_to, _tokenId);\r\n\r\n    if (_to.isContract())\r\n    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract Mdate is NFToken {\r\n\r\n    string internal nftName;\r\n    string internal nftSymbol;\r\n\r\n    string constant INVALID_INDEX = \"005007\";\r\n\r\n    uint256[] public tokens;\r\n    mapping(uint256 => uint256) public idToIndex;\r\n    mapping(address => uint256[]) public ownerToIds;\r\n    mapping(uint256 => uint256) public idToOwnerIndex;\r\n    mapping(uint256 => starall) public all;\r\n    \r\n    struct starall{\r\n        string  _uri;\r\n        uint _power;\r\n    }\r\n    function _setTokenstarall(\r\n        uint256 _tokenId,\r\n        string memory _uri,\r\n        uint power\r\n    ) \r\n    internal  validNFToken(_tokenId)  {\r\n        all[_tokenId] =  starall(_uri,power);\r\n    }\r\n    function totalSupply() external view returns (uint256) {\r\n        return tokens.length;\r\n    }\r\n    \r\n    function _mint(address _to,uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n        tokens.push(_tokenId);\r\n        idToIndex[_tokenId] = tokens.length - 1;\r\n      \r\n    }\r\n    function _burn(uint256 _tokenId) internal {\r\n        super._burn(_tokenId);\r\n\r\n        uint256 tokenIndex = idToIndex[_tokenId];\r\n        uint256 lastTokenIndex = tokens.length - 1;\r\n        uint256 lastToken = tokens[lastTokenIndex];\r\n        tokens[tokenIndex] = lastToken;\r\n        tokens.pop();\r\n        idToIndex[lastToken] = tokenIndex;\r\n        idToIndex[_tokenId] = 0;\r\n    }\r\n    function _removeNFToken(address _from,uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n        super._removeNFToken(_from, _tokenId);\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex){\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n        ownerToIds[_from].pop();\r\n    }\r\n    function _addNFToken(address _to,uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n        super._addNFToken(_to, _tokenId);\r\n\r\n        ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n    }\r\n    function  getAllPower(uint _tid) public view returns (uint256){\r\n        return all[_tid]._power;\r\n    }\r\n}\r\n\r\ncontract zNFTCONTRACT is Mdate,Ownable{\r\n   \r\n    constructor(string memory _name,string memory _symbol) public {\r\n        nftName = _name;\r\n        nftSymbol = _symbol;\r\n    }\r\n    function mint(\r\n        address _to,\r\n        string calldata _uri,\r\n        uint power\r\n    )   \r\n        external\r\n        onlyManager\r\n    {\r\n        uint _tokenId = tokenID;\r\n        super._mint(_to, _tokenId);\r\n        super._setTokenstarall(_tokenId,_uri,power);\r\n    }\r\n    \r\n    function name() public view returns (string memory) {\r\n        return nftName;\r\n    }\r\n    function symbol() public view returns (string memory) {\r\n        return nftName;\r\n    }\r\n    function burn(uint256 _tokenId) external onlyManager {\r\n        super._burn(_tokenId);\r\n    }\r\n\r\n    function setall(\r\n      uint256 _tokenId,\r\n        string calldata _uri,\r\n        uint power) external onlyManager {\r\n       super._setTokenstarall(_tokenId,_uri,power);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_uri\",\"type\":\"string\"},{\"name\":\"power\",\"type\":\"uint256\"}],\"name\":\"setall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maddr\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwnerIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Manager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewTokenID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenIdList\",\"type\":\"uint256[]\"}],\"name\":\"transferList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"all\",\"outputs\":[{\"name\":\"_uri\",\"type\":\"string\"},{\"name\":\"_power\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maddr\",\"type\":\"address\"}],\"name\":\"delManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_uri\",\"type\":\"string\"},{\"name\":\"power\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"getAllPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NOT_CURRENT_MANAGER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerToIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"AddManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delManager\",\"type\":\"address\"}],\"name\":\"DelManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "ContractName": "zNFTCONTRACT", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000c626c756563686970636f696e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034243430000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a4ada742acce00072e5741d640c38ffaa46b2ff26ededa346f54b44b4f55bfc3"}