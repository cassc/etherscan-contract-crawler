{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LockingSchedulerAutomation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport {ISuperfluid, ISuperToken, SuperAppDefinitions} from \\\"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport {SuperAppBase} from \\\"@streamable-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol\\\";\\nimport {IConstantFlowAgreementV1} from \\\"@streamable-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\nimport {CFAv1Library} from \\\"@streamable-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\\\";\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport {AutomateTaskCreator} from \\\"./gelato/AutomateTaskCreator.sol\\\";\\nimport {Module, ModuleData} from \\\"./gelato/Types.sol\\\";\\nimport {ILockingSchedulerAutomation} from \\\"./interfaces/ILockingSchedulerAutomation.sol\\\";\\nimport {LockingScheduler} from \\\"./LockingScheduler.sol\\\";\\n\\n/**\\n * @title Locking scheduler automation contract\\n * @author Streampay\\n */\\ncontract LockingSchedulerAutomation is\\n    ILockingSchedulerAutomation,\\n    LockingScheduler,\\n    AutomateTaskCreator, // Gelato task creator\\n    SuperAppBase, // Superfluid super app\\n    Initializable // Initializable contract\\n{\\n    /* ========== LIBRARIES ========== */\\n\\n    using CFAv1Library for CFAv1Library.InitData;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(bytes32 => TaskIds) internal taskIds; // id = keccak(supertoken, receiver)\\n    uint256 internal singleTaskFee;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyOwnerFromCtx(bytes memory ctx) {\\n        if (_getSender(ctx) != contractOwner) revert NotContractOwner();\\n        _;\\n    }\\n\\n    modifier onlyWhitelisted() {\\n        /**\\n         * @dev gelatoExecutor is dedicated sender from gelato service, which will call the execute functions\\n         * @dev admin is the streampay admin address\\n         * @dev Only these two addresses can call the execute functions (start/transition/end)\\n         */\\n        if (msg.sender != gelatoExecutor && msg.sender != admin)\\n            revert NotWhitelistedExecutor();\\n        _;\\n    }\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    /// @dev ILockingSchedulerAutomation.initialize implementation\\n    function initialize(\\n        ISuperfluid _host,\\n        address payable _automate,\\n        uint256 _fee,\\n        address _admin,\\n        address _owner\\n    ) external initializer {\\n        // Validate inputs\\n        if (\\n            _automate == address(0) ||\\n            _admin == address(0) ||\\n            _owner == address(0) ||\\n            address(_host) == address(0)\\n        ) revert ZeroAddress();\\n        if (_fee == 0) revert ZeroFee();\\n\\n        // Initialize Locker Scheduler and Gelato Automate Task Creator\\n        _initializeLockingScheduler(_host, _admin, _owner);\\n        _initializeAutomateTaskCreator(_automate);\\n\\n        // Set task fee\\n        singleTaskFee = _fee;\\n    }\\n\\n    /* ========== EXTERNAL FUNCTIONS ========== */\\n\\n    /// @notice This function will receive native asset for gelato gas payments\\n    receive() external payable {\\n        emit FeeFundsReceived(msg.sender, msg.value);\\n    }\\n\\n    /* ========== EXTERNAL FUNCTIONS FOR ADMIN ========== */\\n\\n    /// @dev ILockingSchedulerAutomation.withdrawFee implementation\\n    function emergencyFeeWithdraw() external onlyOwner {\\n        // Revert if there are any active or scheduled schedules\\n        if (existingSchedulesCount != 0) revert SchedulesExist();\\n\\n        // Get fee balance and revert if there is nothing to withdraw\\n        uint256 amount = address(this).balance;\\n        if (amount == 0) revert NothingToWithdraw();\\n\\n        // Send native asset to owner\\n        (bool sent, ) = msg.sender.call{value: amount}(\\\"\\\");\\n        if (!sent) revert TransferFailed();\\n\\n        emit FeeFundsWithdrawn(msg.sender, amount);\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.setGelatoTaskFee implementation\\n    function setGelatoTaskFee(uint256 fee) external onlyAdmin {\\n        if (fee == 0) revert ZeroFee();\\n        singleTaskFee = fee;\\n\\n        emit GelatoTaskFeeSet(fee);\\n    }\\n\\n    /* ========== EXTERNAL FUNCTIONS FOR OWNER ========== */\\n\\n    /// @dev ILockingSchedulerAutomation.createLockingSchedule implementation\\n    function createLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        bytes memory ctx\\n    ) external payable onlyOwnerFromCtx(ctx) returns (bytes memory newCtx) {\\n        newCtx = ctx;\\n\\n        // Validate that permission was granted and flow rate allowance is enough for the stream\\n        _validatePermissionAndAllowance(superToken, flowRate);\\n\\n        // Lock funds and create locking schedule\\n        _lockAndCreateSchedule(\\n            superToken,\\n            receiver,\\n            startLockerFlowDate,\\n            endSenderFlowDate,\\n            flowRate,\\n            minAmount\\n        );\\n\\n        // Create gelato tasks\\n        _createFlowTasks(superToken, receiver);\\n\\n        // If flow from sender to receiver exists, delete it\\n        if (isFlowOngoing(superToken, contractOwner, receiver)) {\\n            cfaV1.deleteFlowByOperator(contractOwner, receiver, superToken);\\n        }\\n\\n        // If startLockerFlowDate is not scheduled, flow should start instantly\\n        if (startLockerFlowDate == 0) {\\n            // Flow should never exists from locker to receiver when creating a schedule\\n            // After checking we start flow from locker to receiver\\n            if (!isFlowOngoing(superToken, address(this), receiver)) {\\n                _startLockerFlow(superToken, receiver);\\n            }\\n        }\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.deleteLockingSchedule implementation\\n    function deleteLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        bytes memory ctx\\n    ) external onlyOwnerFromCtx(ctx) returns (bytes memory newCtx) {\\n        newCtx = ctx;\\n\\n        // Get locking schedule\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Delete locking schedule data\\n        _deleteSchedule(superToken, receiver);\\n\\n        // Cancel all active gelato tasks\\n        _cancelFlowTasks(superToken, receiver);\\n\\n        // If flow is active from sender, delete it.\\n        if (\\n            schedule.status == ScheduleStatus.ACTIVE_SENDER_FLOW &&\\n            isFlowOngoing(superToken, contractOwner, receiver)\\n        ) {\\n            // No compensation is needed because stream is from sender and not locker\\n            cfaV1.deleteFlowByOperator(contractOwner, receiver, superToken);\\n        }\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.modifyLockingSchedule implementation\\n    function modifyLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        bytes memory ctx\\n    ) external payable onlyOwnerFromCtx(ctx) returns (bytes memory newCtx) {\\n        newCtx = ctx;\\n\\n        // Validate that permission was granted and flow rate allowance is enough for the stream\\n        _validatePermissionAndAllowance(superToken, flowRate);\\n\\n        // Get locking schedule\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Update locking schedule data and lock funds\\n        _lockAndUpdateSchedule(\\n            superToken,\\n            receiver,\\n            startLockerFlowDate,\\n            endSenderFlowDate,\\n            flowRate,\\n            minAmount\\n        );\\n\\n        // Update gelato tasks\\n        _updateFlowTasks(superToken, receiver);\\n\\n        // If startLockerFlowDate is not scheduled, flow should start instantly\\n        if (\\n            startLockerFlowDate == 0 &&\\n            schedule.status == ScheduleStatus.BEFORE_LOCKER_START\\n        ) {\\n            // If flow from sender to receiver exists, delete it\\n            if (isFlowOngoing(superToken, contractOwner, receiver)) {\\n                cfaV1.deleteFlowByOperator(contractOwner, receiver, superToken);\\n            }\\n\\n            // Flow should never exists from locker to receiver when creating a schedule\\n            // After checking we start flow from locker to receiver\\n            if (!isFlowOngoing(superToken, address(this), receiver)) {\\n                _startLockerFlow(superToken, receiver);\\n            }\\n        }\\n    }\\n\\n    /* ========== EXTERNAL FUNCTIONS FOR GELATO ========== */\\n\\n    /// @dev ILockingSchedulerAutomation.executeStart implementation\\n    function executeStart(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external onlyWhitelisted {\\n        if (!canExecuteLockerFlowStart(superToken, receiver))\\n            revert CantExecuteStart();\\n\\n        // Delete the task id, to know that the task has been executed\\n        // We don't need to call cancel function in Gelato Automate, because this task is not recurring\\n        delete taskIds[getConfigHash(superToken, receiver)].startFlowId;\\n\\n        // Handle fee paymet logic\\n        _payFee();\\n\\n        // Call Locking Scheduler to create the flow\\n        // We don't care about permission and flow rate allowance as we create stream from locker\\n        _executeLockerFlowStart(superToken, receiver);\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.executeTransition implementation\\n    function executeTransition(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external onlyWhitelisted {\\n        if (!canExecuteFlowTransition(superToken, receiver))\\n            revert CantExecuteTransition();\\n\\n        // Delete the task id, to know that the task has been executed\\n        // We don't need to call cancel function in Gelato Automate, because this task is not recurring\\n        delete taskIds[getConfigHash(superToken, receiver)].transitionFlowId;\\n\\n        // Handle fee paymet logic\\n        _payFee();\\n\\n        /**\\n         * @dev If permission is invalid or flow rate allownace is not enough\\n         * @dev Locker will not be able to create stream from sender to receiver\\n         * @dev We can only end the locker stream, cancel end task and delete the schedule\\n         * @dev Same logic applies if contract owner has no balance\\n         */\\n        if (\\n            !isPermissionValid(superToken) ||\\n            !isFlowRateAllowanceInScheduleEnough(superToken, receiver) ||\\n            superToken.balanceOf(contractOwner) == 0\\n        ) {\\n            // We still need to end locker stream\\n            _endLockerFlow(superToken, receiver);\\n\\n            // Cancel the last task as transition task is already executed\\n            _cancelSenderFlowEndTask(superToken, receiver);\\n\\n            // Delete the schedule completely\\n            _deleteSchedule(superToken, receiver);\\n\\n            emit AllTasksCancelled(superToken, contractOwner, receiver);\\n        } else {\\n            // Call Locking Scheduler to successfully execute transition\\n            _executeFlowTransition(superToken, receiver);\\n        }\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.executeEnd implementation\\n    function executeEnd(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external onlyWhitelisted {\\n        if (!canExecuteSenderFlowEnd(superToken, receiver))\\n            revert CantExecuteEnd();\\n\\n        // Delete the task id, to know that the task has been executed\\n        // We don't need to call cancel function in Gelato Automate, because this task is not recurring\\n        delete taskIds[getConfigHash(superToken, receiver)].endFlowId;\\n\\n        // Handle fee paymet logic\\n        _payFee();\\n\\n        /**\\n         * @dev If permission was removed and is currently invalid\\n         * @dev Locker will not be able to end the sender stream as operator\\n         * @dev We can only delete the schedule\\n         */\\n        if (!isPermissionValid(superToken)) {\\n            // Call Flow Scheduler to delete the flow\\n            _deleteSchedule(superToken, receiver);\\n\\n            emit AllTasksCancelled(superToken, contractOwner, receiver);\\n        } else {\\n            _executeSenderFlowEnd(superToken, receiver);\\n        }\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.checker implementation\\n    function checker(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (bool canExec, bytes memory execPayload) {\\n        /**\\n         * @notice Automation should execute if:\\n         * @notice 1. locking schedule status is correct\\n         * @notice 2. current time is allowed to execute the task\\n         * @dev We don't check permission and flow rate allowance\\n         * @dev These checks are done in the execute functions\\n         * @dev else user could manipulate the flow rate allowance and permission\\n         * @dev making the checker function stuck without executing the task\\n         */\\n        if (canExecuteSenderFlowEnd(superToken, receiver)) {\\n            // return canExec as true and executeSenderFlowEnd payload\\n            return (\\n                true,\\n                abi.encodeCall(this.executeEnd, (superToken, receiver))\\n            );\\n        } else if (canExecuteFlowTransition(superToken, receiver)) {\\n            // return canExec as true and executeSenderFlowEnd payload\\n            return (\\n                true,\\n                abi.encodeCall(this.executeTransition, (superToken, receiver))\\n            );\\n        } else if (canExecuteLockerFlowStart(superToken, receiver)) {\\n            // return canExec as true and executeSenderFlowEnd payload\\n            return (\\n                true,\\n                abi.encodeCall(this.executeStart, (superToken, receiver))\\n            );\\n        } else {\\n            // return canExec as false and non-executable payload\\n            return (false, \\\"\\\");\\n        }\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.getSingleTaskFee implementation\\n    function getSingleTaskFee() external view returns (uint256 fee) {\\n        return singleTaskFee;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    /// @dev ILockingSchedulerAutomation.isPermissionValid implementation\\n    function isPermissionValid(\\n        ISuperToken superToken\\n    ) public view returns (bool isValid) {\\n        // Get permissions from CFA\\n        (, uint8 permissions, ) = cfaV1.cfa.getFlowOperatorData(\\n            superToken,\\n            contractOwner,\\n            address(this)\\n        );\\n\\n        // Permission 7 -> AUTHORIZE FULL CONTROL (create/delete/update flows)\\n        return permissions == 7;\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.isFlowRateAllowanceEnough implementation\\n    function isFlowRateAllowanceEnough(\\n        ISuperToken superToken,\\n        int96 flowRate\\n    ) public view returns (bool isEnough) {\\n        // Get allowance from CFA\\n        (, , int96 flowRateAllowance) = cfaV1.cfa.getFlowOperatorData(\\n            superToken,\\n            contractOwner,\\n            address(this)\\n        );\\n\\n        return flowRate <= flowRateAllowance;\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.isFlowRateAllowanceInScheduleEnough implementation\\n    function isFlowRateAllowanceInScheduleEnough(\\n        ISuperToken superToken,\\n        address receiver\\n    ) public view returns (bool isEnough) {\\n        // Get Locking schedule\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Use schedule flow rate to find if allowance is enough\\n        return isFlowRateAllowanceEnough(superToken, schedule.flowRate);\\n    }\\n\\n    /// @dev ILockingSchedulerAutomation.getTaskIds implementation\\n    function getTaskIds(\\n        ISuperToken superToken,\\n        address receiver\\n    ) public view returns (TaskIds memory ids) {\\n        return taskIds[getConfigHash(superToken, receiver)];\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Create gelato tasks for a locking schedule\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Receiver of the stream\\n     */\\n    function _createFlowTasks(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        // Get gelato active tasks for sender flow\\n        TaskIds memory ids = getTaskIds(superToken, receiver);\\n\\n        // If start or end flow task ids exist, revert\\n        if (\\n            ids.startFlowId != bytes32(0) ||\\n            ids.transitionFlowId != bytes32(0) ||\\n            ids.endFlowId != bytes32(0)\\n        ) revert TasksExist();\\n\\n        // Get locking schedule\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // If flow schedule doesn't exist, revert\\n        if (\\n            schedule.startLockerFlowDate == 0 &&\\n            schedule.flowTransitionDate == 0 &&\\n            schedule.endSenderFlowDate == 0\\n        ) revert ScheduleInvalid();\\n\\n        // Create gelato tasks\\n        bool startTaskCreated = _createLockerFlowStartTask(\\n            superToken,\\n            receiver\\n        );\\n        bool transitionTaskCreated = _createFlowTransitionTask(\\n            superToken,\\n            receiver\\n        );\\n        bool endTaskCreated = _createSenderFlowEndTask(superToken, receiver);\\n\\n        // Handle fee deposit validation\\n        uint256 feeAmount = _calculateFeeAmount(\\n            startTaskCreated,\\n            transitionTaskCreated,\\n            endTaskCreated\\n        );\\n        _feeDeposited(feeAmount);\\n    }\\n\\n    /**\\n     * @dev Cancel gelato tasks for a locking schedule\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function _cancelFlowTasks(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        // Cancel all tasks\\n        _cancelLockerFlowStartTask(superToken, receiver);\\n        _cancelFlowTransitionTask(superToken, receiver);\\n        _cancelSenderFlowEndTask(superToken, receiver);\\n    }\\n\\n    /**\\n     * @dev Update gelato tasks for a locking schedule\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function _updateFlowTasks(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        // Get gelato active tasks for sender flow\\n        TaskIds memory ids = getTaskIds(superToken, receiver);\\n\\n        // If tasks don't exist, revert\\n        if (\\n            ids.startFlowId == bytes32(0) &&\\n            ids.transitionFlowId == bytes32(0) &&\\n            ids.endFlowId == bytes32(0)\\n        ) revert TasksDontExist();\\n\\n        // Get locking schedule\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        /**\\n         * @notice If start flow task id doesn't exist AND start date is set (not 0)\\n         * @notice Should not be able to create start task if it has started\\n         * @notice When start flow id = 0x0, we know that the stream start\\n         * @notice was never scheduled or flow has already started\\n         */\\n        if (\\n            ids.startFlowId == bytes32(0) && schedule.startLockerFlowDate != 0\\n        ) {\\n            revert CantUpdateStartDate();\\n        }\\n        /**\\n         * @notice If start flow task id exists AND start date is not set (0)\\n         * @notice Then cancel start flow task\\n         * @notice Batch call should also create the flow from receiver to sender\\n         */\\n        else if (\\n            ids.startFlowId != bytes32(0) && schedule.startLockerFlowDate == 0\\n        ) {\\n            _cancelLockerFlowStartTask(superToken, receiver);\\n        }\\n\\n        /**\\n         * @notice If end flow task id doesn't exist AND end date is set (not 0)\\n         * @notice Then create end flow task and pay fee\\n         */\\n        if (ids.endFlowId == bytes32(0) && schedule.endSenderFlowDate != 0) {\\n            bool created = _createSenderFlowEndTask(superToken, receiver);\\n            if (created) _feeDeposited(singleTaskFee);\\n        }\\n        /**\\n         * @notice If end flow task id exists AND end date is not set (0)\\n         * @notice Then cancel end flow task\\n         */\\n        else if (\\n            ids.endFlowId != bytes32(0) && schedule.endSenderFlowDate == 0\\n        ) {\\n            _cancelSenderFlowEndTask(superToken, receiver);\\n        }\\n    }\\n\\n    /**\\n     * @dev Create gelato task for locker flow start\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @return taskCreated Whether task was created\\n     */\\n    function _createLockerFlowStartTask(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal returns (bool taskCreated) {\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        bytes32 startTaskId = taskIds[configHash].startFlowId;\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // If start task id doesn't exist and start date is set, create the task\\n        if (startTaskId == bytes32(0) && schedule.startLockerFlowDate != 0) {\\n            taskCreated = true;\\n\\n            ModuleData memory moduleData = _getModuleData(superToken, receiver);\\n\\n            // Create the task in the automate\\n            startTaskId = _createTask(\\n                address(this),\\n                abi.encode(this.executeStart.selector),\\n                moduleData,\\n                ETH\\n            );\\n\\n            // Assign new start task id\\n            taskIds[configHash].startFlowId = startTaskId;\\n\\n            emit TaskCreated(\\n                startTaskId,\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                FlowAction.START\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Create gelato task for flow transition\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @return taskCreated Whether task was created\\n     */\\n    function _createFlowTransitionTask(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal returns (bool taskCreated) {\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        bytes32 transitionTaskId = taskIds[configHash].transitionFlowId;\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // If transition task id doesn't exist and transition date is set, create the task\\n        if (\\n            transitionTaskId == bytes32(0) && schedule.flowTransitionDate != 0\\n        ) {\\n            taskCreated = true;\\n\\n            ModuleData memory moduleData = _getModuleData(superToken, receiver);\\n\\n            // Create the task in the automate\\n            transitionTaskId = _createTask(\\n                address(this),\\n                abi.encode(this.executeTransition.selector),\\n                moduleData,\\n                ETH\\n            );\\n\\n            // Assign new transition task id\\n            taskIds[configHash].transitionFlowId = transitionTaskId;\\n\\n            emit TaskCreated(\\n                transitionTaskId,\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                FlowAction.TRANSITION\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Create gelato task for sender flow end\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @return taskCreated Whether task was created\\n     */\\n    function _createSenderFlowEndTask(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal returns (bool taskCreated) {\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        bytes32 endTaskId = taskIds[configHash].endFlowId;\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // If end task id doesn't exist and end date is set, create the task\\n        if (endTaskId == bytes32(0) && schedule.endSenderFlowDate != 0) {\\n            taskCreated = true;\\n\\n            ModuleData memory moduleData = _getModuleData(superToken, receiver);\\n\\n            // Create the task in the automate\\n            endTaskId = _createTask(\\n                address(this),\\n                abi.encode(this.executeEnd.selector),\\n                moduleData,\\n                ETH\\n            );\\n\\n            // Assign new end task id\\n            taskIds[configHash].endFlowId = endTaskId;\\n\\n            emit TaskCreated(\\n                endTaskId,\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                FlowAction.END\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Cancel gelato task for locker flow start\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function _cancelLockerFlowStartTask(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        bytes32 startTaskId = taskIds[configHash].startFlowId;\\n\\n        // If start task id exists, cancel task\\n        if (startTaskId != bytes32(0)) {\\n            // Set start task id to 0\\n            delete taskIds[configHash].startFlowId;\\n\\n            // Cancel the task in the gelato automate\\n            _cancelTask(startTaskId);\\n\\n            emit TaskCancelled(\\n                startTaskId,\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                FlowAction.START\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Cancel gelato task for flow transition\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function _cancelFlowTransitionTask(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        bytes32 transitionTaskId = taskIds[configHash].transitionFlowId;\\n\\n        // If start task id exists, cancel task\\n        if (transitionTaskId != bytes32(0)) {\\n            // Set transition task id to 0\\n            delete taskIds[configHash].transitionFlowId;\\n\\n            // Cancel the task in the gelato automate\\n            _cancelTask(transitionTaskId);\\n\\n            emit TaskCancelled(\\n                transitionTaskId,\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                FlowAction.TRANSITION\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Cancel gelato task for sender flow end\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function _cancelSenderFlowEndTask(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        bytes32 endTaskId = taskIds[configHash].endFlowId;\\n\\n        // If end task id exists, cancel task\\n        if (endTaskId != bytes32(0)) {\\n            // Set end task id to 0\\n            delete taskIds[configHash].endFlowId;\\n\\n            // Cancel the task in the gelato automate\\n            _cancelTask(endTaskId);\\n\\n            emit TaskCancelled(\\n                endTaskId,\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                FlowAction.END\\n            );\\n        }\\n    }\\n\\n    /// @dev Pay gelato fee when executing a task\\n    function _payFee() internal virtual {\\n        // Get fee details from gelato\\n        (uint256 fee, address feeToken) = _getFeeDetails();\\n\\n        // Valildate that fee is not greater than fee balance\\n        if (fee > address(this).balance) revert InsufficientBalance();\\n\\n        // Call gelato to transfer the fee\\n        _transfer(fee, feeToken);\\n    }\\n\\n    /**\\n     * @dev Validate that sender deposited the expected fee\\n     * @param expectedFee Expected fee amount\\n     */\\n    function _feeDeposited(uint256 expectedFee) internal {\\n        if (msg.value < expectedFee) revert NotEnoughFee();\\n\\n        emit GelatoFeeDeposited(contractOwner, expectedFee);\\n    }\\n\\n    function _validatePermissionAndAllowance(\\n        ISuperToken superToken,\\n        int96 flowRate\\n    ) internal view {\\n        if (!isPermissionValid(superToken)) revert InvalidPermission();\\n        if (!isFlowRateAllowanceEnough(superToken, flowRate))\\n            revert FlowRateAllowanceTooSmall();\\n    }\\n\\n    /**\\n     * @dev Get Module Data to create new tasks\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @return moduleData Module data for the task\\n     */\\n    function _getModuleData(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal view returns (ModuleData memory moduleData) {\\n        // Module data for the task\\n        moduleData = ModuleData({\\n            modules: new Module[](3),\\n            args: new bytes[](3)\\n        });\\n\\n        // Define the modules to be used\\n        moduleData.modules[0] = Module.RESOLVER;\\n        moduleData.modules[1] = Module.PROXY;\\n        moduleData.modules[2] = Module.SINGLE_EXEC;\\n\\n        // Define the arguments for the modules\\n        moduleData.args[0] = _resolverModuleArg(\\n            address(this),\\n            abi.encodeCall(this.checker, (superToken, receiver))\\n        );\\n        moduleData.args[1] = _proxyModuleArg();\\n        moduleData.args[2] = _singleExecModuleArg();\\n\\n        return moduleData;\\n    }\\n\\n    /**\\n     * @dev Calculate fee amount based on number of tasks created\\n     * @param created1 Whether task 1 was created\\n     * @param created2 Whether task 2 was created\\n     * @param created3 Whether task 3 was created\\n     * @return feeAmount Fee amount to be paid\\n     */\\n    function _calculateFeeAmount(\\n        bool created1,\\n        bool created2,\\n        bool created3\\n    ) internal view returns (uint256) {\\n        uint8 totalCreated = (created1 ? 1 : 0) +\\n            (created2 ? 1 : 0) +\\n            (created3 ? 1 : 0);\\n        return totalCreated * singleTaskFee;\\n    }\\n\\n    /**\\n     * @dev Get sender from context\\n     * @param ctx Context\\n     * @return sender Sender\\n     */\\n    function _getSender(\\n        bytes memory ctx\\n    ) internal view returns (address sender) {\\n        if (ctx.length != 0) {\\n            if (msg.sender != address(cfaV1.host)) revert HostInvalid();\\n            sender = cfaV1.host.decodeCtx(ctx).msgSender;\\n        } else {\\n            sender = msg.sender;\\n        }\\n        // This is an invariant and should never happen.\\n        assert(sender != address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/ILockingSchedulerAutomation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport {ISuperfluid, ISuperToken, SuperAppDefinitions} from \\\"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport {ISuperApp} from \\\"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\\\";\\n\\ninterface ILockingSchedulerAutomationEvents {\\n    /// Flow action used for events\\n    enum FlowAction {\\n        START,\\n        TRANSITION,\\n        END\\n    }\\n\\n    event FeeFundsReceived(address indexed sender, uint256 indexed amount);\\n    event FeeFundsWithdrawn(address indexed receiver, uint256 indexed amount);\\n    event AllTasksCancelled(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver\\n    );\\n    event TaskCreated(\\n        bytes32 id,\\n        ISuperToken indexed superToken,\\n        address indexed sender,\\n        address indexed receiver,\\n        FlowAction action\\n    );\\n    event TaskCancelled(\\n        bytes32 id,\\n        ISuperToken indexed superToken,\\n        address indexed sender,\\n        address indexed receiver,\\n        FlowAction action\\n    );\\n    event GelatoTaskFeeSet(uint256 fee);\\n    event GelatoFeeDeposited(address indexed sender, uint256 amount);\\n}\\n\\ninterface ILockingSchedulerAutomationInitializer is ISuperApp {\\n    function initialize(\\n        ISuperfluid _host,\\n        address payable _automate,\\n        uint256 _fee,\\n        address _admin,\\n        address _owner\\n    ) external;\\n}\\n\\ninterface ILockingSchedulerAutomation is\\n    ILockingSchedulerAutomationEvents,\\n    ILockingSchedulerAutomationInitializer\\n{\\n    /* ========== ERRORS ========== */\\n\\n    error ZeroFee();\\n    error InsufficientBalance();\\n    error TransferFailed();\\n    error CantExecuteStart();\\n    error CantExecuteTransition();\\n    error CantExecuteEnd();\\n    error TasksExist();\\n    error TasksDontExist();\\n    error ScheduleInvalid();\\n    error NotEnoughFee();\\n    error CantUpdateStartDate();\\n    error HostInvalid();\\n    error NotWhitelistedExecutor();\\n    error SchedulesExist();\\n    error NothingToWithdraw();\\n    error InvalidPermission();\\n    error FlowRateAllowanceTooSmall();\\n\\n    /* ========== STRUCTS ========== */\\n\\n    /// @dev Gelato task IDs used for automation\\n    /// @dev If action is not scheduled, ID is 0\\n    struct TaskIds {\\n        bytes32 startFlowId;\\n        bytes32 transitionFlowId;\\n        bytes32 endFlowId;\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Withdraw accumulated fee if no locking schedules are active or scheduled\\n     * @notice Only callable by owner\\n     */\\n    function emergencyFeeWithdraw() external;\\n\\n    /**\\n     * @dev Set gelato task fee\\n     * @param fee Amount to set as fee\\n     */\\n    function setGelatoTaskFee(uint256 fee) external;\\n\\n    /**\\n     * @dev Create a new locking schedule in Locking Scheduler\\n     * @dev Create new gelato tasks for the schedule in Automation\\n     * @dev Create new stream if start date is 0\\n     * @param superToken SuperToken to be locked\\n     * @param receiver Receiver of the stream\\n     * @param startLockerFlowDate Date to start locker flow\\n     * @param endSenderFlowDate Date to end sender flow\\n     * @param flowRate Flow rate of the stream\\n     * @param minAmount Minimum amount of super tokens to be locked\\n     * @param ctx Streampay context used when batching operations. (or bytes(0) if not batching)\\n     * @return newCtx Returns ctx to make sure batching works\\n     */\\n    function createLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        bytes memory ctx\\n    ) external payable returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Delete a locking schedule in Locking Scheduler\\n     * @dev Cancel all tasks for a locking schedule in Automation\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @param ctx Streampay context used when batching operations. (or bytes(0) if not batching)\\n     * @return newCtx Returns ctx to make sure batching works\\n     */\\n    function deleteLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        bytes memory ctx\\n    ) external returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Modify a locking schedule in Locking Scheduler\\n     * @dev Modify gelato tasks for the schedule in Automation\\n     * @dev Modify stream if start date is 0\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @param startLockerFlowDate Date to start locker flow\\n     * @param endSenderFlowDate Date to end sender flow\\n     * @param flowRate Flow rate of the stream\\n     * @param minAmount Minimum amount of super tokens to be locked\\n     * @param ctx Streampay context used when batching operations. (or bytes(0) if not batching)\\n     * @return newCtx Returns ctx to make sure batching works\\n     */\\n    function modifyLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        bytes memory ctx\\n    ) external payable returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Executes Locking schedule start\\n     * @dev Create flow from locker to receiver\\n     * @dev Called by gelato network\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function executeStart(ISuperToken superToken, address receiver) external;\\n\\n    /**\\n     * @dev Executes Locking schedule transition\\n     * @dev Delete flow from locker to receiver and create flor from sender to receiver\\n     * @dev Called by gelato network\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function executeTransition(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external;\\n\\n    /**\\n     * @dev Executes Locking schedule end\\n     * @dev Delete flow from sender to receiver\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function executeEnd(ISuperToken superToken, address receiver) external;\\n\\n    /**\\n     * @dev Find if gelato can execute a task\\n     * @dev Only returns true if task is scheduled\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @return canExec Whether gelato can execute the task\\n     * @return execPayload Function payload to execute the task\\n     */\\n    function checker(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (bool canExec, bytes memory execPayload);\\n\\n    /**\\n     * @dev Get gelato task fee\\n     * @return fee Amount of gelato task fee\\n     */\\n    function getSingleTaskFee() external view returns (uint256 fee);\\n\\n    /**\\n     * @dev Check if permission for a locker is valid\\n     * @param superToken SuperToken of the locking schedule\\n     * @return isValid Whether permission is valid\\n     */\\n    function isPermissionValid(\\n        ISuperToken superToken\\n    ) external view returns (bool isValid);\\n\\n    /**\\n     * @dev Check if flow rate allowance is enough for a given flow rate\\n     * @param superToken SuperToken\\n     * @param flowRate Flow rate of the stream\\n     * @return isEnough Whether flow rate allowance is enough\\n     */\\n    function isFlowRateAllowanceEnough(\\n        ISuperToken superToken,\\n        int96 flowRate\\n    ) external view returns (bool isEnough);\\n\\n    /**\\n     * @dev Check if flow rate allowance is enough for a locking schedule flow rate\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     * @return isEnough Whether flow rate allowance is enough\\n     */\\n    function isFlowRateAllowanceInScheduleEnough(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (bool isEnough);\\n\\n    /**\\n     * @dev Get gelato task IDs for a locking schedule\\n     * @param superToken SuperToken of the locking schedule\\n     * @param receiver Receiver of the stream\\n     */\\n    function getTaskIds(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (TaskIds memory ids);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/ILockingScheduler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport {ISuperfluid, ISuperApp, ISuperToken, SuperAppDefinitions} from \\\"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\n\\ninterface ILockingSchedulerEvents {\\n    event FundsLocked(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint256 totalAmount\\n    );\\n    event FundsLockedOnCreate(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint256 totalAmount\\n    );\\n    event FundsLockedOnUpdate(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint256 totalAmount\\n    );\\n    event FundsWithdrawnOnUpdate(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint256 totalAmount\\n    );\\n    event NoLockChanges(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver\\n    );\\n    event LockingScheduleCreated(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderDate,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        uint256 bufferAmount\\n    );\\n    event LockingScheduleUpdated(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderDate,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        uint256 bufferAmount\\n    );\\n    event LockingScheduleDeleted(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint256 returnedAmount\\n    );\\n    event FlowStartExecuted(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint32 startDate,\\n        int96 flowRate,\\n        uint256 flowDelayCompensation,\\n        bool lockerFlow\\n    );\\n    event FlowStartFailed(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint32 startDate,\\n        bool lockerFlow\\n    );\\n    event FlowEndExecuted(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint32 endDate,\\n        uint256 earlyEndCompensation,\\n        bool didCompensationFail,\\n        bool lockerFlow\\n    );\\n    event FlowEndFailed(\\n        ISuperToken indexed superToken,\\n        address indexed owner,\\n        address indexed receiver,\\n        uint32 endDate,\\n        bool lockerFlow\\n    );\\n}\\n\\ninterface ILockingScheduler is ILockingSchedulerEvents {\\n    /* ========== ERRORS ========== */\\n    error ZeroAddress();\\n    error LockerFlowStartInPast();\\n    error SenderFlowEndInPast();\\n    error NotContractOwner();\\n    error NotAdmin();\\n    error ScheduleAlreadyExists();\\n    error StatusInvalid(ScheduleStatus status);\\n    error AccountInvalid();\\n    error FlowRateInvalid();\\n    error AmountInvalid();\\n    error TransitionDateInvalid();\\n    error StartAndEndNotDefined();\\n    error StartAfterEnd();\\n    error LockerFlowTooShort();\\n    error SenderFlowTooShort();\\n    error NoChanges();\\n    error LockerFlowStartNotExecutable();\\n    error FlowTransitionNotExecutable();\\n    error SenderFlowEndNotExecutable();\\n    error CantDecreaseBelowZero();\\n\\n    /* ========== ENUMS ========== */\\n\\n    /// @dev Locking schedule possible status\\n    enum ScheduleStatus {\\n        DOES_NOT_EXIST,\\n        BEFORE_LOCKER_START,\\n        ACTIVE_LOCKER_FLOW,\\n        BEFORE_SENDER_FLOW, // Should never be stuck at this status, as it should be transitioned to ACTIVE_SENDER_FLOW\\n        ACTIVE_SENDER_FLOW\\n    }\\n\\n    /* ========== STRUCTS ========== */\\n\\n    /// @dev Locking schedule struct\\n    struct LockingSchedule {\\n        uint32 startLockerFlowDate; // opens stream from locker contract\\n        uint32 flowTransitionDate; // closes stream from locker and opens stream from sender (by operator)\\n        uint32 endSenderFlowDate; // closes stream from sender (by operator)\\n        uint32 gelatoStartSenderFlowDate; // 0 until gelato executes flow transition. Then set to gelato execution date\\n        uint32 expectedSenderFlowDuration; // 0 until gelato executes flow transition. Then set to expected duration\\n        int96 flowRate;\\n        uint256 minAmount;\\n        uint256 bufferAmount;\\n        ScheduleStatus status;\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Get existing schedules count\\n     * @return count Returns count of existing schedules\\n     */\\n    function getExistingSchedulesCount() external view returns (uint24 count);\\n\\n    /**\\n     * @dev Get locker contract owner\\n     * @return owner Address of locker contract owner\\n     */\\n    function getContractOwner() external view returns (address owner);\\n\\n    /**\\n     * @dev Get locker contract admin\\n     * @return admin Address of locker contract admin\\n     */\\n    function getAdmin() external view returns (address);\\n\\n    /**\\n     * @dev Find if locker flow start can be executed by gelato\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Receiver of the stream\\n     * @return returns if flow transition can be executed\\n     */\\n    function canExecuteLockerFlowStart(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Find if flow transition can be executed by gelato\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Receiver of the stream\\n     * @return returns if flow transition can be executed\\n     */\\n    function canExecuteFlowTransition(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Find if sender flow end can be executed by gelato\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Receiver of the stream\\n     * @return returns if flow transition can be executed\\n     */\\n    function canExecuteSenderFlowEnd(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Get locking schedule for a receiver\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Receiver of the stream\\n     * @return schedule Returns locking schedule struct\\n     */\\n    function getLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external view returns (LockingSchedule memory schedule);\\n\\n    /**\\n     * @dev Find transition date based on flow rate and minimal threshold amount\\n     * @dev User will only provide the minimal threshold amount and flow rate\\n     * @dev Locker contract will calculate the transition date based on those parameters\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start. If 0, start now\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     * @return flowTransitionDate returns calculated transition date\\n     */\\n    function getTransitionDate(\\n        uint32 startLockerFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount\\n    ) external view returns (uint32 flowTransitionDate);\\n\\n    /**\\n     * @dev Hashes token, sender and receiver addresses to get custom flow hash (e.g. ID)\\n     * @param superToken SuperToken to be locked\\n     * @param receiver Locking receiver\\n     * @return hashConfig returns hashed passed parameters\\n     */\\n    function getConfigHash(\\n        ISuperToken superToken,\\n        address receiver\\n    ) external pure returns (bytes32 hashConfig);\\n\\n    /**\\n     * @dev Find if flow is ongoing\\n     * @param superToken SuperToken to be streamed\\n     * @param sender Sender of the stream\\n     * @param receiver Receiver of the stream\\n     * @return returns if flow is ongoing\\n     */\\n    function isFlowOngoing(\\n        ISuperToken superToken,\\n        address sender,\\n        address receiver\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Get flow rate\\n     * @param superToken SuperToken of the stream\\n     * @param sender Sender of the stream\\n     * @param receiver Receiver of the stream\\n     * @return flowRate Returns flow rate\\n     */\\n    function getCurrentFlowRate(\\n        ISuperToken superToken,\\n        address sender,\\n        address receiver\\n    ) external view returns (int96 flowRate);\\n}\\n\"\r\n    },\r\n    \"/contracts/gelato/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.12;\\n\\nenum Module {\\n    RESOLVER,\\n    TIME,\\n    PROXY,\\n    SINGLE_EXEC\\n}\\n\\nstruct ModuleData {\\n    Module[] modules;\\n    bytes[] args;\\n}\\n\\ninterface IAutomate {\\n    function createTask(\\n        address execAddress,\\n        bytes calldata execDataOrSelector,\\n        ModuleData calldata moduleData,\\n        address feeToken\\n    ) external returns (bytes32 taskId);\\n\\n    function cancelTask(bytes32 taskId) external;\\n\\n    function getFeeDetails() external view returns (uint256, address);\\n\\n    function gelato() external view returns (address payable);\\n\\n    function taskTreasury() external view returns (ITaskTreasuryUpgradable);\\n}\\n\\ninterface ITaskTreasuryUpgradable {\\n    function depositFunds(\\n        address receiver,\\n        address token,\\n        uint256 amount\\n    ) external payable;\\n\\n    function withdrawFunds(\\n        address payable receiver,\\n        address token,\\n        uint256 amount\\n    ) external;\\n}\\n\\ninterface IOpsProxyFactory {\\n    function getProxyOf(address account) external view returns (address, bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/gelato/AutomateTaskCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.14;\\n\\nimport \\\"./AutomateReady.sol\\\";\\n\\n/**\\n * @dev Inherit this contract to allow your smart contract\\n * to be a task creator and create tasks.\\n */\\nabstract contract AutomateTaskCreator is AutomateReady {\\n    using SafeERC20 for IERC20;\\n\\n    function _initializeAutomateTaskCreator(address _automate) internal {\\n        _initializeAutomateReady(_automate, address(this));\\n    }\\n\\n    function _createTask(\\n        address _execAddress,\\n        bytes memory _execDataOrSelector,\\n        ModuleData memory _moduleData,\\n        address _feeToken\\n    ) internal returns (bytes32) {\\n        return\\n            automate.createTask(\\n                _execAddress,\\n                _execDataOrSelector,\\n                _moduleData,\\n                _feeToken\\n            );\\n    }\\n\\n    function _cancelTask(bytes32 _taskId) internal {\\n        automate.cancelTask(_taskId);\\n    }\\n\\n    function _resolverModuleArg(\\n        address _resolverAddress,\\n        bytes memory _resolverData\\n    ) internal pure returns (bytes memory) {\\n        return abi.encode(_resolverAddress, _resolverData);\\n    }\\n\\n    function _timeModuleArg(\\n        uint256 _startTime,\\n        uint256 _interval\\n    ) internal pure returns (bytes memory) {\\n        return abi.encode(uint128(_startTime), uint128(_interval));\\n    }\\n\\n    function _proxyModuleArg() internal pure returns (bytes memory) {\\n        return bytes(\\\"\\\");\\n    }\\n\\n    function _singleExecModuleArg() internal pure returns (bytes memory) {\\n        return bytes(\\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/gelato/AutomateReady.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./Types.sol\\\";\\n\\n/**\\n * @dev Inherit this contract to allow your smart contract to\\n * - Make synchronous fee payments.\\n * - Have call restrictions for functions to be automated.\\n */\\n// solhint-disable private-vars-leading-underscore\\nabstract contract AutomateReady {\\n    IAutomate public automate;\\n    address public gelatoExecutor;\\n    address private _gelato;\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant OPS_PROXY_FACTORY =\\n        0xC815dB16D4be6ddf2685C201937905aBf338F5D7;\\n\\n    /**\\n     * @dev\\n     * _taskCreator is the address which will create tasks for this contract.\\n     */\\n    function _initializeAutomateReady(\\n        address _automate,\\n        address _taskCreator\\n    ) internal {\\n        automate = IAutomate(_automate);\\n        _gelato = IAutomate(_automate).gelato();\\n        (gelatoExecutor, ) = IOpsProxyFactory(OPS_PROXY_FACTORY).getProxyOf(\\n            _taskCreator\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Transfers fee to gelato for synchronous fee payments.\\n     * _fee & _feeToken should be queried from IAutomate.getFeeDetails()\\n     */\\n    function _transfer(uint256 _fee, address _feeToken) internal {\\n        if (_feeToken == ETH) {\\n            (bool success, ) = _gelato.call{value: _fee}(\\\"\\\");\\n            require(success, \\\"_transfer: ETH transfer failed\\\");\\n        } else {\\n            SafeERC20.safeTransfer(IERC20(_feeToken), _gelato, _fee);\\n        }\\n    }\\n\\n    function _getFeeDetails()\\n        internal\\n        view\\n        virtual\\n        returns (uint256 fee, address feeToken)\\n    {\\n        (fee, feeToken) = automate.getFeeDetails();\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/LockingScheduler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport {ISuperfluid, ISuperApp, ISuperToken, SuperAppDefinitions} from \\\"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport {SuperAppBase} from \\\"@streamable-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol\\\";\\nimport {CFAv1Library} from \\\"@streamable-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\\\";\\nimport {IConstantFlowAgreementV1} from \\\"@streamable-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport {ILockingScheduler} from \\\"./interfaces/ILockingScheduler.sol\\\";\\n\\n/**\\n * @title Locker scheduler contract\\n * @author Streampay\\n */\\nabstract contract LockingScheduler is ILockingScheduler {\\n    /* ========== LIBRARIES ========== */\\n\\n    using CFAv1Library for CFAv1Library.InitData;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    CFAv1Library.InitData internal cfaV1;\\n    mapping(bytes32 => LockingSchedule) internal lockingSchedules; // id = keccak(supertoken, receiver)\\n    uint24 internal existingSchedulesCount;\\n    address internal contractOwner;\\n    address internal admin;\\n\\n    uint32 public constant EARLY_END_COMPENSATION_BUFFER_TIME = 5 minutes;\\n    uint32 public constant MIN_TRHESHOLD_BUFFER_TIME = 4 hours; // Required to calculate buffer amount for min threshold functionality\\n    uint32 public constant PROTOCOL_BUFFER_TIME = 4 hours; // Required to calculate buffer amount, which is taken by protocol to open stream\\n    uint32 public constant MIN_LOCKER_FLOW_TIME = 8 hours;\\n    uint32 public constant MIN_SENDER_FLOW_TIME = 8 hours;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function _initializeLockingScheduler(\\n        ISuperfluid _host,\\n        address _admin,\\n        address _owner\\n    ) internal {\\n        // Assign owner and admin\\n        contractOwner = _owner;\\n        admin = _admin;\\n\\n        cfaV1 = CFAv1Library.InitData(\\n            _host,\\n            IConstantFlowAgreementV1(\\n                address(\\n                    _host.getAgreementClass(\\n                        keccak256(\\n                            \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != contractOwner) revert NotContractOwner();\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        if (msg.sender != admin) revert NotAdmin();\\n        _;\\n    }\\n\\n    /* ========== EXTERNAL GETTER FUNCTIONS ========== */\\n\\n    function getExistingSchedulesCount() external view returns (uint24 count) {\\n        return existingSchedulesCount;\\n    }\\n\\n    /// @dev ILockingScheduler.getContractOwner implementation\\n    function getContractOwner() external view returns (address owner) {\\n        return contractOwner;\\n    }\\n\\n    /// @dev ILockingScheduler.getAdmin implementation\\n    function getAdmin() external view returns (address) {\\n        return admin;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    /// @dev ILockingScheduler.canExecuteLockerFlowStart implementation\\n    function canExecuteLockerFlowStart(\\n        ISuperToken superToken,\\n        address receiver\\n    ) public view returns (bool) {\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        /**\\n         * @notice To execute start:\\n         * @notice 1. locker start date must be set (flow schedule exists)\\n         * @notice 2. start date must have been past\\n         */\\n\\n        return\\n            schedule.status == ScheduleStatus.BEFORE_LOCKER_START &&\\n            schedule.startLockerFlowDate != 0 &&\\n            block.timestamp >= schedule.startLockerFlowDate;\\n    }\\n\\n    /// @dev ILockingScheduler.canExecuteFlowTransition implementation\\n    function canExecuteFlowTransition(\\n        ISuperToken superToken,\\n        address receiver\\n    ) public view returns (bool) {\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        /**\\n         * @notice To execute transition:\\n         * @notice 1. transition date must be set (flow schedule exists)\\n         * @notice 2. transition date with early end must have been past\\n         */\\n\\n        return\\n            schedule.status == ScheduleStatus.ACTIVE_LOCKER_FLOW &&\\n            schedule.flowTransitionDate != 0 &&\\n            block.timestamp >=\\n            schedule.flowTransitionDate - EARLY_END_COMPENSATION_BUFFER_TIME;\\n    }\\n\\n    /// @dev ILockingScheduler.canExecuteSenderFlowEnd implementation\\n    function canExecuteSenderFlowEnd(\\n        ISuperToken superToken,\\n        address receiver\\n    ) public view returns (bool) {\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        /**\\n         * @notice To execute end:\\n         * @notice 1. sender end date must be set (flow schedule exists)\\n         * @notice 2. end date with 2x early end must have been past\\n         * @dev Execute sender flow end if end sender flow date is defined\\n         * @dev Execution is allowed 2x EARLY_END_COMPENSATION_BUFFER_TIME earlier\\n         * @dev as flow transition step is going to be executed EARLY_END_COMPENSATION_BUFFER_TIME earlier\\n         */\\n\\n        return\\n            schedule.status == ScheduleStatus.ACTIVE_SENDER_FLOW &&\\n            schedule.endSenderFlowDate != 0 &&\\n            block.timestamp >=\\n            schedule.endSenderFlowDate -\\n                (2 * EARLY_END_COMPENSATION_BUFFER_TIME);\\n    }\\n\\n    /* ========== PUBLIC GETTER FUNCTIONS ========== */\\n\\n    /// @dev ILockingScheduler.getLockingSchedule implementation\\n    function getLockingSchedule(\\n        ISuperToken superToken,\\n        address receiver\\n    ) public view returns (LockingSchedule memory schedule) {\\n        return lockingSchedules[getConfigHash(superToken, receiver)];\\n    }\\n\\n    /// @dev ILockingScheduler.getTransitionDate implementation\\n    function getTransitionDate(\\n        uint32 startLockerFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount\\n    ) public view returns (uint32 flowTransitionDate) {\\n        // Calculate flow transition date\\n        if (flowRate == 0) revert FlowRateInvalid();\\n        uint256 lockerFlowDuration = minAmount / uint96(flowRate);\\n\\n        /**\\n         * @notice If flow start from locker is not set (is 0)\\n         * @notice sream should start immediately and calculate locker end date from current time\\n         * @notice else calculate locker end date from startLockerFlowDate\\n         */\\n        flowTransitionDate = startLockerFlowDate == 0\\n            ? uint32(block.timestamp + lockerFlowDuration)\\n            : uint32(startLockerFlowDate + lockerFlowDuration);\\n    }\\n\\n    /// @dev ILockingScheduler.getConfigHash implementation\\n    function getConfigHash(\\n        ISuperToken superToken,\\n        address receiver\\n    ) public pure returns (bytes32 hashConfig) {\\n        return keccak256(abi.encodePacked(superToken, receiver));\\n    }\\n\\n    /// @dev ILockingScheduler.isFlowOngoing implementation\\n    function isFlowOngoing(\\n        ISuperToken superToken,\\n        address sender,\\n        address receiver\\n    ) public view returns (bool) {\\n        int96 flowRate = getCurrentFlowRate(superToken, sender, receiver);\\n        return flowRate != 0;\\n    }\\n\\n    function getCurrentFlowRate(\\n        ISuperToken superToken,\\n        address sender,\\n        address receiver\\n    ) public view returns (int96 flowRate) {\\n        (, flowRate, , ) = cfaV1.cfa.getFlow(superToken, sender, receiver);\\n        return flowRate;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Lock sender funds in locker contract and create a new locking schedule\\n     * @dev Function explicitly used only for locking for the first time\\n     * @notice This function is only callable by contract owner\\n     * @param superToken SuperToken to be locked\\n     * @param receiver Locking receiver\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     */\\n    function _lockAndCreateSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount\\n    ) internal {\\n        // Calculate flow transition date\\n        uint32 flowTransitionDate = getTransitionDate(\\n            startLockerFlowDate,\\n            flowRate,\\n            minAmount\\n        );\\n\\n        // Validate a data and time before creating a new schedule\\n        _validateBeforeCreate(\\n            superToken,\\n            receiver,\\n            flowRate,\\n            minAmount,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate\\n        );\\n\\n        // Create a new locking schedule\\n        _createScheduleNoValidation(\\n            superToken,\\n            receiver,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate,\\n            flowRate,\\n            minAmount\\n        );\\n\\n        // Transfer tokens to locker contract\\n        _lockOnCreate(superToken, receiver);\\n    }\\n\\n    /**\\n     * @dev Update schedule and lock sender funds in locker contract (if needed).\\n     * @dev Function explicitly used only for updating locking schedule\\n     * @notice This function is only callable by contract owner\\n     * @param superToken SuperToken to be locked\\n     * @param receiver Locking receiver\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     */\\n    function _lockAndUpdateSchedule(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount\\n    ) internal {\\n        // Calculate flow transition date\\n        uint32 flowTransitionDate = getTransitionDate(\\n            startLockerFlowDate,\\n            flowRate,\\n            minAmount\\n        );\\n\\n        // Validate a data and time before updating a schedule\\n        _validateBeforeUpdate(\\n            superToken,\\n            receiver,\\n            flowRate,\\n            minAmount,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate\\n        );\\n\\n        // Store old schedule in memory for later usage\\n        LockingSchedule memory oldSchedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Update schedule\\n        _updateScheduleNoValidation(\\n            superToken,\\n            receiver,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate,\\n            flowRate,\\n            minAmount\\n        );\\n\\n        // Store new schedule in memory for later usage\\n        LockingSchedule memory newSchedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Use old and new schedules to lock or unlock owner funds\\n        _lockOnUpdate(superToken, receiver, oldSchedule, newSchedule);\\n    }\\n\\n    /**\\n     * @dev Delete locking Schedule with data validation\\n     * @param superToken SuperToken to delete schedule for\\n     * @param receiver Funds receiver\\n     */\\n    function _deleteSchedule(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        // Check if status is valid for deletion\\n        _validateBeforeDelete(superToken, receiver);\\n\\n        // Delete schedule\\n        _deleteScheduleNoValidation(superToken, receiver);\\n    }\\n\\n    /**\\n     * @dev Execute locker flow start (only when start time is scheduled)\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Funds receiver\\n     */\\n    function _executeLockerFlowStart(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        // Check if flow start can be executed\\n        if (!canExecuteLockerFlowStart(superToken, receiver)) {\\n            revert LockerFlowStartNotExecutable();\\n        }\\n\\n        // Execute start\\n        _startLockerFlow(superToken, receiver);\\n    }\\n\\n    /**\\n     * @dev Execute locker flow transition\\n     * @dev End locker flow and start sender flow\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Funds receiver\\n     */\\n    function _executeFlowTransition(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        // Check if flow transition can be executed\\n        if (!canExecuteFlowTransition(superToken, receiver)) {\\n            revert FlowTransitionNotExecutable();\\n        }\\n\\n        // Execute locker flow end and sender flow start\\n        _endLockerFlow(superToken, receiver);\\n        _startSenderFlow(superToken, receiver);\\n    }\\n\\n    /**\\n     * @dev Execute sender flow end\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Funds receiver\\n     */\\n    function _executeSenderFlowEnd(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        // Check if flow end can be executed\\n        if (!canExecuteSenderFlowEnd(superToken, receiver))\\n            revert SenderFlowEndNotExecutable();\\n\\n        // Execute end\\n        _endSenderFlow(superToken, receiver);\\n    }\\n\\n    /**\\n     * @dev Create locking Schedule without validation\\n     * @param superToken SuperToken to be locked\\n     * @param receiver Funds receiver\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param flowTransitionDate Timestamp when the flow from locker should end and sender flow should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     */\\n    function _createScheduleNoValidation(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount\\n    ) internal {\\n        // Calculate buffer amount based on flow rate\\n        uint256 bufferAmount = uint96(flowRate) *\\n            (MIN_TRHESHOLD_BUFFER_TIME + PROTOCOL_BUFFER_TIME);\\n\\n        // Create new schedule\\n        lockingSchedules[getConfigHash(superToken, receiver)] = LockingSchedule(\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate,\\n            0, // 0 until gelato executes flow transition.\\n            0, // 0 until gelato executes flow transition.\\n            flowRate,\\n            minAmount,\\n            bufferAmount,\\n            ScheduleStatus.BEFORE_LOCKER_START\\n        );\\n\\n        _increaseSchedulesCount();\\n\\n        emit LockingScheduleCreated(\\n            superToken,\\n            contractOwner,\\n            receiver,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate,\\n            flowRate,\\n            minAmount,\\n            bufferAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Update locking Schedule without validation\\n     * @param superToken SuperToken to update schedule for\\n     * @param receiver Funds receiver\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param flowTransitionDate Timestamp when the flow from locker should end and sender flow should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     */\\n    function _updateScheduleNoValidation(\\n        ISuperToken superToken,\\n        address receiver,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderFlowDate,\\n        int96 flowRate,\\n        uint256 minAmount\\n    ) internal {\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Calculate buffer amount based on flow rate\\n        uint256 bufferAmount = uint96(flowRate) *\\n            (MIN_TRHESHOLD_BUFFER_TIME + PROTOCOL_BUFFER_TIME);\\n\\n        // Update current schedule\\n        lockingSchedules[getConfigHash(superToken, receiver)] = LockingSchedule(\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate,\\n            schedule.gelatoStartSenderFlowDate,\\n            schedule.expectedSenderFlowDuration,\\n            flowRate,\\n            minAmount,\\n            bufferAmount,\\n            schedule.status\\n        );\\n\\n        emit LockingScheduleUpdated(\\n            superToken,\\n            contractOwner,\\n            receiver,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate,\\n            flowRate,\\n            minAmount,\\n            bufferAmount\\n        );\\n    }\\n\\n    function _deleteScheduleNoValidation(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Delete and set status to DOES_NOT_EXIST\\n        delete lockingSchedules[getConfigHash(superToken, receiver)];\\n\\n        // Transfer Buffer Amount\\n        uint256 amount = schedule.bufferAmount;\\n        if (schedule.status == ScheduleStatus.BEFORE_LOCKER_START)\\n            amount += schedule.minAmount;\\n\\n        superToken.transfer(contractOwner, amount);\\n\\n        _decreaseSchedulesCount();\\n\\n        emit LockingScheduleDeleted(\\n            superToken,\\n            contractOwner,\\n            receiver,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Lock user funds in locker contract\\n     * @param superToken SuperToken to be locked\\n     * @param receiver Funds receiver (when stream is active)\\n     */\\n    function _lockOnCreate(ISuperToken superToken, address receiver) internal {\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Calculate total amount to be locked (min threshold + buffer)\\n        uint256 totalAmount = schedule.minAmount + schedule.bufferAmount;\\n\\n        // Transfer tokens to locker contract\\n        superToken.transferFrom(contractOwner, address(this), totalAmount);\\n\\n        emit FundsLockedOnCreate(\\n            superToken,\\n            contractOwner,\\n            receiver,\\n            totalAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Lock or unlock user funds in locker contract depending on schedule changes\\n     * @param superToken SuperToken to be locked/unlocked\\n     * @param receiver Funds receiver (when stream is active)\\n     * @param oldSchedule Old locking schedule (before update)\\n     * @param newSchedule New locking schedule (after update)\\n     */\\n    function _lockOnUpdate(\\n        ISuperToken superToken,\\n        address receiver,\\n        LockingSchedule memory oldSchedule,\\n        LockingSchedule memory newSchedule\\n    ) internal {\\n        // Calculate changes only if flow rate or min threshold amount has changed\\n        if (\\n            newSchedule.flowRate != oldSchedule.flowRate ||\\n            newSchedule.minAmount != oldSchedule.minAmount\\n        ) {\\n            /**\\n             * @dev Calculate difference between old and new buffer amount\\n             * @dev Negative number means that sender needs to withdraw the difference\\n             * @dev Positive number means that sender needs to deposit the difference\\n             * @dev This is done to avoid multiple transfers\\n             * @dev If buffer amount is 0, no transfer is needed\\n             */\\n            int256 bufferDifference = int256(newSchedule.bufferAmount) -\\n                int256(oldSchedule.bufferAmount);\\n            int256 minAmountDifference = int256(newSchedule.minAmount) -\\n                int256(oldSchedule.minAmount);\\n\\n            // Total difference is buffer difference + min amount difference\\n            int256 totalDifference = bufferDifference + minAmountDifference;\\n\\n            // If total difference is positive, deposit the difference\\n            if (totalDifference > 0) {\\n                uint256 amount = uint256(totalDifference);\\n\\n                /**\\n                 * @dev Transfer tokens to locker contract from owner\\n                 * @todo later on use accumulated Buffer amount instead of taking more tokens\\n                 */\\n                superToken.transferFrom(contractOwner, address(this), amount);\\n                emit FundsLockedOnUpdate(\\n                    superToken,\\n                    contractOwner,\\n                    receiver,\\n                    amount\\n                );\\n            }\\n            // If total difference is negative, withdraw the difference\\n            else if (totalDifference < 0) {\\n                // Convert to positive number\\n                uint256 amount = uint256(-totalDifference);\\n\\n                // Transfer the overpaid amount to contract owner\\n                superToken.transfer(contractOwner, amount);\\n                emit FundsWithdrawnOnUpdate(\\n                    superToken,\\n                    contractOwner,\\n                    receiver,\\n                    amount\\n                );\\n            }\\n            // If total difference is 0, no transfer is needed\\n        }\\n        // No funds were locked or unlocked\\n        else {\\n            emit NoLockChanges(superToken, contractOwner, receiver);\\n        }\\n    }\\n\\n    /**\\n     * @dev Start locker flow\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Funds receiver\\n     */\\n    function _startLockerFlow(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        _validateAddress(superToken, receiver);\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Get config hash\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        // Invalidate configuration to avoid any chance of re-execution or re-entry.\\n        delete lockingSchedules[configHash].startLockerFlowDate;\\n        // Set status to ACTIVE_LOCKER_FLOW\\n        lockingSchedules[configHash].status = ScheduleStatus.ACTIVE_LOCKER_FLOW;\\n\\n        uint256 flowDelayCompensation;\\n\\n        // If start time was not scheduled or deleted, no compensation is needed\\n        // Else calculate compensation\\n        if (\\n            schedule.startLockerFlowDate != 0 &&\\n            block.timestamp > schedule.startLockerFlowDate\\n        ) {\\n            // Compensate for the fact that flow will almost always be executed slightly later than scheduled.\\n            // If there's compensation, transfer that amount.\\n\\n            flowDelayCompensation =\\n                (block.timestamp - schedule.startLockerFlowDate) *\\n                uint96(schedule.flowRate);\\n            superToken.transfer(receiver, flowDelayCompensation);\\n        }\\n\\n        // Get active stream data\\n        int96 currentFlowRate = getCurrentFlowRate(\\n            superToken,\\n            address(this),\\n            receiver\\n        );\\n\\n        // Create Flow\\n        if (currentFlowRate == 0) {\\n            // Create stream from locker contract to receiver\\n            cfaV1.createFlow(receiver, superToken, schedule.flowRate);\\n        }\\n        // If stream is active, update the flow\\n        else if (currentFlowRate > 0 && currentFlowRate != schedule.flowRate) {\\n            // The locker should never have the active stream to receiver when executing start\\n            // But for safety, we update the flow rate\\n            cfaV1.updateFlow(receiver, superToken, schedule.flowRate);\\n        }\\n\\n        emit FlowStartExecuted(\\n            superToken,\\n            contractOwner,\\n            receiver,\\n            schedule.startLockerFlowDate,\\n            schedule.flowRate,\\n            flowDelayCompensation,\\n            true\\n        );\\n    }\\n\\n    /**\\n     * @dev End locker flow\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Funds receiver\\n     */\\n    function _endLockerFlow(ISuperToken superToken, address receiver) internal {\\n        _validateAddress(superToken, receiver);\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Set status to BEFORE_SENDER_FLOW\\n        lockingSchedules[getConfigHash(superToken, receiver)]\\n            .status = ScheduleStatus.BEFORE_SENDER_FLOW;\\n\\n        // If flow is active, we can perform the end\\n        if (isFlowOngoing(superToken, address(this), receiver)) {\\n            // Delete stream to calculate compensation\\n            cfaV1.deleteFlow(address(this), receiver, superToken);\\n\\n            bool didCompensationFail;\\n            uint256 earlyEndCompensation;\\n\\n            if (block.timestamp < schedule.flowTransitionDate) {\\n                earlyEndCompensation =\\n                    (schedule.flowTransitionDate - block.timestamp) *\\n                    uint96(schedule.flowRate);\\n\\n                // try-catch this because if the account does not have tokens for earlyEndCompensation\\n                // we should delete the flow anyway.\\n                try\\n                    superToken.transfer(receiver, earlyEndCompensation)\\n                // solhint-disable-next-line no-empty-blocks\\n                {\\n\\n                } catch {\\n                    didCompensationFail = true;\\n                }\\n            }\\n\\n            emit FlowEndExecuted(\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                schedule.flowTransitionDate,\\n                earlyEndCompensation,\\n                didCompensationFail,\\n                true\\n            );\\n        }\\n        // If flow is not active, we can't do anything, just emit failing event.\\n        else {\\n            emit FlowEndFailed(\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                schedule.flowTransitionDate,\\n                true\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Start sender flow\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Funds receiver\\n     */\\n    function _startSenderFlow(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal {\\n        _validateAddress(superToken, receiver);\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Get config hash\\n        bytes32 configHash = getConfigHash(superToken, receiver);\\n        // Calculate expected sender flow duration\\n        if (schedule.endSenderFlowDate != 0) {\\n            lockingSchedules[configHash].expectedSenderFlowDuration =\\n                schedule.endSenderFlowDate -\\n                schedule.flowTransitionDate;\\n        }\\n\\n        // Invalidate configuration to avoid any chance of re-execution or re-entry.\\n        delete lockingSchedules[configHash].flowTransitionDate;\\n        // Set status to ACTIVE_SENDER_FLOW\\n        lockingSchedules[configHash].status = ScheduleStatus.ACTIVE_SENDER_FLOW;\\n        // Set gelato start sender flow date for compensation calculation\\n        lockingSchedules[configHash].gelatoStartSenderFlowDate = uint32(\\n            block.timestamp\\n        );\\n\\n        // Get active stream data\\n        int96 currentFlowRate = getCurrentFlowRate(\\n            superToken,\\n            contractOwner,\\n            receiver\\n        );\\n\\n        // Create the flow\\n        if (currentFlowRate == 0) {\\n            cfaV1.createFlowByOperator(\\n                contractOwner,\\n                receiver,\\n                superToken,\\n                schedule.flowRate\\n            );\\n        }\\n        // If stream is active, update the flow\\n        else if (currentFlowRate > 0 && currentFlowRate != schedule.flowRate) {\\n            cfaV1.updateFlowByOperator(\\n                contractOwner,\\n                receiver,\\n                superToken,\\n                schedule.flowRate\\n            );\\n        }\\n\\n        emit FlowStartExecuted(\\n            superToken,\\n            contractOwner,\\n            receiver,\\n            schedule.flowTransitionDate,\\n            schedule.flowRate,\\n            0,\\n            false\\n        );\\n    }\\n\\n    /**\\n     * @dev End sender flow\\n     * @param superToken SuperToken to be streamed\\n     * @param receiver Funds receiver\\n     */\\n    function _endSenderFlow(ISuperToken superToken, address receiver) internal {\\n        _validateAddress(superToken, receiver);\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Delete schedule\\n        _deleteSchedule(superToken, receiver);\\n\\n        // If flow is active, we can perform end\\n        if (isFlowOngoing(superToken, contractOwner, receiver)) {\\n            // Delete stream to calculate compensation\\n            cfaV1.deleteFlowByOperator(contractOwner, receiver, superToken);\\n\\n            /**\\n             * @dev Gelato will execute this function earlier (2x EARLY_END_COMPENSATION_BUFFER_TIME)\\n             * @dev That's why we need to calculate real sender flow duration\\n             * @dev and compare it with scheduled sender flow duration\\n             */\\n            uint32 realSenderFlowDuration = uint32(block.timestamp) -\\n                schedule.gelatoStartSenderFlowDate;\\n\\n            uint256 earlyEndCompensation;\\n            bool didCompensationFail;\\n\\n            if (realSenderFlowDuration < schedule.expectedSenderFlowDuration) {\\n                /**\\n                 * @dev Calculate compensation based on real and scheduled sender flow duration\\n                 * @dev If real sender flow duration is longer than scheduled, no compensation is needed\\n                 */\\n                earlyEndCompensation =\\n                    (schedule.expectedSenderFlowDuration -\\n                        realSenderFlowDuration) *\\n                    uint96(schedule.flowRate);\\n\\n                // try-catch this because if the account does not have tokens for earlyEndCompensation\\n                // we should delete the flow anyway.\\n                try\\n                    superToken.transferFrom(\\n                        contractOwner,\\n                        receiver,\\n                        earlyEndCompensation\\n                    )\\n                // solhint-disable-next-line no-empty-blocks\\n                {\\n\\n                } catch {\\n                    didCompensationFail = true;\\n                }\\n            }\\n\\n            emit FlowEndExecuted(\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                schedule.endSenderFlowDate,\\n                earlyEndCompensation,\\n                didCompensationFail,\\n                false\\n            );\\n        }\\n        // If flow is not active, we can't do anything, just emit failing event.\\n        else {\\n            emit FlowEndFailed(\\n                superToken,\\n                contractOwner,\\n                receiver,\\n                schedule.endSenderFlowDate,\\n                false\\n            );\\n        }\\n    }\\n\\n    function _increaseSchedulesCount() internal {\\n        existingSchedulesCount++;\\n    }\\n\\n    function _decreaseSchedulesCount() internal {\\n        if (existingSchedulesCount == 0) revert CantDecreaseBelowZero();\\n        existingSchedulesCount--;\\n    }\\n\\n    /**\\n     * @dev Validate data before creating a new schedule\\n     * @param superToken SuperToken to be locked\\n     * @param receiver Funds receiver\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param flowTransitionDate Timestamp when the flow from locker should end and sender flow should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     */\\n    function _validateBeforeCreate(\\n        ISuperToken superToken,\\n        address receiver,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderFlowDate\\n    ) internal view {\\n        _validateAddress(superToken, receiver);\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Revert if schedule already exists\\n        if (schedule.status != ScheduleStatus.DOES_NOT_EXIST)\\n            revert ScheduleAlreadyExists();\\n\\n        _validateScheduleData(\\n            flowRate,\\n            minAmount,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate\\n        );\\n    }\\n\\n    /**\\n     * @dev Validate data before deleting a schedule\\n     * @param superToken SuperToken to delete schedule for\\n     * @param receiver Funds receiver\\n     */\\n    function _validateBeforeDelete(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal view {\\n        _validateAddress(superToken, receiver);\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n\\n        // Revert if schedule doesn't exist or is already active\\n        if (\\n            schedule.status == ScheduleStatus.DOES_NOT_EXIST ||\\n            schedule.status == ScheduleStatus.ACTIVE_LOCKER_FLOW\\n        ) revert StatusInvalid(schedule.status);\\n    }\\n\\n    /**\\n     * @dev Validate data before updating a schedule\\n     * @param superToken SuperToken to update schedule for\\n     * @param receiver Funds receiver\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param flowTransitionDate Timestamp when the flow from locker should end and sender flow should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     */\\n    function _validateBeforeUpdate(\\n        ISuperToken superToken,\\n        address receiver,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderFlowDate\\n    ) internal view {\\n        _validateAddress(superToken, receiver);\\n\\n        LockingSchedule memory schedule = getLockingSchedule(\\n            superToken,\\n            receiver\\n        );\\n        _validateChanges(\\n            schedule,\\n            flowRate,\\n            minAmount,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate\\n        );\\n\\n        _validateScheduleData(\\n            flowRate,\\n            minAmount,\\n            startLockerFlowDate,\\n            flowTransitionDate,\\n            endSenderFlowDate\\n        );\\n    }\\n\\n    /**\\n     * @dev Validate addresses\\n     * @param superToken SuperToken to be locked/streamed\\n     * @param receiver Locking receiver\\n     */\\n    function _validateAddress(\\n        ISuperToken superToken,\\n        address receiver\\n    ) internal view {\\n        _validateSuperToken(superToken);\\n        if (receiver == address(0)) revert ZeroAddress();\\n        if (receiver == contractOwner) revert AccountInvalid();\\n    }\\n\\n    /**\\n     * @dev Validate SuperToken\\n     * @param superToken SuperToken to be locked/streamed/withdrawn\\n     */\\n    function _validateSuperToken(ISuperToken superToken) internal pure {\\n        if (address(superToken) == address(0)) revert ZeroAddress();\\n    }\\n\\n    /**\\n     * @dev Validate general schedule data\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param flowTransitionDate Timestamp when the flow from locker should end and sender flow should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     */\\n    function _validateScheduleData(\\n        int96 flowRate,\\n        uint256 minAmount,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderFlowDate\\n    ) internal view {\\n        //R evert if flow rate, minimal amount or flow transition date are invalid\\n        if (flowRate <= 0) revert FlowRateInvalid();\\n        if (minAmount <= 0) revert AmountInvalid();\\n        if (flowTransitionDate <= 0) revert TransitionDateInvalid();\\n\\n        // Revert if locker flow start and end dates weren't defined\\n        if (startLockerFlowDate == 0 && endSenderFlowDate == 0)\\n            revert StartAndEndNotDefined();\\n\\n        // Revert if locker flow start date was defined and\\n        // sender flow end date is in the past\\n        if (endSenderFlowDate != 0 && endSenderFlowDate <= block.timestamp)\\n            revert SenderFlowEndInPast();\\n\\n        // Revert if locker flow start date was defined and\\n        // locker flow start date is in the past\\n        if (startLockerFlowDate != 0 && startLockerFlowDate <= block.timestamp)\\n            revert LockerFlowStartInPast();\\n\\n        // Revert if locker flow start date was defined and\\n        // sender flow end date was defined and\\n        // start date is after (or equal to) end date\\n        if (\\n            startLockerFlowDate != 0 &&\\n            endSenderFlowDate != 0 &&\\n            startLockerFlowDate >= endSenderFlowDate\\n        ) revert StartAfterEnd();\\n\\n        // Revert if time window between locker flow end date (flow transition)\\n        // and start date is less than required\\n        if (\\n            startLockerFlowDate != 0 &&\\n            (startLockerFlowDate > flowTransitionDate ||\\n                flowTransitionDate - startLockerFlowDate < MIN_LOCKER_FLOW_TIME)\\n        ) revert LockerFlowTooShort();\\n\\n        // Revert if time window between sender flow end date\\n        // and start date (flow transition) is less than required\\n        if (\\n            endSenderFlowDate != 0 &&\\n            (flowTransitionDate > endSenderFlowDate ||\\n                endSenderFlowDate - flowTransitionDate < MIN_SENDER_FLOW_TIME)\\n        ) revert SenderFlowTooShort();\\n    }\\n\\n    /**\\n     * @dev Validate schedule changes\\n     * @param schedule Current schedule that is going to be updated\\n     * @param flowRate The flowRate for the stream\\n     * @param minAmount The amount to be transferred as minimal threshold\\n     * @param startLockerFlowDate Timestamp when the flow from locker should start\\n     * @param flowTransitionDate Timestamp when the flow from locker should end and sender flow should start\\n     * @param endSenderFlowDate Timestamp when the flow from sender should end\\n     */\\n    function _validateChanges(\\n        LockingSchedule memory schedule,\\n        int96 flowRate,\\n        uint256 minAmount,\\n        uint32 startLockerFlowDate,\\n        uint32 flowTransitionDate,\\n        uint32 endSenderFlowDate\\n    ) internal pure {\\n        ScheduleStatus status = schedule.status;\\n\\n        // Revert if new parameters are the same as current\\n        if (\\n            schedule.startLockerFlowDate == startLockerFlowDate &&\\n            schedule.flowTransitionDate == flowTransitionDate &&\\n            schedule.endSenderFlowDate == endSenderFlowDate &&\\n            schedule.flowRate == flowRate &&\\n            schedule.minAmount == minAmount\\n        ) revert NoChanges();\\n\\n        // Allow update only if status is BEFORE_LOCKER_START\\n        if (status != ScheduleStatus.BEFORE_LOCKER_START)\\n            revert StatusInvalid(status);\\n    }\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\n/**\\n * @title ERC20 token info interface\\n * @author Superfluid\\n * @dev ERC20 standard interface does not specify these functions, but\\n *      often the token implementations have them.\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n/**\\n * @title ERC20 token with token info interface\\n * @author Superfluid\\n * @dev Using abstract contract instead of interfaces because old solidity\\n *      does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * @custom:note \\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * @custom:note \\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account to be liquidated\\n     * @param rewardAmount The amount the rewarded account will receive\\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\\n     *\\n     * @custom:note \\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAmountReceiver,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken  } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\n\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * @custom:note \\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n    \\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n    \\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.2;\\n\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\nimport {\\n    BatchOperation,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    SuperAppDefinitions,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * @notice This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * @custom:modifiers \\n     * - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * @custom:modifiers \\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token) external;\\n    /**\\n     * @dev SuperToken logic updated event\\n     * @param code Address of the new SuperToken logic\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares itself as a super app.\\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\\n     * because app registration is currently governance permissioned on mainnets.\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Message sender declares itself as a super app.\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\\n     * must be the deployer account the registration key was issued for.\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app level\\n     * @param app Super app address\\n     */\\n    function getAppLevel(ISuperApp app) external view returns(uint8 appLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app allowance and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx            The current context of the transaction.\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appAllowanceGranted     App allowance granted so far.\\n     * @param  appAllowanceUsed        App allowance used so far.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appAllowanceGranted,\\n        int256 appAllowanceUsed,\\n        ISuperfluidToken appAllowanceToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appAllowanceUsedDelta   App allowance used by the app.\\n     * @return newCtx                  The current context of the transaction.\\n     *\\n     * @custom:security \\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app allowance.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appAllowanceWantedMore   See app allowance for more details.\\n     * @param  appAllowanceUsedDelta    See app allowance for more details.\\n     * @return newCtx                   The current context of the transaction.\\n     */\\n    function ctxUseAllowance(\\n        bytes calldata ctx,\\n        uint256 appAllowanceWantedMore,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * @custom:note See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * @custom:note on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // callback level\\n        uint8 appLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app allowance granted\\n        uint256 appAllowanceGranted;\\n        // app allowance wanted by the app callback\\n        uint256 appAllowanceWanted;\\n        // app allowance used, allowing negative values over a callback session\\n        int256 appAllowanceUsed;\\n        // app address\\n        address appAddress;\\n        // app allowance in super token\\n        ISuperfluidToken appAllowanceToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes calldata ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] memory operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] memory operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\nimport {\\n    IERC20,\\n    ERC20WithTokenInfo\\n} from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the current super token logic used by the factory\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABE\\n    }\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     *\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * @custom:note SuperToken always uses 18 decimals.\\n     *\\n     * This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * @notice This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:note Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * @custom:emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * @custom:note For super token contracts, this value is always 1\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `data` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * @custom:emits an {AuthorizedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * @custom:emits a {RevokedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     *\\n     * @custom:modifiers \\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to received upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param data User data for the TokensRecipient callback\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are upgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transfer from by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender  The account where the funds is sent from.\\n    * @param recipient The recipient of thefunds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * @custom:note \\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to the after-hook callback.\\n    *\\n    * @custom:note \\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appLevel, uint8 callType)\\n    {\\n        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\n library FlowOperatorDefinitions {\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n    uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n        AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n    function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n        return (\\n            permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n                | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n                | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n            ) == uint8(0);\\n    }\\n }\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes calldata, bytes userdata)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY = \\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure returns (uint256 liquidationPeriod, uint256 patricianPeriod) {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @title Constant Flow Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @notice Get the maximum flow rate allowed with the deposit\\n     * @dev The deposit is clipped and rounded down\\n     * @param deposit Deposit amount used for creating the flow\\n     * @return flowRate The maximum flow rate\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Get the deposit required for creating the flow\\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\\n     * @param flowRate Flow rate to be tested\\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\\n     * @custom:note \\n     * - if calculated deposit (flowRate * liquidationPeriod) is less\\n     *   than the minimum deposit, we use the minimum deposit otherwise\\n     *   we use the calculated deposit\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(\\n        ISuperfluidToken token,\\n        address account)\\n        public view virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 timestamp\\n    )\\n        public view virtual\\n        returns (bool);\\n\\n    /**\\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissions A bitmask representation of the granted permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowOperatorPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance,\\n        bytes calldata ctx\\n    ) \\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\\n     * @param token Super token address\\n     * @param sender The permission granter address\\n     * @param flowOperator The permission grantee address\\n     * @return flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorData(\\n       ISuperfluidToken token,\\n       address sender,\\n       address flowOperator\\n    )\\n        public view virtual\\n        returns (\\n            bytes32 flowOperatorId,\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Get flow operator using flowOperatorId\\n     * @param token Super token address\\n     * @param flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorDataByID(\\n       ISuperfluidToken token,\\n       bytes32 flowOperatorId\\n    )\\n        external view virtual\\n        returns (\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Create a flow betwen ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - A deposit is taken as safety margin for the solvency agents\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Create a flow between sender and receiver\\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function createFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Update the flow rate between ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - Only the flow sender may update the flow rate\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system\\n     * - Deposit amount will be adjusted accordingly\\n     * - No new gas fee is charged\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Update a flow between sender and receiver\\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function updateFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver` of `token`\\n     * @param token Super token address\\n     * @param sender Flow receiver\\n     * @param receiver Flow sender\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @notice Get flow data using agreementId\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The deposit amount of the flow\\n     * @return owedDeposit The owed deposit amount of the flow\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return timestamp Timestamp of when a flow was last updated for account\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return flowRate Net flow rate\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     *\\n     * @custom:callbacks \\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - Both flow sender and receiver may delete the flow\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement\\n     * - Gas fee may be returned to the sender\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     */\\n    function deleteFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n     \\n    /**\\n     * @dev Flow operator updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param flowOperator Flow operator address\\n     * @param permissions Octo bitmask representation of permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    event FlowOperatorUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    );\\n\\n    /**\\n     * @dev Flow updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param receiver Flow recipient address\\n     * @param flowRate Flow rate in amount per second for this flow\\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\\n     * @param userData The user provided data\\n     *\\n     */\\n    event FlowUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed receiver,\\n        int96 flowRate,\\n        int256 totalSenderFlowRate,\\n        int256 totalReceiverFlowRate,\\n        bytes userData\\n    );\\n\\n    /**\\n     * @dev Flow updated extension event\\n     * @param flowOperator Flow operator address - the Context.msgSender\\n     * @param deposit The deposit amount for the stream\\n     */\\n    event FlowUpdatedExtension(\\n        address indexed flowOperator,\\n        uint256 deposit\\n    );\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken,\\n    ISuperApp,\\n    SuperAppDefinitions\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nabstract contract SuperAppBase is ISuperApp {\\n\\n    function beforeAgreementCreated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback - Before Agreement Created\\\");\\n    }\\n\\n    function afterAgreementCreated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Created\\\");\\n    }\\n\\n    function beforeAgreementUpdated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback - Before Agreement updated\\\");\\n    }\\n\\n    function afterAgreementUpdated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Updated\\\");\\n    }\\n\\n    function beforeAgreementTerminated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes memory /*cbdata*/)\\n    {\\n        revert(\\\"Unsupported callback -  Before Agreement Terminated\\\");\\n    }\\n\\n    function afterAgreementTerminated(\\n        ISuperToken /*superToken*/,\\n        address /*agreementClass*/,\\n        bytes32 /*agreementId*/,\\n        bytes calldata /*agreementData*/,\\n        bytes calldata /*cbdata*/,\\n        bytes calldata /*ctx*/\\n    )\\n        external\\n        virtual\\n        override\\n        returns (bytes memory /*newCtx*/)\\n    {\\n        revert(\\\"Unsupported callback - After Agreement Terminated\\\");\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@streamable-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.14;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperfluidToken\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nimport {\\n    IConstantFlowAgreementV1\\n} from \\\"../interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\n\\n/**\\n * @title Constant flow agreement v1 library\\n * @author Superfluid\\n * @dev for working with the constant flow agreement within solidity\\n * @dev the first set of functions are each for callAgreement()\\n * @dev the second set of functions are each for use in callAgreementWithContext()\\n */\\nlibrary CFAv1Library {\\n\\n    /**\\n     * @dev Initialization data\\n     * @param host Superfluid host for calling agreements\\n     * @param cfa Constant Flow Agreement contract\\n     */\\n    struct InitData {\\n        ISuperfluid host;\\n        IConstantFlowAgreementV1 cfa;\\n    }\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        createFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        updateFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal {\\n        deleteFlow(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperator(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperatorWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissions(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissionsWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AccountInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AmountInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantDecreaseBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantExecuteEnd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantExecuteStart\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantExecuteTransition\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantUpdateStartDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlowRateAllowanceTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlowRateInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlowTransitionNotExecutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HostInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermission\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockerFlowStartInPast\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockerFlowStartNotExecutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockerFlowTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoChanges\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotContractOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWhitelistedExecutor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ScheduleAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ScheduleInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SchedulesExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderFlowEndInPast\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderFlowEndNotExecutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderFlowTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StartAfterEnd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StartAndEndNotDefined\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum ILockingScheduler.ScheduleStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"StatusInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TasksDontExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TasksExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransitionDateInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroFee\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"AllTasksCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeFundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeFundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earlyEndCompensation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didCompensationFail\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"lockerFlow\",\"type\":\"bool\"}],\"name\":\"FlowEndExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"lockerFlow\",\"type\":\"bool\"}],\"name\":\"FlowEndFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flowDelayCompensation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"lockerFlow\",\"type\":\"bool\"}],\"name\":\"FlowStartExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"lockerFlow\",\"type\":\"bool\"}],\"name\":\"FlowStartFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FundsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FundsLockedOnCreate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FundsLockedOnUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawnOnUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GelatoFeeDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"GelatoTaskFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startLockerFlowDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"flowTransitionDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endSenderDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bufferAmount\",\"type\":\"uint256\"}],\"name\":\"LockingScheduleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedAmount\",\"type\":\"uint256\"}],\"name\":\"LockingScheduleDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startLockerFlowDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"flowTransitionDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endSenderDate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bufferAmount\",\"type\":\"uint256\"}],\"name\":\"LockingScheduleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"NoLockChanges\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ILockingSchedulerAutomationEvents.FlowAction\",\"name\":\"action\",\"type\":\"uint8\"}],\"name\":\"TaskCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ILockingSchedulerAutomationEvents.FlowAction\",\"name\":\"action\",\"type\":\"uint8\"}],\"name\":\"TaskCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EARLY_END_COMPENSATION_BUFFER_TIME\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_LOCKER_FLOW_TIME\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_SENDER_FLOW_TIME\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_TRHESHOLD_BUFFER_TIME\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROTOCOL_BUFFER_TIME\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterAgreementCreated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterAgreementTerminated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterAgreementUpdated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automate\",\"outputs\":[{\"internalType\":\"contract IAutomate\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeAgreementCreated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeAgreementTerminated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeAgreementUpdated\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"canExecuteFlowTransition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"canExecuteLockerFlowStart\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"canExecuteSenderFlowEnd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"checker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startLockerFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endSenderFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ctx\",\"type\":\"bytes\"}],\"name\":\"createLockingSchedule\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"newCtx\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"ctx\",\"type\":\"bytes\"}],\"name\":\"deleteLockingSchedule\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"newCtx\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyFeeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"executeEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"executeStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"executeTransition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gelatoExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getConfigHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashConfig\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getCurrentFlowRate\",\"outputs\":[{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExistingSchedulesCount\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"count\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getLockingSchedule\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startLockerFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flowTransitionDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endSenderFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gelatoStartSenderFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expectedSenderFlowDuration\",\"type\":\"uint32\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum ILockingScheduler.ScheduleStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct ILockingScheduler.LockingSchedule\",\"name\":\"schedule\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSingleTaskFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getTaskIds\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"startFlowId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"transitionFlowId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"endFlowId\",\"type\":\"bytes32\"}],\"internalType\":\"struct ILockingSchedulerAutomation.TaskIds\",\"name\":\"ids\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"startLockerFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"getTransitionDate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"flowTransitionDate\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"_host\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_automate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"isFlowOngoing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"}],\"name\":\"isFlowRateAllowanceEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEnough\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"isFlowRateAllowanceInScheduleEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEnough\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"}],\"name\":\"isPermissionValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"superToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startLockerFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endSenderFlowDate\",\"type\":\"uint32\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ctx\",\"type\":\"bytes\"}],\"name\":\"modifyLockingSchedule\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"newCtx\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setGelatoTaskFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LockingSchedulerAutomation", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}