{"SourceCode": "//SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\taddress private _previousOwner;\r\n\tmapping(address => bool) private manager;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor () {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t\tmanager[msg.sender] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender() || manager[_msgSender()], \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Leaves the contract without owner. It will not be possible to call\r\n\t* `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t*\r\n\t* NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t* thereby removing any functionality that is only available to the owner.\r\n\t*/\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n\r\n\tfunction setManger(address addr, bool stauts) public onlyOwner{\r\n        manager[addr] = stauts;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\t/**\r\n\t * @dev Returns the amount of tokens in existence.\r\n\t */\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the amount of tokens owned by `account`.\r\n\t */\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\t/**\r\n\t * @dev Returns the remaining number of tokens that `spender` will be\r\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n\t * zero by default.\r\n\t *\r\n\t * This value changes when {approve} or {transferFrom} are called.\r\n\t */\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n\t * that someone may use both the old and the new allowance by unfortunate\r\n\t * transaction ordering. One possible solution to mitigate this race\r\n\t * condition is to first reduce the spender's allowance to 0 and set the\r\n\t * desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n\t * allowance mechanism. `amount` is then deducted from the caller's\r\n\t * allowance.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n\t * another (`to`).\r\n\t *\r\n\t * Note that `value` may be zero.\r\n\t */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n\t * a call to {approve}. `value` is the new allowance.\r\n\t */\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n\t/**\r\n\t * @dev Returns the name of the token.\r\n\t */\r\n\tfunction name() external view returns (string memory);\r\n\r\n\t/**\r\n\t * @dev Returns the symbol of the token.\r\n\t */\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\t/**\r\n\t * @dev Returns the decimals places of the token.\r\n\t */\r\n\tfunction decimals() external view returns (uint256);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n\tmapping(address => uint256) private _balances;\r\n\r\n\tmapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n\tuint256 private _totalSupply;\r\n\r\n\tstring private _name;\r\n\tstring private _symbol;\r\n\r\n\t/**\r\n\t * @dev Sets the values for {name} and {symbol}.\r\n\t *\r\n\t * The default value of {decimals} is 18. To select a different value for\r\n\t * {decimals} you should overload it.\r\n\t *\r\n\t * All two of these values are immutable: they can only be set once during\r\n\t * construction.\r\n\t */\r\n\tconstructor(string memory name_, string memory symbol_) {\r\n\t\t_name = name_;\r\n\t\t_symbol = symbol_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the name of the token.\r\n\t */\r\n\tfunction name() public view virtual override returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the symbol of the token, usually a shorter version of the\r\n\t * name.\r\n\t */\r\n\tfunction symbol() public view virtual override returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the number of decimals used to get its user representation.\r\n\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n\t * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n\t *\r\n\t * Tokens usually opt for a value of 18, imitating the relationship between\r\n\t * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n\t * overridden;\r\n\t *\r\n\t * NOTE: This information is only used for _display_ purposes: it in\r\n\t * no way affects any of the arithmetic of the contract, including\r\n\t * {IERC20-balanceOf} and {IERC20-transfer}.\r\n\t */\r\n\tfunction decimals() public view virtual override returns (uint256) {\r\n\t\treturn 18;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-totalSupply}.\r\n\t */\r\n\tfunction totalSupply() public view virtual override returns (uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-balanceOf}.\r\n\t */\r\n\tfunction balanceOf(address account) public view virtual override returns (uint256) {\r\n\t\treturn _balances[account];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-transfer}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `recipient` cannot be the zero address.\r\n\t * - the caller must have a balance of at least `amount`.\r\n\t */\r\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n\t\t_transfer(_msgSender(), recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-allowance}.\r\n\t */\r\n\tfunction allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n\t\treturn _allowances[owner][spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-approve}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n\t\t_approve(_msgSender(), spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-transferFrom}.\r\n\t *\r\n\t * Emits an {Approval} event indicating the updated allowance. This is not\r\n\t * required by the EIP. See the note at the beginning of {ERC20}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `sender` and `recipient` cannot be the zero address.\r\n\t * - `sender` must have a balance of at least `amount`.\r\n\t * - the caller must have allowance for ``sender``'s tokens of at least\r\n\t * `amount`.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) public virtual override returns (bool) {\r\n\t\t_transfer(sender, recipient, amount);\r\n\r\n\t\tuint256 currentAllowance = _allowances[sender][_msgSender()];\r\n\t\trequire(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n\tunchecked {\r\n\t\t_approve(sender, _msgSender(), currentAllowance - amount);\r\n\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n\t *\r\n\t * This is an alternative to {approve} that can be used as a mitigation for\r\n\t * problems described in {IERC20-approve}.\r\n\t *\r\n\t * Emits an {Approval} event indicating the updated allowance.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n\t *\r\n\t * This is an alternative to {approve} that can be used as a mitigation for\r\n\t * problems described in {IERC20-approve}.\r\n\t *\r\n\t * Emits an {Approval} event indicating the updated allowance.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `spender` cannot be the zero address.\r\n\t * - `spender` must have allowance for the caller of at least\r\n\t * `subtractedValue`.\r\n\t */\r\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n\t\tuint256 currentAllowance = _allowances[_msgSender()][spender];\r\n\t\trequire(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n\tunchecked {\r\n\t\t_approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n\t *\r\n\t * This internal function is equivalent to {transfer}, and can be used to\r\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `sender` cannot be the zero address.\r\n\t * - `recipient` cannot be the zero address.\r\n\t * - `sender` must have a balance of at least `amount`.\r\n\t */\r\n\tfunction _transfer(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) internal virtual {\r\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\r\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(sender, recipient, amount);\r\n\r\n\t\tuint256 senderBalance = _balances[sender];\r\n\t\trequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n\tunchecked {\r\n\t\t_balances[sender] = senderBalance - amount;\r\n\t}\r\n\t\t_balances[recipient] += amount;\r\n\r\n\t\temit Transfer(sender, recipient, amount);\r\n\r\n\t\t_afterTokenTransfer(sender, recipient, amount);\r\n\t}\r\n\r\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n\t * the total supply.\r\n\t *\r\n\t * Emits a {Transfer} event with `from` set to the zero address.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `account` cannot be the zero address.\r\n\t */\r\n\tfunction _mint(address account, uint256 amount) internal virtual {\r\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(address(0), account, amount);\r\n\r\n\t\t_totalSupply += amount;\r\n\t\t_balances[account] += amount;\r\n\t\temit Transfer(address(0), account, amount);\r\n\r\n\t\t_afterTokenTransfer(address(0), account, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Destroys `amount` tokens from `account`, reducing the\r\n\t * total supply.\r\n\t *\r\n\t * Emits a {Transfer} event with `to` set to the zero address.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `account` cannot be the zero address.\r\n\t * - `account` must have at least `amount` tokens.\r\n\t */\r\n\tfunction _burn(address account, uint256 amount) internal virtual {\r\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(account, address(0), amount);\r\n\r\n\t\tuint256 accountBalance = _balances[account];\r\n\t\trequire(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n\tunchecked {\r\n\t\t_balances[account] = accountBalance - amount;\r\n\t}\r\n\t\t_totalSupply -= amount;\r\n\r\n\t\temit Transfer(account, address(0), amount);\r\n\r\n\t\t_afterTokenTransfer(account, address(0), amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n\t *\r\n\t * This internal function is equivalent to `approve`, and can be used to\r\n\t * e.g. set automatic allowances for certain subsystems, etc.\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `owner` cannot be the zero address.\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction _approve(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 amount\r\n\t) internal virtual {\r\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\r\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Hook that is called before any transfer of tokens. This includes\r\n\t * minting and burning.\r\n\t *\r\n\t * Calling conditions:\r\n\t *\r\n\t * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n\t * will be transferred to `to`.\r\n\t * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n\t * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t *\r\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n\t */\r\n\tfunction _beforeTokenTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) internal virtual {}\r\n\r\n\t/**\r\n\t * @dev Hook that is called after any transfer of tokens. This includes\r\n\t * minting and burning.\r\n\t *\r\n\t * Calling conditions:\r\n\t *\r\n\t * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n\t * has been transferred to `to`.\r\n\t * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n\t * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t *\r\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n\t */\r\n\tfunction _afterTokenTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) internal virtual {}\r\n}\r\n\r\nlibrary SafeMathUint {\r\n\tfunction toInt256Safe(uint256 a) internal pure returns (int256) {\r\n\t\tint256 b = int256(a);\r\n\t\trequire(b >= 0);\r\n\t\treturn b;\r\n\t}\r\n}\r\n\r\nlibrary SafeMathInt {\r\n\tfunction mul(int256 a, int256 b) internal pure returns (int256) {\r\n\t\t// Prevent overflow when multiplying INT256_MIN with -1\r\n\t\t// https://github.com/RequestNetwork/requestNetwork/issues/43\r\n\t\trequire(!(a == - 2**255 && b == -1) && !(b == - 2**255 && a == -1));\r\n\r\n\t\tint256 c = a * b;\r\n\t\trequire((b == 0) || (c / b == a));\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(int256 a, int256 b) internal pure returns (int256) {\r\n\t\t// Prevent overflow when dividing INT256_MIN by -1\r\n\t\t// https://github.com/RequestNetwork/requestNetwork/issues/43\r\n\t\trequire(!(a == - 2**255 && b == -1) && (b > 0));\r\n\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction sub(int256 a, int256 b) internal pure returns (int256) {\r\n\t\trequire((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\r\n\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(int256 a, int256 b) internal pure returns (int256) {\r\n\t\tint256 c = a + b;\r\n\t\trequire((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction toUint256Safe(int256 a) internal pure returns (uint256) {\r\n\t\trequire(a >= 0);\r\n\t\treturn uint256(a);\r\n\t}\r\n}\r\n\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\tunchecked {\r\n\t\tuint256 c = a + b;\r\n\t\tif (c < a) return (false, 0);\r\n\t\treturn (true, c);\r\n\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\tunchecked {\r\n\t\tif (b > a) return (false, 0);\r\n\t\treturn (true, a - b);\r\n\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\tunchecked {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\tif (a == 0) return (true, 0);\r\n\t\tuint256 c = a * b;\r\n\t\tif (c / a != b) return (false, 0);\r\n\t\treturn (true, c);\r\n\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\tunchecked {\r\n\t\tif (b == 0) return (false, 0);\r\n\t\treturn (true, a / b);\r\n\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\tunchecked {\r\n\t\tif (b == 0) return (false, 0);\r\n\t\treturn (true, a % b);\r\n\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a + b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a * b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {trySub}.\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\tunchecked {\r\n\t\trequire(b <= a, errorMessage);\r\n\t\treturn a - b;\r\n\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\tunchecked {\r\n\t\trequire(b > 0, errorMessage);\r\n\t\treturn a / b;\r\n\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting with custom message when dividing by zero.\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\tunchecked {\r\n\t\trequire(b > 0, errorMessage);\r\n\t\treturn a % b;\r\n\t}\r\n\t}\r\n}\r\n\r\nlibrary IterableMapping {\r\n\t// Iterable mapping from address to uint;\r\n\tstruct Map {\r\n\t\taddress[] keys;\r\n\t\tmapping(address => uint) values;\r\n\t\tmapping(address => uint) indexOf;\r\n\t\tmapping(address => bool) inserted;\r\n\t}\r\n\r\n\tfunction get(Map storage map, address key) public view returns (uint) {\r\n\t\treturn map.values[key];\r\n\t}\r\n\r\n\tfunction getIndexOfKey(Map storage map, address key) public view returns (int) {\r\n\t\tif(!map.inserted[key]) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\treturn int(map.indexOf[key]);\r\n\t}\r\n\r\n\tfunction getKeyAtIndex(Map storage map, uint index) public view returns (address) {\r\n\t\treturn map.keys[index];\r\n\t}\r\n\r\n\r\n\r\n\tfunction size(Map storage map) public view returns (uint) {\r\n\t\treturn map.keys.length;\r\n\t}\r\n\r\n\tfunction set(Map storage map, address key, uint val) public {\r\n\t\tif (map.inserted[key]) {\r\n\t\t\tmap.values[key] = val;\r\n\t\t} else {\r\n\t\t\tmap.inserted[key] = true;\r\n\t\t\tmap.values[key] = val;\r\n\t\t\tmap.indexOf[key] = map.keys.length;\r\n\t\t\tmap.keys.push(key);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction remove(Map storage map, address key) public {\r\n\t\tif (!map.inserted[key]) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tdelete map.inserted[key];\r\n\t\tdelete map.values[key];\r\n\r\n\t\tuint index = map.indexOf[key];\r\n\t\tuint lastIndex = map.keys.length - 1;\r\n\t\taddress lastKey = map.keys[lastIndex];\r\n\r\n\t\tmap.indexOf[lastKey] = index;\r\n\t\tdelete map.indexOf[key];\r\n\r\n\t\tmap.keys[index] = lastKey;\r\n\t\tmap.keys.pop();\r\n\t}\r\n}\r\n\r\ninterface DividendPayingTokenOptionalInterface {\r\n\tfunction withdrawableDividendOf(address _owner) external view returns(uint256);\r\n\tfunction withdrawnDividendOf(address _owner) external view returns(uint256);\r\n\tfunction accumulativeDividendOf(address _owner) external view returns(uint256);\r\n}\r\n\r\ninterface DividendPayingTokenInterface {\r\n\tfunction dividendOf(address _owner) external view returns(uint256);\r\n\tfunction distributeDividends() external payable;\r\n\tfunction withdrawDividend() external;\r\n\r\n\tevent DividendsDistributed(address indexed from, uint256 weiAmount);\r\n\tevent DividendWithdrawn(address indexed to, uint256 weiAmount);\r\n}\r\n\r\n/// @title Dividend-Paying Token\r\n/// @author Roger Wu (https://github.com/roger-wu)\r\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute ether\r\n///  to token holders as dividends and allows token holders to withdraw their dividends.\r\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\r\ncontract DividendPayingToken is ERC20, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMathUint for uint256;\r\n\tusing SafeMathInt for int256;\r\n\r\n\t// With `magnitude`, we can properly distribute dividends even if the amount of received ether is small.\r\n\t// For more discussion about choosing the value of `magnitude`,\r\n\t//  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\r\n\tuint256 constant internal magnitude = 2**128;\r\n\r\n\tuint256 internal magnifiedDividendPerShare;\r\n\r\n\t// About dividendCorrection:\r\n\t// If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\r\n\t//   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\r\n\t// When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\r\n\t//   `dividendOf(_user)` should not be changed,\r\n\t//   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\r\n\t// To keep the `dividendOf(_user)` unchanged, we add a correction term:\r\n\t//   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\r\n\t//   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\r\n\t//   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\r\n\t// So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\r\n\tmapping(address => int256) internal magnifiedDividendCorrections;\r\n\tmapping(address => uint256) internal withdrawnDividends;\r\n\r\n\tuint256 public totalDividendsDistributed;\r\n\taddress public HDD;\r\n\r\n\tconstructor(string memory _name, string memory _symbol)  ERC20(_name, _symbol) {\r\n\r\n\t}\r\n\r\n\t/// @dev Distributes dividends whenever ether is paid to this contract.\r\n\treceive() external payable {\r\n\t\tdistributeDividends();\r\n\t}\r\n\r\n\t/// @notice Distributes ether to token holders as dividends.\r\n\t/// @dev It reverts if the total supply of tokens is 0.\r\n\t/// It emits the `DividendsDistributed` event if the amount of received ether is greater than 0.\r\n\t/// About undistributed ether:\r\n\t///   In each distribution, there is a small amount of ether not distributed,\r\n\t///     the magnified amount of which is\r\n\t///     `(msg.value * magnitude) % totalSupply()`.\r\n\t///   With a well-chosen `magnitude`, the amount of undistributed ether\r\n\t///     (de-magnified) in a distribution can be less than 1 wei.\r\n\t///   We can actually keep track of the undistributed ether in a distribution\r\n\t///     and try to distribute it in the next distribution,\r\n\t///     but keeping track of such data on-chain costs much more than\r\n\t///     the saved ether, so we don't do that.\r\n\r\n\r\n\tfunction distributeDividends() public override payable {\r\n\t\t// require(totalSupply() > 0);\r\n\r\n\t\t// if (msg.value > 0) {\r\n\t\t//     magnifiedDividendPerShare = magnifiedDividendPerShare.add(\r\n\t\t//         (msg.value).mul(magnitude) / totalSupply()\r\n\t\t//     );\r\n\t\t//     emit DividendsDistributed(msg.sender, msg.value);\r\n\r\n\t\t//     totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\r\n\t\t// }\r\n\t}\r\n\t\r\n\tfunction distributeDividends_HDD(uint256 _amount) public{\r\n\t\trequire(msg.sender == HDD);\r\n\t\trequire(totalSupply() > 0);\r\n\r\n\t\tif (_amount > 0) {\r\n\t\t\tmagnifiedDividendPerShare = magnifiedDividendPerShare.add(\r\n\t\t\t\t(_amount).mul(magnitude) / totalSupply()\r\n\t\t\t);\r\n\t\t\temit DividendsDistributed(msg.sender, _amount);\r\n\r\n\t\t\ttotalDividendsDistributed = totalDividendsDistributed.add(_amount);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Withdraws the ether distributed to the sender.\r\n\t/// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n\tfunction withdrawDividend() public virtual override {\r\n\t\t_withdrawDividendOfUser(msg.sender);\r\n\t}\r\n\r\n\t/// @notice Withdraws the ether distributed to the sender.\r\n\t/// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n\tfunction _withdrawDividendOfUser(address user) internal returns (uint256) {\r\n\t\tuint256 _withdrawableDividend = withdrawableDividendOf(user);\r\n\t\tif (_withdrawableDividend > 0) {\r\n\t\t\twithdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\r\n\t\t\temit DividendWithdrawn(user, _withdrawableDividend);\r\n\t\t\t//(bool success,) = user.call{value: _withdrawableDividend, gas: 3000}(\"\");\r\n\t\t\t \r\n\t\t\t(bool success, bytes memory data) = HDD.call(abi.encodeWithSelector(0xa9059cbb, user, _withdrawableDividend));\r\n\t\t\tif(success && (data.length == 0 || abi.decode(data, (bool)))){\r\n\t\t\t\r\n\t\t\t\twithdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\treturn _withdrawableDividend;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\r\n\t/// @notice View the amount of dividend in wei that an address can withdraw.\r\n\t/// @param _owner The address of a token holder.\r\n\t/// @return The amount of dividend in wei that `_owner` can withdraw.\r\n\tfunction dividendOf(address _owner) public view override returns(uint256) {\r\n\t\treturn withdrawableDividendOf(_owner);\r\n\t}\r\n\r\n\t/// @notice View the amount of dividend in wei that an address can withdraw.\r\n\t/// @param _owner The address of a token holder.\r\n\t/// @return The amount of dividend in wei that `_owner` can withdraw.\r\n\tfunction withdrawableDividendOf(address _owner) public view override returns(uint256) {\r\n\t\treturn accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\r\n\t}\r\n\r\n\t/// @notice View the amount of dividend in wei that an address has withdrawn.\r\n\t/// @param _owner The address of a token holder.\r\n\t/// @return The amount of dividend in wei that `_owner` has withdrawn.\r\n\tfunction withdrawnDividendOf(address _owner) public view override returns(uint256) {\r\n\t\treturn withdrawnDividends[_owner];\r\n\t}\r\n\r\n\r\n\t/// @notice View the amount of dividend in wei that an address has earned in total.\r\n\t/// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\r\n\t/// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\r\n\t/// @param _owner The address of a token holder.\r\n\t/// @return The amount of dividend in wei that `_owner` has earned in total.\r\n\tfunction accumulativeDividendOf(address _owner) public view override returns(uint256) {\r\n\t\treturn magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\r\n\t\t.add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\r\n\t}\r\n\r\n\t/// @dev Internal function that transfer tokens from one address to another.\r\n\t/// Update magnifiedDividendCorrections to keep dividends unchanged.\r\n\t/// @param from The address to transfer from.\r\n\t/// @param to The address to transfer to.\r\n\t/// @param value The amount to be transferred.\r\n\tfunction _transfer(address from, address to, uint256 value) internal virtual override {\r\n\t\trequire(false);\r\n\r\n\t\tint256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\r\n\t\tmagnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);\r\n\t\tmagnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);\r\n\t}\r\n\r\n\t/// @dev Internal function that mints tokens to an account.\r\n\t/// Update magnifiedDividendCorrections to keep dividends unchanged.\r\n\t/// @param account The account that will receive the created tokens.\r\n\t/// @param value The amount that will be created.\r\n\tfunction _mint(address account, uint256 value) internal override {\r\n\t\tsuper._mint(account, value);\r\n\r\n\t\tmagnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n\t\t.sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n\t}\r\n\r\n\t/// @dev Internal function that burns an amount of the token of a given account.\r\n\t/// Update magnifiedDividendCorrections to keep dividends unchanged.\r\n\t/// @param account The account whose tokens will be burnt.\r\n\t/// @param value The amount that will be burnt.\r\n\tfunction _burn(address account, uint256 value) internal override {\r\n\t\tsuper._burn(account, value);\r\n\r\n\t\tmagnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n\t\t.add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n\t}\r\n\r\n\tfunction _setBalance(address account, uint256 newBalance) internal {\r\n\t\tuint256 currentBalance = balanceOf(account);\r\n\r\n\t\tif(newBalance > currentBalance) {\r\n\t\t\tuint256 mintAmount = newBalance.sub(currentBalance);\r\n\t\t\t_mint(account, mintAmount);\r\n\t\t} else if(newBalance < currentBalance) {\r\n\t\t\tuint256 burnAmount = currentBalance.sub(newBalance);\r\n\t\t\t_burn(account, burnAmount);\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract HDDDividendTracker is DividendPayingToken, Ownable {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMathInt for int256;\r\n\tusing IterableMapping for IterableMapping.Map;\r\n\r\n\tIterableMapping.Map private tokenHoldersMap;\r\n\tuint256 public lastProcessedIndex;\r\n\r\n\tmapping (address => bool) public excludedFromDividends;\r\n\r\n\tmapping (address => uint256) public lastClaimTimes;\r\n\r\n\tuint256 public claimWait;\r\n\tuint256 public minimumTokenBalanceForDividends;\r\n\r\n\tevent ExcludeFromDividends(address indexed account);\r\n\tevent ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\r\n\tevent UpdateDistributionBalanceOfUser(address account, uint256 newBalance);\r\n\r\n\tevent Claim(address indexed account, uint256 amount, bool indexed automatic);\r\n\r\n\tconstructor() DividendPayingToken(\"HDD_DividendTracker\", \"HDD_DividendTracker\") {\r\n\t\tclaimWait = 0;\r\n\t\tminimumTokenBalanceForDividends = 1; //must hold 1+ \r\n\t}\r\n\t\r\n\r\n\t\r\n\tfunction setHDD(address _HDD) external onlyOwner{\r\n\t\tHDD = _HDD;\r\n\t}\r\n\r\n\tfunction _transfer(address, address, uint256) internal pure override {\r\n\t\trequire(false, \"HDDDividendTracker: No transfers allowed\");\r\n\t}\r\n\r\n\tfunction withdrawDividend() public pure override {\r\n\t\trequire(false, \"HDDDividendTracker: withdrawDividend disabled. Use the 'claim' function on the main HDD contract.\");\r\n\t}\r\n\r\n\tfunction excludeFromDividends(address account) external onlyOwner {\r\n\t\trequire(!excludedFromDividends[account]);\r\n\t\texcludedFromDividends[account] = true;\r\n\r\n\t\t_setBalance(account, 0);\r\n\t\ttokenHoldersMap.remove(account);\r\n\r\n\t\temit ExcludeFromDividends(account);\r\n\t}\r\n\r\n\tfunction updateClaimWait(uint256 newClaimWait) external onlyOwner {\r\n\t\temit ClaimWaitUpdated(newClaimWait, claimWait);\r\n\t\tclaimWait = newClaimWait;\r\n\t}\r\n\r\n\tfunction updateMinimumTokenBalanceForDividends(uint256 newTokenBalance) external onlyOwner {\r\n\t\temit ClaimWaitUpdated(newTokenBalance, minimumTokenBalanceForDividends);\r\n\t\tminimumTokenBalanceForDividends = newTokenBalance;\r\n\t}\r\n\r\n\tfunction getLastProcessedIndex() external view returns(uint256) {\r\n\t\treturn lastProcessedIndex;\r\n\t}\r\n\r\n\tfunction getNumberOfTokenHolders() external view returns(uint256) {\r\n\t\treturn tokenHoldersMap.keys.length;\r\n\t}\r\n\r\n\tfunction getAccount(address _account) public view returns (\r\n\t\taddress account,\r\n\t\tint256 index,\r\n\t\tint256 iterationsUntilProcessed,\r\n\t\tuint256 withdrawableDividends,\r\n\t\tuint256 totalDividends,\r\n\t\tuint256 lastClaimTime,\r\n\t\tuint256 nextClaimTime,\r\n\t\tuint256 secondsUntilAutoClaimAvailable) {\r\n\t\taccount = _account;\r\n\r\n\t\tindex = tokenHoldersMap.getIndexOfKey(account);\r\n\r\n\t\titerationsUntilProcessed = -1;\r\n\r\n\t\tif(index >= 0) {\r\n\t\t\tif(uint256(index) > lastProcessedIndex) {\r\n\t\t\t\titerationsUntilProcessed = index.sub(int256(lastProcessedIndex));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tuint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ?\r\n\t\t\t\ttokenHoldersMap.keys.length.sub(lastProcessedIndex) :\r\n\t\t\t\t0;\r\n\r\n\t\t\t\titerationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\twithdrawableDividends = withdrawableDividendOf(account);\r\n\t\ttotalDividends = accumulativeDividendOf(account);\r\n\r\n\t\tlastClaimTime = lastClaimTimes[account];\r\n\r\n\t\tnextClaimTime = lastClaimTime > 0 ?\r\n\t\tlastClaimTime.add(claimWait) :\r\n\t\t0;\r\n\r\n\t\tsecondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ?\r\n\t\tnextClaimTime.sub(block.timestamp) :\r\n\t\t0;\r\n\t}\r\n\r\n\tfunction getAccountAtIndex(uint256 index)\r\n\tpublic view returns (\r\n\t\taddress,\r\n\t\tint256,\r\n\t\tint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256) {\r\n\t\tif(index >= tokenHoldersMap.size()) {\r\n\t\t\treturn (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\r\n\t\t}\r\n\r\n\t\taddress account = tokenHoldersMap.getKeyAtIndex(index);\r\n\r\n\t\treturn getAccount(account);\r\n\t}\r\n\r\n\tfunction canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\r\n\t\tif(lastClaimTime > block.timestamp)  {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn block.timestamp.sub(lastClaimTime) >= claimWait;\r\n\t}\r\n\r\n\tfunction setBalance(address account, uint256 newBalance) external onlyOwner {\r\n\t\tif(excludedFromDividends[account]) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(newBalance >= minimumTokenBalanceForDividends) {\r\n\t\t\t_setBalance(account, newBalance);\r\n\t\t\ttokenHoldersMap.set(account, newBalance);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t_setBalance(account, 0);\r\n\t\t\ttokenHoldersMap.remove(account);\r\n\t\t}\r\n\r\n\t\temit UpdateDistributionBalanceOfUser(account, newBalance);\r\n\r\n\t\tprocessAccount(account, true);\r\n\t}\r\n\r\n\tfunction process(uint256 gas) public returns (uint256, uint256, uint256) {\r\n\t\tuint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\r\n\r\n\t\tif(numberOfTokenHolders == 0) {\r\n\t\t\treturn (0, 0, lastProcessedIndex);\r\n\t\t}\r\n\r\n\t\tuint256 _lastProcessedIndex = lastProcessedIndex;\r\n\r\n\t\tuint256 gasUsed = 0;\r\n\r\n\t\tuint256 gasLeft = gasleft();\r\n\r\n\t\tuint256 iterations = 0;\r\n\t\tuint256 claims = 0;\r\n\r\n\t\twhile(gasUsed < gas && iterations < numberOfTokenHolders) {\r\n\t\t\t_lastProcessedIndex++;\r\n\r\n\t\t\tif(_lastProcessedIndex >= tokenHoldersMap.keys.length) {\r\n\t\t\t\t_lastProcessedIndex = 0;\r\n\t\t\t}\r\n\r\n\t\t\taddress account = tokenHoldersMap.keys[_lastProcessedIndex];\r\n\r\n\t\t\tif(canAutoClaim(lastClaimTimes[account])) {\r\n\t\t\t\tif(processAccount(account, true)) {\r\n\t\t\t\t\tclaims++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\titerations++;\r\n\r\n\t\t\tuint256 newGasLeft = gasleft();\r\n\r\n\t\t\tif(gasLeft > newGasLeft) {\r\n\t\t\t\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\r\n\t\t\t}\r\n\r\n\t\t\tgasLeft = newGasLeft;\r\n\t\t}\r\n\r\n\t\tlastProcessedIndex = _lastProcessedIndex;\r\n\r\n\t\treturn (iterations, claims, lastProcessedIndex);\r\n\t}\r\n\r\n\tfunction processAccount(address account, bool automatic) public onlyOwner returns (bool) {\r\n\t\tuint256 amount = _withdrawDividendOfUser(account);\r\n\r\n\t\tif(amount > 0) {\r\n\t\t\tlastClaimTimes[account] = block.timestamp;\r\n\t\t\temit Claim(account, amount, automatic);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tfunction withdrawStuckTokens(address _token, uint256 _amount) public onlyOwner {\r\n\t\tIERC20(_token).transfer(msg.sender, _amount);\r\n\t}\r\n\t\r\n\tfunction withdrawStuckBNB(address payable recipient) public onlyOwner {\r\n\t\trecipient.transfer(address(this).balance);\r\n\t}\r\n\t\r\n}\r\n\r\ninterface IPancakeFactory {\r\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n\tfunction feeTo() external view returns (address);\r\n\tfunction feeToSetter() external view returns (address);\r\n\r\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\tfunction allPairs(uint) external view returns (address pair);\r\n\tfunction allPairsLength() external view returns (uint);\r\n\r\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n\tfunction setFeeTo(address) external;\r\n\tfunction setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IPancakePair {\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\r\n\tfunction name() external pure returns (string memory);\r\n\tfunction symbol() external pure returns (string memory);\r\n\tfunction decimals() external pure returns (uint256);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\r\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n\tevent Swap(\r\n\t\taddress indexed sender,\r\n\t\tuint amount0In,\r\n\t\tuint amount1In,\r\n\t\tuint amount0Out,\r\n\t\tuint amount1Out,\r\n\t\taddress indexed to\r\n\t);\r\n\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\tfunction factory() external view returns (address);\r\n\tfunction token0() external view returns (address);\r\n\tfunction token1() external view returns (address);\r\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\tfunction price0CumulativeLast() external view returns (uint);\r\n\tfunction price1CumulativeLast() external view returns (uint);\r\n\tfunction kLast() external view returns (uint);\r\n\r\n\tfunction mint(address to) external returns (uint liquidity);\r\n\tfunction burn(address to) external returns (uint amount0, uint amount1);\r\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\r\n\tfunction initialize(address, address) external;\r\n}\r\n\r\ninterface IPancakeRouter01 {\r\n\tfunction factory() external pure returns (address);\r\n\tfunction WETH() external pure returns (address);\r\n\r\n\tfunction addLiquidity(\r\n\t\taddress tokenA,\r\n\t\taddress tokenB,\r\n\t\tuint amountADesired,\r\n\t\tuint amountBDesired,\r\n\t\tuint amountAMin,\r\n\t\tuint amountBMin,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint amountA, uint amountB, uint liquidity);\r\n\tfunction addLiquidityETH(\r\n\t\taddress token,\r\n\t\tuint amountTokenDesired,\r\n\t\tuint amountTokenMin,\r\n\t\tuint amountETHMin,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\tfunction removeLiquidity(\r\n\t\taddress tokenA,\r\n\t\taddress tokenB,\r\n\t\tuint liquidity,\r\n\t\tuint amountAMin,\r\n\t\tuint amountBMin,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint amountA, uint amountB);\r\n\tfunction removeLiquidityETH(\r\n\t\taddress token,\r\n\t\tuint liquidity,\r\n\t\tuint amountTokenMin,\r\n\t\tuint amountETHMin,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint amountToken, uint amountETH);\r\n\tfunction removeLiquidityWithPermit(\r\n\t\taddress tokenA,\r\n\t\taddress tokenB,\r\n\t\tuint liquidity,\r\n\t\tuint amountAMin,\r\n\t\tuint amountBMin,\r\n\t\taddress to,\r\n\t\tuint deadline,\r\n\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t) external returns (uint amountA, uint amountB);\r\n\tfunction removeLiquidityETHWithPermit(\r\n\t\taddress token,\r\n\t\tuint liquidity,\r\n\t\tuint amountTokenMin,\r\n\t\tuint amountETHMin,\r\n\t\taddress to,\r\n\t\tuint deadline,\r\n\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t) external returns (uint amountToken, uint amountETH);\r\n\tfunction swapExactTokensForTokens(\r\n\t\tuint amountIn,\r\n\t\tuint amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint[] memory amounts);\r\n\tfunction swapTokensForExactTokens(\r\n\t\tuint amountOut,\r\n\t\tuint amountInMax,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint[] memory amounts);\r\n\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n\texternal\r\n\tpayable\r\n\treturns (uint[] memory amounts);\r\n\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n\texternal\r\n\treturns (uint[] memory amounts);\r\n\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n\texternal\r\n\treturns (uint[] memory amounts);\r\n\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n\texternal\r\n\tpayable\r\n\treturns (uint[] memory amounts);\r\n\r\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\r\n\t\taddress token,\r\n\t\tuint liquidity,\r\n\t\tuint amountTokenMin,\r\n\t\tuint amountETHMin,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint amountETH);\r\n\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n\t\taddress token,\r\n\t\tuint liquidity,\r\n\t\tuint amountTokenMin,\r\n\t\tuint amountETHMin,\r\n\t\taddress to,\r\n\t\tuint deadline,\r\n\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t) external returns (uint amountETH);\r\n\r\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n\t\tuint amountIn,\r\n\t\tuint amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external;\r\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n\t\tuint amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external payable;\r\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n\t\tuint amountIn,\r\n\t\tuint amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external;\r\n}\r\n\r\ncontract Token is ERC20, Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tIPancakeRouter02 public pancakeRouter;\r\n\taddress public pancakePair;\r\n\taddress public usdt;\r\n\r\n\tHDDDividendTracker public dividendTracker;\r\n\r\n\r\n\tuint256 public maxTransactionAmount;   \r\n\tuint256 public maxHoldingAmount;   \r\n \r\n\taddress public burnAddress = 0x000000000000000000000000000000000000dEaD;\r\n\t\r\n\tuint256 public buyDividendFee = 8;      \r\n\tuint256 public sellBurnFee = 15;    \r\n\tuint256 public transferBurnFee = 15;    \r\n  \tuint256 public burntAmount;\r\n\r\n\r\n\t// use by default 300,000 gas to process auto-claiming dividends\r\n\tuint256 public gasForProcessing = 300000;    \r\n    address public lastTransferUser;\r\n\r\n\t/********* TX LIMITS *********/\r\n\r\n\tmapping (address => uint256) public accountLastPeriodSellVolume;\r\n\tuint256 public restrictionPeriod = 1 seconds;    \r\n\tstruct Sell {\r\n\t\tuint256 time;\r\n\t\tuint256 amount;\r\n\t}\r\n\tmapping (address => Sell[]) public accountSells;\r\n\r\n\t/****************/\r\n\r\n\r\n\tbool public tradingEnabled = true;   \r\n\tevent UpdateSwappingStatus(bool status);\r\n\tevent UpdateTradingStatus(bool status);\r\n\r\n\t// exlcude from fees and max transaction amount\r\n\tmapping (address => bool) private _isExcludedFromFees;\r\n\tmapping (address => bool) private _isExcludedFromPeriodLimit;\r\n\tmapping (address => bool) private _isExcludedFromMaxTxLimit;\r\n\tmapping (address => bool) private _isExcludedFromMaxHoldLimit;\r\n\r\n\t// addresses that can make transfers before trading is enabled\r\n\tmapping (address => bool) private canTransferBeforeTradingIsEnabled;\r\n\t\r\n\tmapping (address => bool) public isBlackList;\r\n\r\n\tevent UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);\r\n\tevent UpdateWallets(address oldMarketing, address newMarketing);\r\n\tevent UpdatePancakeRouter(address indexed newAddress, address indexed oldAddress);\r\n\r\n\tevent ExcludeFromFees(address indexed account, bool isExcluded);\r\n\tevent ExcludeFromPeriodLimit(address indexed account, bool isExcluded);\r\n\tevent ExcludeFromMaxTxLimit(address indexed account, bool isExcluded);\r\n\tevent ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\r\n\r\n\tevent GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\r\n\r\n\tevent SetBuyFees(uint256 MarketingFee, uint256 DividendFee);\r\n\r\n\tevent SetSellFees(uint256 SellMarketingFee, uint256 SellDividendFee);\r\n\tevent SetRestrictionPeriod(uint256 OldPeriod, uint256 NewPeriod);\r\n\tevent SetMaxTxAmount(uint256 OldPercent, uint256 NewPercent);\r\n\r\n\tevent SetMaxHoldingAmount(uint256 OldPercent, uint256 NewPercent);\r\n\r\n\t// events for last sell\r\n\tevent UpdateaAccountLastPeriodSellVolume(uint256 oldValue, uint256 newValue);\r\n\tevent AddLastPeriodSellInfo(uint256 timestamp, uint256 amount);\r\n\r\n\r\n\tevent CalculatedCakeForEachRecipient(uint256 forDividends);\r\n\tevent ErrorInProcess(address msgSender);\r\n\tevent SwapAndSendTo(\r\n\t\tuint256 amount,\r\n\t\tstring to\r\n\t);\r\n\r\n\tevent ProcessedDividendTracker(\r\n\t\tuint256 iterations,\r\n\t\tuint256 claims,\r\n\t\tuint256 lastProcessedIndex,\r\n\t\tbool indexed automatic,\r\n\t\tuint256 gas,\r\n\t\taddress indexed processor\r\n\t);\r\n\r\n\tconstructor() ERC20(\"HydroDAO\", \"HDD\") {\r\n\t\tdividendTracker = new HDDDividendTracker();\r\n\t\tusdt = 0x55d398326f99059fF775485246999027B3197955;   // bscmainnet\r\n\t\tupdatePancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);  // bscmainnet\r\n\r\n\t\t\r\n\t\t// exclude from receiving dividends\r\n\t\tdividendTracker.excludeFromDividends(address(dividendTracker));\r\n\t\tdividendTracker.excludeFromDividends(address(this));\r\n\t\tdividendTracker.excludeFromDividends(address(0));\r\n\r\n\t\tdividendTracker.setHDD(address(this));\r\n\t\t\r\n\t\t_isExcludedFromMaxHoldLimit[address(0)] = true;\r\n\r\n\t\t\r\n\t\texcludeFromAllLimits(owner(), true);\r\n\t\texcludeFromAllLimits(address(this), true);\r\n\r\n\t\t\r\n\t\tcanTransferBeforeTradingIsEnabled[owner()] = true;\r\n\t\t\r\n\t\t\r\n\t\r\n\r\n\t\t_mint(msg.sender, 531441000 * (10**decimals()));\r\n\t\t\r\n\t\tmaxTransactionAmount = totalSupply();\r\n\t\tmaxHoldingAmount = totalSupply();\r\n\t\t\r\n\t}\r\n\tfunction updatePancakeRouter(address newAddress) public onlyOwner {\r\n\t\trequire(newAddress != address(pancakeRouter), \"HDD: The router already has that address\");\r\n\t\temit UpdatePancakeRouter(newAddress, address(pancakeRouter));\r\n\t\tpancakeRouter = IPancakeRouter02(newAddress);\r\n\t\taddress _pancakePair = IPancakeFactory(pancakeRouter.factory())\r\n\t\t.createPair(address(this), address(usdt));\r\n\t\tpancakePair = _pancakePair;\r\n\r\n\t\tdividendTracker.excludeFromDividends(address(pancakeRouter));\r\n\t\tdividendTracker.excludeFromDividends(pancakePair);\r\n\r\n\t\texcludeFromAllLimits(newAddress, true);\r\n\r\n\t\t_isExcludedFromPeriodLimit[pancakePair] = true;\r\n\t\t_isExcludedFromMaxHoldLimit[pancakePair] = true;\r\n\r\n\t}\r\n\r\n\treceive() external payable {\r\n\t}\r\n\r\n\tfunction excludeFromAllLimits(address account, bool status) public onlyOwner {\r\n\t\t_isExcludedFromFees[account] = status;\r\n\t\t_isExcludedFromMaxTxLimit[account] = status;\r\n\t\t_isExcludedFromPeriodLimit[account] = status;\r\n\t\t_isExcludedFromMaxHoldLimit[account] = status;\r\n\t}\r\n\r\n\r\n\r\n\r\n\tfunction setMaxTxAmount(uint256 amount) external onlyOwner {\r\n\t\temit SetMaxTxAmount(maxTransactionAmount, amount);\r\n\t\tmaxTransactionAmount = amount;\r\n\t}\r\n\r\n\tfunction setMaxHoldingAmount(uint256 amount)  external onlyOwner {\r\n\t\temit SetMaxHoldingAmount(maxHoldingAmount, amount);\r\n\t\tmaxHoldingAmount = amount;\r\n\t}\r\n\r\n\tfunction setRestrictionPeriod(uint256 _newPeriodSeconds)  external onlyOwner {\r\n\t\temit SetRestrictionPeriod(restrictionPeriod, _newPeriodSeconds);\r\n\t\trestrictionPeriod = _newPeriodSeconds*1 seconds;\r\n\t}\r\n\r\n\tfunction getAccountPeriodSellVolume(address account) public returns(uint256) {\r\n\t\tuint256 offset;\r\n\t\tuint256 newVolume = accountLastPeriodSellVolume[account];\r\n\r\n\t\tfor (uint256 i = 0; i < accountSells[account].length; i++) {\r\n\t\t\tif (block.timestamp.sub(accountSells[account][i].time) <= restrictionPeriod) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (newVolume > 0) {\r\n\t\t\t\tnewVolume = newVolume.sub(accountSells[account][i].amount);\r\n\t\t\t\toffset++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (offset > 0) {\r\n\t\t\tremoveAccSells(account, offset);\r\n\t\t}\r\n\r\n\t\tif (accountLastPeriodSellVolume[account] != newVolume) {\r\n\t\t\temit UpdateaAccountLastPeriodSellVolume(accountLastPeriodSellVolume[account], newVolume);\r\n\t\t\taccountLastPeriodSellVolume[account] = newVolume;\r\n\t\t}\r\n\r\n\t\treturn newVolume;\r\n\t}\r\n\r\n\tfunction removeAccSells(address account, uint256 offset) private {\r\n\t\tfor (uint256 i = 0; i < accountSells[account].length-offset; i++) {\r\n\t\t\taccountSells[account][i] = accountSells[account][i+offset];\r\n\t\t}\r\n\t\tfor (uint256 i = 0; i < offset; i++) {\r\n\t\t\taccountSells[account].pop();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getAccountSells (address account, uint256 i) public view returns (uint256, uint256) {\r\n\t\treturn (accountSells[account][i].time, accountSells[account][i].amount);\r\n\t}\r\n\r\n\tfunction setBuyDividendFee(uint256 _buyDividendFee)  external onlyOwner {\r\n\t\tbuyDividendFee = _buyDividendFee;\r\n\t\t\r\n\t}\r\n\r\n\tfunction setSellBurnFee( uint256 _sellBurnFee)  external onlyOwner {\t\r\n\t\tsellBurnFee = _sellBurnFee;\r\n\t\t\r\n\t}\r\n\r\n\tfunction setTransferBurnFee( uint256 _transferBurnFee)  external onlyOwner {\t\r\n\t\ttransferBurnFee = _transferBurnFee;\r\n\t\t\r\n\t}\r\n\r\n\tfunction setCanTransferBeforeTradingIsEnabled(address account, bool status) external onlyOwner {\r\n\t\tcanTransferBeforeTradingIsEnabled[account] = status;\r\n\t}\r\n\tfunction excludeFromDividends(address account) external onlyOwner {\r\n\t\tdividendTracker.excludeFromDividends(account);\r\n\t}\r\n\r\n\tfunction isExcludedFromDividends(address account) external view returns (bool){\r\n\t\treturn dividendTracker.excludedFromDividends(account);\r\n\t}\r\n\r\n\tfunction updateDividendTracker(address newAddress) public onlyOwner {\r\n\t\trequire(newAddress != address(dividendTracker), \"HDD: The dividend tracker already has that address\");\r\n\r\n\t\tHDDDividendTracker newDividendTracker = HDDDividendTracker(payable(newAddress));\r\n\r\n\t\trequire(newDividendTracker.owner() == address(this), \"HDD: The new dividend tracker must be owned by the HDD token contract\");\r\n\r\n\t\tnewDividendTracker.excludeFromDividends(address(newDividendTracker));\r\n\t\tnewDividendTracker.excludeFromDividends(address(this));\r\n\t\tnewDividendTracker.excludeFromDividends(address(pancakeRouter));\r\n\r\n\t\temit UpdateDividendTracker(newAddress, address(dividendTracker));\r\n\r\n\t\tdividendTracker = newDividendTracker;\r\n\t}\r\n\r\n\tfunction excludeFromFees(address account, bool excluded) public onlyOwner {\r\n\t\trequire(_isExcludedFromFees[account] != excluded, \"HDD: Account is already the value of 'excluded'\");\r\n\t\t_isExcludedFromFees[account] = excluded;\r\n\r\n\t\temit ExcludeFromFees(account, excluded);\r\n\t}\r\n\r\n\tfunction excludeFromPeriodLimit(address account, bool excluded) public onlyOwner {\r\n\t\trequire(_isExcludedFromPeriodLimit[account] != excluded, \"HDD: Account is already the value of 'excluded'\");\r\n\t\t_isExcludedFromPeriodLimit[account] = excluded;\r\n\r\n\t\temit ExcludeFromPeriodLimit(account, excluded);\r\n\t}\r\n\r\n\tfunction excludeFromMaxTxLimit(address account, bool excluded) public onlyOwner {\r\n\t\trequire(_isExcludedFromMaxTxLimit[account] != excluded, \"HDD: Account is already the value of 'excluded'\");\r\n\t\t_isExcludedFromMaxTxLimit[account] = excluded;\r\n\r\n\t\temit ExcludeFromMaxTxLimit(account, excluded);\r\n\t}\r\n\r\n\tfunction excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\r\n\t\tfor(uint256 i = 0; i < accounts.length; i++) {\r\n\t\t\t_isExcludedFromFees[accounts[i]] = excluded;\r\n\t\t}\r\n\r\n\t\temit ExcludeMultipleAccountsFromFees(accounts, excluded);\r\n\t}\r\n\r\n\tfunction updateGasForProcessing(uint256 newValue) public onlyOwner {\r\n\t\trequire(newValue >= 200000 && newValue <= 500000, \"HDD: gasForProcessing must be between 200,000 and 500,000\");\r\n\t\trequire(newValue != gasForProcessing, \"HDD: Cannot update gasForProcessing to same value\");\r\n\t\temit GasForProcessingUpdated(newValue, gasForProcessing);\r\n\t\tgasForProcessing = newValue;\r\n\t}\r\n\r\n\tfunction updateClaimWait(uint256 claimWait) external onlyOwner {\r\n\t\tdividendTracker.updateClaimWait(claimWait);\r\n\t}\r\n\r\n\tfunction updateMinimumTokenBalanceForDividends(uint256 newTokenBalance) external onlyOwner {\r\n\t\tdividendTracker.updateMinimumTokenBalanceForDividends(newTokenBalance);\r\n\t}\r\n\r\n\tfunction getClaimWait() external view returns(uint256) {\r\n\t\treturn dividendTracker.claimWait();\r\n\t}\r\n\r\n\tfunction getTotalDividendsDistributed() external view returns (uint256) {\r\n\t\treturn dividendTracker.totalDividendsDistributed();\r\n\t}\r\n\r\n\tfunction isExcludedFromFees(address account) public view returns(bool) {\r\n\t\treturn _isExcludedFromFees[account];\r\n\t}\r\n\r\n\tfunction isExcludedFromMaxTxLimit(address account) public view returns(bool) {\r\n\t\treturn _isExcludedFromMaxTxLimit[account];\r\n\t}\r\n\r\n\tfunction isExcludedFromMaxHoldLimit(address account) public view returns(bool) {\r\n\t\treturn _isExcludedFromMaxHoldLimit[account];\r\n\t}\r\n\r\n\tfunction isExcludedFromPeriodLimit(address account) public view returns(bool) {\r\n\t\treturn _isExcludedFromPeriodLimit[account];\r\n\t}\r\n\r\n\tfunction withdrawableDividendOf(address account) public view returns(uint256) {\r\n\t\treturn dividendTracker.withdrawableDividendOf(account);\r\n\t}\r\n\r\n\tfunction dividendTokenBalanceOf(address account) public view returns (uint256) {\r\n\t\treturn dividendTracker.balanceOf(account);\r\n\t}\r\n\r\n\tfunction getAccountDividendsInfo(address account)\r\n\texternal view returns (\r\n\t\taddress,\r\n\t\tint256,\r\n\t\tint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256) {\r\n\t\treturn dividendTracker.getAccount(account);\r\n\t}\r\n\r\n\tfunction getAccountDividendsInfoAtIndex(uint256 index)\r\n\texternal view returns (\r\n\t\taddress,\r\n\t\tint256,\r\n\t\tint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint256) {\r\n\t\treturn dividendTracker.getAccountAtIndex(index);\r\n\t}\r\n\r\n\tfunction processDividendTracker(uint256 gas) external {\r\n\t\t(uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\r\n\t\temit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\r\n\t}\r\n\r\n\tfunction claim() external {\r\n\t\tdividendTracker.processAccount(payable(msg.sender), false);\r\n\t}\r\n\r\n\tfunction getLastProcessedIndex() external view returns(uint256) {\r\n\t\treturn dividendTracker.getLastProcessedIndex();\r\n\t}\r\n\r\n\tfunction getNumberOfDividendTokenHolders() external view returns(uint256) {\r\n\t\treturn dividendTracker.getNumberOfTokenHolders();\r\n\t}\r\n\r\n\r\n\tfunction setTradingIsEnabled(bool status) external onlyOwner {\r\n\t\ttradingEnabled = status;\r\n\t\temit UpdateTradingStatus(status);\r\n\t}\r\n\t\r\n\tfunction setBlackList(address _addr,bool _status)public onlyOwner{\r\n\t\tisBlackList[_addr] = _status;\r\n\t}\r\n\t\r\n  \r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) internal override {\r\n\t\trequire(from != address(0), \"ERC20: transfer from the zero address\");\r\n\t\trequire(to != address(0), \"ERC20: transfer to the zero address\");\r\n\t\trequire(!isBlackList[from],\"ERC20: transfer from the BlackList\");\r\n\r\n\t\tif (!_isExcludedFromPeriodLimit[from]) {\r\n\t\t\taccountLastPeriodSellVolume[from] = accountLastPeriodSellVolume[from].add(amount);\r\n\t\t\tSell memory sell;\r\n\t\t\tsell.amount = amount;\r\n\t\t\tsell.time = block.timestamp;\r\n\t\t\taccountSells[from].push(sell);\r\n\t\t\temit AddLastPeriodSellInfo(sell.time, sell.amount);\r\n\t\t}\r\n\r\n\r\n\t\tif(!tradingEnabled) {\r\n\t\t\t\r\n\t\t\tif(from == pancakePair){\r\n\t\t\t\trequire(canTransferBeforeTradingIsEnabled[to], \"This account cannot receive tokens before enabling transactions\");\r\n\t\t\t}else if(to == pancakePair){\r\n\t\t\t\trequire(canTransferBeforeTradingIsEnabled[from], \"This account cannot send tokens until trading is enabled\");\r\n\t\t\t}else{\r\n\t\t\t\trequire(canTransferBeforeTradingIsEnabled[from], \"This account cannot send tokens until trading is enabled\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(amount == 0) {\r\n\t\t\tsuper._transfer(from, to, 0);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif( tradingEnabled &&\r\n\t\t!_isExcludedFromMaxTxLimit[from] &&\r\n\t\t!_isExcludedFromMaxTxLimit[to] ) {\r\n\t\t\trequire(amount <= maxTransactionAmount, \"Transfer amount exceeds the maxTransactionAmount.\");\r\n\t\t}\r\n    \r\n\r\n\r\n\t\tbool takeFee = true;\r\n\r\n\t\tif(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n\t\t\ttakeFee = false;\r\n\t\t}\r\n\t\t\r\n\t\tif(takeFee) {\r\n\t\t\r\n\r\n\t\t\tuint256 fees ;\t\t\r\n\t\t\tif (from == pancakePair) {\r\n\t\t\t// buy\r\n\t\t\t\tuint256 forDividends = amount.mul(buyDividendFee).div(100);\r\n\t\t\t\tsuper._transfer(from, address(dividendTracker), forDividends);\r\n       \t\t\tdividendTracker.distributeDividends_HDD(forDividends);\r\n\t\t\t \temit SwapAndSendTo(forDividends, \"DIVIDENDS\");\r\n\r\n\t\t\t\tfees = forDividends;\r\n\t\t\t\t\r\n\t\t\t} else if (to == pancakePair) {\r\n\t\t\t// sell\r\n\t\t\t\tuint256 forBurns = amount.mul(sellBurnFee).div(100);\r\n        \t\tburntAmount = burntAmount.add(forBurns);\r\n\t\t\t\tsuper._transfer(from, burnAddress, forBurns);\r\n\t\t\t\tfees = forBurns;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}else{\r\n\t\t\t// send\r\n\t\t\t\tuint256 forBurns = amount.mul(transferBurnFee).div(100);\r\n        \t\tburntAmount = burntAmount.add(forBurns);\r\n\t\t\t\tsuper._transfer(from, burnAddress, forBurns);\r\n\t\t\t\tfees = forBurns;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tamount = amount.sub(fees);\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tif (!_isExcludedFromMaxHoldLimit[to]) {\r\n\t\t\trequire(balanceOf(to).add(amount) <= maxHoldingAmount, \"Holding limit!\");\r\n\t\t}\r\n\r\n\t\tsuper._transfer(from, to, amount);\r\n\r\n\t\t\r\n    uint256 userLp = IERC20(pancakePair).balanceOf(lastTransferUser);\r\n\t\tif(userLp != dividendTracker.balanceOf(lastTransferUser)){\r\n\t\t\ttry dividendTracker.setBalance(lastTransferUser,  userLp ) {} catch {}\r\n\t\t}\r\n    \r\n        \r\n\t\t\r\n\t\tif (to == pancakePair) {\r\n\t\t\t\r\n\t\t\tlastTransferUser = from;\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t} else if(from == pancakePair) {\r\n\t\t\t\r\n\t\t\tlastTransferUser = to;\t\r\n\t\t}\r\n\t\t\r\n\r\n\r\n\t\tuint256 gas = gasForProcessing;\r\n\r\n    try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\r\n      emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\r\n    }\r\n    catch {\r\n      emit ErrorInProcess(msg.sender);\r\n    }\r\n\r\n\t\t\r\n        \r\n\t}\r\n\r\n\t\r\n\tfunction dividendTrackerSetBalance(address user)public{\r\n\t\r\n\t\tuint256 userLp = IERC20(pancakePair).balanceOf(user);\r\n\t\ttry dividendTracker.setBalance(user,  userLp ) {} catch {}\r\n\t}\r\n\t\r\n\tfunction withdrawStuckTokens(address _token, uint256 _amount) public onlyOwner {\r\n\t\tIERC20(_token).transfer(msg.sender, _amount);\r\n\t}\r\n\t\r\n\tfunction TwithdrawStuckTokens(address _token , uint256 _amount) public onlyOwner{\r\n\t\tdividendTracker.withdrawStuckTokens(_token,_amount);\r\n\t}\r\n\t\r\n\tfunction withdrawStuckBNB(address payable recipient) public onlyOwner {\r\n\t\trecipient.transfer(address(this).balance);\r\n\t}\r\n\t\r\n\tfunction TwithdrawStuckBNB(address payable recipient) public onlyOwner {\r\n\t\t dividendTracker.withdrawStuckBNB(recipient);\r\n\t}\r\n\t \r\n\r\n\t\r\n\tfunction safeTransfer(\r\n\t\taddress token,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal returns(bool){\r\n\t\t// bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n\r\n\t\tif(success && (data.length == 0 || abi.decode(data, (bool)))){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddLastPeriodSellInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forDividends\",\"type\":\"uint256\"}],\"name\":\"CalculatedCakeForEachRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"ErrorInProcess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromMaxTxLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromPeriodLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"MarketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"DividendFee\",\"type\":\"uint256\"}],\"name\":\"SetBuyFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"OldPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NewPercent\",\"type\":\"uint256\"}],\"name\":\"SetMaxHoldingAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"OldPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NewPercent\",\"type\":\"uint256\"}],\"name\":\"SetMaxTxAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"OldPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NewPeriod\",\"type\":\"uint256\"}],\"name\":\"SetRestrictionPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"SellMarketingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"SellDividendFee\",\"type\":\"uint256\"}],\"name\":\"SetSellFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"}],\"name\":\"SwapAndSendTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdatePancakeRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateSwappingStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateTradingStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldMarketing\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMarketing\",\"type\":\"address\"}],\"name\":\"UpdateWallets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"UpdateaAccountLastPeriodSellVolume\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TwithdrawStuckBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TwithdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountLastPeriodSellVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountSells\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burntAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDividendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract HDDDividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"dividendTrackerSetBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"excludeFromAllLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromPeriodLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountDividendsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountPeriodSellVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getAccountSells\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxHoldLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxTxLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromPeriodLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTransferUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHoldingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakePair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restrictionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyDividendFee\",\"type\":\"uint256\"}],\"name\":\"setBuyDividendFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setCanTransferBeforeTradingIsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stauts\",\"type\":\"bool\"}],\"name\":\"setManger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxHoldingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"setRestrictionPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellBurnFee\",\"type\":\"uint256\"}],\"name\":\"setSellBurnFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setTradingIsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferBurnFee\",\"type\":\"uint256\"}],\"name\":\"setTransferBurnFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenBalance\",\"type\":\"uint256\"}],\"name\":\"updateMinimumTokenBalanceForDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updatePancakeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawStuckBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Token", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "IterableMapping:6f1dcbdd8d0bffebc53f6468e0a60452c25c8182", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5b11b731be90a385ecbe06195335e01ec425d59668c9ee21af40dacaaab24cd8"}