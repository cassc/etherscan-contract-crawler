{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/payouts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\n\\ncontract IclickPayOuts is ReentrancyGuard{\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    IERC20 public immutable _iclickToken;\\n    IERC20 internal immutable _usdToken;\\n    IUniswapRouter public immutable uniswapRouter;\\n    address internal immutable adminWallet;  // onlyCaller\\n    bool private inSwapAndLiquify;\\n\\n    uint internal constant MLTIPLR      = 1e9;\\n    uint internal constant DECIMAL      = 1e18;\\n    uint internal SWAPG                 = 100;\\n    uint internal constant DIVIDER      = 10000;\\n\\n    modifier onlyAdmin(){\\n        require(msg.sender == adminWallet, 'NotAllowed');\\n        _;\\n    }\\n    \\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n    \\n    // token sold\\n    event Tokensold (address indexed _sender, uint _amount);  \\n    // token Sent\\n    event TokenSent(address indexed _sender, uint amount);\\n\\n    constructor(){ \\n        adminWallet = address(0x536682fA000E22D4B41cb4E44Fb094CA18db20B1); // testnet 0x2ECe85C590313fFB84A6ba5978e53Ca5551234f0 // mainnet 0xfCb339d1e5F06fec7E6646A2d70C6d0e587ACDE0\\n        _iclickToken = IERC20(address(0xc8C06a58E4ad7c01b9bb5Af6C76a7a1CfEBd0319)); // testnet 0x80247A78b06bac28B2086D0eb0012feCD0442B66 // mainnet 0xc8C06a58E4ad7c01b9bb5Af6C76a7a1CfEBd0319\\n        _usdToken = IERC20(address(0x55d398326f99059fF775485246999027B3197955)); // testnet 0xC6Efc0f7AF6e0B3e413d8FdD339FAf4d9a6e2D8F // mainnet 0x55d398326f99059fF775485246999027B3197955\\n        IUniswapRouter _uniswapV2Router = IUniswapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); // testnet 0xD99D1c33F9fC3444f8101754aBC46c52416550D1 // mainnet 0x10ED43C718714eb63d5aA57B78B54704E256024E\\n        uniswapRouter = _uniswapV2Router;\\n    }\\n\\n    // make Payouts\\n    function makePayouts (address user, uint _amount) public onlyAdmin{\\n        // sell token\\n        uint _contractBalance = _usdToken.balanceOf(address(this));\\n        if(_contractBalance < _amount){\\n            // swap and liquify [get usdt]\\n            uint _tokenAmount = (_amount / getTokenPrice()) * DECIMAL;\\n            _tokenAmount     += _tokenAmount * SWAPG / DIVIDER; // + 1%\\n            swapAndLiquify(_iclickToken, _usdToken, _tokenAmount);\\n            emit Tokensold(user, _tokenAmount);\\n            _contractBalance  = _usdToken.balanceOf(address(this));\\n        }\\n        // transfer usdt\\n        require(_amount <= _contractBalance, 'noLqty');\\n        require(_usdToken.transfer(user, _amount));\\n    }\\n\\n    // get TOKEN_USDT rate\\n    function getTokenAmount(\\n        address _tokenA,\\n        address _tokenB,\\n        uint _amountIn\\n    ) internal view returns (uint256 _tokens) {\\n        address[] memory path = new address[](2);\\n        path[0] = _tokenA;\\n        path[1] = _tokenB;\\n        uint[] memory amounts = uniswapRouter.getAmountsOut(_amountIn, path);\\n        return amounts[1];\\n    }\\n\\n    function getTokenPrice () private view returns (uint){\\n        uint oneCTRLtoUSDT = getTokenAmount(address(_iclickToken), address(_usdToken), (1 ether / MLTIPLR));\\n        return oneCTRLtoUSDT * MLTIPLR;\\n    }\\n\\n    // swap \\n    function swapAndLiquify(IERC20 _token1, IERC20 _token2, uint tokenAmount) private lockTheSwap{\\n        // uint256 tokenAmount = _busdAddress.balanceOf(address(this));\\n        _token1.approve(address(uniswapRouter), tokenAmount);\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(_token1);\\n        path[1] = address(_token2);\\n        // path[1] = uniswapRouter.WETH();\\n        // make the swap\\n        uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        emit Tokensold(address(this), tokenAmount);\\n    }\\n\\n    // prevent token loss\\n    function getTokens (IERC20 _token) public onlyAdmin {\\n        require(IERC20(_token).balanceOf(address(this)) >= 0, 'LowBlce');\\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\\n        emit TokenSent(msg.sender, IERC20(_token).balanceOf(address(this)));\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n}\\n\\ninterface IUniswapRouter {\\n    function WETH() external pure returns (address);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\n\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier isHuman() {\\n        require(tx.origin == msg.sender, \\\"sorry humans only\\\");\\n        _;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Tokensold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_iclickToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"makePayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "IclickPayOuts", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}