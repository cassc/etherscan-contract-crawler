{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _setOwner(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    _setOwner(address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    _setOwner(newOwner);\r\n  }\r\n\r\n  function _setOwner(address newOwner) private {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n  // Booleans are more expensive than uint or any type that takes up a full\r\n  // word because each write operation emits an extra SLOAD to first read the\r\n  // slot's contents, replace the bits taken up by the boolean, and then write\r\n  // back. This is the compiler's defense against contract upgrades and\r\n  // pointer aliasing, and it cannot be disabled.\r\n\r\n  // The values being non-zero value makes deployment a bit more expensive,\r\n  // but in exchange the refund on every call to nonReentrant will be lower in\r\n  // amount. Since refunds are capped to a percentage of the total\r\n  // transaction's gas, it is best to keep them low in cases like this one, to\r\n  // increase the likelihood of the full refund coming into effect.\r\n  uint private constant _NOT_ENTERED = 1;\r\n  uint private constant _ENTERED = 2;\r\n\r\n  uint private _status;\r\n\r\n  constructor() {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    // On the first call to nonReentrant, _notEntered will be true\r\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n    // Any calls to nonReentrant after this point will fail\r\n    _status = _ENTERED;\r\n\r\n    _;\r\n\r\n    // By storing the original value once again, a refund is triggered (see\r\n    // https://eips.ethereum.org/EIPS/eip-2200)\r\n    _status = _NOT_ENTERED;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n  // To implement this library for multiple types with as little code\r\n  // repetition as possible, we write it in terms of a generic Set type with\r\n  // bytes32 values.\r\n  // The Set implementation uses private functions, and user-facing\r\n  // implementations (such as AddressSet) are just wrappers around the\r\n  // underlying Set.\r\n  // This means that we can only create new EnumerableSets for types that fit\r\n  // in bytes32.\r\n\r\n  struct Set {\r\n    // Storage of set values\r\n    bytes32[] _values;\r\n    // Position of the value in the `values` array, plus 1 because index 0\r\n    // means a value is not in the set.\r\n    mapping(bytes32 => uint) _indexes;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function _add(Set storage set, bytes32 value) private returns (bool) {\r\n    if (!_contains(set, value)) {\r\n      set._values.push(value);\r\n      // The value is stored at length-1, but we add 1 to all indexes\r\n      // and use 0 as a sentinel value\r\n      set._indexes[value] = set._values.length;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n    // We read and store the value's index to prevent multiple reads from the same storage slot\r\n    uint valueIndex = set._indexes[value];\r\n\r\n    if (valueIndex != 0) {\r\n      // Equivalent to contains(set, value)\r\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n      // This modifies the order of the array, as noted in {at}.\r\n\r\n      uint toDeleteIndex = valueIndex - 1;\r\n      uint lastIndex = set._values.length - 1;\r\n\r\n      if (lastIndex != toDeleteIndex) {\r\n        bytes32 lastvalue = set._values[lastIndex];\r\n\r\n        // Move the last value to the index where the value to delete is\r\n        set._values[toDeleteIndex] = lastvalue;\r\n        // Update the index for the moved value\r\n        set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n      }\r\n\r\n      // Delete the slot where the moved value was stored\r\n      set._values.pop();\r\n\r\n      // Delete the index for the deleted slot\r\n      delete set._indexes[value];\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n    return set._indexes[value] != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function _length(Set storage set) private view returns (uint) {\r\n    return set._values.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function _at(Set storage set, uint index) private view returns (bytes32) {\r\n    return set._values[index];\r\n  }\r\n\r\n  // Bytes32Set\r\n\r\n  struct Bytes32Set {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _add(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _remove(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n    return _contains(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(Bytes32Set storage set) internal view returns (uint) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(Bytes32Set storage set, uint index) internal view returns (bytes32) {\r\n    return _at(set._inner, index);\r\n  }\r\n\r\n  // AddressSet\r\n\r\n  struct AddressSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(AddressSet storage set, address value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(uint(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(AddressSet storage set, address value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(uint(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(uint(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(AddressSet storage set) internal view returns (uint) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(AddressSet storage set, uint index) internal view returns (address) {\r\n    return address(uint160(uint(_at(set._inner, index))));\r\n  }\r\n\r\n  // UintSet\r\n\r\n  struct UintSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(UintSet storage set, uint value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(UintSet storage set, uint value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(UintSet storage set, uint value) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function length(UintSet storage set) internal view returns (uint) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(UintSet storage set, uint index) internal view returns (uint) {\r\n    return uint(_at(set._inner, index));\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint size;\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n    (bool success, ) = recipient.call{ value: amount }(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain `call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   *\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   *\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `target` must be a contract.\r\n   * - calling `target` with `data` must not revert.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n    return functionCall(target, data, \"Address: low-level call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n   * `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but also transferring `value` wei to `target`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the calling contract must have an ETH balance of at least `value`.\r\n   * - the called Solidity function must be `payable`.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint value\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint-}[`functionCallWithValue`], but\r\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  /**\r\n   * @dev Deprecated. This function has issues similar to the ones found in\r\n   * {IERC20-approve}, and its usage is discouraged.\r\n   *\r\n   * Whenever possible, use {safeIncreaseAllowance} and\r\n   * {safeDecreaseAllowance} instead.\r\n   */\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint value\r\n  ) internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint value\r\n  ) internal {\r\n    uint newAllowance = token.allowance(address(this), spender) + value;\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint value\r\n  ) internal {\r\n    unchecked {\r\n      uint oldAllowance = token.allowance(address(this), spender);\r\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n      uint newAllowance = oldAllowance - value;\r\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n   * @param token The token targeted by the call.\r\n   * @param data The call data (encoded using abi.encode or one of its variants).\r\n   */\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n    // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n  /**\r\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint indexed tokenId);\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n   */\r\n  event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n   */\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner) external view returns (uint balance);\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint tokenId) external view returns (address owner);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint tokenId) external;\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(uint tokenId) external view returns (address operator);\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint tokenId,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract BullInterface {\r\n  function ownerOf(uint id) public virtual returns (address);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint id\r\n  ) public virtual;\r\n\r\n  function getApproved(uint tokenId) public view virtual returns (address);\r\n\r\n  function balanceOf(address owner) public view virtual returns (uint);\r\n\r\n  function tokenOfOwnerByIndex(address owner, uint index) public view virtual returns (uint);\r\n  function tokensOfOwner(address owner) public view virtual returns (uint[] calldata);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n  /**\r\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n   * by `operator` from `from`, this function is called.\r\n   *\r\n   * It must return its Solidity selector to confirm the token transfer.\r\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n   *\r\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n   */\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint tokenId,\r\n    bytes calldata data\r\n  ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC721Receiver} interface.\r\n *\r\n * Accepts all token transfers.\r\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n */\r\ncontract ERC721Holder is IERC721Receiver {\r\n  /**\r\n   * @dev See {IERC721Receiver-onERC721Received}.\r\n   *\r\n   * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n   */\r\n  function onERC721Received(\r\n    address,\r\n    address,\r\n    uint,\r\n    bytes memory\r\n  ) public virtual override returns (bytes4) {\r\n    return this.onERC721Received.selector;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/IWETH.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n  function deposit() external payable;\r\n\r\n  function transfer(address to, uint value) external returns (bool);\r\n\r\n  function withdraw(uint) external;\r\n}\r\n\r\n// File: contracts/interfaces/ICollectionWhitelistChecker.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICollectionWhitelistChecker {\r\n  function canList(uint _tokenId) external view returns (bool);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\ncontract BullsMarketplace is ERC721Holder, Ownable, ReentrancyGuard {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n  using SafeERC20 for IERC20;\r\n\r\n  enum CollectionStatus {\r\n    Pending,\r\n    Open,\r\n    Close\r\n  }\r\n\r\n  uint public holderDividentBalance;\r\n  uint public mintersDividentBalance;\r\n  mapping(address => uint) public totalHoldersDivident;\r\n  mapping(address => uint) public totalMintersDivident;\r\n  mapping(address => mapping(uint => uint)) lastHolderDividendAt;\r\n  mapping(address => mapping(address => uint)) lastMinterDividendAt;\r\n  mapping(address => mapping(address => uint)) minterCount; // Number mints per address for a collection\r\n\r\n  address public immutable WBNB;\r\n\r\n  uint public constant TOTAL_MAX_FEE = 1000; // 10% of a sale\r\n  uint public constant FEE_DENOMINATOR = 10000; // 10% of a sale\r\n\r\n  BullInterface bullContract;\r\n  address public adminAddress;\r\n  address public treasuryAddress;\r\n  uint public minimumAskPrice; // in wei\r\n  uint public maximumAskPrice; // in wei\r\n\r\n  mapping(address => uint) public pendingRevenue; // For creator/treasury to claim\r\n\r\n  EnumerableSet.AddressSet private _collectionAddressSet;\r\n\r\n  mapping(address => mapping(uint => Ask)) private _askDetails; // Ask details (price + seller address) for a given collection and a tokenId\r\n  mapping(address => EnumerableSet.UintSet) private _askTokenIds; // Set of tokenIds for a collection\r\n  mapping(address => Collection) private _collections; // Details about the collections\r\n  mapping(address => mapping(address => EnumerableSet.UintSet)) private _tokenIdsOfSellerForCollection;\r\n\r\n  struct Ask {\r\n    address seller; // address of the seller\r\n    uint price; // price of the token\r\n  }\r\n\r\n  struct Collection {\r\n    CollectionStatus status; // status of the collection\r\n    address creatorAddress; // address of the creator\r\n    address whitelistChecker; // whitelist checker (if not set --> 0x00)\r\n    uint tradingFee; // trading fee (100 = 1%, 500 = 5%, 5 = 0.05%)\r\n    uint creatorFee; // creator fee (100 = 1%, 500 = 5%, 5 = 0.05%)\r\n    uint reflectionMintRoyalty;\r\n    uint reflectionHolderRoyalty;\r\n    uint collectionSize;\r\n  }\r\n\r\n  event DepositWBNB(uint amount);\r\n\r\n  event AddMinterDataForAccounts(address indexed collection, address[] accounts, uint[] amounts);\r\n\r\n  // Ask order is cancelled\r\n  event AskCancel(address indexed collection, address indexed seller, uint indexed tokenId);\r\n\r\n  // Ask order is created\r\n  event AskNew(address indexed collection, address indexed seller, uint indexed tokenId, uint askPrice);\r\n\r\n  // Ask order is updated\r\n  event AskUpdate(address indexed collection, address indexed seller, uint indexed tokenId, uint askPrice);\r\n\r\n  // Collection is closed for trading and new listings\r\n  event CollectionClose(address indexed collection);\r\n\r\n  // New collection is added\r\n  event CollectionNew(address indexed collection, address indexed creator, address indexed whitelistChecker, uint tradingFee, uint creatorFee, uint reflectionMintRoyalty, uint reflectionHolderRoyalty, uint collectionSize);\r\n\r\n  // Existing collection is updated\r\n  event CollectionUpdate(address indexed collection, address indexed creator, address indexed whitelistChecker, uint tradingFee, uint creatorFee, uint reflectionMintRoyalty, uint reflectionHolderRoyalty, uint collectionSize);\r\n\r\n  // Admin and Treasury Addresses are updated\r\n  event NewAdminAndTreasuryAddresses(address indexed admin, address indexed treasury);\r\n\r\n  // Minimum/maximum ask prices are updated\r\n  event NewMinimumAndMaximumAskPrices(uint minimumAskPrice, uint maximumAskPrice);\r\n\r\n  // Recover NFT tokens sent by accident\r\n  event NonFungibleTokenRecovery(address indexed token, uint indexed tokenId);\r\n\r\n  // Pending revenue is claimed\r\n  event RevenueClaim(address indexed claimer, uint amount);\r\n\r\n  // Recover ERC20 tokens sent by accident\r\n  event TokenRecovery(address indexed token, uint amount);\r\n\r\n  // Ask order is matched by a trade\r\n  event Trade(address indexed collection, uint indexed tokenId, address indexed seller, address buyer, uint askPrice, uint netPrice, bool withBNB);\r\n\r\n  // Modifier for the admin\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == adminAddress, \"Management: Not admin\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Constructor\r\n   * @param _adminAddress: address of the admin\r\n   * @param _treasuryAddress: address of the treasury\r\n   * @param _WBNBAddress: WBNB address\r\n   * @param _minimumAskPrice: minimum ask price\r\n   * @param _maximumAskPrice: maximum ask price\r\n   */\r\n  constructor(\r\n    address _adminAddress,\r\n    address _treasuryAddress,\r\n    address _WBNBAddress,\r\n    address _bullAddress,\r\n    uint _minimumAskPrice,\r\n    uint _maximumAskPrice\r\n  ) {\r\n    require(_adminAddress != address(0), \"Operations: Admin address cannot be zero\");\r\n    require(_treasuryAddress != address(0), \"Operations: Treasury address cannot be zero\");\r\n    require(_WBNBAddress != address(0), \"Operations: WBNB address cannot be zero\");\r\n    require(_minimumAskPrice > 0, \"Operations: _minimumAskPrice must be > 0\");\r\n    require(_minimumAskPrice < _maximumAskPrice, \"Operations: _minimumAskPrice < _maximumAskPrice\");\r\n\r\n    adminAddress = _adminAddress;\r\n    treasuryAddress = _treasuryAddress;\r\n    bullContract = BullInterface(_bullAddress);\r\n\r\n    WBNB = _WBNBAddress;\r\n\r\n    minimumAskPrice = _minimumAskPrice;\r\n    maximumAskPrice = _maximumAskPrice;\r\n  }\r\n\r\n  /**\r\n   * @notice Multiply two numbers and divide by third one.\r\n   * @dev This function is used to prevent overflow in calculations. Read: https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\r\n   */\r\n  function mulDiv (uint x, uint y, uint z)\r\n    public pure returns (uint)\r\n  {\r\n    uint a = x / z; uint b = x % z; // x = a * z + b\r\n    uint c = y / z; uint d = y % z; // y = c * z + d\r\n    return a * b * z + a * d + b * c + b * d / z;\r\n  }\r\n\r\n  /**\r\n   * @notice Add a new collection\r\n   * @param _collection: collection address\r\n   * @param _creator: creator address (must be 0x00 if none)\r\n   * @param _whitelistChecker: whitelist checker (for additional restrictions, must be 0x00 if none)\r\n   * @param _tradingFee: trading fee (100 = 1%, 500 = 5%, 5 = 0.05%)\r\n   * @param _creatorFee: creator fee (100 = 1%, 500 = 5%, 5 = 0.05%, 0 if creator is 0x00)\r\n   * @param _reflectionMintRoyalty: reflection fee for minters (1 = 1%, 5 = 5%, 10 = 10%)\r\n   * @param _reflectionHolderRoyalty: reflection fee for holders (1 = 1%, 5 = 5%, 10 = 10%)\r\n   * @param _collectionSize: size of the collection (minimum 1)\r\n   * @dev Callable by admin\r\n   */\r\n  function addCollection(\r\n    address _collection,\r\n    address _creator,\r\n    address _whitelistChecker,\r\n    uint _tradingFee,\r\n    uint _creatorFee,\r\n    uint _reflectionMintRoyalty,\r\n    uint _reflectionHolderRoyalty,\r\n    uint _collectionSize\r\n  ) external onlyAdmin {\r\n    require(!_collectionAddressSet.contains(_collection), \"Operations: Collection already listed\");\r\n    require(IERC721(_collection).supportsInterface(0x80ac58cd), \"Operations: Not ERC721\");\r\n    require((_creatorFee == 0 && _creator == address(0)) || (_creatorFee != 0 && _creator != address(0)), \"Operations: Creator parameters incorrect\");\r\n    require(_tradingFee + _creatorFee + _reflectionMintRoyalty + _reflectionHolderRoyalty <= TOTAL_MAX_FEE, \"Operations: Sum of fee must inferior to TOTAL_MAX_FEE\");\r\n    require(_reflectionMintRoyalty >= 0 && _reflectionHolderRoyalty >= 0, \"Operations: Royalities mus be equal or higher than 0\");\r\n    require(_collectionSize > 0, \"Operations: Collection size must be higher than 0\");\r\n\r\n    _collectionAddressSet.add(_collection);\r\n\r\n    _collections[_collection] = Collection({\r\n      status: CollectionStatus.Open,\r\n      creatorAddress: _creator,\r\n      whitelistChecker: _whitelistChecker,\r\n      tradingFee: _tradingFee,\r\n      creatorFee: _creatorFee,\r\n      reflectionMintRoyalty: _reflectionMintRoyalty,\r\n      reflectionHolderRoyalty: _reflectionHolderRoyalty,\r\n      collectionSize: _collectionSize\r\n    });\r\n\r\n    emit CollectionNew(_collection, _creator, _whitelistChecker, _tradingFee, _creatorFee, _reflectionMintRoyalty, _reflectionHolderRoyalty, _collectionSize);\r\n  }\r\n\r\n  /**\r\n   * @notice Modify collection characteristics\r\n   * /// Same params as addCollection ///\r\n   * @dev Callable by admin\r\n   */\r\n  function modifyCollection(\r\n    address _collection,\r\n    address _creator,\r\n    address _whitelistChecker,\r\n    uint _tradingFee,\r\n    uint _creatorFee,\r\n    uint _reflectionMintRoyalty,\r\n    uint _reflectionHolderRoyalty,\r\n    uint _collectionSize\r\n  ) external onlyAdmin {\r\n    require(_collectionAddressSet.contains(_collection), \"Operations: Collection not listed\");\r\n\r\n    require((_creatorFee == 0 && _creator == address(0)) || (_creatorFee != 0 && _creator != address(0)), \"Operations: Creator parameters incorrect\");\r\n\r\n    require(_tradingFee + _creatorFee + _reflectionMintRoyalty + _reflectionHolderRoyalty <= TOTAL_MAX_FEE, \"Operations: Sum of fee must inferior to TOTAL_MAX_FEE\");\r\n\r\n    _collections[_collection] = Collection({\r\n      status: CollectionStatus.Open,\r\n      creatorAddress: _creator,\r\n      whitelistChecker: _whitelistChecker,\r\n      tradingFee: _tradingFee,\r\n      creatorFee: _creatorFee,\r\n      reflectionMintRoyalty: _reflectionMintRoyalty,\r\n      reflectionHolderRoyalty: _reflectionHolderRoyalty,\r\n      collectionSize: _collectionSize\r\n    });\r\n\r\n    emit CollectionUpdate(_collection, _creator, _whitelistChecker, _tradingFee, _creatorFee, _reflectionMintRoyalty, _reflectionHolderRoyalty, _collectionSize);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the admin to close collection for trading and new listing\r\n   * @param _collection: collection address\r\n   * @dev Callable by admin\r\n   */\r\n  function closeCollectionForTradingAndListing(address _collection) external onlyAdmin {\r\n    require(_collectionAddressSet.contains(_collection), \"Operations: Collection not listed\");\r\n\r\n    _collections[_collection].status = CollectionStatus.Close;\r\n    _collectionAddressSet.remove(_collection);\r\n\r\n\r\n    emit CollectionClose(_collection);\r\n  }\r\n\r\n  function addDividendForHolders(uint amount, address _collection) private {\r\n    holderDividentBalance += amount;\r\n    totalHoldersDivident[_collection] += (amount / _collections[_collection].collectionSize);\r\n  }\r\n\r\n  function addReflectionForHolders(address _collection) public payable {\r\n    require(_collectionAddressSet.contains(_collection), \"Operations: Collection not listed\");\r\n    IWETH(WBNB).deposit{value: msg.value}();\r\n    addDividendForHolders(msg.value, _collection);\r\n  }\r\n\r\n  function addDividendForMinters(uint amount, address _collection) private {\r\n    mintersDividentBalance += amount;\r\n    totalMintersDivident[_collection] += (amount / _collections[_collection].collectionSize);\r\n  }\r\n\r\n  function addReflectionForMinters(address _collection) public payable {\r\n    require(_collectionAddressSet.contains(_collection), \"Operations: Collection not listed\");\r\n    IWETH(WBNB).deposit{value: msg.value}();\r\n    addDividendForMinters(msg.value, _collection);\r\n  }\r\n\r\n  function addMinterDataForAccounts(address _collection, address[] calldata accounts, uint[] calldata mints) public onlyOwner {\r\n    require(_collectionAddressSet.contains(_collection), \"Operations: Collection not listed\");\r\n    \r\n    for (uint i = 0; i < accounts.length; i++) {\r\n      minterCount[_collection][accounts[i]] = mints[i];\r\n    }\r\n\r\n    emit AddMinterDataForAccounts(_collection, accounts, mints);\r\n  }\r\n\r\n  function getMintCount(address _collection, address minterAddress) public view returns (uint) {\r\n    return minterCount[_collection][minterAddress];\r\n  }\r\n\r\n  /**\r\n   * @notice Claim pending revenue (minters, holders)\r\n   */\r\n  function claimRewards() external nonReentrant {\r\n    uint allBalance = 0;\r\n\r\n    // current bulls count of sender\r\n    uint[] memory bullsIds = bullContract.tokensOfOwner(msg.sender);\r\n\r\n    // add up all rewards from all listed collections\r\n    for (uint i = 0; i < _collectionAddressSet.length(); i++) {\r\n      address _collection = _collectionAddressSet.at(i);\r\n      \r\n      uint holderBalance = 0;\r\n      uint totalDividentHolders = totalHoldersDivident[_collection];\r\n      for (uint j = 0; j < bullsIds.length; j++) {\r\n        // reduce gas cost by checking values\r\n        if(lastHolderDividendAt[_collection][bullsIds[j]] != totalDividentHolders) {\r\n          holderBalance += (totalDividentHolders - lastHolderDividendAt[_collection][bullsIds[j]]);  \r\n          lastHolderDividendAt[_collection][bullsIds[j]] = totalDividentHolders;\r\n        }\r\n      }\r\n      \r\n      uint mintBalance = 0;\r\n      uint totalDividentMinters = totalMintersDivident[_collection];\r\n      // reduce gas cost by checking values\r\n      if(lastMinterDividendAt[_collection][msg.sender] != totalDividentMinters) {\r\n        mintBalance = (totalDividentMinters - lastMinterDividendAt[_collection][msg.sender]) * minterCount[_collection][msg.sender];\r\n        lastMinterDividendAt[_collection][msg.sender] = totalDividentMinters;\r\n      }\r\n\r\n      allBalance += (holderBalance + mintBalance);\r\n    }\r\n\r\n    require(allBalance > 0, \"Claim: Nothing to claim\");\r\n\r\n    // transfer dividents to sender\r\n    IERC20(WBNB).safeTransfer(address(msg.sender), allBalance);\r\n\r\n    emit RevenueClaim(msg.sender, allBalance);\r\n  }\r\n\r\n  /**\r\n   * @notice Return total reflections a wallet has\r\n   */\r\n  function getDividentBalancesForWallet()\r\n    public\r\n    view\r\n    returns (uint)\r\n  {\r\n    uint allBalance = 0;\r\n    \r\n    uint[] memory bullsIds = bullContract.tokensOfOwner(msg.sender);\r\n    for (uint i = 0; i < _collectionAddressSet.length(); i++) {\r\n      address _collection = _collectionAddressSet.at(i);\r\n      // current bulls count\r\n      uint holderBalance = 0;\r\n      uint totalDividentHolders = totalHoldersDivident[_collection];\r\n      \r\n      for (uint j = 0; j < bullsIds.length; j++) {\r\n        holderBalance += (totalDividentHolders - lastHolderDividendAt[_collection][bullsIds[j]]);\r\n      }\r\n      \r\n      uint totalDividentMinters = totalMintersDivident[_collection];\r\n      uint mintBalance = (totalDividentMinters - lastMinterDividendAt[_collection][msg.sender]) * getMintCount(_collection, msg.sender);\r\n\r\n      allBalance += (holderBalance + mintBalance);\r\n    }\r\n\r\n    return allBalance;\r\n  }\r\n\r\n  /**\r\n   * @notice Calculate price and associated fees for a collection\r\n   * @param _collection: address of the collection\r\n   * @param _askPrice: listed price\r\n   */\r\n  function _calculatePriceAndFeesForCollection(address _collection, uint _askPrice)\r\n    internal\r\n    view\r\n    returns (\r\n      uint netPrice,\r\n      uint tradingFee,\r\n      uint creatorFee,\r\n      uint holderFee,\r\n      uint minterFee\r\n    )\r\n  {\r\n    holderFee = mulDiv(_askPrice, _collections[_collection].reflectionHolderRoyalty, FEE_DENOMINATOR);\r\n    minterFee = mulDiv(_askPrice, _collections[_collection].reflectionMintRoyalty,  FEE_DENOMINATOR);\r\n    tradingFee = mulDiv(_askPrice, _collections[_collection].tradingFee, FEE_DENOMINATOR);\r\n    creatorFee = mulDiv(_askPrice, _collections[_collection].creatorFee, FEE_DENOMINATOR);\r\n\r\n    netPrice = _askPrice - tradingFee - creatorFee - holderFee - minterFee;\r\n\r\n    return (netPrice, tradingFee, creatorFee, holderFee, minterFee);\r\n  }\r\n\r\n  /**\r\n   * @notice Calculate price and associated fees for a collection\r\n   * @param collection: address of the collection\r\n   * @param price: listed price\r\n   */\r\n  function calculatePriceAndFeesForCollection(address collection, uint price)\r\n    external\r\n    view\r\n    returns (\r\n      uint netPrice,\r\n      uint tradingFee,\r\n      uint creatorFee,\r\n      uint holderFee,\r\n      uint minterFee\r\n    )\r\n  {\r\n    if (_collections[collection].status != CollectionStatus.Open) {\r\n      return (0, 0, 0, 0, 0);\r\n    }\r\n\r\n    return (_calculatePriceAndFeesForCollection(collection, price));\r\n  }\r\n\r\n  /**\r\n   * @notice Buy token with BNB by matching the price of an existing ask order\r\n   * @param _collection: contract address of the NFT\r\n   * @param _tokenId: tokenId of the NFT purchased\r\n   */\r\n  function buyTokenUsingBNB(address _collection, uint _tokenId) external payable nonReentrant {\r\n    // Wrap BNB\r\n    IWETH(WBNB).deposit{value: msg.value}();\r\n    \r\n    emit DepositWBNB(msg.value);\r\n\r\n    _buyToken(_collection, _tokenId, msg.value, true);\r\n  }\r\n\r\n  /**\r\n   * @notice Buy token with WBNB by matching the price of an existing ask order\r\n   * @param _collection: contract address of the NFT\r\n   * @param _tokenId: tokenId of the NFT purchased\r\n   * @param _price: price (must be equal to the askPrice set by the seller)\r\n   */\r\n  function buyTokenUsingWBNB(\r\n    address _collection,\r\n    uint _tokenId,\r\n    uint _price\r\n  ) external nonReentrant {\r\n    IERC20(WBNB).safeTransferFrom(address(msg.sender), address(this), _price);\r\n\r\n    _buyToken(_collection, _tokenId, _price, false);\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Buy token by matching the price of an existing ask order\r\n   * @param _collection: contract address of the NFT\r\n   * @param _tokenId: tokenId of the NFT purchased\r\n   * @param _price: price (must match the askPrice from the seller)\r\n   * @param _withBNB: whether the token is bought with BNB (true) or WBNB (false)\r\n   */\r\n  function _buyToken(\r\n    address _collection,\r\n    uint _tokenId,\r\n    uint _price,\r\n    bool _withBNB\r\n  ) internal {\r\n    require(_collections[_collection].status == CollectionStatus.Open, \"Collection: Not for trading\");\r\n    require(_askTokenIds[_collection].contains(_tokenId), \"Buy: Not for sale\");\r\n\r\n    Ask memory askOrder = _askDetails[_collection][_tokenId];\r\n\r\n    // Front-running protection\r\n    require(_price == askOrder.price, \"Buy: Incorrect price\");\r\n    require(msg.sender != askOrder.seller, \"Buy: Buyer cannot be seller\");\r\n\r\n    // Calculate the net price (collected by seller), trading fee (collected by treasury), creator fee (collected by creator)\r\n    (uint netPrice, uint tradingFee, uint creatorFee, uint holderFee, uint minterFee) = _calculatePriceAndFeesForCollection(_collection, _price);\r\n\r\n    addDividendForHolders(holderFee, _collection);\r\n    addDividendForMinters(minterFee, _collection);\r\n\r\n    // Update storage information\r\n    _tokenIdsOfSellerForCollection[askOrder.seller][_collection].remove(_tokenId);\r\n    delete _askDetails[_collection][_tokenId];\r\n    _askTokenIds[_collection].remove(_tokenId);\r\n\r\n    // Transfer WBNB\r\n    IERC20(WBNB).safeTransfer(askOrder.seller, netPrice);\r\n\r\n    // Update pending revenues for treasury/creator (if any!)\r\n    if (creatorFee != 0) {\r\n      pendingRevenue[_collections[_collection].creatorAddress] += creatorFee;\r\n    }\r\n\r\n    // Update trading fee if not equal to 0\r\n    if (tradingFee != 0) {\r\n      pendingRevenue[treasuryAddress] += tradingFee;\r\n    }\r\n\r\n    // Transfer NFT to buyer\r\n    IERC721(_collection).safeTransferFrom(address(this), address(msg.sender), _tokenId);\r\n\r\n    // Emit event\r\n    emit Trade(_collection, _tokenId, askOrder.seller, msg.sender, _price, netPrice, _withBNB);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if an array of tokenIds can be listed\r\n   * @param _collection: address of the collection\r\n   * @param _tokenIds: array of tokenIds\r\n   * @dev if collection is not for trading, it returns array of bool with false\r\n   */\r\n  function canTokensBeListed(address _collection, uint[] calldata _tokenIds) external view returns (bool[] memory listingStatuses) {\r\n    listingStatuses = new bool[](_tokenIds.length);\r\n\r\n    if (_collections[_collection].status != CollectionStatus.Open) {\r\n      return listingStatuses;\r\n    }\r\n\r\n    for (uint i = 0; i < _tokenIds.length; i++) {\r\n      listingStatuses[i] = _canTokenBeListed(_collection, _tokenIds[i]);\r\n    }\r\n\r\n    return listingStatuses;\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if a token can be listed\r\n   * @param _collection: address of the collection\r\n   * @param _tokenId: tokenId\r\n   */\r\n  function _canTokenBeListed(address _collection, uint _tokenId) internal view returns (bool) {\r\n    address whitelistCheckerAddress = _collections[_collection].whitelistChecker;\r\n    return (whitelistCheckerAddress == address(0)) || ICollectionWhitelistChecker(whitelistCheckerAddress).canList(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice Create ask order\r\n   * @param _collection: contract address of the NFT\r\n   * @param _tokenId: tokenId of the NFT\r\n   * @param _askPrice: price for listing (in wei)\r\n   */\r\n  function createAskOrder(\r\n    address _collection,\r\n    uint _tokenId,\r\n    uint _askPrice\r\n  ) external nonReentrant {\r\n    // Verify price is not too low/high\r\n    require(_askPrice >= minimumAskPrice && _askPrice <= maximumAskPrice, \"Order: Price not within range\");\r\n\r\n    // Verify collection is accepted\r\n    require(_collections[_collection].status == CollectionStatus.Open, \"Collection: Not for listing\");\r\n\r\n    // Verify token has restriction\r\n    require(_canTokenBeListed(_collection, _tokenId), \"Order: tokenId not eligible\");\r\n\r\n    // Transfer NFT to this contract\r\n    IERC721(_collection).safeTransferFrom(address(msg.sender), address(this), _tokenId);\r\n\r\n    // Adjust the information\r\n    _tokenIdsOfSellerForCollection[msg.sender][_collection].add(_tokenId);\r\n    _askDetails[_collection][_tokenId] = Ask({ seller: msg.sender, price: _askPrice });\r\n\r\n    // Add tokenId to the askTokenIds set\r\n    _askTokenIds[_collection].add(_tokenId);\r\n\r\n    // Emit event\r\n    emit AskNew(_collection, msg.sender, _tokenId, _askPrice);\r\n  }\r\n\r\n  /**\r\n   * @notice Modify existing ask order\r\n   * @param _collection: contract address of the NFT\r\n   * @param _tokenId: tokenId of the NFT\r\n   * @param _newPrice: new price for listing (in wei)\r\n   */\r\n  function modifyAskOrder(\r\n    address _collection,\r\n    uint _tokenId,\r\n    uint _newPrice\r\n  ) external nonReentrant {\r\n    // Verify new price is not too low/high\r\n    require(_newPrice >= minimumAskPrice && _newPrice <= maximumAskPrice, \"Order: Price not within range\");\r\n\r\n    // Verify collection is accepted\r\n    require(_collections[_collection].status == CollectionStatus.Open, \"Collection: Not for listing\");\r\n\r\n    // Verify the sender has listed it\r\n    require(_tokenIdsOfSellerForCollection[msg.sender][_collection].contains(_tokenId), \"Order: Token not listed\");\r\n\r\n    // Adjust the information\r\n    _askDetails[_collection][_tokenId].price = _newPrice;\r\n\r\n    // Emit event\r\n    emit AskUpdate(_collection, msg.sender, _tokenId, _newPrice);\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Cancel existing ask order\r\n   * @param _collection: contract address of the NFT\r\n   * @param _tokenId: tokenId of the NFT\r\n   */\r\n  function cancelAskOrder(address _collection, uint _tokenId) external nonReentrant {\r\n    // Verify the sender has listed it\r\n    require(_tokenIdsOfSellerForCollection[msg.sender][_collection].contains(_tokenId), \"Order: Token not listed\");\r\n\r\n    // Adjust the information\r\n    _tokenIdsOfSellerForCollection[msg.sender][_collection].remove(_tokenId);\r\n    delete _askDetails[_collection][_tokenId];\r\n    _askTokenIds[_collection].remove(_tokenId);\r\n\r\n    // Transfer the NFT back to the user\r\n    IERC721(_collection).transferFrom(address(this), address(msg.sender), _tokenId);\r\n\r\n    // Emit event\r\n    emit AskCancel(_collection, msg.sender, _tokenId);\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Check asks for an array of tokenIds in a collection\r\n   * @param collection: address of the collection\r\n   * @param tokenIds: array of tokenId\r\n   */\r\n  function viewAsksByCollectionAndTokenIds(address collection, uint[] calldata tokenIds) external view returns (bool[] memory statuses, Ask[] memory askInfo) {\r\n    uint length = tokenIds.length;\r\n\r\n    statuses = new bool[](length);\r\n    askInfo = new Ask[](length);\r\n\r\n    for (uint i = 0; i < length; i++) {\r\n      if (_askTokenIds[collection].contains(tokenIds[i])) {\r\n        statuses[i] = true;\r\n      } else {\r\n        statuses[i] = false;\r\n      }\r\n\r\n      askInfo[i] = _askDetails[collection][tokenIds[i]];\r\n    }\r\n\r\n    return (statuses, askInfo);\r\n  }\r\n\r\n  /**\r\n   * @notice View ask orders for a given collection across all sellers\r\n   * @param collection: address of the collection\r\n   * @param cursor: cursor\r\n   * @param size: size of the response\r\n   */\r\n  function viewAsksByCollection(\r\n    address collection,\r\n    uint cursor,\r\n    uint size\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint[] memory tokenIds,\r\n      Ask[] memory askInfo,\r\n      uint\r\n    )\r\n  {\r\n    uint length = size;\r\n\r\n    if (length > _askTokenIds[collection].length() - cursor) {\r\n      length = _askTokenIds[collection].length() - cursor;\r\n    }\r\n\r\n    tokenIds = new uint[](length);\r\n    askInfo = new Ask[](length);\r\n\r\n    for (uint i = 0; i < length; i++) {\r\n      tokenIds[i] = _askTokenIds[collection].at(cursor + i);\r\n      askInfo[i] = _askDetails[collection][tokenIds[i]];\r\n    }\r\n\r\n    return (tokenIds, askInfo, cursor + length);\r\n  }\r\n\r\n  /**\r\n   * @notice View ask orders for a given collection and a seller\r\n   * @param collection: address of the collection\r\n   * @param seller: address of the seller\r\n   * @param cursor: cursor\r\n   * @param size: size of the response\r\n   */\r\n  function viewAsksByCollectionAndSeller(\r\n    address collection,\r\n    address seller,\r\n    uint cursor,\r\n    uint size\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint[] memory tokenIds,\r\n      Ask[] memory askInfo,\r\n      uint\r\n    )\r\n  {\r\n    uint length = size;\r\n\r\n    if (length > _tokenIdsOfSellerForCollection[seller][collection].length() - cursor) {\r\n      length = _tokenIdsOfSellerForCollection[seller][collection].length() - cursor;\r\n    }\r\n\r\n    tokenIds = new uint[](length);\r\n    askInfo = new Ask[](length);\r\n\r\n    for (uint i = 0; i < length; i++) {\r\n      tokenIds[i] = _tokenIdsOfSellerForCollection[seller][collection].at(cursor + i);\r\n      askInfo[i] = _askDetails[collection][tokenIds[i]];\r\n    }\r\n\r\n    return (tokenIds, askInfo, cursor + length);\r\n  }\r\n\r\n  /*\r\n   * @notice View addresses and details for all the collections available for trading\r\n   * @param cursor: cursor\r\n   * @param size: size of the response\r\n   */\r\n  function viewCollections(uint cursor, uint size)\r\n    external\r\n    view\r\n    returns (\r\n      address[] memory collectionAddresses,\r\n      Collection[] memory collectionDetails,\r\n      uint\r\n    )\r\n  {\r\n    uint length = size;\r\n\r\n    if (length > _collectionAddressSet.length() - cursor) {\r\n      length = _collectionAddressSet.length() - cursor;\r\n    }\r\n\r\n    collectionAddresses = new address[](length);\r\n    collectionDetails = new Collection[](length);\r\n\r\n    for (uint i = 0; i < length; i++) {\r\n      collectionAddresses[i] = _collectionAddressSet.at(cursor + i);\r\n      collectionDetails[i] = _collections[collectionAddresses[i]];\r\n    }\r\n\r\n    return (collectionAddresses, collectionDetails, cursor + length);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the admin to update minimum and maximum prices for a token (in wei)\r\n   * @param _minimumAskPrice: minimum ask price\r\n   * @param _maximumAskPrice: maximum ask price\r\n   * @dev Callable by admin\r\n   */\r\n  function updateMinimumAndMaximumPrices(uint _minimumAskPrice, uint _maximumAskPrice) external onlyAdmin {\r\n    require(_minimumAskPrice < _maximumAskPrice, \"Operations: _minimumAskPrice < _maximumAskPrice\");\r\n\r\n    minimumAskPrice = _minimumAskPrice;\r\n    maximumAskPrice = _maximumAskPrice;\r\n\r\n    emit NewMinimumAndMaximumAskPrices(_minimumAskPrice, _maximumAskPrice);\r\n  }\r\n\r\n  /**\r\n   * @notice Claim pending revenue (treasury or creators)\r\n   */\r\n  function claimPendingRevenue() external nonReentrant {\r\n    uint revenueToClaim = pendingRevenue[msg.sender];\r\n    require(revenueToClaim != 0, \"Claim: Nothing to claim\");\r\n    pendingRevenue[msg.sender] = 0;\r\n\r\n    IERC20(WBNB).safeTransfer(address(msg.sender), revenueToClaim);\r\n\r\n    emit RevenueClaim(msg.sender, revenueToClaim);\r\n  }\r\n\r\n  /**\r\n   * @notice Set admin address\r\n   * @dev Only callable by owner\r\n   * @param _adminAddress: address of the admin\r\n   * @param _treasuryAddress: address of the treasury\r\n   */\r\n  function setAdminAndTreasuryAddresses(address _adminAddress, address _treasuryAddress) external onlyOwner {\r\n    require(_adminAddress != address(0), \"Operations: Admin address cannot be zero\");\r\n    require(_treasuryAddress != address(0), \"Operations: Treasury address cannot be zero\");\r\n\r\n    adminAddress = _adminAddress;\r\n    treasuryAddress = _treasuryAddress;\r\n\r\n    emit NewAdminAndTreasuryAddresses(_adminAddress, _treasuryAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to recover tokens sent to the contract by mistake\r\n   * @param _token: token address\r\n   * @dev Callable by owner\r\n   */\r\n  function recoverFungibleTokens(address _token) external onlyOwner {\r\n    require(_token != WBNB, \"Operations: Cannot recover WBNB\");\r\n    uint amountToRecover = IERC20(_token).balanceOf(address(this));\r\n    require(amountToRecover != 0, \"Operations: No token to recover\");\r\n\r\n    IERC20(_token).safeTransfer(address(msg.sender), amountToRecover);\r\n\r\n    emit TokenRecovery(_token, amountToRecover);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to recover NFTs sent to the contract by mistake\r\n   * @param _token: NFT token address\r\n   * @param _tokenId: tokenId\r\n   * @dev Callable by owner\r\n   */\r\n  function recoverNonFungibleToken(address _token, uint _tokenId) external onlyOwner nonReentrant {\r\n    require(!_askTokenIds[_token].contains(_tokenId), \"Operations: NFT not recoverable\");\r\n    IERC721(_token).safeTransferFrom(address(this), address(msg.sender), _tokenId);\r\n\r\n    emit NonFungibleTokenRecovery(_token, _tokenId);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WBNBAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bullAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumAskPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumAskPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"AddMinterDataForAccounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AskCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askPrice\",\"type\":\"uint256\"}],\"name\":\"AskNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askPrice\",\"type\":\"uint256\"}],\"name\":\"AskUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"CollectionClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistChecker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reflectionMintRoyalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reflectionHolderRoyalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectionSize\",\"type\":\"uint256\"}],\"name\":\"CollectionNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistChecker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reflectionMintRoyalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reflectionHolderRoyalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectionSize\",\"type\":\"uint256\"}],\"name\":\"CollectionUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositWBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"NewAdminAndTreasuryAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumAskPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumAskPrice\",\"type\":\"uint256\"}],\"name\":\"NewMinimumAndMaximumAskPrices\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NonFungibleTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RevenueClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withBNB\",\"type\":\"bool\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistChecker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_creatorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reflectionMintRoyalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reflectionHolderRoyalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collectionSize\",\"type\":\"uint256\"}],\"name\":\"addCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mints\",\"type\":\"uint256[]\"}],\"name\":\"addMinterDataForAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"addReflectionForHolders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"addReflectionForMinters\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buyTokenUsingBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"buyTokenUsingWBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"calculatePriceAndFeesForCollection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"holderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minterFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"canTokensBeListed\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"listingStatuses\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAskOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPendingRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"closeCollectionForTradingAndListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_askPrice\",\"type\":\"uint256\"}],\"name\":\"createAskOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividentBalancesForWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minterAddress\",\"type\":\"address\"}],\"name\":\"getMintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderDividentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumAskPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAskPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintersDividentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"modifyAskOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistChecker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_creatorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reflectionMintRoyalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reflectionHolderRoyalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collectionSize\",\"type\":\"uint256\"}],\"name\":\"modifyCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverFungibleTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"recoverNonFungibleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"name\":\"setAdminAndTreasuryAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalHoldersDivident\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalMintersDivident\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumAskPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumAskPrice\",\"type\":\"uint256\"}],\"name\":\"updateMinimumAndMaximumPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"viewAsksByCollection\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct BullsMarketplace.Ask[]\",\"name\":\"askInfo\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"viewAsksByCollectionAndSeller\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct BullsMarketplace.Ask[]\",\"name\":\"askInfo\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"viewAsksByCollectionAndTokenIds\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"statuses\",\"type\":\"bool[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct BullsMarketplace.Ask[]\",\"name\":\"askInfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"viewCollections\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"collectionAddresses\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"enum BullsMarketplace.CollectionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"whitelistChecker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectionMintRoyalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectionHolderRoyalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionSize\",\"type\":\"uint256\"}],\"internalType\":\"struct BullsMarketplace.Collection[]\",\"name\":\"collectionDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BullsMarketplace", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000016656bd6ffc6479bffb1890ac51de42ec8fd0eff0000000000000000000000005c8bca35d182e2f71d54efe9b1808a176969b6ad000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000a46a4920b40f134420b472b16b3328d74d7b6b7000000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000000000000000000000084595161401484a000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://92d7eb97837dafb90bcaad8eaab7dfe9c1d70b19fa72be67fd776cc761845e0e"}