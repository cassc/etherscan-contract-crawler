{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract TokenLock {\r\n    struct Lock {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n        uint256 nonce; \r\n    }\r\n\r\n    \r\n    uint256 private globalNonce = 0;\r\n\r\n    mapping(address => mapping(address => Lock[])) public tokenLocks;\r\n    mapping(address => address[]) private userLockedTokens;\r\n\r\n    function lockTokens(address _token, uint256 _amount, uint256 _duration) external {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        require(IERC20(_token).transferFrom(msg.sender, address(this), _amount), \"Transfer failed\");\r\n\r\n        Lock memory newLock = Lock({\r\n            amount: _amount,\r\n            unlockTime: block.timestamp + _duration,\r\n            nonce: globalNonce // Assign the current global nonce\r\n        });\r\n\r\n        tokenLocks[msg.sender][_token].push(newLock);\r\n        globalNonce++; // Increment the global nonce after each lock\r\n\r\n        if (!isTokenLockedByUser(msg.sender, _token)) {\r\n            userLockedTokens[msg.sender].push(_token);\r\n        }\r\n    }\r\n\r\n    function unlockTokens(address _token, uint256 _index) external {\r\n        Lock storage lock = tokenLocks[msg.sender][_token][_index];\r\n        require(block.timestamp >= lock.unlockTime, \"Tokens are still locked\");\r\n        require(lock.amount > 0, \"No tokens to unlock\");\r\n\r\n        uint256 amount = lock.amount;\r\n        lock.amount = 0;\r\n\r\n        require(IERC20(_token).transfer(msg.sender, amount), \"Transfer failed\");\r\n    }\r\n\r\n    function getLockInfo(address _user, address _token, uint256 _index) public view returns (uint256 amount, uint256 unlockTime, uint256 nonce) {\r\n        Lock memory lock = tokenLocks[_user][_token][_index];\r\n        return (lock.amount, lock.unlockTime, lock.nonce);\r\n    }\r\n\r\n    function getLockCount(address _user, address _token) public view returns (uint256) {\r\n        return tokenLocks[_user][_token].length;\r\n    }\r\n\r\n    function getLockedTokens(address _user) public view returns (address[] memory) {\r\n        return userLockedTokens[_user];\r\n    }\r\n\r\n    function isTokenLockedByUser(address _user, address _token) private view returns (bool) {\r\n        for (uint i = 0; i < userLockedTokens[_user].length; i++) {\r\n            if (userLockedTokens[_user][i] == _token) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getLockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLockInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenLocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"unlockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenLock", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9c85fd755fb814a9d965083ffe2b0552ffc83846007a5855d8d93345063372e0"}