{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-03-27\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface ILockedDealV2 {\r\n    function CreateNewPool(\r\n        address _Token, //token to lock address\r\n        uint256 _StartTime, //Until what time the pool will start\r\n        uint256 _CliffTime, //Before CliffTime can't withdraw tokens\r\n        uint256 _FinishTime, //Until what time the pool will end\r\n        uint256 _StartAmount, //Total amount of the tokens to sell in the pool\r\n        address _Owner // Who the tokens belong to\r\n    ) external payable;\r\n\r\n    function WithdrawToken(uint256 _PoolId)\r\n        external\r\n        returns (uint256 withdrawnAmount);\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\ncontract GovManager is Ownable {\r\n    event GovernorUpdated (\r\n        address indexed oldGovernor,\r\n        address indexed newGovernor\r\n    );\r\n\r\n    address public GovernorContract;\r\n\r\n    modifier onlyOwnerOrGov() {\r\n        require(\r\n            msg.sender == owner() || msg.sender == GovernorContract,\r\n            \"Authorization Error\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setGovernorContract(address _address) external onlyOwnerOrGov {\r\n        address oldGov = GovernorContract;\r\n        GovernorContract = _address;\r\n        emit GovernorUpdated(oldGov, GovernorContract);\r\n    }\r\n\r\n    constructor() {\r\n        GovernorContract = address(0);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\ncontract ERC20Helper {\r\n    event TransferOut(uint256 Amount, address To, address Token);\r\n    event TransferIn(uint256 Amount, address From, address Token);\r\n    modifier TestAllownce(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _amount\r\n    ) {\r\n        require(\r\n            ERC20(_token).allowance(_owner, address(this)) >= _amount,\r\n            \"ERC20Helper: no allowance\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function TransferToken(\r\n        address _Token,\r\n        address _Reciver,\r\n        uint256 _Amount\r\n    ) internal {\r\n        uint256 OldBalance = ERC20(_Token).balanceOf(address(this));\r\n        emit TransferOut(_Amount, _Reciver, _Token);\r\n        ERC20(_Token).transfer(_Reciver, _Amount);\r\n        require(\r\n            (ERC20(_Token).balanceOf(address(this)) + _Amount) == OldBalance,\r\n            \"ERC20Helper: sent incorrect amount\"\r\n        );\r\n    }\r\n\r\n    function TransferInToken(\r\n        address _Token,\r\n        address _Subject,\r\n        uint256 _Amount\r\n    ) internal TestAllownce(_Token, _Subject, _Amount) {\r\n        require(_Amount > 0);\r\n        uint256 OldBalance = ERC20(_Token).balanceOf(address(this));\r\n        ERC20(_Token).transferFrom(_Subject, address(this), _Amount);\r\n        emit TransferIn(_Amount, _Subject, _Token);\r\n        require(\r\n            (OldBalance + _Amount) == ERC20(_Token).balanceOf(address(this)),\r\n            \"ERC20Helper: Received Incorrect Amount\"\r\n        );\r\n    }\r\n\r\n    function ApproveAllowanceERC20(\r\n        address _Token,\r\n        address _Subject,\r\n        uint256 _Amount\r\n    ) internal {\r\n        require(_Amount > 0);\r\n        ERC20(_Token).approve(_Subject, _Amount);\r\n    }\r\n}\r\n\r\n\r\n/// @title contain stores variables.\r\ncontract DelayData {\r\n    address public LockedDealAddress;\r\n    mapping(address => Delay) public DelayLimit; // delay limit for every token\r\n    mapping(address => mapping(address => Vault)) public VaultMap;\r\n    mapping(address => mapping(address => bool)) public Allowance;\r\n    mapping(address => address[]) public MyTokens;\r\n    mapping(address => address[]) public TokenToUsers;\r\n    uint256 public MaxDelay;\r\n\r\n    struct Vault {\r\n        uint256 Amount;\r\n        uint256 StartDelay;\r\n        uint256 CliffDelay;\r\n        uint256 FinishDelay;\r\n    }\r\n\r\n    struct Delay {\r\n        uint256[] Amounts;\r\n        uint256[] StartDelays;\r\n        uint256[] CliffDelays;\r\n        uint256[] FinishDelays;\r\n        bool isActive;\r\n    }\r\n\r\n    function _getMinDelays(\r\n        address _token,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 _startDelay, uint256 _cliffDelay, uint256 _finishDelay)\r\n    {\r\n        Delay memory delayLimit = DelayLimit[_token];\r\n        uint256 arrLength = delayLimit.Amounts.length;\r\n        if (arrLength == 0 || delayLimit.Amounts[0] > _amount) {\r\n            return (0, 0, 0);\r\n        }\r\n        uint256 i;\r\n        for (i = 1; i < arrLength; i++) {\r\n            if (_amount < delayLimit.Amounts[i]) {\r\n                break;\r\n            }\r\n        }\r\n        return (delayLimit.StartDelays[i - 1],\r\n                delayLimit.CliffDelays[i - 1],\r\n                delayLimit.FinishDelays[i - 1]);\r\n    }\r\n}\r\n\r\n\r\n/// @title contains array utility functions\r\nlibrary Array {\r\n    /// @dev returns a new slice of the array\r\n    function KeepNElementsInArray(uint256[] memory _arr, uint256 _n)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory newArray)\r\n    {\r\n        if (_arr.length == _n) return _arr;\r\n        require(_arr.length > _n, \"can't cut more then got\");\r\n        newArray = new uint256[](_n);\r\n        for (uint256 i = 0; i < _n; i++) {\r\n            newArray[i] = _arr[i];\r\n        }\r\n        return newArray;\r\n    }\r\n\r\n    function KeepNElementsInArray(address[] memory _arr, uint256 _n)\r\n        internal\r\n        pure\r\n        returns (address[] memory newArray)\r\n    {\r\n        if (_arr.length == _n) return _arr;\r\n        require(_arr.length > _n, \"can't cut more then got\");\r\n        newArray = new address[](_n);\r\n        for (uint256 i = 0; i < _n; i++) {\r\n            newArray[i] = _arr[i];\r\n        }\r\n        return newArray;\r\n    }\r\n\r\n    /// @return true if the array is ordered\r\n    function isArrayOrdered(uint256[] memory _arr)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        require(_arr.length > 0, \"array should be greater than zero\");\r\n        uint256 temp = _arr[0];\r\n        for (uint256 i = 1; i < _arr.length; i++) {\r\n            if (temp > _arr[i]) {\r\n                return false;\r\n            }\r\n            temp = _arr[i];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @return sum of the array elements\r\n    function getArraySum(uint256[] memory _array)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < _array.length; i++) {\r\n            sum = sum + _array[i];\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    /// @return true if the element exists in the array\r\n    function isInArray(address[] memory _arr, address _elem)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < _arr.length; i++) {\r\n            if (_arr[i] == _elem) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function addIfNotExsist(address[] storage _arr, address _elem) internal {\r\n        if (!Array.isInArray(_arr, _elem)) {\r\n            _arr.push(_elem);\r\n        }\r\n    }\r\n}\r\n\r\n/// @title contains modifiers.\r\ncontract DelayModifiers is DelayData {\r\n    modifier uniqueAddress(address _addr, address _oldAddr) {\r\n        require(_addr != _oldAddr, \"can't set the same address\");\r\n        _;\r\n    }\r\n\r\n    modifier uniqueValue(uint256 _value, uint256 _oldValue) {\r\n        require(_value != _oldValue, \"can't set the same value\");\r\n        _;\r\n    }\r\n\r\n    modifier notZeroAddress(address _addr) {\r\n        _notZeroAddress(_addr);\r\n        _;\r\n    }\r\n\r\n    modifier isVaultNotEmpty(address _token, address _owner) {\r\n        require(VaultMap[_token][_owner].Amount > 0, \"vault is already empty\");\r\n        _;\r\n    }\r\n\r\n    modifier validAmount(uint256 _fAmount, uint256 _sAmount) {\r\n        require(_fAmount >= _sAmount, \"invalid amount\");\r\n        _;\r\n    }\r\n\r\n    ///@dev By default, each token is inactive\r\n    modifier isTokenActive(address _token) {\r\n        require(\r\n            DelayLimit[_token].isActive,\r\n            \"there are no limits set for this token\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier orderedArray(uint256[] memory _array) {\r\n        require(Array.isArrayOrdered(_array), \"array should be ordered\");\r\n        _;\r\n    }\r\n\r\nfunction _DelayValidator(\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _startDelay,\r\n        uint256 _cliffDelay,\r\n        uint256 _finishDelay,\r\n        Vault storage _vault\r\n    ) internal view {\r\n        (\r\n            uint256 _startMinDelay,\r\n            uint256 _cliffMinDelay,\r\n            uint256 _finishMinDelay\r\n        ) = _getMinDelays(_token, _vault.Amount + _amount);\r\n\r\n        require(\r\n            _startDelay >= _vault.StartDelay &&\r\n            _cliffDelay >= _vault.CliffDelay &&\r\n            _finishDelay >= _vault.FinishDelay &&\r\n            _startDelay >= _startMinDelay &&\r\n            _cliffDelay >= _cliffMinDelay &&\r\n            _finishDelay >= _finishMinDelay,\r\n            \"Invalid delay parameters\"\r\n        );\r\n    }\r\n\r\n    function _notZeroAddress(address _addr) private pure {\r\n        require(_addr != address(0), \"address can't be null\");\r\n    }\r\n\r\n    function _equalValue(uint256 _fLength, uint256 _sLength) internal pure {\r\n        require(_fLength == _sLength, \"invalid array length\");\r\n    }\r\n}\r\n\r\n\r\n/// @title contains all events.\r\ninterface IDelayEvents {\r\n    event VaultValueChanged(\r\n        address indexed Token,\r\n        address indexed Owner,\r\n        uint256 Amount,\r\n        uint256 StartDelay,\r\n        uint256 CliffDelay,\r\n        uint256 FinishDelay\r\n    );\r\n    event UpdatedMinDelays(\r\n        address indexed Token,\r\n        uint256[] Amounts,\r\n        uint256[] StartDelays,\r\n        uint256[] CliffDelays,\r\n        uint256[] FinishDelays\r\n    );\r\n    event UpdatedMaxDelay(\r\n        uint256 OldDelay,\r\n        uint256 NewDelay\r\n    );\r\n    event TokenRedemptionApproval(\r\n        address indexed Token,\r\n        address indexed User,\r\n        bool Status\r\n    );\r\n    event RedeemedTokens(\r\n        address indexed Token,\r\n        uint256 Amount,\r\n        uint256 RemaningAmount\r\n    );\r\n    event TokenStatusFilter(\r\n        address indexed Token,\r\n        bool Status\r\n    );\r\n}\r\n\r\n\r\n/// @title all admin settings\r\ncontract DelayManageable is\r\n    Pausable,\r\n    GovManager,\r\n    IDelayEvents,\r\n    DelayModifiers,\r\n    ERC20Helper,\r\n    ReentrancyGuard\r\n{\r\n    function setLockedDealAddress(\r\n        address _lockedDealAddress\r\n    )\r\n        external\r\n        onlyOwnerOrGov\r\n        uniqueAddress(_lockedDealAddress, LockedDealAddress)\r\n    {\r\n        LockedDealAddress = _lockedDealAddress;\r\n    }\r\n\r\n    function setMinDelays(\r\n        address _token,\r\n        uint256[] calldata _amounts,\r\n        uint256[] calldata _startDelays,\r\n        uint256[] calldata _cliffDelays,\r\n        uint256[] calldata _finishDelays\r\n    ) external onlyOwnerOrGov notZeroAddress(_token) orderedArray(_amounts) {\r\n        _equalValues(\r\n            _amounts.length,\r\n            _startDelays.length,\r\n            _cliffDelays.length,\r\n            _finishDelays.length\r\n        );\r\n        // timestamps may not be sorted\r\n        for (uint256 i = 0; i < _startDelays.length; i++) {\r\n            require(\r\n                _startDelays[i] <= MaxDelay &&\r\n                    _cliffDelays[i] <= MaxDelay &&\r\n                    _finishDelays[i] <= MaxDelay,\r\n                \"one of timestamp elements greater than the maximum delay\"\r\n            );\r\n        }\r\n        DelayLimit[_token] = Delay(\r\n            _amounts,\r\n            _startDelays,\r\n            _cliffDelays,\r\n            _finishDelays,\r\n            true\r\n        );\r\n        emit UpdatedMinDelays(\r\n            _token,\r\n            _amounts,\r\n            _startDelays,\r\n            _cliffDelays,\r\n            _finishDelays\r\n        );\r\n    }\r\n\r\n    function setMaxDelay(\r\n        uint256 _maxDelay\r\n    ) external onlyOwnerOrGov uniqueValue(MaxDelay, _maxDelay) {\r\n        uint256 oldDelay = MaxDelay;\r\n        MaxDelay = _maxDelay;\r\n        emit UpdatedMaxDelay(oldDelay, _maxDelay);\r\n    }\r\n\r\n    function setTokenStatusFilter(\r\n        address _token,\r\n        bool _status\r\n    ) external onlyOwnerOrGov notZeroAddress(_token) {\r\n        DelayLimit[_token].isActive = _status;\r\n        emit TokenStatusFilter(_token, _status);\r\n    }\r\n\r\n    function Pause() external onlyOwnerOrGov {\r\n        _pause();\r\n    }\r\n\r\n    function Unpause() external onlyOwnerOrGov {\r\n        _unpause();\r\n    }\r\n\r\n    function _equalValues(\r\n        uint256 _amountsL,\r\n        uint256 _startDelaysL,\r\n        uint256 _finishDelaysL,\r\n        uint256 _cliffDelaysL\r\n    ) private pure {\r\n        _equalValue(_amountsL, _startDelaysL);\r\n        _equalValue(_finishDelaysL, _startDelaysL);\r\n        _equalValue(_cliffDelaysL, _startDelaysL);\r\n    }\r\n\r\n    /// @dev redemption of approved ERC-20 tokens from the contract\r\n    function redeemTokensFromVault(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyOwnerOrGov\r\n        nonReentrant\r\n        notZeroAddress(_token)\r\n        isVaultNotEmpty(_token, _owner)\r\n        validAmount(VaultMap[_token][_owner].Amount, _amount)\r\n    {\r\n        require(Allowance[_token][_owner], \"permission not granted\");\r\n        Vault storage vault = VaultMap[_token][_owner];\r\n        vault.Amount -= _amount;\r\n        if (vault.Amount == 0)\r\n            vault.FinishDelay = vault.CliffDelay = vault.StartDelay = 0; // if Amount is zero, refresh vault values\r\n        TransferToken(_token, msg.sender, _amount);\r\n        emit RedeemedTokens(_token, _amount, vault.Amount);\r\n    }\r\n}\r\n\r\n\r\n/// @title DelayView - getter view functions\r\ncontract DelayView is DelayManageable {\r\n    function GetUsersDataByRange(\r\n        address _token,\r\n        uint256 _from,\r\n        uint256 _to\r\n    ) external view returns (address[] memory _users, Vault[] memory _vaults) {\r\n        require(_from <= _to, \"_from index can't be greater than _to\");\r\n        require(\r\n            _from < TokenToUsers[_token].length &&\r\n                _to < TokenToUsers[_token].length,\r\n            \"index out of range\"\r\n        );\r\n        _vaults = new Vault[](_to - _from + 1);\r\n        _users = new address[](_to - _from + 1);\r\n        for (uint256 i = _from; i <= _to; i++) {\r\n            _users[i] = TokenToUsers[_token][i];\r\n            _vaults[i] = VaultMap[_token][TokenToUsers[_token][i]];\r\n        }\r\n    }\r\n\r\n    function GetMyTokensByRange(\r\n        address _user,\r\n        uint256 _from,\r\n        uint256 _to\r\n    ) external view returns (address[] memory _tokens) {\r\n        require(_from <= _to, \"_from index can't be greater than _to\");\r\n        require(\r\n            _from < MyTokens[_user].length && _to < MyTokens[_user].length,\r\n            \"index out of range\"\r\n        );\r\n        _tokens = new address[](_to - _from + 1);\r\n        for (uint256 i = _from; i <= _to; i++) {\r\n            _tokens[i] = MyTokens[_user][i];\r\n        }\r\n    }\r\n\r\n    function GetUsersLengthByToken(\r\n        address _token\r\n    ) external view returns (uint256) {\r\n        return TokenToUsers[_token].length;\r\n    }\r\n\r\n    function GetMyTokensLengthByUser(\r\n        address _user\r\n    ) external view returns (uint256) {\r\n        return MyTokens[_user].length;\r\n    }\r\n\r\n    function GetMyTokens(\r\n        address _user\r\n    ) external view returns (address[] memory tokens) {\r\n        address[] memory allTokens = MyTokens[_user];\r\n        tokens = new address[](allTokens.length);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < allTokens.length; i++) {\r\n            if (VaultMap[allTokens[i]][_user].Amount > 0) {\r\n                tokens[index++] = allTokens[i];\r\n            }\r\n        }\r\n        // Resize the array to remove the empty slots\r\n        assembly {\r\n            mstore(tokens, index)\r\n        }\r\n    }\r\n\r\n    function GetDelayLimits(\r\n        address _token\r\n    ) external view returns (Delay memory) {\r\n        return DelayLimit[_token];\r\n    }\r\n\r\n    function GetMinDelays(\r\n        address _token,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        view\r\n        isTokenActive(_token)\r\n        returns (uint256 _startDelay, uint256 _cliffDelay, uint256 _finishDelay)\r\n    {\r\n        return _getMinDelays(_token, _amount);\r\n    }\r\n\r\n    function GetTokenFilterStatus(address _token) external view returns (bool) {\r\n        return DelayLimit[_token].isActive;\r\n    }\r\n\r\n    function getChecksum() public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(owner(), GovernorContract));\r\n    }\r\n}\r\n\r\n\r\n/// @title DelayVault core logic\r\n/// @author The-Poolz contract team\r\ncontract DelayVault is DelayView {\r\n    constructor() {\r\n        // maxDelay is set to year by default\r\n        MaxDelay = 365 days;\r\n    }\r\n\r\n    function CreateVault(\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _startDelay,\r\n        uint256 _cliffDelay,\r\n        uint256 _finishDelay\r\n    )\r\n        external\r\n        whenNotPaused\r\n        nonReentrant\r\n        notZeroAddress(_token)\r\n        isTokenActive(_token)\r\n    {\r\n        require(\r\n            _startDelay <= MaxDelay &&\r\n            _cliffDelay <= MaxDelay &&\r\n            _finishDelay <= MaxDelay,\r\n            \"Delay greater than Allowed\"\r\n        );\r\n        Vault storage vault = VaultMap[_token][msg.sender];\r\n        require( // for the possibility of increasing only the time parameters\r\n            _amount > 0 ||\r\n            _startDelay > vault.StartDelay ||\r\n            _cliffDelay > vault.CliffDelay ||\r\n            _finishDelay > vault.FinishDelay,\r\n            \"Invalid parameters: increase at least one value\"\r\n        );\r\n        _DelayValidator(\r\n            _token,\r\n            _amount,\r\n            _startDelay,\r\n            _cliffDelay,\r\n            _finishDelay,\r\n            vault\r\n        );\r\n        vault.StartDelay = _startDelay;\r\n        vault.CliffDelay = _cliffDelay;\r\n        vault.FinishDelay = _finishDelay;\r\n        Array.addIfNotExsist(TokenToUsers[_token], msg.sender);\r\n        Array.addIfNotExsist(MyTokens[msg.sender], _token);\r\n        if (_amount > 0) {\r\n            vault.Amount += _amount;\r\n            TransferInToken(_token, msg.sender, _amount);\r\n        }\r\n        emit VaultValueChanged(\r\n            _token,\r\n            msg.sender,\r\n            vault.Amount,\r\n            vault.StartDelay,\r\n            vault.CliffDelay,\r\n            vault.FinishDelay\r\n        );\r\n    }\r\n\r\n    /** @dev Creates a new pool of tokens for a specified period or,\r\n         if there is no Locked Deal address, sends tokens to the owner.\r\n    */\r\n    function Withdraw(\r\n        address _token\r\n    ) external nonReentrant isVaultNotEmpty(_token, msg.sender) {\r\n        Vault storage vault = VaultMap[_token][msg.sender];\r\n        uint256 startDelay = block.timestamp + vault.StartDelay;\r\n        uint256 finishDelay = startDelay + vault.FinishDelay;\r\n        uint256 cliffDelay = startDelay + vault.CliffDelay;\r\n        uint256 lockAmount = vault.Amount;\r\n        vault.Amount = 0;\r\n        vault.FinishDelay = vault.CliffDelay = vault.StartDelay = 0;\r\n        if (LockedDealAddress != address(0)) {\r\n            ApproveAllowanceERC20(_token, LockedDealAddress, lockAmount);\r\n            ILockedDealV2(LockedDealAddress).CreateNewPool(\r\n                _token,\r\n                startDelay,\r\n                cliffDelay,\r\n                finishDelay,\r\n                lockAmount,\r\n                msg.sender\r\n            );\r\n        } else {\r\n            TransferToken(_token, msg.sender, lockAmount);\r\n        }\r\n        emit VaultValueChanged(\r\n            _token,\r\n            msg.sender,\r\n            vault.Amount,\r\n            vault.StartDelay,\r\n            vault.CliffDelay,\r\n            vault.FinishDelay\r\n        );\r\n    }\r\n\r\n    /// @dev the user can approve the redemption of their tokens by the admin\r\n    function approveTokenRedemption(address _token, bool _status) external {\r\n        Allowance[_token][msg.sender] = _status;\r\n        emit TokenRedemptionApproval(_token, msg.sender, _status);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"RemaningAmount\",\"type\":\"uint256\"}],\"name\":\"RedeemedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Status\",\"type\":\"bool\"}],\"name\":\"TokenRedemptionApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Status\",\"type\":\"bool\"}],\"name\":\"TokenStatusFilter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"From\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"}],\"name\":\"TransferIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"To\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"}],\"name\":\"TransferOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"OldDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NewDelay\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"Amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"StartDelays\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"CliffDelays\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"FinishDelays\",\"type\":\"uint256[]\"}],\"name\":\"UpdatedMinDelays\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"StartDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"CliffDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"FinishDelay\",\"type\":\"uint256\"}],\"name\":\"VaultValueChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Allowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliffDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_finishDelay\",\"type\":\"uint256\"}],\"name\":\"CreateVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"DelayLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"GetDelayLimits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"Amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"StartDelays\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"CliffDelays\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"FinishDelays\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct DelayData.Delay\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GetMinDelays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_startDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliffDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_finishDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"GetMyTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"GetMyTokensByRange\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"GetMyTokensLengthByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"GetTokenFilterStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"GetUsersDataByRange\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StartDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CliffDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"FinishDelay\",\"type\":\"uint256\"}],\"internalType\":\"struct DelayData.Vault[]\",\"name\":\"_vaults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"GetUsersLengthByToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GovernorContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LockedDealAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MyTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TokenToUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"VaultMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StartDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CliffDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"FinishDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"approveTokenRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChecksum\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeemTokensFromVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGovernorContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockedDealAddress\",\"type\":\"address\"}],\"name\":\"setLockedDealAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDelay\",\"type\":\"uint256\"}],\"name\":\"setMaxDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startDelays\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_cliffDelays\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_finishDelays\",\"type\":\"uint256[]\"}],\"name\":\"setMinDelays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setTokenStatusFilter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DelayVault", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "byzantium", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://35f8a00c918f478f240fb539c2e9df08fe27963db454a82159ba0c9c1f9be8a2"}