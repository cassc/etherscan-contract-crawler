{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/asdic/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\n\\n \\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns(bool);\\n}\\n\\n\\n\\n\\n/// @title ERC-721 Non-Fungible Token Standard\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface IERC721 /* is ERC165 */ {\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n    ///  may be created and assigned without emitting Transfer. At the time of\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\n    ///  When a Transfer event emits, this also indicates that the approved\\n    ///  address for that NFT (if any) is reset to none.\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    ///  The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    ///  function throws for queries about the zero address.\\n    /// @param _owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\n    function balanceOf(address _owner) external view returns(uint256);\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    ///  about them do throw.\\n    /// @param _tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 _tokenId) external view returns(address);\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    ///  except this function just sets data to \\\"\\\".\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    ///  operator of the current owner.\\n    /// @param _approved The new approved NFT controller\\n    /// @param _tokenId The NFT to approve\\n    function approve(address _approved, uint256 _tokenId) external payable;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///  all of `msg.sender`'s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    ///  multiple operators per owner.\\n    /// @param _operator Address to add to the set of authorized operators\\n    /// @param _approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\n    /// @param _tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view returns(address);\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _owner The address that owns the NFTs\\n    /// @param _operator The address that acts on behalf of the owner\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) external view returns(bool);\\n}\\n\\n\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\ninterface IERC721Metadata /* is ERC721 */ {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    /// {\\\"name\\\":\\\"\\\",\\\"description\\\":\\\"\\\",\\\"image\\\":\\\"\\\"}\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface IERC721TokenReceiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\\n}\\n\\n\\ninterface IERC721TokenReceiverEx is IERC721TokenReceiver {\\n    // bytes4(keccak256(\\\"onERC721ExReceived(address,address,uint256[],bytes)\\\")) = 0x0f7b88e3\\n    function onERC721ExReceived(address operator, address from,\\n        uint256[] memory tokenIds, bytes memory data)\\n    external returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/asdic/lib/Util.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\n \\n\\nlibrary Util {\\n    bytes4 internal constant ERC721_RECEIVER_RETURN = 0x150b7a02;\\n    bytes4 internal constant ERC721_RECEIVER_EX_RETURN = 0x0f7b88e3;\\n\\n    uint256 public constant UDENO = 10 ** 10;\\n    int256 public constant SDENO = 10 ** 10;\\n\\n    uint256 public constant RARITY_GRAY = 0;\\n    uint256 public constant RARITY_WHITE = 1;\\n    uint256 public constant RARITY_GREEN = 2;\\n    uint256 public constant RARITY_BLUE = 3;\\n    uint256 public constant RARITY_PURPLE = 4;\\n    uint256 public constant RARITY_ORANGE = 5;\\n    uint256 public constant RARITY_GOLD = 6;\\n    uint256 public constant RARITY_COLOR = 7;\\n\\n\\n    function randomUint(bytes memory seed, uint256 min, uint256 max)\\n    internal pure returns (uint256) {\\n\\n        if (min >= max) {\\n            return min;\\n        }\\n\\n        uint256 number = uint256(keccak256(seed));\\n        return number % (max - min + 1) + min;\\n    }\\n\\n    function randomInt(bytes memory seed, int256 min, int256 max)\\n    internal pure returns (int256) {\\n\\n        if (min >= max) {\\n            return min;\\n        }\\n\\n        int256 number = int256(keccak256(seed));\\n        return number % (max - min + 1) + min;\\n    }\\n\\n    function randomWeightCard(bytes memory seed, uint256[] memory weights,\\n        uint256 totalWeight) internal pure returns (uint256) {\\n\\n        uint256 number = Util.randomUint(seed, 1, totalWeight);\\n\\n        uint256 cou = 0;\\n        for(uint i = 0; i < 120; i++) {\\n            if(weights[i] == 0) {\\n                continue;\\n            }\\n            if (cou >= (number - 1)) {\\n                return weights[i];\\n            }\\n            cou = cou + 1;\\n        }\\n        return weights[number - 1];\\n    }\\n\\n    function randomWeight(bytes memory seed, uint256[] memory weights,\\n        uint256 totalWeight) internal pure returns (uint256) {\\n\\n        uint256 number = Util.randomUint(seed, 1, totalWeight);\\n\\n        for (uint256 i = weights.length - 1; i != 0; --i) {\\n            if (number <= weights[i]) {\\n                return i;\\n            }\\n\\n            number -= weights[i];\\n        }\\n\\n        return 0;\\n    }\\n\\n    function randomProb(bytes memory seed, uint256 nume, uint256 deno)\\n    internal pure returns (bool) {\\n\\n        uint256 rand = Util.randomUint(seed, 1, deno);\\n        return rand <= nume;\\n    }\\n\\n}\\n\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param account address of the account to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {size := extcodesize(account)}\\n        return size > 0;\\n    }\\n}\\n\\n\\nlibrary String {\\n    function equals(string memory a, string memory b)\\n    internal pure returns (bool) {\\n\\n        bytes memory ba = bytes(a);\\n        bytes memory bb = bytes(b);\\n\\n        uint256 la = ba.length;\\n        uint256 lb = bb.length;\\n\\n        for (uint256 i = 0; i != la && i != lb; ++i) {\\n            if (ba[i] != bb[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return la == lb;\\n    }\\n\\n    function concat(string memory a, string memory b)\\n    internal pure returns (string memory) {\\n\\n        bytes memory ba = bytes(a);\\n        bytes memory bb = bytes(b);\\n        bytes memory bc = new bytes(ba.length + bb.length);\\n\\n        uint256 bal = ba.length;\\n        uint256 bbl = bb.length;\\n        uint256 k = 0;\\n\\n        for (uint256 i = 0; i != bal; ++i) {\\n            bc[k++] = ba[i];\\n        }\\n        for (uint256 i = 0; i != bbl; ++i) {\\n            bc[k++] = bb[i];\\n        }\\n\\n        return string(bc);\\n    }\\n}\\n\\nlibrary UInteger {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"add error\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(a >= b, \\\"sub error\\\");\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"mul error\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function toString(uint256 a, uint256 radix)\\n    internal pure returns (string memory) {\\n\\n        if (a == 0) {\\n            return \\\"0\\\";\\n        }\\n\\n        uint256 length = 0;\\n        for (uint256 n = a; n != 0; n /= radix) {\\n            length++;\\n        }\\n\\n        bytes memory bs = new bytes(length);\\n\\n        for (uint256 i = length - 1; a != 0; --i) {\\n            uint256 b = a % radix;\\n            a /= radix;\\n\\n            if (b < 10) {\\n                bs[i] = bytes1(uint8(b + 48));\\n            } else {\\n                bs[i] = bytes1(uint8(b + 87));\\n            }\\n        }\\n\\n        return string(bs);\\n    }\\n\\n    function toString(uint256 a) internal pure returns (string memory) {\\n        return UInteger.toString(a, 10);\\n    }\\n\\n}\\n\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\\nlibrary Base64 {\\n\\n    bytes constant private base64stdchars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n    bytes constant private base64urlchars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\\\";\\n\\n    function encode(string memory _str) internal pure returns (string memory) {\\n\\n        bytes memory _bs = bytes(_str);\\n        uint256 rem = _bs.length % 3;\\n\\n        uint256 res_length = (_bs.length + 2) / 3 * 4 - ((3 - rem) % 3);\\n        bytes memory res = new bytes(res_length);\\n\\n        uint256 i = 0;\\n        uint256 j = 0;\\n\\n        for (; i + 3 <= _bs.length; i += 3) {\\n            (res[j], res[j + 1], res[j + 2], res[j + 3]) = encode3(\\n                uint8(_bs[i]),\\n                uint8(_bs[i + 1]),\\n                uint8(_bs[i + 2])\\n            );\\n\\n            j += 4;\\n        }\\n\\n        if (rem != 0) {\\n            uint8 la0 = uint8(_bs[_bs.length - rem]);\\n            uint8 la1 = 0;\\n\\n            if (rem == 2) {\\n                la1 = uint8(_bs[_bs.length - 1]);\\n            }\\n\\n            (byte b0, byte b1, byte b2,) = encode3(la0, la1, 0);\\n            res[j] = b0;\\n            res[j + 1] = b1;\\n            if (rem == 2) {\\n                res[j + 2] = b2;\\n            }\\n        }\\n\\n        return string(res);\\n    }\\n\\n    function encode3(uint256 a0, uint256 a1, uint256 a2)\\n    private\\n    pure\\n    returns (byte b0, byte b1, byte b2, byte b3)\\n    {\\n\\n        uint256 n = (a0 << 16) | (a1 << 8) | a2;\\n\\n        uint256 c0 = (n >> 18) & 63;\\n        uint256 c1 = (n >> 12) & 63;\\n        uint256 c2 = (n >> 6) & 63;\\n        uint256 c3 = (n) & 63;\\n\\n        b0 = base64urlchars[c0];\\n        b1 = base64urlchars[c1];\\n        b2 = base64urlchars[c2];\\n        b3 = base64urlchars[c3];\\n    }\\n\\n}\\n\\nlibrary Integer {\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n\\n        if (a < 0 && b < 0) {\\n            require(c < 0, \\\"add error\\\");\\n        } else if (a > 0 && b > 0) {\\n            require(c > 0, \\\"add error\\\");\\n        }\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n\\n        if (a < 0 && b > 0) {\\n            require(c < 0, \\\"sub error\\\");\\n        } else if (a >= 0 && b < 0) {\\n            require(c > 0, \\\"sub error\\\");\\n        }\\n\\n        return c;\\n    }\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"mul error\\\");\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(a != (int256(1) << 255) || b != - 1, \\\"div error\\\");\\n        return a / b;\\n    }\\n\\n    function toString(int256 a, uint256 radix)\\n    internal pure returns (string memory) {\\n\\n        if (a == 0) {\\n            return \\\"0\\\";\\n        }\\n\\n        uint256 m = a < 0 ? uint256(- a) : uint256(a);\\n\\n        uint256 length = 0;\\n        for (uint256 n = m; n != 0; n /= radix) {\\n            ++length;\\n        }\\n\\n        bytes memory bs;\\n        if (a < 0) {\\n            bs = new bytes(++length);\\n            bs[0] = bytes1(uint8(45));\\n        } else {\\n            bs = new bytes(length);\\n        }\\n\\n        for (uint256 i = length - 1; m != 0; --i) {\\n            uint256 b = m % radix;\\n            m /= radix;\\n\\n            if (b < 10) {\\n                bs[i] = bytes1(uint8(b + 48));\\n            } else {\\n                bs[i] = bytes1(uint8(b + 87));\\n            }\\n        }\\n\\n        return string(bs);\\n    }\\n\\n    function toString(int256 a) internal pure returns (string memory) {\\n        return Integer.toString(a, 10);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/asdic/nft/ASDICCard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"../lib/Util.sol\\\";\\n\\ncontract ASDICCard is ERC721 {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    mapping(address => bool) public packages;\\n    mapping(uint256 => uint16) public _cardType;\\n\\n    constructor(string memory _name, string memory _symbol)\\n        ERC721(_name, _symbol)\\n    {\\n        packages[msg.sender] = true;\\n    }\\n\\n    string public uriPrefix = \\\"https://ipfs.org/ipfs/\\\";\\n\\n    uint256 public total;\\n\\n    function setMaxHoldCard(uint256 num) external onlyOwner {\\n        maxHoldCard = num;\\n    }\\n\\n    function mint(address to, uint16 cardType) public returns (uint256) {\\n        require(packages[msg.sender], \\\"Card: Card only\\\");\\n        total++;\\n        uint256 tokenId = total;\\n        _cardType[tokenId] = cardType;\\n        _addTokenTo(to, tokenId);\\n        return tokenId;\\n    }\\n\\n    function batchByAmountMint(\\n        address to,\\n        uint16 _type,\\n        uint256 _num\\n    ) external returns (uint256[] memory) {\\n        require(packages[msg.sender], \\\"package only\\\");\\n\\n        uint256[] memory tokenIds = new uint256[](_num);\\n        for (uint256 i = 0; i != _num; ++i) {\\n            tokenIds[i] = mint(to, _type);\\n        }\\n        return tokenIds;\\n    }\\n\\n    function batchMint(address to, uint16[] memory cardTypes)\\n        external\\n        returns (uint256[] memory)\\n    {\\n        require(packages[msg.sender], \\\"package only\\\");\\n\\n        uint256 length = cardTypes.length;\\n        uint256[] memory tokenIds = new uint256[](length);\\n        for (uint256 i = 0; i != length; ++i) {\\n            tokenIds[i] = mint(to, cardTypes[i]);\\n        }\\n        return tokenIds;\\n    }\\n\\n    function safeBatchTransferFrom(address from, address to,\\n        uint256[] memory tokenIds) external {\\n\\n        safeBatchTransferFrom(from, to, tokenIds, \\\"\\\");\\n    }\\n\\n    function safeBatchTransferFrom(address from, address to,\\n        uint256[] memory tokenIds, bytes memory data) public {\\n\\n        batchTransferFrom(from, to, tokenIds);\\n\\n        if (to.isContract()) {\\n            require(IERC721TokenReceiverEx(to)\\n            .onERC721ExReceived(msg.sender, from, tokenIds, data)\\n                == Util.ERC721_RECEIVER_EX_RETURN,\\n                \\\"onERC721ExReceived() return invalid\\\");\\n        }\\n    }\\n\\n    function batchTransferFrom(address from, address to,\\n        uint256[] memory tokenIds) public {\\n        require(!_isExcludedFrom[from], \\\"sender is excluded\\\");\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"to is zero address\\\");\\n\\n        uint256 length = tokenIds.length;\\n        address sender = msg.sender;\\n\\n        bool approval = from == sender || approvalForAlls[from][sender];\\n\\n        for (uint256 i = 0; i != length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            require(from == tokenOwners[tokenId], \\\"from must be owner\\\");\\n            require(approval || sender == tokenApprovals[tokenId],\\n                \\\"sender must be owner or approvaled\\\");\\n\\n            if (tokenApprovals[tokenId] != address(0)) {\\n                delete tokenApprovals[tokenId];\\n            }\\n\\n            _removeTokenFrom(from, tokenId);\\n            _addTokenTo(to, tokenId);\\n\\n            emit Transfer(from, to, tokenId);\\n        }\\n    }\\n\\n    function batchBurn(uint256[] memory tokenIds) external {\\n        for (uint256 i = 0; i != tokenIds.length; i++) {\\n            _removeTokenFrom(msg.sender, tokenIds[i]);\\n        }\\n    }\\n\\n    function setPackage(address package, bool enable) external onlyOwner {\\n        packages[package] = enable;\\n    }\\n\\n    function _baseURI() internal view returns (string memory) {\\n        return uriPrefix;\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        view\\n        override\\n        public\\n        returns (string memory)\\n    {\\n        require(_cardType[tokenId] > 0, \\\"not card\\\");\\n        string memory baseURI = _baseURI();\\n        return\\n            bytes(baseURI).length > 0\\n                ? string(\\n                    abi.encodePacked(\\n                        baseURI,\\n                        Base64.encode(\\n                            uint256(_cardType[tokenId]).toString()\\n                        )\\n                    )\\n                )\\n                : \\\"\\\";\\n    }\\n\\n    function setUriPrefix(string memory prefix) external onlyOwner {\\n        uriPrefix = prefix;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/asdic/nft/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\nimport \\\"../interfaces/IERC721.sol\\\";\\n\\nimport \\\"../lib/Util.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nabstract contract ERC721 is Ownable, IERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n\\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    bytes4 private constant INTERFACE_ID_ERC721Metadata = 0x5b5e139f;\\n\\n    string public override name;\\n    string public override symbol;\\n    uint256 internal maxHoldCard = 10;\\n\\n    mapping(address => uint256[]) internal ownerTokens;\\n    mapping(uint256 => uint256) internal tokenIndexs;\\n    mapping(uint256 => address) internal tokenOwners;\\n\\n    mapping(uint256 => address) internal tokenApprovals;\\n    mapping(address => mapping(address => bool)) internal approvalForAlls;\\n    mapping(address => bool) public _isExcludedFrom;\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    function excludeFrom(address account) external onlyOwner {\\n        _isExcludedFrom[account] = true;\\n    }\\n\\n    function includeInFrom(address account) external onlyOwner {\\n        _isExcludedFrom[account] = false;\\n    }\\n\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        require(owner != address(0), \\\"owner is zero address\\\");\\n        return ownerTokens[owner].length;\\n    }\\n\\n    // [startIndex, endIndex)\\n    function tokensOf(\\n        address owner,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) external view returns (uint256[] memory) {\\n        require(owner != address(0), \\\"owner is zero address\\\");\\n\\n        uint256[] storage tokens = ownerTokens[owner];\\n        if (endIndex == 0 || endIndex > tokens.length) {\\n            return tokens;\\n        }\\n\\n        require(startIndex < endIndex, \\\"invalid index\\\");\\n\\n        uint256[] memory result = new uint256[](endIndex - startIndex);\\n        for (uint256 i = startIndex; i != endIndex; ++i) {\\n            result[i] = tokens[i];\\n        }\\n\\n        return result;\\n    }\\n\\n    function ownerOf(uint256 tokenId) external view override returns (address) {\\n        address owner = tokenOwners[tokenId];\\n        require(owner != address(0), \\\"nobody own the token\\\");\\n        return owner;\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public payable override {\\n        _transferFrom(from, to, tokenId);\\n\\n        if (to.isContract()) {\\n            require(\\n                IERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    tokenId,\\n                    data\\n                ) == Util.ERC721_RECEIVER_RETURN,\\n                \\\"onERC721Received() return invalid\\\"\\n            );\\n        }\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable override {\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(!_isExcludedFrom[from], \\\"sender is excluded\\\");\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"to is zero address\\\");\\n\\n        require(from == tokenOwners[tokenId], \\\"from must be owner\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                msg.sender == tokenApprovals[tokenId] ||\\n                approvalForAlls[from][msg.sender],\\n            \\\"sender must be owner or approvaled\\\"\\n        );\\n\\n        if (tokenApprovals[tokenId] != address(0)) {\\n            delete tokenApprovals[tokenId];\\n        }\\n\\n        _removeTokenFrom(from, tokenId);\\n        _addTokenTo(to, tokenId);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    // ensure everything is ok before call it\\n    function _removeTokenFrom(address from, uint256 tokenId) internal {\\n        uint256 index = tokenIndexs[tokenId];\\n\\n        uint256[] storage tokens = ownerTokens[from];\\n        uint256 indexLast = tokens.length - 1;\\n\\n        // save gas\\n        // if (index != indexLast) {\\n        uint256 tokenIdLast = tokens[indexLast];\\n        tokens[index] = tokenIdLast;\\n        tokenIndexs[tokenIdLast] = index;\\n        // }\\n\\n        tokens.pop();\\n\\n        // delete tokenIndexs[tokenId]; // save gas\\n        delete tokenOwners[tokenId];\\n    }\\n\\n    // ensure everything is ok before call it\\n    function _addTokenTo(address to, uint256 tokenId) internal {\\n        uint256[] storage tokens = ownerTokens[to];\\n        tokenIndexs[tokenId] = tokens.length;\\n        tokens.push(tokenId);\\n\\n        tokenOwners[tokenId] = to;\\n    }\\n\\n    function approve(address to, uint256 tokenId) external payable override {\\n        address owner = tokenOwners[tokenId];\\n\\n        require(\\n            msg.sender == owner || approvalForAlls[owner][msg.sender],\\n            \\\"sender must be owner or approved for all\\\"\\n        );\\n\\n        tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    function setApprovalForAll(address to, bool approved) external override {\\n        approvalForAlls[msg.sender][to] = approved;\\n        emit ApprovalForAll(msg.sender, to, approved);\\n    }\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        override\\n        returns (address)\\n    {\\n        require(tokenOwners[tokenId] != address(0), \\\"nobody own then token\\\");\\n\\n        return tokenApprovals[tokenId];\\n    }\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return approvalForAlls[owner][operator];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        external\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceID == INTERFACE_ID_ERC165 ||\\n            interfaceID == INTERFACE_ID_ERC721 ||\\n            interfaceID == INTERFACE_ID_ERC721Metadata;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_cardType\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_type\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"batchByAmountMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"cardTypes\",\"type\":\"uint16[]\"}],\"name\":\"batchMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"cardType\",\"type\":\"uint16\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"packages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setMaxHoldCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"package\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"setUriPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"tokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ASDICCard", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000a415344494320436172640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084e46544153444943000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}