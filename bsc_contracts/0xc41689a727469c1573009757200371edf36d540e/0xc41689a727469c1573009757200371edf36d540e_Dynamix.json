{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"},\"Dynamix.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\n/****************************************************************************************\\n \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\\n\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588   \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \\n \u2591\u2588\u2588\u2588   \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2588\u2588\u2588   \u2591\u2588\u2588\u2588\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588 \u2588\u2588\u2588  \\n \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588    \u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588   \u2591\u2591\u2588\u2588\u2588\u2588\u2588   \\n \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588   \u2591\u2591\u2588\u2588\u2588     \u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2591\u2591  \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2588\u2588\u2588\u2591\u2588\u2588\u2588  \\n \u2591\u2588\u2588\u2588    \u2588\u2588\u2588     \u2591\u2588\u2588\u2588     \u2591\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588      \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588   \u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \\n \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588     \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591      \u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591     \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591 \\n                                                                                        \\n\\u003e More information on https://dynamix.finance/\\n\\n*****************************************************************************************/\\n                                                                                        \\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Reward.sol\\\";\\nimport \\\"./Fee.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Swap.sol\\\";\\n\\ncontract Dynamix is Reward, IERC20, Fee, Swap {\\n\\tusing SafeMath for uint256;\\n\\tusing Address for address;\\n\\t\\n\\tmapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\t\\n\\tstring public name = \\u0027Dynamix\\u0027;\\n    string public symbol = \\u0027DYNA\\u0027;\\n    uint8 public decimals = 9;\\n\\t\\n\\tconstructor(uint256 totalSupply) \\n\\t\\tpublic Reward(totalSupply) {\\n\\t\\t\\temit Transfer(address(0), _msgSender(), totalSupply);\\n\\t}\\n\\t\\n\\tfunction totalSupply() public view override returns (uint256) {\\n        return _tokenSupply;\\n    }\\n\\t\\n\\tfunction balanceOf(address account) public view override returns (uint256)  {\\n        if (_balances[account].excludedFromReward) \\n\\t\\t\\treturn _balances[account].token;\\n\\t\\t\\n        return _rewardToToken(_balances[account].reward);\\n    }\\n\\t\\n\\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\\n\\t\\t _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\t\\n\\tfunction _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\t\\n\\t// Internal Transfer, and fee management\\n\\tfunction _transfer(address sender, address recipient, uint256 amount) private {\\n\\t\\tuint256 rewardFee = 0;\\n\\t\\tbool excludedFromFee = _excludedFromFee[sender] || _excludedFromFee[recipient];\\n\\t\\t\\n\\t\\tif(!excludedFromFee) {\\n\\t\\t\\tif(_isBuy(sender)) {\\n\\t\\t\\t\\t(uint256 rFee, uint256 tokenToTeam, uint256 tokenToOwner) = _getBuyFee(amount, holders);\\n\\t\\t\\t\\t_transfer(sender, teamAddress, tokenToTeam, 0);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Init timestamp for token hold\\n\\t\\t\\t\\t_balances[recipient].timestamp = block.timestamp;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\trewardFee = rFee;\\n\\t\\t\\t\\tamount = tokenToOwner;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\temit Transfer(sender, teamAddress, tokenToTeam);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(_isSell(recipient)) {\\n\\t\\t\\t\\t(uint256 tokenToBuyBack, uint256 tokenToTeam, uint256 tokenToOwner) = _getSellFee(amount, _balances[sender].timestamp);\\n\\t\\t\\t\\t_transfer(sender, teamAddress, tokenToTeam, 0);\\n\\t\\t\\t\\t_transfer(sender, address(this), tokenToBuyBack, 0);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tamount = tokenToOwner;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\temit Transfer(sender, teamAddress, tokenToTeam);\\n\\t\\t\\t\\temit Transfer(sender, address(this), tokenToBuyBack);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(!inSellOrBuy)\\n\\t\\t\\t\\t\\t_sellAndBuy();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        amount = _transfer(sender, recipient, amount, rewardFee);\\n\\t\\t\\n\\t\\temit Transfer(sender, recipient, amount);\\n\\t}\\n\\t\\n    receive() external payable {}\\n\\n\\tbool inSellOrBuy;\\n\\n\\tmodifier lockTheSwap {\\n        inSellOrBuy = true;\\n        _;\\n        inSellOrBuy = false;\\n    }\\n\\t\\t\\n\\t// Sell and BuyBack\\n\\tfunction _sellAndBuy() private lockTheSwap {\\n\\t\\tif(autoBuyBackEnabled){\\n\\t\\t\\t\\n\\t\\t\\t// Sell Tokens for BuyBack\\n\\t\\t\\tuint256 contractToken = balanceOf(address(this));\\n\\t\\t\\tif (contractToken \\u003e= minimumTokensBeforeSell) {\\n\\t\\t\\t\\t_approve(address(this), address(uniswapV2Router), contractToken);\\n\\t\\t\\t\\t_swapTokensForBNB(contractToken); \\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Buy Tokens\\n\\t\\t\\tuint256 contractBnb = address(this).balance;\\n\\t\\t\\t\\n\\t\\t\\tif (contractBnb \\u003e= minimumBNBBeforeBuy) \\n\\t\\t\\t\\t_approve(address(this), address(uniswapV2Router), contractBnb);\\n\\t\\t\\t\\t_buyBackAndBurnToken(contractBnb); // BuyBack and Burn\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Before PreSale, no fees\\n\\tfunction beforePreSale() external onlyOwner()  {\\n\\t\\tsellFee = 0;\\n\\t\\tbuyFee = 0;\\n\\t\\tautoBuyBackEnabled = false;\\n\\t\\tminimumTokensBeforeSell = 0;\\n\\t\\tminimumBNBBeforeBuy = 0;\\n\\n\\t\\temit PreSaleStarted(sellFee, buyFee);\\n    }\\n\\t\\n\\t// After PreSale, initialization fees\\n\\tfunction afterPreSale(address account) external onlyOwner()  {\\n\\t\\tsellFee = 17;\\n\\t\\tbuyFee = 12;\\n\\t\\t_pair[account] = true;\\n\\t\\tautoBuyBackEnabled = true;\\n\\t\\tminimumTokensBeforeSell = 1000 * 10**9 * 10**9;\\n\\t\\tminimumBNBBeforeBuy = 1 * 10**16;\\n\\n\\t\\temit PreSaleCompleted(sellFee, buyFee);\\n    }\\n}\"},\"Fee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\ncontract Fee is Ownable {\\t\\t\\n\\tusing SafeMath for uint256;\\n\\tusing Address for address;\\n\\n    mapping (address =\\u003e bool) internal _pair;\\n    mapping (address =\\u003e bool) internal _excludedFromFee;\\n\\n\\tuint256 public sellFee = 0;\\n\\tuint256 public buyFee = 0;\\n\\n\\taddress public teamAddress = 0x34A1a24BB6C8a692e6F5f7650C89bd88cB51A28d;\\n\\t\\t\\n\\tevent PreSaleStarted(\\n        uint256 sellFee,\\n        uint256 buyFee\\n    );\\n\\t\\n\\tevent PreSaleCompleted(\\n        uint256 sellFee,\\n        uint256 buyFee\\n    );\\n\\t\\n\\tevent TeamAddressChanged(\\n        address addr\\n    );\\n\\t\\n\\tconstructor() internal {\\n\\t\\taddress deadAddress = 0x000000000000000000000000000000000000dEaD;\\n\\t\\t\\n\\t\\t_excludedFromFee[_msgSender()] = true;\\n\\t\\t_excludedFromFee[address(this)] = true;\\n\\t\\t_excludedFromFee[teamAddress] = true;\\n\\t\\t_excludedFromFee[deadAddress] = true;\\n\\t}\\n\\t\\n\\t// Manage Excluded Addr\\n\\tfunction setExcludedFromFee(address account, bool excluded) external onlyOwner()  {\\n        _excludedFromFee[account] = excluded;\\n    }\\t\\n\\t\\n\\t// Manage Pair Address\\n\\tfunction setPair(address account, bool isPair) external onlyOwner()  {\\n        _pair[account] = isPair;\\n    }\\t\\n\\t\\n\\t// Is Tx Buy (in another words from pair)\\n\\tfunction _isBuy(address sender) internal view returns(bool) {\\n        return _pair[sender];\\n    }\\n\\t\\n\\t// Is Tx Sell (in another words to pair)\\n\\tfunction _isSell(address recipient) internal view returns(bool) {\\n        return _pair[recipient];\\n    }\\n\\t\\n\\t// Get Buy Fee (depending holders)\\n\\tfunction _getBuyFee(uint256 amount, uint256 holders) internal view returns(uint256, uint256, uint256) {\\n\\t\\tif(buyFee == 0) \\n\\t\\t\\treturn (0, 0, amount);\\n\\t\\t\\n\\t\\tuint256 rewardFee = _getRewardFee(holders);\\n\\t\\tuint256 teamFee = buyFee - rewardFee;\\n\\t\\t\\n\\t\\tuint256 tokenToTeam = amount.mul(teamFee).div(100);\\n        uint256 tokenToOwner = amount.sub(tokenToTeam);\\n\\n\\t\\treturn (rewardFee, tokenToTeam, tokenToOwner);\\n    }\\n\\t\\n\\t// Get Reward Fee (depending holders)\\n\\tfunction _getRewardFee(uint256 holders) internal pure returns(uint256) {\\n        if(holders \\u003c= 10000)\\n\\t\\t\\treturn 2;\\n        if(holders \\u003c= 20000)\\n\\t\\t\\treturn 3;\\n        if(holders \\u003c= 50000)\\n\\t\\t\\treturn 4;\\n\\t\\tif(holders \\u003c= 100000)\\n\\t\\t\\treturn 6;\\n\\t\\t\\n\\t\\treturn 8;\\n    }\\n\\t\\n\\t// Get Sell Fee (depending hold time)\\n\\tfunction _getSellFee(uint256 amount, uint timestamp) internal view returns(uint256, uint256, uint256) {\\n\\t\\tif(sellFee == 0) \\n\\t\\t\\treturn (0, 0, amount);\\n\\t\\t\\n\\t\\tuint256 fee = _getHoldFee(timestamp);\\n\\t\\t\\n\\t\\tuint256 tokenToTeam = amount.mul(fee).div(100);\\n        uint256 tokenToOwner = amount.sub(tokenToTeam);\\n\\t\\t\\n        uint256 tokenToBuyBack = tokenToTeam.mul(35).div(100);\\n\\t\\ttokenToTeam = tokenToTeam.sub(tokenToBuyBack);\\n\\t\\t\\n\\t\\treturn (tokenToBuyBack, tokenToTeam, tokenToOwner);\\n    }\\n\\t\\n\\t// Get Hold Fee (depending hold time)\\n\\tfunction _getHoldFee(uint timestamp) internal view returns(uint256) {\\n        uint diff = block.timestamp - timestamp;\\n\\n\\t\\tif(diff \\u003c= 604800) // 1 Week: 3600 * 24 * 7\\n\\t\\t\\treturn sellFee;\\n\\t\\tif(diff \\u003c= 2592000) // 1 Month: 3600 * 24 * 30\\n\\t\\t\\treturn 14;\\n\\t\\tif(diff \\u003c= 15552000) // 6 Months: 3600 * 24 * 30 * 6\\n\\t\\t\\treturn 8;\\n\\t\\t\\n\\t\\treturn 5; // \\u003e 6 Months\\n    }\\n\\t\\t\\n\\t// Set Team Address\\n\\tfunction setTeamAddress(address addr) external onlyOwner() {\\n        teamAddress = addr;\\n\\t\\t_excludedFromFee[teamAddress] = true;\\n\\n\\t\\tTeamAddressChanged(addr);\\n    }\\n\\t\\n\\t// Disable Fee\\n\\tfunction disableFee() external onlyOwner()  {\\n\\t\\tsellFee = 0;\\n\\t\\tbuyFee = 0;\\n    }\\n\\t\\n\\t// Enable Fee\\n\\tfunction enableFee() external onlyOwner()  {\\n\\t\\tsellFee = 17;\\n\\t\\tbuyFee = 12;\\n    }\\n}\"},\"Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\ncontract Holder {\\t\\t\\n    uint256 public holders;\\n\\t\\t\\n\\tconstructor() internal {\\n\\t\\tholders = 0;\\n\\t}\\n\\t\\t\\n\\t// Before Transfer Token to recipient\\n\\tfunction recipientTransfert(uint256 recipientAmount) internal {\\n\\t\\tif(recipientAmount == 0)\\n\\t\\t\\tholders++;\\n\\t}\\t\\t\\n\\t\\n\\t// After Transfer Token from sender\\n\\tfunction senderTransfert(uint256 senderAmount) internal {\\n\\t\\tif(senderAmount == 0)\\n\\t\\t\\tholders--;\\n\\t}\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"},\"Reward.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nimport \\\"./Holder.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract Reward is Ownable, Holder {\\n\\tusing SafeMath for uint256;\\n\\t\\n\\tstruct Balance {\\n        uint256 reward; \\n        uint256 token;  \\n        bool excludedFromReward;    \\n\\t\\tuint timestamp;\\n    }\\n\\t\\n    mapping (address =\\u003e Balance) internal _balances;\\n\\n    uint256 internal _tokenSupply;\\n    uint256 internal _rewardSupply;\\n\\t\\n    address[] private _excludedFromRewardAddr;\\n\\t\\t\\n\\tconstructor(uint256 totalSupply) public {\\n\\t\\trequire(totalSupply \\u003c= 1000000000000000000000000, \\\"totalSupply is too high\\\");\\n\\t\\t\\n\\t\\t_tokenSupply = totalSupply;\\n\\t\\t_rewardSupply = (~uint256(0) - (~uint256(0) % _tokenSupply));\\n\\t\\t\\n\\t\\t_balances[_msgSender()].reward = _rewardSupply;\\n\\t\\t_balances[_msgSender()].timestamp = block.timestamp;\\t\\t\\n\\t}\\n\\t\\t\\n\\t// Transfer Token \\n\\tfunction _transfer(address sender, address recipient, uint256 tokenAmount, uint256 fee) internal returns (uint256) {\\t\\t\\n\\t\\tuint256 rate = _getRate();\\t\\t\\n\\t\\trecipientTransfert(_balances[recipient].reward.div(rate));\\n\\t\\t\\n\\t\\t// Compute Fees\\n\\t\\tuint256 tokenFee = tokenAmount.mul(fee).div(100);\\n        uint256 tokenToTransfertAmount = tokenAmount.sub(tokenFee, \\\"tokenAmount sub tokenFee\\\");\\n\\t\\t\\n\\t\\t// Convert Token Amount to Transfert to Reward Amount\\n\\t\\tuint256 rewardAmount = tokenAmount.mul(rate);\\n        uint256 rewardFee = tokenFee.mul(rate);\\n        uint256 rewardToTransferAmount = rewardAmount.sub(rewardFee, \\\"rewardAmount sub rewardFee\\\");\\n\\n\\t\\t// Transfert Reward\\n\\t\\t_balances[sender].reward = _balances[sender].reward.sub(rewardAmount, \\\"reward sub rewardAmount\\\");\\n        _balances[recipient].reward = _balances[recipient].reward.add(rewardToTransferAmount);       \\n\\t\\t\\n\\t\\t// Transfert Exclude\\n\\t\\tif(_balances[sender].excludedFromReward)\\n\\t\\t\\t_balances[sender].token = _balances[sender].token.sub(tokenAmount, \\\"token sub tokenAmount\\\");\\n\\t\\t\\n\\t\\tif(_balances[recipient].excludedFromReward)\\n\\t\\t\\t_balances[recipient].token = _balances[recipient].token.add(tokenToTransfertAmount);\\n\\t\\t\\n\\t\\t// Update Reward Supply\\n\\t\\t_rewardSupply = _rewardSupply.sub(rewardFee, \\\"_rewardSupply sub rewardFee\\\");\\n\\t\\t\\n\\t\\tsenderTransfert(_balances[sender].reward.div(rate));\\n\\t\\t\\n\\t\\treturn tokenToTransfertAmount;\\n\\t}\\n\\n\\t// Get Total Token Supply and Rewards \\n\\tfunction _getTotalSupplyAndTotalReward() private view returns(uint256, uint256) {\\n        uint256 rewardTotal = _rewardSupply;\\n        uint256 tokenTotal = _tokenSupply;      \\n\\t\\t\\n        for (uint256 i = 0; i \\u003c _excludedFromRewardAddr.length; i++) {\\n\\t\\t\\tuint256 reward = _balances[_excludedFromRewardAddr[i]].reward;\\n\\t\\t\\tuint256 token = _balances[_excludedFromRewardAddr[i]].token;\\n\\t\\t\\t\\n            if (reward \\u003e rewardTotal || token \\u003e tokenTotal) \\n\\t\\t\\t\\treturn (_rewardSupply, _tokenSupply);\\n\\t\\t\\t\\n            rewardTotal = rewardTotal.sub(reward);\\n            tokenTotal = tokenTotal.sub(token);\\n        }\\n\\t\\t\\n        if (rewardTotal \\u003c _rewardSupply.div(_tokenSupply)) \\n\\t\\t\\treturn (_rewardSupply, _tokenSupply);\\n\\t\\t\\n        return (rewardTotal, tokenTotal);\\n    }\\n\\t\\n\\t// Convert Reward to Token\\n\\tfunction _rewardToToken(uint256 reward) internal view returns(uint256) {\\n        require(reward \\u003c= _rewardSupply, \\\"Reward Amount must be less than Reward Supply\\\");\\n\\t\\t\\n        uint256 rate = _getRate();\\n        return reward.div(rate);\\n    }\\n\\t\\n\\t// Get Rate between Reward Supply and Token Supply\\n\\tfunction _getRate() private view returns(uint256) {\\n        (uint256 rewardSupply, uint256 tokenSupply) = _getTotalSupplyAndTotalReward();\\n\\t\\t\\n        return rewardSupply.div(tokenSupply);\\n    }\\n\\t\\n\\t// Exclude an account from rewards\\n\\tfunction excludeAccountFromRewards(address account) external onlyOwner()  {\\n        require(!_balances[account].excludedFromReward, \\\"Account is not excluded\\\");\\n\\t\\t\\n        if(_balances[account].reward \\u003e 0) \\n            _balances[account].token = _rewardToToken(_balances[account].reward); \\n        \\n        _balances[account].excludedFromReward = true;\\n\\t\\t\\n        _excludedFromRewardAddr.push(account);\\n    }\\n\\n\\t// Include an account in rewards\\n    function includeAccountInRewards(address account) external onlyOwner() {\\n        require(_balances[account].excludedFromReward, \\\"Account is excluded\\\");\\n\\t\\t\\n        for (uint256 i = 0; i \\u003c _excludedFromRewardAddr.length; i++) {\\n            if (_excludedFromRewardAddr[i] == account) {\\n                _excludedFromRewardAddr[i] = _excludedFromRewardAddr[_excludedFromRewardAddr.length - 1];\\n\\t\\t\\t\\t_excludedFromRewardAddr.pop();\\n\\n                _balances[account].token = 0;\\n\\t\\t\\t\\t_balances[account].excludedFromReward = false;\\n\\t\\t\\t\\t\\n                break;\\n            }\\n        }\\n    }\\n\\t\\t\\n\\t// Account Balance Informations\\n\\tfunction accountBalance(address account) external view returns(uint256, uint256, bool, uint) {\\n        return (_balances[account].reward\\n\\t\\t\\t\\t, _balances[account].token\\n\\t\\t\\t\\t, _balances[account].excludedFromReward\\n\\t\\t\\t\\t, _balances[account].timestamp\\n\\t\\t\\t\\t);\\t\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"},\"Swap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nimport \\\"./Uniswap.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\ncontract Swap is Ownable {\\t\\n\\tusing SafeMath for uint256;\\n\\tusing Address for address;\\n\\t\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n\\t\\n    bool public autoBuyBackEnabled = false;\\n\\t\\n\\tuint256 public minimumTokensBeforeSell = 0;\\n\\tuint256 public minimumBNBBeforeBuy = 0;\\n\\t\\t\\n\\tevent autoBuyBackChanged(\\n        bool enabled,\\n\\t\\tuint256 minimumTokensBeforeSell,\\n\\t\\tuint256 minimumBNBBeforeBuy \\n    );\\n\\t\\n\\tevent TeamAddressChanged(\\n        address addr,\\n        string addrType\\n    );\\n\\n\\tevent BuyBackAndBurned(\\n        uint256 bnb,\\n        address[] path\\n    );\\n    \\n    event SwapTokensForBNB(\\n        uint256 amountIn,\\n        address to,\\n        address[] path\\n    );\\n\\t\\t\\n\\tconstructor() internal {\\n\\t\\t//IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0xD99D1c33F9fC3444f8101754aBC46c52416550D1);\\n\\t\\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n\\n\\t\\tuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n\\t\\tuniswapV2Router = _uniswapV2Router;\\n\\t}\\n\\t\\t\\n\\t// Enable Auto BuyBack and Burn\\n\\tfunction enableAutoBuy(uint256 tokensBeforeSell, uint256 bnbBeforeBuy) external onlyOwner()  {\\n\\t\\tautoBuyBackEnabled = true;\\n\\t\\tminimumTokensBeforeSell = tokensBeforeSell;\\n\\t\\tminimumBNBBeforeBuy = bnbBeforeBuy;\\n\\t\\t\\n\\t\\temit autoBuyBackChanged(autoBuyBackEnabled, minimumTokensBeforeSell, minimumBNBBeforeBuy);\\n    }\\t\\n\\n\\t// Disable Auto BuyBack and Burn\\n\\tfunction disableAutoBuy() external onlyOwner()  {\\n\\t\\tautoBuyBackEnabled = false;\\n\\t\\tminimumTokensBeforeSell = 0;\\n\\t\\tminimumBNBBeforeBuy = 0;\\n\\n\\t\\temit autoBuyBackChanged(autoBuyBackEnabled, minimumTokensBeforeSell, minimumBNBBeforeBuy);\\n    }\\n\\t\\n\\t// Swap Token to receive BNB\\n\\tfunction _swapTokensForBNB(uint256 token) internal {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\t\\ttoken\\n\\t\\t\\t, 0\\n\\t\\t\\t, path\\n\\t\\t\\t, address(this)\\n\\t\\t\\t, block.timestamp\\n\\t\\t);\\n        \\n        emit SwapTokensForBNB(token, address(this), path);\\n\\t\\t\\n    }\\n\\n\\t// Buy Back Token and burn them \\n    function _buyBackAndBurnToken(uint256 bnb) internal {\\n\\t\\taddress deadAddress = 0x000000000000000000000000000000000000dEaD;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = uniswapV2Router.WETH();\\n        path[1] = address(this);\\n\\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnb}(\\n\\t\\t\\t0\\n\\t\\t\\t, path\\n\\t\\t\\t, deadAddress // Tokens are burned\\n\\t\\t\\t, block.timestamp.add(300)\\n\\t\\t);\\n        \\n        emit BuyBackAndBurned(bnb, path);\\n    }\\n}\"},\"Uniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\r\\n\\r\\n// pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\n\\r\\n// pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    \\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\n// pragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\n// pragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnb\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"BuyBackAndBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyFee\",\"type\":\"uint256\"}],\"name\":\"PreSaleCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyFee\",\"type\":\"uint256\"}],\"name\":\"PreSaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapTokensForBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"addrType\",\"type\":\"string\"}],\"name\":\"TeamAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"TeamAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumTokensBeforeSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumBNBBeforeBuy\",\"type\":\"uint256\"}],\"name\":\"autoBuyBackChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"afterPreSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoBuyBackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beforePreSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAutoBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensBeforeSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bnbBeforeBuy\",\"type\":\"uint256\"}],\"name\":\"enableAutoBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccountFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccountInRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumBNBBeforeBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokensBeforeSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPair\",\"type\":\"bool\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setTeamAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Dynamix", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000d3c21bcecceda1000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6c1626e165680fbeb7fe001140a9c05c0fa6410254947be7bd4bbd584eb8c5cc"}