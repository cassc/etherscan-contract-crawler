{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BrewlabsAggregationRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./interfaces/IAdapter.sol\\\";\\r\\nimport \\\"./interfaces/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/IWETH.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IBrewlabsNFTDiscountManager.sol\\\";\\r\\n\\r\\nimport \\\"./libraries/BytesManipulation.sol\\\";\\r\\nimport \\\"./libraries/Ownable.sol\\\";\\r\\nimport \\\"./libraries/ReentrancyGuard.sol\\\";\\r\\nimport \\\"./libraries/SafeERC20.sol\\\";\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\n\\r\\ncontract BrewlabsAggregationRouter is Ownable, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    address public immutable WNATIVE;\\r\\n    address public constant NATIVE = address(0);\\r\\n    string public constant NAME = \\\"BrewlabsAggregationRouter\\\";\\r\\n    uint256 public constant FEE_DENOMINATOR = 1e4;\\r\\n    uint256 public MIN_FEE = 0;\\r\\n    uint256 public BREWS_FEE = 10;\\r\\n    address public FEE_CLAIMER;\\r\\n    address[] public TRUSTED_TOKENS;\\r\\n    address[] public ADAPTERS;\\r\\n    address private NFT_DISCOUNT_MGR;\\r\\n\\r\\n    event Recovered(address indexed _asset, uint256 amount);\\r\\n    event UpdatedTrustedTokens(address[] _newTrustedTokens);\\r\\n    event UpdatedAdapters(address[] _newAdapters);\\r\\n    event UpdatedMinFee(uint256 _oldMinFee, uint256 _newMinFee);\\r\\n    event UpdatedFeeClaimer(address _oldFeeClaimer, address _newFeeClaimer);\\r\\n    event BrewlabsSwap(address indexed _sender, address indexed _tokenIn, address indexed _tokenOut, uint256 _amountIn, uint256 _amountOut);\\r\\n    event SetNFTDiscountManager(address prevMgr, address newMgr);\\r\\n\\r\\n    struct Query {\\r\\n        address adapter;\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint256 amountOut;\\r\\n    }\\r\\n\\r\\n    struct Offer {\\r\\n        bytes amounts;\\r\\n        bytes adapters;\\r\\n        bytes path;\\r\\n        uint256 gasEstimate;\\r\\n    }\\r\\n\\r\\n    struct FormattedOffer {\\r\\n        uint256[] amounts;\\r\\n        address[] adapters;\\r\\n        address[] path;\\r\\n        uint256 gasEstimate;\\r\\n    }\\r\\n\\r\\n    struct Trade {\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOut;\\r\\n        address[] path;\\r\\n        address[] adapters;\\r\\n    }\\r\\n\\r\\n    modifier ensure(uint256 deadline) {\\r\\n        require(deadline >= block.timestamp, 'BrewlabsAggregationRouter: EXPIRED');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address[] memory _adapters,\\r\\n        address[] memory _trustedTokens,\\r\\n        address _feeClaimer,\\r\\n        address _wrapped_native\\r\\n    ) {\\r\\n        _setAllowanceForWrapping(_wrapped_native);\\r\\n        setTrustedTokens(_trustedTokens);\\r\\n        setFeeClaimer(_feeClaimer);\\r\\n        setAdapters(_adapters);\\r\\n        WNATIVE = _wrapped_native;\\r\\n    }\\r\\n\\r\\n    // -- SETTERS --\\r\\n\\r\\n    function _setAllowanceForWrapping(address _wnative) internal {\\r\\n        IERC20(_wnative).safeApprove(_wnative, type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function setTrustedTokens(address[] memory _trustedTokens) public onlyOwner {\\r\\n        emit UpdatedTrustedTokens(_trustedTokens);\\r\\n        TRUSTED_TOKENS = _trustedTokens;\\r\\n    }\\r\\n\\r\\n    function setAdapters(address[] memory _adapters) public onlyOwner {\\r\\n        emit UpdatedAdapters(_adapters);\\r\\n        ADAPTERS = _adapters;\\r\\n    }\\r\\n\\r\\n    function setBrewsFee(uint256 _fee) external onlyOwner {\\r\\n        BREWS_FEE = _fee;\\r\\n    }\\r\\n\\r\\n    function setMinFee(uint256 _fee) external onlyOwner {\\r\\n        emit UpdatedMinFee(MIN_FEE, _fee);\\r\\n        MIN_FEE = _fee;\\r\\n    }\\r\\n\\r\\n    function setFeeClaimer(address _claimer) public onlyOwner {\\r\\n        emit UpdatedFeeClaimer(FEE_CLAIMER, _claimer);\\r\\n        FEE_CLAIMER = _claimer;\\r\\n    }\\r\\n\\r\\n    function setNFTDiscountManager(address _discountMgr) external onlyOwner {\\r\\n        require(NFT_DISCOUNT_MGR != _discountMgr, \\\"BrewlabsAggregationRouter: same address can't be set\\\");\\r\\n        emit SetNFTDiscountManager(NFT_DISCOUNT_MGR, _discountMgr);\\r\\n        NFT_DISCOUNT_MGR = _discountMgr;\\r\\n    }\\r\\n\\r\\n    //  -- GENERAL --\\r\\n\\r\\n    function trustedTokensCount() external view returns (uint256) {\\r\\n        return TRUSTED_TOKENS.length;\\r\\n    }\\r\\n\\r\\n    function adaptersCount() external view returns (uint256) {\\r\\n        return ADAPTERS.length;\\r\\n    }\\r\\n\\r\\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\\r\\n        require(_tokenAmount > 0, \\\"BrewlabsAggregationRouter: Nothing to recover\\\");\\r\\n        IERC20(_tokenAddress).safeTransfer(msg.sender, _tokenAmount);\\r\\n        emit Recovered(_tokenAddress, _tokenAmount);\\r\\n    }\\r\\n\\r\\n    function recoverETH(uint256 _amount) external onlyOwner {\\r\\n        require(_amount > 0, \\\"BrewlabsAggregationRouter: Nothing to recover\\\");\\r\\n        payable(msg.sender).transfer(_amount);\\r\\n        emit Recovered(address(0), _amount);\\r\\n    }\\r\\n\\r\\n    // Fallback\\r\\n    receive() external payable {}\\r\\n\\r\\n    // -- HELPERS --\\r\\n\\r\\n    function _applyFee(uint256 _amountIn, uint256 _fee, uint256 _discount) internal view returns (uint256) {\\r\\n        require(_fee >= MIN_FEE, \\\"BrewlabsAggregationRouter: Insufficient fee\\\");\\r\\n        return _amountIn.mul(_fee).mul(FEE_DENOMINATOR - _discount) / (FEE_DENOMINATOR ** 2);\\r\\n    }\\r\\n\\r\\n    function _wrap(uint256 _amount) internal {\\r\\n        IWETH(WNATIVE).deposit{ value: _amount }();\\r\\n    }\\r\\n\\r\\n    function _unwrap(uint256 _amount) internal {\\r\\n        IWETH(WNATIVE).withdraw(_amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return tokens to user\\r\\n     * @dev Pass address(0) for ETH\\r\\n     * @param _token address\\r\\n     * @param _amount tokens to return\\r\\n     * @param _to address where funds should be sent to\\r\\n     */\\r\\n    function _returnTokensTo(\\r\\n        address _token,\\r\\n        uint256 _amount,\\r\\n        address _to\\r\\n    ) internal {\\r\\n        if (address(this) != _to) {\\r\\n            if (_token == NATIVE) {\\r\\n                payable(_to).transfer(_amount);\\r\\n            } else {\\r\\n                IERC20(_token).safeTransfer(_to, _amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transferFrom(address token, address _from, address _to, uint _amount) internal {\\r\\n        if (_from != address(this))\\r\\n            IERC20(token).safeTransferFrom(_from, _to, _amount);\\r\\n        else\\r\\n            IERC20(token).safeTransfer(_to, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Makes a deep copy of Offer struct\\r\\n     */\\r\\n    function _cloneOffer(Offer memory _queries) internal pure returns (Offer memory) {\\r\\n        return Offer(_queries.amounts, _queries.adapters, _queries.path, _queries.gasEstimate);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Appends Query elements to Offer struct\\r\\n     */\\r\\n    function _addQuery(\\r\\n        Offer memory _queries,\\r\\n        uint256 _amount,\\r\\n        address _adapter,\\r\\n        address _tokenOut,\\r\\n        uint256 _gasEstimate\\r\\n    ) internal pure {\\r\\n        _queries.path = BytesManipulation.mergeBytes(_queries.path, BytesManipulation.toBytes(_tokenOut));\\r\\n        _queries.amounts = BytesManipulation.mergeBytes(_queries.amounts, BytesManipulation.toBytes(_amount));\\r\\n        _queries.adapters = BytesManipulation.mergeBytes(_queries.adapters, BytesManipulation.toBytes(_adapter));\\r\\n        _queries.gasEstimate += _gasEstimate;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Converts byte-arrays to an array of integers\\r\\n     */\\r\\n    function _formatAmounts(bytes memory _amounts) internal pure returns (uint256[] memory) {\\r\\n        // Format amounts\\r\\n        uint256 chunks = _amounts.length / 32;\\r\\n        uint256[] memory amountsFormatted = new uint256[](chunks);\\r\\n        for (uint256 i = 0; i < chunks; i++) {\\r\\n            amountsFormatted[i] = BytesManipulation.bytesToUint256(i * 32 + 32, _amounts);\\r\\n        }\\r\\n        return amountsFormatted;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Converts byte-array to an array of addresses\\r\\n     */\\r\\n    function _formatAddresses(bytes memory _addresses) internal pure returns (address[] memory) {\\r\\n        uint256 chunks = _addresses.length / 32;\\r\\n        address[] memory addressesFormatted = new address[](chunks);\\r\\n        for (uint256 i = 0; i < chunks; i++) {\\r\\n            addressesFormatted[i] = BytesManipulation.bytesToAddress(i * 32 + 32, _addresses);\\r\\n        }\\r\\n        return addressesFormatted;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Formats elements in the Offer object from byte-arrays to integers and addresses\\r\\n     */\\r\\n    function _formatOffer(Offer memory _queries) internal pure returns (FormattedOffer memory) {\\r\\n        return\\r\\n            FormattedOffer(\\r\\n                _formatAmounts(_queries.amounts),\\r\\n                _formatAddresses(_queries.adapters),\\r\\n                _formatAddresses(_queries.path),\\r\\n                _queries.gasEstimate\\r\\n            );\\r\\n    }\\r\\n\\r\\n    // -- QUERIES --\\r\\n\\r\\n    /**\\r\\n     * Query single adapter\\r\\n     */\\r\\n    function queryAdapter(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint8 _index\\r\\n    ) external view returns (uint256) {\\r\\n        IAdapter _adapter = IAdapter(ADAPTERS[_index]);\\r\\n        uint256 amountOut = _adapter.query(_amountIn, _tokenIn, _tokenOut);\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Query specified adapters\\r\\n     */\\r\\n    function queryNoSplit(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint8[] calldata _options\\r\\n    ) public view returns (Query memory) {\\r\\n        Query memory bestQuery;\\r\\n        for (uint8 i; i < _options.length; i++) {\\r\\n            address _adapter = ADAPTERS[_options[i]];\\r\\n            uint256 amountOut = IAdapter(_adapter).query(_amountIn, _tokenIn, _tokenOut);\\r\\n            if (i == 0 || amountOut > bestQuery.amountOut) {\\r\\n                bestQuery = Query(_adapter, _tokenIn, _tokenOut, amountOut);\\r\\n            }\\r\\n        }\\r\\n        return bestQuery;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Query all adapters\\r\\n     */\\r\\n    function queryNoSplit(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut\\r\\n    ) public view returns (Query memory) {\\r\\n        Query memory bestQuery;\\r\\n        for (uint8 i; i < ADAPTERS.length; i++) {\\r\\n            address _adapter = ADAPTERS[i];\\r\\n            uint256 amountOut = IAdapter(_adapter).query(_amountIn, _tokenIn, _tokenOut);\\r\\n            if (i == 0 || amountOut > bestQuery.amountOut) {\\r\\n                bestQuery = Query(_adapter, _tokenIn, _tokenOut, amountOut);\\r\\n            }\\r\\n        }\\r\\n        return bestQuery;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Return path with best returns between two tokens\\r\\n     * Takes gas-cost into account\\r\\n     */\\r\\n    function findBestPathWithGas(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _maxSteps,\\r\\n        uint256 _gasPrice\\r\\n    ) external view returns (FormattedOffer memory) {\\r\\n        require(_maxSteps > 0 && _maxSteps < 5, \\\"BrewlabsAggregationRouter: Invalid max-steps\\\");\\r\\n        Offer memory queries;\\r\\n        queries.amounts = BytesManipulation.toBytes(_amountIn);\\r\\n        queries.path = BytesManipulation.toBytes(_tokenIn);\\r\\n        uint256 gasPriceInExitTkn = _gasPrice > 0 ? getGasPriceInExitTkn(_gasPrice, _tokenOut) : 0;\\r\\n        queries = _findBestPath(_amountIn, _tokenIn, _tokenOut, _maxSteps, queries, gasPriceInExitTkn);\\r\\n        if (queries.adapters.length == 0) {\\r\\n            queries.amounts = \\\"\\\";\\r\\n            queries.path = \\\"\\\";\\r\\n        }\\r\\n        return _formatOffer(queries);\\r\\n    }\\r\\n\\r\\n    // Find the market price between gas-asset(native) and token-out and express gas price in token-out\\r\\n    function getGasPriceInExitTkn(uint256 _gasPrice, address _tokenOut) internal view returns (uint256 price) {\\r\\n        FormattedOffer memory gasQuery = findBestPath(1e18, WNATIVE, _tokenOut, 2);\\r\\n        if (gasQuery.path.length != 0) {\\r\\n            // Leave result in nWei to preserve precision for assets with low decimal places\\r\\n            price = (gasQuery.amounts[gasQuery.amounts.length - 1] * _gasPrice) / 1e9;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Return path with best returns between two tokens\\r\\n     */\\r\\n    function findBestPath(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _maxSteps\\r\\n    ) public view returns (FormattedOffer memory) {\\r\\n        require(_maxSteps > 0 && _maxSteps < 5, \\\"BrewlabsAggregationRouter: Invalid max-steps\\\");\\r\\n        Offer memory queries;\\r\\n        queries.amounts = BytesManipulation.toBytes(_amountIn);\\r\\n        queries.path = BytesManipulation.toBytes(_tokenIn);\\r\\n        queries = _findBestPath(_amountIn, _tokenIn, _tokenOut, _maxSteps, queries, 0);\\r\\n        // If no paths are found return empty struct\\r\\n        if (queries.adapters.length == 0) {\\r\\n            queries.amounts = \\\"\\\";\\r\\n            queries.path = \\\"\\\";\\r\\n        }\\r\\n        return _formatOffer(queries);\\r\\n    }\\r\\n\\r\\n    function _findBestPath(\\r\\n        uint256 _amountIn,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _maxSteps,\\r\\n        Offer memory _queries,\\r\\n        uint256 _tknOutPriceNwei\\r\\n    ) internal view returns (Offer memory) {\\r\\n        Offer memory bestOption = _cloneOffer(_queries);\\r\\n        uint256 bestAmountOut;\\r\\n        uint256 gasEstimate;\\r\\n        bool withGas = _tknOutPriceNwei != 0;\\r\\n\\r\\n        // First check if there is a path directly from tokenIn to tokenOut\\r\\n        Query memory queryDirect = queryNoSplit(_amountIn, _tokenIn, _tokenOut);\\r\\n\\r\\n        if (queryDirect.amountOut != 0) {\\r\\n            if (withGas) {\\r\\n                gasEstimate = IAdapter(queryDirect.adapter).swapGasEstimate();\\r\\n            }\\r\\n            _addQuery(bestOption, queryDirect.amountOut, queryDirect.adapter, queryDirect.tokenOut, gasEstimate);\\r\\n            bestAmountOut = queryDirect.amountOut;\\r\\n        }\\r\\n        // Only check the rest if they would go beyond step limit (Need at least 2 more steps)\\r\\n        if (_maxSteps > 1 && _queries.adapters.length / 32 <= _maxSteps - 2) {\\r\\n            // Check for paths that pass through trusted tokens\\r\\n            for (uint256 i = 0; i < TRUSTED_TOKENS.length; i++) {\\r\\n                if (_tokenIn == TRUSTED_TOKENS[i]) {\\r\\n                    continue;\\r\\n                }\\r\\n                // Loop through all adapters to find the best one for swapping tokenIn for one of the trusted tokens\\r\\n                Query memory bestSwap = queryNoSplit(_amountIn, _tokenIn, TRUSTED_TOKENS[i]);\\r\\n                if (bestSwap.amountOut == 0) {\\r\\n                    continue;\\r\\n                }\\r\\n                // Explore options that connect the current path to the tokenOut\\r\\n                Offer memory newOffer = _cloneOffer(_queries);\\r\\n                if (withGas) {\\r\\n                    gasEstimate = IAdapter(bestSwap.adapter).swapGasEstimate();\\r\\n                }\\r\\n                _addQuery(newOffer, bestSwap.amountOut, bestSwap.adapter, bestSwap.tokenOut, gasEstimate);\\r\\n                newOffer = _findBestPath(\\r\\n                    bestSwap.amountOut,\\r\\n                    TRUSTED_TOKENS[i],\\r\\n                    _tokenOut,\\r\\n                    _maxSteps,\\r\\n                    newOffer,\\r\\n                    _tknOutPriceNwei\\r\\n                ); // Recursive step\\r\\n                address tokenOut = BytesManipulation.bytesToAddress(newOffer.path.length, newOffer.path);\\r\\n                uint256 amountOut = BytesManipulation.bytesToUint256(newOffer.amounts.length, newOffer.amounts);\\r\\n                // Check that the last token in the path is the tokenOut and update the new best option if neccesary\\r\\n                if (_tokenOut == tokenOut && amountOut > bestAmountOut) {\\r\\n                    if (newOffer.gasEstimate > bestOption.gasEstimate) {\\r\\n                        uint256 gasCostDiff = (_tknOutPriceNwei * (newOffer.gasEstimate - bestOption.gasEstimate)) /\\r\\n                            1e9;\\r\\n                        uint256 priceDiff = amountOut - bestAmountOut;\\r\\n                        if (gasCostDiff > priceDiff) {\\r\\n                            continue;\\r\\n                        }\\r\\n                    }\\r\\n                    bestAmountOut = amountOut;\\r\\n                    bestOption = newOffer;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return bestOption;\\r\\n    }\\r\\n\\r\\n    // -- SWAPPERS --\\r\\n    function _swapNoSplit(\\r\\n        Trade memory _trade,\\r\\n        address _from,\\r\\n        address _to\\r\\n    ) internal returns (uint256) {        \\r\\n        uint256[] memory amounts = new uint256[](_trade.path.length);\\r\\n        amounts[0] = _trade.amountIn;\\r\\n\\r\\n        bool feeOn = BREWS_FEE > 0 || MIN_FEE > 0;\\r\\n        if (feeOn) {\\r\\n            uint256 discount = NFT_DISCOUNT_MGR != address(0) ? IBrewlabsNFTDiscountManager(NFT_DISCOUNT_MGR).discountOf(msg.sender) : 0;\\r\\n            uint256 feeAmount = _applyFee(amounts[0], BREWS_FEE, discount);\\r\\n            if (_trade.path[0] == WNATIVE) {\\r\\n                _unwrap(feeAmount);\\r\\n                _returnTokensTo(NATIVE, feeAmount, FEE_CLAIMER);\\r\\n            } else {\\r\\n                _transferFrom(_trade.path[0], _from, FEE_CLAIMER, feeAmount);\\r\\n            }\\r\\n            amounts[0] = amounts[0] - feeAmount;\\r\\n        }\\r\\n\\r\\n        uint256 beforeBal = IERC20(_trade.path[0]).balanceOf(_trade.adapters[0]);\\r\\n        _transferFrom(_trade.path[0], _from, _trade.adapters[0], amounts[0]);\\r\\n        amounts[0] = IERC20(_trade.path[0]).balanceOf(_trade.adapters[0]).sub(beforeBal);\\r\\n\\r\\n        for (uint256 i = 0; i < _trade.adapters.length; i++) {\\r\\n            // All adapters should transfer output token to the following target\\r\\n            // All targets are the adapters, expect for the last swap where tokens are sent out\\r\\n            address targetAddress = i < _trade.adapters.length - 1 ? _trade.adapters[i + 1] : _to;\\r\\n\\r\\n            amounts[i + 1] = IAdapter(_trade.adapters[i]).swap(\\r\\n                amounts[i],\\r\\n                _trade.path[i],\\r\\n                _trade.path[i + 1],\\r\\n                targetAddress\\r\\n            );\\r\\n        }\\r\\n        require(amounts[amounts.length - 1] >= _trade.amountOut, \\\"BrewlabsAggregatonRouter: Insufficient output amount\\\");\\r\\n        return amounts[amounts.length - 1];\\r\\n    }\\r\\n\\r\\n    function swapNoSplit(\\r\\n        Trade memory _trade,\\r\\n        address _to,\\r\\n        uint256 _deadline\\r\\n    ) public ensure(_deadline) nonReentrant {\\r\\n        require(_trade.path[0] != _trade.path[_trade.path.length - 1], \\\"BrewlabsAggregatonRouter: Path needs to be valid\\\");\\r\\n        uint256 returnAmount = _swapNoSplit(_trade, msg.sender, _to);\\r\\n        emit BrewlabsSwap(msg.sender, _trade.path[0], _trade.path[_trade.path.length - 1], _trade.amountIn, returnAmount);\\r\\n    }\\r\\n\\r\\n    function swapNoSplitFromETH(\\r\\n        Trade memory _trade,\\r\\n        address _to,\\r\\n        uint256 _deadline\\r\\n    ) public payable ensure(_deadline) nonReentrant {\\r\\n        require(msg.value >= _trade.amountIn, \\\"BrewlabsAggregationRouter: Invalid msg value\\\");\\r\\n        require(_trade.path[0] == WNATIVE && _trade.path[_trade.path.length - 1] != WNATIVE, \\\"BrewlabsAggregationRouter: Path needs to be valid\\\");\\r\\n        uint256 leftOver = msg.value - _trade.amountIn;\\r\\n        if (leftOver > 0) {\\r\\n            payable(msg.sender).transfer(leftOver);\\r\\n        }\\r\\n        _wrap(_trade.amountIn);\\r\\n        uint256 returnAmount = _swapNoSplit(_trade, address(this), _to);\\r\\n        emit BrewlabsSwap(msg.sender, _trade.path[0], _trade.path[_trade.path.length - 1], _trade.amountIn, returnAmount);\\r\\n    }\\r\\n\\r\\n    function swapNoSplitToETH(\\r\\n        Trade memory _trade,\\r\\n        address _to,\\r\\n        uint256 _deadline\\r\\n    ) public ensure(_deadline) nonReentrant {\\r\\n        require(_trade.path[_trade.path.length - 1] == WNATIVE && _trade.path[0] != WNATIVE, \\\"BrewlabsAggregationRouter: Path needs to be valid\\\");\\r\\n        uint256 returnAmount = _swapNoSplit(_trade, msg.sender, address(this));\\r\\n        _unwrap(returnAmount);\\r\\n        _returnTokensTo(NATIVE, returnAmount, _to);\\r\\n\\r\\n        emit BrewlabsSwap(msg.sender, _trade.path[0], _trade.path[_trade.path.length - 1], _trade.amountIn, returnAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Swap token to token without the need to approve the first token\\r\\n     */\\r\\n    function swapNoSplitWithPermit(\\r\\n        Trade memory _trade,\\r\\n        address _to,\\r\\n        uint256 _deadline,\\r\\n        uint8 _v,\\r\\n        bytes32 _r,\\r\\n        bytes32 _s\\r\\n    ) external {\\r\\n        IERC20(_trade.path[0]).permit(msg.sender, address(this), _trade.amountIn, _deadline, _v, _r, _s);\\r\\n        swapNoSplit(_trade, _to, _deadline);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Swap token to ETH without the need to approve the first token\\r\\n     */\\r\\n    function swapNoSplitToETHWithPermit(\\r\\n        Trade memory _trade,\\r\\n        address _to,\\r\\n        uint256 _deadline,\\r\\n        uint8 _v,\\r\\n        bytes32 _r,\\r\\n        bytes32 _s\\r\\n    ) external {\\r\\n        IERC20(_trade.path[0]).permit(msg.sender, address(this), _trade.amountIn, _deadline, _v, _r, _s);\\r\\n        swapNoSplitToETH(_trade, _to, _deadline);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IAdapter {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function swapGasEstimate() external view returns (uint256);\\r\\n\\r\\n    function swap(\\r\\n        uint256,\\r\\n        address,\\r\\n        address,\\r\\n        address\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function query(\\r\\n        uint256,\\r\\n        address,\\r\\n        address\\r\\n    ) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBrewlabsNFTDiscountManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IBrewlabsNFTDiscountManager {\\r\\n    function discountOf(address _to) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address, address, uint256);\\r\\n    event Transfer(address, address, uint256);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function transferFrom(\\r\\n        address,\\r\\n        address,\\r\\n        uint256\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function allowance(address, address) external view returns (uint256);\\r\\n\\r\\n    function approve(address, uint256) external returns (bool);\\r\\n\\r\\n    function transfer(address, uint256) external returns (bool);\\r\\n\\r\\n    function balanceOf(address) external view returns (uint256);\\r\\n\\r\\n    function nonces(address) external view returns (uint256); // Only tokens that support permit\\r\\n\\r\\n    function permit(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        uint256,\\r\\n        uint8,\\r\\n        bytes32,\\r\\n        bytes32\\r\\n    ) external; // Only tokens that support permit\\r\\n\\r\\n    function swap(address, uint256) external; // Only Avalanche bridge tokens\\r\\n\\r\\n    function swapSupply(address) external view returns (uint256); // Only Avalanche bridge tokens\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n    function withdraw(uint256 amount) external;\\r\\n\\r\\n    function deposit() external payable;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/BytesManipulation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./BytesToTypes.sol\\\";\\r\\n\\r\\nlibrary BytesManipulation {\\r\\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\\r\\n        b = new bytes(32);\\r\\n        assembly {\\r\\n            mstore(add(b, 32), x)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toBytes(address x) internal pure returns (bytes memory b) {\\r\\n        b = new bytes(32);\\r\\n        assembly {\\r\\n            mstore(add(b, 32), x)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mergeBytes(bytes memory a, bytes memory b) public pure returns (bytes memory c) {\\r\\n        uint256 alen = a.length;\\r\\n        uint256 totallen = alen + b.length;\\r\\n        uint256 loopsa = (a.length + 31) / 32;\\r\\n        uint256 loopsb = (b.length + 31) / 32;\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(m, totallen)\\r\\n            for {\\r\\n                let i := 0\\r\\n            } lt(i, loopsa) {\\r\\n                i := add(1, i)\\r\\n            } {\\r\\n                mstore(add(m, mul(32, add(1, i))), mload(add(a, mul(32, add(1, i)))))\\r\\n            }\\r\\n            for {\\r\\n                let i := 0\\r\\n            } lt(i, loopsb) {\\r\\n                i := add(1, i)\\r\\n            } {\\r\\n                mstore(add(m, add(mul(32, add(1, i)), alen)), mload(add(b, mul(32, add(1, i)))))\\r\\n            }\\r\\n            mstore(0x40, add(m, add(32, totallen)))\\r\\n            c := m\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function bytesToAddress(uint256 _offst, bytes memory _input) internal pure returns (address) {\\r\\n        return BytesToTypes.bytesToAddress(_offst, _input);\\r\\n    }\\r\\n\\r\\n    function bytesToUint256(uint256 _offst, bytes memory _input) internal pure returns (uint256) {\\r\\n        return BytesToTypes.bytesToUint256(_offst, _input);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/BytesToTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache2.0\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary BytesToTypes {\\r\\n    function bytesToAddress(uint256 _offst, bytes memory _input) internal pure returns (address _output) {\\r\\n        assembly {\\r\\n            _output := mload(add(_input, _offst))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function bytesToUint256(uint256 _offst, bytes memory _input) internal pure returns (uint256 _output) {\\r\\n        assembly {\\r\\n            _output := mload(add(_input, _offst))\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: Caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: New owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// This is a simplified version of OpenZepplin's SafeERC20 library\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\r\\n    }\\r\\n\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/BytesManipulation.sol\": {\r\n        \"BytesManipulation\": \"0xd9341e95992840005779da16e31796221971274b\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_trustedTokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_feeClaimer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrapped_native\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"name\":\"BrewlabsSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevMgr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMgr\",\"type\":\"address\"}],\"name\":\"SetNFTDiscountManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_newAdapters\",\"type\":\"address[]\"}],\"name\":\"UpdatedAdapters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldFeeClaimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newFeeClaimer\",\"type\":\"address\"}],\"name\":\"UpdatedFeeClaimer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldMinFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMinFee\",\"type\":\"uint256\"}],\"name\":\"UpdatedMinFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_newTrustedTokens\",\"type\":\"address[]\"}],\"name\":\"UpdatedTrustedTokens\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ADAPTERS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BREWS_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_CLAIMER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TRUSTED_TOKENS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WNATIVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adaptersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSteps\",\"type\":\"uint256\"}],\"name\":\"findBestPath\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"}],\"internalType\":\"struct BrewlabsAggregationRouter.FormattedOffer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSteps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"findBestPathWithGas\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"}],\"internalType\":\"struct BrewlabsAggregationRouter.FormattedOffer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_index\",\"type\":\"uint8\"}],\"name\":\"queryAdapter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"_options\",\"type\":\"uint8[]\"}],\"name\":\"queryNoSplit\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"internalType\":\"struct BrewlabsAggregationRouter.Query\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"queryNoSplit\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"internalType\":\"struct BrewlabsAggregationRouter.Query\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"}],\"name\":\"setAdapters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setBrewsFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_claimer\",\"type\":\"address\"}],\"name\":\"setFeeClaimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setMinFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_discountMgr\",\"type\":\"address\"}],\"name\":\"setNFTDiscountManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_trustedTokens\",\"type\":\"address[]\"}],\"name\":\"setTrustedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"internalType\":\"struct BrewlabsAggregationRouter.Trade\",\"name\":\"_trade\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapNoSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"internalType\":\"struct BrewlabsAggregationRouter.Trade\",\"name\":\"_trade\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapNoSplitFromETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"internalType\":\"struct BrewlabsAggregationRouter.Trade\",\"name\":\"_trade\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapNoSplitToETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"internalType\":\"struct BrewlabsAggregationRouter.Trade\",\"name\":\"_trade\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"swapNoSplitToETHWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"internalType\":\"struct BrewlabsAggregationRouter.Trade\",\"name\":\"_trade\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"swapNoSplitWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedTokensCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BrewlabsAggregationRouter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000160000000000000000000000000cd3b71d65d1f03f0b2c5a4e67a17347dc71141f7000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000000000000000000000000000000000000000000060000000000000000000000005dab09861b3bcefb453612ed3e331b4792770b64000000000000000000000000ea60321b9bb6b312acb2174e9413af180fade9cc00000000000000000000000078f81d1d1f66e1ea0be841fb7caf055d1c3453b2000000000000000000000000f9c9fb47dba1391443ce6a2d6b2ec69c227bb9ad0000000000000000000000007191cc71044564974a32659fe886630e836f31480000000000000000000000003e1383a615ebf6c905a18b8b190aadb10999fa3b0000000000000000000000000000000000000000000000000000000000000007000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000001af3f329e8be154074d8769d1ffa4ee058b1dbc30000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f80000000000000000000000006aac56305825f712fd44599e59f2ede51d42c3e7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}