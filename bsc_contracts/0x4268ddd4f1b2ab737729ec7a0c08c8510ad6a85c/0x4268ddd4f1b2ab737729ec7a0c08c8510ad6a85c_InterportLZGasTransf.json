{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/OwnerManageable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\\nimport { Pausable } from '@openzeppelin/contracts/security/Pausable.sol';\\nimport { ITokenBalance } from '../interfaces/ITokenBalance.sol';\\nimport '../helpers/TransferHelper.sol' as TransferHelper;\\nimport '../Constants.sol' as Constants;\\n\\n/**\\n * @title OwnerManageable\\n * @notice OwnerManageable contract\\n */\\ncontract OwnerManageable is Ownable, Pausable {\\n    /**\\n     * @notice Enter pause state\\n     */\\n    function pause() external onlyOwner whenNotPaused {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Exit pause state\\n     */\\n    function unpause() external onlyOwner whenPaused {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @notice Performs the token cleanup\\n     * @dev Use the \\\"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\\" address for the native token\\n     * @param _tokenAddress The address of the token\\n     */\\n    function cleanup(address _tokenAddress) external onlyOwner {\\n        if (_tokenAddress == Constants.NATIVE_TOKEN_ADDRESS) {\\n            TransferHelper.safeTransferNative(msg.sender, address(this).balance);\\n        } else {\\n            TransferHelper.safeTransfer(\\n                _tokenAddress,\\n                msg.sender,\\n                ITokenBalance(_tokenAddress).balanceOf(address(this))\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Performs the token cleanup using the provided amount\\n     * @dev Use the \\\"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\\" address for the native token\\n     * @param _tokenAddress The address of the token\\n     * @param _tokenAmount The amount of the token\\n     */\\n    function cleanupWithAmount(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\\n        if (_tokenAddress == Constants.NATIVE_TOKEN_ADDRESS) {\\n            TransferHelper.safeTransferNative(msg.sender, _tokenAmount);\\n        } else {\\n            TransferHelper.safeTransfer(_tokenAddress, msg.sender, _tokenAmount);\\n        }\\n    }\\n\\n    function _initOwner(address _owner) internal {\\n        if (_owner != _msgSender() && _owner != address(0)) {\\n            _transferOwnership(_owner);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev The default token decimals value\\n */\\nuint256 constant DECIMALS_DEFAULT = 18;\\n\\n/**\\n * @dev The maximum uint256 value for swap amount limit settings\\n */\\nuint256 constant INFINITY = type(uint256).max;\\n\\n/**\\n * @dev The default limit of account list size\\n */\\nuint256 constant LIST_SIZE_LIMIT_DEFAULT = 100;\\n\\n/**\\n * @dev The limit of swap router list size\\n */\\nuint256 constant LIST_SIZE_LIMIT_ROUTERS = 200;\\n\\n/**\\n * @dev The factor for percentage settings. Example: 100 is 0.1%\\n */\\nuint256 constant MILLIPERCENT_FACTOR = 100_000;\\n\\n/**\\n * @dev The de facto standard address to denote the native token\\n */\\naddress constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\"\r\n    },\r\n    \"contracts/crosschain/layerzero/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title ILayerZeroEndpoint\\n * @notice LayerZero endpoint interface\\n */\\ninterface ILayerZeroEndpoint {\\n    /**\\n     * @notice Send a cross-chain message\\n     * @param _dstChainId The destination chain identifier\\n     * @param _destination Remote address concatenated with local address packed into 40 bytes\\n     * @param _payload The message content\\n     * @param _refundAddress Refund the additional amount to this address\\n     * @param _zroPaymentAddress The address of the ZRO token holder who would pay for the transaction\\n     * @param _adapterParam Parameters for the adapter service\\n     */\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParam\\n    ) external payable;\\n\\n    /**\\n     * @notice Cross-chain message fee estimation\\n     * @param _dstChainId The destination chain identifier\\n     * @param _userApplication The application address on the source chain\\n     * @param _payload The message content\\n     * @param _payInZRO If false, the user application pays the protocol fee in the native token\\n     * @param _adapterParam Parameters for the adapter service\\n     * @return nativeFee The native token fee for the message\\n     * @return zroFee The ZRO token fee for the message\\n     */\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\\n}\\n\"\r\n    },\r\n    \"contracts/crosschain/layerzero/interfaces/ILayerZeroRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title ILayerZeroRelayer\\n * @notice LayerZero relayer interface\\n */\\ninterface ILayerZeroRelayer {\\n    /**\\n     * @notice Destination config lookup\\n     * @param _chainId The chain identifier\\n     * @param _outboundProofType The type of the outbound proof\\n     * @return dstNativeAmtCap The native token amount cap on the destination chain\\n     * @return baseGas The base gas value\\n     * @return gasPerByte The gas value per byte\\n     */\\n    function dstConfigLookup(\\n        uint16 _chainId,\\n        uint16 _outboundProofType\\n    ) external view returns (uint128 dstNativeAmtCap, uint64 baseGas, uint64 gasPerByte);\\n}\\n\"\r\n    },\r\n    \"contracts/crosschain/layerzero/interfaces/ILayerZeroResumeReceive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title ILayerZeroResumeReceive\\n * @notice LayerZero queue unblocking interface\\n */\\ninterface ILayerZeroResumeReceive {\\n    /**\\n     * @notice Unblocks the LayerZero message queue\\n     * @param _srcChainId The source chain identifier\\n     * @param _srcAddress Remote address concatenated with local address packed into 40 bytes\\n     */\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/gas-transfer/InterportLZGasTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\nimport { ILayerZeroEndpoint } from '../crosschain/layerzero/interfaces/ILayerZeroEndpoint.sol';\\nimport { ILayerZeroRelayer } from '../crosschain/layerzero/interfaces/ILayerZeroRelayer.sol';\\nimport { ILayerZeroResumeReceive } from '../crosschain/layerzero/interfaces/ILayerZeroResumeReceive.sol';\\nimport { OwnerManageable } from '../access/OwnerManageable.sol';\\nimport { SystemVersionId } from '../SystemVersionId.sol';\\nimport '../helpers/AddressHelper.sol' as AddressHelper;\\n\\n/**\\n * @title InterportLZGasTransfer\\n * @notice Gas transfer contract\\n */\\ncontract InterportLZGasTransfer is SystemVersionId, OwnerManageable {\\n    /**\\n     * @notice Gas transfer parameter data structure\\n     * @param lzChainId LayerZero-specific chain identifier\\n     * @param recipient The address of the gas transfer recipient\\n     * @param amount Gas transfer amount\\n     * @param settings Gas transfer settings\\n     */\\n    struct GasTransferParameters {\\n        uint16 lzChainId;\\n        address recipient;\\n        uint256 amount;\\n        bytes settings;\\n    }\\n\\n    /**\\n     * @dev The address of the cross-chain endpoint\\n     */\\n    address public lzEndpoint;\\n\\n    /**\\n     * @dev The address of the cross-chain relayer\\n     */\\n    address public lzRelayer;\\n\\n    uint16 private constant LZ_ADAPTER_PARAMETERS_VERSION = 2;\\n    bytes private constant LZ_PAYLOAD_NONE = '';\\n    uint256 private minDstGas;\\n    uint256 private minReserve;\\n\\n    /**\\n     * @notice Emitted when the cross-chain endpoint contract reference is set\\n     * @param endpoint The cross-chain endpoint contract address\\n     */\\n    event SetEndpoint(address indexed endpoint);\\n\\n    /**\\n     * @notice Emitted when the cross-chain relayer contract reference is set\\n     * @param relayer The cross-chain relayer contract address\\n     */\\n    event SetRelayer(address indexed relayer);\\n\\n    /**\\n     * @notice Emitted when the parameter validation results in an error\\n     */\\n    error ValidationError();\\n\\n    /**\\n     * @notice Initializes the InterportLZGasTransfer contract\\n     * @param _lzEndpoint The cross-chain endpoint contract address\\n     * @param _lzRelayer The cross-chain relayer contract address\\n     * @param _validation The initial validation data\\n     * @param _owner The address of the initial owner of the contract\\n     */\\n    constructor(address _lzEndpoint, address _lzRelayer, bytes memory _validation, address _owner) {\\n        _setEndpoint(_lzEndpoint);\\n        _setRelayer(_lzRelayer);\\n        _setValidation(_validation);\\n\\n        _initOwner(_owner);\\n    }\\n\\n    /**\\n     * @notice The standard \\\"receive\\\" function\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @notice Performs a gas transfer action\\n     * @param _parameters Gas transfer parameters\\n     */\\n    function gasTransfer(\\n        GasTransferParameters calldata _parameters\\n    ) external payable whenNotPaused {\\n        (uint256 lzValue, address dstApp, bytes memory lzAdapterParameters) = _getEndpointData(\\n            _parameters,\\n            true\\n        );\\n\\n        ILayerZeroEndpoint(lzEndpoint).send{ value: lzValue }(\\n            _parameters.lzChainId,\\n            abi.encodePacked(dstApp, address(this)),\\n            LZ_PAYLOAD_NONE,\\n            payable(this),\\n            address(0),\\n            lzAdapterParameters\\n        );\\n    }\\n\\n    /**\\n     * @notice Receives cross-chain messages\\n     * @dev The function is called by the cross-chain endpoint\\n     */\\n    function lzReceive(uint16, bytes calldata, uint64, bytes calldata) external {}\\n\\n    /**\\n     * @notice Unblocks the cross-chain message queue\\n     * @param _lzSourceChainId The source chain identifier (LayerZero-specific)\\n     * @param _sourceApp The source chain app address\\n     */\\n    function resumeReceive(uint16 _lzSourceChainId, address _sourceApp) external {\\n        ILayerZeroResumeReceive(lzEndpoint).forceResumeReceive(\\n            _lzSourceChainId,\\n            abi.encodePacked(_sourceApp, address(this))\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the cross-chain endpoint contract reference\\n     * @param _lzEndpoint The cross-chain endpoint contract address\\n     */\\n    function setEndpoint(address _lzEndpoint) external onlyOwner {\\n        _setEndpoint(_lzEndpoint);\\n    }\\n\\n    /**\\n     * @notice Sets the cross-chain relayer contract reference\\n     * @param _lzRelayer The cross-chain relayer contract address\\n     */\\n    function setRelayer(address _lzRelayer) external onlyOwner {\\n        _setRelayer(_lzRelayer);\\n    }\\n\\n    /**\\n     * @notice Sets the validation data\\n     * @param _validation The validation data\\n     */\\n    function setValidation(bytes memory _validation) external onlyOwner {\\n        _setValidation(_validation);\\n    }\\n\\n    /**\\n     * @notice Source chain tx value estimation\\n     * @param _parameters Gas transfer parameters\\n     * @return lzValue The source chain tx value\\n     */\\n    function estimateSourceValue(\\n        GasTransferParameters calldata _parameters\\n    ) external view returns (uint256 lzValue) {\\n        (lzValue, , ) = _getEndpointData(_parameters, false);\\n    }\\n\\n    /**\\n     * @notice The native token amount cap on the destination chains\\n     * @param _lzChainIds The destination chain identifier array (LayerZero-specific)\\n     * @return The native token amount cap on the destination chains\\n     */\\n    function destinationAmountCap(\\n        uint16[] calldata _lzChainIds\\n    ) external view returns (uint128[] memory) {\\n        uint128[] memory result = new uint128[](_lzChainIds.length);\\n\\n        uint16 lzChainId;\\n        uint16 outboundProofType;\\n        uint128 cap;\\n\\n        address sendLibrary = SendLibraryProvider(lzEndpoint).getSendLibraryAddress(address(this));\\n\\n        for (uint256 index; index < _lzChainIds.length; index++) {\\n            lzChainId = _lzChainIds[index];\\n            outboundProofType = AppConfigProvider(sendLibrary)\\n                .getAppConfig(lzChainId, address(this))\\n                .outboundProofType;\\n\\n            (cap, , ) = ILayerZeroRelayer(lzRelayer).dstConfigLookup(lzChainId, outboundProofType);\\n\\n            result[index] = cap;\\n        }\\n\\n        return result;\\n    }\\n\\n    function _setEndpoint(address _lzEndpoint) private {\\n        AddressHelper.requireContract(_lzEndpoint);\\n\\n        lzEndpoint = _lzEndpoint;\\n\\n        emit SetEndpoint(_lzEndpoint);\\n    }\\n\\n    function _setRelayer(address _lzRelayer) private {\\n        AddressHelper.requireContract(_lzRelayer);\\n\\n        lzRelayer = _lzRelayer;\\n\\n        emit SetRelayer(_lzRelayer);\\n    }\\n\\n    function _setValidation(bytes memory _validation) private {\\n        (minDstGas, minReserve) = abi.decode(_validation, (uint256, uint256));\\n    }\\n\\n    function _getEndpointData(\\n        GasTransferParameters calldata _parameters,\\n        bool _validate\\n    ) private view returns (uint256 lzValue, address dstApp, bytes memory lzAdapterParameters) {\\n        uint256 dstGas;\\n\\n        (dstApp, dstGas, lzAdapterParameters) = _decodeParameters(_parameters);\\n\\n        (lzValue, ) = ILayerZeroEndpoint(lzEndpoint).estimateFees(\\n            _parameters.lzChainId,\\n            address(this),\\n            LZ_PAYLOAD_NONE,\\n            false,\\n            lzAdapterParameters\\n        );\\n\\n        if (_validate && (dstGas < minDstGas || lzValue + minReserve > msg.value)) {\\n            revert ValidationError();\\n        }\\n    }\\n\\n    function _decodeParameters(\\n        GasTransferParameters calldata _parameters\\n    ) private view returns (address dstApp, uint256 dstGas, bytes memory lzAdapterParameters) {\\n        (dstApp, dstGas) = abi.decode(_parameters.settings, (address, uint256));\\n\\n        lzAdapterParameters = abi.encodePacked(\\n            LZ_ADAPTER_PARAMETERS_VERSION,\\n            dstGas,\\n            _parameters.amount,\\n            _parameters.recipient == address(0) ? msg.sender : _parameters.recipient\\n        );\\n    }\\n}\\n\\ninterface SendLibraryProvider {\\n    function getSendLibraryAddress(\\n        address _userApplication\\n    ) external view returns (address sendLibraryAddress);\\n}\\n\\ninterface AppConfigProvider {\\n    struct ApplicationConfiguration {\\n        uint16 inboundProofLibraryVersion;\\n        uint64 inboundBlockConfirmations;\\n        address relayer;\\n        uint16 outboundProofType;\\n        uint64 outboundBlockConfirmations;\\n        address oracle;\\n    }\\n\\n    function getAppConfig(\\n        uint16 _remoteChainId,\\n        address _userApplicationAddress\\n    ) external view returns (ApplicationConfiguration memory);\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/AddressHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @notice Emitted when the account is not a contract\\n * @param account The account address\\n */\\nerror NonContractAddressError(address account);\\n\\n/**\\n * @notice Function to check if the account is a contract\\n * @return The account contract status flag\\n */\\nfunction isContract(address _account) view returns (bool) {\\n    return _account.code.length > 0;\\n}\\n\\n/**\\n * @notice Function to require an account to be a contract\\n */\\nfunction requireContract(address _account) view {\\n    if (!isContract(_account)) {\\n        revert NonContractAddressError(_account);\\n    }\\n}\\n\\n/**\\n * @notice Function to require an account to be a contract or a zero address\\n */\\nfunction requireContractOrZeroAddress(address _account) view {\\n    if (_account != address(0)) {\\n        requireContract(_account);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @notice Emitted when an approval action fails\\n */\\nerror SafeApproveError();\\n\\n/**\\n * @notice Emitted when a transfer action fails\\n */\\nerror SafeTransferError();\\n\\n/**\\n * @notice Emitted when a transferFrom action fails\\n */\\nerror SafeTransferFromError();\\n\\n/**\\n * @notice Emitted when a transfer of the native token fails\\n */\\nerror SafeTransferNativeError();\\n\\n/**\\n * @notice Safely approve the token to the account\\n * @param _token The token address\\n * @param _to The token approval recipient address\\n * @param _value The token approval amount\\n */\\nfunction safeApprove(address _token, address _to, uint256 _value) {\\n    // 0x095ea7b3 is the selector for \\\"approve(address,uint256)\\\"\\n    (bool success, bytes memory data) = _token.call(\\n        abi.encodeWithSelector(0x095ea7b3, _to, _value)\\n    );\\n\\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\\n\\n    if (!condition) {\\n        revert SafeApproveError();\\n    }\\n}\\n\\n/**\\n * @notice Safely transfer the token to the account\\n * @param _token The token address\\n * @param _to The token transfer recipient address\\n * @param _value The token transfer amount\\n */\\nfunction safeTransfer(address _token, address _to, uint256 _value) {\\n    // 0xa9059cbb is the selector for \\\"transfer(address,uint256)\\\"\\n    (bool success, bytes memory data) = _token.call(\\n        abi.encodeWithSelector(0xa9059cbb, _to, _value)\\n    );\\n\\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\\n\\n    if (!condition) {\\n        revert SafeTransferError();\\n    }\\n}\\n\\n/**\\n * @notice Safely transfer the token between the accounts\\n * @param _token The token address\\n * @param _from The token transfer source address\\n * @param _to The token transfer recipient address\\n * @param _value The token transfer amount\\n */\\nfunction safeTransferFrom(address _token, address _from, address _to, uint256 _value) {\\n    // 0x23b872dd is the selector for \\\"transferFrom(address,address,uint256)\\\"\\n    (bool success, bytes memory data) = _token.call(\\n        abi.encodeWithSelector(0x23b872dd, _from, _to, _value)\\n    );\\n\\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\\n\\n    if (!condition) {\\n        revert SafeTransferFromError();\\n    }\\n}\\n\\n/**\\n * @notice Safely transfer the native token to the account\\n * @param _to The native token transfer recipient address\\n * @param _value The native token transfer amount\\n */\\nfunction safeTransferNative(address _to, uint256 _value) {\\n    (bool success, ) = _to.call{ value: _value }(new bytes(0));\\n\\n    if (!success) {\\n        revert SafeTransferNativeError();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title ITokenBalance\\n * @notice Token balance interface\\n */\\ninterface ITokenBalance {\\n    /**\\n     * @notice Getter of the token balance by the account\\n     * @param _account The account address\\n     * @return Token balance\\n     */\\n    function balanceOf(address _account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/SystemVersionId.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title SystemVersionId\\n * @notice Base contract providing the system version identifier\\n */\\nabstract contract SystemVersionId {\\n    /**\\n     * @dev The system version identifier\\n     */\\n    uint256 public constant SYSTEM_VERSION_ID = uint256(keccak256('Initial'));\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lzEndpoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lzRelayer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_validation\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NonContractAddressError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferNativeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValidationError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"endpoint\",\"type\":\"address\"}],\"name\":\"SetEndpoint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"SetRelayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SYSTEM_VERSION_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"cleanup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"cleanupWithAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_lzChainIds\",\"type\":\"uint16[]\"}],\"name\":\"destinationAmountCap\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"\",\"type\":\"uint128[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"lzChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"settings\",\"type\":\"bytes\"}],\"internalType\":\"struct InterportLZGasTransfer.GasTransferParameters\",\"name\":\"_parameters\",\"type\":\"tuple\"}],\"name\":\"estimateSourceValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lzValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"lzChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"settings\",\"type\":\"bytes\"}],\"internalType\":\"struct InterportLZGasTransfer.GasTransferParameters\",\"name\":\"_parameters\",\"type\":\"tuple\"}],\"name\":\"gasTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzEndpoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzRelayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_lzSourceChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_sourceApp\",\"type\":\"address\"}],\"name\":\"resumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lzEndpoint\",\"type\":\"address\"}],\"name\":\"setEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lzRelayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_validation\",\"type\":\"bytes\"}],\"name\":\"setValidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InterportLZGasTransfer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003c2269811836af69497e5f486a85d7316753cf62000000000000000000000000a27a2ca24dd28ce14fb5f5844b59851f03dcf182000000000000000000000000000000000000000000000000000000000000008000000000000000000000000072e28c7f34100afefc399fcc0ae041b8fe5841ae000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000005c8f5d1a8da0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}