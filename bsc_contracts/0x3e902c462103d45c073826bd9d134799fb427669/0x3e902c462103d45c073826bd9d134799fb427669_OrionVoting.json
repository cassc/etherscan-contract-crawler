{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/base/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\nabstract contract Staking\\n{\\n    uint256 constant internal RATE_PRECISION=1e40;\\n\\n    uint256 public rewardRate;//\u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043d\u0430\u0433\u0440\u0430\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 1 ORN \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0443 \u043d\u0430 \u0432\u0441\u0435\u0445 (\u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c 10**48)\\n\\n    struct UserState\\n    {\\n        uint256 stake;\\n        uint256 rateCumulative;\\n        uint256 reward;\\n        uint256 rewardWithdraw;\\n    }\\n\\n    uint256 public allStake; //\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u0441\u0442\u0435\u0439\u043a\u043e\u0432\\n    mapping(address => UserState) public poolStake;//\u0441\u0442\u0435\u0439\u043a\u0438 \u043f\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\\n\\n    uint256 public rateCumulative;\\n    uint256 public rateTime;\\n    uint256 private rewardCumulativeTotal;//\u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u043d\u0430\u0433\u0440\u0430\u0434\\n\\n    event SetRewards(uint64 rewards, uint64 duration, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 timestamp);\\n    event Stake(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    event Unstake(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    event ClaimReward(address indexed account, uint256 amount, uint256 rewardCumulativeTotal, uint256 rateCumulative, uint256 reward, uint256 timestamp);\\n    \\n\\n    //  Set the overall reward\\n    function _setRewards(uint64 rewards, uint64 duration) internal\\n    {\\n        require(duration > 0, \\\"_setRewards: zero duration\\\");\\n\\n        _writeCumulative();\\n\\n        //  ORN / sec\\n        rewardRate = RATE_PRECISION * rewards / duration;\\n\\n        emit SetRewards(rewards, duration, rewardCumulativeTotal, rateCumulative, block.timestamp);\\n    }\\n\\n    //\u0420\u0430\u0441\u0447\u0435\u0442 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u0443\u0440\u0441\u0430 \u043d\u0430\u0433\u0440\u0430\u0434\u044b\\n    function calcNewRate() public virtual view returns (uint256)\\n    {\\n        uint256 Rate=0;\\n        if(allStake>0)\\n        {\\n            Rate=rewardRate/allStake;\\n        }\\n\\n        return Rate*(block.timestamp-rateTime);\\n    }\\n\\n    function _writeCumulative() virtual internal\\n    {\\n        uint256 newRate = calcNewRate();\\n\\n        rewardCumulativeTotal += newRate*allStake/RATE_PRECISION;\\n        rateCumulative += newRate;\\n        rateTime=block.timestamp;\\n    }\\n\\n    function _stake(address account, uint256 amount) internal\\n    {\\n        require(amount>0,\\\"_stake: zero stake amount\\\");\\n\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n        item.reward=_calcReward(item, rateCumulative);\\n        item.stake += amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        allStake += amount;\\n\\n        emit Stake(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n    function _claimReward(address account, uint256 amount) internal\\n    {\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n\\n        item.reward=_calcReward(item, rateCumulative);\\n        require(item.reward - item.rewardWithdraw >= amount,\\\"Error claim amount\\\");\\n        item.rewardWithdraw += amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        emit ClaimReward(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n    function _unstake(address account, uint256 amount) internal\\n    {\\n        _writeCumulative();\\n\\n        UserState memory item=poolStake[account];\\n        require(item.stake >= amount,\\\"Error unstake amount\\\");\\n        \\n        item.reward=_calcReward(item, rateCumulative);\\n        item.stake -= amount;\\n        item.rateCumulative=rateCumulative;\\n        poolStake[account]=item;\\n\\n        allStake -= amount;\\n\\n        emit Unstake(account, amount, rewardCumulativeTotal, rateCumulative, item.reward, block.timestamp);\\n    }\\n\\n\\n    function _calcReward(UserState memory item, uint256 _rateCumulative) internal pure returns (uint256)\\n    {\\n        return item.reward + (_rateCumulative-item.rateCumulative)*item.stake/RATE_PRECISION;\\n    }\\n\\n    function getReward(address account) public virtual view returns (uint256)\\n    {\\n        UserState memory item=poolStake[account];\\n        uint256 _rateCumulative = rateCumulative + calcNewRate();\\n        return _calcReward(item, _rateCumulative) - item.rewardWithdraw;\\n    }\\n\\n    function getStake(address account) public view returns (uint256)\\n    {\\n        return poolStake[account].stake;\\n    }\\n\\n    function getRewardWithdraw(address account) external view returns (uint256)\\n    {\\n        return poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulative(address account) external view returns (uint256)\\n    {\\n        return getReward(account) + poolStake[account].rewardWithdraw;\\n    }\\n\\n    function getRewardCumulativeAll() public view returns (uint256)\\n    {\\n        uint256 newRate = calcNewRate();\\n        return rewardCumulativeTotal + newRate*allStake/RATE_PRECISION;\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOrionFarmV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IOrionFarmV2\\n{\\n    //Action\\n    function create_lock_period(address pool, uint256 amount, uint256 lock_period) external;\\n    function increase_amount(address pool, uint256 amount) external;\\n    function increase_lock_period(address pool, uint256 new_lock_period) external;\\n    function withdraw(address pool) external;\\n    function claimReward(address pool) external;\\n\\n    function createSmartReward(address pool) external;\\n\\n    //View\\n    function getReward(address pool, address account) external view returns (uint256);\\n    function getBoost(address pool, address account) external view returns (uint256);\\n    function getStake(address pool, address account) external view returns (uint256);\\n    function allStake(address pool) external view returns (uint256);\\n    function lockTimeStart(address pool, address account) external view returns (uint48);\\n    function lockTimePeriod(address pool, address account) external view returns (uint48);\\n\\n    function libStakingReward() external view returns(address);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrionVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IOrionVoting is IStaking\\n{\\n\\n    //admin\\n    function setSmart(address addr, bool bUse) external;\\n    function setRewards(uint64 rewards, uint64 duration) external;\\n    function addPool(address pool) external;\\n    function deletePool(address pool) external;\\n\\n\\n    //user\\n    function vote(address pool, uint256 amount) external;\\n    function voteArr(address[] calldata pools, uint256[] calldata amounts) external;\\n    function unvote(address pool, uint256 amount) external;\\n    function unvoteAll(address account) external;\\n\\n    //smart\\n    function claimReward(address pool, address to, uint256 amount) external;\\n\\n    //vew\\n    function countPool() external view returns (uint256);//number of pools\\n    function poolList(uint256) external view returns (address);//list of pools\\n    function poolIndex(address pool) external view returns (uint256);//whether there is a pool in the list (index numbers starting from 1)\\n    function users(address user) external view returns (uint256);//user votes across all pools\\n    function usersPool(address user,address pool) external view returns (uint256);//user votes by pool\\n    function smarts(address smart) external view returns (bool);//white list of trusted farm contracts\\n\\n    function veORN() external view returns (address);\\n    function ORN() external view returns (address);\\n\\n    function havePool(address account) external view returns (bool);\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IStaking\\n{\\n    //staking\\n    function getReward(address account) external view returns (uint256);\\n    function getStake(address account) external view returns (uint256);\\n    function allStake() external view returns (uint256);\\n    function rewardRate() external view returns (uint256);\\n    function rateCumulative() external view returns (uint256);\\n    function rateTime() external view returns (uint256);\\n\\n\\n    function getRewardWithdraw(address account) external view returns (uint256);\\n    function getRewardCumulative(address account) external view returns (uint256);\\n    function getRewardCumulativeAll() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITWBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface ITWBalance\\n{\\n    struct TWItem\\n    {\\n        // the block timestamp\\n        uint48  timestamp;        \\n        // the amount accumulator, i.e. amount * time elapsed\\n        uint208 amountTW;\\n    }\\n\\n    /// @notice Returns the time weight (TW) amount of tokens in existence.\\n    function totalSupplyTW() external view returns (TWItem memory);\\n\\n    /// @notice Calculates the average aamount of tokens in existence from the specified TW period\\n    function totalSupplyAvg(TWItem memory itemStart) view external returns (uint256);\\n\\n    /// @notice Returns the time weight (TW) balance of a token\\n    /// @param user The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOfTW(address user) external view returns (TWItem memory);\\n    \\n    /// @notice Calculates the average address balance from the specified TW period\\n    function balanceOfAvg(address user, TWItem memory itemStart) view external returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IveORN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ITWBalance.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IveORN is ITWBalance,IStaking\\n{\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n    function totalSupply(uint256 ts) external view returns (uint256);\\n    function totalSupply0() external view returns (uint256);//balance on start timestamp\\n\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n    function balanceOf(address account, uint256 ts) external view returns (uint256);\\n    function balanceOf0(address account) external view returns (uint256);//balance on start timestamp\\n\\n    function balanceTokenOf(address account) external view  returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n    \\n    function name() pure external returns(string memory);\\n    function symbol() pure external returns(string memory);\\n \\n\\n    function ORN() external view returns (address);\\n\\n    function lockTime(address account) external view returns (uint48);\\n\\n    \\n    //staking ORN\\n    function create_lock(uint256 _value, uint256 _unlock_time) external;\\n    //function deposit_for(address _addr, uint256 _value) external;\\n    function increase_amount(uint256 _value) external;\\n    function increase_unlock_time(uint256 _unlock_time) external;\\n    function increase_unlock_period(uint256 unlock_period) external;\\n    function create_lock_period(uint256 _value, uint256 unlock_period) external;\\n\\n    function withdraw() external;\\n    function claimReward() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.7;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OrionVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./base/Staking.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./interfaces/IveORN.sol\\\";\\nimport \\\"./interfaces/IOrionVoting.sol\\\";\\nimport \\\"./interfaces/IOrionFarmV2.sol\\\";\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\ncontract OrionVoting is Staking\\n{\\n    uint256 constant MAX_PERCENT=10000;\\n\\n    uint256 public countPool;//number of pools\\n    mapping(uint256 => address) public poolList;//list of pools\\n    mapping(address => uint256) public poolIndex;//whether there is a pool in the list (index numbers starting from 1)\\n\\n    mapping(address => uint256) public users;//user votes across all pools\\n    mapping(address => mapping(address => uint256)) public usersPool;//user votes by pool\\n\\n    mapping(address => bool) public smarts;//white list of trusted farm contracts\\n\\n    address public immutable veORN;\\n    address public immutable ORN;\\n    address public immutable smartOwner;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == smartOwner, \\\"Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    event UsePool(address indexed pool, bool bUse);\\n    event Vote(address indexed pool, address indexed account, uint256 amount);\\n    event Unvote(address indexed pool, address indexed account, uint256 amount);\\n    event UnvoteAll(address indexed account);\\n    \\n\\n    constructor(address veORN_)\\n    {\\n        veORN=veORN_;\\n        ORN=IveORN(veORN).ORN();\\n        smartOwner=msg.sender;\\n    }\\n\\n    //admin caller\\n\\n    function setSmart(address addr, bool bUse) onlyOwner external\\n    {\\n        smarts[addr]=bUse;\\n    }\\n    \\n\\n    function setRewards(uint64 rewards, uint64 duration) onlyOwner external\\n    {\\n        _setRewards(rewards,duration);\\n    }\\n\\n    function addPool(address pool) onlyOwner public\\n    {\\n        countPool++;\\n        poolIndex[pool]=countPool;\\n        poolList[countPool]=pool;\\n\\n        emit UsePool(pool, true);\\n    }\\n\\n    function deletePool(address pool) onlyOwner external\\n    {\\n        uint256 index=poolIndex[pool];\\n        require(index>0,\\\"Pool not found\\\");\\n        delete poolIndex[pool];\\n\\n        //we move the last element to the place of the deleted one and delete the last element\\n        poolList[index]=poolList[countPool];\\n        \\n        delete poolList[countPool];\\n        countPool--;\\n\\n        emit UsePool(pool, false);\\n    }\\n\\n    //smart caller\\n\\n    function claimReward(address pool, address to, uint256 amount) external\\n    {\\n        require(smarts[msg.sender],\\\"claimReward: caller not found in white list\\\");\\n\\n        _claimReward(pool,amount);\\n\\n        TransferHelper.safeTransfer(ORN,to,amount);\\n    }\\n\\n\\n    //user caller\\n    function votePercent(address pool, uint256 percent) external\\n    {\\n        require(percent<=MAX_PERCENT,\\\"Error percent\\\");\\n        uint256 balanceVeORN=IveORN(veORN).balanceOf0(msg.sender);\\n        vote(pool, balanceVeORN*percent/MAX_PERCENT);\\n    }\\n\\n    function vote(address pool, uint256 amount) public\\n    {\\n        require(poolIndex[pool]>0,\\\"Pool not found\\\");\\n\\n        //check balance\\n        uint256 balanceVeORN=IveORN(veORN).balanceOf0(msg.sender);\\n        uint256 balanceVotes=users[msg.sender];\\n        //require(balanceVeORN >= balanceVotes+amount,\\\"Error user veORN balance\\\");// and revert if overflow\\n        uint256 balanceRemained;\\n        if(balanceVeORN>balanceVotes)\\n            balanceRemained=balanceVeORN-balanceVotes;\\n        if(amount>balanceRemained)\\n            amount=balanceRemained;\\n\\n\\n        users[msg.sender] += amount;\\n        usersPool[msg.sender][pool] += amount;\\n\\n        _stake(pool, amount);\\n\\n        emit Vote(pool, msg.sender, amount);\\n    }\\n    \\n    function unvotePercent(address pool, uint256 percent) external\\n    {\\n        require(percent<=MAX_PERCENT,\\\"Error percent\\\");\\n        uint256 balanceVeORN=IveORN(veORN).balanceOf0(msg.sender);\\n        unvote(pool, balanceVeORN*percent/MAX_PERCENT);\\n    }\\n\\n    function unvote(address pool, uint256 amount) public\\n    {\\n        if(usersPool[msg.sender][pool]>amount)\\n        {\\n            usersPool[msg.sender][pool] -= amount;\\n        }\\n        else\\n        {\\n            amount=usersPool[msg.sender][pool];\\n            delete usersPool[msg.sender][pool];\\n        }\\n        if(users[msg.sender]>amount)\\n        {\\n            users[msg.sender] -= amount;\\n        }\\n        else\\n        {\\n            amount=users[msg.sender];\\n            delete users[msg.sender];\\n        }\\n\\n        _unstake(pool, amount);\\n\\n        emit Unvote(pool, msg.sender, amount);\\n    }\\n\\n    //array call support\\n    function voteArr(address[] calldata pools, uint256[] calldata amounts) external\\n    {\\n        require(pools.length == amounts.length,\\\"Pool not found\\\");\\n\\n        for(uint256 i=0;i<pools.length;i++)\\n            vote(pools[i], amounts[i]);\\n    }\\n\\n\\n    //user or smart caller\\n\\n    function unvoteAll(address account) external\\n    {\\n        require(msg.sender == veORN || msg.sender==account, \\\"unvoteAll: caller is not the veORN contract\\\");\\n\\n        uint256 balanceVotes=users[account];\\n        if(balanceVotes>0)\\n        {\\n            uint256 _countPool=countPool;\\n            for(uint256 i=1; i<=_countPool; i++)\\n            {\\n                address pool=poolList[i];\\n                uint256 amount=usersPool[account][pool];\\n\\n                if(amount>0)\\n                {\\n                    usersPool[account][pool] = 0;\\n                    _unstake(pool, amount);\\n\\n                    balanceVotes -= amount;\\n                    if(balanceVotes==0) \\n                        break;\\n                }\\n\\n            }\\n            users[account]=0;\\n\\n            emit UnvoteAll(account);        \\n        }\\n    }\\n\\n    function addPool2(address pool, address farmv2) external\\n    {\\n        //\u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0443\u043b\u0430 \u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u043d\u0430\u0433\u0440\u0430\u0434 \u0434\u043b\u044f \u043f\u0443\u043b\u043e\u0432 v2\\n        addPool(pool);//check owner\\n        IOrionFarmV2(farmv2).createSmartReward(pool);\\n    }\\n\\n    //view\\n    function havePool(address account) external view returns (bool)\\n    {\\n        return poolIndex[account]>0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"veORN_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"rewards\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SetRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCumulativeTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unvote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnvoteAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"bUse\",\"type\":\"bool\"}],\"name\":\"UsePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ORN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"farmv2\",\"type\":\"address\"}],\"name\":\"addPool2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcNewRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"deletePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardCumulativeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"havePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateCumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateCumulative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rewards\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"}],\"name\":\"setRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"bUse\",\"type\":\"bool\"}],\"name\":\"setSmart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"smarts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unvote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unvoteAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"unvotePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veORN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"voteArr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"votePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrionVoting", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d2c8b8915c8d8548bf4f16a8cdce73de7796c39e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}