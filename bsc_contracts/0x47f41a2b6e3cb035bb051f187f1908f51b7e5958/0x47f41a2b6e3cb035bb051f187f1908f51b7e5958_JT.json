{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(\r\n        address account\r\n    ) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            msg.sender,\r\n            _allowances[sender][msg.sender].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) public virtual returns (bool) {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) public virtual returns (bool) {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(\r\n            amount,\r\n            \"ERC20: burn amount exceeds balance\"\r\n        );\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address);\r\n}\r\n\r\ncontract JT001{\r\n    function getInviter(address recipient) public view returns (address) {}\r\n}\r\n\r\ncontract TokenDistributor {\r\n    constructor (address token)  {\r\n       (bool success, ) = token.call(abi.encodeWithSignature(\"approve(address,uint256)\",msg.sender, ~uint256(0)));\r\n       require(success);\r\n    }\r\n}\r\n\r\ncontract JT is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IUniswapV2Router02 public _swapRouter;\r\n    address public _mainPair;\r\n    bool private swapping;\r\n    ETHBackDividendTracker public dividendTracker;\r\n    JT001 public _jtBindRouter;\r\n\r\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    address public immutable ETH;\r\n\r\n    uint256 public swapTokensAtAmount;\r\n\r\n    mapping(address => bool) public _rewardList;\r\n\r\n    uint256[] public inviterRewardPercentList;\r\n    uint256 public totalInvitorFee;\r\n\r\n    uint256 public buy_marketingFee;\r\n    uint256 public buy_liquidityFee;\r\n    uint256 public buy_ETHRewardsFee;\r\n    uint256 public buy_totalFees;\r\n    uint256 public buy_burnFee;\r\n    uint256 public transferFee;\r\n\r\n    uint256 public sell_marketingFee;\r\n    uint256 public sell_liquidityFee;\r\n    uint256 public sell_ETHRewardsFee;\r\n    uint256 public sell_totalFees;\r\n    uint256 public sell_burnFee;\r\n\r\n    bool private enableOffTrade;\r\n    bool private enableKillBlock;\r\n    bool private enableRewardList;\r\n    bool private enableSwapLimit;\r\n    bool private enableWalletLimit;\r\n    bool private enableChangeTax;\r\n    bool private enableSwapWhiteList = true;\r\n    bool private enableWhiteList = true;\r\n\r\n    address private fundAddress;\r\n    address private ReceiveAddress;\r\n\r\n    address[] private fundManAddr;\r\n    uint256[] private fundManRatio;\r\n    TokenDistributor public _tokenDistributor;\r\n\r\n    address USDTAddress = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    address public _swapRouterAddress;\r\n\r\n    address private bindRouterAddress;\r\n\r\n    uint256 private kb = 0;\r\n    uint256 private maxSellAmount;\r\n    uint256 private maxBuyAmount;\r\n    uint256 private maxWalletAmount;\r\n    uint256 public startTradeBlock;\r\n    uint256 public mushHoldNum;\r\n\r\n    bool private enableTransferFee = false;\r\n    bool private swapAndLiquifyEnabled = true;\r\n    uint256 private airdropNumbs = 1;\r\n\r\n    bool public isLaunch;\r\n\r\n    uint256 public gasForProcessing = 300000;\r\n\r\n    mapping(address => bool) public _feeWhiteList;\r\n\r\n    mapping(address => bool) public _swapPairList;\r\n\r\n    mapping(address => bool) private _swapWhiteList;\r\n\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity\r\n    );\r\n\r\n    event SendDividends(uint256 tokensSwapped, uint256 amount);\r\n\r\n    event ProcessedDividendTracker(\r\n        uint256 iterations,\r\n        uint256 claims,\r\n        uint256 lastProcessedIndex,\r\n        bool indexed automatic,\r\n        uint256 gas,\r\n        address indexed processor\r\n    );\r\n\r\n    constructor(\r\n        string[] memory stringParams,\r\n        address[] memory addressParams,\r\n        address[] memory fundManAddrParams,\r\n        uint256[] memory fundManRatioParams,\r\n        uint256[] memory numberParams,\r\n        bool[] memory boolParams\r\n    ) ERC20(stringParams[0], stringParams[1]) {\r\n        maxBuyAmount = numberParams[0];\r\n        maxSellAmount = numberParams[1];\r\n        require(\r\n            maxSellAmount >= maxBuyAmount,\r\n            \" maxSell should be > than maxBuy \"\r\n        );\r\n        maxWalletAmount = numberParams[2];\r\n\r\n        buy_marketingFee = numberParams[3];\r\n        buy_liquidityFee = numberParams[4];\r\n        buy_ETHRewardsFee = numberParams[5];\r\n        buy_totalFees = buy_ETHRewardsFee.add(buy_liquidityFee).add(\r\n            buy_marketingFee\r\n        );\r\n        buy_burnFee = numberParams[6];\r\n\r\n        sell_marketingFee = numberParams[7];\r\n        sell_liquidityFee = numberParams[8];\r\n        sell_ETHRewardsFee = numberParams[9];\r\n        sell_totalFees = sell_ETHRewardsFee.add(sell_liquidityFee).add(\r\n            sell_marketingFee\r\n        );\r\n        sell_burnFee = numberParams[10];\r\n        inviterRewardPercentList = new uint256[](2);\r\n        inviterRewardPercentList[0] = buy_ETHRewardsFee.div(2);\r\n        inviterRewardPercentList[1] = buy_ETHRewardsFee-inviterRewardPercentList[0];\r\n\r\n        require(buy_totalFees + buy_burnFee < 2500, \"buy fee too high\");\r\n        require(sell_totalFees + sell_burnFee < 2500, \"sell fee too high\");\r\n\r\n        uint256 __totalSupply = numberParams[11];\r\n        //\r\n        fundAddress = address(addressParams[0]);\r\n        ETH = addressParams[1];\r\n        _swapRouterAddress = addressParams[2];\r\n\r\n        bindRouterAddress = addressParams[3];\r\n\r\n        fundManAddr = fundManAddrParams;\r\n        fundManRatio = fundManRatioParams;\r\n\r\n        mushHoldNum = numberParams[12];//\r\n        kb = numberParams[13]; // \r\n        require(airdropNumbs <= 3, \"airdropNumbs should be <= 3\");\r\n\r\n        dividendTracker = new ETHBackDividendTracker(mushHoldNum,addressParams[1]);\r\n\r\n        swapTokensAtAmount = __totalSupply / 10000000;\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_swapRouterAddress);\r\n\r\n        //\r\n        _jtBindRouter = JT001(bindRouterAddress);\r\n\r\n        address __mainPair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), USDTAddress);\r\n        _tokenDistributor = new TokenDistributor(USDTAddress);\r\n\r\n        enableOffTrade = boolParams[0];//\r\n        enableKillBlock = boolParams[1];//\r\n        enableRewardList = boolParams[2];//\r\n        enableSwapLimit = boolParams[3];//\r\n        enableWalletLimit = boolParams[4];//\r\n        enableChangeTax = boolParams[5];//\r\n        enableTransferFee = true;//\r\n        if (enableTransferFee) {\r\n            transferFee = 700;\r\n        }\r\n        _swapRouter = _uniswapV2Router;\r\n        _mainPair = __mainPair;\r\n\r\n        _setAutomatedMarketMakerPair(__mainPair, true);\r\n\r\n        ReceiveAddress = msg.sender;\r\n        _approve(ReceiveAddress, _swapRouterAddress, ~uint256(0));\r\n\r\n        dividendTracker.excludeFromDividends(address(dividendTracker));\r\n        dividendTracker.excludeFromDividends(address(this));\r\n        dividendTracker.excludedFromDividends(ReceiveAddress);\r\n        dividendTracker.excludeFromDividends(deadWallet);\r\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\r\n        dividendTracker.excludeFromDividends(address(_jtBindRouter));\r\n        _whiteList[ReceiveAddress] = true;\r\n        _whiteList[address(this)] = true;\r\n        _whiteList[deadWallet] = true;\r\n        _whiteList[_mainPair] = true;\r\n        _whiteList[address(_uniswapV2Router)] = true;\r\n        _whiteList[address(dividendTracker)] = true;\r\n        _feeWhiteList[ReceiveAddress] = true;\r\n        _feeWhiteList[fundAddress] = true;\r\n        _feeWhiteList[address(this)] = true;\r\n        _swapWhiteList[ReceiveAddress] = true;\r\n        _swapWhiteList[address(this)] = true;\r\n        _swapWhiteList[deadWallet] = true;\r\n        _swapWhiteList[_mainPair] = true;\r\n        _swapWhiteList[address(_uniswapV2Router)] = true;\r\n        _swapWhiteList[address(dividendTracker)] = true;\r\n\r\n        _mint(ReceiveAddress, __totalSupply);\r\n    }\r\n\r\n    function setSwapTokensAtAmount(uint256 newValue) public onlyOwner {\r\n        swapTokensAtAmount = newValue;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function changeSwapLimit(\r\n        uint256 _buyamount,\r\n        uint256 _sellamount\r\n    ) external onlyOwner {\r\n        maxBuyAmount = _buyamount;\r\n        maxSellAmount = _sellamount;\r\n        require(\r\n            maxSellAmount >= maxBuyAmount,\r\n            \" maxSell should be > than maxBuy \"\r\n        );\r\n    }\r\n\r\n    function changeWalletLimit(uint256 _amount) external onlyOwner {\r\n        maxWalletAmount = _amount;\r\n    }\r\n\r\n    function setMinHoldCount(uint256 _amount) external onlyOwner {\r\n        mushHoldNum = _amount;\r\n    }\r\n\r\n    function changeSwapLimit(bool status) public onlyOwner {\r\n        enableSwapLimit = status;\r\n    }\r\n\r\n    function changeWalletLimit(bool status) public onlyOwner {\r\n        enableWalletLimit = status;\r\n    }\r\n\r\n    function disableChangeTax() public onlyOwner {\r\n        enableChangeTax = false;\r\n    }\r\n\r\n    function superDisableWhiteListAndLimit() public onlyOwner {\r\n        enableSwapLimit = false;\r\n        enableWalletLimit = false;\r\n        enableSwapWhiteList = false;\r\n        enableWhiteList = false;\r\n    }\r\n\r\n    function disableSwapWhiteList() public onlyOwner {\r\n        enableSwapWhiteList = false;\r\n    }\r\n\r\n    function disableWhiteList() public onlyOwner{\r\n        enableWhiteList = false;\r\n    }\r\n\r\n    function launch() public onlyOwner {\r\n        require(enableOffTrade, \"enableOffTrade false\");\r\n        isLaunch = true;\r\n        startTradeBlock = block.number;\r\n    }\r\n\r\n    function stopLaunch() public onlyOwner {\r\n        require(enableOffTrade, \"enableOffTrade false\");\r\n        isLaunch = false;\r\n    }\r\n\r\n    function setKillBlock(uint256 killBlockNumber) public onlyOwner {\r\n        require(enableKillBlock, \"enableKillBlock false\");\r\n        kb = killBlockNumber;\r\n    }\r\n\r\n    function setFeeWhiteList(\r\n        address[] calldata addr,\r\n        bool enable\r\n    ) public onlyOwner {\r\n        for (uint256 i = 0; i < addr.length; i++) {\r\n            _feeWhiteList[addr[i]] = enable;\r\n        }\r\n    }\r\n\r\n    function setSwapWhiteList(address[] calldata addr, bool enable) public onlyOwner  {\r\n        for (uint256 i = 0; i < addr.length; i++) {\r\n            _swapWhiteList[addr[i]] = enable;\r\n        }\r\n    }\r\n\r\n    function setJtBindRouter(address newJtBindRouter) public onlyOwner {\r\n        _jtBindRouter = JT001(newJtBindRouter);\r\n    }\r\n\r\n    \r\n    function setFundAddress(address payable wallet) external onlyOwner {\r\n        fundAddress = wallet;\r\n    }\r\n\r\n\r\n    function setFundManAndRatioList(address[] calldata addr,uint[] calldata ratio) public onlyOwner {\r\n        require(addr.length==ratio.length,\"wrong! Length mismatched\");\r\n        fundManAddr = addr;\r\n        fundManRatio = ratio;\r\n    }\r\n\r\n    function completeCustoms(uint256[] calldata customs) external onlyOwner {\r\n        require(enableChangeTax, \"tax change disabled\");\r\n        buy_marketingFee = customs[0];\r\n        buy_liquidityFee = customs[1];\r\n        buy_ETHRewardsFee = customs[2];\r\n        buy_totalFees = buy_ETHRewardsFee.add(buy_liquidityFee).add(\r\n            buy_marketingFee\r\n        );\r\n        buy_burnFee = customs[3];\r\n\r\n        sell_marketingFee = customs[4];\r\n        sell_liquidityFee = customs[5];\r\n        sell_ETHRewardsFee = customs[6];\r\n        sell_totalFees = sell_ETHRewardsFee.add(sell_liquidityFee).add(\r\n            sell_marketingFee\r\n        );\r\n        sell_burnFee = customs[7];\r\n        require(buy_totalFees + buy_burnFee < 2500, \"buy fee too high\");\r\n        require(sell_totalFees + sell_burnFee < 2500, \"sell fee too high\");\r\n    }\r\n    function setSwapPairList(address addr, bool enable) public onlyOwner {\r\n        require(\r\n            addr != _mainPair,\r\n            \"ETHBack: The PanETHSwap pair cannot be removed from _swapPairList\"\r\n        );\r\n        _setAutomatedMarketMakerPair(addr, enable);\r\n    }\r\n    function multi_bclist(address[] calldata addresses,bool value) public onlyOwner {\r\n        require(enableRewardList, \"enableRewardList false\");\r\n        require(addresses.length < 201);\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            _rewardList[addresses[i]] = value;\r\n        }\r\n    }\r\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n        require(\r\n            _swapPairList[pair] != value,\r\n            \"ETHBack: Automated market maker pair is already set to that value\"\r\n        );\r\n        _swapPairList[pair] = value;\r\n        if (value) {\r\n            dividendTracker.excludeFromDividends(pair);\r\n        }\r\n    }\r\n    mapping(address => bool) private _whiteList;\r\n    function setWhiteList(address[] calldata addr, bool enable) public onlyOwner  {\r\n        for (uint256 i = 0; i < addr.length; i++) {\r\n            _whiteList[addr[i]] = enable;\r\n        }\r\n    }\r\n    function excludeFromDividends(address account) external onlyOwner {\r\n        dividendTracker.excludeFromDividends(account);\r\n    }\r\n    function processDividendTracker(uint256 gas) external {\r\n        (\r\n            uint256 iterations,\r\n            uint256 claims,\r\n            uint256 lastProcessedIndex\r\n        ) = dividendTracker.process(gas);\r\n        emit ProcessedDividendTracker(\r\n            iterations,\r\n            claims,\r\n            lastProcessedIndex,\r\n            false,\r\n            gas,\r\n            tx.origin\r\n        );\r\n    }\r\n    function claim() external {\r\n        dividendTracker.processAccount(payable(msg.sender), false);\r\n    }\r\n    function isReward(address account) public view returns (uint256) {\r\n        if (_rewardList[account]) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    function setSwapAndLiquifyEnabled(bool status) public onlyOwner {\r\n        swapAndLiquifyEnabled = status;\r\n    }\r\n    function setEnableTransferFee(bool status) public onlyOwner {\r\n        // enableTransferFee = status;\r\n        if (status) {\r\n            transferFee = 700 ;\r\n        } else {\r\n            transferFee = 0;\r\n        }\r\n    }\r\n    function setAirdropNumbs(uint256 newValue) public onlyOwner {\r\n        require(newValue <= 3, \"newValue must <= 3\");\r\n        airdropNumbs = newValue;\r\n    }\r\n    function setTransferFee(uint256 newValue) public onlyOwner {\r\n        require(newValue <= 2500, \"transfer > 25 !\");\r\n        transferFee = newValue;\r\n    }\r\n    bool public enableInviter = true;\r\n    function setEnableInvitor(bool status) public onlyOwner {\r\n        enableInviter = status;\r\n    }\r\n    bool public enableJT001 = true;\r\n    function setEnableJT001(bool status) public onlyOwner{\r\n        enableJT001 = status;\r\n    }\r\n    function setInvitorRewardPercentList(uint256[] calldata newValue) public onlyOwner {\r\n        require(newValue.length <= 2, \"length should be <= 2 !\");\r\n        inviterRewardPercentList = new uint256[](newValue.length);\r\n        totalInvitorFee = 0;\r\n        for (uint256 i = 0; i < newValue.length; i++) {\r\n            inviterRewardPercentList[i] = newValue[i];\r\n            totalInvitorFee += inviterRewardPercentList[i];\r\n        }\r\n        require(totalInvitorFee< buy_totalFees, \"totalInvitorFee too high\");\r\n    }\r\n    mapping(address => address) public _inviter;\r\n    mapping(address => uint256) public _inviterNum;\r\n    mapping(address => mapping(address => bool)) public _inviterHold;\r\n    uint256 private beInvitorThreshold =  mushHoldNum ;\r\n    function setBeInvitorThreshold(uint256 newValue) public onlyOwner {\r\n        beInvitorThreshold = newValue;\r\n    }\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(isReward(from) <= 0, \"isReward > 0 !\");\r\n        if(enableSwapWhiteList){\r\n            require(_swapWhiteList[to],\"Fail!\");\r\n        }\r\n        if(enableWhiteList){\r\n            require(_whiteList[to],\"fail!\");\r\n        }\r\n        if (amount == 0) {\r\n            super._transfer(from, to, amount);\r\n            return;\r\n        }\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n        uint256 numTokensSellToFund = amount;\r\n        if (numTokensSellToFund > contractTokenBalance) {\r\n            numTokensSellToFund = contractTokenBalance;\r\n        }\r\n        if (\r\n            canSwap &&\r\n            !swapping &&\r\n            !_swapPairList[from] &&\r\n            !_feeWhiteList[from] &&\r\n            !_feeWhiteList[to] &&\r\n            swapAndLiquifyEnabled &&\r\n            (buy_totalFees + sell_totalFees) > 0\r\n        ) {\r\n            swapping = true;\r\n            uint256 marketingTokens = numTokensSellToFund\r\n                .mul(buy_marketingFee + sell_marketingFee)\r\n                .div(buy_totalFees + sell_totalFees);\r\n            if (marketingTokens > 0) swapAndSendToFee(marketingTokens);\r\n            uint256 swapTokens = numTokensSellToFund\r\n                .mul(buy_liquidityFee + sell_liquidityFee)\r\n                .div(buy_totalFees + sell_totalFees);\r\n            if (swapTokens > 0) swapAndLiquify(swapTokens);\r\n            uint256 sellTokens = numTokensSellToFund -marketingTokens -swapTokens;\r\n            if (sellTokens > 0) swapAndSendDividends(sellTokens);\r\n            swapping = false;\r\n        }\r\n        bool takeFee = !swapping;\r\n        if (_feeWhiteList[from] || _feeWhiteList[to]) {\r\n            takeFee = false;\r\n        }\r\n        if (takeFee) {\r\n            if (enableOffTrade && (_swapPairList[from] || _swapPairList[to])) {\r\n                require(isLaunch, \"ERC20: Transfer not open\");\r\n            }\r\n            if (enableSwapLimit) {\r\n                if (_swapPairList[from]) {\r\n                    require(amount <= maxBuyAmount, \"ERC20: > max tx amount\");\r\n                } else {\r\n                    require(amount <= maxSellAmount, \"ERC20: > max tx amount\");\r\n                }\r\n            }\r\n            if (from == _mainPair) {\r\n                if (enableWalletLimit) {\r\n                    require(amount.add(balanceOf(to)) <= maxWalletAmount,\"ERC20: > max wallet amount\");\r\n                }\r\n                if (startTradeBlock + kb > block.number && enableRewardList && enableKillBlock) {\r\n                    _rewardList[to] = true;//\r\n                }\r\n            }\r\n            uint256 fees;\r\n            uint256 inviterFees;\r\n            address inviterOrNormal = _jtBindRouter.getInviter(to);\r\n            uint256 burnAmount;\r\n            if(!_swapPairList[from]&&!_swapPairList[to]){\r\n                fees = 0;\r\n                inviterFees = 0;\r\n                burnAmount = amount.mul(transferFee).div(10000);\r\n            }else if(_swapPairList[from]&&!_swapPairList[to]){\r\n                burnAmount = amount.mul(buy_burnFee).div(10000);\r\n                if(enableJT001){\r\n                    if(address(0)!=inviterOrNormal){\r\n                        inviterFees = amount.mul(300).div(10000);\r\n                        fees = amount.mul(buy_totalFees.sub(300)).div(10000);\r\n                    }else{\r\n                        fees = amount.mul(buy_totalFees).div(10000);\r\n                        inviterFees = 0;\r\n                    }\r\n                }else{\r\n                    fees = amount.mul(buy_totalFees).div(10000);\r\n                    inviterFees = 0;\r\n                }\r\n            }else{\r\n                burnAmount = amount.mul(sell_burnFee).div(10000);\r\n                fees = amount.mul(sell_totalFees).div(10000);\r\n                inviterFees = 0;\r\n            }\r\n            if (enableInviter && inviterFees!=0) {\r\n                address current;\r\n                current = to;\r\n                uint256 totalShare = 0;\r\n                for (uint256 i; i < inviterRewardPercentList.length; i++) {\r\n                    totalShare += inviterRewardPercentList[i];\r\n                }\r\n                if (totalShare != 0){//\r\n                    for (uint256 i; i < inviterRewardPercentList.length; ++i) {\r\n                        address inviter = _jtBindRouter.getInviter(current);\r\n                        if (address(0) != inviter && balanceOf(inviter)>=beInvitorThreshold) {\r\n                            _inviter[current] = inviter;\r\n                            if(i == 0){\r\n                                if(balanceOf(current)>=beInvitorThreshold){\r\n                                    if(!_inviterHold[inviter][current]){\r\n                                        _inviterHold[inviter][current] = true;\r\n                                        _inviterNum[inviter] = _inviterNum[inviter].add(1);\r\n                                    }\r\n                                    super._transfer(from, inviter, inviterFees.mul(inviterRewardPercentList[i]).div(totalShare));\r\n                                }else{\r\n                                    if(_inviterHold[inviter][current]&&_inviterNum[inviter]>0){\r\n                                        _inviterHold[inviter][current] = false;\r\n                                        _inviterNum[inviter] = _inviterNum[inviter].sub(1);\r\n                                    }\r\n                                    super._transfer(from, address(this), inviterFees.mul(inviterRewardPercentList[i]).div(totalShare));\r\n                                } \r\n                            }else{\r\n                                if(balanceOf(current)>=beInvitorThreshold){\r\n                                    if(!_inviterHold[inviter][current]){\r\n                                        _inviterHold[inviter][current] = true;\r\n                                        _inviterNum[inviter] = _inviterNum[inviter].add(1);\r\n                                    }\r\n                                    if(_inviterNum[inviter]>=5){\r\n                                        super._transfer(from, inviter, inviterFees.mul(inviterRewardPercentList[i]).div(totalShare));\r\n                                    }else{\r\n                                        super._transfer(from, address(this), inviterFees.mul(inviterRewardPercentList[i]).div(totalShare));\r\n                                    }\r\n                                }else{\r\n                                    if(_inviterHold[inviter][current]&&_inviterNum[inviter]>0){\r\n                                        _inviterHold[inviter][current] = false;\r\n                                        _inviterNum[inviter] = _inviterNum[inviter].sub(1);\r\n                                    }\r\n                                    if(_inviterNum[inviter]>=5){\r\n                                        super._transfer(from, inviter, inviterFees.mul(inviterRewardPercentList[i]).div(totalShare));\r\n                                    }else{\r\n                                        super._transfer(from, address(this), inviterFees.mul(inviterRewardPercentList[i]).div(totalShare));\r\n                                    }\r\n                                }   \r\n                            }\r\n                        }else{\r\n                            super._transfer(from, address(this), inviterFees.mul(inviterRewardPercentList[i]).div(totalShare));\r\n                        }\r\n                        current = inviter;\r\n                    }\r\n                    amount = amount.sub(inviterFees);\r\n                }\r\n            }\r\n            if (burnAmount > 0) {\r\n                super._transfer(from, address(0xdead), burnAmount);\r\n                amount = amount.sub(burnAmount);\r\n            }\r\n            amount = amount.sub(fees);\r\n            super._transfer(from, address(this), fees);\r\n            if (airdropNumbs > 0) {\r\n                for (uint256 a = 0; a < airdropNumbs; a++) {\r\n                    super._transfer(\r\n                        from,\r\n                        address(\r\n                            uint160(\r\n                                uint256(\r\n                                    keccak256(\r\n                                        abi.encodePacked(\r\n                                            a,\r\n                                            block.number,\r\n                                            block.difficulty,\r\n                                            block.timestamp\r\n                                        )\r\n                                    )\r\n                                )\r\n                            )\r\n                        ),\r\n                        1\r\n                    );\r\n                }\r\n                amount = amount.sub(airdropNumbs);\r\n            }\r\n        }\r\n        super._transfer(from, to, amount);\r\n        try\r\n            dividendTracker.setBalance(payable(from), balanceOf(from))\r\n        {} catch {}\r\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\r\n\r\n        if (!swapping) {\r\n            uint256 gas = gasForProcessing;\r\n\r\n            try dividendTracker.process(gas) returns (\r\n                uint256 iterations,\r\n                uint256 claims,\r\n                uint256 lastProcessedIndex\r\n            ) {\r\n                emit ProcessedDividendTracker(\r\n                    iterations,\r\n                    claims,\r\n                    lastProcessedIndex,\r\n                    true,\r\n                    gas,\r\n                    tx.origin\r\n                );\r\n            } catch {}\r\n        }\r\n    }\r\n\r\n    function swapAndSendToFee(uint256 tokens) private {\r\n        uint256 initialETHBalance = IERC20(ETH).balanceOf(address(this));\r\n        swapTokensForETH(tokens);\r\n        uint256 newBalance = (IERC20(ETH).balanceOf(address(this))).sub(initialETHBalance);\r\n        uint256 fundBalance = newBalance.mul(130).div(300);\r\n        IERC20(ETH).transfer(fundAddress, fundBalance);\r\n        uint256 fundManBalance = newBalance-fundBalance;\r\n        uint256 lastFundManBalance = fundManBalance;\r\n        uint256 currentFundManBalance;\r\n        uint256 totalShare = 0;\r\n        for(uint256 i=0;i<fundManRatio.length;i++){\r\n            totalShare += fundManRatio[i];\r\n        }\r\n        if (totalShare > 0){\r\n            for(uint256 i=0;i<fundManRatio.length-1;i++){\r\n                currentFundManBalance = fundManBalance * fundManRatio[i] / totalShare;\r\n                IERC20(ETH).transfer(fundManAddr[i], currentFundManBalance);\r\n                lastFundManBalance = lastFundManBalance-currentFundManBalance;\r\n            }\r\n            IERC20(ETH).transfer(fundManAddr[fundManRatio.length-1], lastFundManBalance);\r\n        }\r\n    }\r\n    function swapAndLiquify(uint256 tokens) private {\r\n        // split the contract balance into halves\r\n        uint256 half = tokens.div(2);\r\n        uint256 otherHalf = tokens.sub(half);\r\n        // capture the contract's current ETH balance.\r\n        // this is so that we can capture exactly the amount of ETH that the\r\n        // swap creates, and not make the liquidity event include any ETH that\r\n        // has been manually sent to the contract\r\n        uint256 initialBalance = IERC20(ETH).balanceOf(address(this));\r\n        // swap tokens for ETH\r\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\r\n        // how much ETH did we just swap into?\r\n        uint256 newBalance = IERC20(ETH).balanceOf(address(this)).sub(initialBalance);\r\n        // add liquidity to uniswap\r\n        addLiquidity(otherHalf, newBalance);\r\n        emit SwapAndLiquify(half, newBalance, otherHalf);\r\n    }\r\n\r\n    event Failed_swapExactTokensForETHSupportingFeeOnTransferTokens();\r\n    event Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens();\r\n    event Failed_addLiquidityETH();\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = USDTAddress;\r\n\r\n        _approve(address(this), address(_swapRouter), tokenAmount);\r\n\r\n        // make the swap\r\n        try\r\n            _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                tokenAmount,\r\n                0, // accept any amount of ETH\r\n                path,\r\n                address(_tokenDistributor),\r\n                block.timestamp\r\n            )\r\n        {} catch {\r\n            emit Failed_swapExactTokensForETHSupportingFeeOnTransferTokens();\r\n        }\r\n        IERC20(USDTAddress).transferFrom(address(_tokenDistributor), address(this), IERC20(USDTAddress).balanceOf(address(_tokenDistributor)));\r\n    }\r\n\r\n    function swapTokensForETH(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = USDTAddress;\r\n\r\n        _approve(address(this), address(_swapRouter), tokenAmount);\r\n\r\n        // make the swap\r\n        try\r\n            _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                tokenAmount,\r\n                0,\r\n                path,\r\n                address(_tokenDistributor),\r\n                block.timestamp\r\n            )\r\n        {} catch {\r\n            emit Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens();\r\n        }\r\n\r\n        IERC20(USDTAddress).transferFrom(address(_tokenDistributor), address(this), IERC20(USDTAddress).balanceOf(address(_tokenDistributor)));\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(_swapRouter), tokenAmount);\r\n        IERC20(USDTAddress).approve(address( _swapRouter),ethAmount);\r\n\r\n        // add the liquidity\r\n        try\r\n            _swapRouter.addLiquidity(\r\n                address(this),\r\n                address(USDTAddress),\r\n                tokenAmount,\r\n                ethAmount,\r\n                0, // slippage is unavoidable\r\n                0, // slippage is unavoidable\r\n                ReceiveAddress,\r\n                block.timestamp\r\n            )\r\n        {} catch {\r\n            emit Failed_addLiquidityETH();\r\n        }\r\n    }\r\n\r\n    function swapAndSendDividends(uint256 tokens) private {\r\n        swapTokensForETH(tokens);\r\n        uint256 dividends = IERC20(ETH).balanceOf(address(this));\r\n        bool success = IERC20(ETH).transfer(\r\n            address(dividendTracker),\r\n            dividends\r\n        );\r\n\r\n        if (success) {\r\n            dividendTracker.distributeETHDividends(dividends);\r\n            emit SendDividends(tokens, dividends);\r\n        }\r\n    }\r\n}\r\n\r\ninterface DividendPayingTokenOptionalInterface {\r\n    function withdrawableDividendOf(\r\n        address _owner\r\n    ) external view returns (uint256);\r\n\r\n    function withdrawnDividendOf(\r\n        address _owner\r\n    ) external view returns (uint256);\r\n\r\n    function accumulativeDividendOf(\r\n        address _owner\r\n    ) external view returns (uint256);\r\n}\r\n\r\ninterface DividendPayingTokenInterface {\r\n    function dividendOf(address _owner) external view returns (uint256);\r\n\r\n    function withdrawDividend() external;\r\n\r\n    event DividendsDistributed(address indexed from, uint256 weiAmount);\r\n\r\n    event DividendWithdrawn(address indexed to, uint256 weiAmount);\r\n}\r\n\r\nabstract contract DividendPayingToken is\r\n    ERC20,\r\n    Ownable,\r\n    DividendPayingTokenInterface,\r\n    DividendPayingTokenOptionalInterface\r\n{\r\n    using SafeMath for uint256;\r\n    using SafeMathUint for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    address public immutable ETH; //ETH\r\n\r\n    uint256 internal constant magnitude = 2 ** 128;\r\n\r\n    uint256 internal magnifiedDividendPerShare;\r\n\r\n    mapping(address => int256) internal magnifiedDividendCorrections;\r\n    mapping(address => uint256) internal withdrawnDividends;\r\n\r\n    uint256 public totalDividendsDistributed;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address RewardToken\r\n    ) ERC20(_name, _symbol) {\r\n        ETH = RewardToken;\r\n    }\r\n\r\n    function distributeETHDividends(uint256 amount) public onlyOwner {\r\n        require(totalSupply() > 0);\r\n\r\n        if (amount > 0) {\r\n            magnifiedDividendPerShare = magnifiedDividendPerShare.add(\r\n                (amount).mul(magnitude) / totalSupply()\r\n            );\r\n            emit DividendsDistributed(msg.sender, amount);\r\n\r\n            totalDividendsDistributed = totalDividendsDistributed.add(amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraws the ether distributed to the sender.\r\n    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n    function withdrawDividend() public virtual override {\r\n        _withdrawDividendOfUser(payable(msg.sender));\r\n    }\r\n\r\n    /// @notice Withdraws the ether distributed to the sender.\r\n    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n    function _withdrawDividendOfUser(\r\n        address payable user\r\n    ) internal returns (uint256) {\r\n        uint256 _withdrawableDividend = withdrawableDividendOf(user);\r\n        if (_withdrawableDividend > 0) {\r\n            withdrawnDividends[user] = withdrawnDividends[user].add(\r\n                _withdrawableDividend\r\n            );\r\n            emit DividendWithdrawn(user, _withdrawableDividend);\r\n            bool success = IERC20(ETH).transfer(user, _withdrawableDividend);\r\n\r\n            if (!success) {\r\n                withdrawnDividends[user] = withdrawnDividends[user].sub(\r\n                    _withdrawableDividend\r\n                );\r\n                return 0;\r\n            }\r\n\r\n            return _withdrawableDividend;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function dividendOf(address _owner) public view override returns (uint256) {\r\n        return withdrawableDividendOf(_owner);\r\n    }\r\n\r\n    function withdrawableDividendOf(\r\n        address _owner\r\n    ) public view override returns (uint256) {\r\n        return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\r\n    }\r\n\r\n    function withdrawnDividendOf(\r\n        address _owner\r\n    ) public view override returns (uint256) {\r\n        return withdrawnDividends[_owner];\r\n    }\r\n\r\n    function accumulativeDividendOf(\r\n        address _owner\r\n    ) public view override returns (uint256) {\r\n        return\r\n            magnifiedDividendPerShare\r\n                .mul(balanceOf(_owner))\r\n                .toInt256Safe()\r\n                .add(magnifiedDividendCorrections[_owner])\r\n                .toUint256Safe() / magnitude;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual override {\r\n        require(false);\r\n\r\n        int256 _magCorrection = magnifiedDividendPerShare\r\n            .mul(value)\r\n            .toInt256Safe();\r\n        magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from]\r\n            .add(_magCorrection);\r\n        magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(\r\n            _magCorrection\r\n        );\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal override {\r\n        super._mint(account, value);\r\n\r\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\r\n            account\r\n        ].sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal override {\r\n        super._burn(account, value);\r\n\r\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\r\n            account\r\n        ].add((magnifiedDividendPerShare.mul(value)).toInt256Safe());\r\n    }\r\n\r\n    function _setBalance(address account, uint256 newBalance) internal {\r\n        uint256 currentBalance = balanceOf(account);\r\n\r\n        if (newBalance > currentBalance) {\r\n            uint256 mintAmount = newBalance.sub(currentBalance);\r\n            _mint(account, mintAmount);\r\n        } else if (newBalance < currentBalance) {\r\n            uint256 burnAmount = currentBalance.sub(newBalance);\r\n            _burn(account, burnAmount);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ETHBackDividendTracker is Ownable, DividendPayingToken {\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n    using IterableMapping for IterableMapping.Map;\r\n\r\n    IterableMapping.Map private tokenHoldersMap;\r\n    uint256 public lastProcessedIndex;\r\n\r\n    mapping(address => bool) public excludedFromDividends;\r\n\r\n    mapping(address => uint256) public lastClaimTimes;\r\n\r\n    uint256 public claimWait;\r\n    uint256 public immutable minimumTokenBalanceForDividends;\r\n\r\n    event ExcludeFromDividends(address indexed account);\r\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\r\n\r\n    event Claim(\r\n        address indexed account,\r\n        uint256 amount,\r\n        bool indexed automatic\r\n    );\r\n    constructor(\r\n        uint256 mushHoldTokenAmount,\r\n        address RewardToken\r\n    )\r\n        DividendPayingToken(\r\n            \"ETHBack_Dividen_Tracker\",\r\n            \"ETHBack_Dividend_Tracker\",\r\n            RewardToken\r\n        )\r\n    {\r\n        claimWait = 600;\r\n        minimumTokenBalanceForDividends = mushHoldTokenAmount; //must hold\r\n    }\r\n    function _transfer(address, address, uint256) internal pure override {\r\n        require(false, \"ETHBack_Dividend_Tracker: No transfers allowed\");\r\n    }\r\n    function withdrawDividend() public pure override {\r\n        require(\r\n            false,\r\n            \"ETHBack_Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main ETHBack contract.\"\r\n        );\r\n    }\r\n    function excludeFromDividends(address account) external onlyOwner {\r\n        require(!excludedFromDividends[account]);\r\n        excludedFromDividends[account] = true;\r\n        _setBalance(account, 0);\r\n        tokenHoldersMap.remove(account);\r\n        emit ExcludeFromDividends(account);\r\n    }\r\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\r\n        if (lastClaimTime > block.timestamp) {\r\n            return false;\r\n        }\r\n        return block.timestamp.sub(lastClaimTime) >= claimWait;\r\n    }\r\n    function setBalance(\r\n        address payable account,\r\n        uint256 newBalance\r\n    ) external onlyOwner {\r\n        if (excludedFromDividends[account]) {\r\n            return;\r\n        }\r\n\r\n        if (newBalance >= minimumTokenBalanceForDividends) {\r\n            _setBalance(account, newBalance);\r\n            tokenHoldersMap.set(account, newBalance);\r\n        } else {\r\n            _setBalance(account, 0);\r\n            tokenHoldersMap.remove(account);\r\n        }\r\n        processAccount(account, true);\r\n    }\r\n\r\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\r\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\r\n        if (numberOfTokenHolders == 0) {\r\n            return (0, 0, lastProcessedIndex);\r\n        }\r\n        uint256 _lastProcessedIndex = lastProcessedIndex;\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n        uint256 iterations = 0;\r\n        uint256 claims = 0;\r\n        while (gasUsed < gas && iterations < numberOfTokenHolders) {\r\n            _lastProcessedIndex++;\r\n            if (_lastProcessedIndex >= tokenHoldersMap.keys.length) {\r\n                _lastProcessedIndex = 0;\r\n            }\r\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\r\n            if (canAutoClaim(lastClaimTimes[account])) {\r\n                if (processAccount(payable(account), true)) {\r\n                    claims++;\r\n                }\r\n            }\r\n            iterations++;\r\n            uint256 newGasLeft = gasleft();\r\n            if (gasLeft > newGasLeft) {\r\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\r\n            }\r\n            gasLeft = newGasLeft;\r\n        }\r\n        lastProcessedIndex = _lastProcessedIndex;\r\n        return (iterations, claims, lastProcessedIndex);\r\n    }\r\n    function processAccount(\r\n        address payable account,\r\n        bool automatic\r\n    ) public onlyOwner returns (bool) {\r\n        uint256 amount = _withdrawDividendOfUser(account);\r\n        if (amount > 0) {\r\n            lastClaimTimes[account] = block.timestamp;\r\n            emit Claim(account, amount, automatic);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nlibrary IterableMapping {\r\n    // Iterable mapping from address to uint;\r\n    struct Map {\r\n        address[] keys;\r\n        mapping(address => uint256) values;\r\n        mapping(address => uint256) indexOf;\r\n        mapping(address => bool) inserted;\r\n    }\r\n    function get(Map storage map, address key) public view returns (uint256) {\r\n        return map.values[key];\r\n    }\r\n    function getIndexOfKey(\r\n        Map storage map,\r\n        address key\r\n    ) public view returns (int256) {\r\n        if (!map.inserted[key]) {\r\n            return -1;\r\n        }\r\n        return int256(map.indexOf[key]);\r\n    }\r\n    function getKeyAtIndex(\r\n        Map storage map,\r\n        uint256 index\r\n    ) public view returns (address) {\r\n        return map.keys[index];\r\n    }\r\n    function size(Map storage map) public view returns (uint256) {\r\n        return map.keys.length;\r\n    }\r\n    function set(Map storage map, address key, uint256 val) public {\r\n        if (map.inserted[key]) {\r\n            map.values[key] = val;\r\n        } else {\r\n            map.inserted[key] = true;\r\n            map.values[key] = val;\r\n            map.indexOf[key] = map.keys.length;\r\n            map.keys.push(key);\r\n        }\r\n    }\r\n    function remove(Map storage map, address key) public {\r\n        if (!map.inserted[key]) {\r\n            return;\r\n        }\r\n        delete map.inserted[key];\r\n        delete map.values[key];\r\n        uint256 index = map.indexOf[key];\r\n        uint256 lastIndex = map.keys.length - 1;\r\n        address lastKey = map.keys[lastIndex];\r\n        map.indexOf[lastKey] = index;\r\n        delete map.indexOf[key];\r\n        map.keys[index] = lastKey;\r\n        map.keys.pop();\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMathInt\r\n * @dev Math operations for int256 with overflow safety checks.\r\n */\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    /**\r\n     * @dev Multiplies two int256 variables and fails on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Division of two int256 variables and fails on overflow.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two int256 variables and fails on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two int256 variables and fails on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts to absolute value, and fails on overflow.\r\n     */\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMathUint\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMathUint {\r\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n        int256 b = int256(a);\r\n        require(b >= 0);\r\n        return b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"stringParams\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"addressParams\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"fundManAddrParams\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fundManRatioParams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"numberParams\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"boolParams\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Failed_addLiquidityETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Failed_swapExactTokensForETHSupportingFeeOnTransferTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inviterHold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inviterNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_jtBindRouter\",\"outputs\":[{\"internalType\":\"contract JT001\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rewardList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_ETHRewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellamount\",\"type\":\"uint256\"}],\"name\":\"changeSwapLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changeSwapLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"changeWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changeWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"customs\",\"type\":\"uint256[]\"}],\"name\":\"completeCustoms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableChangeTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableSwapWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract ETHBackDividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableInviter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableJT001\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inviterRewardPercentList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLaunch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"multi_bclist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mushHoldNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_ETHRewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setAirdropNumbs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setBeInvitorThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setEnableInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setEnableJT001\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setEnableTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"}],\"name\":\"setFundManAndRatioList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newValue\",\"type\":\"uint256[]\"}],\"name\":\"setInvitorRewardPercentList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newJtBindRouter\",\"type\":\"address\"}],\"name\":\"setJtBindRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"killBlockNumber\",\"type\":\"uint256\"}],\"name\":\"setKillBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMinHoldCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superDisableWhiteListAndLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvitorFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "JT", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000004400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000082000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000064a696e675475000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024a54000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000010149c3c34223f4ee0e5dd0564453c859c08784200000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000f8db58b29d26cb49bb514c951c2e8a3a2249fae8000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000006a75f5aa6573d1f39ccf0b5797b6af78ecee7e8b0000000000000000000000000cbbb0730c0ecd818c782fc4bb22fa154f45daf9000000000000000000000000927a3e2cc97d2d3f30319896474a0ea8cbcf02c00000000000000000000000004cfe9ed9829d5ed07653bc163e00cb2d32c1a987000000000000000000000000747db807490733b102bd0e9ab5d00f67a588b6690000000000000000000000000e403f73e825fdf4a28d717e7c86b99bd25ff135000000000000000000000000721ee01822fe29c705404274b388338e55385f7100000000000000000000000065d6f995a1e365d06511c69606a388a11070c1d800000000000000000000000001f4cab421e3f913a9d5820d47731b2893d8827c000000000000000000000000d1e4a77c9ab8da24dbb251e11493781b08c3dc50000000000000000000000000962daa3d9e36e02b52c844db42565eb0879cd62600000000000000000000000089dba1be15b52e61148a1613b873dc9518d4a73e00000000000000000000000000e31898e7e6c8390fc1fd66abc8d5a048a8368a000000000000000000000000c0b9a640eacb9cf7021cee746fc0c4246186f7b4000000000000000000000000025d5b76454c518fe6e012ddeba8fd131419028e000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000019d971e4fe8401e740000000000000000000000000000000000000000000000019d971e4fe8401e740000000000000000000000000000000000000000000000033b2e3c9fd0803ce8000000000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000004ee2d6d415b85acef81000000000000000000000000000000000000000000000000000422ca8b0a00a42500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "IterableMapping:edeb65088d75fec22aee1e3a4d6b54102a6dc0c8", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8b588b224705b91ce90fe533df41389aa824c5032720a5477ed4d0bd80afb0de"}