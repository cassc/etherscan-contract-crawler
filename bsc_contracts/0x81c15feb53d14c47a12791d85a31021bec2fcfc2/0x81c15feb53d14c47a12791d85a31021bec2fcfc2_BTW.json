{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BTW.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\ncontract BTW {\\r\\n    using SafeMath for uint256; \\r\\n    IERC20 public USDT;\\r\\n    uint256 private constant baseDivider = 10000;\\r\\n    uint256 private constant feePercents = 300;\\r\\n    uint256 private constant minDeposit = 50e18;\\r\\n    uint256 private constant maxDeposit = 2000e18;\\r\\n    uint256 private constant timeStep = 1 days;\\r\\n    uint256 private constant dayPerRound = 10 days; \\r\\n    uint256 private constant maxAddFreeze = 20 days;\\r\\n    uint256[5] private refReward = [200, 50, 50, 50, 50];\\r\\n    uint256 private refRewardSum = 400;\\r\\n    uint256 private constant referDepth = 20;\\r\\n    uint256 private constant directDepth = 1;\\r\\n    uint256 private constant directPercents = 100;\\r\\n    uint256[4] private senManPercents = [50, 50, 50, 50];\\r\\n    uint256[5] private asvpPercents = [20, 20, 20, 20, 20];\\r\\n    uint256[10] private vpPercents = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10];\\r\\n    uint256 private constant MPoolPercents = 10;\\r\\n    uint256 private constant SMPoolPercents = 10;\\r\\n    uint256 private constant AVPoolPercents = 10;\\r\\n    uint256 private constant VPPoolPercents = 10;\\r\\n    uint256 private rewardingMultiple = 20000;\\r\\n     \\r\\n    uint256[10] private balDown = [10e22, 20e22, 30e22, 50e22, 100e22, 300e22, 500e22, 800e22, 1000e22, 1500e22];\\r\\n    uint256[10] private balDownRate = [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000];\\r\\n    uint256[10] private balRecover = [10e22, 20e22, 30e22, 50e22, 100e22, 300e22, 500e22, 800e22, 1000e22, 1500e22];\\r\\n    mapping(uint256=>bool) public balStatus;\\r\\n\\r\\n    address public feeReceiver;\\r\\n    address public ContractAddress;\\r\\n    address public defaultRefer;\\r\\n    uint256 public startTime;\\r\\n    uint256 public lastDistribute;\\r\\n    uint256 public totalUser; \\r\\n    uint256 public lastfreezetime;\\r\\n    uint256 public MPool;\\r\\n    uint256 public SMPool;\\r\\n    uint256 public AVPool;\\r\\n    uint256 public VPPool;\\r\\n     \\r\\n    mapping(uint256=>address[]) public dayUsers;\\r\\n    \\r\\n     address[] public MUsers;\\r\\n     address[] public SMUsers;\\r\\n     address[] public AVUsers;\\r\\n     address[] public VPUsers;\\r\\n\\r\\n\\r\\n     struct OrderInfo {\\r\\n        uint256 amount; \\r\\n        uint256 start;\\r\\n        uint256 unfreeze; \\r\\n        bool isUnfreezed;\\r\\n    }\\r\\n\\r\\n    mapping(address => OrderInfo[]) public orderInfos;\\r\\n\\r\\n    address[] public depositors;\\r\\n\\r\\n    struct UserInfo {\\r\\n        address referrer;\\r\\n        uint256 start;\\r\\n        uint256 level;\\r\\n        uint256 maxDeposit;\\r\\n        uint256 totalDeposit;\\r\\n        uint256 totalDepositbeforeHarvested;\\r\\n        uint256 teamNum;\\r\\n        uint256 directnum;\\r\\n        uint256 maxDirectDeposit;\\r\\n        uint256 teamTotalDeposit;\\r\\n        uint256 totalRevenue;\\r\\n        uint256 totalRevenueFinal;\\r\\n        bool isactive;   \\r\\n    }\\r\\n\\r\\n    struct TwoXInfo {\\r\\n        bool isTwoX;\\r\\n    }\\r\\n        struct LastMaxTeamC {\\r\\n        uint256 LastLegC;\\r\\n    }\\r\\n\\r\\n    struct UserInfoHarvest {  \\r\\n        uint256 acheived;\\r\\n        uint256 currentdays;\\r\\n        uint256 harvestCount;\\r\\n        \\r\\n    }\\r\\n\\r\\n    struct UserInfoPercents {\\r\\n        uint256 dayRewardPercents;\\r\\n    }\\r\\n    mapping(address => UserInfoPercents) public userInfoPercents;\\r\\n    mapping(address => TwoXInfo) public twoXInfo;\\r\\n    mapping(address => LastMaxTeamC) public lastMaxTeamC;\\r\\n \\r\\n      struct UserInfoTeamBuss {  \\r\\n        uint256 totalTeam;\\r\\n        uint256 maxTeamA;\\r\\n        uint256 maxTeamB;\\r\\n        uint256 maxTeamC;\\r\\n        uint256 maxusernumberA; \\r\\n    }\\r\\n\\r\\n       \\r\\n     mapping(address=>UserInfo) public userInfo;\\r\\n     mapping(address=>UserInfoHarvest) public userInfoHarvest;\\r\\n     mapping(address=>UserInfoTeamBuss) public userInfoTeamBuss;\\r\\n   \\r\\n    mapping(address => mapping(uint256 => address[])) public teamUsers;\\r\\n    struct RewardInfo{\\r\\n       \\r\\n        uint256 statics;\\r\\n        uint256 refRewards;\\r\\n        uint256 directs;\\r\\n        uint256 sm;\\r\\n        uint256 av;\\r\\n        uint256 vp;\\r\\n    }\\r\\n\\r\\n     struct RewardInfoPool{\\r\\n        uint256 MN;\\r\\n        uint256 SM;\\r\\n        uint256 AV;\\r\\n        uint256 VP;\\r\\n        \\r\\n    }\\r\\n\\r\\n    mapping(address=>RewardInfo) public rewardInfo;\\r\\n    mapping(address=>RewardInfoPool) public rewardInfoPool;\\r\\n    bool public isFreezeReward;\\r\\n    event Register(address user, address referral);\\r\\n    event Deposit(address user, uint256 amount);\\r\\n    event DepositByActivationFund(address user, uint256 amount);\\r\\n    event TransferByActivation(address user, address receiver, uint256 amount);\\r\\n    event Withdraw(address user, uint256 withdrawable);\\r\\n    event Harvests(address user, uint256 reward , uint256 amount );\\r\\n    constructor(address _usdtAddr, address _defaultRefer, address _feeReceiver, uint256 _startTime) {\\r\\n        USDT = IERC20(_usdtAddr);\\r\\n        feeReceiver = _feeReceiver;\\r\\n        defaultRefer = _defaultRefer;\\r\\n        startTime = _startTime;\\r\\n        lastDistribute = _startTime;\\r\\n    }\\r\\n\\r\\n    function register(address _referral) external {\\r\\n        require(userInfo[_referral].totalDeposit > 0 || _referral == defaultRefer, \\\"invalid refer\\\");\\r\\n        UserInfo storage user = userInfo[msg.sender];\\r\\n        require(user.referrer == address(0), \\\"referrer bonded\\\");\\r\\n        user.referrer = _referral;\\r\\n        user.start = block.timestamp;\\r\\n        totalUser = totalUser.add(1);\\r\\n        emit Register(msg.sender, _referral);\\r\\n    }\\r\\n\\r\\n    function _updatedirectNum(address _user) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n        for(uint256 i = 0; i < directDepth; i++){\\r\\n            if(upline != address(0)){\\r\\n                userInfo[upline].directnum = userInfo[upline].directnum.add(1);                         \\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for(uint256 i = 0; i < referDepth; i++){\\r\\n            if(upline != address(0)){\\r\\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\\r\\n                teamUsers[upline][i].push(_user);\\r\\n                _updateLevel(upline);\\r\\n                if(upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateReferInfo(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n        for(uint256 i = 0; i < referDepth; i++){\\r\\n            if(upline != address(0)){\\r\\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\\r\\n                _updateLevel(upline);\\r\\n                if(upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n     function _updateLevel(address _user) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n         updateUserTeamBusscurrent(_user);\\r\\n        uint256 levelNow = _calLevelNow(_user);\\r\\n        if(levelNow > user.level){\\r\\n            user.level = levelNow;\\r\\n              if(levelNow == 2){        \\r\\n                MUsers.push(_user);\\r\\n            }\\r\\n              if(levelNow == 3){        \\r\\n                SMUsers.push(_user);\\r\\n            }\\r\\n             if(levelNow == 4){        \\r\\n                AVUsers.push(_user);\\r\\n            }\\r\\n            if(levelNow == 5){         \\r\\n                VPUsers.push(_user);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n  \\r\\n    function _calLevelNow(address _user) private view returns (uint256) {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        uint256 total = user.maxDeposit;\\r\\n        uint256 totaldirectnum = user.directnum;\\r\\n        uint256 totaldirectdepositnum = user.maxDirectDeposit;\\r\\n        uint256 levelNow;\\r\\n\\r\\n        if(total >= 500e18){\\r\\n            (uint256 maxTeam, uint256 otherTeam,uint256 othermaxTeam) = checkteamconditions(_user);  // a //c ///b\\r\\n            if(total >= 2000e18 && totaldirectnum>=10 && totaldirectdepositnum>=5000e18   && user.teamNum >= 250 &&   otherTeam  + othermaxTeam + maxTeam >=210000e18){\\r\\n                levelNow = 5;\\r\\n            }else if(total >= 2000e18 && totaldirectnum>=8 && totaldirectdepositnum>=2000e18 && user.teamNum >= 100 &&  otherTeam  + othermaxTeam + maxTeam >=60000e18){\\r\\n                levelNow = 4;\\r\\n            }else if(total >= 1000e18  && totaldirectnum>=5 && totaldirectdepositnum>=1000e18 && user.teamNum >= 50 &&  otherTeam  + othermaxTeam + maxTeam >=15000e18){\\r\\n                levelNow = 3;\\r\\n            }\\r\\n            else if(total >= 500e18  && totaldirectnum>=5 && totaldirectdepositnum>=500e18 && user.teamNum >= 5 &&  otherTeam  + othermaxTeam + maxTeam >=600e18)\\r\\n            {\\r\\n               levelNow = 2;\\r\\n            }\\r\\n            else if(totaldirectnum >= 1){\\r\\n              levelNow = 1;\\r\\n            }\\r\\n        }\\r\\n        return levelNow;\\r\\n    }\\r\\n    function updateUserTeamBusscurrent(address _user) private {\\r\\n        UserInfoTeamBuss storage userteaminfo = userInfoTeamBuss[_user];\\r\\n        uint256 totalTeam;\\r\\n        uint256 maxTeam; //a\\r\\n        uint256 othermaxTeam; //b\\r\\n        uint256 otherTeam; //c\\r\\n        uint256 maxusernumber;\\r\\n        uint256 teamUsersLength = teamUsers[_user][0].length;\\r\\n        for (uint256 i = 0; i < teamUsersLength; i++) {\\r\\n            address currentUser = teamUsers[_user][0][i];\\r\\n            uint256 userTotalTeam = userInfo[currentUser].teamTotalDeposit.add(userInfo[currentUser].totalDeposit);\\r\\n            totalTeam = totalTeam.add(userTotalTeam);\\r\\n            if (userTotalTeam > maxTeam) { maxTeam = userTotalTeam;\\r\\n                maxusernumber = i;\\r\\n            }\\r\\n        }\\r\\n        for (uint256 i = 0; i < teamUsersLength; i++) {\\r\\n            if (i != maxusernumber) {\\r\\n                address currentUser = teamUsers[_user][0][i];\\r\\n                uint256 userTotalTeam = userInfo[currentUser].teamTotalDeposit.add(userInfo[currentUser].totalDeposit);\\r\\n                if (userTotalTeam > othermaxTeam) { othermaxTeam = userTotalTeam;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        otherTeam = totalTeam.sub(maxTeam).sub(othermaxTeam);\\r\\n        userteaminfo.totalTeam = totalTeam;\\r\\n        userteaminfo.maxTeamA = maxTeam;\\r\\n        userteaminfo.maxTeamB = othermaxTeam;\\r\\n        userteaminfo.maxTeamC = otherTeam;\\r\\n        userteaminfo.maxusernumberA = maxusernumber;\\r\\n    }\\r\\n\\r\\n    function getTeamDeposit(address _user) public view returns(uint256, uint256, uint256 ){\\r\\n       \\r\\n        uint256 maxTeam;\\r\\n        uint256 othermaxTeam;\\r\\n        uint256 otherTeam;\\r\\n        \\r\\n         maxTeam =  userInfoTeamBuss[_user].maxTeamA;\\r\\n         othermaxTeam =  userInfoTeamBuss[_user].maxTeamB;\\r\\n         otherTeam =  userInfoTeamBuss[_user].maxTeamC;\\r\\n        \\r\\n          return(maxTeam, otherTeam, othermaxTeam);\\r\\n    }\\r\\n    function checkteamconditions(address _user) private view returns(uint256, uint256, uint256 ) {      \\r\\n        uint256 maxTeam;\\r\\n        uint256 othermaxTeam;\\r\\n        uint256 otherTeam;\\r\\n        uint256 usercurrentlevel;\\r\\n        usercurrentlevel = userInfo[_user].level;\\r\\n        maxTeam =  userInfoTeamBuss[_user].maxTeamA;\\r\\n        othermaxTeam =  userInfoTeamBuss[_user].maxTeamB;\\r\\n        otherTeam =  userInfoTeamBuss[_user].maxTeamC;\\r\\n            if(usercurrentlevel==2) {\\r\\n                if(maxTeam>=5000e18) { \\r\\n                    maxTeam = 5000e18;\\r\\n                }\\r\\n                if(othermaxTeam>=5000e18) {\\r\\n                    othermaxTeam = 5000e18;\\r\\n                }\\r\\n            }\\r\\n                if(usercurrentlevel==3) {\\r\\n                    if(maxTeam>=20000e18) {\\r\\n                        maxTeam = 20000e18;\\r\\n                    }\\r\\n                    if(othermaxTeam>=20000e18) {\\r\\n                        othermaxTeam = 20000e18;\\r\\n                    }            \\r\\n\\r\\n                    }\\r\\n                        if(usercurrentlevel==4) {\\r\\n                                if(maxTeam>=70000e18) {\\r\\n                                    maxTeam = 70000e18;\\r\\n                            }\\r\\n                            if(othermaxTeam>=70000e18) {\\r\\n                                othermaxTeam = 70000e18;\\r\\n                            }              \\r\\n                        }\\r\\n\\r\\n          return(maxTeam, otherTeam, othermaxTeam);    \\r\\n   }\\r\\n  \\r\\n    function deposit(uint256 _amount) external {\\r\\n        USDT.transferFrom(msg.sender, address(this), _amount);\\r\\n        _deposit(msg.sender, _amount);\\r\\n        emit Deposit(msg.sender, _amount);\\r\\n    }\\r\\n    function _deposit(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        UserInfoHarvest storage userHarvest = userInfoHarvest[_user];\\r\\n        \\r\\n        require(user.referrer != address(0), \\\"register first\\\");\\r\\n        require(_amount >= minDeposit, \\\"less than min\\\");\\r\\n        require(_amount.mod(minDeposit) == 0 && _amount >= minDeposit, \\\"mod err\\\");\\r\\n        require(user.maxDeposit == 0 || _amount >= user.maxDeposit, \\\"less before\\\");\\r\\n        \\r\\n        depositors.push(_user); \\r\\n        \\r\\n        user.totalDepositbeforeHarvested = user.totalDepositbeforeHarvested.add(_amount);\\r\\n        user.isactive = true;\\r\\n                 \\r\\n        uint256 currorder=  orderInfos[_user].length;\\r\\n\\r\\n        if(userHarvest.acheived == 0  && currorder ==0)\\r\\n        {  \\r\\n            if(user.maxDeposit == 0){\\r\\n               user.maxDeposit = _amount; \\r\\n              _updatedirectNum(_user);\\r\\n            }else if(user.maxDeposit < _amount){\\r\\n            user.maxDeposit = _amount;\\r\\n            }  \\r\\n\\r\\n           userHarvest.acheived = block.timestamp;\\r\\n           user.totalDeposit = user.totalDeposit.add(user.totalDepositbeforeHarvested);\\r\\n           user.totalDepositbeforeHarvested = 0;\\r\\n          \\r\\n           uint256 addFreeze = (orderInfos[_user].length.div(1)).mul(timeStep);\\r\\n           if(addFreeze > maxAddFreeze){\\r\\n            addFreeze = maxAddFreeze;\\r\\n           }\\r\\n           uint256 unfreezeTime = block.timestamp.add(dayPerRound).add(addFreeze);\\r\\n           userHarvest.currentdays = unfreezeTime;\\r\\n           orderInfos[_user].push(OrderInfo(\\r\\n            _amount, \\r\\n            block.timestamp, \\r\\n            unfreezeTime,\\r\\n            false\\r\\n          ));\\r\\n            _distributeDeposit(_amount);     \\r\\n           _updateReferInfo(msg.sender, _amount);\\r\\n           _updatemaxdirectdepositInfo(msg.sender, _amount);\\r\\n           _updateLevel(msg.sender);\\r\\n           _resetTwoXUser(msg.sender);\\r\\n           updateUserTeamBusscurrent(user.referrer);\\r\\n          _distributedepositreward(msg.sender, _amount);\\r\\n        }\\r\\n         \\r\\n        if(userHarvest.acheived == 0  && currorder>0)\\r\\n        {  \\r\\n             if(user.maxDeposit < _amount){\\r\\n                user.maxDeposit = _amount;\\r\\n              }  \\r\\n\\r\\n           userHarvest.acheived = block.timestamp;\\r\\n           user.totalDeposit = user.totalDeposit.add(user.totalDepositbeforeHarvested);\\r\\n           user.totalDepositbeforeHarvested = 0;\\r\\n           _updateReferInfo(msg.sender, _amount);\\r\\n           _updatemaxdirectdepositInfo(msg.sender, _amount);\\r\\n           _updateLevel(msg.sender);\\r\\n           _resetTwoXUser(msg.sender);\\r\\n           updateUserTeamBusscurrent(user.referrer);\\r\\n           _distributedepositreward(msg.sender, _amount);\\r\\n\\r\\n        }\\r\\n\\r\\n         distributePoolRewards();\\r\\n       \\r\\n        uint256 bal = USDT.balanceOf(address(this));\\r\\n        _balActived(bal);\\r\\n        if(isFreezeReward){\\r\\n            _setFreezeReward(bal);\\r\\n        }\\r\\n    }\\r\\n    function checkusermultiplerewardingstage(address _user) private {\\r\\n            UserInfo storage user = userInfo[_user];  \\r\\n            UserInfoHarvest storage userHarvest = userInfoHarvest[_user];\\r\\n            TwoXInfo storage twoX = twoXInfo[_user];\\r\\n            UserInfoTeamBuss storage userTeam = userInfoTeamBuss[_user];\\r\\n            LastMaxTeamC storage lastMaxC = lastMaxTeamC[_user];\\r\\n            uint256 _rewarding = rewardingMultiple;\\r\\n            if(user.totalRevenue >= user.totalDeposit.mul(_rewarding).div(baseDivider)){\\r\\n                user.totalRevenueFinal = user.totalRevenueFinal.add(user.totalRevenue);\\r\\n                user.isactive = false;\\r\\n                user.totalDeposit=0;\\r\\n                user.totalRevenue =  0;\\r\\n                userHarvest.acheived = 0;\\r\\n                twoX.isTwoX = true;\\r\\n                lastMaxC.LastLegC = userTeam.maxTeamC;\\r\\n            }\\r\\n    }\\r\\n\\r\\n    function _resetTwoXUser(address _user) private {\\r\\n        UserInfo storage user = userInfo[_user];  \\r\\n        TwoXInfo storage twoX = twoXInfo[_user];\\r\\n        UserInfoTeamBuss storage userTeam = userInfoTeamBuss[_user];\\r\\n        LastMaxTeamC storage lastMaxC = lastMaxTeamC[_user];\\r\\n        uint256 reqPlusTeamC = user.totalDeposit * 3;\\r\\n        if(twoX.isTwoX == true && user.totalDeposit > 0) {\\r\\n            if (userTeam.maxTeamC - lastMaxC.LastLegC >= reqPlusTeamC) {\\r\\n                twoX.isTwoX = false;\\r\\n                lastMaxC.LastLegC = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkCurDayPercent(address _user) private {\\r\\n        UserInfoHarvest storage userHarvest = userInfoHarvest[_user];\\r\\n        UserInfoPercents storage userPercents = userInfoPercents[_user];\\r\\n        \\r\\n        if (userHarvest.harvestCount >= 13) {\\r\\n            userPercents.dayRewardPercents = 50;\\r\\n        } else {\\r\\n            userPercents.dayRewardPercents = 75;\\r\\n        }\\r\\n    }\\r\\n    function HarvestReward() public {\\r\\n        TwoXInfo storage twoX = twoXInfo[msg.sender];\\r\\n        _checkCurDayPercent(msg.sender);\\r\\n        checkusermultiplerewardingstage(msg.sender);\\r\\n        _resetTwoXUser(msg.sender);\\r\\n        UserInfo storage user = userInfo[msg.sender];\\r\\n        UserInfoHarvest storage userHarvest = userInfoHarvest[msg.sender];\\r\\n        UserInfoPercents storage userPercents = userInfoPercents[msg.sender];\\r\\n        require(user.isactive == true, \\\"Inactive Account\\\");\\r\\n        uint256 _rewarding = rewardingMultiple;\\r\\n        uint256 initialAmt;\\r\\n        if (user.totalDeposit > 0) {\\r\\n            require(user.totalRevenue < user.totalDeposit.mul(_rewarding).div(baseDivider), \\\"Cannot harvest more than 2x, update level\\\");\\r\\n            if (block.timestamp > userHarvest.currentdays) {\\r\\n                bool hasHarvest = false;\\r\\n                for (uint256 i = 0; i < orderInfos[msg.sender].length; i++) {\\r\\n                    OrderInfo storage order = orderInfos[msg.sender][i];\\r\\n                    if (block.timestamp > order.unfreeze && order.isUnfreezed == false) {\\r\\n                        order.isUnfreezed = true;\\r\\n                        uint256 interest = order.amount.mul(userPercents.dayRewardPercents).mul(dayPerRound).div(timeStep).div(baseDivider);\\r\\n                        if (interest > 0 && user.isactive) {\\r\\n                            if (user.totalRevenue.add(interest) > user.totalDeposit.mul(_rewarding).div(baseDivider)) {\\r\\n                                interest = (user.totalDeposit.mul(_rewarding).div(baseDivider)).sub(user.totalRevenue);\\r\\n                            }\\r\\n                            initialAmt = order.amount;\\r\\n                            if (isFreezeReward) {\\r\\n                                if (user.totalDeposit > user.totalRevenue) {\\r\\n                                    uint256 leftCapital = user.totalDeposit.sub(user.totalRevenue);\\r\\n                                    if (interest > leftCapital) {\\r\\n                                        interest = leftCapital;\\r\\n                                    }\\r\\n                                } else {\\r\\n                                    interest = 0;\\r\\n                                }\\r\\n                            }\\r\\n                            uint256 temp = interest;\\r\\n                            if (!twoX.isTwoX) {\\r\\n                                rewardInfo[msg.sender].statics = rewardInfo[msg.sender].statics.add(temp);\\r\\n                                user.totalRevenue = user.totalRevenue.add(temp);\\r\\n                            }\\r\\n                            uint256 addFreeze = (orderInfos[msg.sender].length.div(1)).mul(timeStep);\\r\\n                            if (addFreeze > maxAddFreeze) {\\r\\n                                addFreeze = maxAddFreeze;\\r\\n                            }\\r\\n                            uint256 unfreezeTime = block.timestamp.add(dayPerRound).add(addFreeze);\\r\\n                            userHarvest.currentdays = unfreezeTime;\\r\\n                            userHarvest.harvestCount++;\\r\\n                            hasHarvest = true;\\r\\n                            uint256 nextamt = user.totalDeposit;\\r\\n                            if (user.totalDepositbeforeHarvested > 0) {\\r\\n                                if (user.totalDeposit < maxDeposit) {\\r\\n                                    uint256 availbal = maxDeposit.sub(user.totalDeposit);\\r\\n                                    if (user.totalDepositbeforeHarvested >= availbal) {\\r\\n                                        nextamt = nextamt.add(availbal);\\r\\n                                        user.totalDepositbeforeHarvested = user.totalDepositbeforeHarvested.sub(availbal);\\r\\n                                        _updateReferInfo(msg.sender, availbal);\\r\\n                                        _updatemaxdirectdepositInfo(msg.sender, availbal);\\r\\n                                        _distributedepositreward(msg.sender, availbal);\\r\\n                                    } else {\\r\\n                                        nextamt = nextamt.add(user.totalDepositbeforeHarvested);\\r\\n                                        _updateReferInfo(msg.sender, user.totalDepositbeforeHarvested);\\r\\n                                        _updatemaxdirectdepositInfo(msg.sender, user.totalDepositbeforeHarvested);\\r\\n                                        _distributedepositreward(msg.sender, user.totalDepositbeforeHarvested);\\r\\n                                        user.totalDepositbeforeHarvested = 0;\\r\\n                                    }\\r\\n                                }\\r\\n                            }\\r\\n                            \\r\\n                            user.totalDeposit = nextamt;\\r\\n                            _distributeDeposit(nextamt);\\r\\n                            user.maxDeposit = nextamt;\\r\\n                            \\r\\n                            if (user.totalDeposit >= maxDeposit) {\\r\\n                                user.maxDeposit = maxDeposit;\\r\\n                            }\\r\\n                            \\r\\n                            orderInfos[msg.sender].push(OrderInfo(\\r\\n                                nextamt,\\r\\n                                block.timestamp,\\r\\n                                unfreezeTime,\\r\\n                                false\\r\\n                            ));\\r\\n                            _updateLevel(msg.sender);\\r\\n                            updateUserTeamBusscurrent(user.referrer);\\r\\n                            \\r\\n                            if (!isFreezeReward) {\\r\\n                                _releaseReward(msg.sender, initialAmt);\\r\\n                                emit Harvests(msg.sender, temp, initialAmt);\\r\\n                            }\\r\\n                        }\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n                if (!hasHarvest) {\\r\\n                    userHarvest.harvestCount--;\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            user.isactive = false;\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function _releaseReward(address _user, uint256 _initialAmt) private { \\r\\n        UserInfo storage user = userInfo[_user]; \\r\\n        address upline = user.referrer;\\r\\n        bool isTwoX = twoXInfo[_user].isTwoX;\\r\\n        for (uint256 i = 0; i < referDepth && !isTwoX; i++) { \\r\\n            if(upline != address(0)){ \\r\\n                bool idstatus = false; \\r\\n                checkusermultiplerewardingstage(upline);\\r\\n                distributePoolRewards();\\r\\n                _resetTwoXUser(upline); \\r\\n                idstatus = getActiveUpline(upline);\\r\\n                uint256 newAmount = _initialAmt;\\r\\n                if(upline != defaultRefer){\\r\\n                    uint256 maxFreezing = getMaxFreezingUpline(upline); \\r\\n                    if(maxFreezing < newAmount){ \\r\\n                        newAmount = maxFreezing;   \\r\\n                    } \\r\\n                } \\r\\n                RewardInfo storage upRewards = rewardInfo[upline]; \\r\\n                uint256 reward; \\r\\n                uint256 _rewarding = rewardingMultiple; \\r\\n                if(userInfo[upline].totalRevenue < userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider) && idstatus==true){ \\r\\n                    if (!twoXInfo[upline].isTwoX) {\\r\\n                        if(i==0 && idstatus==true){\\r\\n                            reward = newAmount.mul(directPercents).div(baseDivider); \\r\\n                            if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) { \\r\\n                                reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue); \\r\\n                            }\\r\\n                            upRewards.directs = upRewards.directs.add(reward);                        \\r\\n                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                        } else if(i>0 && i<5 && idstatus==true && userInfo[upline].level > 2){ \\r\\n                            reward = newAmount.mul(senManPercents[i - 1]).div(baseDivider);\\r\\n                            if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) { \\r\\n                                reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue); \\r\\n                            }\\r\\n                            upRewards.sm = upRewards.sm.add(reward); \\r\\n                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                        } else if(userInfo[upline].level > 3 && i>4 && i <10 && idstatus==true){ \\r\\n                            reward = newAmount.mul(asvpPercents[i - 5]).div(baseDivider); \\r\\n                            if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) { \\r\\n                                reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue); \\r\\n                            }\\r\\n                            upRewards.av = upRewards.av.add(reward); \\r\\n                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                        } else if(userInfo[upline].level > 4 && i >=10 && idstatus==true){ \\r\\n                            reward = newAmount.mul(vpPercents[i - 10]).div(baseDivider); \\r\\n                            if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) { \\r\\n                                reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue); \\r\\n                            }\\r\\n                            upRewards.vp = upRewards.vp.add(reward); \\r\\n                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                        } \\r\\n                    }\\r\\n                } \\r\\n                if(upline == defaultRefer) break; \\r\\n                upline = userInfo[upline].referrer; \\r\\n            }else{ \\r\\n                break; \\r\\n            } \\r\\n        } \\r\\n    }\\r\\n\\r\\n    function withdraw() external {\\r\\n        distributePoolRewards();\\r\\n        _updateLevel(msg.sender);\\r\\n        uint256 staticReward = _calCurStaticRewards(msg.sender);\\r\\n        uint256 withdrawable = staticReward;\\r\\n        uint256 dynamicReward = _calCurDynamicRewards(msg.sender);\\r\\n        withdrawable = withdrawable.add(dynamicReward);   \\r\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\r\\n        RewardInfoPool storage userRewardsf = rewardInfoPool[msg.sender];\\r\\n        UserInfo storage user = userInfo[msg.sender];\\r\\n        _resetTwoXUser(msg.sender);\\r\\n        userRewards.statics = 0;\\r\\n        userRewards.refRewards = 0;\\r\\n        userRewards.directs = 0;\\r\\n        userRewards.sm = 0;\\r\\n        userRewards.av = 0;\\r\\n        userRewards.vp = 0;\\r\\n        userRewardsf.VP = 0;  \\r\\n        userRewardsf.SM = 0;\\r\\n        userRewardsf.AV = 0; \\r\\n        userRewardsf.MN = 0; \\r\\n        withdrawable = withdrawable.add(user.totalDepositbeforeHarvested);\\r\\n        user.totalDepositbeforeHarvested = 0;\\r\\n        uint256 bal = USDT.balanceOf(address(this));\\r\\n        _setFreezeReward(bal);\\r\\n         \\r\\n         USDT.transfer(msg.sender, withdrawable);\\r\\n        emit Withdraw(msg.sender, withdrawable);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    function getMaxFreezingUpline(address _user) public view returns(uint256) {\\r\\n        uint256 maxFreezing;\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        maxFreezing =   user.maxDeposit;\\r\\n        return maxFreezing;\\r\\n    }\\r\\n\\r\\n     function getActiveUpline(address _user) public view returns(bool) {\\r\\n        bool currentstatus = false;  \\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        if(user.isactive==true){\\r\\n           UserInfoHarvest storage userHarvest = userInfoHarvest[_user];\\r\\n          if(block.timestamp < userHarvest.currentdays){\\r\\n             currentstatus =  true;\\r\\n           }\\r\\n        }\\r\\n        \\r\\n        return currentstatus;\\r\\n    }\\r\\n       \\r\\n    function _calCurStaticRewards(address _user) private view returns(uint256) {\\r\\n        RewardInfo storage userRewards = rewardInfo[_user];\\r\\n        uint256 totalRewards = userRewards.statics;\\r\\n        uint256 withdrawable = totalRewards;\\r\\n        return withdrawable;\\r\\n    }\\r\\n\\r\\n    function _calCurDynamicRewards(address _user) private view returns(uint256) {\\r\\n        RewardInfo storage userRewards = rewardInfo[_user];\\r\\n        RewardInfoPool storage userRewardsf = rewardInfoPool[_user];\\r\\n        uint256 totalRewards = userRewards.directs.add(userRewards.refRewards).add(userRewards.sm).add(userRewards.av).add(userRewards.vp);     \\r\\n        totalRewards = totalRewards.add(userRewardsf.VP.add(userRewardsf.MN).add(userRewardsf.AV).add(userRewardsf.SM));\\r\\n        uint256 withdrawable = totalRewards;\\r\\n        return withdrawable;\\r\\n    }\\r\\n\\r\\n    function _removeInvalidDepositnew(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n            for(uint256 i = 0; i < directDepth; i++){\\r\\n            if(upline != address(0)){           \\r\\n                userInfo[upline].maxDirectDeposit = userInfo[upline].maxDirectDeposit.sub(_amount);   \\r\\n                if(upline == defaultRefer) break;\\r\\n            \\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for(uint256 i = 0; i < referDepth; i++){\\r\\n            if(upline != address(0)){           \\r\\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.sub(_amount);           \\r\\n                if(upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updatemaxdirectdepositInfo(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n        for(uint256 i = 0; i < directDepth; i++){\\r\\n            if(upline != address(0)){\\r\\n                userInfo[upline].maxDirectDeposit = userInfo[upline].maxDirectDeposit.add(_amount);       \\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n   \\r\\n    function _distributedepositreward(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer; \\r\\n        uint256 level_sum =  _amount.mul(refRewardSum).div(baseDivider);     \\r\\n            for(uint256 i = 0; i < refReward.length; i++){\\r\\n                if(upline != address(0)){\\r\\n                    bool idstatus = false;\\r\\n                    checkusermultiplerewardingstage(upline);\\r\\n                    _resetTwoXUser(upline);\\r\\n                    idstatus = getActiveUpline(upline);\\r\\n                \\r\\n                    uint256 newAmount = _amount;\\r\\n                    if(upline != defaultRefer){       \\r\\n                        uint256 maxFreezing = getMaxFreezingUpline(upline);\\r\\n                        if(maxFreezing < _amount){\\r\\n                            newAmount = maxFreezing;\\r\\n                        }\\r\\n                    }\\r\\n                    RewardInfo storage upRewards = rewardInfo[upline];\\r\\n                    uint256 reward;\\r\\n                    if(i==0 && idstatus==true && userInfo[upline].directnum >=i+1){   \\r\\n                    uint256 _rewarding = rewardingMultiple;\\r\\n                    if(userInfo[upline].totalRevenue < userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider))\\r\\n                    {\\r\\n\\r\\n                    reward = newAmount.mul(refReward[i]).div(baseDivider);\\r\\n                        \\r\\n                    if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) {\\r\\n                        reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\\r\\n                        }  \\r\\n                                                \\r\\n                            upRewards.refRewards += reward;\\r\\n                            userInfo[upline].totalRevenue += reward;\\r\\n                            level_sum = level_sum.sub(reward);\\r\\n                    \\r\\n                        }\\r\\n                    }else if(i>0 && idstatus==true && userInfo[upline].directnum >=i+1){\\r\\n                    uint256 _rewarding = rewardingMultiple;\\r\\n                        if(userInfo[upline].totalRevenue < userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider))\\r\\n                            {\\r\\n                            reward = newAmount.mul(refReward[i]).div(baseDivider);\\r\\n                            if(userInfo[upline].totalRevenue.add(reward) > userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)) \\r\\n                            {\\r\\n                            reward = (userInfo[upline].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[upline].totalRevenue);\\r\\n                            }  \\r\\n                            \\r\\n                                upRewards.refRewards += reward;\\r\\n                                userInfo[upline].totalRevenue += reward;\\r\\n                                level_sum = level_sum.sub(reward);\\r\\n                            }           \\r\\n                        }\\r\\n                    if(upline == defaultRefer) break;\\r\\n                    upline = userInfo[upline].referrer;\\r\\n                }else{\\r\\n                    break;\\r\\n                }\\r\\n                }\\r\\n                if(level_sum > 0){\\r\\n                    rewardInfo[defaultRefer].directs = rewardInfo[defaultRefer].directs.add(level_sum);                  \\r\\n            }\\r\\n    }\\r\\n    \\r\\n    function _balActived(uint256 _bal) private {\\r\\n        for(uint256 i = balDown.length; i > 0; i--){\\r\\n            if(_bal >= balDown[i - 1]){\\r\\n                balStatus[balDown[i - 1]] = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _distributeDeposit(uint256 _amount) private {\\r\\n        USDT.transfer(feeReceiver, _amount.mul(feePercents).div(baseDivider));\\r\\n        uint256 manager = _amount.mul(MPoolPercents).div(baseDivider);\\r\\n        MPool = MPool.add(manager); \\r\\n        uint256 sm = _amount.mul(SMPoolPercents).div(baseDivider);\\r\\n        SMPool = SMPool.add(sm); \\r\\n        uint256 avp = _amount.mul(AVPoolPercents).div(baseDivider);\\r\\n        AVPool = AVPool.add(avp); \\r\\n        uint256 vp = _amount.mul(VPPoolPercents).div(baseDivider);\\r\\n        VPPool = VPPool.add(vp); \\r\\n    }\\r\\n\\r\\n    function distributePoolRewards() public {\\r\\n        if(block.timestamp > lastDistribute.add(timeStep)){ \\r\\n\\r\\n        if(!isFreezeReward){\\r\\n           _distributeMPool(); \\r\\n           _distributeSMPool(); \\r\\n           _distributeAVPool(); \\r\\n           _distributeVPPool();\\r\\n       }\\r\\n       else{\\r\\n           MPool = 0;\\r\\n           SMPool = 0;\\r\\n           AVPool = 0;\\r\\n           VPPool = 0;\\r\\n       }\\r\\n          \\r\\n           \\r\\n            lastDistribute = block.timestamp;\\r\\n        }\\r\\n    }\\r\\n    function _distributeMPool() private {\\r\\n        uint256 managerCount;\\r\\n        for(uint256 i = 0; i < MUsers.length; i++){\\r\\n           \\r\\n            if(userInfo[MUsers[i]].level == 2 && userInfo[MUsers[i]].isactive == true){\\r\\n                managerCount = managerCount.add(1);\\r\\n            }\\r\\n        }\\r\\n        if(managerCount > 0){\\r\\n            uint256 reward = MPool.div(managerCount);\\r\\n            uint256 totalReward;\\r\\n            for(uint256 i = 0; i < MUsers.length; i++){\\r\\n                if(userInfo[MUsers[i]].level == 2 && userInfo[MUsers[i]].isactive == true && !twoXInfo[MUsers[i]].isTwoX){\\r\\n                      uint256 _rewarding = rewardingMultiple;\\r\\n                     if(userInfo[MUsers[i]].totalRevenue < userInfo[MUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\\r\\n                      {\\r\\n                         if(userInfo[MUsers[i]].totalRevenue.add(reward) > userInfo[MUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\\r\\n                               reward = (userInfo[MUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[MUsers[i]].totalRevenue);\\r\\n                           }   \\r\\n                \\r\\n                          rewardInfoPool[MUsers[i]].MN = rewardInfoPool[MUsers[i]].MN.add(reward);\\r\\n                          userInfo[MUsers[i]].totalRevenue = userInfo[MUsers[i]].totalRevenue.add(reward);\\r\\n                          totalReward = totalReward.add(reward);\\r\\n                      }\\r\\n\\r\\n                   \\r\\n                }\\r\\n            }\\r\\n            if(MPool > totalReward){\\r\\n                MPool = MPool.sub(totalReward);\\r\\n            }else{\\r\\n                MPool = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function _distributeSMPool() private {\\r\\n        uint256 smCount;\\r\\n        for(uint256 i = 0; i < SMUsers.length; i++){\\r\\n            \\r\\n            if(userInfo[SMUsers[i]].level == 3 && userInfo[SMUsers[i]].isactive == true){\\r\\n                smCount = smCount.add(1);\\r\\n            }\\r\\n        }\\r\\n        if(smCount > 0){\\r\\n            uint256 reward = SMPool.div(smCount);\\r\\n            uint256 totalReward;\\r\\n            for(uint256 i = 0; i < SMUsers.length; i++){\\r\\n                if(userInfo[SMUsers[i]].level == 3 && userInfo[SMUsers[i]].isactive == true && !twoXInfo[SMUsers[i]].isTwoX ){\\r\\n                       uint256 _rewarding = rewardingMultiple;\\r\\n                       if(userInfo[SMUsers[i]].totalRevenue < userInfo[SMUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\\r\\n                        {\\r\\n                             if(userInfo[SMUsers[i]].totalRevenue.add(reward) > userInfo[SMUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\\r\\n                               reward = (userInfo[SMUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[SMUsers[i]].totalRevenue);\\r\\n                           }\\r\\n\\r\\n                           rewardInfoPool[SMUsers[i]].SM = rewardInfoPool[SMUsers[i]].SM.add(reward);\\r\\n                           userInfo[SMUsers[i]].totalRevenue = userInfo[SMUsers[i]].totalRevenue.add(reward);\\r\\n                            totalReward = totalReward.add(reward);\\r\\n                      }\\r\\n\\r\\n                  \\r\\n                }\\r\\n            }\\r\\n            if(SMPool > totalReward){\\r\\n                SMPool = SMPool.sub(totalReward);\\r\\n            }else{\\r\\n                SMPool = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _distributeAVPool() private {\\r\\n            uint256 avCount;\\r\\n            for(uint256 i = 0; i < AVUsers.length; i++){\\r\\n                \\r\\n                if(userInfo[AVUsers[i]].level == 4 && userInfo[AVUsers[i]].isactive == true){\\r\\n                    avCount = avCount.add(1);\\r\\n                }\\r\\n            }\\r\\n            if(avCount > 0){\\r\\n                uint256 reward = AVPool.div(avCount);\\r\\n                uint256 totalReward;\\r\\n                for(uint256 i = 0; i < AVUsers.length; i++){\\r\\n                    if(userInfo[AVUsers[i]].level == 4 && userInfo[AVUsers[i]].isactive == true && !twoXInfo[AVUsers[i]].isTwoX){\\r\\n                            uint256 _rewarding = rewardingMultiple;\\r\\n                            if(userInfo[AVUsers[i]].totalRevenue < userInfo[AVUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\\r\\n                            {  \\r\\n                                if(userInfo[AVUsers[i]].totalRevenue.add(reward) > userInfo[AVUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\\r\\n                                    reward = (userInfo[AVUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[AVUsers[i]].totalRevenue);\\r\\n                                }\\r\\n                                rewardInfoPool[AVUsers[i]].AV = rewardInfoPool[AVUsers[i]].AV.add(reward);\\r\\n                                userInfo[AVUsers[i]].totalRevenue = userInfo[AVUsers[i]].totalRevenue.add(reward);\\r\\n                                totalReward = totalReward.add(reward);\\r\\n                            }\\r\\n                    \\r\\n                    }\\r\\n                }\\r\\n                if(AVPool > totalReward){\\r\\n                    AVPool = AVPool.sub(totalReward);\\r\\n                }else{\\r\\n                    AVPool = 0;\\r\\n                }\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function _distributeVPPool() private {\\r\\n            uint256 vpCount;\\r\\n            for(uint256 i = 0; i < VPUsers.length; i++){\\r\\n                    \\r\\n                if(userInfo[VPUsers[i]].level == 5 && userInfo[VPUsers[i]].isactive == true){\\r\\n                    vpCount = vpCount.add(1);\\r\\n                }\\r\\n            }\\r\\n        if(vpCount > 0){\\r\\n            uint256 reward = VPPool.div(vpCount);\\r\\n            uint256 totalReward;\\r\\n            for(uint256 i = 0; i < VPUsers.length; i++){\\r\\n                if(userInfo[VPUsers[i]].level == 5 && userInfo[VPUsers[i]].isactive == true && !twoXInfo[VPUsers[i]].isTwoX){\\r\\n\\r\\n                    uint256 _rewarding = rewardingMultiple;\\r\\n                        if(userInfo[VPUsers[i]].totalRevenue < userInfo[VPUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider))\\r\\n                        {  \\r\\n                            if(userInfo[VPUsers[i]].totalRevenue.add(reward) > userInfo[VPUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)) {\\r\\n                                reward = (userInfo[VPUsers[i]].totalDeposit.mul(_rewarding).div(baseDivider)).sub(userInfo[VPUsers[i]].totalRevenue);\\r\\n                            }\\r\\n                                rewardInfoPool[VPUsers[i]].VP = rewardInfoPool[VPUsers[i]].VP.add(reward);\\r\\n                                userInfo[VPUsers[i]].totalRevenue = userInfo[VPUsers[i]].totalRevenue.add(reward);\\r\\n                                totalReward = totalReward.add(reward);\\r\\n                        }\\r\\n                        \\r\\n                    }\\r\\n                }\\r\\n                if(VPPool > totalReward){\\r\\n                    VPPool = VPPool.sub(totalReward);\\r\\n                }else{\\r\\n                    VPPool = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getCurDay() public view returns(uint256) {\\r\\n        return (block.timestamp.sub(startTime)).div(timeStep);\\r\\n    }\\r\\n    function getCurDaytime() public view returns(uint256) {\\r\\n        return (block.timestamp);\\r\\n    }\\r\\n    function getDayLength(uint256 _day) external view returns(uint256) {\\r\\n        return dayUsers[_day].length;\\r\\n    }\\r\\n    function getTeamUsersLength(address _user, uint256 _layer) external view returns(uint256) {\\r\\n        return teamUsers[_user][_layer].length;\\r\\n    }\\r\\n    function getOrderLength(address _user) external view returns(uint256) {\\r\\n        return orderInfos[_user].length;\\r\\n    }\\r\\n    function getDepositorsLength() external view returns(uint256) {\\r\\n        return depositors.length;\\r\\n    }\\r\\n    function getMUsersLength() external view returns(uint256) {\\r\\n        return MUsers.length;\\r\\n    }\\r\\n    function getSMUsersLength() external view returns(uint256) {\\r\\n        return SMUsers.length;\\r\\n    }\\r\\n    function getAVUsersLength() external view returns(uint256) {\\r\\n        return AVUsers.length;\\r\\n    }\\r\\n    function getVPUsersLength() external view returns(uint256) {\\r\\n        return VPUsers.length;\\r\\n    }\\r\\n    function _setFreezeReward(uint256 _bal) private {\\r\\n        for(uint256 i = balDown.length; i > 0; i--){\\r\\n            if(balStatus[balDown[i - 1]]){\\r\\n                uint256 maxDown = balDown[i - 1].mul(balDownRate[i - 1]).div(baseDivider);\\r\\n                if(_bal < balDown[i - 1].sub(maxDown)){\\r\\n                    isFreezeReward = true;       \\r\\n                    ContractAddress=defaultRefer;\\r\\n                }else if(isFreezeReward && _bal >= balRecover[i - 1]){\\r\\n                    isFreezeReward = false;\\r\\n                }\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n \\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositByActivationFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferByActivation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AVPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AVUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HarvestReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SMPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SMUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VPPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"VPUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAVUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getActiveUpline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDaytime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositorsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezingUpline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSMUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVPUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFreezeReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastMaxTeamC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LastLegC\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastfreezetime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"av\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfoPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"MN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"VP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"twoXInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isTwoX\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositbeforeHarvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directnum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenueFinal\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isactive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfoHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"acheived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentdays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harvestCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfoPercents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dayRewardPercents\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfoTeamBuss\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxusernumberA\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BTW", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000003d3fe44436907ff827df7b97179d811d9238c4b2000000000000000000000000ae93f51760d05cc39e770b1b80962172c913440200000000000000000000000000000000000000000000000000000000650974a4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}