/********************** @2022 Wizarre, All rights reserved *********************
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMmMMMMMMMMMMMMMNNMMMMNddNMMMMmmmmmNMMMMNddNMMMMNMMMMMMMMMMMMMMmMMMMMMMMM
MMMMMMMMdysNhoossydNMmosyyMM+ddd-NhssdNMMNdsshN-ddd+MMsysomMNdyssoohNysdMMMMMMMM
MMMMMMMMmss::NMMh/+o+/-ohhMMhhdm`:hNNmMMMMmMNy:.mdhhMNhho-/+o+/dMMN-:ssmMMMMMMMM
MMMMMMMMNoMhyhdNNNmsoyNh/:mMMMs.oNMhoNMMMMmodMNo.yMMMd:/hNyoymNNNdhyhNoNMMMMMMMM
MMMMMMMNy/:shhhhy/-syyhhy`.hho :hho-yhhhhhhy-shh: ohh.`yhhyyo./yhhhhs:/hNMMMMMMM
MMMMMMMd `+://sso:`.`---/:osoo.syhh+yyyssyyyohhyo-osso:/---`.`/oss//:o  mMMMMMMM
MMMMMMMd `s+s+:..``.-+yhmyddhhsmyoyosddyyddsoyoymsyhdhymhy+-.``..:+s+y  mMMMMMMM
MMMMMMMd  sm`  -shhy. sMNys+ho+ssymyoodmmhooydyos+oh+yyMMo -yhhs-  `ms  mMMMMMMM
MMMMMMMd `yds` `/ss+:/hddddhhodNNhdssyNMMNyssdhNNhshhddddh/:+ss/` `ydy  mMMMMMMM
MMMMMMMd  ooNh/-..`````     :sdhdssddshmmhsddsydhdo-     `````..-/dNoo  mMMMMMMM
MMMMMMMd `md+ymddysohs.   `odmmdoyNoNmohhoNNoNssdmmho`   .yhosyddmy+dm  mMMMMMMM
MMMMMMMd `Nmh+/oyo-+o` `  syMMsM/dy/NhdyhhhN:yd+MsMNyo  ` `o+-oyo:+hmm  mMMMMMMM
MMMMMMMd  -NNy+/+yy.  :../odyhohssohyhsooshshossh+hyd+/`-:  -yy+/+yNm.  mMMMMMMM
MMMMMMMd -/-::yNN/   +/`so/shhssyhyy+yy++hy+hshysyhho:oo`++   +Nms::-/. mMMMMMMM
MMMMMMMd oMy/MMh.   ss hMNNhs+:/++++/yhyyhy/++++::oshNhNy ys   .hMM:hM+ mMMMMMMM
MMMMMMMd hMooMo    ym`oMdhymhyo/    `ooo+oo`    .shhdmyhM+`ms    oM+oMy mMMMMMMM
MMMMMMMd mMsy-    yM:`Nmsdyhysys:  ` `:ys/` ` `hmMMdsshsom /My    :ysMm mMMMMMMM
MMMMMMMd.MMd.    yMh :yssMNhshymNy: /``Nm .: .yNdMN/hmMddM- dMs    .mMM`mMMMMMMM
MMMMMMMdoMh`    oMM- :omdoMMMMdhddm/ s.--.s /mhshMhydhhdoN/ :MM+    `dM+mMMMMMMM
MMMMMMMdmh`    :MMd  /yhhh+s:ysyy+hN+`d..d`+ddhyyssNNyddss+  mMM-    `ddmMMMMMMM
MMMMMMMMh`     dMMy  :hodoNoy+hysdmym-+dd/-mymhdhdyd+NNmyN-  hMMd     `hMMMMMMMM
MMMMMMMM.      .sNMh- /yddyms+NMm:mmhs`Nm yMmhdssyhs+dy+o: -dMNs`      .MMMMMMMM
MMMMMMMNd:       .sNNs.`sNNyhhoNMm+dh-`dd`:Moymhhdyhsdho`.sNNs.       /mMMMMMMMM
MMMMMMMdhmo:`      .odm+`:sddmmsmmo/o +--+ /dymddhhmms-`+md+`      `:sNymMMMMMMM
MMMMMMMd/sy:do-      `:hh/`:sdmdydm- ./  /``odmyhydo-./dy:`      -sh:yy:mMMMMMMM
MMMMMMMd`m/.+shh+-      .os/`:ohdds  - // - `hMNhs-./s+.     `-+hhs/./m mMMMMMMM
MMMMMMMd -.mho/-hNds:.    `-/-`.oo`    --    `oo-`-/-`   `./sdNy-/sdm`- mMMMMMMM
MMMMMMMd  oMoo/.mNyooss+/-`  ``       `/:`       ``  .-/+ssoohMm.+osMo  mMMMMMMM
MMMMMMMd  myssh+hN.`o++/oNmo+/-.`  `.+hddh/.`  `.-++smm+/++o`.Nhohssyd  mMMMMMMM
MMMMMMMd  ++++osys-..--:/++:/yso+/:/o+-``-+o/:/+oss::++/:--..:syso++++  mMMMMMMM
MMMMMMMMh/.`-+hdmoohdmmmmddhmmmy+ooh/ .ys` +hoo+ymmmhddmmmmdhoomdh+-`.+hMMMMMMMM
MMMMMMMMMNmhs.`::`yhymdyoshNdsddyy. .+mNNm+` -yydhsmNhsoymdyhs /:`.sdmNMMMMMMMMM
MMMMMMMMMsohh.ymhy+//+./NMNssh+::.`+dmymmymd/`.::+hosNMm/.+//+yhmy.dh+yMMMMMMMMM
MMMMMMMMMNhysmMMMMMMMMh+MNhNMMMNNMdysyNMMNssydMNNMMMNhNN+dMMMMMMMMmsydNMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/

// SPDX-License-Identifier: None
pragma solidity ^0.8.16;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

interface iNFT {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface iERC1155 {
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}

interface ISafeTransfer {
    //ERC721
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    function balanceOf(address owner) external view returns (uint256 balance);

    //ERC1155
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    function balanceOf(address account, uint256 id) external view returns (uint256);
}

contract Marketplace is ERC721Holder, ERC1155Holder, Ownable, Pausable {
    using Counters for Counters.Counter;
    Counters.Counter private lastOfferId;

    IERC20 public tokenContract;
    address public feeReceiverContract;
    uint128 public feePermil = 30;
    uint128 public minimalPrice = 25000 * 10 ** 18 - 1;
    uint128 public maximumPrice = 999999999 * 10 ** 18 + 1;

    mapping(ISafeTransfer => uint8) supportedContracts; // "0"=not set; "1"=erc721; "2"=erc1155

    struct Offer {
        ISafeTransfer nftContractAddress;
        uint32 assetId;
        address owner;
        uint32 amount;
        uint128 price;
    }

    mapping(uint256 => Offer) public offers;

    event OfferCreated (
        uint256 offerId,
        ISafeTransfer nftContractAddress,
        address owner,
        uint128 price,
        uint32 assetId,
        uint32 amount,
        uint8 contractType
    );

    event OfferCancelled (
        uint256 offerId
    );

    event OfferTaken (
        uint256 offerId,
        address taker
    );

    event OfferPriceUpdated (
        uint256 offerId,
        uint128 newPrice
    );

    event FeeChanged (
        uint128 prevFeePermil,
        uint128 newFeePermil
    );

    event MinimalPriceChanged (
        uint128 prevPrice,
        uint128 newPrice
    );

    event MaximumPriceChanged (
        uint128 prevPrice,
        uint128 newPrice
    );

    event AddedSupportedContracts (
        ISafeTransfer[] contractsAddresses,
        bool[] isItERC1155
    );

    event RemovedSupportedContract(
        ISafeTransfer contractAddress
    );

    constructor(
        IERC20 _tokenContract,
        address _feeReceiverAddress,
        ISafeTransfer[] memory _supportedContracts,
        bool[] memory _isSupportedContractErc1155
    ) {
        tokenContract = _tokenContract;
        feeReceiverContract = _feeReceiverAddress;
        addSupportedContracts(_supportedContracts, _isSupportedContractErc1155);
    }

    function addSupportedContracts(ISafeTransfer[] memory _contracts, bool[] memory _isItErc1155) public onlyOwner {
        for (uint256 i = 0; i < _contracts.length; i++) {
            supportedContracts[_contracts[i]] = _isItErc1155[i] ? 2 : 1;
        }
        emit AddedSupportedContracts(_contracts, _isItErc1155);
    }

    // Remember to also remove all offers using that contract
    function removeSupportedContract(ISafeTransfer _contract) external onlyOwner {
        delete supportedContracts[_contract];
        emit RemovedSupportedContract(_contract);
    }

    function setMinimalPrice(uint128 _price) external onlyOwner {
        require(_price >= 0, "CANNOT_BE_BELOW_0");

        emit MinimalPriceChanged(
            minimalPrice,
            _price
        );

        minimalPrice = _price;
    }

    function setMaximumPrice(uint128 _price) external onlyOwner {
        require(_price >= 0, "CANNOT_BE_BELOW_0");

        emit MaximumPriceChanged(
            maximumPrice,
            _price
        );

        maximumPrice = _price;
    }

    function getSupportedContractType(ISafeTransfer _contractAddress) external view returns (uint256){
        return supportedContracts[_contractAddress];
    }

    function createOffer(
        ISafeTransfer _nftContractAddress,
        uint32 _assetId,
        uint32 _amount,
        uint128 _price
    ) external whenNotPaused {
        require(_price > minimalPrice, "PRICE_BELOW_MINIMAL_PRICE");
        require(_price < maximumPrice, "PRICE_ABOVE_MAX_PRICE");
        require(_amount > 0, "AMOUNT_MUST_BE_ABOVE_0");
        require(supportedContracts[_nftContractAddress] > 0, "CONTRACT_NOT_SUPPORTED");

        lastOfferId.increment();
        uint256 _currentOfferId = lastOfferId.current();
        offers[_currentOfferId] = Offer({
            nftContractAddress : _nftContractAddress, //contract address
            owner : _msgSender(), //owner address
            price : _price, //price
            assetId : _assetId, //asset Id
            amount : _amount // amount
        });

        if (supportedContracts[_nftContractAddress] == 1) {
            // ERC721
            _nftContractAddress.safeTransferFrom(_msgSender(), address(this), _assetId);
        } else if (supportedContracts[_nftContractAddress] == 2) {
            // ERC1155
            _nftContractAddress.safeTransferFrom(_msgSender(), address(this), _assetId, _amount, bytes(''));
        } else {
            revert('UNKNOWN_ASSET_TYPE');
        }

        emit OfferCreated(
            _currentOfferId, //uint256 offerId,
            _nftContractAddress, //address nftContractAddress,
            _msgSender(), //address owner
            _price, //uint128 price,
            _assetId, //uint256 assetId,
            _amount, //uint256 amount,
            supportedContracts[_nftContractAddress]
        );
    }

    function takeOffer(uint256 _offerId, uint256 _price) external whenNotPaused {
        require(tokenContract.balanceOf(_msgSender()) >= uint256(offers[_offerId].price), 'TOKEN_AMOUNT_NOT_SUFFICIENT');
        require(offers[_offerId].price > 0, 'OFFER_DOES_NOT_EXIST');
        require(offers[_offerId].price == _price, 'OFFER_PRICE_CHANGED');

        uint256 _fee = calculateFee(offers[_offerId].price);
        // transfer to offer owner
        tokenContract.transferFrom(_msgSender(), offers[_offerId].owner, (offers[_offerId].price - _fee));
        if (_fee > 0) {
            // transfer fee to contract
            tokenContract.transferFrom(_msgSender(), feeReceiverContract, _fee);
        }

        if (supportedContracts[offers[_offerId].nftContractAddress] == 1) {
            // ERC721
            offers[_offerId].nftContractAddress.safeTransferFrom(address(this), _msgSender(), offers[_offerId].assetId);
        } else if (supportedContracts[offers[_offerId].nftContractAddress] == 2) {
            // ERC1155
            offers[_offerId].nftContractAddress.safeTransferFrom(address(this), _msgSender(), offers[_offerId].assetId, offers[_offerId].amount, bytes(''));
        } else {
            revert('UNKNOWN_ASSET_TYPE');
        }

        // Delete offer
        delete offers[_offerId];

        emit OfferTaken(
            _offerId, // uint256 offerId,
            _msgSender() // address taker,
        );
    }

    function updateOfferPrice(uint256 _offerId, uint128 _price) external whenNotPaused {
        require(offers[_offerId].owner == _msgSender(), "ONLY_OFFER_OWNER_CAN_CANCEL_OFFER");
        require(_price > minimalPrice, "PRICE_BELOW_MINIMAL_PRICE");
        require(_price < maximumPrice, "PRICE_ABOVE_MAX_PRICE");

        offers[_offerId].price = _price;

        emit OfferPriceUpdated(
            _offerId,
            _price
        );
    }

    function cancelOffer(uint256 _offerId) public {
        require(offers[_offerId].owner == _msgSender() || owner() == _msgSender(), "ONLY_OFFER_OWNER_CAN_CANCEL_OFFER");

        // Transfer asset back to user
        if (supportedContracts[offers[_offerId].nftContractAddress] == 1) {
            // ERC721
            offers[_offerId].nftContractAddress.safeTransferFrom(address(this), offers[_offerId].owner, offers[_offerId].assetId);
        } else if (supportedContracts[offers[_offerId].nftContractAddress] == 2) {
            // ERC1155
            offers[_offerId].nftContractAddress.safeTransferFrom(address(this), offers[_offerId].owner, offers[_offerId].assetId, offers[_offerId].amount, bytes(''));
        } else {
            revert('UNKNOWN_ASSET_TYPE');
        }

        // Delete offer
        delete offers[_offerId];

        emit OfferCancelled(_offerId);
    }

    function cancelManyOffers(uint256[] calldata _offersId) external {
        for (uint256 i = 0; i < _offersId.length; i++) {
            cancelOffer(_offersId[i]);
        }
    }

    function setFeePermil(uint128 _newFeePermil) external onlyOwner {
        require(_newFeePermil < 1000, 'CANNOT_BE_ABOVE_1000');
        require(_newFeePermil >= 0, 'CANNOT_BE_BELOW_0');

        emit FeeChanged(
            feePermil,
            _newFeePermil
        );

        feePermil = _newFeePermil;
    }

    function calculateFee(uint128 _price) public view returns (uint256){
        return uint256(_price) * uint256(feePermil) / 1000;
    }

    function calculateUsersEarn(uint128 _price) external view returns (uint256) {
        return uint256(_price) - calculateFee(_price);
    }

    function adminReturnAccidentallySentToken(IERC20 _tokenContractAddress) external onlyOwner {
        uint256 _amount = _tokenContractAddress.balanceOf(address(this));
        _tokenContractAddress.transfer(_msgSender(), _amount);
    }

    // Supports only ERC721
    function adminReturnAccidentallySentNFT(ISafeTransfer _nftContractAddress, uint256 _assetId) external onlyOwner {
        for (uint256 i = 0; i <= lastOfferId.current(); i++) {
            if (offers[i].assetId == _assetId && offers[i].nftContractAddress == _nftContractAddress) {
                revert("REQUESTED_ASSET_IS_IN_OFFER");
            }
        }

        _nftContractAddress.safeTransferFrom(address(this), _msgSender(), _assetId);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}