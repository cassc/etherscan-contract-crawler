{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/shard_warriors.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"./shard_warriors_lib.sol\\\";\\r\\ninterface IERC20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  function transfer(address recipient, uint256 amount)\\r\\n  external\\r\\n  returns (bool);\\r\\n\\r\\n  function allowance(address owner, address spender)\\r\\n  external\\r\\n  view\\r\\n  returns (uint256);\\r\\n\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed spender,\\r\\n    uint256 value\\r\\n  );\\r\\n}\\r\\n\\r\\ninterface IShardWarriorsGame {\\r\\n  struct heroStats {\\r\\n    uint256 hp; // health\\r\\n    uint256 mana; // mana\\r\\n    uint256 attack; // attack\\r\\n    uint256 def; // defense\\r\\n    uint256 magic; // magic\\r\\n    uint256 level; // level\\r\\n    bool isDead; // killed?\\r\\n  }\\r\\n  struct HeroBattle {\\r\\n    uint256 id;\\r\\n    address player1;\\r\\n    address player2;\\r\\n    uint256 battleCost;\\r\\n    uint256 result;\\r\\n    heroStats p1;\\r\\n    heroStats p2;\\r\\n    uint256 turnP1;\\r\\n    uint256 turnP2;\\r\\n    uint256 timestampP1;\\r\\n    uint256 timestampP2;\\r\\n    uint256 randomTurnP1;\\r\\n    uint256 randomTurnP2;\\r\\n    uint256 p1HeroId;\\r\\n    uint256 p2HeroId;\\r\\n    uint256 p1faction;\\r\\n    uint256 p2faction;\\r\\n  }\\r\\n\\r\\n  struct Army {\\r\\n    heroStats[20] stat; // heroes stats\\r\\n  }\\r\\n\\r\\n  function isHeroDead(address user, uint256 heroId) external returns(bool);\\r\\n  function getHeroLevel(address user, uint256 heroId) external returns(uint256);\\r\\n  function setHeroLevel(address user, uint256 heroId) external returns(bool);\\r\\n  function setUpgradeHeroLevel(address user, uint256 heroId, uint256 statIndex) external returns(bool);\\r\\n  function setHeroDead(address user, uint256 heroId) external returns(bool);\\r\\n  function fillHeroesStats(address user, uint256 faction) external returns(bool);\\r\\n  function fightTurn(address user, uint256 turn, uint256 battleId) external;\\r\\n  function getHeroBattle(uint256 battleId) external view returns (HeroBattle memory);\\r\\n  function fightCreateOrJoin(address user, uint256 cost, uint256 heroId, uint256 faction) external returns (uint256);\\r\\n  function calcRewards(uint256 battleId) external returns(uint256[3] memory);\\r\\n}\\r\\n\\r\\ncontract ShardWarriors {\\r\\n  using SafeMath for uint256;\\r\\n  IERC20 public USDTBep20;\\r\\n  address public USDTBep20address = 0x55d398326f99059fF775485246999027B3197955; //0xD0071e9142638E4d88C9011799ED117536Dcd19c; //0x337610d27c682E347C9cD60BD4b3b107C9d34dDd;//0x55d398326f99059fF775485246999027B3197955; //USDT Bep20\\r\\n  using ShardWarriorsLibrary for *;\\r\\n  IShardWarriorsGame gameContract;\\r\\n\\r\\n  event addShardEvent(address indexed sender, uint256 value);\\r\\n  event withdrawGoldEvent(address indexed sender, uint256 value);\\r\\n\\r\\n  struct Building {\\r\\n    bool active; // flag indicating if the building is active\\r\\n    uint256 startTs; // start time of construction\\r\\n    uint256 endTs; // end time of construction\\r\\n    uint256 collectTs; // time to collect resources\\r\\n  }\\r\\n\\r\\n  struct Warrior {\\r\\n    uint256 faction; // 0) user faction\\r\\n    uint256 shard; // 1) shards = 100 gold\\r\\n    uint256 sphere; // 2) spheres = 1000 gold\\r\\n    uint256 gold; // 3) gold only\\r\\n    uint256 regTs; // 4) registration timestamp\\r\\n    //uint256 referals; // number of referrals\\r\\n    address refL1; // 5) L1 referral 3%\\r\\n    address refL2; // 6) L2 referral 2%\\r\\n    address refL3; // 7) L3 referral 1%\\r\\n    Building[24] myBuildings; // 8) user's buildings\\r\\n    uint256 myHero; // 9) user's hero\\r\\n    uint256 battleId; // 10) active battle\\r\\n  }\\r\\n\\r\\n  uint256 public totalBuildings; // total number of buildings\\r\\n  uint256 public totalWarriors; // total number of warriors\\r\\n  uint256 public totalHeroes; // total number of heroes\\r\\n  uint256 public totalInvestments; // total investments in the contract\\r\\n\\r\\n  mapping(address => Warrior) private warriors; // list of warriors by address\\r\\n\\r\\n  address payable public owner = payable(address(0x3DF0BCfB484BCc7e51ab3FFe04A2ceE2814a48fB)); // owner's address (3%)\\r\\n  address payable public manager = payable(address(0x1066B070920aeF7BE52d73E1EC0b2a727BFa1ff7)); // manager's address (2%)\\r\\n  address payable public marketing = payable(address(0xaC90af29a24A5a207F247CbC5212586125d253e1)); // marketing address (1%)\\r\\n\\r\\n  modifier onlyUser() {\\r\\n    require(msg.sender == tx.origin, \\\"Function can only be called by a user account.\\\");\\r\\n    require(msg.sender != address(0), \\\"Null address\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor(address gameContractAddress) {\\r\\n    USDTBep20 = IERC20(USDTBep20address);\\r\\n    gameContract = IShardWarriorsGame(gameContractAddress);\\r\\n  }\\r\\n\\r\\n  function getWarrior() external view onlyUser returns (Warrior memory) {\\r\\n    return warriors[msg.sender];\\r\\n  }\\r\\n\\r\\n  function registerMe(address referrer, uint256 faction)\\r\\n  external onlyUser {\\r\\n    address user = msg.sender;\\r\\n    require(warriors[user].regTs == 0, \\\"already registered\\\");\\r\\n    require(faction >= 0 && faction < 4, \\\"no faction\\\");\\r\\n    totalWarriors = totalWarriors.add(1);\\r\\n\\r\\n    // refs\\r\\n    address refL1 = warriors[referrer].regTs == 0 ? marketing: referrer;\\r\\n    address refL2 = warriors[refL1].regTs == 0 ? marketing: warriors[refL1].refL1;\\r\\n    address refL3 = warriors[refL2].regTs == 0 ? marketing: warriors[refL2].refL1;\\r\\n\\r\\n    //set user refs\\r\\n    warriors[user].refL1 = refL1;\\r\\n    warriors[user].refL2 = refL2;\\r\\n    warriors[user].refL3 = refL3;\\r\\n    warriors[user].faction = faction;\\r\\n\\r\\n    warriors[user].regTs = block.timestamp; //\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0430\\r\\n    // helper fillHeroesStats function random fill heroes stats\\r\\n    require(gameContract.fillHeroesStats(user, faction), \\\"Error creating heroes!\\\");\\r\\n  }\\r\\n\\r\\n  // purchase shards\\r\\n  function addShard (uint256 amountUSDT)\\r\\n  external onlyUser {\\r\\n    address user = msg.sender;\\r\\n    require(warriors[user].regTs != 0, \\\"not registered\\\");\\r\\n\\r\\n    uint256 shard = amountUSDT.mul(120).div(1e18); //msg.value.div(2e13);\\r\\n    require(shard > 0, \\\"Zero shard\\\");\\r\\n    require(USDTBep20.transferFrom(address(msg.sender), address(this), amountUSDT), \\\"Error transfer USDT\\\");\\r\\n\\r\\n    totalInvestments = totalInvestments.add(amountUSDT.div(1e18));\\r\\n\\r\\n    // calc refs gold\\r\\n    address rL1 = warriors[user].refL1;\\r\\n    address rL2 = warriors[user].refL2;\\r\\n    address rL3 = warriors[user].refL3;\\r\\n\\r\\n    warriors[rL1].gold = warriors[rL1].gold.add(shard.mul(3));\\r\\n    warriors[rL2].gold = warriors[rL2].gold.add(shard.mul(2));\\r\\n    warriors[rL3].gold = warriors[rL3].gold.add(shard.mul(1));\\r\\n\\r\\n    // commission calculations\\r\\n    uint256 goldFee = amountUSDT.mul(3).div(100);\\r\\n    uint256 managerFee = amountUSDT.mul(2).div(100);\\r\\n    uint256 marketingFee = amountUSDT.mul(1).div(100);\\r\\n\\r\\n    payUSDT(goldFee, owner);\\r\\n    payUSDT(managerFee, manager);\\r\\n    payUSDT(marketingFee, marketing);\\r\\n    warriors[user].shard = warriors[user].shard.add(shard);\\r\\n    emit addShardEvent(user, amountUSDT);\\r\\n  }\\r\\n\\r\\n  // The function withdrawGold allows the user to withdraw gold from the smart contract\\r\\n  function withdrawGold (uint256 amount)\\r\\n  external onlyUser {\\r\\n    // Check that the function is called by the user and not by another contract\\r\\n    // Check that the amount of gold is greater than or equal to 100\\r\\n    require(amount >= 100, \\\"Invalid amount\\\");\\r\\n\\r\\n    // Address of the transaction sender\\r\\n    address user = msg.sender;\\r\\n\\r\\n    // Amount of USDT to withdraw gold\\r\\n    uint256 usdt = amount.mul(1e18).div(120).div(100); //12000=1usdt\\r\\n    warriors[user].gold = warriors[user].gold.sub(amount);\\r\\n\\r\\n    // Transfer the funds if the contract has sufficient balance\\r\\n    payUSDT(usdt, user);\\r\\n\\r\\n    emit withdrawGoldEvent(user, usdt);\\r\\n  }\\r\\n\\r\\n  // The function swapGoldForShard allows the user to exchange gold for shards\\r\\n  function swapGoldForShardOrSphere(uint256 amount, bool sphere)\\r\\n  external onlyUser {\\r\\n    // Check that the amount of gold is greater than or equal to 100\\r\\n    require(amount >= 100, \\\"Invalid amount\\\");\\r\\n    // Address of the transaction sender\\r\\n    address user = msg.sender;\\r\\n\\r\\n    // Modify the contract state: subtract the amount of gold from the user and add shards\\r\\n    warriors[user].gold = warriors[user].gold.sub(amount);\\r\\n    if (sphere)\\r\\n      warriors[user].sphere = warriors[user].sphere.add(amount.div(1000));\\r\\n    else\\r\\n      warriors[user].shard = warriors[user].shard.add(amount.div(100));\\r\\n\\r\\n  }\\r\\n\\r\\n  // The function purchaseBuilding allows the user to purchase a building\\r\\n  function purchaseBuilding (uint256 buildingId)\\r\\n  external onlyUser {\\r\\n    // Check that the building identifier is less than 24\\r\\n    require(buildingId < 24, \\\"No such building\\\");\\r\\n    // Address of the transaction sender\\r\\n    address user = msg.sender;\\r\\n    // Check that the building has not already been purchased by the user\\r\\n    require(\\r\\n      warriors[user].myBuildings[buildingId].active == false,\\r\\n      \\\"This building already exists!\\\"\\r\\n    );\\r\\n    // Synchronize user data\\r\\n    syncWarrior(user);\\r\\n    // Modify the contract state: set the building parameters\\r\\n    warriors[user].myBuildings[buildingId].active = true;\\r\\n\\r\\n    warriors[user].myBuildings[buildingId].startTs = block.timestamp;\\r\\n    warriors[user].myBuildings[buildingId].endTs = block.timestamp + 100 days;\\r\\n    warriors[user].myBuildings[buildingId].collectTs = block.timestamp;\\r\\n    totalBuildings = totalBuildings.add(1);\\r\\n\\r\\n    // Deduct the cost of the building from shards or spheres depending on its identifier\\r\\n    if (buildingId < 12)\\r\\n      warriors[user].shard = warriors[user].shard.sub(ShardWarriorsLibrary.getPurchaseBuildingPrice(buildingId));\\r\\n    if (buildingId >= 12 && buildingId < 24)\\r\\n      warriors[user].sphere = warriors[user].sphere.sub(ShardWarriorsLibrary.getPurchaseBuildingPrice(buildingId));\\r\\n\\r\\n  }\\r\\n\\r\\n  function purchaseHero (uint256 heroId)\\r\\n  external onlyUser {\\r\\n    // Check if heroId is less than 20\\r\\n    require(heroId < 20, \\\"No such hero\\\");\\r\\n    // Transaction sender address\\r\\n    address user = msg.sender;\\r\\n    // Check if the user has not already purchased a hero\\r\\n    require(\\r\\n      warriors[user].myHero == 0,\\r\\n      \\\"You got hero already!\\\"\\r\\n    );\\r\\n    // Check if the hero is not currently in battle\\r\\n    require(\\r\\n      warriors[user].battleId == 0,\\r\\n      \\\"You are in battle!\\\"\\r\\n    );\\r\\n\\r\\n    // Check if the hero is not dead\\r\\n    require(gameContract.isHeroDead(user, heroId) == false,\\r\\n      //armies[user].stat[heroId].isDead == false,\\r\\n      \\\"This hero is Dead!\\\"\\r\\n    );\\r\\n    // Deduct the cost of the hero from shards\\r\\n    warriors[user].shard = warriors[user].shard.sub(2400);\\r\\n    totalHeroes = totalHeroes.add(1);\\r\\n    gameContract.setHeroLevel(user, heroId);\\r\\n    // Save the selected hero\\r\\n    warriors[user].myHero = heroId.add(1);\\r\\n  }\\r\\n\\r\\n  function upgradeHero (uint256 statIndex)\\r\\n  external onlyUser {\\r\\n    // Transaction sender address\\r\\n    address user = msg.sender;\\r\\n    // Check if the statIndex is valid\\r\\n    require(statIndex < 5, \\\"No such stat\\\");\\r\\n    // Check if the hero is not currently in battle\\r\\n    require(\\r\\n      warriors[user].battleId == 0,\\r\\n      \\\"You are in battle!\\\"\\r\\n    );\\r\\n    uint256 heroId = warriors[user].myHero;\\r\\n    // Check if the heroId is valid\\r\\n    require(heroId > 0 && heroId < 21, \\\"No such hero\\\");\\r\\n\\r\\n    heroId = heroId.sub(1);\\r\\n\\r\\n    uint256 heroLevel = gameContract.getHeroLevel(user, heroId);\\r\\n    //armies[user].stat[heroId].level;\\r\\n\\r\\n    // Check if the hero level does not exceed the maximum value\\r\\n    require(heroLevel <= 20, \\\"Max hero level exceeded\\\");\\r\\n\\r\\n    // Deduct the cost of upgrading the hero from shards or spheres depending on its level\\r\\n    if (heroLevel <= 10)\\r\\n      warriors[user].shard = warriors[user].shard.sub(ShardWarriorsLibrary.getUpgradeHeroPrice()); //heroLevel));\\r\\n    if (heroLevel > 10 && heroLevel <= 20)\\r\\n      warriors[user].sphere = warriors[user].sphere.sub(ShardWarriorsLibrary.getUpgradeHeroPriceSphere()); //heroLevel));\\r\\n\\r\\n    require(gameContract.setUpgradeHeroLevel(user, heroId, statIndex), \\\"Error upgrading\\\");\\r\\n\\r\\n  }\\r\\n\\r\\n  function killHero()\\r\\n  external onlyUser {\\r\\n    // Transaction sender address\\r\\n    address user = msg.sender;\\r\\n    // Check if the hero is not currently in battle\\r\\n    require(\\r\\n      warriors[user].battleId == 0,\\r\\n      \\\"You are in battle!\\\"\\r\\n    );\\r\\n    uint256 heroId = warriors[user].myHero;\\r\\n    // Check if the heroId is valid\\r\\n    require(heroId > 0 && heroId < 21, \\\"No such hero\\\");\\r\\n\\r\\n    heroId = heroId.sub(1);\\r\\n    require(gameContract.setHeroDead(user, heroId), \\\"Can't dismiss hero!\\\");\\r\\n    warriors[user].myHero = 0;\\r\\n\\r\\n    totalHeroes = totalHeroes.sub(1);\\r\\n  }\\r\\n\\r\\n  // The collectGold function allows the user to collect accumulated gold\\r\\n  function collectGold()\\r\\n  external onlyUser {\\r\\n    // Transaction sender address\\r\\n    address user = msg.sender;\\r\\n    // Check if the user is registered\\r\\n    require(warriors[user].regTs > 0, \\\"User is not registered\\\");\\r\\n\\r\\n    // Synchronize user data\\r\\n    syncWarrior(user);\\r\\n\\r\\n  }\\r\\n\\r\\n  // The auxiliary function syncWarrior synchronizes user data\\r\\n  function syncWarrior(address user) internal {\\r\\n    // Check if the user is registered\\r\\n    uint256 gold = 0;\\r\\n    for (uint i = 0; i < 24; i++) {\\r\\n      // Check if the building is active and its end time is greater than the current time\\r\\n      if (warriors[user].myBuildings[i].active == true &&\\r\\n        warriors[user].myBuildings[i].endTs > block.timestamp) {\\r\\n\\r\\n        // Calculate the elapsed time in hours\\r\\n        uint256 hoursElapsed = block.timestamp.div(3600).sub(warriors[user].myBuildings[i].collectTs.div(3600));\\r\\n        // Increase the gold collection time by the number of elapsed hours\\r\\n        warriors[user].myBuildings[i].collectTs = warriors[user].myBuildings[i].collectTs.add(hoursElapsed.mul(3600));\\r\\n        if (hoursElapsed > 24) hoursElapsed = 24;\\r\\n        // Calculate the amount of gold earned during the elapsed time\\r\\n        gold = hoursElapsed.mul(ShardWarriorsLibrary.getBuildingYield(i));\\r\\n\\r\\n        // Increase the user's gold amount\\r\\n        warriors[user].gold = warriors[user].gold.add(gold);\\r\\n\\r\\n      }\\r\\n      // Check if the building is active and its end time is less than or equal to the current time\\r\\n      if (warriors[user].myBuildings[i].active == true &&\\r\\n        warriors[user].myBuildings[i].endTs <= block.timestamp) {\\r\\n\\r\\n        // Deactivate the building and calculate the elapsed time in hours\\r\\n        warriors[user].myBuildings[i].active = false;\\r\\n        uint256 hoursElapsed = warriors[user].myBuildings[i].endTs.div(3600).sub(warriors[user].myBuildings[i].collectTs.div(3600));\\r\\n        // Increase the gold collection time by the number of elapsed hours\\r\\n        warriors[user].myBuildings[i].collectTs = warriors[user].myBuildings[i].collectTs.add(hoursElapsed.mul(3600));\\r\\n\\r\\n        if (hoursElapsed > 24) {\\r\\n          hoursElapsed = 24;\\r\\n        } else {\\r\\n          // If the building end time is less than 24 hours, calculate the elapsed time in minutes\\r\\n          uint256 minutesElapsed = warriors[user].myBuildings[i].endTs.div(60).sub(warriors[user].myBuildings[i].collectTs.div(60));\\r\\n          warriors[user].myBuildings[i].collectTs = block.timestamp;\\r\\n          // Calculate the gold earned during the elapsed minutes\\r\\n          gold = minutesElapsed.mul(ShardWarriorsLibrary.getBuildingYield(i)).div(60);\\r\\n        }\\r\\n        // Calculate the gold earned during the elapsed hours\\r\\n        gold = gold.add(hoursElapsed.mul(ShardWarriorsLibrary.getBuildingYield(i)));\\r\\n        totalBuildings = totalBuildings.sub(1);\\r\\n        warriors[user].myBuildings[i].startTs = 0;\\r\\n        warriors[user].myBuildings[i].endTs = 0;\\r\\n        warriors[user].myBuildings[i].collectTs = 0;\\r\\n        // Increase the user's gold amount\\r\\n        warriors[user].gold = warriors[user].gold.add(gold);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function getHeroId(address user)\\r\\n  external view returns(uint256) {\\r\\n    //require(isRegistered(user), \\\"User is not registered\\\");\\r\\n    require(warriors[user].myHero > 0 && warriors[user].myHero < 21, \\\"No hero\\\");\\r\\n    return warriors[user].myHero.sub(1);\\r\\n  }\\r\\n\\r\\n  function getHeroFaction(address user)\\r\\n  external view returns(uint256) {\\r\\n    require(isRegistered(user), \\\"User is not registered\\\");\\r\\n    return warriors[user].faction;\\r\\n  }\\r\\n\\r\\n  function isRegistered(address user)\\r\\n  public view returns (bool) {\\r\\n    return warriors[user].regTs > 0;\\r\\n  }\\r\\n\\r\\n  function finishBattle()\\r\\n  external onlyUser returns (bool) {\\r\\n    address user = msg.sender;\\r\\n    require(warriors[user].battleId > 0, \\\"No rewards\\\");\\r\\n    IShardWarriorsGame.HeroBattle memory checkBattle = gameContract.getHeroBattle(warriors[user].battleId);\\r\\n    warriors[checkBattle.player1].battleId = 0;\\r\\n    warriors[checkBattle.player2].battleId = 0;\\r\\n    uint256[3] memory result = gameContract.calcRewards(checkBattle.id);\\r\\n    uint256 reward = result[0];\\r\\n    uint256 rtype = result[1];\\r\\n    uint256 usdt = result[2].mul(1e18);\\r\\n    if (checkBattle.result == 3) {\\r\\n      if (rtype == 1) {\\r\\n        warriors[checkBattle.player1].shard = warriors[checkBattle.player1].shard.add(reward);\\r\\n        warriors[checkBattle.player2].shard = warriors[checkBattle.player2].shard.add(reward);\\r\\n      } else {\\r\\n        warriors[checkBattle.player1].sphere = warriors[checkBattle.player1].sphere.add(reward);\\r\\n        warriors[checkBattle.player2].sphere = warriors[checkBattle.player2].sphere.add(reward);\\r\\n      }\\r\\n    } else {\\r\\n      address winner;\\r\\n      if (checkBattle.result == 1) winner = checkBattle.player1;\\r\\n      else if (checkBattle.result == 2) winner = checkBattle.player2;\\r\\n      require(winner != address(0));\\r\\n      if (rtype == 1) {\\r\\n        warriors[winner].shard = warriors[winner].shard.add(reward);\\r\\n      } else {\\r\\n        warriors[winner].sphere = warriors[winner].sphere.add(reward);\\r\\n      }\\r\\n\\r\\n    }\\r\\n\\r\\n    // System commission of 10% for marketing\\r\\n    // Transfer funds if there is sufficient balance on the contract\\r\\n    payUSDT(usdt, marketing);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function fightCreateOrJoin(uint256 cost)\\r\\n  external onlyUser {\\r\\n    address user = msg.sender;\\r\\n    //require(isRegistered(user), \\\"User is not registered\\\");\\r\\n    require(warriors[user].battleId == 0, \\\"Youre in fight!\\\");\\r\\n    require(warriors[user].myHero > 0 && warriors[user].myHero < 21, \\\"No hero\\\");\\r\\n    if (gameContract.getHeroLevel(user, warriors[user].myHero.sub(1)) <= 10)\\r\\n      warriors[user].shard = warriors[user].shard.sub(cost.add(1).mul(1000));\\r\\n    else\\r\\n      warriors[user].sphere = warriors[user].sphere.sub(cost.add(1).mul(100));\\r\\n    uint256 id = gameContract.fightCreateOrJoin(user, cost, warriors[user].myHero.sub(1), warriors[user].faction);\\r\\n    require(id > 0, \\\"Fight error\\\");\\r\\n\\r\\n    warriors[user].battleId = id;\\r\\n  }\\r\\n\\r\\n  function fightTurn(uint256 turn)\\r\\n  external onlyUser returns(bool) {\\r\\n\\r\\n    address user = msg.sender;\\r\\n    // Check if the user is registered\\r\\n    //require(warriors[user].regTs > 0, \\\"User is not registered\\\");\\r\\n    require(warriors[user].battleId > 0, \\\"No battle\\\");\\r\\n\\r\\n    uint256 battleId = warriors[user].battleId;\\r\\n    gameContract.fightTurn(user, turn, battleId);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function payUSDT(uint256 amountUSDT, address user)\\r\\n  internal {\\r\\n    uint256 contractBalance = USDTBep20.balanceOf(address(this));\\r\\n\\r\\n    if (contractBalance < amountUSDT) {\\r\\n      amountUSDT = contractBalance;\\r\\n    }\\r\\n    // Check the success of the transfer\\r\\n    require(USDTBep20.transfer(payable(user), amountUSDT), \\\"Transfer failed.\\\");\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/shard_warriors_lib.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\n\\r\\nlibrary ShardWarriorsLibrary {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  // helper getPurchaseBuildingPrice returns building purchase cost\\r\\n  function getPurchaseBuildingPrice(uint256 buildingId)\\r\\n  external\\r\\n  pure\\r\\n  returns (uint256) {\\r\\n    // Check that the building identifier is less than 24\\r\\n    require(buildingId < 24, \\\"No such building\\\");\\r\\n    // If the building identifier is less than 12, return the price calculated based on the formula\\r\\n    if (buildingId < 12)\\r\\n      return buildingId.add(1).mul(2400);\\r\\n    // If the building identifier is greater than or equal to 12 and less than 24, return the price calculated based on the formula\\r\\n    if (buildingId >= 12 && buildingId < 24)\\r\\n      return buildingId.add(1).mul(240);\\r\\n    revert();\\r\\n  }\\r\\n\\r\\n  // helper getBuildingYield building yield\\r\\n  function getBuildingYield(uint256 buildingId)\\r\\n  public\\r\\n  pure\\r\\n  returns (uint256) {\\r\\n    // Check that the building identifier is less than 24\\r\\n    require(buildingId < 24, \\\"No such building\\\");\\r\\n    // The variable \\\"percent\\\" is calculated based on the formula\\r\\n    uint256 percent = 20 + buildingId.div(12)+ buildingId.div(14)+buildingId.div(16)+buildingId.div(18)+buildingId.div(20)+buildingId.div(22);\\r\\n    // Return the yield calculated based on the formula\\r\\n    return buildingId.add(1).mul(240).div(24).mul(percent);\\r\\n  }\\r\\n\\r\\n  // helper getUpgradeHeroPrice returns hero cost\\r\\n  function getUpgradeHeroPrice()\\r\\n  external pure returns (uint256) {\\r\\n    return 2400; //level.add(1).mul(2400);\\r\\n  }\\r\\n\\r\\n  // helper function  getUpgradeHeroPriceSphere returns upgrade hero cost in sphere\\r\\n  function getUpgradeHeroPriceSphere()\\r\\n  external pure returns (uint256) {\\r\\n    return 240; //level.sub(10).add(1).add(240);\\r\\n  }\\r\\n\\r\\n\\r\\n  // helper _randomNumber use to get pseudo random num\\r\\n  function _randomNumber(uint256 min, uint256 max, uint256 starthash)\\r\\n  internal view returns (uint8) {\\r\\n    // randomize hash\\r\\n    uint8 hashByte;\\r\\n    bytes32 transactionHash = keccak256(abi.encodePacked(tx.origin, tx.gasprice, block.timestamp, msg.data));\\r\\n    // pseudorandomize hash\\r\\n    for (uint j = 0; j < starthash % 10; j++) {\\r\\n      transactionHash = keccak256(abi.encodePacked(transactionHash));\\r\\n    }\\r\\n    // get random num from transactionHash\\r\\n    for (uint j = 0; j < 10; j++) {\\r\\n      for (uint i = 0; i < 32; i++) {\\r\\n        hashByte = uint8(uint8(bytes1(transactionHash[i])));\\r\\n\\r\\n        // check random in our range\\r\\n        if (hashByte >= min && hashByte <= max) {\\r\\n          return uint8(hashByte);\\r\\n        }\\r\\n      }\\r\\n      transactionHash = keccak256(abi.encodePacked(transactionHash));\\r\\n    }\\r\\n\\r\\n    // if random number not found - error\\r\\n    revert(\\\"Error. No suitable random number found\\\");\\r\\n  }\\r\\n\\r\\n  function cleanUsername(string memory username)\\r\\n  external pure returns (string memory) {\\r\\n\\r\\n    bytes memory inputBytes = bytes(username);\\r\\n\\r\\n    if (inputBytes.length > 50) {\\r\\n      assembly {\\r\\n        mstore(inputBytes, 50)\\r\\n      }\\r\\n    }\\r\\n    uint256 resultLength = 0;\\r\\n    bytes memory resultBytes = new bytes(inputBytes.length);\\r\\n\\r\\n\\r\\n    for (uint256 i = 0; i < inputBytes.length; i++) {\\r\\n      bytes1 char = inputBytes[i];\\r\\n\\r\\n      if ((uint8(char) >= 48 && uint8(char) <= 57) || (uint8(char) >= 65 && uint8(char) <= 90) || (uint8(char) >= 97 && uint8(char) <= 122)) {\\r\\n        resultBytes[resultLength] = char;\\r\\n        resultLength++;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    bytes memory finalResultBytes = new bytes(resultLength);\\r\\n    for (uint256 i = 0; i < resultLength; i++) {\\r\\n      finalResultBytes[i] = resultBytes[i];\\r\\n    }\\r\\n\\r\\n    return string(finalResultBytes);\\r\\n  }\\r\\n\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {\r\n      \"/contracts/shard_warriors_lib.sol\": {\r\n        \"ShardWarriorsLibrary\": \"0x03D576464713537C1d2444560E39Cc20Ee6091aF\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"addShardEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawGoldEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USDTBep20\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTBep20address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"}],\"name\":\"addShard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"fightCreateOrJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"turn\",\"type\":\"uint256\"}],\"name\":\"fightTurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishBattle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getHeroFaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getHeroId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWarrior\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"faction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shard\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sphere\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"regTs\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refL1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refL2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refL3\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectTs\",\"type\":\"uint256\"}],\"internalType\":\"struct ShardWarriors.Building[24]\",\"name\":\"myBuildings\",\"type\":\"tuple[24]\"},{\"internalType\":\"uint256\",\"name\":\"myHero\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"battleId\",\"type\":\"uint256\"}],\"internalType\":\"struct ShardWarriors.Warrior\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buildingId\",\"type\":\"uint256\"}],\"name\":\"purchaseBuilding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"purchaseHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"faction\",\"type\":\"uint256\"}],\"name\":\"registerMe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sphere\",\"type\":\"bool\"}],\"name\":\"swapGoldForShardOrSphere\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuildings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHeroes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvestments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWarriors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"statIndex\",\"type\":\"uint256\"}],\"name\":\"upgradeHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ShardWarriors", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "00000000000000000000000059b448957316fbb356f051a45af9d85cb97784e8", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}