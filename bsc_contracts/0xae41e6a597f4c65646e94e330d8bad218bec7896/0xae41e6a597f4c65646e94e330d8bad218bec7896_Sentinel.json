{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\nlibrary Utils {\\n    // https://ethereum.stackexchange.com/a/83577\\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return \\\"Transaction reverted silently\\\";\\n        assembly {\\n            // Slice the sighash.\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n *\\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\\n * renounceOwnership. So we can support Proxy based upgradable contract\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\\n     * we require _owner == address(0), which is only possible when it's a delegateCall\\n     * because constructor sets _owner in contract state.\\n     */\\n    function initOwner() internal {\\n        require(_owner == address(0), \\\"owner already set\\\");\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/sentinel/Guard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../Ownable.sol\\\";\\n\\nabstract contract Guard is Ownable {\\n    enum GuardState {\\n        None,\\n        Guarded,\\n        Relaxed\\n    }\\n\\n    bool public relaxed;\\n    uint256 public numRelaxedGuards;\\n    uint256 public relaxThreshold;\\n    address[] public guards;\\n    mapping(address => GuardState) public guardStates; // guard address -> guard state\\n\\n    event GuardUpdated(address account, GuardState state);\\n    event RelaxStatusUpdated(bool relaxed);\\n    event RelaxThresholdUpdated(uint256 threshold, uint256 total);\\n\\n    function _initGuards(address[] memory _guards) internal {\\n        require(guards.length == 0, \\\"guards already initiated\\\");\\n        for (uint256 i = 0; i < _guards.length; i++) {\\n            _addGuard(_guards[i]);\\n        }\\n        _setRelaxThreshold(guards.length);\\n    }\\n\\n    // change GuardState of msg.sender from relaxed to guarded\\n    function guard() external {\\n        require(guardStates[msg.sender] == GuardState.Relaxed, \\\"invalid caller\\\");\\n        guardStates[msg.sender] = GuardState.Guarded;\\n        numRelaxedGuards--;\\n        _updateRelaxed();\\n        emit GuardUpdated(msg.sender, GuardState.Guarded);\\n    }\\n\\n    // change GuardState of msg.sender from guarded to relaxed\\n    function relax() external {\\n        require(guardStates[msg.sender] == GuardState.Guarded, \\\"invalid caller\\\");\\n        guardStates[msg.sender] = GuardState.Relaxed;\\n        numRelaxedGuards++;\\n        _updateRelaxed();\\n        emit GuardUpdated(msg.sender, GuardState.Relaxed);\\n    }\\n\\n    function updateGuards(\\n        address[] calldata _add,\\n        address[] calldata _remove,\\n        uint256 _newRelaxThreshold\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i < _remove.length; i++) {\\n            _removeGuard(_remove[i]);\\n        }\\n        for (uint256 i = 0; i < _add.length; i++) {\\n            _addGuard(_add[i]);\\n        }\\n        _setRelaxThreshold(_newRelaxThreshold);\\n    }\\n\\n    function _addGuard(address _account) private {\\n        require(guardStates[_account] == GuardState.None, \\\"account is already guard\\\");\\n        guards.push(_account);\\n        guardStates[_account] = GuardState.Guarded;\\n        emit GuardUpdated(_account, GuardState.Guarded);\\n    }\\n\\n    function _removeGuard(address _account) private {\\n        GuardState state = guardStates[_account];\\n        require(state != GuardState.None, \\\"account is not guard\\\");\\n        if (state == GuardState.Relaxed) {\\n            numRelaxedGuards--;\\n        }\\n        uint256 lastIndex = guards.length - 1;\\n        for (uint256 i = 0; i < guards.length; i++) {\\n            if (guards[i] == _account) {\\n                if (i < lastIndex) {\\n                    guards[i] = guards[lastIndex];\\n                }\\n                guards.pop();\\n                guardStates[_account] = GuardState.None;\\n                emit GuardUpdated(_account, GuardState.None);\\n                return;\\n            }\\n        }\\n        revert(\\\"guard not found\\\"); // this should never happen\\n    }\\n\\n    function setRelaxThreshold(uint256 _threshold) external onlyOwner {\\n        _setRelaxThreshold(_threshold);\\n    }\\n\\n    function _setRelaxThreshold(uint256 _threshold) private {\\n        require(_threshold <= guards.length, \\\"invalid threshold\\\");\\n        relaxThreshold = _threshold;\\n        _updateRelaxed();\\n        emit RelaxThresholdUpdated(_threshold, guards.length);\\n    }\\n\\n    function _updateRelaxed() private {\\n        bool _relaxed = numRelaxedGuards >= relaxThreshold;\\n        if (relaxed != _relaxed) {\\n            relaxed = _relaxed;\\n            emit RelaxStatusUpdated(relaxed);\\n        }\\n    }\\n\\n    function numGuards() public view returns (uint256) {\\n        return guards.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/sentinel/GuardedGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./Guard.sol\\\";\\n\\ninterface IBridge {\\n    // delayed transfer\\n    function setDelayPeriod(uint256 _period) external;\\n\\n    function delayPeriod() external view returns (uint256);\\n\\n    function setDelayThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) external;\\n\\n    function delayThresholds(address _token) external view returns (uint256);\\n\\n    // volume control\\n    function setEpochLength(uint256 _length) external;\\n\\n    function epochLength() external view returns (uint256);\\n\\n    function setEpochVolumeCaps(address[] calldata _tokens, uint256[] calldata _caps) external;\\n\\n    function epochVolumeCaps(address _token) external view returns (uint256);\\n\\n    // pool bridge\\n    function setMinAdd(address[] calldata _tokens, uint256[] calldata _amounts) external;\\n\\n    function minAdd(address _token) external view returns (uint256);\\n\\n    function setMinSend(address[] calldata _tokens, uint256[] calldata _amounts) external;\\n\\n    function minSend(address _token) external view returns (uint256);\\n\\n    function setMaxSend(address[] calldata _tokens, uint256[] calldata _amounts) external;\\n\\n    function maxSend(address _token) external view returns (uint256);\\n\\n    function setNativeTokenTransferGas(uint256 _gasUsed) external;\\n\\n    function setMinimalMaxSlippage(uint32 _minimalMaxSlippage) external;\\n\\n    // peg bridge\\n    function setMinDeposit(address[] calldata _tokens, uint256[] calldata _amounts) external;\\n\\n    function minDeposit(address _token) external view returns (uint256);\\n\\n    function setMaxDeposit(address[] calldata _tokens, uint256[] calldata _amounts) external;\\n\\n    function maxDeposit(address _token) external view returns (uint256);\\n\\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external;\\n\\n    function minBurn(address _token) external view returns (uint256);\\n\\n    function setMaxBurn(address[] calldata _tokens, uint256[] calldata _amounts) external;\\n\\n    function maxBurn(address _token) external view returns (uint256);\\n}\\n\\nabstract contract GuardedGovernor is Guard {\\n    uint64 public numGovernors;\\n    mapping(address => bool) public governors;\\n\\n    event GovernorUpdated(address account, bool added);\\n\\n    function _initGovernors(address[] memory _governors) internal {\\n        require(numGovernors == 0, \\\"governors already initiated\\\");\\n        for (uint256 i = 0; i < _governors.length; i++) {\\n            _addGovernor(_governors[i]);\\n        }\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(msg.sender), \\\"Caller is not governor\\\");\\n        _;\\n    }\\n\\n    // delayed transfer\\n\\n    function setDelayPeriod(address _target, uint256 _period) external onlyGovernor {\\n        if (!relaxed) {\\n            uint256 current = IBridge(_target).delayPeriod();\\n            require(_period > current, \\\"not in relax mode, can only increase period\\\");\\n        }\\n        IBridge(_target).setDelayPeriod(_period);\\n    }\\n\\n    function setDelayThresholds(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _thresholds\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).delayThresholds(_tokens[i]);\\n                require(_thresholds[i] > current, \\\"not in relax mode, can only increase threshold\\\");\\n            }\\n        }\\n        IBridge(_target).setDelayThresholds(_tokens, _thresholds);\\n    }\\n\\n    // volume control\\n\\n    function setEpochLength(address _target, uint256 _length) external onlyGovernor {\\n        if (!relaxed) {\\n            uint256 current = IBridge(_target).epochLength();\\n            require(_length > current, \\\"not in relax mode, can only increase length\\\");\\n        }\\n        IBridge(_target).setEpochLength(_length);\\n    }\\n\\n    function setEpochVolumeCaps(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _caps\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).epochVolumeCaps(_tokens[i]);\\n                require(_caps[i] < current, \\\"not in relax mode, can only reduce cap\\\");\\n            }\\n        }\\n        IBridge(_target).setEpochVolumeCaps(_tokens, _caps);\\n    }\\n\\n    // pool bridge\\n\\n    function setMinAdd(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _amounts\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).minAdd(_tokens[i]);\\n                require(_amounts[i] > current, \\\"not in relax mode, can only increase minAdd\\\");\\n            }\\n        }\\n        IBridge(_target).setMinAdd(_tokens, _amounts);\\n    }\\n\\n    function setMinSend(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _amounts\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).minSend(_tokens[i]);\\n                require(_amounts[i] > current, \\\"not in relax mode, can only increase minSend\\\");\\n            }\\n        }\\n        IBridge(_target).setMinSend(_tokens, _amounts);\\n    }\\n\\n    function setMaxSend(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _amounts\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).maxSend(_tokens[i]);\\n                require(_amounts[i] < current, \\\"not in relax mode, can only reduce maxSend\\\");\\n            }\\n        }\\n        IBridge(_target).setMaxSend(_tokens, _amounts);\\n    }\\n\\n    function setNativeTokenTransferGas(address _target, uint256 _gasUsed) external onlyGovernor {\\n        IBridge(_target).setNativeTokenTransferGas(_gasUsed);\\n    }\\n\\n    function setMinimalMaxSlippage(address _target, uint32 _minimalMaxSlippage) external onlyGovernor {\\n        IBridge(_target).setMinimalMaxSlippage(_minimalMaxSlippage);\\n    }\\n\\n    // peg bridge\\n\\n    function setMinDeposit(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _amounts\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).minDeposit(_tokens[i]);\\n                require(_amounts[i] > current, \\\"not in relax mode, can only increase minDeposit\\\");\\n            }\\n        }\\n        IBridge(_target).setMinDeposit(_tokens, _amounts);\\n    }\\n\\n    function setMaxDeposit(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _amounts\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).maxDeposit(_tokens[i]);\\n                require(_amounts[i] < current, \\\"not in relax mode, can only reduce maxDeposit\\\");\\n            }\\n        }\\n        IBridge(_target).setMaxDeposit(_tokens, _amounts);\\n    }\\n\\n    function setMinBurn(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _amounts\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).minBurn(_tokens[i]);\\n                require(_amounts[i] > current, \\\"not in relax mode, can only increase minBurn\\\");\\n            }\\n        }\\n        IBridge(_target).setMinBurn(_tokens, _amounts);\\n    }\\n\\n    function setMaxBurn(\\n        address _target,\\n        address[] calldata _tokens,\\n        uint256[] calldata _amounts\\n    ) external onlyGovernor {\\n        if (!relaxed) {\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\n                uint256 current = IBridge(_target).maxBurn(_tokens[i]);\\n                require(_amounts[i] < current, \\\"not in relax mode, can only reduce maxBurn\\\");\\n            }\\n        }\\n        IBridge(_target).setMaxBurn(_tokens, _amounts);\\n    }\\n\\n    function isGovernor(address _account) public view returns (bool) {\\n        return governors[_account];\\n    }\\n\\n    function addGovernors(address[] calldata _accounts) external onlyOwner {\\n        for (uint256 i = 0; i < _accounts.length; i++) {\\n            _addGovernor(_accounts[i]);\\n        }\\n    }\\n\\n    function _addGovernor(address _account) internal {\\n        require(!isGovernor(_account), \\\"Account is already governor\\\");\\n        governors[_account] = true;\\n        numGovernors++;\\n        emit GovernorUpdated(_account, true);\\n    }\\n\\n    function removeGovernors(address[] calldata _accounts) external onlyOwner {\\n        for (uint256 i = 0; i < _accounts.length; i++) {\\n            _removeGovernor(_accounts[i]);\\n        }\\n    }\\n\\n    function _removeGovernor(address _account) private {\\n        require(isGovernor(_account), \\\"Account is not governor\\\");\\n        governors[_account] = false;\\n        numGovernors--;\\n        emit GovernorUpdated(_account, false);\\n    }\\n\\n    function renounceGovernor() external {\\n        _removeGovernor(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/sentinel/GuardedPauser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./Guard.sol\\\";\\nimport \\\"../../libraries/Utils.sol\\\";\\n\\ninterface IPauser {\\n    function pause() external;\\n\\n    function unpause() external;\\n}\\n\\nabstract contract GuardedPauser is Guard {\\n    enum PauserRole {\\n        None,\\n        Full,\\n        PauseOnly\\n    }\\n\\n    uint64 public numPausers;\\n    mapping(address => PauserRole) public pausers;\\n\\n    event PauserUpdated(address account, PauserRole role);\\n    event Failed(address target, string reason);\\n\\n    function _initPausers(address[] memory _pausers) internal {\\n        require(numPausers == 0, \\\"pausers already initiated\\\");\\n        for (uint256 i = 0; i < _pausers.length; i++) {\\n            _addPauser(_pausers[i], PauserRole.Full);\\n        }\\n    }\\n\\n    function pause(address _target) public {\\n        require(pausers[msg.sender] != PauserRole.None, \\\"invalid caller\\\");\\n        IPauser(_target).pause();\\n    }\\n\\n    function pause(address[] calldata _targets) public {\\n        require(pausers[msg.sender] != PauserRole.None, \\\"invalid caller\\\");\\n        require(_targets.length > 0, \\\"empty target list\\\");\\n        bool hasSuccess;\\n        for (uint256 i = 0; i < _targets.length; i++) {\\n            (bool ok, bytes memory res) = address(_targets[i]).call(abi.encodeWithSelector(IPauser.pause.selector));\\n            if (ok) {\\n                hasSuccess = true;\\n            } else {\\n                emit Failed(_targets[i], Utils.getRevertMsg(res));\\n            }\\n        }\\n        require(hasSuccess, \\\"pause failed for all targets\\\");\\n    }\\n\\n    function unpause(address _target) public {\\n        require(pausers[msg.sender] == PauserRole.Full, \\\"invalid caller\\\");\\n        require(relaxed, \\\"not in relaxed mode\\\");\\n        IPauser(_target).unpause();\\n    }\\n\\n    function unpause(address[] calldata _targets) public {\\n        require(pausers[msg.sender] == PauserRole.Full, \\\"invalid caller\\\");\\n        require(relaxed, \\\"not in relaxed mode\\\");\\n        require(_targets.length > 0, \\\"empty target list\\\");\\n        bool hasSuccess;\\n        for (uint256 i = 0; i < _targets.length; i++) {\\n            (bool ok, bytes memory res) = address(_targets[i]).call(abi.encodeWithSelector(IPauser.unpause.selector));\\n            if (ok) {\\n                hasSuccess = true;\\n            } else {\\n                emit Failed(_targets[i], Utils.getRevertMsg(res));\\n            }\\n        }\\n        require(hasSuccess, \\\"unpause failed for all targets\\\");\\n    }\\n\\n    function addPausers(address[] calldata _accounts, PauserRole[] calldata _roles) external onlyOwner {\\n        for (uint256 i = 0; i < _accounts.length; i++) {\\n            _addPauser(_accounts[i], _roles[i]);\\n        }\\n    }\\n\\n    function _addPauser(address _account, PauserRole _role) private {\\n        require(pausers[_account] == PauserRole.None, \\\"account is already pauser\\\");\\n        require(_role == PauserRole.Full || _role == PauserRole.PauseOnly, \\\"invalid role\\\");\\n        pausers[_account] = _role;\\n        numPausers++;\\n        emit PauserUpdated(_account, _role);\\n    }\\n\\n    function removePausers(address[] calldata _accounts) external onlyOwner {\\n        for (uint256 i = 0; i < _accounts.length; i++) {\\n            _removePauser(_accounts[i]);\\n        }\\n    }\\n\\n    function _removePauser(address _account) private {\\n        require(pausers[_account] != PauserRole.None, \\\"account is not pauser\\\");\\n        pausers[_account] = PauserRole.None;\\n        numPausers--;\\n        emit PauserUpdated(_account, PauserRole.None);\\n    }\\n\\n    function setPausers(address[] calldata _accounts, PauserRole[] calldata _roles) external onlyOwner {\\n        for (uint256 i = 0; i < _accounts.length; i++) {\\n            _setPauser(_accounts[i], _roles[i]);\\n        }\\n    }\\n\\n    function _setPauser(address _account, PauserRole _role) private {\\n        require(pausers[_account] != PauserRole.None, \\\"account is not pauser\\\");\\n        require(_role == PauserRole.Full || _role == PauserRole.PauseOnly, \\\"invalid role\\\");\\n        pausers[_account] = _role;\\n        emit PauserUpdated(_account, _role);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/sentinel/Sentinel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./GuardedPauser.sol\\\";\\nimport \\\"./GuardedGovernor.sol\\\";\\n\\ncontract Sentinel is GuardedPauser, GuardedGovernor {\\n    constructor(\\n        address[] memory _guards,\\n        address[] memory _pausers,\\n        address[] memory _governors\\n    ) {\\n        _initGuards(_guards);\\n        _initPausers(_pausers);\\n        _initGovernors(_governors);\\n    }\\n\\n    // This is to support upgradable deployment.\\n    // Only to be called by Proxy via delegateCall as initOwner will require _owner is 0,\\n    // so calling init on this contract directly will guarantee to fail\\n    function init(\\n        address[] memory _guards,\\n        address[] memory _pausers,\\n        address[] memory _governors\\n    ) external {\\n        initOwner();\\n        _initGuards(_guards);\\n        _initPausers(_pausers);\\n        _initGovernors(_governors);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_guards\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pausers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_governors\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"Failed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"added\",\"type\":\"bool\"}],\"name\":\"GovernorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Guard.GuardState\",\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"GuardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum GuardedPauser.PauserRole\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"PauserUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"relaxed\",\"type\":\"bool\"}],\"name\":\"RelaxStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"RelaxThresholdUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addGovernors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"enum GuardedPauser.PauserRole[]\",\"name\":\"_roles\",\"type\":\"uint8[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"guardStates\",\"outputs\":[{\"internalType\":\"enum Guard.GuardState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"guards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_guards\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pausers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_governors\",\"type\":\"address[]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numGovernors\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numGuards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numRelaxedGuards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"enum GuardedPauser.PauserRole\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relaxThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relaxed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeGovernors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_minimalMaxSlippage\",\"type\":\"uint32\"}],\"name\":\"setMinimalMaxSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasUsed\",\"type\":\"uint256\"}],\"name\":\"setNativeTokenTransferGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"enum GuardedPauser.PauserRole[]\",\"name\":\"_roles\",\"type\":\"uint8[]\"}],\"name\":\"setPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setRelaxThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_add\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_remove\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_newRelaxThreshold\",\"type\":\"uint256\"}],\"name\":\"updateGuards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Sentinel", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000083039377ddd862821d92d416b2ddb9efb5ba90000000000000000000000000008934b5d91a33269ad7e2202482a0df5ddbc5d4e10000000000000000000000000000000000000000000000000000000000000006000000000000000000000000ed9fdf5b16f9f254bec5ad389b80b48225186655000000000000000000000000dfe4f07d1f36b8d559b25082460a4f6a72531de200000000000000000000000034dfa1226f8b3e36fe597b34eea809a2b5c0bbf90000000000000000000000009ad3a3ca7d6b14e830de247c8ca3fad9d4c9d88c0000000000000000000000002fb8783c14a71c08bfc1de8fc3d715dd93039bf2000000000000000000000000e45cb56cee56dd1a94f7e5fbdfaa5bafb3c053d30000000000000000000000000000000000000000000000000000000000000004000000000000000000000000ed9fdf5b16f9f254bec5ad389b80b4822518665500000000000000000000000034dfa1226f8b3e36fe597b34eea809a2b5c0bbf90000000000000000000000009ad3a3ca7d6b14e830de247c8ca3fad9d4c9d88c00000000000000000000000040c11bddeb38dec685eed3586baebf086fac9da0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}