{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BinaryLandPro.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\nimport \\\"./mainbinaryland.sol\\\";\\r\\nimport \\\"./oldUsers.sol\\\";\\r\\ncontract BLP is Context {\\r\\n    using SafeERC20 for IERC20;\\r\\n    struct Node {uint32 LN;uint32 RN;uint32 CB;uint8 FC;uint32 TR;uint32 NB;uint32 RA;address L;address R;address U;int8 UD; bool ST;}\\r\\n    struct NodeA{uint32 LN;uint32 RN;uint32 CB;uint8 FC;uint32 TR;uint32 NB;uint32 RA;address N;address L;address R;address U;int8 UD;bool ST;}\\r\\n    mapping(address => Node) private _users;\\r\\n    mapping(address => bool) private _oldUsers;\\r\\n    address[] private _usersAddresses;\\r\\n    address private owner;\\r\\n    IERC20 private tetherToken;\\r\\n    uint256 private lastRun;\\r\\n    uint256 private registrationFee;\\r\\n    uint32 private numberOfRegisteredUsersIn_24Hours;\\r\\n    uint32 private numberOfNewBalanceIn_24Hours;\\r\\n    uint32 private constMaxBalanceForCalculatedReward;\\r\\n    Binary_Land private OC;\\r\\n    BLOC private BLOA;\\r\\n    event UserRegistered(address indexed upLine, address indexed newUser);\\r\\n\\r\\n    constructor() {\\r\\n        owner = _msgSender();\\r\\n        registrationFee = 1 * 10**18;\\r\\n        tetherToken = IERC20(0x55d398326f99059fF775485246999027B3197955); // bsc-usd\\r\\n        //tetherToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56); // busd\\r\\n        OC = Binary_Land(0xeE01EB63e5Bed116a7Db03260c5f0fb078325B3F);\\r\\n        BLOA = BLOC(0x6Be5F6eFa6E035e03FBda6777F0bbA62A8162b3d);\\r\\n        lastRun = block.timestamp;\\r\\n        numberOfRegisteredUsersIn_24Hours = 0;\\r\\n        numberOfNewBalanceIn_24Hours = 0;\\r\\n        constMaxBalanceForCalculatedReward = 8;\\r\\n        _users[owner] = Node(0,0,0,0,0,0,0,address(0),address(0),address(0),1,true);\\r\\n        _usersAddresses.push(owner);\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(_msgSender() == owner, \\\"Just owner can run this order!\\\");\\r\\n        _;\\r\\n    }\\r\\n    /************** Write Functions ***************/\\r\\n    function A_Register(address uplineAddress) external {\\r\\n        require( _users[uplineAddress].L == address(0) || _users[uplineAddress].R == address(0) ,\\\"This address has two directs and could not accept new members!\\\");\\r\\n        require(_msgSender() != uplineAddress,\\\"You can not enter your own address!\\\");\\r\\n        require(!_users[_msgSender()].ST, \\\"This address is already registered!\\\");\\r\\n        require(_users[uplineAddress].ST, \\\"This upline address is not exist!\\\");\\r\\n        uint32 NumberOfCurrentBalanced;\\r\\n        uint32 NB;\\r\\n        address temp_UplineAddress;\\r\\n        address temp_CurrentAddress;\\r\\n        int8 temp_DirectionOfCurrentNodeInUplineNode;\\r\\n        if (!_oldUsers[_msgSender()]) {\\r\\n            tetherToken.safeTransferFrom(\\r\\n                _msgSender(),\\r\\n                address(this),\\r\\n                registrationFee\\r\\n            );       \\r\\n        }\\r\\n        if(_users[uplineAddress].R == address(0)) {\\r\\n            _users[uplineAddress].R = _msgSender();\\r\\n            temp_DirectionOfCurrentNodeInUplineNode = 1;\\r\\n        } else {\\r\\n            _users[uplineAddress].L = _msgSender();\\r\\n            temp_DirectionOfCurrentNodeInUplineNode = -1;\\r\\n        }\\r\\n        _users[_msgSender()] = Node(0,0,0,0,0,0,0,address(0),address(0),uplineAddress,temp_DirectionOfCurrentNodeInUplineNode,true);\\r\\n        temp_UplineAddress = uplineAddress;\\r\\n        temp_CurrentAddress = _msgSender();\\r\\n        if (!_oldUsers[temp_CurrentAddress]) {\\r\\n            while (true) {\\r\\n                if (!_users[temp_UplineAddress].ST) {break;}\\r\\n                if (temp_DirectionOfCurrentNodeInUplineNode == 1) { _users[temp_UplineAddress].RN++;\\r\\n                } else { _users[temp_UplineAddress].LN++;}\\r\\n                NumberOfCurrentBalanced = _users[temp_UplineAddress].LN;\\r\\n                if ( _users[temp_UplineAddress].RN < NumberOfCurrentBalanced) { NumberOfCurrentBalanced = _users[temp_UplineAddress].RN;}\\r\\n                NB = NumberOfCurrentBalanced - (_users[temp_UplineAddress].CB + _users[temp_UplineAddress].NB); // combine the two lline for gas lower\\r\\n                if (NB > 0) {\\r\\n                    _users[temp_UplineAddress].NB = NB + _users[temp_UplineAddress].NB;\\r\\n                    if (_users[temp_UplineAddress].NB <= constMaxBalanceForCalculatedReward) { numberOfNewBalanceIn_24Hours = NB + numberOfNewBalanceIn_24Hours;}\\r\\n                }\\r\\n                temp_CurrentAddress = temp_UplineAddress;\\r\\n                temp_DirectionOfCurrentNodeInUplineNode = _users[temp_CurrentAddress].UD;\\r\\n                temp_UplineAddress = _users[temp_UplineAddress].U;\\r\\n            }\\r\\n            numberOfRegisteredUsersIn_24Hours++;\\r\\n        }\\r\\n        _usersAddresses.push(_msgSender());\\r\\n        emit UserRegistered(uplineAddress, _msgSender());\\r\\n    }\\r\\n    function B_Withdraw() external {\\r\\n        require(_users[_msgSender()].RA > 0, \\\"You have not received any reward yet\\\");\\r\\n        uint32 reward;\\r\\n        reward = _users[_msgSender()].RA;\\r\\n        _users[_msgSender()].TR += reward;\\r\\n        _users[_msgSender()].RA = 0;\\r\\n        tetherToken.safeTransfer(_msgSender(), reward);\\r\\n    }    \\r\\n    function C_Calculating_Rewards_In_24_Hours() external  {\\r\\n        //require(block.timestamp > lastRun + 1 days,\\\"The Calculating_Rewards_In_24_Hours time has not come.\\\");\\r\\n        uint32 rewardPerBalanced = D_Today_Reward_Per_Balance();\\r\\n        uint32 userReward;\\r\\n        for (uint256 i=0; i < _usersAddresses.length; i = i+1) {\\r\\n            if (_users[_usersAddresses[i]].NB > constMaxBalanceForCalculatedReward ) {\\r\\n                userReward = rewardPerBalanced * constMaxBalanceForCalculatedReward;\\r\\n                _users[_usersAddresses[i]].FC ++;\\r\\n            } else {userReward = rewardPerBalanced * _users[_usersAddresses[i]].NB; }\\r\\n            _users[_usersAddresses[i]].CB += _users[_usersAddresses[i]].NB;\\r\\n            _users[_usersAddresses[i]].NB = 0;\\r\\n            if (userReward > 0) { _users[_usersAddresses[i]].RA = _users[_usersAddresses[i]].RA + userReward;}\\r\\n        }\\r\\n        lastRun = block.timestamp;\\r\\n        numberOfRegisteredUsersIn_24Hours = 0;\\r\\n        numberOfNewBalanceIn_24Hours = 0;\\r\\n    }\\r\\n    function ChangeStableCoin(address Coin) external onlyOwner {\\r\\n        tetherToken = IERC20(Coin);\\r\\n    }    \\r\\n    function Emergency_72() onlyOwner external {\\r\\n        require( block.timestamp > lastRun + 3 days,\\\"The Emergency_72 time has not come!\\\");\\r\\n        require(tetherToken.balanceOf(address(this)) > 0 , \\\"Contract does not have any balance!\\\");\\r\\n        tetherToken.safeTransfer(owner,tetherToken.balanceOf(address(this)));\\r\\n    }\\r\\n    function Upload(address User) external onlyOwner {\\r\\n        require(!_users[User].ST , \\\"This address is already registered!\\\");\\r\\n        require(!_oldUsers[User] , \\\"This address is already registered in old user list!\\\");\\r\\n        _oldUsers[User] = true;\\r\\n    }\\r\\n    function Import_Users() external  onlyOwner{\\r\\n        address[] memory AD;\\r\\n        AD = BLOA.BLOF();\\r\\n        for(uint256 i = 0; i < AD.length; i++){\\r\\n            address UserAddress = AD[i];\\r\\n            _users[UserAddress] = Node(\\r\\n                uint32(OC.User_Information(UserAddress).NumberOfChildNodeOnLeft),\\r\\n                uint32(OC.User_Information(UserAddress).NumberOfChildNodeOnRight),\\r\\n                uint32(OC.User_Information(UserAddress).NumberOfBalancedCalculated),\\r\\n                0 ,\\r\\n                uint32(OC.User_Information(UserAddress).TotalUserRewarded),\\r\\n                uint32(OC.User_Information(UserAddress).NumberOfNewBalanced),\\r\\n                uint32(OC.User_Information(UserAddress).RewardAmountNotReleased),\\r\\n                OC.User_Information(UserAddress).LeftNode,\\r\\n                OC.User_Information(UserAddress).RightNode,\\r\\n                OC.User_Information(UserAddress).UplineAddress,\\r\\n                int8(OC.User_Information(UserAddress).DirectionOfCurrentNodeInUplineNode),\\r\\n                OC.User_Information(UserAddress).Status \\r\\n            );\\r\\n            _usersAddresses.push(UserAddress);\\r\\n        }\\r\\n    }\\r\\n    function Add(NodeA memory User) external onlyOwner{\\r\\n        _users[User.N] = Node(uint32(User.LN),uint32(User.RN),uint32(User.CB),uint8(User.FC),uint32(User.TR),uint32(User.NB),uint32(User.RA),User.L,User.R,User.U,int8(User.UD),User.ST );\\r\\n        _usersAddresses.push(User.N);\\r\\n    }\\r\\n    /************** Read Functions ***************/\\r\\n    function A_Today_Number_Of_Registrations() external view returns (uint256) {return numberOfRegisteredUsersIn_24Hours;}\\r\\n    function B_Total_Number_Of_Registrations() external view returns (uint256) {return _usersAddresses.length - 1;}    \\r\\n    function C_Today_Contract_Balance_Count() external view returns(uint32) {return numberOfNewBalanceIn_24Hours;}    \\r\\n    function D_Today_Reward_Per_Balance() public view returns (uint32) {\\r\\n        uint32 todayReward;\\r\\n        if (numberOfNewBalanceIn_24Hours == 0) {todayReward = 0;} \\r\\n        else { todayReward = uint32(registrationFee / 10 ** 18 ) * numberOfRegisteredUsersIn_24Hours / numberOfNewBalanceIn_24Hours;}\\r\\n        return todayReward; \\r\\n    }    \\r\\n    function E_Total_Payment() external view returns (uint256) {return (_usersAddresses.length - 1) * (registrationFee  / 10 ** 18);}    \\r\\n    function F_Registration_Fee() external view returns(uint256) {return registrationFee / 10 ** 18;}    \\r\\n    function G_Check_User(address UserAddress) external view returns (string memory){if(_users[UserAddress].ST){return \\\"User is already registered in the contract.\\\";} else {return \\\"User does not exist in the contract.\\\";}}\\r\\n    function H_Today_User_Balance_Count(address userAddress) external view returns(uint256) {return _users[userAddress].NB;}    \\r\\n    function I_User_Reward_Not_Released(address userAddress) external view returns(uint256) {return _users[userAddress].RA;}\\r\\n    function J_Total_User_Reward(address userAddress) external view returns(uint256) {return _users[userAddress].TR;}\\r\\n    function K_User_Left_Right_Count(address userAddress) external view returns(uint128 ,uint128) {return (_users[userAddress].LN,_users[userAddress].RN);}\\r\\n    function L_User_Information(address userAddress) external view returns(Node memory) {return _users[userAddress];}\\r\\n}\"\r\n    },\r\n    \"contracts/oldUsers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\r\\npragma solidity 0.8.7;\\r\\ncontract BLOC{ \\r\\n    address[] internal BLOA;\\r\\n    constructor(){ BLOA = [ \\r\\n        0x852C9a0d4392F79DEBe8DA39d0485ba891B42500,\\r\\n        0xE5422e406AEC5416Ce31FD58ebeEdC296599a2Bf,\\r\\n        0x54502E22a88ade952Ff91FE29cD244a1E79123d0,\\r\\n        0x29a30F2ECEa336026B6ed1971263fA34e6A5ce65,\\r\\n        0x978e09779C13b5cF2b785202AA263F1331131eA5,\\r\\n        0x9aC4159dF12Dc121f07f39fD5C323Ce6448f321C,\\r\\n        0x53a76fA4C994f8AE0A15F7c6dc6528006E848d53,\\r\\n        0x4224f6910c8FCAac458F1f1C2670B53AEDdC0c83,\\r\\n        0xE3B9716E72FeAE07fD8Ae427c7aEb9C6ef690017,\\r\\n        0x1B9D11a5795e5fFE1554F750230a3d69880F6c8b,\\r\\n        0x77F50600E20251Cc1B1A375eA34Cff0bfe8FC69f,\\r\\n        0x346ed580C44A7C6f82df350C5F626C99E9D51533,\\r\\n        0x3e664e2EF0aE910A224e2EdC312bcB07CC7f5cb8,\\r\\n        0x8486567B95041DE540Ddcf2f50887ccB373939a7,\\r\\n        0x9767aC999836a26eff30ceDECAb68550E9B754c2,\\r\\n        0xa2f2E5569c21372d5e3bb580E8ff930D1bB03eD2,\\r\\n        0xad80bA9B46422e88B8BAf68AfD57a9757C282372,\\r\\n        0xe91160c5E637c0233C8B13A98c3121817BF269D7,\\r\\n        0xD05A809E987eE50265b65F5c165dc343c8A6DC2D,\\r\\n        0x3A3022CFdEFB3b11b0178B532A933c89BA75a86A,\\r\\n        0x5FE6A0d8c22b8384585807232dd83ED57426a2f1,\\r\\n        0xe5486e1d56d57Cc7F7025D1B3c7083890f27433D,\\r\\n        0x639cd31c0e9160f090A80D2CCD10677C93c5Fa20,\\r\\n        0x24Aac45C88013ca7d8724671e64C3D40122e23Dc,\\r\\n        0xDDFfE187Ef0eae97EEb8FE4E7dc2e8262BF9a19d,\\r\\n        0xF777499d86c4609131D34b5999b87efA690f6963,\\r\\n        0x13f82692f61a4D2C7aDed21586ec36Fa2C02166C,\\r\\n        0x470ba23513589B24604eB1F9e4A2d3e23c5Ee1BA,\\r\\n        0x85df31A5590Fe3c851683dcFc09A54b4F9F245Ad,\\r\\n        0x4066565a39E8F1790c5989a50b32A85230989F7F,\\r\\n        0xD8300E2e34af84c8898Acc87DBdb9B850FE3F9BE,\\r\\n        0xF23BBE1d7D67005b3dF9c3c770A2aCeC857A72B5,\\r\\n        0xE8c8914365bf5a90cCaa8bcf27F27e1aa88Fc762,\\r\\n        0x77eD2D23122efc36A2B358FCDa336738346066c5,\\r\\n        0x22d5448e30BEE69e7D20e5265727B94D3a0197BF,\\r\\n        0xFb754CAB17070cE72AfB4D5935EC27324190Ca3B,\\r\\n        0x7ff2e87c4B225CDD6f50Ce1629d4206E83DC4e8B,\\r\\n        0x7475346767e8BB1716B7CE464e0e701fA493C4ba,\\r\\n        0x9F8c8649157A1592edb8FA420eE5864F92D1132a,\\r\\n        0xf0BdFA89578F73227ED704cd197540784bff5095,\\r\\n        0x711adCAAAfe578f2B454a4F9A4FB7F86d20aB6d3,\\r\\n        0x39A0271A05dED94c503fEc8507A4A4846400151f,\\r\\n        0xd1291EF9F599d89dCb6E392eB2498bFd9F16dAFc,\\r\\n        0x0767EA9b20E3d0F25d5dDADA52Db0841139a3381,\\r\\n        0x289d79Db3e0264305f8fdD86c6eccCe6b0A033f0,\\r\\n        0x5EaAd6A0e7991CF0023bc0Ce2C1647FD2FdfcAD9,\\r\\n        0x14f0ceb1EBa20cE02BC48974F1ce8820A39aB498,\\r\\n        0x2320018680552eC5588Cde50936f10b7a66697a0,\\r\\n        0xBf19E4c5DCdfDbf2aF8aE845782a3425114dC9e2,\\r\\n        0xFd24Eed1CD8B37d03c0b4B85f242d660B5c27684,\\r\\n        0x24947A919161F7b6A8Af5478e66FFeD77b034B2f,\\r\\n        0x14941cC9f88C295cdC5AB1Fbe3BB3e2E9b20c609,\\r\\n        0x088b8744DE658E6F6af9eBaccd8451369fE60265,\\r\\n        0xF3C8A0C1eAFe73a2F57067eccFE33079Da9d01e2,\\r\\n        0x1397beb987E7Eb1D6E5fcd7F90C119e3dAE8F0af,\\r\\n        0x55077C128A66bE910459E8bcc9A6F26bd7BF4Cf9,\\r\\n        0x5c7f4B38324Edde1c422AdcA4a50F89895fe7F7E,\\r\\n        0x3d7cCF48342D0bBd7813660944C4C0b0093CA680,\\r\\n        0xb6BB627eA0eE166a06b9fEf8DBA29f872BeAf3B6,\\r\\n        0x67E98fB866600F7010e6CFb08F0674226f795e42,\\r\\n        0xb29F88e4faa3608ff46A6Af88642035aE6cc6e69,\\r\\n        0x925Ae4d8CD1197CaA5B924bdc31FCB40eDdBd2c0,\\r\\n        0x9D56452e2093Cd4b6638b09458B26B78709FaC4D,\\r\\n        0x606dCD7Aa55Ec3185a25D82d3D92276E7128B684,\\r\\n        0x7CEFE87C01080F59ef77e300192Fe49E2a722ea4,\\r\\n        0x3D59234Af900f38Ff52b37C3BF09f153B53e2D31,\\r\\n        0x25026cD219ef8AFFACb756Afd0F146e4245A7Ff5,\\r\\n        0xd710E696Dc5c5c68037CE85e0DBa6597D61fc358,\\r\\n        0x12EfE725C55A6C09334d8371f87F99c08073b1b1,\\r\\n        0xE700f94d9C9F20F91d2FA59526B99C96585FDc61,\\r\\n        0x6Bd6bE6958e3f6d794fC7a1463bebE99f3f976cB,\\r\\n        0x3AE41490F91753b10E87A980aB1025BdB24Fa88b,\\r\\n        0x7993FA2FEc728be6Da48Ad57860039028de3F1A9,\\r\\n        0x46b329330b04D101c60e095f00c368240E4265de,\\r\\n        0x7326F194A5fd8079Ea95e7333eF6A7fE1DFa51D6,\\r\\n        0xD35b939aaD6Ffa42Ae62da840ec60A74eF31d4e4,\\r\\n        0xaae581c2E534765cD29E2207ce90ea83E1b5Efd6,\\r\\n        0x9b1dC3A98055D88472B124773E72e2e425cc1F75,\\r\\n        0x5C80E48D89124dB688b5209368aaD7cc42EdE613,\\r\\n        0x8DB3ECc90ba41047D481A30820Bb4eC7C1432743,\\r\\n        0x0E02f00a92830BCa28FebcEff326af3b62ad05FD,\\r\\n        0x1179106C0b36492aEeD56De61Fe19AE8B84EB74C,\\r\\n        0x580C960d510F079b904166fcaB4cbDf06c97797e,\\r\\n        0xF1416A453632581473b5FFce0cb7890e2990fD0c,\\r\\n        0x082aFC60072107d1e1907f5134ac9e80eB9479fC,\\r\\n        0x5bbeB486F261aaf3D84CB160475D676E08f82D2e,\\r\\n        0x21B481EA63E244A8011136d561957EA1b45D58eC,\\r\\n        0xCb39EA40A1Bcb66e31a552dA6aA6fbb81daAA6f0,\\r\\n        0xfa53d740845e4BC3e116DaA719A12B7AA1c6Ae8b,\\r\\n        0xE724e367106ee3481fC0a93163C250b2FD6Af738,\\r\\n        0x20D9f262e028FC8906F3d7eDe7D05E5303C7f0E5,\\r\\n        0xA74C5BBA210B6D353eA1a2a33cCfE209216c08e9,\\r\\n        0x9c2a3C738DeCB3A09B0bBa9F659810B347a2F424,\\r\\n        0xbdDf9F7d96D654F9a0CE7cE7D7b9Cd05063F7a49,\\r\\n        0xb46cDb5074A4B308b10f0840Bc832CF8B1c599CE,\\r\\n        0xd29674Ad7C923983249fd1b29494251D16dC984a,\\r\\n        0x24D52c031C67D29CB7703d2E0Be428d0f9e30894,\\r\\n        0x6A00ce7D7A679191c3B40d0ebf9054739295095d,\\r\\n        0x77eDC3d47dB611ec7D0B1E0Afda2e6a8a8d691EB,\\r\\n        0x6F9ba650E14476ACce8cFb95A9d10db9bb43B70b,\\r\\n        0xeb0b96658Cac5150090db2768f1fFc60b55c43CF,\\r\\n        0xE61d406852c36492Fb10000AE636ee43CCc49b4F,\\r\\n        0x65BA12453c892Be02F257124CFf1326031FB4cC6,\\r\\n        0xEA992a311CD623455518dAf7F62AacC750C42ccc,\\r\\n        0x96bF9394c9a86264d38b15C50fAdF11eB1BDB3B1,\\r\\n        0xce262AC363B6DdEE98De5FF7f233cD4cc6be3aaD,\\r\\n        0xC07EaF9F15394ADccE4a080cc9710FED41cD2Ce8,\\r\\n        0x78b7856Fe18EfbCF2B80204e27544e7791222298,\\r\\n        0x6bE83611beeCd97a9A3879E5d0Fa0111cDC9C014,\\r\\n        0x2386d59817512e25E3bD3BAD451aEAC598a0b3d4,\\r\\n        0x61E1d52edabeC2e0d7FcD4184cc46AFF2AA78d00,\\r\\n        0x84d74C230d1B5E9cD10654Dc280Bd20c68905E6a,\\r\\n        0x7595ddcE74499C4e15561B33f4BE7C4F02a721bB,\\r\\n        0x79cFd9aC4b5dE749d384bc8601114be2e4f2BA19,\\r\\n        0x988Bf72BE7fab992ac19E61126c4Af183Ce6e90D,\\r\\n        0xD0e7312a1b89856A8d346517C9104f8cBB074645,\\r\\n        0x44b6554B345A3092a3DAA3210e9b1347249Db52a,\\r\\n        0x65a5964e796bF026541B4AC1418A38C8DA8D5262,\\r\\n        0x1EbA82774a95A6C1A7ACBFfb99ad0B9f5E8a1D6D,\\r\\n        0x774609F1c34e59c65C3357f7Da9cB0776499E7A8,\\r\\n        0xFC98a5B6648cE7d62a253EDD37070E7d484e3185,\\r\\n        0x79bc1BE5054065355b28f33a17E8c6B95b206876,\\r\\n        0x3eba57a9abdDFBddBFEe77107c4F81384D2c42B9,\\r\\n        0xa0197cE062f879413A65B9f8979A35eEef062EB7,\\r\\n        0xdCA74b512dF907C9dE84677107aD5D559C5bA9aC,\\r\\n        0xb1a8bF576832eeE9bB613158dc9fdc7CE70ef99D,\\r\\n        0x1E9B37b6d5D63a033e8911d3bD950c3f2eE7d9Ea,\\r\\n        0x8d57F28445c42fb0Cc80f3a2F88157D54dadc158,\\r\\n        0x53Da71866744De8E9714b95f2Dd59ec0D3566BeC,\\r\\n        0x7113bD281c563231d8f3cEB3278062a2708ac895,\\r\\n        0xf6BF5c8953B54A7BcDC6f2AaC6814ce6a2b6bb88,\\r\\n        0xf97992CBe138409FC8817D461A01FcF3F56C1c19,\\r\\n        0x936bb9eF1DD4845Bed55af93859345664627E336,\\r\\n        0xd5383F5E83a0BFD3fb5515687C08ce44d7514D1c,\\r\\n        0x80137E81597D676B3F3D026e1fF4B3D13D0678A4,\\r\\n        0xAFcA87B7D43FC7a84EAC877C28C9Aa4cBE14cF15,\\r\\n        0x2575EAB22CDFeEEd0f62EDc36Fd27A5DF0d045dC,\\r\\n        0xcA82B0eac8F0768A1F8f76F9b0B6AEC6b52978F5,\\r\\n        0x2453a0B58eC05752301D686eafb1F266E546E968,\\r\\n        0xA06c3ccB9225A2aEd6633accD49A458875aDA522,\\r\\n        0x81ECfbD7241E0F70b345460E9f900AeAA7b48F44,\\r\\n        0xF9604281aB67fb764D56304eE2D9890De66dE7b1,\\r\\n        0x0250edA8Dd2fdC390A40296F0bA4ffF7C8340Ee9,\\r\\n        0x59206A66e763aaAcEed3cca845cE6399D3E68F33,\\r\\n        0x3201fB4995fd9a33503cD898fD15E0E73069a9F5,\\r\\n        0x518b66101E7f12F18d14d87d7dD770A4e35650F0,\\r\\n        0xB67c3a77ce52d5E8A2035134510F4346df0D4C20,\\r\\n        0x3e00cB1156b22734099b05C194E98bdF973c0129,\\r\\n        0x36590d4cD6cCAB9304934c8aE09D140CF1208E11,\\r\\n        0x7bEF09EF7a2CB05Cc3CF9eaf10D9505363869950,\\r\\n        0x0812BD203C03EeeeAB0E3f724Be9D82F44803B63,\\r\\n        0x17B545eC7c8093fD31A42828e15bFB93471E4De9,\\r\\n        0xf5b77d0562BCDF8aC1bB29b59409217C4D77Bb7F,\\r\\n        0x158b5414F3f97b85376A3A3E2aeF62D7E579D724,\\r\\n        0x2a430B0A5d2d703FB33455604Fe3c6317204CefA,\\r\\n        0xA55d9ba9169Dba5bbC7B3f0A7c42caC1D236d28c,\\r\\n        0x26e1DC5Dffd0396f1047faA8D8F6f0f76b6FBc1F,\\r\\n        0x5cb4117E3F2343C99c54D80F16Ba0f650414e7f3,\\r\\n        0x866cf536F4eF445e3CaB3Aa725630b8bEeF92F3a,\\r\\n        0x271aE634abA88f6CAf4c3A7e08e05045443CcAff,\\r\\n        0x0066cd8b28c177631325755C38f56BC1f2321815,\\r\\n        0xe6714d12A0cB99309Cb1619EEf66C12E97C42BF6,\\r\\n        0x868286985CDd843Ec658b66aD196520196580403,\\r\\n        0x90C52CbBF438d1f79bD43C6f0A01228F21d3dC58,\\r\\n        0x1e61AC69Fd03e9cD78CD495ab61909B27598d706,\\r\\n        0x90531f3396Ef9f1642Fc2e8BAC6dfa041523B7cB,\\r\\n        0x029B5f4960960eD795A247D8A31b08edB010F60c,\\r\\n        0xaDD038608098cf0ee56Da43345eE2410a603c6Bb,\\r\\n        0xbAaeEbcD85d4249070f8C492AFDD037124B40Ed8,\\r\\n        0x24381BE42d664f7d91495c8328d20Cd194B43a81,\\r\\n        0x350Adf756B73118FD085547f3A4337F66bC3aDe0,\\r\\n        0x75Aee56c9FdCf3efaE646537B379b5b5041AB6A1,\\r\\n        0xBc76f54F90D233EA38B746786771fd20E3a4D8d3,\\r\\n        0x4F9Be3b2c15bffF2F69285EBcC432C41a4d4E729,\\r\\n        0xEaeC92ACb99B0e0422D299Be2a14f569aBF3A1a9,\\r\\n        0xF504da28503f964D667440b1FE4781cC1Dbdb7Ca,\\r\\n        0xfba8378691F826acb2DF994f8C95fe80AdC13dff,\\r\\n        0xCAEce60ed7110F1de862770E5233B262e181d501,\\r\\n        0x4FD0CBF8A14BC83834737076C95eB611522d131e,\\r\\n        0xa8944884A2B7b68B5B2B1E610D0752e3EB2AfDF1,\\r\\n        0x11990cabBaAeb7A61b6B545b2926c6cd64793350,\\r\\n        0x12660b6F4d260B4CcB546114936b57c3964f6D0d,\\r\\n        0xC70dFB4a7248386c7b80d28ce4681f60CCA785ab,\\r\\n        0xBF9beC7ED57dab9eeF3B7b07cabA6AdF8E6F7612,\\r\\n        0x5a3a92b8Af80e645ddb2Bd17b66C73678c545680,\\r\\n        0x0334b93FF8AA58fb462eDD01b765c6dCa56449FB,\\r\\n        0xc371eC951AE558f1e183d7E87020e573FbDC16D1,\\r\\n        0x23c51Cb17dF5BFEEb83469c77096c39F950F503b,\\r\\n        0x6459f50e8b18b5069Baa180126B7bb85E1c0e28A,\\r\\n        0x1982629C0205906eC6048F1b4ad3414652f4fbe0,\\r\\n        0x5dEa9ACfb42EeF8c4e1D18F3d0D4667E3C6Cee6e,\\r\\n        0x6b0D5d51f19c2d271045826E30d4dDF6E771E6d9,\\r\\n        0xaF0cCd361AbD078aac9C362E2990e40B25C9Aaa9,\\r\\n        0x37572AbFD3DCFcC0E11f8a7775A1b6F7CEB7D314,\\r\\n        0xb3E732219E3e8251cBE34315848efe083eB87039,\\r\\n        0x98D07801462A804fC1dEaaDafBA16ceD7525782e,\\r\\n        0xEF4D83B5C0245Aac4867ED57fA29515F14b0094F,\\r\\n        0x299249c486B713eA3b0FC3bc42790060361a00a2,\\r\\n        0xbb1A4BC5C9218Bd6a6a783497E434BCABB4A45Ae,\\r\\n        0x67E6c4366A52Ae6B4be84f86011b5eBe7BAeB618,\\r\\n        0x4b32C268C92290D62700d5A72B43952b5867e195,\\r\\n        0xE15f1C118f0Ad6EA04b633B22FC2a87766E41508,\\r\\n        0xFFd1338680739669860A51f71a7e4600520086FE,\\r\\n        0x5EdA25189dE22F4e5Cd1f31058e42990dD5B203B,\\r\\n        0x668568F9AB1F610DA6718c6f5A2b9cA7f8f06062,\\r\\n        0x86B4335D902f8C685445BC167b4a0F27F35144Da,\\r\\n        0x2e4090E550532814544693f3354592962384e410,\\r\\n        0x028fdd3bF5330F421E88404F92c923C01335e9Cc,\\r\\n        0xAcCe6735A87d3313CD19C3Cc2e8fC4B7cA733281,\\r\\n        0x66d7293da168D614254BF1C85722017F3A08c08c,\\r\\n        0x67B437fe315f56227f120527AC1c9aA773Db1f44,\\r\\n        0x974a3C721401b3ee4e9DD9fc0e28F476f68C93F7,\\r\\n        0x8781DC52e4b4A29cc3Ff1799d38ab3292E49ab95,\\r\\n        0x4085a0420c0096996237F9658cc8C0575B4A4d21,\\r\\n        0x016d765283B3cE35A079ffaDb474ABeFDc5B059B,\\r\\n        0x834920784f3438050EeFBf952659Fa67463105eF,\\r\\n        0x5ab879F0087Db296b536A391726FC5Cd7DfE8D0B,\\r\\n        0x87b32a2418496D8dFE4011624b3BF82A7F0A9529,\\r\\n        0x5484242F3Ac9dB4814CdBA0a02f91A7081Ee4F33,\\r\\n        0x2612Ef04936Fd65ae7e3aD2A8217003084634450,\\r\\n        0xA2903aE673d14aB656765908F066BAc44F48de20,\\r\\n        0x5FD890c9E459ff1a8fbc2C416740702e465355c0,\\r\\n        0xeAceA6E112ed237BEe8ad10122858D4c5eaE40eB,\\r\\n        0x4d3b81147A1b24ea08419ec4C8C6D72aC812c57F,\\r\\n        0x35E4c0dfB8bF50E5C95B7Fc046D9a7cf914Dc04E,\\r\\n        0x409De8cB598DA65Ca1c565101EFf0Be298BA18fe,\\r\\n        0xD8109b3d41898A339f8e19dBc94B92823645f706,\\r\\n        0xFe368dC1DD0a9C1dc8373D33958297654c82d9c0,\\r\\n        0x93F708FE591a9b8E5231e4dFb9CCcf7bA4fF1030,\\r\\n        0x477c333827C0fF7B2cf5C004481fEDc048D4dd57,\\r\\n        0x114eC40e95e5627F95B5FeF0e8073BF70bf82E03,\\r\\n        0xa34Aea2d9d2d8f6187Dba747d471BfAD6868a10C,\\r\\n        0xeC804f16B75835ed5C9f099beE509F3FFA09f87d,\\r\\n        0xDD76DB87F6781B5D28F3Ca0593dDe3E86031D30c,\\r\\n        0xc6eb979bF9f7232E17a0909883D3E05A90165e1a,\\r\\n        0xE36ea67ebFEc6e17f4673b4965A8234bC8d15545,\\r\\n        0x571B98140A60eE83eCF7bB8B2E316872d8f9198D,\\r\\n        0x8869cEf9a8EbC9f72332b3ACfA48BF53766FAB32,\\r\\n        0xE1fD7eB82859eA3879210e2Eb790482cE044ecc2,\\r\\n        0x04d558667B1C69c625a8B3BF2aC64DEd868f9DeF,\\r\\n        0xb82fFF54c0535818087272E6D77E15bbeb8Bb9be,\\r\\n        0x959ABc919Df0d07ADdd5116D9C306549a0d798b3,\\r\\n        0xA09c4D01d556Fc955eCe05eC539c833703102995,\\r\\n        0x22fd59e1E86a3E2CBE3b4d8Dc97674c24f5CA7a1,\\r\\n        0x653b0df3FC4d1a7eE100A0dfbec14db4c64C8599,\\r\\n        0x8DDAB83b26C24e5BEBD171Bb4f35E8c21CE63364,\\r\\n        0x1788A5aEAe6dC1aB1B72c9E0155ACE47647675D3,\\r\\n        0x27a745707885cd1D2E24D36Ae84ad280A01ED497,\\r\\n        0x9285ef4f76854192FEA203072D8A961aEB386727,\\r\\n        0x48f6e5950D8F61F7dBf06918908d3AD6d15A885D,\\r\\n        0x71f8802C405739A39afD8Fc56f525F1C218373fD,\\r\\n        0x4394ACa1aB0986c60877c9546fb726d0F961792e,\\r\\n        0x470CB08E25f68955dC3A9197fFf0785bAb921721,\\r\\n        0x3AB6Ce71B0bc6a9Ce111b5d179506b7fFc93aD88,\\r\\n        0x99602d70A98C587023922c467E4793c6Ddc950C1 // until 30 Oct 2023\\r\\n    ];\\r\\n} \\r\\n    function BLOF() public view returns(address[] memory){ return BLOA; }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/mainbinaryland.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at BscScan.com on 2023-03-09\\r\\n*/\\r\\n\\r\\n/**\\r\\n *Submitted for verification at BscScan.com on 2022-09-01\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal pure virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance >= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n    function functionCall(address target, bytes memory data)\\r\\n        internal\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance >= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n    function _functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 weiValue,\\r\\n        string memory errorMessage\\r\\n    ) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\r\\n            data\\r\\n        );\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            if (returndata.length > 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) +\\r\\n            (value);\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                newAllowance\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) -\\r\\n            (value);\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                newAllowance\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        bytes memory returndata = address(token).functionCall(\\r\\n            data,\\r\\n            \\\"SafeERC20: low-level call failed\\\"\\r\\n        );\\r\\n        if (returndata.length > 0) {\\r\\n            require(\\r\\n                abi.decode(returndata, (bool)),\\r\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Binary_Land is Context {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    struct Node {\\r\\n        uint128 NumberOfChildNodeOnLeft;\\r\\n        uint128 NumberOfChildNodeOnRight;\\r\\n        uint256 NumberOfBalancedCalculated;\\r\\n        uint256 TotalUserRewarded;\\r\\n        uint256 NumberOfNewBalanced;\\r\\n        uint256 RewardAmountNotReleased;\\r\\n        address LeftNode;\\r\\n        address RightNode;\\r\\n        address UplineAddress;\\r\\n        int8 DirectionOfCurrentNodeInUplineNode; // left: -1, right: 1 \\r\\n        bool Status;\\r\\n    }\\r\\n    \\r\\n    mapping(address => Node) private _users;\\r\\n    mapping(address => bool) private _oldUsers;\\r\\n    address[] private _usersAddresses;\\r\\n\\r\\n    uint256 private lastRun;\\r\\n    address private owner;\\r\\n    IERC20 private tetherToken;\\r\\n    uint256 private registrationFee;\\r\\n    uint256 private numberOfRegisteredUsersIn_24Hours;\\r\\n    uint256 private totalBalance;\\r\\n    uint256 private allPayments;\\r\\n    uint256 private numberOfNewBalanceIn_24Hours;\\r\\n    uint256 private constMaxBalanceForCalculatedReward;\\r\\n    \\r\\n    event UserRegistered(address indexed upLine, address indexed newUser);\\r\\n\\r\\n\\r\\n    constructor(address headOfUpline, address _tetherToken) {\\r\\n        owner = _msgSender();\\r\\n        registrationFee = 70 ether;\\r\\n\\r\\n        tetherToken = IERC20(_tetherToken);\\r\\n        lastRun = block.timestamp;\\r\\n        numberOfRegisteredUsersIn_24Hours = 0;\\r\\n        numberOfNewBalanceIn_24Hours = 0;\\r\\n        constMaxBalanceForCalculatedReward = 8  \\r\\n        ;\\r\\n        \\r\\n        _users[headOfUpline] = Node({\\r\\n            NumberOfChildNodeOnLeft: 0,\\r\\n            NumberOfChildNodeOnRight: 0,\\r\\n            NumberOfBalancedCalculated : 0,\\r\\n            TotalUserRewarded: 0,\\r\\n            NumberOfNewBalanced: 0,\\r\\n            RewardAmountNotReleased: 0,\\r\\n            LeftNode: address(0),\\r\\n            RightNode: address(0),\\r\\n            UplineAddress: address(0),\\r\\n            DirectionOfCurrentNodeInUplineNode: 1,\\r\\n            Status: true\\r\\n        });\\r\\n\\r\\n        _usersAddresses.push(headOfUpline);\\r\\n    }\\r\\n\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_msgSender() == owner, \\\"Just Owner Can Run This Order!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function Calculating_Rewards_In_24_Hours() public {\\r\\n\\r\\n        require(\\r\\n            block.timestamp > lastRun + 1 days,\\r\\n            \\\"The Calculating_Node_Rewards_In_24_Hours Time Has Not Come\\\"\\r\\n        );\\r\\n\\r\\n\\r\\n        uint256 rewardPerBalanced = Today_Reward_Per_Balance();\\r\\n        uint256 userReward;\\r\\n\\r\\n        for (uint256 i=0; i < _usersAddresses.length; i = i+1) {\\r\\n\\r\\n            if (_users[_usersAddresses[i]].NumberOfNewBalanced > constMaxBalanceForCalculatedReward ) {\\r\\n                userReward = rewardPerBalanced * constMaxBalanceForCalculatedReward;\\r\\n\\r\\n            } else {\\r\\n                userReward = rewardPerBalanced * _users[_usersAddresses[i]].NumberOfNewBalanced; \\r\\n\\r\\n            }\\r\\n\\r\\n            _users[_usersAddresses[i]].NumberOfBalancedCalculated += _users[_usersAddresses[i]].NumberOfNewBalanced;\\r\\n            _users[_usersAddresses[i]].NumberOfNewBalanced = 0;\\r\\n\\r\\n            if (userReward > 0) {\\r\\n                _users[_usersAddresses[i]].RewardAmountNotReleased += userReward;\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n        lastRun = block.timestamp;\\r\\n        numberOfRegisteredUsersIn_24Hours = 0;\\r\\n        numberOfNewBalanceIn_24Hours = 0;\\r\\n\\r\\n    }\\r\\n\\r\\n    function B_Withdraw() public {\\r\\n\\r\\n        require(_users[_msgSender()].RewardAmountNotReleased > 0, \\\"You have not received any award yet\\\");\\r\\n        \\r\\n        uint256 reward;\\r\\n        reward = _users[_msgSender()].RewardAmountNotReleased;\\r\\n        _users[_msgSender()].TotalUserRewarded += reward;\\r\\n        _users[_msgSender()].RewardAmountNotReleased = 0;\\r\\n        tetherToken.safeTransfer(_msgSender(), reward);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function Emergency_72() onlyOwner public {\\r\\n        require(\\r\\n            block.timestamp > lastRun + 3 days,\\r\\n            \\\"The Emergency_72 Time Has Not Come\\\"\\r\\n        );\\r\\n        require(tetherToken.balanceOf(address(this)) > 0 , \\\"contract not have balance\\\");\\r\\n\\r\\n        tetherToken.safeTransfer(\\r\\n            owner,\\r\\n            tetherToken.balanceOf(address(this))\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function A_Register(address uplineAddress) public {\\r\\n        require(\\r\\n            _users[uplineAddress].LeftNode == address(0) || _users[uplineAddress].RightNode == address(0) ,\\r\\n            \\\"This address have two directs and could not accept new members!\\\"\\r\\n        );\\r\\n        require(\\r\\n            _msgSender() != uplineAddress,\\r\\n            \\\"You can not enter your own address!\\\"\\r\\n        );\\r\\n\\r\\n        require(_users[_msgSender()].Status == false, \\\"This address is already registered!\\\");\\r\\n        require(_users[uplineAddress].Status == true, \\\"This Upline address is Not Exist!\\\");\\r\\n\\r\\n        uint256 NumberOfCurrentBalanced;\\r\\n        uint256 NumberOfNewBalanced;\\r\\n\\r\\n        address temp_UplineAddress;\\r\\n        address temp_CurrentAddress;\\r\\n        int8 temp_DirectionOfCurrentNodeInUplineNode;\\r\\n        \\r\\n\\r\\n        if (_oldUsers[_msgSender()] == false) {\\r\\n            tetherToken.safeTransferFrom(\\r\\n                _msgSender(),\\r\\n                address(this),\\r\\n                registrationFee\\r\\n            );       \\r\\n        }\\r\\n\\r\\n        if (_users[uplineAddress].RightNode == address(0)) {\\r\\n\\r\\n            _users[uplineAddress].RightNode = _msgSender();\\r\\n            temp_DirectionOfCurrentNodeInUplineNode = 1;\\r\\n        \\r\\n        } else {\\r\\n        \\r\\n            _users[uplineAddress].LeftNode = _msgSender();\\r\\n            temp_DirectionOfCurrentNodeInUplineNode = -1;\\r\\n        \\r\\n        }\\r\\n        \\r\\n        _users[_msgSender()] = Node({\\r\\n            NumberOfChildNodeOnLeft: 0,\\r\\n            NumberOfChildNodeOnRight: 0,\\r\\n            NumberOfBalancedCalculated : 0,\\r\\n            TotalUserRewarded: 0,\\r\\n            NumberOfNewBalanced : 0,\\r\\n            RewardAmountNotReleased: 0,\\r\\n            LeftNode: address(0),\\r\\n            RightNode: address(0),\\r\\n            UplineAddress: uplineAddress,\\r\\n            DirectionOfCurrentNodeInUplineNode: temp_DirectionOfCurrentNodeInUplineNode,\\r\\n            Status: true\\r\\n        });\\r\\n\\r\\n        temp_UplineAddress = uplineAddress;\\r\\n        temp_CurrentAddress = _msgSender();\\r\\n\\r\\n        if (_oldUsers[temp_CurrentAddress] == false) {\\r\\n            while (true) {\\r\\n                \\r\\n                if (_users[temp_UplineAddress].Status == false) {\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                if (temp_DirectionOfCurrentNodeInUplineNode == 1) {\\r\\n                    _users[temp_UplineAddress].NumberOfChildNodeOnRight += 1;\\r\\n\\r\\n                } else {\\r\\n                    _users[temp_UplineAddress].NumberOfChildNodeOnLeft += 1;\\r\\n\\r\\n                }\\r\\n\\r\\n                NumberOfCurrentBalanced = _users[temp_UplineAddress].NumberOfChildNodeOnLeft;\\r\\n                \\r\\n                if ( _users[temp_UplineAddress].NumberOfChildNodeOnRight < NumberOfCurrentBalanced) {\\r\\n                    NumberOfCurrentBalanced = _users[temp_UplineAddress].NumberOfChildNodeOnRight;\\r\\n                }\\r\\n\\r\\n                NumberOfNewBalanced = NumberOfCurrentBalanced - (_users[temp_UplineAddress].NumberOfBalancedCalculated + _users[temp_UplineAddress].NumberOfNewBalanced); // combine the two lline for gas lower\\r\\n                \\r\\n                if (NumberOfNewBalanced > 0) {\\r\\n                    _users[temp_UplineAddress].NumberOfNewBalanced += NumberOfNewBalanced;\\r\\n\\r\\n                    if (_users[temp_UplineAddress].NumberOfNewBalanced <= constMaxBalanceForCalculatedReward) {\\r\\n                        totalBalance += NumberOfNewBalanced;\\r\\n                        numberOfNewBalanceIn_24Hours += NumberOfNewBalanced;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                temp_CurrentAddress = temp_UplineAddress;\\r\\n                temp_DirectionOfCurrentNodeInUplineNode = _users[temp_CurrentAddress].DirectionOfCurrentNodeInUplineNode;\\r\\n                temp_UplineAddress = _users[temp_UplineAddress].UplineAddress;\\r\\n            }\\r\\n\\r\\n            numberOfRegisteredUsersIn_24Hours += 1;\\r\\n        }\\r\\n\\r\\n        _usersAddresses.push(_msgSender());\\r\\n        emit UserRegistered(uplineAddress, _msgSender());\\r\\n    }\\r\\n\\r\\n    function Upload_Old_User(address oldUserAddress) public onlyOwner {\\r\\n        require(_users[oldUserAddress].Status == false , \\\"This address is already registered!\\\");\\r\\n        require(_oldUsers[oldUserAddress] == false, \\\"This address is already registered in old user list!\\\");\\r\\n\\r\\n        _oldUsers[oldUserAddress] = true;\\r\\n    }\\r\\n\\r\\n    function Today_Contract_Balance() public view returns (uint256) {\\r\\n        return (70 ether) * numberOfRegisteredUsersIn_24Hours;\\r\\n    }\\r\\n\\r\\n    function All_Time_User_Left_Right(address userAddress) public view returns(uint128 ,uint128) {\\r\\n        return (\\r\\n            _users[userAddress].NumberOfChildNodeOnLeft,\\r\\n            _users[userAddress].NumberOfChildNodeOnRight\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function Today_User_Balance(address userAddress) public view returns(uint256) {\\r\\n        return _users[userAddress].NumberOfNewBalanced;\\r\\n    }\\r\\n\\r\\n    function Today_Total_Balance() public view returns(uint256) {\\r\\n        return numberOfNewBalanceIn_24Hours;\\r\\n    }\\r\\n\\r\\n    function Today_Reward_Per_Balance() public view returns (uint256) {\\r\\n        uint256 todayReward;\\r\\n        if (numberOfNewBalanceIn_24Hours == 0) {\\r\\n            todayReward = 0;\\r\\n\\r\\n        } else {\\r\\n            todayReward = (70 ether) * numberOfRegisteredUsersIn_24Hours / numberOfNewBalanceIn_24Hours;\\r\\n        }\\r\\n\\r\\n        return todayReward; \\r\\n    }\\r\\n\\r\\n    function Reward_Amount_Not_Released(address userAddress) public view returns(uint256) {\\r\\n        return _users[userAddress].RewardAmountNotReleased;\\r\\n    }\\r\\n    \\r\\n    function Total_User_Reward(address userAddress) public view returns(uint256) {\\r\\n        return _users[userAddress].TotalUserRewarded;\\r\\n    }\\r\\n    \\r\\n    function User_Upline(address userAddress) public view returns(address) {\\r\\n        return _users[userAddress].UplineAddress;\\r\\n    }\\r\\n\\r\\n    function User_Directs_Address(address userAddress) public view returns (address, address){\\r\\n        return (\\r\\n            _users[userAddress].LeftNode,\\r\\n            _users[userAddress].RightNode\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function Registration_Fee() public view returns(uint256) {\\r\\n        return registrationFee;\\r\\n    }\\r\\n\\r\\n    function User_Information(address userAddress) public view returns(Node memory) {\\r\\n        return _users[userAddress];\\r\\n    }\\r\\n\\r\\n    function Total_Number_Of_Registrations() public view returns (uint256) {\\r\\n        return _usersAddresses.length - 1;\\r\\n    }\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upLine\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uplineAddress\",\"type\":\"address\"}],\"name\":\"A_Register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"A_Today_Number_Of_Registrations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"LN\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"RN\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"CB\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"FC\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"TR\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"NB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"RA\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"N\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"R\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"U\",\"type\":\"address\"},{\"internalType\":\"int8\",\"name\":\"UD\",\"type\":\"int8\"},{\"internalType\":\"bool\",\"name\":\"ST\",\"type\":\"bool\"}],\"internalType\":\"struct BLP.NodeA\",\"name\":\"User\",\"type\":\"tuple\"}],\"name\":\"Add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"B_Total_Number_Of_Registrations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"B_Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"C_Calculating_Rewards_In_24_Hours\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"C_Today_Contract_Balance_Count\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Coin\",\"type\":\"address\"}],\"name\":\"ChangeStableCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"D_Today_Reward_Per_Balance\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"E_Total_Payment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Emergency_72\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"F_Registration_Fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"UserAddress\",\"type\":\"address\"}],\"name\":\"G_Check_User\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"H_Today_User_Balance_Count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"I_User_Reward_Not_Released\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Import_Users\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"J_Total_User_Reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"K_User_Left_Right_Count\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"L_User_Information\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"LN\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"RN\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"CB\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"FC\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"TR\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"NB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"RA\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"L\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"R\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"U\",\"type\":\"address\"},{\"internalType\":\"int8\",\"name\":\"UD\",\"type\":\"int8\"},{\"internalType\":\"bool\",\"name\":\"ST\",\"type\":\"bool\"}],\"internalType\":\"struct BLP.Node\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"Upload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BLP", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}