{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.12;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function factory() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the pawswap factory contract.\r\n */\r\ninterface PawSwapFactory {\r\n    function feeTo() external view returns (address);\r\n}\r\n\r\n/**\r\n * @dev Interface of the tax structure contract.\r\n */\r\ninterface ITaxStructure {\r\n    function routerAddress() external view returns (address);\r\n\r\n    // these taxes will be taken as eth\r\n    function tax1Name() external view returns (string memory);\r\n    function tax1Wallet() external view returns (address);\r\n    function tax1BuyAmount(address) external view returns (uint256);\r\n    function tax1SellAmount(address) external view returns (uint256);\r\n    \r\n    function tax2Name() external view returns (string memory);\r\n    function tax2Wallet() external view returns (address);\r\n    function tax2BuyAmount(address) external view returns (uint256);\r\n    function tax2SellAmount(address) external view returns (uint256);\r\n    \r\n    function tax3Name() external view returns (string memory);\r\n    function tax3Wallet() external view returns (address);\r\n    function tax3BuyAmount(address) external view returns (uint256);\r\n    function tax3SellAmount(address) external view returns (uint256);\r\n\r\n    function tax4Name() external view returns (string memory);\r\n    function tax4Wallet() external view returns (address);\r\n    function tax4BuyAmount(address) external view returns (uint256);\r\n    function tax4SellAmount(address) external view returns (uint256);\r\n\r\n    // this tax will be taken as tokens\r\n    function tokenTaxName() external view returns (string memory);\r\n    function tokenTaxWallet() external view returns (address);\r\n    function tokenTaxBuyAmount(address) external view returns (uint256);\r\n    function tokenTaxSellAmount(address) external view returns (uint256);\r\n\r\n    // this tax will send tokens to burn address\r\n    function burnTaxBuyAmount(address) external view returns (uint256);\r\n    function burnTaxSellAmount(address) external view returns (uint256);\r\n    function burnAddress() external view returns (address);\r\n\r\n    // this tax will be sent to the LP\r\n    function liquidityTaxBuyAmount(address) external view returns (uint256);\r\n    function liquidityTaxSellAmount(address) external view returns (uint256);\r\n    function lpTokenHolder() external view returns (address);\r\n\r\n    // this custom tax will send ETH to a dynamic address\r\n    function customTaxName() external view returns (string memory);\r\n\r\n    function feeDecimal() external view returns (uint256);\r\n}\r\n\r\ninterface OwnableContract {\r\n    function owner() external view returns (address);\r\n}\r\n\r\ncontract PawSwap is Ownable, ReentrancyGuard {\r\n    struct TaxStruct {\r\n        IERC20 token;\r\n        uint256 tax1;\r\n        uint256 tax2;\r\n        uint256 tax3;\r\n        uint256 tax4;\r\n        uint256 tokenTax;\r\n        uint256 burnTax;\r\n        uint256 liquidityTax;\r\n        uint256 customTax;\r\n        uint256 feeDecimal;\r\n        address router;\r\n        address lpTokenHolder;\r\n    }\r\n\r\n    mapping(address => bool) public excludedTokens; // tokens that are not allowed to list\r\n    mapping(address => bool) public listers; // addresses that can list new tokens\r\n    mapping(address => address) public tokenTaxContracts;\r\n    mapping(address => bool) public dexExcludedFromTreasury;\r\n\r\n    PawSwapFactory public pawSwapFactory;\r\n\r\n    address public pawSwapRouter;\r\n    address public immutable WETH;\r\n    // sets treasury fee to 0.03%\r\n    uint256 public treasuryFee = 3;\r\n\r\n    event Buy(\r\n        address indexed buyer,\r\n        address indexed tokenAddress,\r\n        uint256 ethSpent,\r\n        uint256 tokensReceived,\r\n        uint256 customTaxAmount,\r\n        address indexed customTaxAddress\r\n    );\r\n\r\n    event Sell(\r\n        address indexed seller,\r\n        address indexed tokenAddress,\r\n        uint256 tokensSold,\r\n        uint256 ethReceived,\r\n        uint256 customTaxAmount,\r\n        address indexed customTaxAddress\r\n    );\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'Pawswap: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor (address factory, address router, address weth) {\r\n        WETH = weth;\r\n        PawSwapFactory _factory = PawSwapFactory(factory);\r\n        pawSwapFactory = _factory;\r\n        pawSwapRouter = router;\r\n        dexExcludedFromTreasury[router] = true;\r\n    }\r\n\r\n    function processPreSwapBuyTaxes (\r\n        uint256 ethAmount,\r\n        address customTaxAddress,\r\n        TaxStruct memory taxStructure,\r\n        ITaxStructure taxStructureContract\r\n    ) private returns (uint256, uint256, uint256) {\r\n        uint256 ethToSwap = ethAmount;\r\n        uint256 liquidityEth;\r\n        uint256 customTaxSent;\r\n\r\n        if (!dexExcludedFromTreasury[taxStructure.router]) {\r\n            // take a treasury fee if we are not using the pawswap dex\r\n            uint256 treasuryEth = ethAmount * treasuryFee / 10**4; // always 4\r\n            ethToSwap -= treasuryEth;\r\n            (bool sent, ) = pawSwapFactory.feeTo().call{value: treasuryEth}(\"\");\r\n            require(sent, \"Failed to send eth to treasury\");\r\n        }\r\n\r\n        if (taxStructure.liquidityTax != 0) {\r\n            // hold onto some eth to pair with tokens for liquidity\r\n            liquidityEth = ethAmount * (taxStructure.liquidityTax / 2) / 10**(taxStructure.feeDecimal + 2);\r\n            ethToSwap -= liquidityEth;\r\n        }\r\n\r\n        if (taxStructure.tax1 != 0) {\r\n            // send eth percentage to the tax1 wallet\r\n            uint256 tax1Eth = ethAmount * taxStructure.tax1 / 10**(taxStructure.feeDecimal + 2);\r\n            ethToSwap -= tax1Eth;\r\n            (bool sent, ) = taxStructureContract.tax1Wallet().call{value: tax1Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax1 wallet\");\r\n        }\r\n\r\n        if (taxStructure.tax2 != 0) {\r\n            // send eth percentage to the tax2 wallet\r\n            uint256 tax2Eth = ethAmount * taxStructure.tax2 / 10**(taxStructure.feeDecimal + 2);\r\n            ethToSwap -= tax2Eth;\r\n            (bool sent, ) = taxStructureContract.tax2Wallet().call{value: tax2Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax2 wallet\");\r\n        }\r\n        \r\n        if (taxStructure.tax3 != 0) {\r\n            // send eth percentage to the tax3 wallet\r\n            uint256 tax3Eth = ethAmount * taxStructure.tax3 / 10**(taxStructure.feeDecimal + 2);\r\n            ethToSwap -= tax3Eth;\r\n            (bool sent, ) = taxStructureContract.tax3Wallet().call{value: tax3Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax3 wallet\");\r\n        }\r\n\r\n        if (taxStructure.tax4 != 0) {\r\n            // send eth percentage to the tax4 wallet\r\n            uint256 tax4Eth = ethAmount * taxStructure.tax4 / 10**(taxStructure.feeDecimal + 2);\r\n            ethToSwap -= tax4Eth;\r\n            (bool sent, ) = taxStructureContract.tax4Wallet().call{value: tax4Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax4 wallet\");\r\n        }\r\n        \r\n        if (taxStructure.customTax != 0) {\r\n            // send to the custom tax address\r\n            customTaxSent = ethAmount * taxStructure.customTax / 10**(taxStructure.feeDecimal + 2);\r\n            ethToSwap -= customTaxSent;\r\n            (bool sent, ) = customTaxAddress.call{value: customTaxSent}(\"\");\r\n            require(sent, \"Failed to send eth to custom tax wallet\");\r\n        }\r\n\r\n        return (ethToSwap, liquidityEth, customTaxSent);\r\n    }\r\n\r\n    function processPostSwapBuyTaxes(\r\n      IERC20 token,\r\n      uint256 tokensFromSwap,\r\n      uint256 liquidityEth,\r\n      TaxStruct memory taxStruct,\r\n      ITaxStructure taxStructureContract\r\n    ) private returns (uint256) {\r\n        uint256 purchasedTokens = tokensFromSwap;\r\n        uint256 taxDenominator = 10**(taxStruct.feeDecimal + 2) + 1; // +1 makes up for precision errors\r\n\r\n        if (taxStruct.liquidityTax != 0) {\r\n            // add to the LP\r\n            uint256 liquidityTokens = tokensFromSwap * (taxStruct.liquidityTax / 2) / taxDenominator;\r\n            purchasedTokens -= liquidityTokens;\r\n            addLiquidity(liquidityTokens, liquidityEth, taxStruct.lpTokenHolder, token, taxStruct.router);\r\n        }\r\n\r\n        // burn fee is taken in pawth\r\n        if (taxStruct.burnTax != 0) {\r\n            // send to the pawth burn addr\r\n            uint256 burnTokens = tokensFromSwap * taxStruct.burnTax / taxDenominator;\r\n            purchasedTokens -= burnTokens;\r\n            token.transfer(taxStructureContract.burnAddress(), burnTokens);\r\n        }\r\n\r\n        // staking fee is taken in token\r\n        if (taxStruct.tokenTax != 0) {\r\n            // send to the token tax wallet\r\n            uint256 taxTokens = tokensFromSwap * taxStruct.tokenTax / taxDenominator;\r\n            purchasedTokens -= taxTokens;\r\n            token.transfer(taxStructureContract.tokenTaxWallet(), taxTokens);\r\n        }\r\n\r\n        return purchasedTokens;\r\n    }\r\n\r\n    function executeBuy (\r\n        address tokenAddress,\r\n        uint customTaxAmount, \r\n        address customTaxAddress, \r\n        uint256 minTokensToReceive,\r\n        bool isExactIn\r\n    ) private returns (uint256, uint256, uint256) {\r\n        ITaxStructure _taxStructureContract = ITaxStructure(tokenTaxContracts[tokenAddress]);\r\n        TaxStruct memory _taxStruct = getTaxStruct(_taxStructureContract, customTaxAmount, _msgSender(), tokenAddress, true);\r\n\r\n        // uses getBuyAmountIn if this is an exact out trade because\r\n        // we should take taxes out based on what the actual buy amount is since\r\n        // the user might give us more eth than necessary -- we only want to tax the\r\n        // amount used to purchased, not the excess eth sent in msg.value\r\n        (uint256 ethToSwap, uint256 liquidityEth, uint256 customTaxSent) = processPreSwapBuyTaxes(\r\n          isExactIn ? msg.value : getBuyAmountIn(_msgSender(), tokenAddress, customTaxAmount, minTokensToReceive),\r\n          customTaxAddress,\r\n          _taxStruct,\r\n          _taxStructureContract\r\n        );\r\n\r\n        (uint256 tokensFromSwap, uint256 dustEth) = swapEthForTokens(\r\n          ethToSwap,\r\n          isExactIn ? 0 : addTokenTax(minTokensToReceive, _taxStruct), // this wont get used if IsExactIn is true\r\n          _taxStruct,\r\n          isExactIn\r\n        );\r\n\r\n        uint256 purchasedTokens = processPostSwapBuyTaxes(\r\n          _taxStruct.token,\r\n          tokensFromSwap,\r\n          liquidityEth,\r\n          _taxStruct,\r\n          _taxStructureContract\r\n        );\r\n\r\n        // require that we met the minimum set by the user\r\n        require (purchasedTokens >= minTokensToReceive, \"Insufficient tokens purchased\");\r\n        // send the tokens to the buyer\r\n        if (isExactIn) {\r\n            _taxStruct.token.transfer(_msgSender(), purchasedTokens);\r\n            return (purchasedTokens, dustEth, customTaxSent);\r\n        } else {\r\n            _taxStruct.token.transfer(_msgSender(), minTokensToReceive);\r\n            return (minTokensToReceive, dustEth, customTaxSent);\r\n        }\r\n    }\r\n\r\n    function buyOnPawSwap (\r\n        address tokenAddress,\r\n        uint customTaxAmount, \r\n        address customTaxAddress, \r\n        uint256 minTokensToReceive,\r\n        bool isExactIn\r\n    ) external payable nonReentrant {\r\n        require(tokenTaxContracts[tokenAddress] != address(0), \"Token not listed\");\r\n        \r\n        (uint256 purchasedTokens, uint256 dustEth, uint256 customTaxSent) = executeBuy(\r\n            tokenAddress,\r\n            customTaxAmount, \r\n            customTaxAddress, \r\n            minTokensToReceive,\r\n            isExactIn\r\n        );\r\n\r\n        emit Buy(\r\n            _msgSender(),\r\n            tokenAddress,\r\n            isExactIn ? msg.value : msg.value - dustEth, \r\n            purchasedTokens,\r\n            customTaxSent,\r\n            customTaxAddress\r\n        );\r\n    }\r\n\r\n    function addTokenTax (uint256 amount, TaxStruct memory taxStruct) private pure returns (uint256) {\r\n        uint256 percentageTakenPostSwap = (taxStruct.liquidityTax / 2) + taxStruct.burnTax + taxStruct.tokenTax;\r\n        uint256 otherPercentage = 10**(taxStruct.feeDecimal + 2) - percentageTakenPostSwap;\r\n        uint256 minAmount = amount / otherPercentage * (10**(taxStruct.feeDecimal + 2) + 1);\r\n\r\n        return minAmount;\r\n    }\r\n\r\n    function addEthTax (uint256 amount, TaxStruct memory taxStruct) private view returns (uint256) {\r\n        uint256 percentageTakenPostSwap = (taxStruct.liquidityTax / 2) + taxStruct.tax1 + taxStruct.tax2 + taxStruct.tax3 + taxStruct.tax4 + taxStruct.customTax;\r\n        uint256 otherPercentage = 10**(taxStruct.feeDecimal + 2) - percentageTakenPostSwap;\r\n\r\n        if (!dexExcludedFromTreasury[taxStruct.router]) {\r\n            uint256 treasuryTax = amount * treasuryFee / 10**4;\r\n            amount += treasuryTax;\r\n        }\r\n\r\n        return amount / otherPercentage * (10**(taxStruct.feeDecimal + 2) + 1);\r\n    }\r\n\r\n    function processPreSwapSellTaxes(\r\n        uint256 tokensToSwap,\r\n        TaxStruct memory taxStruct,\r\n        ITaxStructure taxStructureContract\r\n    ) private returns (uint256, uint256) {\r\n        uint256 liquidityTokens;\r\n        uint256 taxDenominator = 10**(taxStruct.feeDecimal + 2) + 1; // +1 makes up for precision errors\r\n\r\n        if (taxStruct.liquidityTax != 0) {\r\n            // hold onto some tokens to pair with eth for liquidity\r\n            liquidityTokens = tokensToSwap * (taxStruct.liquidityTax / 2) / taxDenominator;\r\n            tokensToSwap -= liquidityTokens;\r\n        }\r\n    \r\n        // burn fee is taken in pawth\r\n        if (taxStruct.burnTax != 0) {\r\n            // send to the pawth burn addr\r\n            uint256 burnTokens = tokensToSwap * taxStruct.burnTax / taxDenominator;\r\n            taxStruct.token.transfer(taxStructureContract.burnAddress(), burnTokens);\r\n            tokensToSwap -= burnTokens;\r\n        }\r\n\r\n        // staking fee is taken in tokens\r\n        if (taxStruct.tokenTax != 0) {\r\n            // send to the token tax wallet\r\n            uint256 taxTokens = tokensToSwap * taxStruct.tokenTax / taxDenominator;\r\n            taxStruct.token.transfer(taxStructureContract.tokenTaxWallet(), taxTokens);\r\n            tokensToSwap -= taxTokens;\r\n        }\r\n\r\n        return (tokensToSwap, liquidityTokens);\r\n    }\r\n\r\n    function processPostSwapSellTaxes(\r\n      uint256 ethFromSwap,\r\n      address customTaxAddress,\r\n      uint256 liquidityTokens,\r\n      TaxStruct memory taxStruct,\r\n      ITaxStructure taxStructureContract\r\n    ) private returns (uint256, uint256) {\r\n        uint256 ethToTransfer = ethFromSwap;\r\n        uint256 customTaxSent;\r\n\r\n        if (taxStruct.tax1 != 0) {\r\n            // send eth percentage to the tax1 wallet\r\n            uint256 tax1Eth = ethFromSwap * taxStruct.tax1 / 10**(taxStruct.feeDecimal + 2);\r\n            ethToTransfer -= tax1Eth;\r\n            (bool sent, ) = taxStructureContract.tax1Wallet().call{value: tax1Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax1 wallet\");\r\n        }\r\n\r\n        if (taxStruct.tax2 != 0) {\r\n            // send eth percentage to the tax2 wallet\r\n            uint256 tax2Eth = ethFromSwap * taxStruct.tax2 / 10**(taxStruct.feeDecimal + 2);\r\n            ethToTransfer -= tax2Eth;\r\n            (bool sent, ) = taxStructureContract.tax2Wallet().call{value: tax2Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax2 wallet\");\r\n        }\r\n\r\n        if (taxStruct.tax3 != 0) {\r\n            // send eth percentage to the tax3 wallet\r\n            uint256 tax3Eth = ethFromSwap * taxStruct.tax3 / 10**(taxStruct.feeDecimal + 2);\r\n            ethToTransfer -= tax3Eth;\r\n            (bool sent, ) = taxStructureContract.tax3Wallet().call{value: tax3Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax3 wallet\");\r\n        }\r\n    \r\n        if (taxStruct.tax4 != 0) {\r\n            // send eth percentage to the tax4 wallet\r\n            uint256 tax4Eth = ethFromSwap * taxStruct.tax4 / 10**(taxStruct.feeDecimal + 2);\r\n            ethToTransfer -= tax4Eth;\r\n            (bool sent, ) = taxStructureContract.tax4Wallet().call{value: tax4Eth}(\"\");\r\n            require(sent, \"Failed to send eth to tax4 wallet\");\r\n        }\r\n\r\n        if (taxStruct.customTax != 0) {\r\n            // send eth percentage to the tax4 wallet\r\n            customTaxSent = ethFromSwap * taxStruct.customTax / 10**(taxStruct.feeDecimal + 2);\r\n            ethToTransfer -= customTaxSent;\r\n            (bool sent, ) = customTaxAddress.call{value: customTaxSent}(\"\");\r\n            require(sent, \"Failed to send eth to tax4 wallet\");\r\n        }\r\n\r\n        if (!dexExcludedFromTreasury[taxStruct.router]) {\r\n            // take a treasury fee if we are not using the pawswap dex\r\n            uint256 treasuryEth = ethFromSwap * treasuryFee / 10**4; // always 4\r\n            ethToTransfer -= treasuryEth;\r\n            (bool sent, ) = pawSwapFactory.feeTo().call{value: treasuryEth}(\"\");\r\n            require(sent, \"Failed to send eth to treasury\");\r\n        }\r\n\r\n        if (taxStruct.liquidityTax != 0) {\r\n            // add to the LP\r\n            uint256 liquidityEth = ethFromSwap * (taxStruct.liquidityTax / 2) / 10**(taxStruct.feeDecimal + 2);\r\n            ethToTransfer -= liquidityEth;\r\n            addLiquidity(liquidityTokens, liquidityEth, taxStruct.lpTokenHolder, taxStruct.token, taxStruct.router);\r\n        }\r\n\r\n        return (ethToTransfer, customTaxSent);\r\n    }\r\n\r\n    function executeSell (\r\n        address tokenAddress,\r\n        uint256 tokensSold, \r\n        uint customTaxAmount, \r\n        address customTaxAddress, \r\n        uint minEthToReceive,\r\n        bool isExactIn\r\n    ) private returns (uint256, uint256, uint256) {\r\n        ITaxStructure _taxStructureContract = ITaxStructure(tokenTaxContracts[tokenAddress]);\r\n        TaxStruct memory _taxStruct = getTaxStruct(_taxStructureContract, customTaxAmount, _msgSender(), tokenAddress, false);\r\n\r\n        _taxStruct.token.transferFrom(_msgSender(), address(this), tokensSold);\r\n        (uint256 tokensToSwap, uint256 liquidityTokens) = processPreSwapSellTaxes(\r\n          isExactIn ? tokensSold : getSellAmountIn(_msgSender(), tokenAddress, customTaxAmount, minEthToReceive),\r\n          _taxStruct,\r\n          _taxStructureContract\r\n        );\r\n\r\n        (uint256 ethFromSwap, uint256 dustTokens) = swapTokensForEth(\r\n          tokensToSwap, \r\n          addEthTax(minEthToReceive, _taxStruct), // this wont get used if IsExactIn is true\r\n          _taxStruct,\r\n          isExactIn\r\n        );\r\n\r\n        (uint256 ethToTransfer, uint256 customTaxSent) = processPostSwapSellTaxes(\r\n          ethFromSwap, \r\n          customTaxAddress,\r\n          liquidityTokens,\r\n          _taxStruct,\r\n          _taxStructureContract\r\n        );\r\n\r\n        // require that we met the minimum set by the user\r\n        require(ethToTransfer >= minEthToReceive, \"Insufficient ETH out\");\r\n        // send the eth to seller\r\n        uint256 ethTransferred = sendEthToUser(ethToTransfer, minEthToReceive, isExactIn);\r\n        return (ethTransferred, tokensToSwap - dustTokens, customTaxSent);\r\n    }\r\n\r\n    function sellOnPawSwap (\r\n        address tokenAddress,\r\n        uint256 tokensSold, \r\n        uint customTaxAmount, \r\n        address customTaxAddress, \r\n        uint minEthToReceive,\r\n        bool isExactIn\r\n    ) external {\r\n        address listedTaxStructContract = tokenTaxContracts[tokenAddress];\r\n        require(listedTaxStructContract != address(0), \"Token not listed\");\r\n\r\n        (uint256 ethToTransfer, uint256 tokensSwapped, uint256 customTaxSent) = executeSell(\r\n            tokenAddress,\r\n            tokensSold, \r\n            customTaxAmount, \r\n            customTaxAddress, \r\n            minEthToReceive,\r\n            isExactIn\r\n        );\r\n\r\n        emit Sell(\r\n            _msgSender(),\r\n            tokenAddress,\r\n            isExactIn ? tokensSold : tokensSwapped,\r\n            ethToTransfer,\r\n            customTaxSent,\r\n            customTaxAddress\r\n        );\r\n    }\r\n\r\n    function sendEthToUser (uint256 amount, uint256 minEthToReceive, bool isExactIn) private returns (uint256) {\r\n        if (isExactIn) {\r\n            (bool sent, ) = _msgSender().call{value: amount}(\"\");\r\n            require(sent, \"Failed to send eth to user\");\r\n            return amount;\r\n        } else {\r\n            (bool sent, ) = _msgSender().call{value: minEthToReceive}(\"\");\r\n            require(sent, \"Failed to send eth to user\");\r\n            return minEthToReceive;\r\n        }\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount, address lpTokenHolder, IERC20 token, address routerAddress) private {\r\n        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(routerAddress);\r\n        token.approve(address(uniswapV2Router), tokenAmount);\r\n\r\n        (uint amountToken, uint amountETH) = _addLiquidity(\r\n            address(token),\r\n            WETH,\r\n            tokenAmount,\r\n            ethAmount,\r\n            uniswapV2Router\r\n        );\r\n        address pair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(token), WETH);\r\n        token.transfer(pair, amountToken);\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        assert(IWETH(WETH).transfer(pair, amountETH));\r\n        IUniswapV2Pair(pair).mint(lpTokenHolder);\r\n        // refund dust eth, if any\r\n        if (ethAmount > amountETH) {\r\n            (bool sent, ) = _msgSender().call{value: ethAmount - amountETH}(\"\");\r\n            require(sent, \"Failed to refund user dust eth after adding liquidity\");\r\n        }\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    ) private returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        address pair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(tokenA, tokenB);\r\n        if (pair == address(0)) {\r\n            IUniswapV2Factory(uniswapV2Router.factory()).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB,) = IUniswapV2Pair(pair).getReserves();\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = uniswapV2Router.quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= 0, 'Pawswap: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = uniswapV2Router.quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= 0, 'Pawswap: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function swapEthForTokens(\r\n      uint256 ethToSwap,\r\n      uint256 minAmountOut,\r\n      TaxStruct memory taxStruct,\r\n      bool isExactIn\r\n    ) private returns (uint256, uint256) {\r\n        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(taxStruct.router);\r\n        address [] memory path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = address(taxStruct.token);\r\n\r\n        uint256 initialTokenBalance = taxStruct.token.balanceOf(address(this));\r\n        uint256 dustEth;\r\n\r\n        if (isExactIn) {\r\n          // if user specified amount of eth to spend, get as many tokens as possible\r\n          swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n              ethToSwap,\r\n              0,\r\n              path,\r\n              uniswapV2Router\r\n          );\r\n        } else {\r\n          (, dustEth) = swapETHForExactTokens(\r\n              ethToSwap,\r\n              minAmountOut,\r\n              path,\r\n              uniswapV2Router\r\n          );\r\n        }\r\n\r\n        return (taxStruct.token.balanceOf(address(this)) - initialTokenBalance, dustEth);\r\n    }\r\n\r\n    function swapTokensForEth(\r\n      uint256 tokenAmount,\r\n      uint256 minEthToReceive,\r\n      TaxStruct memory taxStruct,\r\n      bool isExactIn\r\n    ) private returns (uint256, uint256) {\r\n        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(taxStruct.router);\r\n        address [] memory path = new address[](2);\r\n        path[0] = address(taxStruct.token);\r\n        path[1] = uniswapV2Router.WETH();\r\n        \r\n        taxStruct.token.approve(address(uniswapV2Router), tokenAmount);\r\n\r\n        uint256 initialEthBalance = address(this).balance;\r\n        if (isExactIn) {\r\n          swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            uniswapV2Router\r\n          );\r\n        } else {                        \r\n          swapTokensForExactETH(\r\n            minEthToReceive,\r\n            tokenAmount,\r\n            path,\r\n            address(this),\r\n            uniswapV2Router\r\n          );\r\n        }\r\n\r\n        return (address(this).balance - initialEthBalance, 0);\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] memory path,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    ) internal {\r\n        require(path[path.length - 1] == WETH, 'Pawswap: INVALID_PATH');\r\n        address pair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(path[0],path[1]);\r\n        IERC20(path[0]).transfer(pair, amountIn);\r\n        _swapSupportingFeeOnTransferTokens(path, uniswapV2Router);\r\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'Pawswap: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).withdraw(amountOut);\r\n    }\r\n\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountIn, \r\n        uint amountOut, \r\n        address[] memory path,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    )\r\n        private\r\n        returns (uint[] memory amounts, uint dustEth)\r\n    {\r\n        require(path[0] == WETH, 'Pawswap: INVALID_PATH');\r\n        amounts = uniswapV2Router.getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= amountIn, 'Pawswap: EXCESSIVE_INPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        address pair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(path[0],path[1]);\r\n        assert(IWETH(WETH).transfer(pair, amounts[0]));\r\n        _swap(amounts, path, pair);\r\n        // refund dust eth, if any\r\n        if (amountIn > amounts[0]) {\r\n            dustEth = amountIn - amounts[0];\r\n            (bool sent, ) = _msgSender().call{value: dustEth}(\"\");\r\n            require(sent, \"Failed to refund user dust eth\");\r\n        }\r\n    }\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] memory path,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    ) private {\r\n        require(path[0] == WETH, 'Pawswap: INVALID_PATH');\r\n        IWETH(WETH).deposit{value: amountIn}();\r\n        address pair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(path[0],path[1]);\r\n        assert(IWETH(WETH).transfer(pair, amountIn));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(address(this));\r\n        _swapSupportingFeeOnTransferTokens(path, uniswapV2Router);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(address(this)) - balanceBefore >= amountOutMin,\r\n            'Pawswap: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] memory path, address to, IUniswapV2Router02 uniswapV2Router)\r\n        private\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'Pawswap: INVALID_PATH');\r\n        amounts = uniswapV2Router.getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'Pawswap: EXCESSIVE_INPUT_AMOUNT');\r\n        address pair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(path[0],path[1]);\r\n        IERC20(path[0]).transfer(pair, amounts[0]);\r\n        _swap(amounts, path, pair);\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        (bool sent, ) = to.call{value: amounts[amounts.length - 1]}(\"\");\r\n        require(sent, \"Failed to send eth to seller\");\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _pair) private {\r\n        (address input, address output) = (path[0], path[1]);\r\n        (address token0,) = sortTokens(input, output);\r\n        uint amountOut = amounts[1];\r\n        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n        IUniswapV2Pair(_pair).swap(\r\n            amount0Out, amount1Out, address(this), new bytes(0)\r\n        );\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, IUniswapV2Router02 uniswapV2Router) private {\r\n        (address input, address output) = (path[0], path[1]);\r\n        (address token0,) = sortTokens(input, output);\r\n        IUniswapV2Pair pair = IUniswapV2Pair(IUniswapV2Factory(uniswapV2Router.factory()).getPair(input, output));\r\n        uint amountInput;\r\n        uint amountOutput;\r\n        { // scope to avoid stack too deep errors\r\n        (uint reserve0, uint reserve1,) = pair.getReserves();\r\n        (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\r\n        amountOutput = uniswapV2Router.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n        }\r\n        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n        pair.swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'Pawswap: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'Pawswap: ZERO_ADDRESS');\r\n    }\r\n\r\n    function getTaxStruct(\r\n        ITaxStructure _taxStructureContract,\r\n        uint256 customTaxAmount,\r\n        address _account, \r\n        address _token, \r\n        bool isBuy\r\n    ) internal view returns (TaxStruct memory) {\r\n        if (isBuy) {\r\n            return TaxStruct(\r\n                IERC20(_token),\r\n                _taxStructureContract.tax1BuyAmount(_account),\r\n                _taxStructureContract.tax2BuyAmount(_account),\r\n                _taxStructureContract.tax3BuyAmount(_account),\r\n                _taxStructureContract.tax4BuyAmount(_account),\r\n                _taxStructureContract.tokenTaxBuyAmount(_account),\r\n                _taxStructureContract.burnTaxBuyAmount(_account),\r\n                _taxStructureContract.liquidityTaxBuyAmount(_account),\r\n                customTaxAmount,\r\n                _taxStructureContract.feeDecimal(),\r\n                _taxStructureContract.routerAddress(),\r\n                _taxStructureContract.lpTokenHolder()\r\n            );\r\n        } else {\r\n            return TaxStruct(\r\n                IERC20(_token),\r\n                _taxStructureContract.tax1SellAmount(_account),\r\n                _taxStructureContract.tax2SellAmount(_account),\r\n                _taxStructureContract.tax3SellAmount(_account),\r\n                _taxStructureContract.tax4SellAmount(_account),\r\n                _taxStructureContract.tokenTaxSellAmount(_account),\r\n                _taxStructureContract.burnTaxSellAmount(_account),\r\n                _taxStructureContract.liquidityTaxSellAmount(_account),\r\n                customTaxAmount,\r\n                _taxStructureContract.feeDecimal(),\r\n                _taxStructureContract.routerAddress(),\r\n                _taxStructureContract.lpTokenHolder()\r\n            );\r\n        }\r\n    }\r\n\r\n    function getBuyAmountIn (\r\n        address buyer,\r\n        address tokenAddress,\r\n        uint customTaxAmount,\r\n        uint minTokensToReceive\r\n    ) public view returns (uint256 amountIn) {\r\n        require(tokenTaxContracts[tokenAddress] != address(0), \"Token not listed\");\r\n        ITaxStructure _taxStructureContract = ITaxStructure(tokenTaxContracts[tokenAddress]);\r\n        TaxStruct memory _taxStruct = getTaxStruct(_taxStructureContract, customTaxAmount, buyer, tokenAddress, true);\r\n\r\n        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(_taxStruct.router);\r\n        address [] memory path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = tokenAddress;\r\n\r\n        uint256 [] memory amountsIn = uniswapV2Router.getAmountsIn(\r\n            addTokenTax(minTokensToReceive, _taxStruct),\r\n            path\r\n        );\r\n\r\n        return addEthTax(amountsIn[0], _taxStruct);\r\n    }\r\n\r\n    function getSellAmountIn (\r\n        address seller,\r\n        address tokenAddress,\r\n        uint customTaxAmount,\r\n        uint minEthToReceive\r\n    ) public view returns (uint256) {\r\n        require(tokenTaxContracts[tokenAddress] != address(0), \"Token not listed\");\r\n        ITaxStructure _taxStructureContract = ITaxStructure(tokenTaxContracts[tokenAddress]);\r\n        TaxStruct memory _taxStruct = getTaxStruct(_taxStructureContract, customTaxAmount, seller, tokenAddress, false);\r\n\r\n        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(_taxStruct.router);\r\n        address [] memory path = new address[](2);\r\n        path[0] = tokenAddress;\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        uint256 [] memory amountsIn = uniswapV2Router.getAmountsIn(\r\n            addEthTax(minEthToReceive, _taxStruct),\r\n            path\r\n        );\r\n        return addTokenTax(amountsIn[0], _taxStruct);\r\n    }\r\n\r\n    function setTokenTaxContract (address _tokenAddress, address _taxStructureContractAddress) external {\r\n        require (!excludedTokens[_tokenAddress], \"Token is not allowed to list\");\r\n        require (tokenTaxContracts[_tokenAddress] != _taxStructureContractAddress, \"Structure already set to this address\");\r\n        // caller must be the pawswap owner, have the listing role, or be the owner of the listed contract\r\n        require (\r\n            listers[_msgSender()] ||\r\n            OwnableContract(_tokenAddress).owner() == _msgSender() ||\r\n            this.owner() == _msgSender(),\r\n            \"Permission denied\"\r\n        );\r\n        tokenTaxContracts[_tokenAddress] = _taxStructureContractAddress;\r\n    }\r\n\r\n    function setListerAccount (address _address, bool isLister) external onlyOwner {\r\n        listers[_address] = isLister;\r\n    }\r\n\r\n    function excludeToken (address _tokenAddress, bool isExcluded) external onlyOwner {\r\n        excludedTokens[_tokenAddress] = isExcluded;\r\n    }\r\n    \r\n    function setPawSwapFactory (address _address) external onlyOwner {\r\n        PawSwapFactory _factory = PawSwapFactory(_address);\r\n        pawSwapFactory = _factory;\r\n    }\r\n\r\n    function setPawSwapRouter (address _address) external onlyOwner {\r\n        require (pawSwapRouter != _address, \"Router already set to this address\");\r\n        pawSwapRouter = _address;\r\n    }\r\n\r\n    function setTreasuryFee (uint256 _fee) external onlyOwner {\r\n        require (treasuryFee != _fee, \"Fee already set to this value\");\r\n        require (_fee <= 300, \"Fee cannot exceed 3%\");\r\n        treasuryFee = _fee;\r\n    }\r\n\r\n    function toggleDexExcludedFromTreasuryFee (address _dex, bool _excluded) external onlyOwner {\r\n        dexExcludedFromTreasury[_dex] = _excluded;\r\n    }\r\n\r\n    function withdrawEthToOwner (uint256 _amount) external onlyOwner {\r\n        (bool sent, ) = _msgSender().call{value: _amount}(\"\");\r\n        require(sent, \"Failed to send eth to owner\");\r\n    }\r\n\r\n    function withdrawTokenToOwner(address tokenAddress, uint256 amount) external onlyOwner {\r\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\r\n        require(balance >= amount, \"Insufficient token balance\");\r\n\r\n        IERC20(tokenAddress).transfer(_msgSender(), amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"customTaxAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customTaxAddress\",\"type\":\"address\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"customTaxAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customTaxAddress\",\"type\":\"address\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"customTaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"customTaxAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minTokensToReceive\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExactIn\",\"type\":\"bool\"}],\"name\":\"buyOnPawSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dexExcludedFromTreasury\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"excludeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"customTaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokensToReceive\",\"type\":\"uint256\"}],\"name\":\"getBuyAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"customTaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEthToReceive\",\"type\":\"uint256\"}],\"name\":\"getSellAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pawSwapFactory\",\"outputs\":[{\"internalType\":\"contract PawSwapFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pawSwapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"customTaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"customTaxAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minEthToReceive\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExactIn\",\"type\":\"bool\"}],\"name\":\"sellOnPawSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLister\",\"type\":\"bool\"}],\"name\":\"setListerAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPawSwapFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPawSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_taxStructureContractAddress\",\"type\":\"address\"}],\"name\":\"setTokenTaxContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setTreasuryFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dex\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_excluded\",\"type\":\"bool\"}],\"name\":\"toggleDexExcludedFromTreasuryFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenTaxContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthToOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenToOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PawSwap", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000577c27566de2397ae27cf589d747ab57b8e0b227000000000000000000000000229a3370bd43792db113d1eab47176e428e2e539000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8b4fa9f6bf7b561c3eb187b42256c3dba7c6f7f4dee79b0c6feabb932a6d6439"}