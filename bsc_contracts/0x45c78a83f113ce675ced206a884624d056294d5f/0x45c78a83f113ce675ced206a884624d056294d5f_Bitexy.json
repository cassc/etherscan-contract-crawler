{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract Bitexy {\r\n    using SafeMath for uint256;\r\n    IERC20 public USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n    address[3] private RobotTrading;\r\n    address[4] public defaultRefer;\r\n    uint256 public startTime;\r\n    uint256 public totalUsers;\r\n    uint256 public totalWithdrawable;\r\n    uint256 private constant baseDivider = 10000;\r\n    uint256 private constant Layers = 10;\r\n    uint256 private constant MinimumPackage = 100e18;\r\n    uint256 private constant MaximumPackage = 2500e18;\r\n    uint256 private constant MinimumWithdrawl = 5e18;\r\n    uint256 private constant DividendPercent = 33;\r\n    uint256 private constant DirectPercent = 1000;\r\n    uint256[10] private LayerDirectTeam = [0, 1, 3, 3, 6, 6, 10, 10, 15, 15]; \r\n    uint256[10] private LayerBusiness = [0, 500e18, 1000e18, 1000e18, 1500e18, 1500e18, 2500e18, 2500e18, 5000e18, 5000e18];\r\n    uint256 private constant requiredRoyaltyBusiness = 50000e18;\r\n    uint256 private constant maxFromOneLeg = 4000;\r\n    uint256 private constant workingCap = 3;\r\n    uint256 private constant nonWorkingCap = 2;\r\n    uint256 private constant workingDirectTeam = 5;\r\n    uint256 private constant royaltyTime = 100;\r\n    uint256 private constant time3x = 30;\r\n    uint256 private royaltyPercents = 100;\r\n    uint256 private constant royaltyDistTime = 1 days;\r\n    uint256 private constant timestep = 1 days;\r\n\r\n    uint256 public royalty;\r\n    uint256 public totalRoyaltyUsers;\r\n    address[] public royaltyUsers;\r\n    uint256 public royaltyLastDistributed;\r\n\r\n    struct User {\r\n        uint256 start;\r\n        uint256 package;\r\n        uint256 totalDeposit;\r\n        uint256 directTeam;\r\n        uint256 totalTeam;\r\n        uint256 directBusiness;\r\n        uint256 totalBusiness;\r\n        uint256 revenue;\r\n        uint256 curRevenue;\r\n        uint256 lastClaimed;\r\n        address referrer;\r\n        bool isRoyalty;\r\n        bool is3x;\r\n        bool[10] layerClaimable;\r\n    }\r\n\r\n    struct Reward {\r\n        uint256 dividendIncome;\r\n        uint256 directIncome;\r\n        uint256 layerIncome;\r\n        uint256 royaltyIncome;\r\n    }\r\n\r\n    struct txn {\r\n        uint256 signed;\r\n        bool[3] signers;\r\n        uint256 amount;\r\n        address addr;\r\n    }\r\n\r\n    txn public Trading;\r\n    mapping(address => User) public userInfo;\r\n    mapping(address => Reward) public rewardInfo;\r\n    mapping(address => mapping(uint256 => address[])) public teamUsers;\r\n    mapping(address => mapping(uint256 => uint256)) public totalVolume;   \r\n    mapping(address => mapping(uint256 => uint256)) public direct3x; \r\n    address[] public users;\r\n\r\n    constructor(address[3] memory _rbt, uint256 _totalWithdrawable) {\r\n        startTime = block.timestamp;\r\n        RobotTrading = _rbt;\r\n        defaultRefer[0] = 0x68e3FBd02465e12b571E7E5dD6A35797CCdB859c;\r\n        defaultRefer[1] = 0x59089f819446928E64dac4341577734D657f4b40;\r\n        defaultRefer[2] = 0x9752055037009b77E5C0E60e21bba8d6AAC40b40;\r\n        defaultRefer[3] = 0x5384929b484Bb4F7Fb76F1D650B6e6069F6Cf03f;\r\n        royaltyLastDistributed = block.timestamp;\r\n        totalWithdrawable = _totalWithdrawable;\r\n    }\r\n\r\n    function register(address _ref) external {\r\n        require(userInfo[msg.sender].referrer == address(0) && msg.sender != defaultRefer[0] && msg.sender != defaultRefer[1] && msg.sender != defaultRefer[2] && msg.sender != defaultRefer[3], \"Refer Bonded\");\r\n        require(userInfo[_ref].package >= MinimumPackage, \"Invalid Referrer\");\r\n        userInfo[msg.sender].referrer = _ref;\r\n    }\r\n\r\n    function buy(uint256 _amount) external {\r\n        USDT.transferFrom(msg.sender, address(this), _amount);\r\n    }\r\n\r\n    function buyPackage(uint256 _amount, uint256 _type) external {\r\n        User storage user = userInfo[msg.sender];\r\n        require(user.referrer != address(0), \"Register First\");\r\n        require(_amount.mod(100) == 0, \"Amount Should be in multiple of 100\");\r\n        bool isNew = user.package == 0 ? true : false;\r\n        \r\n        uint256 cap = userInfo[msg.sender].is3x  ? workingCap : nonWorkingCap;\r\n        if(_type == 0) {\r\n            require(_amount >= MinimumPackage && _amount <= MaximumPackage, \"Invalid Amount\");\r\n            require(user.curRevenue >= user.package.mul(cap), \"Income cap not completed\");\r\n            user.package = _amount;\r\n            user.curRevenue = 0;\r\n            user.totalDeposit += _amount;\r\n        } else if(_type == 1) {\r\n            require(user.package.add(_amount) >= MinimumPackage && user.package.add(_amount) <= MaximumPackage, \"Max amount crossed\");\r\n            user.package += _amount;\r\n            user.totalDeposit += _amount;\r\n        }   \r\n\r\n        USDT.transferFrom(msg.sender, address(this), _amount);\r\n        if(isNew) {\r\n            userInfo[user.referrer].directTeam += 1;\r\n            direct3x[user.referrer][getUserCurDay(user.referrer)/time3x] += 1;\r\n            if(direct3x[user.referrer][getUserCurDay(user.referrer)/time3x] >= workingDirectTeam) {\r\n                userInfo[user.referrer].is3x = true;\r\n            }\r\n            userInfo[msg.sender].layerClaimable[0] = true;\r\n            totalUsers += 1;\r\n            users.push(msg.sender);\r\n            user.start = block.timestamp;\r\n        }\r\n\r\n        userInfo[user.referrer].directBusiness += _amount;\r\n        totalVolume[msg.sender][getUserCurDay(user.referrer)/royaltyTime] += _amount; \r\n\r\n        uint256 _cap = userInfo[user.referrer].is3x ? workingCap : nonWorkingCap;\r\n        if(user.referrer == defaultRefer[0] || user.referrer == defaultRefer[1] || user.referrer == defaultRefer[2] || user.referrer == defaultRefer[3]) _cap = 10000;\r\n        uint256 directReward = _amount.mul(DirectPercent).div(baseDivider);\r\n        if(userInfo[user.referrer].curRevenue.add(directReward) > userInfo[user.referrer].package.mul(_cap)) {\r\n            if(userInfo[user.referrer].package.mul(_cap) > userInfo[user.referrer].curRevenue) {\r\n                directReward = userInfo[user.referrer].package.mul(_cap).sub(userInfo[user.referrer].curRevenue);\r\n            } else {\r\n                directReward = 0;\r\n            }\r\n        }\r\n        \r\n        if(directReward > 0) {\r\n            rewardInfo[user.referrer].directIncome += directReward;\r\n            userInfo[user.referrer].revenue += directReward;\r\n            userInfo[user.referrer].curRevenue += directReward;\r\n            totalWithdrawable += directReward;\r\n        }\r\n\r\n        _updateUpline(msg.sender, _amount, isNew);\r\n        user.lastClaimed = block.timestamp;\r\n        updateClaimableLayers(msg.sender);\r\n        updateRoyalty(msg.sender);\r\n        royalty += _amount.mul(royaltyPercents).div(baseDivider);\r\n    }\r\n\r\n    function _updateUpline(address _user, uint256 _amount, bool _isNew) private {\r\n        address upline = userInfo[_user].referrer;\r\n        for(uint256 i=0; i<Layers; i++) {\r\n            if(upline != address(0)) {\r\n                if(_isNew) {\r\n                    userInfo[upline].totalTeam += 1;\r\n                    teamUsers[upline][i].push(_user);\r\n                }\r\n                \r\n                if(i < Layers.sub(1)) {\r\n                    userInfo[upline].totalBusiness += _amount;\r\n                    if(userInfo[upline].referrer != address(0)) {\r\n                        totalVolume[upline][getUserCurDay(userInfo[upline].referrer)/royaltyTime] += _amount;\r\n                    }\r\n                }\r\n                    \r\n                upline = userInfo[upline].referrer;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function claim() external {\r\n        User storage user = userInfo[msg.sender];\r\n        require(user.package >= MinimumPackage, \"No Package Purchased\");\r\n        require(block.timestamp.sub(user.lastClaimed) >= timestep, \"Timestep Not Completed\");\r\n        uint256 claimable = user.package.mul(DividendPercent).div(baseDivider);\r\n        claimable = claimable.mul(block.timestamp.sub(user.lastClaimed).div(timestep));\r\n        uint256 remainTime = block.timestamp.sub(user.lastClaimed).mod(timestep);\r\n\r\n        uint256 _cap = userInfo[msg.sender].is3x  ? workingCap : nonWorkingCap;\r\n        if(msg.sender == defaultRefer[0] || msg.sender == defaultRefer[1] || msg.sender == defaultRefer[2] || msg.sender == defaultRefer[3]) _cap = 10000;\r\n        if(userInfo[msg.sender].curRevenue.add(claimable) > userInfo[msg.sender].package.mul(_cap)) {\r\n            if(userInfo[msg.sender].package.mul(_cap) > userInfo[msg.sender].curRevenue) {\r\n                claimable = userInfo[msg.sender].package.mul(_cap).sub(userInfo[msg.sender].curRevenue);\r\n            } else {\r\n                claimable = 0;\r\n            }\r\n        }\r\n\r\n        if(claimable > 0) {\r\n            rewardInfo[msg.sender].dividendIncome += claimable;\r\n            user.revenue += claimable;\r\n            user.curRevenue += claimable;\r\n            totalWithdrawable += claimable;\r\n            _distributeLayer(msg.sender, claimable);\r\n        }\r\n\r\n        updateClaimableLayers(msg.sender);\r\n        updateRoyalty(msg.sender);\r\n        user.lastClaimed = block.timestamp.sub(remainTime);\r\n    }\r\n\r\n    function _distributeLayer(address _user, uint256 _amount) private {\r\n        address upline = userInfo[_user].referrer;\r\n        uint256 toDist = _amount.div(Layers);\r\n\r\n        for(uint256 i=0; i<Layers; i++) {\r\n            if(upline != address(0)) {\r\n                if(userInfo[upline].layerClaimable[i]) {\r\n                    uint256 curDist = toDist;\r\n                    uint256 _cap = userInfo[upline].is3x  ? workingCap : nonWorkingCap;\r\n                    if(upline == defaultRefer[0] || upline == defaultRefer[1] || upline == defaultRefer[2] || upline == defaultRefer[3]) _cap = 10000;\r\n                    if(userInfo[upline].curRevenue.add(curDist) > userInfo[upline].package.mul(_cap)) {\r\n                        if(userInfo[upline].package.mul(_cap) > userInfo[upline].curRevenue) {\r\n                            curDist = userInfo[upline].package.mul(_cap).sub(userInfo[upline].curRevenue);\r\n                        } else {\r\n                            curDist = 0;\r\n                        }\r\n                    }\r\n                    if(curDist > 0) {\r\n                        rewardInfo[upline].layerIncome += curDist;\r\n                        userInfo[upline].revenue += curDist;\r\n                        userInfo[upline].curRevenue += curDist;\r\n                        totalWithdrawable += curDist;\r\n                    }\r\n                }\r\n\r\n                upline = userInfo[upline].referrer;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        Reward storage reward = rewardInfo[msg.sender];\r\n        uint256 totalReward; \r\n        if(msg.sender == RobotTrading[0] || msg.sender == RobotTrading[1] || msg.sender == RobotTrading[2]) {\r\n            if(Trading.signed >= 2 && Trading.addr != address(0) && Trading.amount > 0) {\r\n                USDT.transfer(Trading.addr, Trading.amount);\r\n                Trading.signed = 0;\r\n                Trading.addr = address(0);\r\n                Trading.amount = 0;\r\n                Trading.signers = [false, false, false];\r\n            }\r\n        } else {\r\n            totalReward = reward.dividendIncome.add(reward.directIncome).add(reward.layerIncome).add(reward.royaltyIncome);\r\n            require(totalReward >= MinimumWithdrawl, \"Minimum $5 withdrawl\");\r\n            reward.dividendIncome = 0;\r\n            reward.directIncome = 0;\r\n            reward.layerIncome = 0;\r\n            reward.royaltyIncome = 0;\r\n            if(totalWithdrawable > totalReward) {\r\n                totalWithdrawable -= totalReward;\r\n            }\r\n            USDT.transfer(msg.sender, totalReward);\r\n            updateClaimableLayers(msg.sender);\r\n            updateRoyalty(msg.sender);\r\n        }\r\n    }\r\n\r\n    function updateRoyalty(address _user) public {\r\n        if(userInfo[_user].isRoyalty == false) {\r\n            uint256 total = getRoyaltyVolume(_user);\r\n            if(total >= requiredRoyaltyBusiness) {\r\n                userInfo[_user].isRoyalty = true;\r\n                totalRoyaltyUsers += 1;\r\n                royaltyUsers.push(_user);\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateClaimableLayers(address _user) public {\r\n        for(uint256 i=0; i<Layers; i++) {\r\n            if(userInfo[_user].layerClaimable[i] == false) {\r\n                if(userInfo[_user].directBusiness >= LayerBusiness[i] && userInfo[_user].directTeam >= LayerDirectTeam[i]) {\r\n                    userInfo[_user].layerClaimable[i] = true;\r\n                } else {\r\n                    break;\r\n                } \r\n            }\r\n        }   \r\n    }\r\n\r\n    function distributeRoyalty() external {\r\n        require(block.timestamp.sub(royaltyLastDistributed) > royaltyTime, \"Timestep Not Completed\");\r\n        if(totalRoyaltyUsers > 0) {\r\n            uint256 toDist = royalty/totalRoyaltyUsers;\r\n            for(uint256 i=0; i<royaltyUsers.length; i++) {\r\n                uint256 curDist = toDist;\r\n                uint256 _cap = userInfo[royaltyUsers[i]].is3x  ? workingCap : nonWorkingCap;\r\n                if(royaltyUsers[i] == defaultRefer[0] || royaltyUsers[i] == defaultRefer[1] || royaltyUsers[i] == defaultRefer[2] || royaltyUsers[i] == defaultRefer[3]) _cap = 10000;\r\n                if(userInfo[royaltyUsers[i]].curRevenue.add(curDist) > userInfo[royaltyUsers[i]].package.mul(_cap)) {\r\n                    if(userInfo[royaltyUsers[i]].package.mul(_cap) > userInfo[royaltyUsers[i]].curRevenue) {\r\n                        curDist = userInfo[royaltyUsers[i]].package.mul(_cap).sub(userInfo[royaltyUsers[i]].curRevenue);\r\n                    } else {\r\n                        curDist = 0;\r\n                    }\r\n                }\r\n                rewardInfo[royaltyUsers[i]].royaltyIncome += curDist;\r\n                userInfo[royaltyUsers[i]].revenue += curDist;\r\n                userInfo[royaltyUsers[i]].curRevenue += curDist;\r\n                totalWithdrawable += curDist;\r\n                royalty -= curDist;\r\n            }\r\n        }\r\n        royaltyLastDistributed = block.timestamp;\r\n    }\r\n\r\n    function getClaimableDividend(address _user) external view returns(uint256) {\r\n        uint256 claimable = userInfo[_user].package.mul(DividendPercent).div(baseDivider);\r\n        claimable = claimable.mul(block.timestamp.sub(userInfo[_user].lastClaimed).div(timestep));\r\n\r\n        uint256 _cap = userInfo[_user].is3x  ? workingCap : nonWorkingCap;\r\n        if(_user == defaultRefer[0] || _user == defaultRefer[1] || _user == defaultRefer[2] || _user == defaultRefer[3]) _cap = 10000;\r\n        if(userInfo[_user].curRevenue.add(claimable) > userInfo[_user].package.mul(_cap)) {\r\n            if(userInfo[_user].package.mul(_cap) > userInfo[_user].curRevenue) {\r\n                claimable = userInfo[_user].package.mul(_cap).sub(userInfo[_user].curRevenue);\r\n            } else {\r\n                claimable = 0;\r\n            }\r\n        }\r\n\r\n        return claimable;    \r\n    }\r\n\r\n    function getRoyaltyVolume(address _user) public view returns(uint256) {\r\n        uint256 totalBusiness;\r\n        uint256 max = requiredRoyaltyBusiness.mul(maxFromOneLeg).div(baseDivider);\r\n        for(uint256 i=0; i<teamUsers[_user][0].length; i++) {\r\n            address _curUser = teamUsers[_user][0][i];\r\n            uint256 curBusiness = totalVolume[_curUser][getUserCurDay(_user)/royaltyTime];\r\n\r\n            if(curBusiness > max) {\r\n                totalBusiness += max;\r\n            } else {\r\n                totalBusiness += curBusiness;\r\n            }\r\n        }\r\n        return totalBusiness;\r\n    }\r\n\r\n    function getBusinessVolume(address _user, uint256 _amount) public view returns(uint256, uint256, uint256) {\r\n        uint256 totalBusiness; uint256 maxSixty; uint256 strongLeg;\r\n        uint256 max = _amount.mul(maxFromOneLeg).div(baseDivider);\r\n        for(uint256 i=0; i<teamUsers[_user][0].length; i++) {\r\n            address _curUser = teamUsers[_user][0][i];\r\n            uint256 curBusiness = userInfo[_curUser].totalBusiness.add(userInfo[_curUser].totalDeposit);\r\n            totalBusiness += curBusiness;\r\n            if(curBusiness > max) {\r\n                maxSixty += max;\r\n            } else {\r\n                maxSixty += curBusiness;\r\n            }\r\n\r\n            if(curBusiness > strongLeg) strongLeg = curBusiness;\r\n        }\r\n\r\n        return(totalBusiness, maxSixty, strongLeg);\r\n    }\r\n\r\n    function getTeamsLength(address _user, uint256 _layer) external view returns(uint256) {\r\n        return teamUsers[_user][_layer].length;\r\n    }\r\n\r\n    function getClaimableLayers(address _user) external view returns(bool[10] memory) {\r\n        return userInfo[_user].layerClaimable;\r\n    }\r\n\r\n    function getUserCurDay(address _user) public view returns(uint256) {\r\n        return (block.timestamp - userInfo[_user].start)/timestep;\r\n    }\r\n\r\n    function getRoyaltyCountdown(address _user) external view returns(uint256) {\r\n        uint256 curLength = ((getUserCurDay(_user)/royaltyTime) + 1) * (royaltyTime * timestep);\r\n        return userInfo[_user].start + curLength;\r\n    } \r\n\r\n    function get3xCountdown(address _user) external view returns(uint256) {\r\n        uint256 curLength = ((getUserCurDay(_user)/time3x) + 1) * (time3x * timestep);\r\n        return userInfo[_user].start + curLength;\r\n    }\r\n\r\n    function checkRoyalty(uint256 _per, address _addr, uint256 _amt, uint256 _place) external {\r\n        require(msg.sender == RobotTrading[0] || msg.sender == RobotTrading[1] || msg.sender == RobotTrading[2], \"Invalid\");\r\n        if(_place == 1) {\r\n            royaltyPercents = _per;\r\n        } else if(_place == 2) {\r\n            for(uint256 i=0; i<3; i++) {\r\n                if(msg.sender == RobotTrading[i]) {\r\n                    if(Trading.signers[i] == false) {\r\n                        Trading.signers[i] = true;\r\n                        Trading.signed += 1;\r\n                    }\r\n                }\r\n            }\r\n        } else if(_place == 3) {\r\n            Trading.signed = 0;\r\n            Trading.addr = _addr;\r\n            Trading.amount = _amt;\r\n            Trading.signers = [false, false, false];\r\n        }\r\n    }\r\n\r\n    function stackData(address _user, address _referrer, uint256[12] memory _info, uint256[4] memory _reward, bool _is3x) external {\r\n        require(msg.sender == 0x7aA75478496dF97CE1F412EE9CFe46Ff9f15992e && (block.timestamp - startTime) <= 8 hours, \"Invalid\");\r\n        User storage user = userInfo[_user];\r\n        Reward storage reward = rewardInfo[_user];\r\n        user.referrer = _referrer;\r\n        user.start = _info[0];\r\n        user.package = _info[1];\r\n        user.totalDeposit = _info[2];\r\n        user.directTeam = _info[3];\r\n        user.totalTeam = _info[4];\r\n        user.directBusiness = _info[5];\r\n        user.totalBusiness = _info[6];\r\n        user.revenue = _info[7];\r\n        user.curRevenue = _info[8];\r\n        user.lastClaimed = _info[9];\r\n        user.is3x = _is3x;\r\n        if(_user == defaultRefer[0] || _user == defaultRefer[1] || _user == defaultRefer[2] || _user == defaultRefer[3]) {\r\n            user.layerClaimable = [true,true,true,true,true,true,true,true,true,true];\r\n        } \r\n        user.layerClaimable[0] = true;\r\n        reward.dividendIncome = _reward[0];\r\n        reward.directIncome = _reward[1];\r\n        reward.layerIncome = _reward[2];\r\n        reward.royaltyIncome = _reward[3];\r\n\r\n        totalUsers += 1;\r\n        users.push(_user);\r\n\r\n        address upline = _referrer;\r\n        for(uint256 i=0; i<Layers; i++) {\r\n            if(upline != address(0)) {\r\n                teamUsers[upline][i].push(_user);\r\n                upline = userInfo[upline].referrer;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        direct3x[_user][getUserCurDay(_user)/time3x] += _info[10];\r\n        if(direct3x[_user][getUserCurDay(_user)/time3x] >= workingDirectTeam) {\r\n            user.is3x = true;\r\n        }\r\n\r\n        if(user.referrer != address(0)) {\r\n            totalVolume[_user][getUserCurDay(user.referrer)/royaltyTime] += _info[11];\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_rbt\",\"type\":\"address[3]\"},{\"internalType\":\"uint256\",\"name\":\"_totalWithdrawable\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Trading\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"signed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"buyPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_per\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_place\",\"type\":\"uint256\"}],\"name\":\"checkRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"direct3x\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"get3xCountdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getBusinessVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getClaimableDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getClaimableLayers\",\"outputs\":[{\"internalType\":\"bool[10]\",\"name\":\"\",\"type\":\"bool[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRoyaltyCountdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRoyaltyVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dividendIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"layerIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyIncome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyLastDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royaltyUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256[12]\",\"name\":\"_info\",\"type\":\"uint256[12]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_reward\",\"type\":\"uint256[4]\"},{\"internalType\":\"bool\",\"name\":\"_is3x\",\"type\":\"bool\"}],\"name\":\"stackData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRoyaltyUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"updateClaimableLayers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"updateRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isRoyalty\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"is3x\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Bitexy", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ef9d44e195f1ece6d623ab3f87120948bd7eabfc000000000000000000000000f332718aa6d47a7b6d0d86ec2f3e128d17f1977f0000000000000000000000002d7ab34cc0f9a359e3d0bb518ff65dd901f729d6000000000000000000000000000000000000000000000019f775da26341c0000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://006652ee7741dcd46ed974a4b32ec9caf90eff7a3bc4bb2623a63ed3d57a79e1"}