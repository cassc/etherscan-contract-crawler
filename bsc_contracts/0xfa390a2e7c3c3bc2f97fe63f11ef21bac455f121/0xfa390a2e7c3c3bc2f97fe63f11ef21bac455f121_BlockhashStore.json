{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"BlockhashStore.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n/**\\n * @title BlockhashStore\\n * @notice This contract provides a way to access blockhashes older than\\n *   the 256 block limit imposed by the BLOCKHASH opcode.\\n *   You may assume that any blockhash stored by the contract is correct.\\n */\\ncontract BlockhashStore {\\n\\n  mapping(uint => bytes32) internal s_blockhashes;\\n\\n  /**\\n   * @notice stores blockhash of a given block, assuming it is available through BLOCKHASH\\n   * @param n the number of the block whose blockhash should be stored\\n   */\\n  function store(uint256 n) public {\\n    bytes32 h = blockhash(n);\\n    require(h != 0x0, \\\"blockhash(n) failed\\\");\\n    s_blockhashes[n] = h;\\n  }\\n\\n\\n  /**\\n   * @notice stores blockhash of the earliest block still available through BLOCKHASH.\\n   */\\n  function storeEarliest() external {\\n    store(block.number - 256);\\n  }\\n\\n  /**\\n   * @notice stores blockhash after verifying blockheader of child/subsequent block\\n   * @param n the number of the block whose blockhash should be stored\\n   * @param header the rlp-encoded blockheader of block n+1. We verify its correctness by checking\\n   *   that it hashes to a stored blockhash, and then extract parentHash to get the n-th blockhash.\\n   */\\n  function storeVerifyHeader(uint256 n, bytes memory header) public {\\n    require(keccak256(header) == s_blockhashes[n + 1], \\\"header has unknown blockhash\\\");\\n\\n    // At this point, we know that header is the correct blockheader for block n+1.\\n\\n    // The header is an rlp-encoded list. The head item of that list is the 32-byte blockhash of the parent block.\\n    // Based on how rlp works, we know that blockheaders always have the following form:\\n    // 0xf9____a0PARENTHASH...\\n    //   ^ ^   ^\\n    //   | |   |\\n    //   | |   +--- PARENTHASH is 32 bytes. rlpenc(PARENTHASH) is 0xa || PARENTHASH.\\n    //   | |\\n    //   | +--- 2 bytes containing the sum of the lengths of the encoded list items\\n    //   |\\n    //   +--- 0xf9 because we have a list and (sum of lengths of encoded list items) fits exactly into two bytes.\\n    //\\n    // As a consequence, the PARENTHASH is always at offset 4 of the rlp-encoded block header.\\n\\n    bytes32 parentHash;\\n    assembly {\\n      parentHash := mload(add(header, 36)) // 36 = 32 byte offset for length prefix of ABI-encoded array\\n                                           //    +  4 byte offset of PARENTHASH (see above)\\n    }\\n\\n    s_blockhashes[n] = parentHash;\\n  }\\n\\n  /**\\n   * @notice gets a blockhash from the store. If no hash is known, this function reverts.\\n   * @param n the number of the block whose blockhash should be returned\\n   */\\n  function getBlockhash(uint256 n) external view returns (bytes32) {\\n    bytes32 h = s_blockhashes[n];\\n    require(h != 0x0, \\\"blockhash not found in store\\\");\\n    return h;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getBlockhash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"store\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storeEarliest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"storeVerifyHeader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlockhashStore", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}