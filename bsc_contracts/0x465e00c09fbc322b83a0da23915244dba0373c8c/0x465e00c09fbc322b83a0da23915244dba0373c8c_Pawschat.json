{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Pawschat.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\ncontract Pawschat {\\n    struct User {\\n        string name;\\n        Friend[] friendlist;\\n    }\\n\\n    struct Friend {\\n        address pubKey;\\n        string name;\\n    }\\n\\n    struct AllUsersStruct {\\n        string name;\\n        address account;\\n    }\\n\\n    struct Message {\\n        address sender;\\n        uint256 timeStamp;\\n        string message;\\n    }\\n\\n    AllUsersStruct[] getAllUsers;\\n\\n    mapping(address => User) userList;\\n    mapping(bytes32 => Message[]) allMessages;\\n\\n    //create Account\\n    function createAccount(string calldata name) external {\\n        require(checkUserExists(msg.sender) == false, \\\"User already exists\\\");\\n        require(bytes(name).length > 0, \\\"User name cannot be empty\\\");\\n\\n        userList[msg.sender].name = name;\\n        getAllUsers.push(AllUsersStruct(name, msg.sender));\\n    }\\n\\n    //Add Friend\\n    function addFriend(address friend_key, string calldata name) external {\\n        require(checkUserExists(friend_key), \\\"User does not exist\\\");\\n        require(checkUserExists(msg.sender), \\\"create an account first\\\");\\n        require(msg.sender != friend_key, \\\"User cant add themselves as friend\\\");\\n        require(\\n            checkAlreadyFriends(msg.sender, friend_key) == false,\\n            \\\"Alredy friends\\\"\\n        );\\n\\n        _addFriend(msg.sender, friend_key, name);\\n        _addFriend(friend_key, msg.sender, userList[msg.sender].name);\\n    }\\n\\n    //Sends message\\n    function sendMessage(address friend, string calldata _msg) external {\\n        require(checkUserExists(friend), \\\"User does not exist\\\");\\n        require(checkUserExists(msg.sender), \\\"create an account first\\\");\\n        require(checkAlreadyFriends(msg.sender, friend), \\\"Not friends\\\");\\n\\n        bytes32 chatCode = _getChatCode(msg.sender, friend);\\n        Message memory newMsg = Message(msg.sender, block.timestamp, _msg);\\n        allMessages[chatCode].push(newMsg);\\n    }\\n\\n    // adds freind address to friendList\\n    function _addFriend(\\n        address user,\\n        address friend,\\n        string memory friendName\\n    ) internal {\\n        Friend memory newFriend = Friend(friend, friendName);\\n        userList[user].friendlist.push(newFriend);\\n    }\\n\\n    //Read Message\\n    function readMessage(\\n        address friend\\n    ) external view returns (Message[] memory) {\\n        bytes32 chatCode = _getChatCode(msg.sender, friend);\\n        return allMessages[chatCode];\\n    }\\n\\n    // check if user exist or not\\n    function checkUserExists(address _user) public view returns (bool) {\\n        return bytes(userList[_user].name).length > 0;\\n    }\\n\\n    // Checks if already friends or not\\n    function checkAlreadyFriends(\\n        address user,\\n        address friend\\n    ) internal view returns (bool) {\\n        if (\\n            userList[user].friendlist.length >\\n            userList[friend].friendlist.length\\n        ) {\\n            address tmp = user;\\n            user = friend;\\n            friend = tmp;\\n        }\\n\\n        for (uint256 i = 0; i < userList[user].friendlist.length; i++) {\\n            if (userList[user].friendlist[i].pubKey == friend) return true;\\n        }\\n        return false;\\n    }\\n\\n    // returns name of user\\n    function getUserName(address pubKey) external view returns (string memory) {\\n        require(checkUserExists(pubKey), \\\"User does not exist\\\");\\n        return userList[pubKey].name;\\n    }\\n\\n    // returns friend array\\n    function getFriendList() external view returns (Friend[] memory) {\\n        return userList[msg.sender].friendlist;\\n    }\\n\\n    // returns chat code\\n    function _getChatCode(\\n        address pubKey1,\\n        address pubKey2\\n    ) public pure returns (bytes32) {\\n        if (pubKey1 < pubKey2) {\\n            return keccak256(abi.encodePacked(pubKey1, pubKey2));\\n        }\\n        return keccak256(abi.encodePacked(pubKey2, pubKey1));\\n    }\\n\\n    // get all user\\n    function getAllUsersApp() public view returns (AllUsersStruct[] memory) {\\n        return getAllUsers;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pubKey1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pubKey2\",\"type\":\"address\"}],\"name\":\"_getChatCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"friend_key\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"addFriend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"createAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllUsersApp\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"internalType\":\"struct Pawschat.AllUsersStruct[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFriendList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pubKey\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct Pawschat.Friend[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pubKey\",\"type\":\"address\"}],\"name\":\"getUserName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"}],\"name\":\"readMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct Pawschat.Message[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Pawschat", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}