{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract GhostInterface {\r\n    function ownerOf(uint256 id) public virtual returns (address);\r\n    function transferFrom(address from, address to, uint256 id) public virtual;\r\n    function getApproved(uint256 tokenId) public view virtual returns (address);\r\n    function balanceOf(address owner) public view virtual returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256);\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC721Receiver} interface.\r\n *\r\n * Accepts all token transfers.\r\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n */\r\ncontract ERC721Holder is IERC721Receiver {\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IWETH.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n\r\n// File: contracts/interfaces/ICollectionWhitelistChecker.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICollectionWhitelistChecker {\r\n    function canList(uint256 _tokenId) external view returns (bool);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\ncontract GhostThirdParty is ERC721Holder, Ownable, ReentrancyGuard {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    enum CollectionStatus {\r\n        Pending,\r\n        Open,\r\n        Close\r\n    }\r\n    \r\n    mapping (address => uint256) private minterCount;\r\n     \r\n    uint256 private _reflectionMintRoyalty = 2;\r\n    uint256 public reflectionMintBalance;\r\n    uint256 public totalMintDividend;\r\n    mapping(address => uint256) lastMintDividendAt;\r\n    \r\n    uint256 private _reflectionRoyalty = 5;\r\n    uint256 public reflectionBalance;\r\n    uint256 public totalDividend;\r\n    mapping(uint256 => uint256) lastDividendAt;\r\n\r\n    address public immutable WBNB;\r\n\r\n    uint256 public constant TOTAL_MAX_FEE = 1000; // 10% of a sale\r\n\r\n    GhostInterface ghostContract; \r\n    address public adminAddress;\r\n    address public treasuryAddress;\r\n    uint256 public minimumAskPrice; // in wei\r\n    uint256 public maximumAskPrice; // in wei\r\n\r\n    mapping(address => uint256) public pendingRevenue; // For creator/treasury to claim\r\n\r\n    EnumerableSet.AddressSet private _collectionAddressSet;\r\n\r\n    mapping(address => mapping(uint256 => Ask)) private _askDetails; // Ask details (price + seller address) for a given collection and a tokenId\r\n    mapping(address => EnumerableSet.UintSet) private _askTokenIds; // Set of tokenIds for a collection\r\n    mapping(address => Collection) private _collections; // Details about the collections\r\n    mapping(address => mapping(address => EnumerableSet.UintSet)) private _tokenIdsOfSellerForCollection;\r\n\r\n    struct Ask {\r\n        address seller; // address of the seller\r\n        uint256 price; // price of the token\r\n    }\r\n\r\n    struct Collection {\r\n        CollectionStatus status; // status of the collection\r\n        address creatorAddress; // address of the creator\r\n        address whitelistChecker; // whitelist checker (if not set --> 0x00)\r\n        uint256 tradingFee; // trading fee (100 = 1%, 500 = 5%, 5 = 0.05%)\r\n        uint256 creatorFee; // creator fee (100 = 1%, 500 = 5%, 5 = 0.05%)\r\n    }\r\n    \r\n    event AddMinterDataForAccounts(address[] accounts, uint256[] amounts);\r\n\r\n\r\n    // Ask order is cancelled\r\n    event AskCancel(address indexed collection, address indexed seller, uint256 indexed tokenId);\r\n\r\n    // Ask order is created\r\n    event AskNew(address indexed collection, address indexed seller, uint256 indexed tokenId, uint256 askPrice);\r\n\r\n    // Ask order is updated\r\n    event AskUpdate(address indexed collection, address indexed seller, uint256 indexed tokenId, uint256 askPrice);\r\n\r\n    // Collection is closed for trading and new listings\r\n    event CollectionClose(address indexed collection);\r\n\r\n    // New collection is added\r\n    event CollectionNew(\r\n        address indexed collection,\r\n        address indexed creator,\r\n        address indexed whitelistChecker,\r\n        uint256 tradingFee,\r\n        uint256 creatorFee\r\n    );\r\n\r\n    // Existing collection is updated\r\n    event CollectionUpdate(\r\n        address indexed collection,\r\n        address indexed creator,\r\n        address indexed whitelistChecker,\r\n        uint256 tradingFee,\r\n        uint256 creatorFee\r\n    );\r\n\r\n    // Admin and Treasury Addresses are updated\r\n    event NewAdminAndTreasuryAddresses(address indexed admin, address indexed treasury);\r\n\r\n    // Minimum/maximum ask prices are updated\r\n    event NewMinimumAndMaximumAskPrices(uint256 minimumAskPrice, uint256 maximumAskPrice);\r\n\r\n    // Recover NFT tokens sent by accident\r\n    event NonFungibleTokenRecovery(address indexed token, uint256 indexed tokenId);\r\n\r\n    // Pending revenue is claimed\r\n    event RevenueClaim(address indexed claimer, uint256 amount);\r\n\r\n    // Recover ERC20 tokens sent by accident\r\n    event TokenRecovery(address indexed token, uint256 amount);\r\n\r\n    // Ask order is matched by a trade\r\n    event Trade(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address buyer,\r\n        uint256 askPrice,\r\n        uint256 netPrice,\r\n        bool withBNB\r\n    );\r\n\r\n    // Modifier for the admin\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Management: Not admin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _adminAddress: address of the admin\r\n     * @param _treasuryAddress: address of the treasury\r\n     * @param _WBNBAddress: WBNB address\r\n     * @param _minimumAskPrice: minimum ask price\r\n     * @param _maximumAskPrice: maximum ask price\r\n     */\r\n    constructor(\r\n        address _adminAddress,\r\n        address _treasuryAddress,\r\n        address _WBNBAddress,\r\n        address _ghostAddress,\r\n        uint256 _minimumAskPrice,\r\n        uint256 _maximumAskPrice\r\n    ) {\r\n        require(_adminAddress != address(0), \"Operations: Admin address cannot be zero\");\r\n        require(_treasuryAddress != address(0), \"Operations: Treasury address cannot be zero\");\r\n        require(_WBNBAddress != address(0), \"Operations: WBNB address cannot be zero\");\r\n        require(_minimumAskPrice > 0, \"Operations: _minimumAskPrice must be > 0\");\r\n        require(_minimumAskPrice < _maximumAskPrice, \"Operations: _minimumAskPrice < _maximumAskPrice\");\r\n\r\n        adminAddress = _adminAddress;\r\n        treasuryAddress = _treasuryAddress;\r\n        ghostContract = GhostInterface(_ghostAddress);\r\n\r\n        WBNB = _WBNBAddress;\r\n\r\n        minimumAskPrice = _minimumAskPrice;\r\n        maximumAskPrice = _maximumAskPrice;\r\n    }\r\n    \r\n     function reflectDividend(uint256 amount) private {\r\n        reflectionBalance  = reflectionBalance + amount;\r\n        totalDividend = totalDividend + (amount/10000);\r\n    }\r\n    \r\n\r\n    function reflectToHolders() public payable {\r\n        reflectDividend(msg.value);\r\n    }\r\n\r\n    function currentRate() public view returns (uint256){\r\n      return reflectionBalance/10000;\r\n    }\r\n    \r\n      function reflectMintDividend(uint256 amount) private {\r\n        reflectionMintBalance  = reflectionMintBalance + amount;\r\n        totalMintDividend = totalMintDividend + (amount/10000);\r\n    }\r\n    \r\n    function reflectToMinters() public payable {\r\n        reflectMintDividend(msg.value);\r\n    }\r\n\r\n    \r\n     function currentMintRate() public view returns (uint256){\r\n      return reflectionMintBalance/10000;\r\n    }\r\n    \r\n    function addMinterDataForAccounts(address[] calldata accounts, uint256[] calldata mints) public onlyOwner {\r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n            minterCount[accounts[i]] = mints[i];\r\n        }\r\n\r\n        emit AddMinterDataForAccounts(accounts, mints);\r\n    }\r\n    \r\n    function getMintCount(address minterAddress) public view returns(uint256) {\r\n        return minterCount[minterAddress];\r\n    }\r\n    \r\n     /**\r\n     * @notice Claim pending revenue (minters, holders)\r\n     */\r\n    function claimRewards() external nonReentrant {\r\n        uint count = ghostContract.balanceOf(msg.sender);\r\n        uint256 balance = 0;\r\n        for(uint i=0; i < count; i++) {\r\n            uint tokenId = ghostContract.tokenOfOwnerByIndex(msg.sender, i);\r\n            balance += getReflectionBalance(tokenId);\r\n            lastDividendAt[tokenId] = totalDividend;\r\n        }\r\n        \r\n        balance += getReflectionMintBalance(msg.sender,getMintCount(msg.sender));\r\n        lastMintDividendAt[msg.sender] = totalMintDividend;\r\n        \r\n        require(balance != 0, \"Claim: Nothing to claim\");\r\n        \r\n        payable(msg.sender).transfer(balance);\r\n        \r\n        emit RevenueClaim(msg.sender, balance);\r\n    }\r\n\r\n  function getReflectionBalances() public view returns(uint256) {\r\n        uint count = ghostContract.balanceOf(msg.sender);\r\n        uint256 total = 0;\r\n        for(uint i=0; i < count; i++){\r\n            uint tokenId = ghostContract.tokenOfOwnerByIndex(msg.sender, i);\r\n            total += getReflectionBalance(tokenId);\r\n        }\r\n        uint mintCount = getMintCount(msg.sender);\r\n        total += getReflectionMintBalance(msg.sender,mintCount);\r\n        return total;\r\n    }\r\n    function getReflectionMintBalance(address senderAddress,uint256 mintCount) public view returns (uint256){\r\n      return (totalMintDividend - lastMintDividendAt[senderAddress])*mintCount;\r\n    }\r\n    function getReflectionBalance(uint256 tokenId) public view returns (uint256){\r\n      return totalDividend - lastDividendAt[tokenId];\r\n    }\r\n    /**\r\n     * @notice Buy token with BNB by matching the price of an existing ask order\r\n     * @param _collection: contract address of the NFT\r\n     * @param _tokenId: tokenId of the NFT purchased\r\n     */\r\n    function buyTokenUsingBNB(address _collection, uint256 _tokenId) external payable nonReentrant {\r\n        // Wrap BNB\r\n        IWETH(WBNB).deposit{value: msg.value}();\r\n\r\n        _buyToken(_collection, _tokenId, msg.value, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Buy token with WBNB by matching the price of an existing ask order\r\n     * @param _collection: contract address of the NFT\r\n     * @param _tokenId: tokenId of the NFT purchased\r\n     * @param _price: price (must be equal to the askPrice set by the seller)\r\n     */\r\n    function buyTokenUsingWBNB(\r\n        address _collection,\r\n        uint256 _tokenId,\r\n        uint256 _price\r\n    ) external nonReentrant {\r\n        IERC20(WBNB).safeTransferFrom(address(msg.sender), address(this), _price);\r\n\r\n        _buyToken(_collection, _tokenId, _price, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel existing ask order\r\n     * @param _collection: contract address of the NFT\r\n     * @param _tokenId: tokenId of the NFT\r\n     */\r\n    function cancelAskOrder(address _collection, uint256 _tokenId) external nonReentrant {\r\n        // Verify the sender has listed it\r\n        require(_tokenIdsOfSellerForCollection[msg.sender][_collection].contains(_tokenId), \"Order: Token not listed\");\r\n\r\n        // Adjust the information\r\n        _tokenIdsOfSellerForCollection[msg.sender][_collection].remove(_tokenId);\r\n        delete _askDetails[_collection][_tokenId];\r\n        _askTokenIds[_collection].remove(_tokenId);\r\n\r\n        // Transfer the NFT back to the user\r\n        IERC721(_collection).transferFrom(address(this), address(msg.sender), _tokenId);\r\n\r\n        // Emit event\r\n        emit AskCancel(_collection, msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim pending revenue (treasury or creators)\r\n     */\r\n    function claimPendingRevenue() external nonReentrant {\r\n        uint256 revenueToClaim = pendingRevenue[msg.sender];\r\n        require(revenueToClaim != 0, \"Claim: Nothing to claim\");\r\n        pendingRevenue[msg.sender] = 0;\r\n\r\n        IERC20(WBNB).safeTransfer(address(msg.sender), revenueToClaim);\r\n\r\n        emit RevenueClaim(msg.sender, revenueToClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Create ask order\r\n     * @param _collection: contract address of the NFT\r\n     * @param _tokenId: tokenId of the NFT\r\n     * @param _askPrice: price for listing (in wei)\r\n     */\r\n    function createAskOrder(\r\n        address _collection,\r\n        uint256 _tokenId,\r\n        uint256 _askPrice\r\n    ) external nonReentrant {\r\n        // Verify price is not too low/high\r\n        require(_askPrice >= minimumAskPrice && _askPrice <= maximumAskPrice, \"Order: Price not within range\");\r\n\r\n        // Verify collection is accepted\r\n        require(_collections[_collection].status == CollectionStatus.Open, \"Collection: Not for listing\");\r\n\r\n        // Verify token has restriction\r\n        require(_canTokenBeListed(_collection, _tokenId), \"Order: tokenId not eligible\");\r\n\r\n        // Transfer NFT to this contract\r\n        IERC721(_collection).safeTransferFrom(address(msg.sender), address(this), _tokenId);\r\n\r\n        // Adjust the information\r\n        _tokenIdsOfSellerForCollection[msg.sender][_collection].add(_tokenId);\r\n        _askDetails[_collection][_tokenId] = Ask({seller: msg.sender, price: _askPrice});\r\n\r\n        // Add tokenId to the askTokenIds set\r\n        _askTokenIds[_collection].add(_tokenId);\r\n\r\n        // Emit event\r\n        emit AskNew(_collection, msg.sender, _tokenId, _askPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Modify existing ask order\r\n     * @param _collection: contract address of the NFT\r\n     * @param _tokenId: tokenId of the NFT\r\n     * @param _newPrice: new price for listing (in wei)\r\n     */\r\n    function modifyAskOrder(\r\n        address _collection,\r\n        uint256 _tokenId,\r\n        uint256 _newPrice\r\n    ) external nonReentrant {\r\n        // Verify new price is not too low/high\r\n        require(_newPrice >= minimumAskPrice && _newPrice <= maximumAskPrice, \"Order: Price not within range\");\r\n\r\n        // Verify collection is accepted\r\n        require(_collections[_collection].status == CollectionStatus.Open, \"Collection: Not for listing\");\r\n\r\n        // Verify the sender has listed it\r\n        require(_tokenIdsOfSellerForCollection[msg.sender][_collection].contains(_tokenId), \"Order: Token not listed\");\r\n\r\n        // Adjust the information\r\n        _askDetails[_collection][_tokenId].price = _newPrice;\r\n\r\n        // Emit event\r\n        emit AskUpdate(_collection, msg.sender, _tokenId, _newPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new collection\r\n     * @param _collection: collection address\r\n     * @param _creator: creator address (must be 0x00 if none)\r\n     * @param _whitelistChecker: whitelist checker (for additional restrictions, must be 0x00 if none)\r\n     * @param _tradingFee: trading fee (100 = 1%, 500 = 5%, 5 = 0.05%)\r\n     * @param _creatorFee: creator fee (100 = 1%, 500 = 5%, 5 = 0.05%, 0 if creator is 0x00)\r\n     * @dev Callable by admin\r\n     */\r\n    function addCollection(\r\n        address _collection,\r\n        address _creator,\r\n        address _whitelistChecker,\r\n        uint256 _tradingFee,\r\n        uint256 _creatorFee\r\n    ) external onlyAdmin {\r\n        require(!_collectionAddressSet.contains(_collection), \"Operations: Collection already listed\");\r\n        require(IERC721(_collection).supportsInterface(0x80ac58cd), \"Operations: Not ERC721\");\r\n\r\n        require(\r\n            (_creatorFee == 0 && _creator == address(0)) || (_creatorFee != 0 && _creator != address(0)),\r\n            \"Operations: Creator parameters incorrect\"\r\n        );\r\n\r\n        require(_tradingFee + _creatorFee <= TOTAL_MAX_FEE, \"Operations: Sum of fee must inferior to TOTAL_MAX_FEE\");\r\n\r\n        _collectionAddressSet.add(_collection);\r\n\r\n        _collections[_collection] = Collection({\r\n            status: CollectionStatus.Open,\r\n            creatorAddress: _creator,\r\n            whitelistChecker: _whitelistChecker,\r\n            tradingFee: _tradingFee,\r\n            creatorFee: _creatorFee\r\n        });\r\n\r\n        emit CollectionNew(_collection, _creator, _whitelistChecker, _tradingFee, _creatorFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the admin to close collection for trading and new listing\r\n     * @param _collection: collection address\r\n     * @dev Callable by admin\r\n     */\r\n    function closeCollectionForTradingAndListing(address _collection) external onlyAdmin {\r\n        require(_collectionAddressSet.contains(_collection), \"Operations: Collection not listed\");\r\n\r\n        _collections[_collection].status = CollectionStatus.Close;\r\n        _collectionAddressSet.remove(_collection);\r\n\r\n        emit CollectionClose(_collection);\r\n    }\r\n\r\n    /**\r\n     * @notice Modify collection characteristics\r\n     * @param _collection: collection address\r\n     * @param _creator: creator address (must be 0x00 if none)\r\n     * @param _whitelistChecker: whitelist checker (for additional restrictions, must be 0x00 if none)\r\n     * @param _tradingFee: trading fee (100 = 1%, 500 = 5%, 5 = 0.05%)\r\n     * @param _creatorFee: creator fee (100 = 1%, 500 = 5%, 5 = 0.05%, 0 if creator is 0x00)\r\n     * @dev Callable by admin\r\n     */\r\n    function modifyCollection(\r\n        address _collection,\r\n        address _creator,\r\n        address _whitelistChecker,\r\n        uint256 _tradingFee,\r\n        uint256 _creatorFee\r\n    ) external onlyAdmin {\r\n        require(_collectionAddressSet.contains(_collection), \"Operations: Collection not listed\");\r\n\r\n        require(\r\n            (_creatorFee == 0 && _creator == address(0)) || (_creatorFee != 0 && _creator != address(0)),\r\n            \"Operations: Creator parameters incorrect\"\r\n        );\r\n\r\n        require(_tradingFee + _creatorFee <= TOTAL_MAX_FEE, \"Operations: Sum of fee must inferior to TOTAL_MAX_FEE\");\r\n\r\n        _collections[_collection] = Collection({\r\n            status: CollectionStatus.Open,\r\n            creatorAddress: _creator,\r\n            whitelistChecker: _whitelistChecker,\r\n            tradingFee: _tradingFee,\r\n            creatorFee: _creatorFee\r\n        });\r\n\r\n        emit CollectionUpdate(_collection, _creator, _whitelistChecker, _tradingFee, _creatorFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the admin to update minimum and maximum prices for a token (in wei)\r\n     * @param _minimumAskPrice: minimum ask price\r\n     * @param _maximumAskPrice: maximum ask price\r\n     * @dev Callable by admin\r\n     */\r\n    function updateMinimumAndMaximumPrices(uint256 _minimumAskPrice, uint256 _maximumAskPrice) external onlyAdmin {\r\n        require(_minimumAskPrice < _maximumAskPrice, \"Operations: _minimumAskPrice < _maximumAskPrice\");\r\n\r\n        minimumAskPrice = _minimumAskPrice;\r\n        maximumAskPrice = _maximumAskPrice;\r\n\r\n        emit NewMinimumAndMaximumAskPrices(_minimumAskPrice, _maximumAskPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to recover tokens sent to the contract by mistake\r\n     * @param _token: token address\r\n     * @dev Callable by owner\r\n     */\r\n    function recoverFungibleTokens(address _token) external onlyOwner {\r\n        require(_token != WBNB, \"Operations: Cannot recover WBNB\");\r\n        uint256 amountToRecover = IERC20(_token).balanceOf(address(this));\r\n        require(amountToRecover != 0, \"Operations: No token to recover\");\r\n\r\n        IERC20(_token).safeTransfer(address(msg.sender), amountToRecover);\r\n\r\n        emit TokenRecovery(_token, amountToRecover);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to recover NFTs sent to the contract by mistake\r\n     * @param _token: NFT token address\r\n     * @param _tokenId: tokenId\r\n     * @dev Callable by owner\r\n     */\r\n    function recoverNonFungibleToken(address _token, uint256 _tokenId) external onlyOwner nonReentrant {\r\n        require(!_askTokenIds[_token].contains(_tokenId), \"Operations: NFT not recoverable\");\r\n        IERC721(_token).safeTransferFrom(address(this), address(msg.sender), _tokenId);\r\n\r\n        emit NonFungibleTokenRecovery(_token, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Set admin address\r\n     * @dev Only callable by owner\r\n     * @param _adminAddress: address of the admin\r\n     * @param _treasuryAddress: address of the treasury\r\n     */\r\n    function setAdminAndTreasuryAddresses(address _adminAddress, address _treasuryAddress) external onlyOwner {\r\n        require(_adminAddress != address(0), \"Operations: Admin address cannot be zero\");\r\n        require(_treasuryAddress != address(0), \"Operations: Treasury address cannot be zero\");\r\n\r\n        adminAddress = _adminAddress;\r\n        treasuryAddress = _treasuryAddress;\r\n\r\n        emit NewAdminAndTreasuryAddresses(_adminAddress, _treasuryAddress);\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * @notice Check asks for an array of tokenIds in a collection\r\n     * @param collection: address of the collection\r\n     * @param tokenIds: array of tokenId\r\n     */\r\n    function viewAsksByCollectionAndTokenIds(address collection, uint256[] calldata tokenIds)\r\n        external\r\n        view\r\n        returns (bool[] memory statuses, Ask[] memory askInfo)\r\n    {\r\n        uint256 length = tokenIds.length;\r\n\r\n        statuses = new bool[](length);\r\n        askInfo = new Ask[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (_askTokenIds[collection].contains(tokenIds[i])) {\r\n                statuses[i] = true;\r\n            } else {\r\n                statuses[i] = false;\r\n            }\r\n\r\n            askInfo[i] = _askDetails[collection][tokenIds[i]];\r\n        }\r\n\r\n        return (statuses, askInfo);\r\n    }\r\n\r\n    /**\r\n     * @notice View ask orders for a given collection across all sellers\r\n     * @param collection: address of the collection\r\n     * @param cursor: cursor\r\n     * @param size: size of the response\r\n     */\r\n    function viewAsksByCollection(\r\n        address collection,\r\n        uint256 cursor,\r\n        uint256 size\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory tokenIds,\r\n            Ask[] memory askInfo,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 length = size;\r\n\r\n        if (length > _askTokenIds[collection].length() - cursor) {\r\n            length = _askTokenIds[collection].length() - cursor;\r\n        }\r\n\r\n        tokenIds = new uint256[](length);\r\n        askInfo = new Ask[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tokenIds[i] = _askTokenIds[collection].at(cursor + i);\r\n            askInfo[i] = _askDetails[collection][tokenIds[i]];\r\n        }\r\n\r\n        return (tokenIds, askInfo, cursor + length);\r\n    }\r\n\r\n    /**\r\n     * @notice View ask orders for a given collection and a seller\r\n     * @param collection: address of the collection\r\n     * @param seller: address of the seller\r\n     * @param cursor: cursor\r\n     * @param size: size of the response\r\n     */\r\n    function viewAsksByCollectionAndSeller(\r\n        address collection,\r\n        address seller,\r\n        uint256 cursor,\r\n        uint256 size\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory tokenIds,\r\n            Ask[] memory askInfo,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 length = size;\r\n\r\n        if (length > _tokenIdsOfSellerForCollection[seller][collection].length() - cursor) {\r\n            length = _tokenIdsOfSellerForCollection[seller][collection].length() - cursor;\r\n        }\r\n\r\n        tokenIds = new uint256[](length);\r\n        askInfo = new Ask[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tokenIds[i] = _tokenIdsOfSellerForCollection[seller][collection].at(cursor + i);\r\n            askInfo[i] = _askDetails[collection][tokenIds[i]];\r\n        }\r\n\r\n        return (tokenIds, askInfo, cursor + length);\r\n    }\r\n\r\n    /*\r\n     * @notice View addresses and details for all the collections available for trading\r\n     * @param cursor: cursor\r\n     * @param size: size of the response\r\n     */\r\n    function viewCollections(uint256 cursor, uint256 size)\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory collectionAddresses,\r\n            Collection[] memory collectionDetails,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 length = size;\r\n\r\n        if (length > _collectionAddressSet.length() - cursor) {\r\n            length = _collectionAddressSet.length() - cursor;\r\n        }\r\n\r\n        collectionAddresses = new address[](length);\r\n        collectionDetails = new Collection[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            collectionAddresses[i] = _collectionAddressSet.at(cursor + i);\r\n            collectionDetails[i] = _collections[collectionAddresses[i]];\r\n        }\r\n\r\n        return (collectionAddresses, collectionDetails, cursor + length);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate price and associated fees for a collection\r\n     * @param collection: address of the collection\r\n     * @param price: listed price\r\n     */\r\n    function calculatePriceAndFeesForCollection(address collection, uint256 price)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 netPrice,\r\n            uint256 tradingFee,\r\n            uint256 creatorFee\r\n        )\r\n    {\r\n        if (_collections[collection].status != CollectionStatus.Open) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        return (_calculatePriceAndFeesForCollection(collection, price));\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if an array of tokenIds can be listed\r\n     * @param _collection: address of the collection\r\n     * @param _tokenIds: array of tokenIds\r\n     * @dev if collection is not for trading, it returns array of bool with false\r\n     */\r\n    function canTokensBeListed(address _collection, uint256[] calldata _tokenIds)\r\n        external\r\n        view\r\n        returns (bool[] memory listingStatuses)\r\n    {\r\n        listingStatuses = new bool[](_tokenIds.length);\r\n\r\n        if (_collections[_collection].status != CollectionStatus.Open) {\r\n            return listingStatuses;\r\n        }\r\n\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            listingStatuses[i] = _canTokenBeListed(_collection, _tokenIds[i]);\r\n        }\r\n\r\n        return listingStatuses;\r\n    }\r\n\r\n    /**\r\n     * @notice Buy token by matching the price of an existing ask order\r\n     * @param _collection: contract address of the NFT\r\n     * @param _tokenId: tokenId of the NFT purchased\r\n     * @param _price: price (must match the askPrice from the seller)\r\n     * @param _withBNB: whether the token is bought with BNB (true) or WBNB (false)\r\n     */\r\n    function _buyToken(\r\n        address _collection,\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        bool _withBNB\r\n    ) internal {\r\n        require(_collections[_collection].status == CollectionStatus.Open, \"Collection: Not for trading\");\r\n        require(_askTokenIds[_collection].contains(_tokenId), \"Buy: Not for sale\");\r\n\r\n        Ask memory askOrder = _askDetails[_collection][_tokenId];\r\n\r\n        // Front-running protection\r\n        require(_price == askOrder.price, \"Buy: Incorrect price\");\r\n        require(msg.sender != askOrder.seller, \"Buy: Buyer cannot be seller\");\r\n\r\n        // Calculate the net price (collected by seller), trading fee (collected by treasury), creator fee (collected by creator)\r\n        (uint256 netPrice, uint256 tradingFee, uint256 creatorFee) = _calculatePriceAndFeesForCollection(\r\n            _collection,\r\n            _price\r\n        );\r\n        reflectDividend((_price*_reflectionRoyalty)/100);\r\n        reflectMintDividend((_price*_reflectionMintRoyalty)/100);\r\n        \r\n    \r\n\r\n        // Update storage information\r\n        _tokenIdsOfSellerForCollection[askOrder.seller][_collection].remove(_tokenId);\r\n        delete _askDetails[_collection][_tokenId];\r\n        _askTokenIds[_collection].remove(_tokenId);\r\n\r\n        // Transfer WBNB\r\n        IERC20(WBNB).safeTransfer(askOrder.seller, netPrice);\r\n\r\n        // Update pending revenues for treasury/creator (if any!)\r\n        if (creatorFee != 0) {\r\n            pendingRevenue[_collections[_collection].creatorAddress] += creatorFee;\r\n        }\r\n\r\n        // Update trading fee if not equal to 0\r\n        if (tradingFee != 0) {\r\n            pendingRevenue[treasuryAddress] += tradingFee;\r\n        }\r\n\r\n        // Transfer NFT to buyer\r\n        IERC721(_collection).safeTransferFrom(address(this), address(msg.sender), _tokenId);\r\n\r\n        // Emit event\r\n        emit Trade(_collection, _tokenId, askOrder.seller, msg.sender, _price, netPrice, _withBNB);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate price and associated fees for a collection\r\n     * @param _collection: address of the collection\r\n     * @param _askPrice: listed price\r\n     */\r\n    function _calculatePriceAndFeesForCollection(address _collection, uint256 _askPrice)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 netPrice,\r\n            uint256 tradingFee,\r\n            uint256 creatorFee\r\n        )\r\n    {\r\n        \r\n        uint256 reflectionFee = (_askPrice*_reflectionRoyalty)/100;\r\n        uint256 minterFee = (_askPrice*_reflectionMintRoyalty)/100;\r\n    \r\n        tradingFee = (_askPrice * _collections[_collection].tradingFee) / 10000;\r\n        creatorFee = (_askPrice * _collections[_collection].creatorFee) / 10000;\r\n\r\n        netPrice = _askPrice - tradingFee - creatorFee - reflectionFee - minterFee;\r\n\r\n        return (netPrice, tradingFee, creatorFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a token can be listed\r\n     * @param _collection: address of the collection\r\n     * @param _tokenId: tokenId\r\n     */\r\n    function _canTokenBeListed(address _collection, uint256 _tokenId) internal view returns (bool) {\r\n        address whitelistCheckerAddress = _collections[_collection].whitelistChecker;\r\n        return\r\n            (whitelistCheckerAddress == address(0)) ||\r\n            ICollectionWhitelistChecker(whitelistCheckerAddress).canList(_tokenId);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WBNBAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ghostAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumAskPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumAskPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"AddMinterDataForAccounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AskCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askPrice\",\"type\":\"uint256\"}],\"name\":\"AskNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askPrice\",\"type\":\"uint256\"}],\"name\":\"AskUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"CollectionClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistChecker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"}],\"name\":\"CollectionNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistChecker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"}],\"name\":\"CollectionUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"NewAdminAndTreasuryAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumAskPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumAskPrice\",\"type\":\"uint256\"}],\"name\":\"NewMinimumAndMaximumAskPrices\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NonFungibleTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RevenueClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withBNB\",\"type\":\"bool\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TOTAL_MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistChecker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_creatorFee\",\"type\":\"uint256\"}],\"name\":\"addCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mints\",\"type\":\"uint256[]\"}],\"name\":\"addMinterDataForAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buyTokenUsingBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"buyTokenUsingWBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"calculatePriceAndFeesForCollection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"canTokensBeListed\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"listingStatuses\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAskOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPendingRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"closeCollectionForTradingAndListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_askPrice\",\"type\":\"uint256\"}],\"name\":\"createAskOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMintRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minterAddress\",\"type\":\"address\"}],\"name\":\"getMintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getReflectionBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReflectionBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintCount\",\"type\":\"uint256\"}],\"name\":\"getReflectionMintBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumAskPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAskPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"modifyAskOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistChecker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_creatorFee\",\"type\":\"uint256\"}],\"name\":\"modifyCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverFungibleTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"recoverNonFungibleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectToHolders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectToMinters\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionMintBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"name\":\"setAdminAndTreasuryAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumAskPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumAskPrice\",\"type\":\"uint256\"}],\"name\":\"updateMinimumAndMaximumPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"viewAsksByCollection\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct GhostThirdParty.Ask[]\",\"name\":\"askInfo\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"viewAsksByCollectionAndSeller\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct GhostThirdParty.Ask[]\",\"name\":\"askInfo\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"viewAsksByCollectionAndTokenIds\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"statuses\",\"type\":\"bool[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct GhostThirdParty.Ask[]\",\"name\":\"askInfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"viewCollections\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"collectionAddresses\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"enum GhostThirdParty.CollectionStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"whitelistChecker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"}],\"internalType\":\"struct GhostThirdParty.Collection[]\",\"name\":\"collectionDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GhostThirdParty", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a4760e78422672cccd66184a3f87727023d8a7a2000000000000000000000000a4760e78422672cccd66184a3f87727023d8a7a2000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000098f606a4cdde68b9f68732d21fb9ba8b5510ee480000000000000000000000000000000000000000000000000011c37937e0800000000000000000000000000000000000000000000000021e19e0c9bab2400000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8a8dd85bd66ba9c04b5d47897308c6f451b769ab1f63860f2b6c466210679e81"}