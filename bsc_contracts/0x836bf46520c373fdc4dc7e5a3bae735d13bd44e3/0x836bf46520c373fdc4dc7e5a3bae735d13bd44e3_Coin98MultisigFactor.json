{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\ninterface IMultisig {\r\n\r\n    function owners() external view returns (address[] memory addresses, uint256[] memory vPowers);\r\n    function request() external view returns (address destination, uint256 value, bytes memory data);\r\n    function requestProgress() external view returns (uint32 requestId, uint256 timestamp, uint16 currentVote, uint16 requiredVote);\r\n    function voteRequirement() external view returns (uint16 requiredVote, uint16 totalVote);\r\n    function hasVoted(address owner) external view returns (bool voted, uint16 vPower);\r\n    function createRequest(address destination, uint256 value, bytes memory data) external returns (bool);\r\n    function vote() external returns (bool);\r\n    function cancelRequest() external returns (bool);\r\n    function changeOwners(address[] memory nOwners, uint16[] memory vPowers, uint16 vRate) external returns (bool);\r\n\r\n    event Requested(uint256 requestId, address indexed destination, uint256 value, bytes data, uint16 currentVote, uint16 requiredVote);\r\n    event Voted(address owner, uint256 requestId, uint16 currentVote, uint16 requiredVote);\r\n    event Executed(bool status, uint256 requestId, address indexed destination, uint256 value, bytes data);\r\n    event Cancelled(uint256 requestId);\r\n    event OwnersChanged(address[] owners, uint16 requireVote, uint16 totalVote);\r\n    event Deposited(address indexed sender, uint256 value);\r\n}\r\n\r\ncontract Coin98Multisig is IMultisig {\r\n\r\n    address[] private _owners;\r\n    mapping(address => uint16) private _votePowers;\r\n    VoteRequirement private _voteRequirement;\r\n\r\n    uint32 private _requestId;\r\n    Request private _request;\r\n    mapping(address => uint32) private _votes;\r\n    VoteProgress private _voteProgress;\r\n\r\n    /// @dev Initialize wallet, with a list of initial owners\r\n    /// @param owners_ Array of owners's address\r\n    /// @param vPowers_ Array of voting weight of the owners, owner with vPower == 0 will be ignored\r\n    /// @param requiredVote_ Number of votes needed to execute the request\r\n    constructor(address[] memory owners_, uint16[] memory vPowers_, uint16 requiredVote_) {\r\n        _lock = _NOT_ENTERED;\r\n        _changeOwners(owners_, vPowers_, requiredVote_);\r\n    }\r\n\r\n    // Data structure to store information of a request\r\n    struct Request {\r\n        address destination;\r\n        uint256 value;\r\n        bytes data;\r\n    }\r\n\r\n    // Data structure to store information for the vote of current request\r\n    struct VoteProgress {\r\n        uint32 requestId;\r\n        uint16 currentVote;\r\n        uint16 requiredVote;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    // Data structure to store information about voting weight\r\n    struct VoteRequirement {\r\n        uint16 requiredVote;\r\n        uint16 totalVote;\r\n    }\r\n\r\n    modifier selfOnly() {\r\n        require(msg.sender == address(this), \"Coin98MSig: Wallet only\");\r\n        _;\r\n    }\r\n\r\n    modifier isOwner(address owner) {\r\n        require(_votePowers[owner] > 0, \"Coin98MSig: Not an owner\");\r\n        _;\r\n    }\r\n\r\n    fallback() external payable {\r\n        if (msg.value > 0) {\r\n            emit Deposited(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    /// @dev enable wallet to receive ETH\r\n    receive() external payable {\r\n        if (msg.value > 0) {\r\n            emit Deposited(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    /// @dev return list of currents owners and their respective voting weight\r\n    /// @return addresses List of owners's address\r\n    /// @return vPowers List of owner's voting weight\r\n    function owners() external view override returns (address[] memory addresses, uint256[] memory vPowers) {\r\n        uint256[] memory values = new uint256[](_owners.length);\r\n        uint256 i;\r\n        for (i = 0; i < _owners.length; i++) {\r\n            values[i] = (_votePowers[_owners[i]]);\r\n        }\r\n        return (_owners, values);\r\n    }\r\n\r\n    /// @dev Return current request information\r\n    /// @return destination destination address of the recipient to interface with (address/contract...)\r\n    /// @return value value of ETH to send\r\n    /// @return data data data of the function call in ABI encoded format\r\n    function request() external view override returns (address destination, uint256 value, bytes memory data) {\r\n        Request memory req = _request;\r\n        return (req.destination, req.value, req.data);\r\n    }\r\n\r\n    /// @dev Return current number of votes vs required number of votes to execute request\r\n    /// @return requestId ID of current request\r\n    /// @return timestamp Timestamp when the request is created\r\n    /// @return currentVote Number of votes for current request\r\n    /// @return requiredVote Required number of votes to execute current request\r\n    function requestProgress() external view override returns (uint32 requestId, uint256 timestamp, uint16 currentVote, uint16 requiredVote) {\r\n        VoteProgress memory progress = _voteProgress;\r\n        return (progress.requestId, progress.timestamp, progress.currentVote, progress.requiredVote);\r\n    }\r\n\r\n    /// @dev Return required number of votes vs total number of votes of all owners\r\n    /// @return requiredVote Required number of votes to execute request\r\n    /// @return totalVote Total number of votes of all owners\r\n    function voteRequirement() external view override returns (uint16 requiredVote, uint16 totalVote) {\r\n        VoteRequirement memory requirement = _voteRequirement;\r\n        return (requirement.requiredVote, requirement.totalVote);\r\n    }\r\n\r\n    /// @dev Check whether a owner has voted\r\n    /// @return voted user's voting status\r\n    /// @return vPower voting weight of owner\r\n    function hasVoted(address owner) external view override returns (bool voted, uint16 vPower) {\r\n        VoteProgress memory progress = _voteProgress;\r\n        uint16 power = _votePowers[owner];\r\n        if (progress.requestId == 0) {\r\n            return (false, power);\r\n        }\r\n        return (progress.requestId == _votes[owner], power);\r\n    }\r\n\r\n    /// @dev Submit a new request for voting, the owner submitting request will count as voted.\r\n    /// @param destination address of the recipient to interface with (address/contract...)\r\n    /// @param value of ETH to send\r\n    /// @param data data of the function call in ABI encoded format\r\n    function createRequest(address destination, uint256 value, bytes memory data)\r\n        isOwner(msg.sender)\r\n        external override returns (bool) {\r\n        VoteProgress memory progress = _voteProgress;\r\n        require(progress.requestId == 0, \"Coin98MSig: Request pending\");\r\n\r\n        Request memory req;\r\n        req.destination = destination;\r\n        req.value = value;\r\n        req.data = data;\r\n        progress.requestId = _requestId + 1;\r\n        progress.requiredVote = _voteRequirement.requiredVote;\r\n        progress.timestamp = block.timestamp;\r\n        _request = req;\r\n        _requestId = progress.requestId;\r\n        _voteProgress = progress;\r\n        vote();\r\n\r\n        emit Requested(progress.requestId, req.destination, req.value, req.data, progress.currentVote, progress.requiredVote);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Owner vote for the current request. Then execute the request if enough votes\r\n    function vote()\r\n        isOwner(msg.sender)\r\n        nonReentrant()\r\n        public override returns (bool) {\r\n        VoteProgress memory progress = _voteProgress;\r\n        require(progress.requestId > 0, \"Coin98MSig: No pending request\");\r\n        if (_votes[msg.sender] < progress.requestId) {\r\n            _votes[msg.sender] = progress.requestId;\r\n            progress.currentVote += _votePowers[msg.sender];\r\n            _voteProgress = progress;\r\n            emit Voted(msg.sender, progress.requestId, progress.currentVote, progress.requiredVote);\r\n        }\r\n        if (progress.currentVote >= progress.requiredVote) {\r\n            Request memory req = _request;\r\n            (bool success,) = req.destination.call{value: req.value}(req.data);\r\n            if (success) {\r\n                delete _request;\r\n                delete _voteProgress;\r\n                Executed(true, progress.requestId, req.destination, req.value, req.data);\r\n            }\r\n            else {\r\n                Executed(false, progress.requestId, req.destination, req.value, req.data);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Cancel current request. Throw error if request does not exist\r\n    function cancelRequest()\r\n        isOwner(msg.sender)\r\n        external override returns (bool) {\r\n        VoteProgress memory progress = _voteProgress;\r\n        require(progress.requestId > 0, \"Coin98MSig: No pending request\");\r\n        require(block.timestamp - progress.timestamp > 600, \"Coin98MSig: 10 mins not passed\");\r\n\r\n        delete _request;\r\n        delete _voteProgress;\r\n\r\n        emit Cancelled(progress.requestId);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Add/remove/change owner, with their respective voting weight,\r\n    /// and number of votes needed to perform the request\r\n    /// @param nOwners Array of owners' address that need to change\r\n    /// @param vPowers Array of voting weight of the nOwners, vPower == 0 will remove the respective user\r\n    /// @param vRate New number of required votes to perform the request. vRate == 0 will keep the current number of required votes\r\n    function changeOwners(address[] memory nOwners, uint16[] memory vPowers, uint16 vRate)\r\n        selfOnly()\r\n        external override returns (bool) {\r\n        _changeOwners(nOwners, vPowers, vRate);\r\n        return true;\r\n    }\r\n\r\n    function _changeOwners(address[] memory nOwners, uint16[] memory vPowers, uint16 vRate) internal {\r\n        require(nOwners.length == vPowers.length, \"Coin98MSig: Owners and vPowers length mismatch\");\r\n        VoteRequirement memory requirement = _voteRequirement;\r\n        uint256 i;\r\n        for (i = 0; i < nOwners.length; i++) {\r\n            address nOwner = nOwners[i];\r\n            uint16 cPower = _votePowers[nOwner];\r\n            uint16 vPower = vPowers[i];\r\n            require(vPower <= 256, \"Coin98MSig: Invalid vRate\");\r\n            if (cPower > 0) {\r\n                if (vPower == 0) {\r\n                    uint256 j;\r\n                    for(j = 0; j < _owners.length; j++) {\r\n                        if (_owners[j] == nOwner) {\r\n                            _owners[j] = _owners[_owners.length - 1];\r\n                            _owners.pop();\r\n                            delete _votes[nOwner];\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                requirement.totalVote -= cPower;\r\n            }\r\n            else {\r\n                if (vPower > 0) {\r\n                    _owners.push(nOwner);\r\n                }\r\n            }\r\n            _votePowers[nOwner] = vPower;\r\n            requirement.totalVote += vPower;\r\n        }\r\n        if (vRate > 0) {\r\n            requirement.requiredVote = vRate;\r\n        }\r\n        uint256 ownerCount = _owners.length;\r\n        require(requirement.requiredVote > 0, \"Coin98MSig: Invalid vRate\");\r\n        require(requirement.requiredVote <= requirement.totalVote, \"Coin98MSig: Invalid vRate\");\r\n        require(requirement.totalVote <= 4096, \"Coin98MSig: Max weight reached\");\r\n        require(ownerCount > 0, \"Coin98MSig: At least 1 owner\");\r\n        require(ownerCount <= 64, \"Coin98MSig: Max owner reached\");\r\n        _voteRequirement = requirement;\r\n\r\n        OwnersChanged(nOwners, requirement.requiredVote, requirement.totalVote);\r\n    }\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _lastLockTimestamp;\r\n    uint256 private _lock;\r\n\r\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\r\n    /// Calling a `nonReentrant` function from another `nonReentrant`\r\n    /// function is not supported. It is possible to prevent this from happening\r\n    /// by making the `nonReentrant` function external, and make it call a\r\n    /// `private` function that does the actual work.\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        // Add 24-hour timeout to unlock contract in case of deadlock\r\n        require(_lock != _ENTERED || block.timestamp - _lastLockTimestamp > 86400, \"Coin98MSig: Reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _lastLockTimestamp = block.timestamp;\r\n        _lock = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _lock = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract Coin98MultisigFactory {\r\n    event Created(address indexed wallet, address[] owners);\r\n\r\n    /// @dev Create a new multisig wallet\r\n    /// @param owners_ Array of intial owners. If the list is empty, sending adress will be assigned as owner\r\n    /// @param vPowers_ Array of voting weight of the owners, owner with vPower == 0 will be ignored\r\n    /// @param requiredVote_ Number of votes needed to perform the request\r\n    function createMulitSig(address[] memory owners_, uint16[] memory vPowers_, uint16 requiredVote_)\r\n        external returns (Coin98Multisig wallet) {\r\n        wallet = new Coin98Multisig(owners_, vPowers_, requiredVote_);\r\n        emit Created(address(wallet), owners_);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"name\":\"Created\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners_\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"vPowers_\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16\",\"name\":\"requiredVote_\",\"type\":\"uint16\"}],\"name\":\"createMulitSig\",\"outputs\":[{\"internalType\":\"contract Coin98Multisig\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Coin98MultisigFactory", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b7f769c0ce3f2c0c210721724f823be9f97e1d12566752631c367433b4a2580f"}