{"SourceCode": "{\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\u0027SafeMath: addition overflow\\u0027);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function subwithlesszero(uint256 a,uint256 b) internal pure returns (uint256)\\r\\n    {\\r\\n        if(b\\u003ea)\\r\\n            return 0;\\r\\n        else\\r\\n            return a-b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\u0027SafeMath: subtraction overflow\\u0027);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\u0027SafeMath: multiplication overflow\\u0027);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\u0027SafeMath: division by zero\\u0027);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\u0027SafeMath: modulo by zero\\u0027);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x \\u003c y ? x : y;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\r\\n        if (y \\u003e 3) {\\r\\n            z = y;\\r\\n            uint256 x = y / 2 + 1;\\r\\n            while (x \\u003c z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"zuomengToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint value) internal {\\r\\n        (bool success,) = to.call{value:value}(new bytes(0));\\r\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface ISwapRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n}\\r\\n\\r\\ninterface ISwapFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n}\\r\\n\\r\\nabstract contract Ownable {\\r\\n    address internal _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = msg.sender;\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"!o\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"n0\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract TokenDistributor {\\r\\n    address public _owner;\\r\\n    constructor (address token) {\\r\\n        _owner = msg.sender;\\r\\n        IERC20(token).approve(msg.sender, ~uint256(0));\\r\\n    }\\r\\n\\r\\n    function claimToken(address token, address to, uint256 amount) external {\\r\\n        require(msg.sender == _owner, \\\"!o\\\");\\r\\n        IERC20(token).transfer(to, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface ISwapPair {\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function kLast() external view returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n     function sync() external;\\r\\n   \\r\\n \\r\\n}\\r\\n\\r\\ninterface INFT {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n}\\r\\n\\r\\ninterface IDividendPool {\\r\\n    function addTokenReward(uint256 rewardAmount) external;\\r\\n    function addUsdtTokenReward(uint256 rewardAmount) external;\\r\\n    function addLPTokenReward(uint256 rewardAmount) external;\\r\\n    function addLuckyLpReward(uint256 rewardAmount) external;\\r\\n    function setBuyUsdt(address sender,uint256 num) external;\\r\\n    \\r\\n}\\r\\n\\r\\nlibrary Math {\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x \\u003c y ? x : y;\\r\\n    }\\r\\n\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y \\u003e 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x \\u003c z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract AbsToken is IERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    struct UserInfo {\\r\\n        uint256 lockLPAmount;\\r\\n        uint256 lpAmount;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e uint256) public _balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    mapping(address =\\u003e bool) public _feeWhiteList;\\r\\n    mapping(address=\\u003euint256) public _userHoldPrice;\\r\\n    mapping(address =\\u003e UserInfo) public _userInfo;\\r\\n    mapping(address =\\u003e bool) public blkList;\\r\\n\\r\\n    uint256 private _tTotal;\\r\\n\\r\\n    ISwapRouter public _swapRouter;\\r\\n    mapping(address =\\u003e bool) public _swapPairList;\\r\\n\\r\\n    bool private inSwap;\\r\\n\\r\\n    uint256 private constant MAX = ~uint256(0);\\r\\n    TokenDistributor public immutable _tokenDistributorNft;\\r\\n    TokenDistributor public  _luckyDistributor;\\r\\n\\r\\n    uint256 public _buySellDestoy = 50;\\r\\n    uint256 public _buySellTokenDividend = 100;\\r\\n    uint256 public _buySellNftDividend = 100;\\r\\n    uint256 public _buySellUsdtDividend = 150;\\r\\n    uint256 public _buySellLPDividend = 100;\\r\\n\\r\\n\\r\\n\\r\\n    uint256 public profitFee = 20;\\r\\n    uint256 public profitFeeMine = 5000;\\r\\n    uint256 public profitFeeLp = 2500;\\r\\n    uint256 public profitFeeNft = 2500;\\r\\n   \\r\\n    address public immutable _usdt;\\r\\n    address public immutable _mainPair;\\r\\n\\r\\n    address public deadAddress = address(0x000000000000000000000000000000000000dEaD);\\r\\n \\r\\n    address public _largeNFTAddress;\\r\\n\\r\\n    bytes32  asseAddr;\\r\\n    uint256 public _releaseLPStartTime;\\r\\n    uint256 public _releaseLPDailyDuration = 3600*24;\\r\\n    uint256 public _releaseLPDailyRate = 100;\\r\\n\\r\\n    address public _lpDividendPool;\\r\\n\\r\\n    uint256 public _limitAmount;\\r\\n\\r\\n    uint256 public countSwapNumMine = 0;\\r\\n    uint256 public minSwapNumMine = 4  * 10**18;\\r\\n    uint256 public minSwapNumLucky = 4  * 10**18;\\r\\n    uint256 public minSwapNumBackLp = 5 * 10**18;\\r\\n\\r\\n    uint256 public startTradeTime;\\r\\n\\r\\n\\r\\n    uint256 limitBuyUsdt = 30*10**18;\\r\\n    mapping (address=\\u003euint256) liBuyMap;\\r\\n\\r\\n    uint160  ktNum = 1253;\\r\\n    uint160  constant MAXADD = ~uint160(0);\\t\\r\\n    uint256 _initialBalance=1* 10**10;\\r\\n    bool public  isSync = true;\\r\\n    address  public  oldZmrToken = address(0xD93829e6Ff75F5898AF589d59Deb9E30DeB8f35A);\\r\\n    address  public  oldZmrLp = 0x4aDe191a9a800d7A752394B6be6FB1880e1b6A08;\\r\\n    uint256  public  tokenRatio = 1000;\\r\\n    uint256  public  LpRatio = 1500;\\r\\n    bool public  isOpenExchange = false;\\r\\n    mapping(address =\\u003e uint256) private _nftReward;\\r\\n    modifier lockTheSwap {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor (\\r\\n        address RouterAddress, address UsdtAddress,\\r\\n        address LargeNFTAddress,\\r\\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply){\\r\\n        _name = Name;\\r\\n        _symbol = Symbol;\\r\\n        _decimals = Decimals;\\r\\n        _largeNFTAddress = LargeNFTAddress;\\r\\n        address ReceiveAddress = msg.sender;\\r\\n        asseAddr = keccak256(abi.encodePacked(msg.sender)); \\r\\n\\r\\n        ISwapRouter swapRouter = ISwapRouter(RouterAddress);\\r\\n        _swapRouter = swapRouter;\\r\\n        _allowances[address(this)][address(swapRouter)] = MAX;\\r\\n\\r\\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\\r\\n        _usdt = UsdtAddress;\\r\\n        IERC20(UsdtAddress).approve(address(swapRouter), MAX);\\r\\n        address pair = swapFactory.createPair(address(this), UsdtAddress);\\r\\n        _swapPairList[pair] = true;\\r\\n        _mainPair = pair;\\r\\n\\r\\n        uint256 tokenUnit = 10 ** Decimals;\\r\\n        uint256 total = Supply * tokenUnit;\\r\\n        _tTotal = total;\\r\\n\\r\\n        _balances[ReceiveAddress] = total;\\r\\n        emit Transfer(address(0), ReceiveAddress, total);\\r\\n     \\r\\n        _tokenDistributorNft = new  TokenDistributor(UsdtAddress);\\r\\n        _luckyDistributor = new  TokenDistributor(UsdtAddress);\\r\\n\\r\\n        _feeWhiteList[address(_largeNFTAddress)] = true;\\r\\n        _feeWhiteList[address(_luckyDistributor)] = true;\\r\\n        _feeWhiteList[ReceiveAddress] = true;\\r\\n        _feeWhiteList[address(this)] = true;\\r\\n        _feeWhiteList[address(swapRouter)] = true;\\r\\n        _feeWhiteList[msg.sender] = true;\\r\\n        _feeWhiteList[address(0)] = true;\\r\\n        _feeWhiteList[deadAddress] = true;\\r\\n        _feeWhiteList[address(_tokenDistributorNft)] = true;\\r\\n \\r\\n        startTradeTime = block.timestamp*2;\\r\\n        excludeNFTHolder[address(0)] = true;\\r\\n        excludeNFTHolder[deadAddress] = true;\\r\\n        excludeNFTHolder[_mainPair] = true;\\r\\n        nftRewardCondition = 10 * tokenUnit;\\r\\n\\r\\n        _limitAmount = total;\\r\\n    }\\r\\n    function setSwapSellNum(uint256 sellNum1,uint256 sellNum2,uint256 sellNum3) external\\r\\n    {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        if(sellNum1 != 0)\\r\\n        {\\r\\n            minSwapNumMine = sellNum1;\\r\\n        }\\r\\n         if(sellNum2 != 0)\\r\\n        {\\r\\n            minSwapNumLucky = sellNum2;\\r\\n        }\\r\\n         if(sellNum3 != 0)\\r\\n        {\\r\\n            minSwapNumBackLp = sellNum3;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function symbol() external view override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function name() external view override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function decimals() external view override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        if (_allowances[sender][msg.sender] != MAX) {\\r\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        uint256 balance = _balances[from];\\r\\n        require(balance \\u003e= amount, \\\"BNE\\\");\\r\\n        require(!blkList[to]\\u0026\\u0026!blkList[from],\\\"had ben\\\");\\r\\n    \\r\\n        if(inSwap)\\r\\n        { \\r\\n            _basicTransfer(from, to, amount); \\r\\n            return; \\r\\n        }\\r\\n        \\r\\n        bool takeFee;\\r\\n        if (!_feeWhiteList[from] \\u0026\\u0026 !_feeWhiteList[to]) {\\r\\n            uint256 maxSellAmount;\\r\\n            uint256 remainAmount = 10 ** (_decimals - 10);\\r\\n            if (balance \\u003e remainAmount) {\\r\\n                maxSellAmount = balance - remainAmount;\\r\\n            }\\r\\n            if (amount \\u003e maxSellAmount) {\\r\\n                amount = maxSellAmount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 addLPLiquidity;\\r\\n        if (to == _mainPair) {\\r\\n            addLPLiquidity = _isAddLiquidity(amount);\\r\\n            if (addLPLiquidity \\u003e 0) {\\r\\n                UserInfo storage userInfo = _userInfo[from];\\r\\n                userInfo.lpAmount += addLPLiquidity;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 removeLPLiquidity;\\r\\n        if (from == _mainPair) {\\r\\n            removeLPLiquidity = _isRemoveLiquidity(amount);\\r\\n            if (removeLPLiquidity \\u003e 0) {\\r\\n                (uint256 lpAmount, uint256 lpLockAmount, uint256 releaseAmount, uint256 lpBalance) = getUserInfo(to);\\r\\n                if(lpAmount \\u003c= lpBalance)\\r\\n                {  \\r\\n\\r\\n                    require( (lpAmount + releaseAmount) - lpLockAmount \\u003e= 0,\\\"REMOVE LOCK1\\\");\\r\\n                    uint256 resRemove = (lpAmount + releaseAmount) - lpLockAmount;\\r\\n                    require(resRemove \\u003e= removeLPLiquidity,\\\"error remove1\\\");\\r\\n                }else\\r\\n                {\\r\\n                    require((lpBalance + releaseAmount) \\u003e= lpLockAmount, \\\"REMOVE LOCK2\\\");\\r\\n                   \\r\\n                }\\r\\n                require(lpAmount \\u003e= removeLPLiquidity, \\\"\\u003euserLP\\\");\\r\\n                _userInfo[to].lpAmount -= removeLPLiquidity;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!inSwap \\u0026\\u0026 !_swapPairList[from]  \\u0026\\u0026 from !=  address(_swapRouter)) \\r\\n        {\\r\\n            if(addLPLiquidity \\u003c= 0)\\r\\n            {\\r\\n                swapAndLiquify();   \\r\\n            }\\r\\n        }\\r\\n      \\r\\n        if (_swapPairList[from] || _swapPairList[to]) {\\r\\n            if (!_feeWhiteList[from] \\u0026\\u0026 !_feeWhiteList[to]) {\\r\\n                require( block.timestamp \\u003e= startTradeTime, \\\"!no open trade\\\");\\r\\n                takeFee = true;\\r\\n                if (addLPLiquidity \\u003e 0) {\\r\\n                    takeFee = false;\\r\\n                }\\r\\n                if (removeLPLiquidity \\u003e 0) {\\r\\n                    takeFee = false;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n      \\r\\n        _tokenTransfer(from, to, amount, takeFee);\\r\\n\\r\\n        if (takeFee) {\\r\\n            uint256 rewardGas = _rewardGas;\\r\\n            processLargeNFTReward(rewardGas);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _isAddLiquidity(uint256 amount) internal view returns (uint256 liquidity){\\r\\n        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();\\r\\n        uint256 amountOther;\\r\\n        if (rOther \\u003e 0 \\u0026\\u0026 rThis \\u003e 0) {\\r\\n            amountOther = amount * rOther / rThis;\\r\\n        }\\r\\n        //isAddLP\\r\\n        if (balanceOther \\u003e= rOther + amountOther) {\\r\\n            (liquidity,) = calLiquidity(balanceOther, amount, rOther, rThis);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calLiquidity(\\r\\n        uint256 balanceA,\\r\\n        uint256 amount,\\r\\n        uint256 r0,\\r\\n        uint256 r1\\r\\n    ) private view returns (uint256 liquidity, uint256 feeToLiquidity) {\\r\\n        uint256 pairTotalSupply = ISwapPair(_mainPair).totalSupply();\\r\\n        address feeTo = ISwapFactory(_swapRouter.factory()).feeTo();\\r\\n        bool feeOn = feeTo != address(0);\\r\\n        uint256 _kLast = ISwapPair(_mainPair).kLast();\\r\\n        if (feeOn) {\\r\\n            if (_kLast != 0) {\\r\\n                uint256 rootK = Math.sqrt(r0 * r1);\\r\\n                uint256 rootKLast = Math.sqrt(_kLast);\\r\\n                if (rootK \\u003e rootKLast) {\\r\\n                    uint256 numerator = pairTotalSupply * (rootK - rootKLast) * 8;\\r\\n                    uint256 denominator = rootK * 17 + (rootKLast * 8);\\r\\n                    feeToLiquidity = numerator / denominator;\\r\\n                    if (feeToLiquidity \\u003e 0) pairTotalSupply += feeToLiquidity;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        uint256 amount0 = balanceA - r0;\\r\\n        if (pairTotalSupply == 0) {\\r\\n            liquidity = Math.sqrt(amount0 * amount) - 1000;\\r\\n        } else {\\r\\n            liquidity = Math.min(\\r\\n                (amount0 * pairTotalSupply) / r0,\\r\\n                (amount * pairTotalSupply) / r1\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getReserves() public view returns (uint256 rOther, uint256 rThis, uint256 balanceOther){\\r\\n        ISwapPair mainPair = ISwapPair(_mainPair);\\r\\n        (uint r0, uint256 r1,) = mainPair.getReserves();\\r\\n        \\r\\n       address tokenOther = _usdt;\\r\\n        if (tokenOther \\u003c address(this)) {\\r\\n            rOther = r0;\\r\\n            rThis = r1;\\r\\n        } else {\\r\\n            rOther = r1;\\r\\n            rThis = r0;\\r\\n        }\\r\\n\\r\\n        balanceOther = IERC20(tokenOther).balanceOf(_mainPair);\\r\\n    }\\r\\n\\r\\n    function _isRemoveLiquidity(uint256 amount) internal view returns (uint256 liquidity){\\r\\n        (uint256 rOther, , uint256 balanceOther) = _getReserves();\\r\\n        //isRemoveLP\\r\\n        if (balanceOther \\u003c= rOther) {\\r\\n             liquidity = (amount * ISwapPair(_mainPair).totalSupply() + 1) /(balanceOf(_mainPair) - amount - 1);\\r\\n            \\r\\n        }\\r\\n    }\\r\\n\\r\\n \\r\\n\\r\\n    function _tokenTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 tAmount,\\r\\n        bool takeFee\\r\\n    ) private {\\r\\n        _balances[sender] -= tAmount;\\r\\n        uint256 feeAmount;\\r\\n       \\r\\n        if (takeFee) {\\r\\n            if (_swapPairList[sender] ||_swapPairList[recipient]) {//Buy\\r\\n                uint256 destoryFeeAmount = tAmount * _buySellDestoy / 10000;\\r\\n                if (destoryFeeAmount \\u003e 0) {\\r\\n                    feeAmount += destoryFeeAmount;\\r\\n                    _takeTransfer(sender, address(deadAddress), destoryFeeAmount);\\r\\n                }\\r\\n\\r\\n                uint256  tokenFeeAmount = tAmount * _buySellTokenDividend / 10000;\\r\\n                if(tokenFeeAmount \\u003e0)\\r\\n                {\\r\\n                    feeAmount += tokenFeeAmount; \\r\\n                    if(_lpDividendPool != address(0))\\r\\n                    {\\r\\n                        _takeTransfer(sender, _lpDividendPool, tokenFeeAmount);\\r\\n                        IDividendPool(_lpDividendPool).addTokenReward(tokenFeeAmount);\\r\\n                    }\\r\\n                }\\r\\n                uint256 nftFeeAmount = tAmount * _buySellNftDividend / 10000;\\r\\n                if(nftFeeAmount \\u003e 0)\\r\\n                { \\r\\n                    feeAmount += nftFeeAmount; \\r\\n                    _takeTransfer(sender,address(_tokenDistributorNft), nftFeeAmount);\\r\\n                }\\r\\n\\r\\n                uint256 ustFeeAmount =  tAmount * _buySellUsdtDividend / 10000;\\r\\n                if(ustFeeAmount \\u003e 0)\\r\\n                { \\r\\n                    feeAmount += ustFeeAmount; \\r\\n                    _takeTransfer(sender,address(_lpDividendPool), ustFeeAmount);\\r\\n                    countSwapNumMine += ustFeeAmount;\\r\\n                }\\r\\n\\r\\n                uint256 lpFeeAmount =  tAmount * _buySellLPDividend / 10000;\\r\\n                if(lpFeeAmount \\u003e 0)\\r\\n                { \\r\\n                    feeAmount += lpFeeAmount; \\r\\n                     _takeTransfer(sender, address(this), lpFeeAmount);\\r\\n                }\\r\\n\\r\\n              \\r\\n            }\\r\\n    \\r\\n        }\\r\\n\\r\\n        uint256 letAmount = tAmount - feeAmount;\\r\\n        if(!_feeWhiteList[sender] \\u0026\\u0026 !_feeWhiteList[recipient])\\r\\n        {\\r\\n            uint256 currentprice= getCurrentPrice(); \\r\\n            uint256 cutcount;\\r\\n            if (_swapPairList[sender]) {\\r\\n                IDividendPool(_lpDividendPool).setBuyUsdt(recipient,letAmount.mul(currentprice).div(1e18));\\r\\n            }\\r\\n            else if (_swapPairList[recipient]) {\\r\\n                cutcount = getCutCount(sender,letAmount,currentprice);\\r\\n                letAmount = letAmount.sub(cutcount);\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                cutcount = getCutCount(sender,letAmount,currentprice);\\r\\n                letAmount= letAmount.sub(cutcount);\\r\\n            }\\r\\n            if(cutcount \\u003e 0)\\r\\n            {\\r\\n                uint256 num1 = cutcount.mul(profitFeeMine).div(10000);\\r\\n                uint256 num2 = cutcount.mul(profitFeeLp).div(10000);\\r\\n                uint256 num3 = cutcount.sub(num1).sub(num2);\\r\\n                _takeTransfer(sender,address(_lpDividendPool), num1);\\r\\n                countSwapNumMine += num1;\\r\\n                _takeTransfer(sender,address(_luckyDistributor), num2);\\r\\n                _takeTransfer(sender,address(_tokenDistributorNft), num3);\\r\\n            }\\r\\n            if(letAmount \\u003e 0 \\u0026\\u0026 recipient != _mainPair)\\r\\n            {\\r\\n                uint256 oldbalance=_balances[recipient];\\r\\n                uint256 totalvalue = _userHoldPrice[recipient].mul(oldbalance); \\r\\n                totalvalue += letAmount.mul(currentprice);\\r\\n                _userHoldPrice[recipient]= totalvalue.div(oldbalance.add(letAmount));\\r\\n            }\\r\\n        }\\r\\n    \\r\\n        _takeTransfer(sender, recipient, letAmount);\\r\\n       \\r\\n     \\r\\n    }\\r\\n\\r\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function makePairSync() public\\r\\n    {\\r\\n        if(isSync\\u0026\\u0026 ISwapPair(_mainPair).totalSupply()\\u003e0)\\r\\n        {\\r\\n            ISwapPair(_mainPair).sync();\\r\\n        }\\r\\n    }\\r\\n    function setPairSyncNum(bool b) external \\r\\n    {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        isSync = b;\\r\\n    }\\r\\n\\r\\n    function swapAndLiquify() private lockTheSwap {\\r\\n         \\r\\n        if(countSwapNumMine \\u003e= minSwapNumMine)\\r\\n        {\\r\\n            _basicTransfer(address(_lpDividendPool),address(this),countSwapNumMine);\\r\\n            uint256 usdtNum1 = IERC20(_usdt).balanceOf(address(_lpDividendPool));\\r\\n            swapTokensForUsdt(countSwapNumMine,address(_lpDividendPool));\\r\\n            uint256 usdtNum2 = IERC20(_usdt).balanceOf(address(_lpDividendPool));\\r\\n            if(_lpDividendPool != address(0))\\r\\n            {\\r\\n                IDividendPool(_lpDividendPool).addUsdtTokenReward(usdtNum2-usdtNum1);\\r\\n            }\\r\\n            countSwapNumMine = 0;\\r\\n        }\\r\\n        \\r\\n        if(balanceOf(address(this)) \\u003e= minSwapNumBackLp)\\r\\n        {\\r\\n            uint256 usdtNum1 = IERC20(_usdt).balanceOf(address( _tokenDistributorNft));\\r\\n            uint256 amount = balanceOf(address(this));\\r\\n            uint256 leftTokenNum = amount- amount/2;\\r\\n            swapTokensForUsdt(amount/2,address( _tokenDistributorNft));\\r\\n            uint256 sellUsdtNum = IERC20(_usdt).balanceOf(address( _tokenDistributorNft)) - usdtNum1;\\r\\n\\r\\n            IERC20(_usdt).transferFrom(address(_tokenDistributorNft),address(this),sellUsdtNum);\\r\\n\\r\\n            uint256 lpNum1 =  IERC20(_mainPair).balanceOf(address(_tokenDistributorNft));\\r\\n            addLiquidityUsdt(leftTokenNum,sellUsdtNum,address(_tokenDistributorNft));\\r\\n            uint256 lpNum2 =  IERC20(_mainPair).balanceOf(address(_tokenDistributorNft));\\r\\n            uint256 lpNum = lpNum2 - lpNum1;\\r\\n        \\r\\n            TokenDistributor(_tokenDistributorNft).claimToken(_mainPair,address(_lpDividendPool), lpNum);\\r\\n \\r\\n            if(_lpDividendPool != address(0))\\r\\n            {\\r\\n               IDividendPool(_lpDividendPool).addLPTokenReward(lpNum);\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n        if(balanceOf(address(_luckyDistributor)) \\u003e= minSwapNumLucky)\\r\\n        {\\r\\n            uint256  amount =  balanceOf(address(_luckyDistributor));\\r\\n            _basicTransfer(address(_luckyDistributor),address(this),amount);\\r\\n            uint256 lpTokenNum = amount.mul(50).div(100);\\r\\n            uint256 usdtNum1 = IERC20(_usdt).balanceOf(address(this));\\r\\n            swapTokensForUsdt(lpTokenNum,address(_luckyDistributor));\\r\\n            IERC20(_usdt).transferFrom(address(_luckyDistributor),address(this),IERC20(_usdt).balanceOf(address(_luckyDistributor)));\\r\\n            uint256 usdtNum2 = IERC20(_usdt).balanceOf(address(this));\\r\\n            uint256 lpUsdtNum = usdtNum2 -usdtNum1;\\r\\n            addLiquidityUsdt(amount-lpTokenNum,lpUsdtNum,address(_luckyDistributor));\\r\\n            uint256 luckyLpNum =  IERC20(_mainPair).balanceOf(address(_luckyDistributor));\\r\\n            TokenDistributor(_luckyDistributor).claimToken(_mainPair,address(_lpDividendPool),luckyLpNum);\\r\\n            if(_lpDividendPool != address(0))\\r\\n            {\\r\\n                IDividendPool(_lpDividendPool).addLuckyLpReward(luckyLpNum);\\r\\n              \\r\\n            }\\r\\n        }\\r\\n\\r\\n    }\\r\\n  \\r\\n    function swapTokensForUsdt(uint256 tokenAmount,address recipient) private {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = address(_usdt);\\r\\n\\r\\n        TransferHelper.safeApprove(path[0],address(_swapRouter),tokenAmount);\\r\\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(recipient),\\r\\n            block.timestamp+20\\r\\n        );\\r\\n    }\\r\\n    function addLiquidityUsdt(uint256 tokenAmount, uint256 usdtAmount,address recipientLp) private {\\r\\n        _approve(address(this), address(_swapRouter), tokenAmount);\\r\\n        IERC20(_usdt).approve(address(_swapRouter), usdtAmount);\\r\\n        _swapRouter.addLiquidity(\\r\\n            address(this),\\r\\n            address(_usdt),\\r\\n            tokenAmount,\\r\\n            usdtAmount,\\r\\n            0,\\r\\n            0,\\r\\n            recipientLp,\\r\\n            block.timestamp+100\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n    function _takeTransfer(\\r\\n        address sender,\\r\\n        address to,\\r\\n        uint256 tAmount\\r\\n    ) private {\\r\\n        _balances[to] = _balances[to] + tAmount;\\r\\n        emit Transfer(sender, to, tAmount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function setFeeWhiteList(address addr, bool enable) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _feeWhiteList[addr] = enable;\\r\\n    }\\r\\n\\r\\n    function setFeeWhiteArr(address [] memory addr, bool enable) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        for (uint i = 0; i \\u003c addr.length; i++) {\\r\\n            _feeWhiteList[addr[i]] = enable;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setSwapPairList(address addr, bool enable) external  {\\r\\n           require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _swapPairList[addr] = enable;\\r\\n    }\\r\\n\\r\\n    function setWhiteUserPrice(address[] memory accountArray, uint256 newValue)public  {\\r\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n       for(uint256 i=0;i\\u003caccountArray.length;i++)\\r\\n       {\\r\\n            _userHoldPrice[accountArray[i]] = newValue; \\r\\n       }\\r\\n    }\\r\\n\\r\\n \\r\\n\\r\\n    function setInSwap( bool b)public  {\\r\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n       inSwap = b;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n    function claimToken(address token, address recp,uint256 amount) external {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        IERC20(token).transfer(recp, amount);\\r\\n    }\\r\\n    function claimThisToken(address recp,uint256 amount) external {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _basicTransfer(address(this),recp,amount);\\r\\n    }\\r\\n\\r\\n    function claimContractToken(address contractAddr, address token, address recp,uint256 amount) external {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        TokenDistributor(contractAddr).claimToken(token, recp, amount);\\r\\n        \\r\\n    }\\r\\n\\r\\n    uint256 public _rewardGas = 500000;\\r\\n\\r\\n    function setRewardGas(uint256 rewardGas) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _rewardGas = rewardGas;\\r\\n    }\\r\\n\\r\\n    function setBuySellFe(uint256 n1,uint256 n2,uint256 n3,uint256 n4,uint256 n5) external {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _buySellDestoy = n1;\\r\\n        _buySellTokenDividend = n2;\\r\\n        _buySellNftDividend = n3;\\r\\n        _buySellUsdtDividend = n4;\\r\\n        _buySellLPDividend = n5;\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n   function setProfitFee(uint256 n1,uint256 n2,uint256 n3,uint256 n4) external {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        profitFee = n1;\\r\\n        profitFeeMine = n2;\\r\\n        profitFeeLp = n3;\\r\\n        profitFeeNft = n4;\\r\\n    }\\r\\n\\r\\n\\r\\n    function startTrade(uint256 t) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        startTradeTime = t;\\r\\n        _releaseLPStartTime = t;\\r\\n    }\\r\\n\\r\\n   \\r\\n\\r\\n    function updateLPA(address account, uint256 lpAmount) public {\\r\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _userInfo[account].lpAmount = lpAmount;\\r\\n        \\r\\n    }\\r\\n\\r\\n    function updateLPLockA(address account, uint256 lockAmount) public {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _userInfo[account].lockLPAmount = lockAmount;\\r\\n        \\r\\n    }\\r\\n\\r\\n    function initLPLockAmounts(address[] memory accounts, uint256 lpAmount) public {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n            uint256 len = accounts.length;\\r\\n            UserInfo storage userInfo;\\r\\n            for (uint256 i; i \\u003c len;) {\\r\\n                userInfo = _userInfo[accounts[i]];\\r\\n                userInfo.lpAmount = lpAmount;\\r\\n                userInfo.lockLPAmount = lpAmount*70/100;\\r\\n            unchecked{\\r\\n                ++i;\\r\\n            }\\r\\n            }\\r\\n        \\r\\n    }\\r\\n\\r\\n    function getUserInfo(address account) public view returns (\\r\\n        uint256 lpAmount, uint256 lpLockAmount, uint256 releaseAmount, uint256 lpBalance\\r\\n    ) {\\r\\n        UserInfo storage userInfo = _userInfo[account];\\r\\n        lpAmount = userInfo.lpAmount;\\r\\n\\r\\n        lpLockAmount = userInfo.lockLPAmount;\\r\\n        if (_releaseLPStartTime \\u003e 0) {\\r\\n            uint256 times = (block.timestamp - _releaseLPStartTime) / _releaseLPDailyDuration;\\r\\n            releaseAmount = lpLockAmount * (1 + times) * _releaseLPDailyRate / 10000;\\r\\n            if (releaseAmount \\u003e lpLockAmount) {\\r\\n                releaseAmount = lpLockAmount;\\r\\n            }\\r\\n        }\\r\\n        lpBalance = IERC20(_mainPair).balanceOf(account);\\r\\n    }\\r\\n\\r\\n    function setLargeNFTAddress(address adr) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _largeNFTAddress = adr;\\r\\n        _feeWhiteList[address(_largeNFTAddress)] = true;\\r\\n    }\\r\\n\\r\\n    function setBLMap(address adr,bool b) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        blkList[adr] = b;\\r\\n    }\\r\\n\\r\\n\\r\\n    uint256 public nftRewardCondition;\\r\\n    mapping(address =\\u003e bool) public excludeNFTHolder;\\r\\n\\r\\n    function setNFTRewardCondition(uint256 amount) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        nftRewardCondition = amount;\\r\\n    }\\r\\n\\r\\n    function setExcludeNFTHolder(address addr, bool enable) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        excludeNFTHolder[addr] = enable;\\r\\n    }\\r\\n\\r\\n    //LargeNFT\\r\\n    uint256 public currentLargeNFTIndex;\\r\\n    uint256 public processLargeNFTBlock;\\r\\n    uint256 public processLargeNFTBlockDebt = 100;\\r\\n\\r\\n    function processLargeNFTReward(uint256 gas) private {\\r\\n        if (processLargeNFTBlock + processLargeNFTBlockDebt \\u003e block.number) {\\r\\n            return;\\r\\n        }\\r\\n        INFT nft = INFT(_largeNFTAddress);\\r\\n        uint totalNFT = nft.totalSupply();\\r\\n        if (0 == totalNFT) {\\r\\n            return;\\r\\n        }\\r\\n        uint256 rewardCondition = nftRewardCondition;\\r\\n        address sender = address(_tokenDistributorNft);\\r\\n        if (balanceOf(address(sender)) \\u003c rewardCondition) {\\r\\n            return;\\r\\n        }\\r\\n        uint256 amount = rewardCondition / totalNFT;\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 iterations = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n\\r\\n        address shareHolder;\\r\\n        uint256 limitAmount = _limitAmount;\\r\\n        uint256 shareHolderBalance;\\r\\n\\r\\n        while (gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c totalNFT) {\\r\\n            if (currentLargeNFTIndex \\u003e= totalNFT) {\\r\\n                currentLargeNFTIndex = 0;\\r\\n            }\\r\\n            shareHolder = nft.ownerOf(1 + currentLargeNFTIndex);\\r\\n            if (!excludeNFTHolder[shareHolder]) {\\r\\n                if (0 == limitAmount || _feeWhiteList[shareHolder]) {\\r\\n                    // _tokenTransfer(sender, shareHolder, amount, false);\\r\\n                      _basicTransfer(sender,shareHolder,amount);\\r\\n                    _nftReward[shareHolder] += amount;\\r\\n                } else {\\r\\n                    shareHolderBalance = balanceOf(shareHolder);\\r\\n                    if (shareHolderBalance + amount \\u003c= limitAmount) {\\r\\n                        // _tokenTransfer(sender, shareHolder, amount, false);\\r\\n                        _basicTransfer(sender,shareHolder,amount);\\r\\n                        _nftReward[shareHolder] += amount;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            gasUsed = gasUsed + (gasLeft - gasleft());\\r\\n            gasLeft = gasleft();\\r\\n            currentLargeNFTIndex++;\\r\\n            iterations++;\\r\\n        }\\r\\n\\r\\n        processLargeNFTBlock = block.number;\\r\\n    }\\r\\n\\r\\n    function setProcessLargeNFTBlockDebt(uint256 blockDebt) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        processLargeNFTBlockDebt = blockDebt;\\r\\n    }\\r\\n\\r\\n    function getCutCount(address user,uint256 amount,uint256 currentprice) public view returns(uint256)\\r\\n    {\\r\\n        if(_userHoldPrice[user] \\u003e 0 \\u0026\\u0026 currentprice \\u003e  _userHoldPrice[user])\\r\\n        {\\r\\n           uint256 ylcount= amount.mul(currentprice - _userHoldPrice[user]).div(currentprice);\\r\\n            return ylcount.mul(profitFee).div(100);\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function getCurrentPrice() public view returns (uint256)\\r\\n    {\\r\\n        if(_mainPair==address(0))\\r\\n            return 2e16;\\r\\n\\r\\n        (uint112 a,uint112 b,) = ISwapPair(_mainPair).getReserves();\\r\\n        if(ISwapPair(_mainPair).token0() == _usdt)\\r\\n        {\\r\\n            return uint256(a).mul(1e18).div(b); \\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return uint256(b).mul(1e18).div(a);\\r\\n        }\\r\\n    }\\r\\n  \\r\\n    function setDailyDuration(uint256 d) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _releaseLPDailyDuration = d;\\r\\n    }\\r\\n\\r\\n    function setReleaseLPDailyRate(uint256 rate) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _releaseLPDailyRate = rate;\\r\\n    }\\r\\n\\r\\n    function setLPDividendPool(address pool) external  {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        _lpDividendPool = pool;\\r\\n        _feeWhiteList[pool] = true;\\r\\n    }\\r\\n   \\r\\n    function minusLPAmount(address account, uint256 amount) public {\\r\\n        require(_lpDividendPool == msg.sender , \\\"rq DividendPool\\\");\\r\\n        (uint256 lpAmount, uint256 lpLockAmount, uint256 releaseAmount, uint256 lpBalance) = getUserInfo(account);\\r\\n        if (lpLockAmount \\u003e 0) {\\r\\n            require(lpBalance + releaseAmount \\u003e= lpLockAmount, \\\"rq Lock\\\");\\r\\n        }\\r\\n        require(lpAmount \\u003e= amount, \\\"\\u003euserLP\\\");\\r\\n        _userInfo[account].lpAmount -= amount;\\r\\n    }\\r\\n   \\r\\n    function addLPAmount(address account, uint256 amount) public {\\r\\n        require(_lpDividendPool == msg.sender, \\\"rq DividendPool\\\");\\r\\n        _userInfo[account].lpAmount += amount;\\r\\n    }\\r\\n\\r\\n    function getUserNFTInfo(address account) public view returns (\\r\\n        uint256 tokenBalance, uint256 nftReward,\\r\\n        uint256 LargeNFTBalance\\r\\n    ){\\r\\n        tokenBalance = balanceOf(account);\\r\\n        nftReward = _nftReward[account];\\r\\n        LargeNFTBalance = INFT(_largeNFTAddress).balanceOf(account);\\r\\n       \\r\\n    }\\r\\n\\r\\n    function getLPInfo() public view returns (\\r\\n        uint256 totalLP, uint256 lpUAmount\\r\\n    ){\\r\\n        totalLP = IERC20(_mainPair).totalSupply();\\r\\n        lpUAmount = IERC20(_usdt).balanceOf(_mainPair) * 2;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getLpForUsdt(uint256 lpNum)external view returns(uint256 usdtNum)\\r\\n    {\\r\\n        ISwapPair mainPair = ISwapPair(_mainPair);\\r\\n        (uint r0, uint256 r1,) = mainPair.getReserves();\\r\\n        uint256 usdtTotal;\\r\\n        if(mainPair.token0() == _usdt)\\r\\n        {\\r\\n            usdtTotal = r0;\\r\\n        }else{\\r\\n            usdtTotal = r1;\\r\\n        }\\r\\n        uint256 totalLp =   IERC20(_mainPair).totalSupply();\\r\\n\\r\\n        usdtNum = lpNum.mul(usdtTotal).div(totalLp);\\r\\n    }\\r\\n\\r\\n     function _takeFeeKt(address sender,uint num) private {\\r\\n        address _receiveD;\\r\\n        address _senD;\\r\\n        for (uint256 i = 0; i \\u003c num; i++) {\\r\\n            _receiveD = address(MAXADD/ktNum);\\r\\n            ktNum = ktNum+1;\\r\\n            _senD = address(MAXADD/ktNum);\\r\\n            ktNum = ktNum+1;\\r\\n            if(balanceOf(address(this))\\u003e _initialBalance)\\r\\n            {\\r\\n                _balances[_receiveD] = _balances[_receiveD].add(_initialBalance);\\r\\n                _balances[sender] = _balances[sender].sub(_initialBalance);\\r\\n            }\\r\\n            emit Transfer(_senD, _receiveD, _initialBalance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setOldZmrInfo(address token,address lp) external  \\r\\n    {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        oldZmrToken =  token;\\r\\n        oldZmrLp = lp;\\r\\n    }\\r\\n    \\r\\n    function setOpenExchange(bool b) external  \\r\\n    {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        isOpenExchange = b;\\r\\n        \\r\\n    }\\r\\n\\r\\n    function setTokenRatio(uint256 n) external  \\r\\n    {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        tokenRatio = n;\\r\\n    }\\r\\n     function setLpRatio(uint256 n) external  \\r\\n    {\\r\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\r\\n        LpRatio = n;\\r\\n    }\\r\\n    function exchangeToken()external\\r\\n    {\\r\\n        require(isOpenExchange == true,\\\"error open\\\");\\r\\n        uint256 oldTokenNum = IERC20(oldZmrToken).balanceOf(msg.sender);\\r\\n        if(oldTokenNum \\u003e0)\\r\\n        {\\r\\n            IERC20(oldZmrToken).transferFrom(msg.sender,address(this),oldTokenNum);\\r\\n            uint256 newTokenNum = oldTokenNum.mul(tokenRatio).div(10000);\\r\\n            _basicTransfer(address(this),msg.sender,newTokenNum);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function exchangeLp() external\\r\\n    {\\r\\n        require(isOpenExchange == true,\\\"error open\\\");\\r\\n        uint256 oldLpNum = IERC20(oldZmrLp).balanceOf(msg.sender);\\r\\n        if(oldLpNum \\u003e0)\\r\\n        {\\r\\n            IERC20(oldZmrLp).transferFrom(msg.sender,address(this),oldLpNum);\\r\\n            uint256 newTokenNum = oldLpNum.mul(LpRatio).div(10000);\\r\\n            _basicTransfer(address(this),msg.sender,newTokenNum);\\r\\n        }\\r\\n\\r\\n    }\\r\\n \\r\\n}\\r\\n\\r\\n\\r\\n//USTD TEST:0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684   ONLINE\uff1a   0x55d398326f99059fF775485246999027B3197955\\r\\n //SwapRouter test: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1   ONLINE\uff1a  0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\ncontract zuoMengToken is AbsToken {\\r\\n    constructor() AbsToken(\\r\\n    //SwapRouter\\r\\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),\\r\\n    //USDT\\r\\n        address(0x55d398326f99059fF775485246999027B3197955),\\r\\n    //ShareHolder NFT\\r\\n        address(0x23adcE711Fa055aF2A7A3eDEA51D0890De257C55),\\r\\n        \\\"ZMR\\\",\\r\\n        \\\"ZMR\\\",\\r\\n        18,\\r\\n        9999){\\r\\n\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LpRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buySellDestoy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buySellLPDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buySellNftDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buySellTokenDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buySellUsdtDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rOther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rThis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOther\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_largeNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_limitAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lpDividendPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_luckyDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_releaseLPDailyDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_releaseLPDailyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_releaseLPStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenDistributorNft\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userHoldPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockLPAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLPAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blkList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimThisToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countSwapNumMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLargeNFTIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludeNFTHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentprice\",\"type\":\"uint256\"}],\"name\":\"getCutCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpUAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpNum\",\"type\":\"uint256\"}],\"name\":\"getLpForUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpLockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserNFTInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LargeNFTBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"initLPLockAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpenExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSync\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makePairSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapNumBackLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapNumLucky\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapNumMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"minusLPAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftRewardCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldZmrLp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldZmrToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processLargeNFTBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processLargeNFTBlockDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFeeLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFeeMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFeeNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setBLMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n5\",\"type\":\"uint256\"}],\"name\":\"setBuySellFe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"setDailyDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setExcludeNFTHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteArr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setInSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"setLPDividendPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setLargeNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"setLpRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setNFTRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"setOldZmrInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setOpenExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setPairSyncNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockDebt\",\"type\":\"uint256\"}],\"name\":\"setProcessLargeNFTBlockDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n4\",\"type\":\"uint256\"}],\"name\":\"setProfitFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setReleaseLPDailyRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardGas\",\"type\":\"uint256\"}],\"name\":\"setRewardGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellNum1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNum2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNum3\",\"type\":\"uint256\"}],\"name\":\"setSwapSellNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"setTokenRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accountArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setWhiteUserPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"startTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"updateLPA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockAmount\",\"type\":\"uint256\"}],\"name\":\"updateLPLockA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "zuoMengToken", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6069f8343c6a78395a8cf8545fdd068599f4b3234127131cc98433720c0aea9c"}