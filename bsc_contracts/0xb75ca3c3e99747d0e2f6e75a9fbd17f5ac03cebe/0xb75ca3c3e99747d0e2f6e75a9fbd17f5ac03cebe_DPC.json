{"SourceCode": "pragma solidity ^0.8.7;\r\n\r\n// SPDX-License-Identifier: Unlicensed\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract Ownable {\r\n    address public _owner;\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n    \r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) public pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) public pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) public pure returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n   \r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    \r\n}\r\n\r\n\r\ncontract DPC is IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _rOwned;\r\n    mapping(address => uint256) private _tOwned;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private _tTotal;\r\n    uint256 private _rTotal;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint256 private _decimals;\r\n\r\n    address private _destroyAddress = address(0x000000000000000000000000000000000000dEaD);\r\n\r\n    address private _destroy = address(0x000000000000000000000000000000000000dEaD);\r\n\r\n    mapping(address => address) public inviter;\r\n    mapping(address => uint256) public lastSellTime;\r\n\r\n    address public swapV2Router = address(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address public swapV2OPT;\r\n    \r\n    uint256 public _mintTotal;\r\n    mapping(address => bool) public limitExcluded;\r\n\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n    address public uniswapV2BNBPair;\r\n\r\n    mapping(address => bool) public isAirdrop;\r\n    mapping(address => uint256) public teamAirdrop;\r\n    mapping(address => uint256) public shareNum;\r\n    uint256 public totalAirdrop;\r\n    uint256 public restAirdrop;\r\n\r\n    address public meshAddress = address(0xaC398182fAAc3Bc7bc2f355512575e31Dad4bBd4); \r\n    address public metaverseAddress = address(0x2561846026977a50d5732eAD15331f0eF05DA719);\r\n    address public airdropAddress = address(0x169204cd8E5b5c691d42e55162B4A8A65c2B129A);\r\n    address public lpminingAddress = address(0xb6c1B86786128C79F2ECe0d3b19b2403c958C398);\r\n    address public institutionAddress = address(0x0CC6c8508149DC10B573508Bc6e06A0f9b748C0D);\r\n    address public defiAddress = address(0x12bfa7657cEb77379143eEA6cD57d07294B25867);\r\n    address public poolAddress = address(0xfF2032689E903926549b45c2621Ef81a2d1D0E26);\r\n\r\n    address public lpbonusAddress = address(0xF59A687035229fDDd196B31055bd3f17fCCE6B7C);\r\n\r\n    address public ucur1 = address(0x7402B515EfCFFA99035E37c3a60224f6bBF5f1d8);\r\n\r\n    // address public swapV2Router;\r\n    address public swapV2pairs;\r\n    \r\n    address public fundAddress = address(0x2f72fe7CB8784E6b34a62C1E71c9DF4D8451be02);\r\n    address public lpAddress = address(0x2FDE85185E26E43aa4BbA7E25Ec1f2556D631402);\r\n   \r\n    address private poperator = address(0xF58309ec357119fCAA2a619B72130b7C2568EBc1);\r\n    address public claimAdderss = address(0x7245D2062299CAa6B496f6a53Eae15c9d379e796);\r\n\r\n    //time\r\n    using DateTime for uint;\r\n    uint time;\r\n    uint month;\r\n    uint day;\r\n    uint lastTs;\r\n\r\n    uint256 startTime; \r\n   \r\n    mapping(address => uint256) transferTime;\r\n    mapping(address => uint256) transferNum;\r\n    mapping(address => uint256) speedNum;\r\n    mapping(address => uint256) sellNum;\r\n    \r\n    address public usdt = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    mapping(address => uint256) dpcIdo;\r\n    mapping(address => uint256) dpcIdoTimes;\r\n    mapping(address => uint256) dpcIdoOneNum;\r\n    mapping(address => uint256) dpcRestClaimNum;\r\n    mapping(address => uint256) idoStartTime;\r\n    mapping(address => uint256) claimDpcRestTime;\r\n   \r\n    mapping(address => uint256) dpcAirdrop;\r\n\r\n    uint256 private olddaoDay;\r\n    uint256 private olddaoTotal;\r\n    uint256 private newdaoDay;\r\n    uint256 private newdaoTotal;\r\n    uint256 private daoTotal;\r\n    uint256 private daoNum;\r\n\r\n    uint256 private oldlpDay;\r\n    uint256 private oldlpTotal;\r\n    uint256 private newlpDay;\r\n    uint256 private newlpTotal;\r\n    uint256 private lpTotal;\r\n    uint256 private lpNum;\r\n\r\n    uint256 private IdoPrice;\r\n\r\n    mapping(address => uint256) ClaimDaoTime;\r\n    mapping(address => bool) isDao;\r\n\r\n    address public LpContract;\r\n    uint256 private LpNum;\r\n    uint256 private DpcRest = 5;\r\n    mapping(address => uint256) dpcLp;\r\n    mapping(address => uint256) dpcLpTime;\r\n    uint256 private dpcLpTotal;\r\n    mapping(address => uint256) ClaimQuotaTime;\r\n    mapping(address => uint256) oldClaimQuota;\r\n    address private appaddr;\r\n    mapping(address => uint256) claimDpcBonusDay;\r\n    uint256 private bonus = 2000 * 10**18;\r\n    uint256 private lpQuota = 4;\r\n\r\n    bool public isClaim;\r\n    \r\n    \r\n    constructor(address tokenOwner) {\r\n        if (block.chainid == 56) {\r\n            uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n            uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\r\n                address(this),\r\n                usdt);\r\n        }\r\n        // Create a pancake pair for this new token\r\n        //USDT Pair\r\n       \r\n        LpContract = uniswapV2Pair;\r\n        //BNB Pair\r\n        // uniswapV2BNBPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\r\n        //         address(this),\r\n        //         uniswapV2Router.WETH());\r\n                \r\n        swapV2pairs = uniswapV2Pair;//USDT\r\n        // limitExcluded[swapV2pairs] = true;\r\n        // limitExcluded[uniswapV2Pair] = true;\r\n        limitExcluded[_destroyAddress] = true;\r\n        \r\n\r\n        _name = \"DARK_POOL\";\r\n        _symbol = \"DPC\";\r\n        _decimals = 18;\r\n\r\n        _tTotal = 33000000 * 10**_decimals;\r\n        _mintTotal = 330000 * 10**_decimals;\r\n        IdoPrice = 50;\r\n        LpNum = 1 * 10 ** 18;\r\n        // _rTotal = (MAX - (MAX % _tTotal));\r\n        _rTotal = _tTotal;\r\n    \r\n        \r\n        limitExcluded[tokenOwner] = true;\r\n        limitExcluded[address(this)] = true;\r\n        limitExcluded[meshAddress] = true;\r\n        limitExcluded[metaverseAddress] = true;\r\n        limitExcluded[airdropAddress] = true;\r\n        limitExcluded[lpminingAddress] = true;\r\n        limitExcluded[institutionAddress] = true;\r\n        limitExcluded[defiAddress] = true;\r\n        limitExcluded[poolAddress] = true;\r\n        limitExcluded[poperator] = true;\r\n        limitExcluded[fundAddress] = true;\r\n        limitExcluded[lpAddress] = true;\r\n        limitExcluded[lpbonusAddress] = true;\r\n\r\n         startTime = block.timestamp;\r\n    \r\n        _owner = tokenOwner;\r\n\r\n        totalAirdrop = _tTotal.mul(375).div(1000);\r\n        restAirdrop = totalAirdrop;\r\n       \r\n        _rOwned[meshAddress] = _rTotal.mul(25).div(100);\r\n        _rOwned[metaverseAddress] = _rTotal.mul(23).div(100);\r\n        _rOwned[airdropAddress] = _rTotal.mul(375).div(1000);\r\n        _rOwned[lpminingAddress] = _rTotal.mul(10).div(100);\r\n        _rOwned[institutionAddress] = _rTotal.mul(2).div(100);\r\n        _rOwned[defiAddress] = _rTotal.mul(2).div(100);\r\n        _rOwned[poolAddress] = _rTotal.mul(5).div(1000);\r\n\r\n        emit Transfer(address(0), meshAddress, _rTotal.mul(25).div(100));\r\n        emit Transfer(address(0), metaverseAddress, _rTotal.mul(23).div(100));\r\n        emit Transfer(address(0), airdropAddress, _rTotal.mul(375).div(1000));\r\n        emit Transfer(address(0), lpminingAddress, _rTotal.mul(10).div(100));\r\n        emit Transfer(address(0), institutionAddress, _rTotal.mul(2).div(100));\r\n        emit Transfer(address(0), defiAddress, _rTotal.mul(2).div(100));\r\n        emit Transfer(address(0), poolAddress, _rTotal.mul(5).div(1000));\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n    \r\n    function getShareNum(address account) public view returns (uint256) {\r\n        return shareNum[account];\r\n    }\r\n\r\n    function getTeamAirdrop(address account) public view returns (uint256) {\r\n        return teamAirdrop[account];\r\n    }\r\n\r\n    function getInviter(address account) public view returns (address) {\r\n        return inviter[account];\r\n    }\r\n\r\n    function getdpcLp(address account) public view returns (uint256) {\r\n        return dpcLp[account];\r\n    }\r\n\r\n    function getdpcIdoTimes(address account) public view returns (uint256) {\r\n        return dpcIdoTimes[account];\r\n        }\r\n\r\n    function getdpcIdo(address account) public view returns (uint256) {\r\n        return dpcIdo[account];\r\n    }\r\n\r\n    function getdpcRestClaimNum(address account) public view returns (uint256) {\r\n        return dpcRestClaimNum[account];\r\n    }\r\n\r\n    function getdpcremainingNum(address account) public view returns (uint256) {\r\n        return dpcIdo[account].sub(dpcRestClaimNum[account]);\r\n    }\r\n\r\n    function getdpcAirdropNum(address account) public view returns (uint256) {\r\n        return dpcAirdrop[account];\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        // if(msg.sender == uniswapV2Pair){\r\n             _transfer(msg.sender, recipient, amount);\r\n        // }else{\r\n        //     _tokenOlnyTransfer(msg.sender, recipient, amount);\r\n        // }\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        // if(recipient == uniswapV2Pair){\r\n             _transfer(sender, recipient, amount);\r\n        // }else{\r\n        //      _tokenOlnyTransfer(sender, recipient, amount);\r\n        // }\r\n       \r\n        _approve(\r\n            sender,\r\n            msg.sender,\r\n            _allowances[sender][msg.sender].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function tokenFromReflection(uint256 rAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            rAmount <= _rTotal,\r\n            \"Amount must be less than total reflections\"\r\n        );\r\n        uint256 currentRate = _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n    //to recieve ETH from uniswapV2Router when swaping\r\n    receive() external payable {}\r\n\r\n    function _getRate() private view returns (uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply.div(tSupply);\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns (uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;\r\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function claimTokens(uint256 uAmount) public {\r\n        require(msg.sender == poperator,\"No permission\");\r\n        IERC20(usdt).transfer(claimAdderss,uAmount);\r\n        // payable(_owner).transfer(address(this).balance);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        require(balanceOf(from) >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        // if(_rOwned[to] == 0 && inviter[to] == address(0) && amount >= 1 * 10**18 && to!=swapV2pairs && from!=swapV2pairs && to!=address(this)){\r\n        //             inviter[to] = from;\r\n        //             shareNum[from] += 1;\r\n        //         }\r\n\r\n        //indicates if fee should be deducted from transfer\r\n        bool takeFee = true;\r\n\r\n        //if any account belongs to _isExcludedFromFee account then remove the fee\r\n        // if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\r\n        //     takeFee = false;\r\n        // }\r\n        if (limitExcluded[from] || limitExcluded[to]) {\r\n            takeFee = false;\r\n        }\r\n        if(to==address(0) || to==_destroy || to==swapV2Router || from==swapV2Router){\r\n            takeFee = false;\r\n        }\r\n        if(_mintTotal>=_tTotal){\r\n            takeFee = false;\r\n        }\r\n \r\n        if(from!=swapV2pairs && to!=swapV2pairs){\r\n            takeFee = false;\r\n        }\r\n        \r\n        //transfer amount, it will take tax, burn, liquidity fee\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n    }\r\n\r\n\r\n    //this method is responsible for taking all fee, if takeFee is true\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount,\r\n        bool takeFee\r\n    ) private {\r\n        uint256 currentRate = _getRate();\r\n\r\n        uint256 rAmount = tAmount.mul(currentRate);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount,\"a\");\r\n\r\n        uint256 rate = 0;\r\n        uint256 crate;\r\n        uint256 dao = 0;\r\n        uint256 lpbonus = 0;\r\n\r\n        bool _isBuy = false;\r\n        if (takeFee) {\r\n            rate = 5;\r\n            \r\n            if(sender==swapV2pairs){\r\n                _isBuy = true;\r\n                dao = tAmount.mul(3).div(100);\r\n                _takeTransfer(\r\n                    sender,\r\n                    address(this),\r\n                    dao,\r\n                    currentRate\r\n                            ); \r\n                _addDao(dao);\r\n\r\n                _takeTransfer(\r\n                    sender,\r\n                    _destroyAddress,\r\n                    tAmount.mul(2).div(100),\r\n                    currentRate\r\n                            );\r\n            }else{\r\n                dao = tAmount.mul(2).div(100);\r\n                lpbonus = tAmount.mul(2).div(100);\r\n                _takeTransfer(\r\n                    sender,\r\n                    address(this),\r\n                    dao,\r\n                    currentRate\r\n                            );\r\n                _addDao(dao);\r\n\r\n                _takeTransfer(\r\n                    sender,\r\n                    address(this),\r\n                    lpbonus,\r\n                    currentRate\r\n                            );\r\n                _addLpBonus(lpbonus);\r\n                           \r\n                _takeTransfer(\r\n                    sender,\r\n                    fundAddress,\r\n                    tAmount.mul(1).div(100),\r\n                    currentRate\r\n                            );\r\n                \r\n            }\r\n\r\n        }\r\n        \r\n        crate = 100 - rate;\r\n         _takeTransfer(\r\n            sender,\r\n            recipient,\r\n            tAmount.mul(crate).div(100),\r\n            currentRate\r\n            );\r\n\r\n    }\r\n    \r\n    function _addDao(uint256 Amount) private{\r\n         time=currTimeStamp();\r\n         daoTotal = daoTotal.add(Amount);\r\n        if(newdaoDay!=time.getDay()){\r\n            olddaoDay = newdaoDay;\r\n            olddaoTotal = newdaoTotal;\r\n            newdaoDay = time.getDay();\r\n            newdaoTotal = Amount;\r\n        }else{\r\n            newdaoTotal = newdaoTotal.add(Amount);\r\n        }   \r\n    }\r\n\r\n    function _addLpBonus(uint256 Amount) private{\r\n         time=currTimeStamp();\r\n         lpTotal = lpTotal.add(Amount);\r\n        if(newlpDay!=time.getDay()){\r\n            oldlpDay = newlpDay;\r\n            oldlpTotal = newlpTotal;\r\n            newlpDay = time.getDay();\r\n            newlpTotal = Amount;\r\n        }else{\r\n            newlpTotal = newlpTotal.add(Amount);\r\n        }   \r\n    }\r\n\r\n    \r\n     function getClaimDao(address addr) public view returns (uint256) {\r\n         uint256 nowTime=currTimeStamp()-24*60*60;\r\n         if(!isDao[addr] || nowTime.getDay() != olddaoDay  || ClaimDaoTime[addr] == olddaoDay ){\r\n             return 0;\r\n         }else{\r\n              uint256 Amount = olddaoTotal.div(daoNum);\r\n              if(daoTotal < Amount){\r\n                return daoTotal;\r\n              }else{\r\n                return Amount;\r\n              }\r\n         }\r\n    }\r\n\r\n\r\n     function claimDao(address addr) public {\r\n        require(msg.sender == addr,\"No permission\");\r\n        require(isDao[addr],\"not dao\");\r\n        time=currTimeStamp()-24*60*60;\r\n        require(time.getDay() == olddaoDay,\"No dao\");\r\n        require(ClaimDaoTime[addr] != olddaoDay,\"today is claim\");\r\n        ClaimDaoTime[addr] = olddaoDay;\r\n        uint256 Amount;\r\n        Amount = olddaoTotal.div(daoNum);\r\n        require(daoTotal >= Amount,\"No daoTotal\");\r\n        daoTotal = daoTotal.sub(Amount);\r\n        _rOwned[addr] = _rOwned[addr].add(Amount);\r\n        _rOwned[address(this)] = _rOwned[address(this)].sub(Amount);\r\n        emit Transfer(address(this), addr, Amount);\r\n    }\r\n\r\n\r\n    function _takeTransfer(\r\n        address sender,\r\n        address to,\r\n        uint256 tAmount,\r\n        uint256 currentRate\r\n    ) private {\r\n        \r\n        //  if(!limitExcluded[to] && balanceOf(to).add(tAmount) > 30 * 10**18){\r\n\r\n            // uint256 dAmount = balanceOf(to).add(tAmount).sub(30 * 10**18,\"b\");\r\n            // uint256 rdAmount = dAmount.mul(currentRate);\r\n            // _rOwned[_destroyAddress] = _rOwned[_destroyAddress].add(rdAmount);\r\n            // emit Transfer(sender, _destroyAddress, dAmount);\r\n            \r\n            // tAmount = tAmount.sub(dAmount,\"c\");\r\n        // }\r\n            uint256 rAmount = tAmount.mul(currentRate);\r\n            _rOwned[to] = _rOwned[to].add(rAmount);\r\n            emit Transfer(sender, to, tAmount);\r\n    }\r\n\r\n\r\n    function changeV2pairs(address router) public onlyOwner {\r\n        swapV2pairs = router;\r\n        uniswapV2Pair = router;\r\n        // limitExcluded[swapV2pairs] = true;\r\n    }\r\n\r\n    function changeIdoPrice(uint256 amt) public {\r\n        require(msg.sender == poperator,\"No permission\");\r\n        IdoPrice = amt;\r\n    }\r\n\r\n    function setAirdrop(address[] memory addr, uint256[] memory idoTimes, uint256[] memory dpcIdoNum,uint256[] memory dpcAirdropNum) public onlyOwner {\r\n        require(addr.length == idoTimes.length && addr.length == dpcIdoNum.length && addr.length == dpcAirdropNum.length, \"account neq paccount\");\r\n        for (uint i=0; i<addr.length; i++) {\r\n            isAirdrop[addr[i]] = true;\r\n            dpcIdoTimes[addr[i]] = idoTimes[i];\r\n            uint256 dpcIdoNumWei =  dpcIdoNum[i] * 10 ** 18;\r\n            dpcIdo[addr[i]] = dpcIdoNumWei;\r\n            dpcAirdrop[addr[i]] = dpcAirdropNum[i] * 10 ** 18;\r\n            restAirdrop = restAirdrop.sub(dpcIdoNumWei);\r\n            if(inviter[addr[i]]!=address(0)){\r\n                teamAirdrop[inviter[addr[i]]] += 1;\r\n                if(teamAirdrop[inviter[addr[i]]] >= 10){\r\n                    isDao[inviter[addr[i]]] = true;\r\n                    daoNum += 1;\r\n                }\r\n            }            \r\n         }\r\n    }\r\n\r\n      \r\n    function tokenAirdrop(address _from,address _to, uint _amt) public {\r\n        address cur = _from;\r\n         \r\n        uint256 uAmount = _amt * 10 ** 18;\r\n        uint256 Amount = IdoPrice;\r\n        uint256 Amountwei = Amount * 10 ** 18;\r\n        \r\n        require(_amt == 100,\"Quantity must is 100u\");\r\n        \r\n        require(_from==msg.sender,\"error\");\r\n        require(_to==address(this),\"error\");\r\n        // require(!isAirdrop[_from],\"Only one airdrop can be obtained for each address\");\r\n        // require(restAirdrop>=Amountwei,\"Airdrop End\");\r\n\r\n        require(IERC20(usdt).allowance(_from,address(this)) >= uAmount ,\"Insufficient authorization limit\");\r\n        IERC20(usdt).transferFrom(_from,_to,uAmount);//\u8f6cU\r\n        isAirdrop[_from] = true;\r\n\r\n        // dpcIdo[_from] = dpcIdo[_from].add(Amountwei);\r\n        // dpcIdoTimes[_from] +=1;\r\n        // idoStartTime[_from] = 0;\r\n         idoStartTime[_from] = currTimeStamp();\r\n\r\n        dpcAirdrop[_from] = dpcAirdrop[_from].add(Amountwei.mul(10));\r\n        //  restAirdrop = restAirdrop.sub(Amountwei);\r\n         \r\n        if(inviter[_from] != address(0)){\r\n            teamAirdrop[inviter[_from]] += 1;\r\n            if(teamAirdrop[inviter[_from]] >= 10){\r\n                isDao[inviter[_from]] = true;\r\n                daoNum += 1;\r\n            }\r\n             dpcAirdrop[inviter[_from] ] = dpcAirdrop[inviter[_from]].add(Amountwei.div(2));\r\n        //     _rOwned[inviter[_from]] = _rOwned[inviter[_from]].add(uAmount.div(2));\r\n        //  emit Transfer(address(this), inviter[_from], uAmount.div(2));\r\n        }\r\n\r\n        uint256 ubonus1 = uAmount.mul(70).div(100);\r\n        IERC20(usdt).transfer(ucur1,ubonus1);\r\n        // uint256 ubonus2 = uAmount.mul(25).div(100);\r\n        // IERC20(usdt).transfer(ucur2,ubonus2);\r\n        // uint256 ubonus3 = uAmount.mul(20).div(100);\r\n        // IERC20(usdt).transfer(ucur3,ubonus3);\r\n\r\n          uint256 ubonus = uAmount.mul(15).div(100);\r\n          for (uint256 i = 1; i <= 5; i++) {\r\n             cur = inviter[cur] ;\r\n             if(cur == address(0)){\r\n                 break;\r\n             }\r\n             if(isAirdrop[cur]){\r\n                  IERC20(usdt).transfer(cur,ubonus);\r\n             }\r\n             ubonus = ubonus.div(2);\r\n         }\r\n        \r\n    }\r\n\r\n        function claimDpc(address addr) public {\r\n            require(isClaim,\"Collection has not started yet\");\r\n            require(msg.sender == addr,\"No permission\");\r\n            require(dpcIdoTimes[addr] >= 1,\"Received ido\");\r\n            require(dpcIdo[addr] > 0,\"No DPC\");\r\n            //uint256 Amount = IdoPrice.mul(10*10**18).mul(dpcIdoTimes[addr]).div(10);\r\n            uint256 Amount = dpcIdo[addr].div(10);\r\n            dpcIdo[addr] = dpcIdo[addr].sub(Amount);\r\n            dpcIdoTimes[addr] = 0;\r\n            idoStartTime[addr] = currTimeStamp();\r\n            dpcIdoOneNum[addr] = dpcIdoOneNum[addr].add(Amount);\r\n            _rOwned[addr] = _rOwned[addr].add(Amount);\r\n            _rOwned[address(this)] = _rOwned[address(this)].sub(Amount);\r\n            emit Transfer(address(this), addr, Amount);\r\n        }\r\n\r\n        function getclaimDpc(address addr) public view returns (uint256) {\r\n            uint256 nowTime = currTimeStamp();\r\n            uint256 Amount = 0;\r\n            if(!isClaim || nowTime.sub(claimDpcRestTime[addr]) < 5*24*60*60 || dpcRestClaimNum[addr] > dpcIdo[addr] || dpcIdo[addr]==0){\r\n                Amount = 0;\r\n            }else{\r\n                if(idoStartTime[addr] == 0){\r\n                     //Amount = IdoPrice.mul(10*10**18).mul(dpcIdoTimes[addr]).div(10);\r\n                     Amount = dpcIdo[addr].div(10);\r\n\r\n                }else{\r\n                    if(idoStartTime[addr] <= time - 24*60*60){\r\n                     Amount = dpcIdo[addr].mul(DpcRest).div(100);\r\n                    }\r\n                         \r\n                }\r\n            }\r\n            return Amount;\r\n        }\r\n    \r\n        function claimDpcRest(address addr) public {\r\n                require(isClaim,\"Collection has not started yet\");\r\n                require(msg.sender == addr,\"No permission\");\r\n                 time=currTimeStamp();\r\n                require(idoStartTime[addr] <= time - 24*60*60,\"one day later\");\r\n                require(dpcIdo[addr] > 0,\"No DPC\");\r\n                // require(idoStartTime[addr] > 0,\"Receive 10% first\");\r\n                if(idoStartTime[addr] == 0){\r\n                    claimDpc(addr);\r\n                }else{\r\n                    // require(claimDpcRestDay[addr] != time.getDay(),\"Received today\");\r\n                    require(time.sub(claimDpcRestTime[addr]) >= 5*24*60*60,\"Receive once every 5 days\");\r\n                    require(dpcRestClaimNum[addr] <= dpcIdo[addr],\"Already received\");\r\n\r\n                    if(idoStartTime[addr] < time - 48*60*60)\r\n                    {\r\n                        if(6 * 10**18 > balanceOf(addr) && LpNum > IERC20(LpContract).balanceOf(addr) && LpNum > dpcLp[addr]){\r\n                            dpcIdo[addr] = 0;\r\n                            claimDpcRestTime[addr] = time;\r\n                        }else{\r\n                            claimDpcRestTime[addr] = time;\r\n                            uint256 Amount = dpcIdo[addr].mul(DpcRest).div(100);\r\n                            dpcRestClaimNum[addr] = dpcRestClaimNum[addr].add(Amount);\r\n\r\n                            _rOwned[addr] = _rOwned[addr].add(Amount);\r\n                            _rOwned[address(this)] = _rOwned[address(this)].sub(Amount);\r\n                            emit Transfer(address(this), addr, Amount);\r\n                        }\r\n                    }else{\r\n                            claimDpcRestTime[addr] = time;\r\n                            uint256 Amount = dpcIdo[addr].mul(DpcRest).div(100);\r\n                            dpcRestClaimNum[addr] = dpcRestClaimNum[addr].add(Amount);\r\n\r\n                            _rOwned[addr] = _rOwned[addr].add(Amount);\r\n                            _rOwned[address(this)] = _rOwned[address(this)].sub(Amount);\r\n                            emit Transfer(address(this), addr, Amount);\r\n                    }\r\n                }\r\n        }\r\n\r\n        function stakeLp(address _from,address _to, uint256 Amountwei) public {\r\n\r\n                require(Amountwei > 0,\"Quantity error\");\r\n                require(_from==msg.sender,\"error\");\r\n                require(_to==address(this),\"error\");\r\n                require(IERC20(LpContract).allowance(_from,address(this)) >= Amountwei ,\"Insufficient authorization limit\");\r\n                IERC20(LpContract).transferFrom(_from,_to,Amountwei);\r\n\r\n                oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from));\r\n\r\n                dpcLp[_from] = dpcLp[_from].add(Amountwei);\r\n\r\n                time=currTimeStamp();\r\n               \r\n\r\n                dpcLpTime[_from] = time;\r\n                \r\n\r\n                dpcLpTotal = dpcLpTotal.add(Amountwei);\r\n        \r\n         }\r\n\r\n        function claimStakeLp(address _from ,uint256 Amountwei) public {\r\n                require(Amountwei > 0,\"Quantity error\");\r\n                require(_from==msg.sender,\"error\");\r\n                require(dpcLp[_from] >= Amountwei ,\"Insufficient authorization limit\");\r\n                IERC20(LpContract).transfer(_from,Amountwei);\r\n\r\n                oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from));\r\n\r\n                dpcLp[_from] = dpcLp[_from].sub(Amountwei);\r\n\r\n                time=currTimeStamp();\r\n                dpcLpTime[_from] = time;\r\n\r\n                dpcLpTotal = dpcLpTotal.sub(Amountwei);\r\n        \r\n         }\r\n\r\n\r\n        function getClaimQuota(address addr) public view returns (uint256) {\r\n                uint256 ClaimQuota;\r\n               if(dpcAirdrop[addr] > 0 && dpcLp[addr]>0){\r\n                    uint256 QuotastartTime;\r\n                    uint256 limit = 50 * 10**18;\r\n                    uint256 LpQuotaNum = dpcLp[addr].mul(getLpPrice()).mul(lpQuota).div(100);\r\n                    uint256 secondQuota;\r\n                    if(getDpcPrice()>0){\r\n                        secondQuota = LpQuotaNum.div(24*60*60).div(getDpcPrice());\r\n                    }\r\n\r\n                    uint256 limitSecondQuota = limit.div(24*60*60);\r\n                    if(secondQuota > limitSecondQuota){\r\n                        secondQuota = limitSecondQuota;\r\n                    }\r\n                    uint256 nowTime = currTimeStamp();\r\n\r\n                    if(dpcLpTime[addr]>ClaimQuotaTime[addr]){\r\n                        QuotastartTime = dpcLpTime[addr];\r\n                    }else{\r\n                        QuotastartTime = ClaimQuotaTime[addr];\r\n                    }\r\n                    ClaimQuota = (nowTime.sub(QuotastartTime)).mul(secondQuota);\r\n                    if(ClaimQuota > dpcAirdrop[addr]){\r\n                        ClaimQuota = dpcAirdrop[addr];\r\n                    }\r\n               }else{\r\n                    ClaimQuota = 0;\r\n               }\r\n               ClaimQuota = ClaimQuota.add(oldClaimQuota[addr]);\r\n\r\n               return ClaimQuota;\r\n        \r\n         }\r\n\r\n        function claimDpcAirdrop(address addr) public {\r\n                require(isClaim,\"Collection has not started yet\");\r\n                require(msg.sender == addr,\"No permission\");\r\n                time=currTimeStamp();\r\n                uint256 ClaimQuota = getClaimQuota(addr);\r\n                require(ClaimQuota > 0,\"erro\");\r\n                \r\n                _rOwned[addr] = _rOwned[addr].add(ClaimQuota);\r\n                _rOwned[address(this)] = _rOwned[address(this)].sub(ClaimQuota);\r\n                emit Transfer(address(this), addr, ClaimQuota);\r\n                ClaimQuotaTime[addr] = time; \r\n                oldClaimQuota[addr] = 0;      \r\n                dpcAirdrop[addr] = dpcAirdrop[addr].sub(ClaimQuota);        \r\n                \r\n        }\r\n\r\n\r\n        function getClaimDpcBonus(address addr) public view returns (uint256) {\r\n                // require(msg.sender == addr,\"No permission\");\r\n                uint256 nowTime=currTimeStamp();\r\n                // require(claimDpcBonusDay[addr] != nowTime.getDay(),\"Received today\");\r\n                // require(dpcLp[addr] > 0,\"No permission\");\r\n                if(claimDpcBonusDay[addr] == nowTime.getDay() || dpcLp[addr] == 0 || nowTime.sub(dpcLpTime[addr]) < 24*60*60){\r\n                    return 0;\r\n                }\r\n\r\n                uint256 quietBonus = balanceOf(lpbonusAddress).mul(30).div(100);\r\n                uint256 oldtime=nowTime.sub(24*60*60);\r\n                if(oldtime.getDay() == oldlpDay && oldlpTotal > 0){\r\n                    quietBonus = quietBonus.add(oldlpTotal.mul(30).div(100));\r\n                }\r\n\r\n                // require(nowTime.sub(dpcLpTime[addr]) > 24*60*60,\"The pledge can only be received after one day\");\r\n                \r\n                uint256 ClaimBonus = quietBonus.mul(dpcLp[addr]).div(dpcLpTotal);\r\n                return ClaimBonus;         \r\n        }\r\n\r\n        function claimDpcBonus(address addr) public {\r\n                require(isClaim,\"Collection has not started yet\");\r\n                require(msg.sender == addr,\"No permission\");\r\n                time=currTimeStamp();\r\n                require(claimDpcBonusDay[addr] != time.getDay(),\"Received today\");\r\n                require(dpcLp[addr] > 0,\"No permission\");\r\n                require(time.sub(dpcLpTime[addr]) > 24*60*60,\"The pledge can only be received after one day\");\r\n               \r\n                uint256 ClaimBonus = getClaimDpcBonus(addr);\r\n\r\n                require(ClaimBonus > 0,\"No permission\");\r\n                \r\n                _rOwned[addr] = _rOwned[addr].add(ClaimBonus);\r\n                _rOwned[address(this)] = _rOwned[address(this)].sub(ClaimBonus);\r\n                emit Transfer(address(this), addr, ClaimBonus);\r\n\r\n                claimDpcBonusDay[addr] = time.getDay();\r\n\r\n                address cur = addr;\r\n                uint256 rate;\r\n                uint256 moveBonus;\r\n                for (uint256 i = 1; i <= 8; i++) {\r\n                    cur = inviter[cur] ;\r\n                    if(cur == address(0)){\r\n                        break;\r\n                    }\r\n                        if(i==1){\r\n                            rate = 50;\r\n                        }else if(i==2 || i==3){\r\n                            rate = 35;\r\n                        }else if(i>3 && i<8){\r\n                            rate = 25;\r\n                        }else{\r\n                            rate = 10;\r\n                        }\r\n                moveBonus = ClaimBonus.mul(rate).div(100);\r\n                _rOwned[cur] = _rOwned[cur].add(moveBonus);\r\n                _rOwned[address(this)] = _rOwned[address(this)].sub(moveBonus);\r\n                emit Transfer(address(this), cur, moveBonus);\r\n                       \r\n                }       \r\n        }\r\n\r\n        \r\n        function changePoperator(address addr) public {\r\n            require(msg.sender == poperator,\"No permission\");\r\n            poperator = addr;\r\n        }\r\n        function changeLpContract(address addr) public onlyOwner {\r\n            LpContract = addr;\r\n        }\r\n        function changeLpNum(uint256 num) public {\r\n            require(msg.sender == poperator,\"No permission\");\r\n            LpNum = num;\r\n        }\r\n        function changeDpcRest(uint256 num) public {\r\n            require(msg.sender == poperator,\"No permission\");\r\n            DpcRest = num;\r\n    }\r\n        function changeIsClaim(bool istrue) public {\r\n             require(msg.sender == poperator,\"No permission\");\r\n            isClaim = istrue;\r\n        }\r\n        function changeLpQuota(uint256 num) public {\r\n            require(msg.sender == poperator,\"No permission\");\r\n            lpQuota = num;\r\n        }\r\n        function changeAppaddr(address addr) public {\r\n            require(msg.sender == poperator,\"No permission\");\r\n            appaddr = addr;\r\n        }\r\n        function changeUcur1(address addr) public {\r\n            require(msg.sender == poperator,\"No permission\");\r\n            ucur1 = addr;\r\n        }\r\n        // function changeUcur2(address addr) public {\r\n        //     require(msg.sender == poperator,\"No permission\");\r\n        //     ucur2 = addr;\r\n        // }\r\n        // function changeUcur3(address addr) public {\r\n        //     require(msg.sender == poperator,\"No permission\");\r\n        //     ucur3 = addr;\r\n        // }\r\n        \r\n\r\n        function getDpcPrice() public view returns (uint256) {\r\n            uint256 price =  IERC20(usdt).balanceOf(uniswapV2Pair).mul(100000000).div(balanceOf(uniswapV2Pair));\r\n            return price;\r\n        }\r\n        function getLpPrice() public view returns (uint256) {\r\n            uint256 lpNumTotal = IERC20(LpContract).totalSupply();\r\n            uint256 price =  IERC20(usdt).balanceOf(uniswapV2Pair).mul(100000000).mul(2).div(lpNumTotal);\r\n            return price;\r\n        }\r\n        function getDpcLpTotalNum() public view returns (uint256) {\r\n            return dpcLpTotal;\r\n        }\r\n\r\n        \r\n    function inviterSet(address paddr) public {\r\n        require(inviter[msg.sender] == address(0),\"Address bound\");\r\n        require(msg.sender != paddr,\"Address erro\");\r\n        inviter[msg.sender] = paddr; \r\n        shareNum[paddr] += 1;      \r\n    }\r\n\r\n    function setallInviter(address[] memory _a, address[] memory _pa) public onlyOwner {\r\n        require(_a.length == _pa.length, \"account neq paccount\");\r\n        for (uint i=0; i<_a.length; i++) {\r\n            inviter[_a[i]] = _pa[i];\r\n            shareNum[_pa[i]] += 1; \r\n         }\r\n    }\r\n\r\n\r\n    function claimAdderssSet(address addr) public {\r\n        require(msg.sender == poperator,\"No permission\");\r\n        claimAdderss = addr;   \r\n    }\r\n\r\n    function setIsDao(address addr,bool isTrue) public {\r\n        require(msg.sender == poperator,\"No permission\");\r\n        isDao[addr] = isTrue; \r\n        if(isTrue){\r\n        daoNum += 1;\r\n        }else{\r\n        daoNum -= 1;\r\n        }\r\n    }\r\n\r\n    function currTimeStamp() public view returns (uint256){\r\n        return block.timestamp + 8*60*60;\r\n    }\r\n\r\n    function updateLimitedall(address[] memory _account, bool enabled) public  onlyOwner {\r\n         for (uint i=0; i<_account.length; i++) {\r\n            limitExcluded[_account[i]] = enabled;\r\n         }\r\n    }\r\n \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LpContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mintTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAppaddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeDpcRest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"changeIdoPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"istrue\",\"type\":\"bool\"}],\"name\":\"changeIsClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeLpContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeLpNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeLpQuota\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changePoperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeUcur1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"changeV2pairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdderss\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimAdderssSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimDpc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimDpcAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimDpcBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimDpcRest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amountwei\",\"type\":\"uint256\"}],\"name\":\"claimStakeLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getClaimDao\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getClaimDpcBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getClaimQuota\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDpcLpTotalNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDpcPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getShareNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTeamAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getclaimDpc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getdpcAirdropNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getdpcIdo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getdpcIdoTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getdpcLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getdpcRestClaimNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getdpcremainingNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"institutionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paddr\",\"type\":\"address\"}],\"name\":\"inviterSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastSellTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpbonusAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpminingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"meshAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaverseAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"idoTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dpcIdoNum\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dpcAirdropNum\",\"type\":\"uint256[]\"}],\"name\":\"setAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isTrue\",\"type\":\"bool\"}],\"name\":\"setIsDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_a\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pa\",\"type\":\"address[]\"}],\"name\":\"setallInviter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amountwei\",\"type\":\"uint256\"}],\"name\":\"stakeLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapV2OPT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapV2Router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapV2pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"tokenAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ucur1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2BNBPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_account\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"updateLimitedall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DPC", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008e59424663e6ba2327564b28437b6e0294a4725c", "EVMVersion": "Default", "Library": "DateTime:ff7a90fa8193b51482c37e84f3e9a0798921380b", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ef09bfb10910703fcf2044f378b531ab08d1b6b8024591d19e7fa7e42eb23597"}