{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PreSales.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.21;\\nimport './ReentrancyGuard.sol';\\n\\ncontract CoinstTrailPresales is ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    IERC20 internal immutable _wbnbToken;\\n    IERC20 internal immutable _usdToken;\\n    IERC20 public immutable _ctrlToken;\\n    address public immutable _sysOps; \\n    address internal immutable dev;\\n\\n    address internal immutable _stmrsrvd = address(0x3a2DF645850e6da7700Fb022015723eFaE4afD21); // multisig 40%\\n    address internal immutable _teamwrsrd = address(0xf653562815Ab51bB67baE3f9278D90269b5B0F22); // R&D 15% + Team 5% \\n    address internal immutable _mrktgWlt = address(0x07821dC911eA9C6229E8844DE458535443B3C399); // multisig 10%\\n\\n    IUniswapRouter public immutable uniswapRouter;\\n\\n    // system config\\n    uint internal constant MLTIPLR = 1000000;\\n    uint internal constant DIVIDER = 10000;\\n    uint internal constant COMMISS = 500; // 5% \\n    uint internal constant INLQDTY = 4000; // System Reserve 40% \\n    uint internal constant MARKTNG = 1000; // Marketing Wallet 10% \\n    uint internal constant STMLQTY = 2500; // System Liquity 25% \\n    uint internal constant TEAMRSV = 2000; // 20% \\n    uint internal constant MINPURC = 50 ether; // $50 minimum purchase\\n    uint internal constant INIPRIC = 0.0001 ether;\\n    uint internal constant PRVPRIC = 0.00001 ether; // 18 months Locked \\n    uint internal constant DECIMAL = 1e18;\\n    uint internal constant SALEWDW = 365 days; // 1 years sales\\n    uint internal constant PRVLCKT = 540 days;\\n\\n    uint internal immutable STARTED = block.timestamp;\\n\\n    uint public lastUserId;\\n\\n    struct User {\\n        uint uid;\\n        address sponsor; \\n        uint purchased; // total ctrl\\n        uint _lstVtd;\\n        uint spent; // total usdt worth\\n        uint earned; // total commissions in usdt\\n        mapping(uint => VestedToken) vestedTokens;\\n    }\\n\\n    struct VestedToken {\\n        uint uid;\\n        uint _amount;\\n        bool _claimed;\\n        uint _release;\\n    }\\n\\n    struct Stat {\\n        uint totalSold; // total ctrl sold\\n        uint totalVolm; // total usdt volume\\n        uint totalComm; // total commissions\\n    }\\n\\n    bool private inSwapAndLiquify;\\n\\n    mapping (address => User) public users;\\n\\n    Stat public stats;\\n\\n    modifier salesOpen() {\\n        require(block.timestamp < STARTED + SALEWDW, 'Sales Closed');\\n        _;\\n    }\\n\\n    modifier isAllowed() {\\n        require(!address(msg.sender).isContract(), \\\"NotAllowed\\\");\\n        _;\\n    }\\n\\n    modifier hasVested (uint _pchId) {\\n        require(users[msg.sender].vestedTokens[_pchId].uid == _pchId, 'NotFound');\\n        _;\\n    }\\n\\n    modifier hasRdyVested (uint _pchId) {\\n        require(users[msg.sender].vestedTokens[_pchId].uid == _pchId && \\n                users[msg.sender].vestedTokens[_pchId]._release <= block.timestamp, 'NotRdy');\\n        _;\\n    }\\n\\n    modifier hasNclmdVested (uint _pchId) {\\n        require(users[msg.sender].vestedTokens[_pchId].uid == _pchId && \\n                users[msg.sender].vestedTokens[_pchId]._release <= block.timestamp && \\n                !users[msg.sender].vestedTokens[_pchId]._claimed\\n                , 'NotRdy');\\n        _;\\n    }\\n    \\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    // Events [NewOrder, NewUser, TokenSent, CommissionSent]\\n    event NewUser(address indexed sender, address indexed sponsor);\\n    event NewOrder(address indexed sender, uint _amount, uint amount, string payoption);\\n    event TokenSent(address indexed sender, uint amount);\\n    event TokenVested(address indexed sender, uint amount);\\n    event VestedTokenClaimed(address indexed sender, uint pchId, uint amount);\\n    event CommissionSent(address indexed sender, uint amount);\\n\\n    constructor(){\\n        dev = msg.sender;\\n        _sysOps    = msg.sender; // CTRL engine test 0xC4807d8A76316873484f0dE8a89E48D78B7467F2 mainnet 0x04C42e3419Ff76B7E5f4E7e9428FB3C18D358525\\n        _usdToken  = IERC20(address(0x55d398326f99059fF775485246999027B3197955)); // testnet 0xC6Efc0f7AF6e0B3e413d8FdD339FAf4d9a6e2D8F 0xaB1a4d4f1D656d2450692D237fdD6C7f9146e814 // mainnet 0x55d398326f99059fF775485246999027B3197955\\n        _wbnbToken = IERC20(address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c)); // testnet 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd // mainnet 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\\n        _ctrlToken = IERC20(address(0x3645c60ce5679c950D629D0BCcfecf9d9Bd6E3B8)); // tesnet 0x8724A3850Df4F65c43a67de65A7a4ddA1FFc8F77 // mainnet 0x3645c60ce5679c950D629D0BCcfecf9d9Bd6E3B8\\n        IUniswapRouter _uniswapV2Router = IUniswapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); // testnet 0xD99D1c33F9fC3444f8101754aBC46c52416550D1 // mainnet 0x10ED43C718714eb63d5aA57B78B54704E256024E\\n        uniswapRouter = _uniswapV2Router;\\n    }\\n\\n    // Register User\\n    function register(address _sender, address _sponsor) private{\\n        lastUserId++;\\n        if(_sender == _sponsor || _sponsor == address(0) || users[_sponsor].uid == 0) \\n            _sponsor = dev;\\n        users[_sender].sponsor = _sponsor;\\n        users[_sender].uid = lastUserId;\\n        emit NewUser(_sender, _sponsor);\\n    }\\n\\n    // Credit user\\n    function credit(address _sender, uint _amount, bool _vtdtkn) private{\\n        uint tokenPrice = _vtdtkn ? PRVPRIC : INIPRIC;\\n        uint _tokenAmount = (_amount / tokenPrice) * DECIMAL;\\n        users[_sender].purchased += _tokenAmount;\\n        users[_sender].spent += _amount;\\n        if(!_vtdtkn){\\n            require(_ctrlToken.transferFrom(dev, _sender, _tokenAmount), 'txferFailed');\\n            emit TokenSent(_sender, _tokenAmount);\\n        }\\n        else {\\n            require(_ctrlToken.transferFrom(dev, address(this), _tokenAmount), 'txferFailed');\\n            emit TokenSent(address(this), _tokenAmount);\\n            // Vested Token\\n            users[_sender]._lstVtd++;\\n            uint _lstVtd = users[_sender]._lstVtd;\\n            VestedToken memory newVestedToken = VestedToken({\\n                uid: _lstVtd,\\n                _amount : _tokenAmount,\\n                _claimed : false,\\n                _release : block.timestamp + PRVLCKT\\n            });\\n            users[_sender].vestedTokens[_lstVtd] = newVestedToken;\\n            \\n            emit TokenVested(_sender, _tokenAmount);\\n        }\\n        stats.totalSold += _tokenAmount;\\n        stats.totalVolm += _amount;\\n    }\\n\\n    function disptachOrder(address _sender, uint _amount, bool _isUSDT) private{\\n        if(!_isUSDT){\\n            uint _contractBalance = _usdToken.balanceOf(address(this));\\n            swapBNBForUSDT(_amount);\\n            // USDT received\\n            _amount = _usdToken.balanceOf(address(this)) - _contractBalance;\\n        }\\n        // distribution\\n        uint _commission = _amount * COMMISS / DIVIDER; // 5%\\n        uint _mrktgservd = _amount * MARKTNG / DIVIDER; // 10%\\n        uint _initialLqt = _amount * INLQDTY / DIVIDER; // 40%\\n        uint _systmilLqt = _amount * STMLQTY / DIVIDER; // 25%\\n        // uint _projectmgt = _amount * PRJTRSC / DIVIDER; // 15%\\n        uint _teamRservd = _amount * TEAMRSV / DIVIDER; // 20%\\n        _usdToken.transfer(users[_sender].sponsor, _commission);\\n        _usdToken.transfer(_mrktgWlt, _mrktgservd);\\n        _usdToken.transfer(_stmrsrvd, _initialLqt);\\n        _usdToken.transfer(_sysOps, _systmilLqt);\\n        // _usdToken.transfer(_mangmntWlt, _projectmgt);\\n        _usdToken.transfer(_teamwrsrd, _teamRservd);\\n        emit CommissionSent(_sender, _commission);\\n        stats.totalComm += _commission;\\n    }\\n\\n    // Process Order\\n    function processOrder(address _sender, address _sponsor, \\n                        uint _amount, uint _usdtAmount, \\n                        bool _isUSDT, bool _vtdtkn) private{\\n        if(users[msg.sender].uid == 0) register(msg.sender, _sponsor);\\n        string memory payOption = \\\"BNB\\\";\\n        if(_isUSDT){ \\n            payOption = \\\"USDT\\\";\\n        }\\n        credit(_sender, _usdtAmount, _vtdtkn);\\n        disptachOrder(_sender, _amount, _isUSDT);\\n        emit NewOrder(_sender, _amount, _usdtAmount, payOption);\\n    }\\n\\n    // Purchase with BNB\\n    function purchase(address _sponsor, bool _vtdtkn) public payable isAllowed salesOpen nonReentrant{\\n        uint _amount = msg.value;\\n        uint oneBNBtoUSDT = getTokenAmount(address(_wbnbToken), address(_usdToken), (1 ether / MLTIPLR));\\n        uint _usdtvalue = _amount * oneBNBtoUSDT * MLTIPLR / DECIMAL;\\n        require(_usdtvalue >= MINPURC, 'req50USDT');\\n        processOrder(msg.sender, _sponsor, _amount, _usdtvalue, false, _vtdtkn);\\n    }\\n\\n    // Purchase with USDT\\n    function usdtPurchase(address _sponsor, uint _amount, bool _vtdtkn) public isAllowed salesOpen nonReentrant{\\n        require(_amount >= MINPURC, 'req50USDT');\\n        require(_usdToken.transferFrom(msg.sender, address(this), _amount), 'xferFailed');\\n        processOrder(msg.sender, _sponsor, _amount, _amount, true, _vtdtkn);\\n    }\\n\\n    // Claim Vested Tokens\\n    function claimVested(uint _pchId) public hasVested(_pchId) hasRdyVested(_pchId) hasNclmdVested(_pchId) {\\n        VestedToken storage _vestedToken = users[msg.sender].vestedTokens[_pchId];\\n        uint _tamount = _vestedToken._amount;\\n        _vestedToken._claimed = true;\\n        require(_ctrlToken.transfer(msg.sender, _tamount), 'txferFailed');\\n        emit TokenSent(msg.sender, _tamount);\\n        emit VestedTokenClaimed(msg.sender, _pchId, _tamount);\\n    }\\n    \\n    // get BNB_USDT rate\\n    // get CTRL_USDT rate\\n    function getTokenAmount(\\n        address _tokenA,\\n        address _tokenB,\\n        uint _amountIn\\n    ) private view returns (uint256 _tokens) {\\n        address[] memory path = new address[](2);\\n        path[0] = _tokenA;\\n        path[1] = _tokenB;\\n        uint[] memory amounts = uniswapRouter.getAmountsOut(_amountIn, path);\\n        return amounts[1];\\n    }\\n\\n    function swapBNBForUSDT(uint256 _amount) private lockTheSwap{\\n        // Swap BNB to BUSD for contest rewards.\\n        address[] memory path = new address[](2);\\n        path[0] = uniswapRouter.WETH();\\n        path[1] = address(_usdToken);\\n        // make the swap\\n        uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: _amount }(\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function getBNBRate() public view returns(uint _value){\\n        _value = getTokenAmount(address(_wbnbToken), address(_usdToken), (1 ether / MLTIPLR)); \\n        // fecthes from price panackageswap\\n        _value = _value * MLTIPLR;\\n    }\\n\\n    function processCallback(address _sender, uint _amount) private {\\n        if(!_sender.isContract()) {\\n            uint oneBNBtoUSDT = getTokenAmount(address(_wbnbToken), address(_usdToken), (1 ether / MLTIPLR));\\n            uint _usdtvalue = _amount * oneBNBtoUSDT * MLTIPLR / DECIMAL;\\n            processOrder(_sender, dev, _amount, _usdtvalue, false, false);\\n        }\\n        else if(_sender.isContract()) payable(_sysOps).transfer(_amount); // prevents contract from buying tokens\\n    }\\n\\n    receive () external payable nonReentrant {\\n        processCallback(msg.sender, msg.value);\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n}\\n\\ninterface IUniswapRouter {\\n    function WETH() external pure returns (address);\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.21;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\n\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier isHuman() {\\n        require(tx.origin == msg.sender, \\\"sorry humans only\\\");\\n        _;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CommissionSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"payoption\",\"type\":\"string\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"NewUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenVested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestedTokenClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_ctrlToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sysOps\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pchId\",\"type\":\"uint256\"}],\"name\":\"claimVested\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBNBRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_vtdtkn\",\"type\":\"bool\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVolm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalComm\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_vtdtkn\",\"type\":\"bool\"}],\"name\":\"usdtPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"purchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lstVtd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CoinstTrailPresales", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}