{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FunFund_sale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ncontract FunFundSale_v3 is Ownable {\\n    IERC20 public USDT;\\n    IERC20 public USDC;\\n    IERC20 public BUSD;\\n    IERC20 public FUND;\\n\\n    \\n    uint public dexTime = 1701385200;\\n    uint public min;\\n    uint public totalRisedUSD;\\n    uint public currentRound = 1;\\n    bool public whiteListEnable;\\n    mapping(address => bool) public whiteListAddress;\\n\\n    struct Round {\\n        uint amount;\\n        uint price;\\n        uint timeStart;\\n        uint timeEnd;\\n        uint timeUnclock;\\n        uint limitOneAddress; \\n        mapping(address => uint) purchased; \\n        uint sold;\\n        uint[] vestingTime;\\n        mapping(address => uint[]) vestingAmount;\\n        mapping(address => bool) bought;\\n    }\\n    mapping(uint => Round) public rounds; \\n\\n    struct Level {\\n        uint bonusReferrer;\\n        uint bonusReferral;\\n        uint purchased;\\n        uint minRefCounts;\\n    }\\n    mapping(uint => Level) public levels;\\n\\n    struct RefStats {\\n        uint myLevel;\\n        address myReferrer;\\n        uint refCounts;\\n        uint refPurchasesUSDT;\\n    }\\n    mapping(address => RefStats) public refStats;\\n\\n    constructor() {\\n        //3 FunFund DAO lover \\n        levels[1].bonusReferrer = 300; //3%\\n        levels[1].bonusReferral = 200; //2%\\n        levels[1].purchased = 50 * 10 ** 18; //50 USDT\\n\\n        //2 FunFund DAO Patron\\n        levels[2].minRefCounts = 100; //100 refferals\\n        levels[2].bonusReferrer = 500; //5%\\n        levels[2].bonusReferral = 200; //2%\\n        levels[2].purchased = 500 * 10 ** 18; //500 USDT\\n\\n        //1 FunFund DAO Ambassador  \\n        levels[3].minRefCounts = 200; //200 refferals\\n        levels[3].bonusReferrer = 1000; //10%\\n        levels[3].bonusReferral = 300; //3%\\n        levels[3].purchased = 5000 * 10 ** 18; //5000 USDT\\n\\n        setRound(1,60000000000000000000,17000000000000,1692118800,1693328400,1693425994,2941176400000000000);\\n        setRound(2,2000000000000000000000,17300000000000,1697274000,1698660000,1697274000,100000000000000000000);\\n\\n        USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\\n        USDC = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\\n        BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\\n        FUND = IERC20(0x91c04B958ED68110AC45d850ebbdF5bD68C47B5f);\\n    }\\n\\n    function buy(uint _round, uint _amount, address _referrer, uint _currency) public {\\n        require(_amount >= min);\\n        require(_currency == 1 || _currency == 2 || _currency == 3);\\n        //Checks currency\\n        IERC20 _STABLE;\\n        _currency == 1 ? _STABLE = USDT : _currency == 2 ? _STABLE = BUSD : _STABLE = USDC;\\n        //Checks WL\\n        if(whiteListEnable) {\\n            require(whiteListAddress[msg.sender]);\\n        }\\n        //Checks max amount for one address if it isn't level 1\\n        if(refStats[msg.sender].myLevel != 3) {\\n            require(rounds[_round].purchased[msg.sender] + _amount <= rounds[_round].limitOneAddress);\\n        } \\n        //Checks max amount for round\\n        require(rounds[_round].sold + _amount <= rounds[_round].amount);\\n        //Checks time start and time end\\n        require(rounds[_round].timeStart < block.timestamp && block.timestamp < rounds[_round].timeEnd);\\n        //Sends stable coins to sale contract \\n        uint _stable = _amount/(1 * 10 ** FUND.decimals()) * rounds[_round].price;\\n        _STABLE.transferFrom(msg.sender, address(this), _stable);\\n        totalRisedUSD += _stable;\\n        //Writes amount FUND tokens\\n        rounds[_round].purchased[msg.sender] += _amount;\\n        //Adds vesting\\n        addVesting(msg.sender, _round, _amount);\\n        //Stats sold\\n        rounds[_round].sold += _amount;\\n\\n        //Sets refferal to referrer\\n        if(_referrer != 0x0000000000000000000000000000000000000000 && refStats[msg.sender].myReferrer == 0x0000000000000000000000000000000000000000) {\\n            refStats[msg.sender].myReferrer = _referrer;\\n            refStats[_referrer].refCounts++;\\n        } \\n\\n        if(refStats[msg.sender].myReferrer != 0x0000000000000000000000000000000000000000) {\\n            refStats[_referrer].refPurchasesUSDT += _stable;\\n        }\\n\\n        //Referrer and referral rewards\\n        address _myReferrer = refStats[msg.sender].myReferrer;\\n        checkLvl(_myReferrer);\\n        uint _lvl = refStats[_myReferrer].myLevel;\\n\\n        if(_myReferrer != 0x0000000000000000000000000000000000000000 && _lvl != 0) {\\n            //Adds FUND to referrer\\n            addVesting(_myReferrer, _round, calculate(levels[_lvl].bonusReferrer, _amount));\\n            //Adds FUND to refereal\\n            addVesting(msg.sender, _round, calculate(levels[_lvl].bonusReferral, _amount));\\n        }\\n    }\\n\\n    function claim(uint _round, uint _vesting) public {\\n        //Checks zero amount and climed\\n        require(rounds[_round].vestingAmount[msg.sender][_vesting] != 0);\\n        //Checks time unlock\\n        require(rounds[_round].vestingTime[_vesting] < block.timestamp);\\n        //Claim FUND tokens\\n        FUND.transfer(msg.sender, rounds[_round].vestingAmount[msg.sender][_vesting]);\\n        rounds[_round].vestingAmount[msg.sender][_vesting] = 0;\\n    }\\n\\n    // Counting an percentage by basis points\\n    function calculate(uint256 amount, uint256 bps) private pure returns (uint256) {\\n        require((amount * bps) >= 10000);\\n        return amount * bps / 10000;\\n    }\\n\\n    function addVesting(address _sender, uint _round, uint _amount) private {\\n        //Adds vesting\\n        if(_round == 1) {\\n            //Check bought or not early\\n            if(rounds[_round].bought[_sender] == false) {\\n                rounds[_round].vestingAmount[_sender] = [0,0,0,0,0,0,0,0,0,0,0]; \\n            }\\n            //20%\\n            rounds[_round].vestingAmount[_sender][0] += calculate( _amount, 2000);\\n            //80%\\n            uint _amountVesting = calculate( _amount, 8000);\\n            //10% next 10 month\\n            for (uint i=1; i < 11; i++) {\\n                rounds[_round].vestingAmount[_sender][i] += calculate( _amountVesting, 1000);\\n            }\\n        } else {\\n            //Check bought or not early\\n            if(rounds[_round].bought[_sender] == false) {\\n                rounds[_round].vestingAmount[_sender] = [0,0,0];\\n            }\\n            //20%\\n            rounds[_round].vestingAmount[_sender][0] += calculate( _amount, 2000);\\n            //80%\\n            uint _amountVesting = calculate( _amount, 8000);\\n            //40% and 40%\\n            for (uint i=1; i < 3; i++) {\\n                rounds[_round].vestingAmount[_sender][i] += calculate( _amountVesting, 5000);\\n            }\\n        }\\n\\n        if(rounds[_round].bought[_sender] == false) {\\n            rounds[_round].bought[_sender] = true;\\n        }\\n    }\\n\\n    function checkLvl(address _addr) private {\\n        if(\\n            refStats[_addr].myLevel == 0 &&\\n            refStats[_addr].refPurchasesUSDT > levels[1].purchased && \\n            refStats[_addr].refPurchasesUSDT < levels[2].purchased  \\n         ) {\\n             refStats[_addr].myLevel = 1;\\n        }\\n\\n        if(\\n            refStats[_addr].myLevel == 1 &&\\n            refStats[_addr].refPurchasesUSDT > levels[2].purchased && \\n            refStats[_addr].refPurchasesUSDT < levels[3].purchased && \\n            refStats[_addr].refCounts > levels[2].minRefCounts && \\n            refStats[_addr].refCounts < levels[3].minRefCounts\\n         ) {\\n             refStats[_addr].myLevel = 2;\\n        }\\n\\n        if(\\n            refStats[_addr].myLevel == 2 &&\\n            refStats[_addr].refPurchasesUSDT > levels[3].purchased && \\n            refStats[_addr].refCounts > levels[3].minRefCounts \\n         ) {\\n             refStats[_addr].myLevel = 3;\\n        }\\n    }\\n\\n    function vestingTime(uint _round) public view returns (uint[] memory) {\\n        return rounds[_round].vestingTime;\\n    }\\n\\n    function purchased(uint _round, address _adr) public view returns (uint[] memory) {\\n        return rounds[_round].vestingAmount[_adr];\\n    }\\n\\n    //Admin functions\\n    function buyAdm(address _sender, uint _round, uint _amount, address _referrer) public onlyOwner {\\n        require(_amount >= min);\\n        //Checks WL\\n        if(whiteListEnable) {\\n            require(whiteListAddress[_sender]);\\n        }\\n        //Checks max amount for one address if it isn't level 1\\n        if(refStats[_sender].myLevel != 3) {\\n            require(rounds[_round].purchased[_sender] + _amount <= rounds[_round].limitOneAddress);\\n        } \\n        //Checks max amount for round\\n        require(rounds[_round].sold + _amount <= rounds[_round].amount);\\n        //Checks time start and time end\\n        require(rounds[_round].timeStart < block.timestamp && block.timestamp < rounds[_round].timeEnd);\\n        //Sends stable coins to sale contract \\n        uint _stable = _amount/(1 * 10 ** FUND.decimals()) * rounds[_round].price;\\n        totalRisedUSD += _stable;\\n        //Writes amount FUND tokens\\n        rounds[_round].purchased[_sender] += _amount;\\n        //Adds vesting\\n        addVesting(_sender, _round, _amount);\\n        //Stats sold\\n        rounds[_round].sold += _amount;\\n\\n        //Sets refferal to referrer\\n        if(_referrer != 0x0000000000000000000000000000000000000000 && refStats[_sender].myReferrer == 0x0000000000000000000000000000000000000000) {\\n            refStats[_sender].myReferrer = _referrer;\\n            refStats[_referrer].refCounts++;\\n        } \\n\\n        if(refStats[_sender].myReferrer != 0x0000000000000000000000000000000000000000) {\\n            refStats[_referrer].refPurchasesUSDT += _stable;\\n        }\\n\\n        //Referrer and referral rewards\\n        address _myReferrer = refStats[_sender].myReferrer;\\n        checkLvl(_myReferrer);\\n        uint _lvl = refStats[_myReferrer].myLevel;\\n\\n        if(_myReferrer != 0x0000000000000000000000000000000000000000 && _lvl != 0) {\\n            //Adds FUND to referrer\\n            addVesting(_myReferrer, _round, calculate(levels[_lvl].bonusReferrer, _amount));\\n            //Adds FUND to refereal\\n            addVesting(_sender, _round, calculate(levels[_lvl].bonusReferral, _amount));\\n        }\\n    }\\n\\n    function setRound(\\n        uint _round,\\n        uint _amount,\\n        uint _price,\\n        uint _timeStart,\\n        uint _timeEnd,\\n        uint _timeUnclock,\\n        uint _limitOneAddress\\n    ) public onlyOwner {\\n        rounds[_round].amount = _amount;\\n        rounds[_round].price = _price;\\n        rounds[_round].timeStart = _timeStart;\\n        rounds[_round].timeEnd = _timeEnd;\\n        rounds[_round].timeUnclock = _timeUnclock;\\n        rounds[_round].limitOneAddress = _limitOneAddress;\\n\\n        uint _time;\\n        \\n        if(_round == 1) {\\n            _time = _timeUnclock;\\n            rounds[_round].vestingTime = [0,0,0,0,0,0,0,0,0,0,0];\\n            rounds[_round].vestingTime[0] = _timeUnclock;\\n\\n            for (uint i=1; i <= 10; i++) {\\n                _time += 2678400;\\n                rounds[_round].vestingTime[i] = _time;\\n            }\\n        } else {\\n            _time = dexTime;\\n            rounds[_round].vestingTime = [0,0,0];\\n            rounds[_round].vestingTime[0] = _timeUnclock;\\n\\n            for (uint i=1; i <= 2; i++) {\\n                _time += 2678400;\\n                rounds[_round].vestingTime[i] = _time;\\n            }\\n        }\\n    }\\n\\n    function setDexTime(uint _time) public onlyOwner {\\n        for (uint r=1; r <= currentRound; r++) {\\n                for (uint i=1; i < 3; i++) {\\n                _time += 2678400;\\n                rounds[r].vestingTime[1] = _time;\\n            }\\n        }\\n\\n        dexTime = _time;\\n    }\\n\\n    function changeRound(uint _round) public onlyOwner {\\n        currentRound = _round;\\n    }\\n\\n    function setMin(uint _min) public onlyOwner {\\n        min = _min;\\n    }\\n\\n    function enableWhiteList(bool _wl) public onlyOwner {\\n        whiteListEnable = _wl;\\n    }\\n\\n    function addWhitelist(address[] memory _adr) public onlyOwner {\\n        for (uint i=0; i < _adr.length; i++) {\\n            whiteListAddress[_adr[i]] = true;\\n        }\\n    }\\n\\n    function removeWhitelist(address[] memory _adr) public onlyOwner {\\n        for (uint i=0; i < _adr.length; i++) {\\n            whiteListAddress[_adr[i]] = false;\\n        }\\n    }\\n\\n    function withdrawStable(uint _amount, address _adr, uint _currency) public onlyOwner {\\n        require(_currency == 1 || _currency == 2 || _currency == 3);\\n        //Checks currency\\n        IERC20 _STABLE;\\n        _currency == 1 ? _STABLE = USDT : _currency == 2 ? _STABLE = BUSD : _STABLE = USDC;\\n        USDT.transfer(_adr, _amount);\\n    }\\n\\n    function withdrawFUND(uint _amount, address _adr) public onlyOwner {\\n        FUND.transfer(_adr, _amount);\\n    }\\n\\n    function setContracts(IERC20 _usdt, IERC20 _usdc, IERC20 _busd, IERC20 _fundToken) public onlyOwner {\\n        USDT = _usdt;\\n        USDC = _usdc;\\n        BUSD = _busd;\\n        FUND = _fundToken;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUND\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_adr\",\"type\":\"address[]\"}],\"name\":\"addWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currency\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"buyAdm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"changeRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vesting\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_wl\",\"type\":\"bool\"}],\"name\":\"enableWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusReferrer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusReferral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRefCounts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"purchased\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"myLevel\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"myReferrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refCounts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refPurchasesUSDT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_adr\",\"type\":\"address[]\"}],\"name\":\"removeWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeUnclock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitOneAddress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_busd\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_fundToken\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setDexTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min\",\"type\":\"uint256\"}],\"name\":\"setMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeUnclock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limitOneAddress\",\"type\":\"uint256\"}],\"name\":\"setRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRisedUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"vestingTime\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteListAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whiteListEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"withdrawFUND\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currency\",\"type\":\"uint256\"}],\"name\":\"withdrawStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FunFundSale_v3", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}