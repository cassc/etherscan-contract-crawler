{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/diamond/facets/PredictionManagerFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../utils/Constants.sol\\\";\\nimport {ZeroAddress} from \\\"../../utils/Errors.sol\\\";\\nimport \\\"../interfaces/IPredictionManager.sol\\\";\\nimport \\\"../libraries/LibPredictionManager.sol\\\";\\nimport \\\"../libraries/LibAccessControlEnumerable.sol\\\";\\n\\ncontract PredictionManagerFacet is IPredictionManager {\\n\\n    function addPredictionPair(\\n        address base, string calldata name, PredictionPeriod[] calldata predictionPeriods\\n    ) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        _predictionPeriodsCheck(predictionPeriods);\\n        LibPredictionManager.addPredictionPair(base, name, predictionPeriods);\\n    }\\n\\n    function removePredictionPair(address base) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        LibPredictionManager.removePredictionPair(base);\\n    }\\n\\n    function updatePredictionPairStatus(address base, PredictionPairStatus status) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        LibPredictionManager.updatePredictionPairStatus(base, status);\\n    }\\n\\n    function updatePredictionPairMaxCap(address base, PeriodCap[] calldata periodCaps) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        LibPredictionManager.PredictionPair storage pp = LibPredictionManager.requireExists(base);\\n        for (uint256 i = 0; i < periodCaps.length;) {\\n            PeriodCap memory ic = periodCaps[i];\\n            LibPredictionManager.updatePredictionPairPeriodMaxCap(pp, ic.period, ic.maxUpUsd, ic.maxDownUsd);\\n            unchecked{++i;}\\n        }\\n    }\\n\\n    function updatePredictionPairWinRatio(address base, PeriodWinRatio[] calldata periodWinRatios) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        LibPredictionManager.PredictionPair storage pp = LibPredictionManager.requireExists(base);\\n        for (uint256 i = 0; i < periodWinRatios.length;) {\\n            PeriodWinRatio memory iwr = periodWinRatios[i];\\n            LibPredictionManager.updatePredictionPairPeriodWinRatio(pp, iwr.period, iwr.winRatio);\\n            unchecked{++i;}\\n        }\\n    }\\n\\n    function updatePredictionPairFee(address base, PeriodFee[] calldata periodFees) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        LibPredictionManager.PredictionPair storage pp = LibPredictionManager.requireExists(base);\\n        for (uint256 i = 0; i < periodFees.length;) {\\n            PeriodFee memory iFee = periodFees[i];\\n            LibPredictionManager.updatePredictionPairPeriodFee(pp, iFee.period, iFee.openFeeP, iFee.winCloseFeeP, iFee.loseCloseFeeP);\\n            unchecked{++i;}\\n        }\\n    }\\n\\n    function addPeriodForPredictionPair(address base, PredictionPeriod[] calldata predictionPeriods) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        _predictionPeriodsCheck(predictionPeriods);\\n        LibPredictionManager.PredictionPair storage pp = LibPredictionManager.requireExists(base);\\n        LibPredictionManager.addPeriodForPredictionPair(pp, predictionPeriods);\\n    }\\n\\n    function replacePredictionPairPeriod(address base, PredictionPeriod[] calldata predictionPeriods) external override {\\n        LibAccessControlEnumerable.checkRole(Constants.ADMIN_ROLE);\\n        _isBaseNonZero(base);\\n        _predictionPeriodsCheck(predictionPeriods);\\n        LibPredictionManager.PredictionPair storage pp = LibPredictionManager.requireExists(base);\\n        LibPredictionManager.replacePredictionPairPeriod(pp, predictionPeriods);\\n    }\\n\\n    function _isBaseNonZero(address base) private pure {\\n        if (base == address(0)) revert ZeroAddress();\\n    }\\n\\n    function _predictionPeriodsCheck(PredictionPeriod[] calldata predictionPeriods) private pure {\\n        require(predictionPeriods.length > 0, \\\"PredictionManagerFacet: contains at least one period\\\");\\n        for (uint256 i = 0; i < predictionPeriods.length;) {\\n            PredictionPeriod memory pi = predictionPeriods[i];\\n            require(pi.winRatio > 5000 && pi.winRatio <= 1e4, \\\"PredictionManagerFacet: invalid winRatio\\\");\\n            require(\\n                pi.openFeeP < 1e4 && pi.winCloseFeeP < 1e4 && pi.loseCloseFeeP < 1e4,\\n                \\\"PredictionManagerFacet: invalid openFeeP or closeFeeP\\\"\\n            );\\n            unchecked{++i;}\\n        }\\n    }\\n\\n    function getPredictionPairByBase(address base) public view override returns (PredictionPairView memory) {\\n        LibPredictionManager.PredictionPair storage pp = LibPredictionManager.predictionManagerStorage().predictionPairs[base];\\n        PredictionPeriod[] memory predictionPeriods = new PredictionPeriod[](pp.periods.length);\\n        for (uint256 i = 0; i < pp.periods.length;) {\\n            predictionPeriods[i] = pp.predictionPeriods[pp.periods[i]];\\n            unchecked{++i;}\\n        }\\n        return PredictionPairView(pp.name, pp.base, predictionPeriods);\\n    }\\n\\n    function predictionPairs(uint start, uint8 size) external view override returns (PredictionPairView[] memory predictPairViews) {\\n        LibPredictionManager.PredictionManagerStorage storage pms = LibPredictionManager.predictionManagerStorage();\\n        if (start >= pms.predictionPairBases.length || size == 0) {\\n            predictPairViews = new PredictionPairView[](0);\\n        } else {\\n            uint count = pms.predictionPairBases.length - start > size ? size : pms.predictionPairBases.length - start;\\n            predictPairViews = new PredictionPairView[](count);\\n            for (uint256 i = 0; i < count;) {\\n                uint256 index;\\n                unchecked{index = i + start;}\\n                predictPairViews[i] = getPredictionPairByBase(pms.predictionPairBases[index]);\\n                unchecked{++i;}\\n            }\\n        }\\n        return predictPairViews;\\n    }\\n\\n    function getPredictionPeriod(address base, Period period) external view override returns (PredictionPeriod memory) {\\n        return LibPredictionManager.predictionManagerStorage().predictionPairs[base].predictionPeriods[period];\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nerror ZeroAddress();\\n\\ninterface IPriceFacadeError {\\n    error NonexistentRequestId(bytes32 requestId);\\n}\"\r\n    },\r\n    \"/contracts/utils/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ntype Price8 is uint64;\\ntype Qty10 is uint80;\\ntype Usd18 is uint96;\\n\\nlibrary Constants {\\n\\n    /*-------------------------------- Role --------------------------------*/\\n    // 0x0000000000000000000000000000000000000000000000000000000000000000\\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\\n    // 0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775\\n    bytes32 constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    // 0xfc425f2263d0df187444b70e47283d622c70181c5baebb1306a01edba1ce184c\\n    bytes32 constant DEPLOYER_ROLE = keccak256(\\\"DEPLOYER_ROLE\\\");\\n    // 0x62150a51582c26f4255242a3c4ca35fb04250e7315069523d650676aed01a56a\\n    bytes32 constant TOKEN_OPERATOR_ROLE = keccak256(\\\"TOKEN_OPERATOR_ROLE\\\");\\n    // 0xa6fbd0d4ef0ac50b4de984ab8f303863596293cce6d67dd6111979bcf56abe74\\n    bytes32 constant STAKE_OPERATOR_ROLE = keccak256(\\\"STAKE_OPERATOR_ROLE\\\");\\n    // 0xc24d2c87036c9189cc45e221d5dff8eaffb4966ee49ea36b4ffc88a2d85bf890\\n    bytes32 constant PRICE_FEED_OPERATOR_ROLE = keccak256(\\\"PRICE_FEED_OPERATOR_ROLE\\\");\\n    // 0x04fcf77d802b9769438bfcbfc6eae4865484c9853501897657f1d28c3f3c603e\\n    bytes32 constant PAIR_OPERATOR_ROLE = keccak256(\\\"PAIR_OPERATOR_ROLE\\\");\\n    // 0xfc8737ab85eb45125971625a9ebdb75cc78e01d5c1fa80c4c6e5203f47bc4fab\\n    bytes32 constant KEEPER_ROLE = keccak256(\\\"KEEPER_ROLE\\\");\\n    // 0x4e89f34ce8e0125b1b19130806ace319a8a06b7e1b4d6ef98c0eac043b6f119a\\n    bytes32 constant PREDICTION_KEEPER_ROLE = keccak256(\\\"PREDICTION_KEEPER_ROLE\\\");\\n    // 0x7d867aa9d791a9a4be418f90a2f248aa2c5f1348317792a6f6412f94df9819f7\\n    bytes32 constant PRICE_FEEDER_ROLE = keccak256(\\\"PRICE_FEEDER_ROLE\\\");\\n    // 0x8227712ef8ad39d0f26f06731ef0df8665eb7ada7f41b1ee089adf3c238862a2\\n    bytes32 constant MONITOR_ROLE = keccak256(\\\"MONITOR_ROLE\\\");\\n\\n    /*-------------------------------- Decimals --------------------------------*/\\n    uint8 constant public PRICE_DECIMALS = 8;\\n    uint8 constant public QTY_DECIMALS = 10;\\n    uint8 constant public USD_DECIMALS = 18;\\n\\n    uint16 constant public BASIS_POINTS_DIVISOR = 1e4;\\n    uint16 constant public MAX_LEVERAGE = 1e3;\\n    int256 constant public FUNDING_FEE_RATE_DIVISOR = 1e18;\\n    uint8 constant public FEED_DELAY_BLOCK = 10;\\n    uint8 constant public MAX_REQUESTS_PER_PAIR_IN_BLOCK = 100;\\n    uint256 constant public TIME_LOCK_DELAY = 2 hours;\\n    uint256 constant public TIME_LOCK_GRACE_PERIOD = 24 hours;\\n}\\n\"\r\n    },\r\n    \"/contracts/diamond/libraries/LibPredictionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../interfaces/IPriceFacade.sol\\\";\\nimport {Period, PredictionPairStatus, PredictionPeriod} from  \\\"../interfaces/IPredictionManager.sol\\\";\\nimport {IPredictUpDown, PredictionMarket} from  \\\"../interfaces/IPredictUpDown.sol\\\";\\n\\nlibrary LibPredictionManager {\\n\\n    bytes32 constant PREDICTION_MANAGER_STORAGE_POSITION = keccak256(\\\"apollox.prediction.manager.storage\\\");\\n\\n    struct PredictionPair {\\n        string name;\\n        address base;\\n        uint16 basePosition;\\n        mapping(Period => PredictionPeriod) predictionPeriods;\\n        Period[] periods;\\n    }\\n\\n    struct PredictionManagerStorage {\\n        mapping(address base => PredictionPair) predictionPairs;\\n        address[] predictionPairBases;\\n    }\\n\\n    function predictionManagerStorage() internal pure returns (PredictionManagerStorage storage pms) {\\n        bytes32 position = PREDICTION_MANAGER_STORAGE_POSITION;\\n        assembly {\\n            pms.slot := position\\n        }\\n    }\\n\\n    event AddPredictionPair(address indexed base, string name, PredictionPeriod[] predictionPeriods);\\n    event RemovePredictionPair(address indexed base);\\n    event UpdatePredictionPairStatus(address indexed base, PredictionPairStatus status);\\n    event UpdatePredictionPairPeriodMaxCap(address indexed base, Period indexed period, uint256 maxUpUsd, uint256 maxDownUsd);\\n    event UpdatePredictionPairPeriodWinRatio(address indexed base, Period indexed period, uint16 winRatio);\\n    event UpdatePredictionPairPeriodFee(address indexed base, Period indexed period, uint16 openFeeP, uint16 winCloseFeeP, uint16 loseCloseFeeP);\\n    event AddPeriodForPredictionPair(address indexed base, PredictionPeriod[] predictionPeriods);\\n    event ReplacePredictionPairPeriod(address indexed base, PredictionPeriod[] predictionPeriods);\\n\\n    function requireExists(address base) internal view returns (PredictionPair storage) {\\n        PredictionManagerStorage storage pms = predictionManagerStorage();\\n        PredictionPair storage pp = pms.predictionPairs[base];\\n        require(pp.base != address(0), \\\"LibPredictionManager: Predict pair not exist\\\");\\n        return pp;\\n    }\\n\\n    function addPredictionPair(address base, string calldata name, PredictionPeriod[] calldata predictionPeriods) internal {\\n        PredictionManagerStorage storage pms = predictionManagerStorage();\\n        PredictionPair storage pp = pms.predictionPairs[base];\\n        require(pp.base == address(0), \\\"LibPredictionManager: Predict pair already exists\\\");\\n        require(IPriceFacade(address(this)).getPrice(base) > 0, \\\"LibPredictionManager: No price feed has been configured for the predict pair\\\");\\n        pp.base = base;\\n        pp.name = name;\\n        pp.basePosition = uint16(pms.predictionPairBases.length);\\n        pms.predictionPairBases.push(base);\\n        Period[] memory periods = new Period[](predictionPeriods.length);\\n        for (uint256 i = 0; i < predictionPeriods.length;) {\\n            PredictionPeriod memory pi = predictionPeriods[i];\\n            pp.predictionPeriods[pi.period] = pi;\\n            periods[i] = pi.period;\\n            unchecked{++i;}\\n        }\\n        pp.periods = periods;\\n        emit AddPredictionPair(base, name, predictionPeriods);\\n    }\\n\\n    function removePredictionPair(address base) internal {\\n        PredictionPair storage pp = requireExists(base);\\n        PredictionManagerStorage storage pms = predictionManagerStorage();\\n\\n        PredictionMarket[] memory markets = IPredictUpDown(address(this)).getPredictionMarket(base, pp.periods);\\n        for (uint256 i = 0; i < markets.length;) {\\n            PredictionMarket memory pm = markets[i];\\n            if (pm.upUsd > 0 || pm.downUsd > 0) {\\n                revert(\\\"LibPredictionManager: There are still unclosed predictions.\\\");\\n            }\\n            unchecked{++i;}\\n        }\\n        _removeAllPeriodFromPredictionPair(pp);\\n        uint lastPosition = pms.predictionPairBases.length - 1;\\n        uint basePosition = pp.basePosition;\\n        if (basePosition != lastPosition) {\\n            address lastBase = pms.predictionPairBases[lastPosition];\\n            pms.predictionPairBases[basePosition] = lastBase;\\n            pms.predictionPairs[lastBase].basePosition = uint16(basePosition);\\n        }\\n        pms.predictionPairBases.pop();\\n        delete pms.predictionPairs[base];\\n        emit RemovePredictionPair(base);\\n    }\\n\\n    function updatePredictionPairStatus(address base, PredictionPairStatus status) internal {\\n        PredictionPair storage pp = requireExists(base);\\n        for (uint256 i = 0; i < pp.periods.length;) {\\n            pp.predictionPeriods[pp.periods[i]].status = status;\\n            unchecked{++i;}\\n        }\\n        emit UpdatePredictionPairStatus(base, status);\\n    }\\n\\n    function _requireExistsPeriod(PredictionPair storage pp, Period period) private view returns (PredictionPeriod storage){\\n        PredictionPeriod storage pi = pp.predictionPeriods[period];\\n        require(pi.winRatio > 0, \\\"LibPredictionManager: The period does not exist.\\\");\\n        return pi;\\n    }\\n\\n    function updatePredictionPairPeriodMaxCap(\\n        PredictionPair storage pp, Period period, uint256 maxUpUsd, uint256 maxDownUsd\\n    ) internal {\\n        PredictionPeriod storage pi = _requireExistsPeriod(pp, period);\\n        pi.maxUpUsd = maxUpUsd;\\n        pi.maxDownUsd = maxDownUsd;\\n        emit UpdatePredictionPairPeriodMaxCap(pp.base, period, maxUpUsd, maxDownUsd);\\n    }\\n\\n    function updatePredictionPairPeriodWinRatio(PredictionPair storage pp, Period period, uint16 winRatio) internal {\\n        PredictionPeriod storage pi = _requireExistsPeriod(pp, period);\\n        pi.winRatio = winRatio;\\n        emit UpdatePredictionPairPeriodWinRatio(pp.base, period, winRatio);\\n    }\\n\\n    function updatePredictionPairPeriodFee(\\n        PredictionPair storage pp, Period period, uint16 openFeeP, uint16 winCloseFeeP, uint16 loseCloseFeeP\\n    ) internal {\\n        PredictionPeriod storage pi = _requireExistsPeriod(pp, period);\\n        pi.openFeeP = openFeeP;\\n        pi.winCloseFeeP = winCloseFeeP;\\n        pi.loseCloseFeeP = loseCloseFeeP;\\n        emit UpdatePredictionPairPeriodFee(pp.base, period, openFeeP, winCloseFeeP, loseCloseFeeP);\\n    }\\n\\n    function addPeriodForPredictionPair(PredictionPair storage pp, PredictionPeriod[] calldata predictionPeriods) internal {\\n        for (uint256 i = 0; i < predictionPeriods.length;) {\\n            PredictionPeriod calldata pi = predictionPeriods[i];\\n            require(pp.predictionPeriods[pi.period].winRatio == 0, \\\"LibPredictionManager: The period already exists\\\");\\n            pp.predictionPeriods[pi.period] = pi;\\n            pp.periods.push(pi.period);\\n            unchecked{++i;}\\n        }\\n        emit AddPeriodForPredictionPair(pp.base, predictionPeriods);\\n    }\\n\\n    function replacePredictionPairPeriod(PredictionPair storage pp, PredictionPeriod[] calldata predictionPeriods) internal {\\n        _removeAllPeriodFromPredictionPair(pp);\\n        for (uint256 i = 0; i < predictionPeriods.length;) {\\n            PredictionPeriod calldata pi = predictionPeriods[i];\\n            pp.predictionPeriods[pi.period] = pi;\\n            pp.periods.push(pi.period);\\n            unchecked{++i;}\\n        }\\n        emit ReplacePredictionPairPeriod(pp.base, predictionPeriods);\\n    }\\n\\n    function _removeAllPeriodFromPredictionPair(PredictionPair storage pp) private {\\n        uint oldCount = pp.periods.length;\\n        for (uint256 i = 0; i < oldCount;) {\\n            Period period = pp.periods[i];\\n            delete pp.predictionPeriods[period];\\n            unchecked{++i;}\\n        }\\n        for (uint256 i = 0; i < oldCount;) {\\n            pp.periods.pop();\\n            unchecked{++i;}\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/diamond/libraries/LibAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nlibrary LibAccessControlEnumerable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    bytes32 constant ACCESS_CONTROL_STORAGE_POSITION = keccak256(\\\"apollox.access.control.storage\\\");\\n\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct AccessControlStorage {\\n        mapping(bytes32 => RoleData) roles;\\n        mapping(bytes32 => EnumerableSet.AddressSet) roleMembers;\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function accessControlStorage() internal pure returns (AccessControlStorage storage acs) {\\n        bytes32 position = ACCESS_CONTROL_STORAGE_POSITION;\\n        assembly {\\n            acs.slot := position\\n        }\\n    }\\n\\n    function checkRole(bytes32 role) internal view {\\n        checkRole(role, msg.sender);\\n    }\\n\\n    function checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n            string(\\n                abi.encodePacked(\\n                    \\\"AccessControl: account \\\",\\n                    Strings.toHexString(account),\\n                    \\\" is missing role \\\",\\n                    Strings.toHexString(uint256(role), 32)\\n                )\\n            )\\n            );\\n        }\\n    }\\n\\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\\n        AccessControlStorage storage acs = accessControlStorage();\\n        return acs.roles[role].members[account];\\n    }\\n\\n    function grantRole(bytes32 role, address account) internal {\\n        AccessControlStorage storage acs = accessControlStorage();\\n        if (!hasRole(role, account)) {\\n            acs.roles[role].members[account] = true;\\n            emit RoleGranted(role, account, msg.sender);\\n            acs.roleMembers[role].add(account);\\n        }\\n    }\\n\\n    function revokeRole(bytes32 role, address account) internal {\\n        AccessControlStorage storage acs = accessControlStorage();\\n        if (hasRole(role, account)) {\\n            acs.roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, msg.sender);\\n            acs.roleMembers[role].remove(account);\\n        }\\n    }\\n\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        AccessControlStorage storage acs = accessControlStorage();\\n        bytes32 previousAdminRole = acs.roles[role].adminRole;\\n        acs.roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n}\"\r\n    },\r\n    \"/contracts/diamond/interfaces/IPriceFacade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nenum RequestType {CLOSE, OPEN, PREDICT}\\n\\ninterface IPriceFacade {\\n\\n    struct Config {\\n        uint16 lowPriceGapP;\\n        uint16 highPriceGapP;\\n        uint16 maxDelay;\\n        uint16 triggerLowPriceGapP;   // 1e4\\n        uint16 triggerHighPriceGapP;  // 1e4\\n    }\\n\\n    struct PriceCallbackParam {\\n        bytes32 requestId;\\n        uint64 price;\\n    }\\n\\n    function setLowAndHighPriceGapP(uint16 lowPriceGapP, uint16 highPriceGapP) external;\\n\\n    function setTriggerLowAndHighPriceGapP(uint16 triggerLowPriceGapP, uint16 triggerHighPriceGapP) external;\\n\\n    function setMaxDelay(uint16 maxDelay) external;\\n\\n    function getPriceFacadeConfig() external view returns (Config memory);\\n\\n    function getPrice(address token) external view returns (uint256);\\n\\n    function getPriceFromCacheOrOracle(address token) external view returns (uint64 price, uint40 updatedAt);\\n\\n    function requestPrice(bytes32 tradeHash, address token, RequestType requestType) external;\\n\\n    function requestPriceCallback(bytes32 requestId, uint64 price) external;\\n\\n    function batchRequestPriceCallback(PriceCallbackParam[] calldata params) external;\\n\\n    function confirmTriggerPrice(address token, uint64 price) external returns (bool, uint64, uint64);\\n}\\n\"\r\n    },\r\n    \"/contracts/diamond/interfaces/IPredictionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nenum Period{MINUTE1, MINUTE5, MINUTE10, MINUTE15, MINUTE30, HOUR1, HOUR2, HOUR3, HOUR4, HOUR6, HOUR8, HOUR12, DAY1}\\nenum PredictionPairStatus{AVAILABLE, CLOSE_ONLY, CLOSED}\\n\\nstruct PredictionPeriod {\\n    uint256 maxUpUsd;     // USD 1e18\\n    uint256 maxDownUsd;   // USD 1e18\\n    Period period;\\n    PredictionPairStatus status;\\n    uint16 winRatio;      // 1e4\\n    uint16 openFeeP;      // 1e4\\n    uint16 winCloseFeeP;  // 1e4\\n    uint16 loseCloseFeeP; // 1e4\\n}\\n\\ninterface IPredictionManager {\\n\\n    event AddPredictionPair(address indexed base, string name, PredictionPeriod[] predictionPeriods);\\n    event RemovePredictionPair(address indexed base);\\n    event UpdatePredictionPairStatus(address indexed base, PredictionPairStatus status);\\n    event UpdatePredictionPairPeriodMaxCap(address indexed base, Period indexed period, uint256 maxUpUsd, uint256 maxDownUsd);\\n    event UpdatePredictionPairPeriodWinRatio(address indexed base, Period indexed period, uint16 winRatio);\\n    event UpdatePredictionPairPeriodFee(address indexed base, Period indexed period, uint16 openFeeP, uint16 winCloseFeeP, uint16 loseCloseFeeP);\\n    event AddPeriodForPredictionPair(address indexed base, PredictionPeriod[] predictionPeriods);\\n    event ReplacePredictionPairPeriod(address indexed base, PredictionPeriod[] predictionPeriods);\\n\\n    struct PeriodCap {\\n        Period period;\\n        uint256 maxUpUsd;     // USD 1e18\\n        uint256 maxDownUsd;   // USD 1e18\\n    }\\n\\n    struct PeriodWinRatio {\\n        Period period;\\n        uint16 winRatio;\\n    }\\n\\n    struct PeriodFee {\\n        Period period;\\n        uint16 openFeeP;      // 1e4\\n        uint16 winCloseFeeP;  // 1e4\\n        uint16 loseCloseFeeP; // 1e4\\n    }\\n\\n    struct PredictionPairView {\\n        string name;\\n        address base;\\n        PredictionPeriod[] predictionPeriods;\\n    }\\n\\n    function addPredictionPair(\\n        address base, string calldata name, PredictionPeriod[] calldata predictionPeriods\\n    ) external;\\n\\n    function removePredictionPair(address base) external;\\n\\n    function updatePredictionPairStatus(address base, PredictionPairStatus status) external;\\n\\n    function updatePredictionPairMaxCap(address base, PeriodCap[] calldata periodCaps) external;\\n\\n    function updatePredictionPairWinRatio(address base, PeriodWinRatio[] calldata periodWinRatios) external;\\n\\n    function updatePredictionPairFee(address base, PeriodFee[] calldata periodFees) external;\\n\\n    function addPeriodForPredictionPair(address base, PredictionPeriod[] calldata predictionPeriods) external;\\n\\n    function replacePredictionPairPeriod(address base, PredictionPeriod[] calldata predictionPeriods) external;\\n\\n    function getPredictionPairByBase(address base) external returns (PredictionPairView memory);\\n\\n    function predictionPairs(uint start, uint8 size) external returns (PredictionPairView[] memory);\\n\\n    function getPredictionPeriod(address base, Period period) external returns (PredictionPeriod memory);\\n}\\n\"\r\n    },\r\n    \"/contracts/diamond/interfaces/IPredictUpDown.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {Period} from \\\"./IPredictionManager.sol\\\";\\n\\nstruct PendingPrediction {\\n    address tokenIn;\\n    uint96 amountIn;     // tokenIn decimals\\n    address predictionPairBase;\\n    uint96 openFee;      // tokenIn decimals\\n    address user;\\n    uint64 price;        // 1e8\\n    uint24 broker;\\n    bool isUp;\\n    uint128 blockNumber;\\n    Period period;\\n}\\n\\nstruct OpenPrediction {\\n    address tokenIn;\\n    uint96 betAmount;      // tokenIn decimals\\n    address predictionPairBase;\\n    uint96 openFee;        // tokenIn decimals\\n    address user;\\n    uint96 betAmountUsd;\\n    uint32 userOpenPredictIndex;\\n    uint64 entryPrice;     // 1e8\\n    uint40 startTime;\\n    uint24 broker;\\n    bool isUp;\\n    Period period;\\n}\\n\\nstruct PredictionMarket {\\n    uint96 upUsd;\\n    uint96 downUsd;\\n}\\n\\ninterface IPredictUpDown {\\n\\n    event PredictAndBetPending(address indexed user, uint256 indexed id, PendingPrediction pp);\\n    event PendingPredictionRefund(address indexed user, uint256 indexed id, PredictionRefund refund);\\n    event PredictAndBet(address indexed user, uint256 indexed id, OpenPrediction op);\\n    event SettlePredictionReject(uint256 indexed id, Period period, uint256 correctTime);\\n    event SettlePredictionSuccessful(\\n        uint256 indexed id, bool win, uint256 endPrice, address token, uint256 profitOrLoss, uint256 closeFee\\n    );\\n\\n    enum PredictionRefund{NO, FEED_DELAY, USER_PRICE}\\n\\n    struct PredictionInput {\\n        address predictionPairBase;\\n        bool isUp;\\n        Period period;\\n        address tokenIn;\\n        uint96 amountIn;\\n        uint64 price;\\n        uint24 broker;\\n    }\\n\\n    struct SettlePrediction {\\n        uint256 id;\\n        uint64 price;\\n    }\\n\\n    struct PredictionView {\\n        uint256 id;\\n        address tokenIn;\\n        uint96 betAmount;      // tokenIn decimals\\n        address predictionPairBase;\\n        uint96 openFee;        // tokenIn decimals\\n        uint64 entryPrice;     // 1e8\\n        uint40 startTime;\\n        bool isUp;\\n        Period period;\\n    }\\n\\n    function predictAndBet(PredictionInput memory pi) external;\\n\\n    function predictAndBetBNB(PredictionInput memory pi) external payable;\\n\\n    function predictionCallback(bytes32 id, uint256 price) external;\\n\\n    function settlePredictions(SettlePrediction[] calldata) external;\\n\\n    function getPredictionById(uint256 id) external view returns (PredictionView memory);\\n\\n    function getPredictions(address user, address predictionPairBase) external view returns (PredictionView[] memory);\\n\\n    function getPredictionMarket(\\n        address predictionPairBase, Period[] calldata periods\\n    ) external view returns (PredictionMarket[] memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"name\":\"AddPeriodForPredictionPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"name\":\"AddPredictionPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"}],\"name\":\"RemovePredictionPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"name\":\"ReplacePredictionPairPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"name\":\"UpdatePredictionPairPeriodFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"}],\"name\":\"UpdatePredictionPairPeriodMaxCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"}],\"name\":\"UpdatePredictionPairPeriodWinRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"UpdatePredictionPairStatus\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"name\":\"addPeriodForPredictionPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"name\":\"addPredictionPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"}],\"name\":\"getPredictionPairByBase\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IPredictionManager.PredictionPairView\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"}],\"name\":\"getPredictionPeriod\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"internalType\":\"struct PredictionPeriod\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"name\":\"predictionPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IPredictionManager.PredictionPairView[]\",\"name\":\"predictPairViews\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"}],\"name\":\"removePredictionPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"},{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"internalType\":\"struct PredictionPeriod[]\",\"name\":\"predictionPeriods\",\"type\":\"tuple[]\"}],\"name\":\"replacePredictionPairPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"openFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"winCloseFeeP\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loseCloseFeeP\",\"type\":\"uint16\"}],\"internalType\":\"struct IPredictionManager.PeriodFee[]\",\"name\":\"periodFees\",\"type\":\"tuple[]\"}],\"name\":\"updatePredictionPairFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxUpUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDownUsd\",\"type\":\"uint256\"}],\"internalType\":\"struct IPredictionManager.PeriodCap[]\",\"name\":\"periodCaps\",\"type\":\"tuple[]\"}],\"name\":\"updatePredictionPairMaxCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"enum PredictionPairStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"updatePredictionPairStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"winRatio\",\"type\":\"uint16\"}],\"internalType\":\"struct IPredictionManager.PeriodWinRatio[]\",\"name\":\"periodWinRatios\",\"type\":\"tuple[]\"}],\"name\":\"updatePredictionPairWinRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PredictionManagerFacet", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}