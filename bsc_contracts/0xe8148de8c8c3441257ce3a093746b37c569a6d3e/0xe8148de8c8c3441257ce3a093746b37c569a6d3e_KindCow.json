{"SourceCode": "pragma solidity ^ 0.6 .2;\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns(uint256);\r\n\r\n\tfunction balanceOf(address account) external view returns(uint256);\r\n\r\n\tfunction transfer(address recipient, uint256 amount) external returns(bool);\r\n\r\n\tfunction allowance(address owner, address spender) external view returns(uint256);\r\n\r\n\tfunction approve(address spender, uint256 amount) external returns(bool);\r\n\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\npragma solidity ^ 0.6 .2;\r\nlibrary SafeMath {\r\n\tfunction add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n\t\trequire(b <= a, errorMessage);\r\n\t\tuint256 c = a - b;\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\treturn div(a, b, \"SafeMath: division by zero\");\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n\t\trequire(b > 0, errorMessage);\r\n\t\tuint256 c = a / b;\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\r\n\t}\r\n\r\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n\t\trequire(b != 0, errorMessage);\r\n\t\treturn a % b;\r\n\t}\r\n}\r\npragma solidity ^ 0.6 .2;\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\t\t(bool success, ) = recipient.call {\r\n\t\t\tvalue: amount\r\n\t\t}(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data) internal returns(bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {\r\n\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns(bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns(bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\treturn _functionCallWithValue(target, data, value, errorMessage);\r\n\t}\r\n\r\n\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns(bytes memory) {\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\t\t(bool success, bytes memory returndata) = target.call {\r\n\t\t\tvalue: weiValue\r\n\t\t}(data);\r\n\t\t if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n\t}\r\n}\r\npragma solidity ^ 0.6 .2;\r\nlibrary SafeERC20 {\r\n\tusing SafeMath\r\n\tfor uint256;\r\n\tusing Address\r\n\tfor address;\r\n\r\n\tfunction safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n\t}\r\n\r\n\tfunction safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n\t}\r\n\r\n\tfunction safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n\t\t// or when resetting it to zero. To increase and decrease it, use\r\n\t\t// solhint-disable-next-line max-line-length\r\n\t\trequire((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n\t}\r\n\r\n\tfunction safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n\t\tuint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n\t}\r\n\r\n\tfunction safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n\t\tuint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n\t}\r\n\r\n\tfunction _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\t\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n\t\tbytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n\t\tif (returndata.length > 0) { // Return data is optional\r\n\t\t\trequire(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n\t\t}\r\n\t}\r\n}\r\npragma solidity ^ 0.6 .2;\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns(address payable) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns(bytes memory) {\r\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\npragma solidity ^ 0.6 .2;\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\tconstructor() internal {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t}\r\n\r\n\tfunction owner() public view returns(address) {\r\n\t\treturn _owner;\r\n\t}\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\npragma solidity ^ 0.6 .2;\r\ncontract ERC20 is Context, IERC20 {\r\n\tusing SafeMath\r\n\tfor uint256;\r\n\tusing Address\r\n\tfor address;\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(address => mapping(address => uint256)) private _allowances;\r\n\tuint256 private _totalSupply;\r\n\tstring private _name;\r\n\tstring private _symbol;\r\n\tuint8 private _decimals;\r\n\tconstructor(string memory name, string memory symbol) public {\r\n\t\t_name = name;\r\n\t\t_symbol = symbol;\r\n\t\t_decimals = 8;\r\n\t\t_totalSupply = 10 ** 6 * 10 ** 8;\r\n\t\t_balances[_msgSender()] = _totalSupply;\r\n\t\temit Transfer(address(0), _msgSender(), _totalSupply);\r\n\t}\r\n\r\n\tfunction name() public view returns(string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol() public view returns(string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction decimals() public view returns(uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n\r\n\tfunction totalSupply() public view override returns(uint256) {\r\n\t\treturn _totalSupply.sub(_balances[address(0)]);\r\n\t}\r\n\r\n\tfunction balanceOf(address account) public view override returns(uint256) {\r\n\t\treturn _balances[account];\r\n\t}\r\n\r\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns(bool) {\r\n\t\t_transfer(_msgSender(), recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address owner, address spender) public view virtual override returns(uint256) {\r\n\t\treturn _allowances[owner][spender];\r\n\t}\r\n\r\n\tfunction approve(address spender, uint256 amount) public virtual override returns(bool) {\r\n\t\t_approve(_msgSender(), spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public virtual override returns(bool) {\r\n\t\t_transfer(sender, recipient, amount);\r\n\t\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns(bool) {\r\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns(bool) {\r\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\r\n\t\trequire(_balances[sender] >= amount, \"ERC20: balance sender not enough\");\r\n\t\t_beforeTokenTransfer(sender, recipient, amount);\r\n\t\t_balances[sender] = _balances[sender].sub(amount);\r\n\t\t_balances[recipient] = _balances[recipient].add(amount);\r\n\t\temit Transfer(sender, recipient, amount);\r\n\t}\r\n\r\n\tfunction _mint(address account, uint256 amount) internal virtual {\r\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\r\n\t\t_beforeTokenTransfer(address(0), account, amount);\r\n\t\t_totalSupply = _totalSupply.add(amount);\r\n\t\t_balances[account] = _balances[account].add(amount);\r\n\t\temit Transfer(address(0), account, amount);\r\n\t}\r\n\r\n\tfunction _burn(address account, uint256 amount) internal virtual {\r\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\r\n\t\trequire(_balances[account] >= amount, \"ERC20: balance sender not enough\");\r\n\t\t_beforeTokenTransfer(account, address(0), amount);\r\n\t\t_balances[account] = _balances[account].sub(amount);\r\n\t\t_totalSupply = _totalSupply.sub(amount);\r\n\t\temit Transfer(account, address(0), amount);\r\n\t}\r\n\r\n\tfunction _approve(address owner, address spender, uint256 amount) internal virtual {\r\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\r\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\tfunction _setupDecimals(uint8 decimals_) internal {\r\n\t\t_decimals = decimals_;\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\npragma solidity 0.6 .2;\r\ncontract KindCow is ERC20(\"Kindcow Finance\", \"KIND\"), Ownable {\r\n\tfunction mint(address _to, uint256 _amount) public onlyOwner {\r\n\t\t_mint(_to, _amount);\r\n\t}\r\n\r\n\tfunction safe32(uint n, string memory errorMessage) internal pure returns(uint32) {\r\n\t\trequire(n < 2 ** 32, errorMessage);\r\n\t\treturn uint32(n);\r\n\t}\r\n\r\n\tfunction getChainId() internal pure returns(uint) {\r\n\t\tuint256 chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid()\r\n\t\t}\r\n\t\treturn chainId;\r\n\t}\r\n}\r\npragma solidity 0.6 .2;\r\ncontract Neatherd is Ownable {\r\n\tusing SafeMath\r\n\tfor uint256;\r\n\tusing SafeERC20\r\n\tfor IERC20;\r\n\tstruct UserInfo {\r\n\t\tuint256 amount; // How many LP tokens the user has provided.\r\n\t\tuint256 rewardDebt; // Reward debt. See explanation below.\r\n\t\t// We do some fancy math here. Basically, any point in time, the amount of KINDs\r\n\t\t//   1. The pool's `accKindPerShare` (and `lastRewardBlock`) gets updated.\r\n\t\t//   3. User's `amount` gets updated.\r\n\t}\r\n\tstruct PoolInfo {\r\n\t\tIERC20 lpToken; // Address of LP token contract.\r\n\t\tuint256 allocPoint; // How many allocation points assigned to this pool. KINDs to distribute per block.\r\n\t\tuint256 lastRewardBlock; // Last block number that KINDs distribution occurs.\r\n\t\tuint256 accKindPerShare; // Accumulated KINDs per share, times 1e12. See below.\r\n\t\tuint256 totalLP; //Total LP at Neatherd\r\n\t}\r\n\tIERC20 MC;\r\n\tKindCow public kind;\r\n\taddress public devaddr;\r\n\taddress public donation;\r\n\tuint256 public bonusEndBlock;\r\n\tuint256 public kindPerBlock;\r\n\tPoolInfo[] public poolInfo;\r\n\tmapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\tmapping(string => bool) private listPool;\r\n\tuint256 public totalAllocPoint = 0;\r\n\tuint256 public startBlock;\r\n\tuint256 public total_Vote_Reward;\r\n\tuint256 public total_Donation;\r\n\tuint256 public count_to_send_donation = 0;\r\n\t\r\n\tuint256 private jackpot = 50;\r\n\tuint256 private winner  = 150;\r\n\tevent Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n\tevent Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\tevent EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\tconstructor(KindCow _kind, address _devaddr , address donate) public {\r\n\t\tkind = _kind;\r\n\t\tdonation = donate;\r\n\t\tdevaddr = _devaddr;\r\n\t\tkindPerBlock = 100000000;\r\n\t\tbonusEndBlock = 0;\r\n\t\tstartBlock = 0;\r\n\t\tMC = _kind;\r\n\t}\r\n\r\n\tfunction poolLength() external view returns(uint256) {\r\n\t\treturn poolInfo.length;\r\n\t}\r\n\t// fee list is 1000 KIND and Minimum vote 10.000 to start Receive reward\r\n\tfunction add(IERC20 _lpToken) public {\r\n\t\tuint256 _allocPoint = 1000;\r\n\t\tuint256 _allocPointToBurn = 1000 * 100000000;\r\n\t\tuint256 kindBal = kind.balanceOf(msg.sender);\r\n\t\trequire(kindBal >= _allocPointToBurn, \"Not Enough KIND to Listing\");\r\n\t\tuint256 notyetadd = 0;\r\n\t\tfor (uint256 a = 0; a < poolInfo.length; a++) {\r\n\t\t\tif (poolInfo[a].lpToken == _lpToken) notyetadd = 1;\r\n\t\t}\r\n\t\tif (notyetadd == 0) {\r\n\t\t\tMC.safeTransferFrom(address(msg.sender), address(this), _allocPointToBurn);\r\n\t\t\tsafeKindTransfer(address(0), _allocPointToBurn);\r\n\t\t\ttotalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n\t\t\tpoolInfo.push(PoolInfo({\r\n\t\t\t\tlpToken: _lpToken,\r\n\t\t\t\tallocPoint: _allocPoint,\r\n\t\t\t\tlastRewardBlock: 0,\r\n\t\t\t\taccKindPerShare: 0,\r\n\t\t\t\ttotalLP: 0\r\n\t\t\t}));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction rewardPerBlock(IERC20 _lpToken) public view returns(uint256) {\r\n\t\tuint256 total = totalAllocPoint;\r\n\t\tuint256 pid = checkPid(_lpToken);\r\n\t\tuint256 aloc = poolInfo[pid].allocPoint;\r\n\t\tuint256 rr = 100000000000000;\r\n\t\trr = rr.div(total);\r\n\t\trr = rr.mul(aloc);\r\n\t\trr = rr.div(1000000);\r\n\t\treturn rr;\r\n\t}\r\n\r\n\tfunction checkPid(IERC20 _lpToken) public view returns(uint256) {\r\n\t\tfor (uint256 a = 0; a < poolInfo.length; a++) {\r\n\t\t\tif (poolInfo[a].lpToken == _lpToken) return a;\r\n\t\t}\r\n\t\treturn 1000000;\r\n\t}\r\n\r\n\tfunction voteUp(uint256 _pid, uint256 _allocPoint) public {\r\n\t\trequire(_allocPoint > 0, \"voteUp : Minimum 1 KIND\");\r\n\t\tuint256 kindBal = kind.balanceOf(msg.sender);\r\n\t\tuint256 kindToBurn = _allocPoint.mul(100000000);\r\n\t\trequire(kindBal > kindToBurn, \"voteUp : Your KIND Balance Not Enough\");\r\n\t\tif (kindBal > kindToBurn) {\r\n\t\t\tMC.safeTransferFrom(address(msg.sender), address(this), kindToBurn);\r\n\t\t\tsafeKindTransfer(address(0), kindToBurn.div(2));\r\n\t\t\ttotal_Vote_Reward = total_Vote_Reward.add(kindToBurn.div(4));\r\n\t\t\ttotal_Donation    = total_Donation.add(kindToBurn.div(4));\r\n\t\t\t_sendReward();\r\n\t\t\ttotalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n\t\t\tpoolInfo[_pid].allocPoint = poolInfo[_pid].allocPoint.add(_allocPoint);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction voteDown(uint256 _pid, uint256 _allocPoint) public {\r\n\t\trequire(_allocPoint > 0, \"voteUp : Minimum 1 KIND\");\r\n\t\tuint256 kindBal = kind.balanceOf(msg.sender);\r\n\t\tuint256 kindToBurn = _allocPoint.mul(100000000);\r\n\t\trequire(kindBal > kindToBurn, \"voteDown : Your KIND Balance Not Enough\");\r\n\t\tuint256 currentAllocPoint = poolInfo[_pid].allocPoint;\r\n\t\trequire(currentAllocPoint >= _allocPoint, \"voteDown : _allocPoint too High\");\r\n\t\tif (kindBal > kindToBurn) {\r\n\t\t\tMC.safeTransferFrom(address(msg.sender), address(this), kindToBurn);\r\n\t\t\tsafeKindTransfer(address(0), kindToBurn.div(2));\r\n\t\t\ttotal_Vote_Reward = total_Vote_Reward.add(kindToBurn.div(4));\r\n\t\t\ttotal_Donation    = total_Donation.add(kindToBurn.div(4));\r\n\t\t\t_sendReward();\r\n\t\t\ttotalAllocPoint = totalAllocPoint.sub(_allocPoint);\r\n\t\t\tpoolInfo[_pid].allocPoint = poolInfo[_pid].allocPoint.sub(_allocPoint);\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _sendReward() public {\r\n\t\tuint256 _rRandom = total_Vote_Reward.div(10);\r\n\t\tuint256 _randomNumber = _random();\r\n\t\tuint256 _reward = 1;\r\n\t\tif (_randomNumber < winner)   _reward =  _randomNumber.mul(_rRandom.div(20));\r\n\t\tif (_randomNumber < jackpot)  _reward =  total_Vote_Reward;\r\n\t\t \r\n\t \r\n\t\tif (_reward > 0) {\r\n\t\t\ttotal_Vote_Reward = total_Vote_Reward.sub(_reward);\r\n\t\t\tsafeKindTransfer(msg.sender, _reward);\r\n\t\t}\r\n\t\t count_to_send_donation=count_to_send_donation.add(1);\r\n\t\t if(count_to_send_donation>20){\r\n\t\t safeKindTransfer(donation, total_Donation);\r\n\t\t total_Donation = 0;\r\n\t\t count_to_send_donation=0;\r\n\t     }\r\n\t\t    \r\n\t}\r\n\r\n\tfunction _random() private view returns(uint32) {\r\n\t\tuint8 r = uint8(uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % 251);\r\n\t\treturn r;\r\n\t}\r\n\r\n\tfunction voteReward() private view returns(uint256) {\r\n\t\treturn total_Vote_Reward;\r\n\t}\r\n\r\n\tfunction getMultiplier(uint256 _from, uint256 _to) private view returns(uint256) {\r\n\t\tif (_to <= bonusEndBlock) {\r\n\t\t\treturn _to.sub(_from).mul(10);\r\n\t\t} else if (_from >= bonusEndBlock) {\r\n\t\t\treturn _to.sub(_from);\r\n\t\t} else {\r\n\t\t\treturn bonusEndBlock.sub(_from).mul(10).add(_to.sub(bonusEndBlock));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction pendingKind(uint256 _pid, address _user) external view returns(uint256) {\r\n\t\tPoolInfo storage pool = poolInfo[_pid];\r\n\t\tUserInfo storage user = userInfo[_pid][_user];\r\n\t\tuint256 accKindPerShare = pool.accKindPerShare;\r\n\t\tuint256 lpSupply = pool.totalLP; //pool.lpToken.balanceOf(address(this));\r\n\t\tif (pool.allocPoint < 10000) return 0;\r\n\t\tif (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n\t\t\tuint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n\t\t\tuint256 kindReward = multiplier.mul(kindPerBlock).mul(10 ** 10).div(totalAllocPoint).mul(pool.allocPoint).div(10 ** 10);\r\n\t\t\taccKindPerShare = accKindPerShare.add(kindReward.mul(1e12).div(lpSupply));\r\n\t\t}\r\n\t\treturn user.amount.mul(accKindPerShare).div(1e12).sub(user.rewardDebt);\r\n\t}\r\n\r\n\tfunction balanceLP(uint256 _pid, address _user) external view returns(uint256) {\r\n\t\tUserInfo storage user = userInfo[_pid][_user];\r\n\t\treturn user.amount;\r\n\t}\r\n\r\n\tfunction massUpdatePools() public {\r\n\t\tuint256 length = poolInfo.length;\r\n\t\tfor (uint256 pid = 0; pid < length; ++pid) {\r\n\t\t\tupdatePool(pid);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction updatePool(uint256 _pid) public {\r\n\t\tPoolInfo storage pool = poolInfo[_pid];\r\n\t\tif (block.number <= pool.lastRewardBlock) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint256 lpSupply = pool.totalLP; //pool.lpToken.balanceOf(address(this));\r\n\t\tif (lpSupply == 0) {\r\n\t\t\tpool.lastRewardBlock = block.number;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n\t\tuint256 kindReward = multiplier.mul(kindPerBlock).mul(10 ** 10).div(totalAllocPoint).mul(pool.allocPoint).div(10 ** 10);\r\n\t\tif (pool.allocPoint >= 10000) {\r\n\t\t\tkind.mint(devaddr, kindReward.div(10));\r\n\t\t\tkind.mint(address(this), kindReward);\r\n\t\t}\r\n\t\tpool.accKindPerShare = pool.accKindPerShare.add(kindReward.mul(1e12).div(lpSupply));\r\n\t\tpool.lastRewardBlock = block.number;\r\n\t}\r\n\r\n\tfunction deposit(uint256 _pid, uint256 _amount) public {\r\n\t\tPoolInfo storage pool = poolInfo[_pid];\r\n\t\tUserInfo storage user = userInfo[_pid][msg.sender];\r\n\t\tupdatePool(_pid);\r\n\t\tif (user.amount > 0) {\r\n\t\t\tuint256 pending = user.amount.mul(pool.accKindPerShare).div(1e12).sub(user.rewardDebt);\r\n\t\t\tsafeKindTransfer(msg.sender, pending);\r\n\t\t}\r\n\t\tif (_amount > 0) {\r\n\t\t\tpool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n\t\t\tuser.amount = user.amount.add(_amount);\r\n\t\t\tpool.totalLP = pool.totalLP.add(_amount);\r\n\t\t}\r\n\t\tuser.rewardDebt = user.amount.mul(pool.accKindPerShare).div(1e12);\r\n\t\temit Deposit(msg.sender, _pid, _amount);\r\n\t}\r\n\r\n\tfunction withdraw(uint256 _pid, uint256 _amount) public {\r\n\t\tPoolInfo storage pool = poolInfo[_pid];\r\n\t\tUserInfo storage user = userInfo[_pid][msg.sender];\r\n\t\trequire(user.amount >= _amount, \"withdraw: not good\");\r\n\t\trequire(_amount > 0, \"withdraw: Must > 0\");\r\n\t\tupdatePool(_pid);\r\n\t\tuint256 pending = user.amount.mul(pool.accKindPerShare).div(1e12).sub(user.rewardDebt);\r\n\t\tsafeKindTransfer(msg.sender, pending);\r\n\t\tuser.amount = user.amount.sub(_amount);\r\n\t\tuser.rewardDebt = user.amount.mul(pool.accKindPerShare).div(1e12);\r\n\t\tpool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n\t\tif (_amount > 0) pool.totalLP = pool.totalLP.add(_amount);\r\n\t\temit Withdraw(msg.sender, _pid, _amount);\r\n\t}\r\n\r\n\tfunction emergencyWithdraw(uint256 _pid) public {\r\n\t\tPoolInfo storage pool = poolInfo[_pid];\r\n\t\tUserInfo storage user = userInfo[_pid][msg.sender];\r\n\t\tpool.lpToken.safeTransfer(address(msg.sender), user.amount);\r\n\t\temit EmergencyWithdraw(msg.sender, _pid, user.amount);\r\n\t\tuser.amount = 0;\r\n\t\tuser.rewardDebt = 0;\r\n\t}\r\n\t//transfer from mc\r\n\tfunction safeKindTransfer(address _to, uint256 _amount) internal {\r\n\t\tuint256 kindBal = kind.balanceOf(address(this));\r\n\t\tif (_amount > kindBal) {\r\n\t\t\tkind.transfer(_to, kindBal);\r\n\t\t} else {\r\n\t\t\tkind.transfer(_to, _amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction dev_addr(address _devaddr) onlyOwner public {\r\n\t  devaddr = _devaddr;\r\n\t}\r\n\t function donation_address(address d) onlyOwner public {\r\n\t  donation = d;\r\n\t}\r\n    function vote_reward(uint256 win,uint256 jak) onlyOwner public {\r\n\t  winner = win;\r\n\t  jackpot= jak;\r\n\t}\r\n\t\r\n\tfunction sendnow_donation() onlyOwner public {\r\n\t     safeKindTransfer(donation, total_Donation);\r\n\t\t total_Donation = 0;\r\n\t\t count_to_send_donation=0;\r\n\t\t \r\n        }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KindCow", "CompilerVersion": "v0.6.2+commit.bacdbe57", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1d9b4ccf2f164dbabc4392a0bcdc165aac1734afd687057aba062c8eeb22153b"}