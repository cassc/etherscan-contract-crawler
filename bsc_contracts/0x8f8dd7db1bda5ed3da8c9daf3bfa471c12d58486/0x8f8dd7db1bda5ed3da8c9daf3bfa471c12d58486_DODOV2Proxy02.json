{"SourceCode": "// File: contracts/SmartRoute/intf/IDODOV2Proxy01.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\n\r\n\r\ninterface IDODOV2Proxy01 {\r\n    function dodoSwapV2ETHToToken(\r\n        address toToken,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    ) external payable returns (uint256 returnAmount);\r\n\r\n    function dodoSwapV2TokenToETH(\r\n        address fromToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    ) external returns (uint256 returnAmount);\r\n\r\n    function dodoSwapV2TokenToToken(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    ) external returns (uint256 returnAmount);\r\n\r\n    function createDODOVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP,\r\n        uint256 deadLine\r\n    ) external payable returns (address newVendingMachine, uint256 shares);\r\n\r\n    function addDVMLiquidity(\r\n        address dvmAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        uint8 flag, //  0 - ERC20, 1 - baseInETH, 2 - quoteInETH\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseAdjustedInAmount,\r\n            uint256 quoteAdjustedInAmount\r\n        );\r\n\r\n    function createDODOPrivatePool(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTwap,\r\n        uint256 deadLine\r\n    ) external payable returns (address newPrivatePool);\r\n\r\n    function resetDODOPrivatePool(\r\n        address dppAddress,\r\n        uint256[] memory paramList,  //0 - newLpFeeRate, 1 - newI, 2 - newK\r\n        uint256[] memory amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3 - quoteOutAmount\r\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\r\n        uint256 minBaseReserve,\r\n        uint256 minQuoteReserve,\r\n        uint256 deadLine\r\n    ) external payable;\r\n\r\n    function createCrowdPooling(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256[] memory timeLine,\r\n        uint256[] memory valueList,\r\n        bool isOpenTWAP,\r\n        uint256 deadLine\r\n    ) external payable returns (address payable newCrowdPooling);\r\n\r\n    function bid(\r\n        address cpAddress,\r\n        uint256 quoteAmount,\r\n        uint8 flag, // 0 - ERC20, 1 - quoteInETH\r\n        uint256 deadLine\r\n    ) external payable;\r\n\r\n    function addLiquidityToV1(\r\n        address pair,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        uint256 baseMinShares,\r\n        uint256 quoteMinShares,\r\n        uint8 flag, // 0 erc20 Out  1 baseInETH  2 quoteInETH \r\n        uint256 deadLine\r\n    ) external payable returns(uint256, uint256);\r\n\r\n    function dodoSwapV1(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    ) external payable returns (uint256 returnAmount);\r\n\r\n    function externalSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        address approveTarget,\r\n        address to,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        bytes memory callDataConcat,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    ) external payable returns (uint256 returnAmount);\r\n\r\n    function mixSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory mixAdapters,\r\n        address[] memory mixPairs,\r\n        address[] memory assetTo,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    ) external payable returns (uint256 returnAmount);\r\n\r\n}\r\n\r\n// File: contracts/SmartRoute/intf/IDODOV2.sol\r\n\r\ninterface IDODOV2 {\r\n\r\n    //========== Common ==================\r\n\r\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\r\n\r\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\r\n\r\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\r\n\r\n    function _BASE_TOKEN_() external view returns (address);\r\n\r\n    function _QUOTE_TOKEN_() external view returns (address);\r\n\r\n    function getPMMStateForCall() external view returns (\r\n            uint256 i,\r\n            uint256 K,\r\n            uint256 B,\r\n            uint256 Q,\r\n            uint256 B0,\r\n            uint256 Q0,\r\n            uint256 R\r\n    );\r\n\r\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\r\n\r\n    \r\n    function getDODOPoolBidirection(address token0, address token1) external view returns (address[] memory, address[] memory);\r\n\r\n    //========== DODOVendingMachine ========\r\n    \r\n    function createDODOVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external returns (address newVendingMachine);\r\n    \r\n    function buyShares(address to) external returns (uint256,uint256,uint256);\r\n\r\n\r\n    //========== DODOPrivatePool ===========\r\n\r\n    function createDODOPrivatePool() external returns (address newPrivatePool);\r\n\r\n    function initDODOPrivatePool(\r\n        address dppAddress,\r\n        address creator,\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 lpFeeRate,\r\n        uint256 k,\r\n        uint256 i,\r\n        bool isOpenTwap\r\n    ) external;\r\n\r\n    function reset(\r\n        address operator,\r\n        uint256 newLpFeeRate,\r\n        uint256 newI,\r\n        uint256 newK,\r\n        uint256 baseOutAmount,\r\n        uint256 quoteOutAmount,\r\n        uint256 minBaseReserve,\r\n        uint256 minQuoteReserve\r\n    ) external returns (bool); \r\n\r\n\r\n    function _OWNER_() external returns (address);\r\n    \r\n    //========== CrowdPooling ===========\r\n\r\n    function createCrowdPooling() external returns (address payable newCrowdPooling);\r\n\r\n    function initCrowdPooling(\r\n        address cpAddress,\r\n        address creator,\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256[] memory timeLine,\r\n        uint256[] memory valueList,\r\n        bool isOpenTWAP\r\n    ) external;\r\n\r\n    function bid(address to) external;\r\n}\r\n\r\n// File: contracts/SmartRoute/intf/IDODOV1.sol\r\n\r\n\r\ninterface IDODOV1 {\r\n    function init(\r\n        address owner,\r\n        address supervisor,\r\n        address maintainer,\r\n        address baseToken,\r\n        address quoteToken,\r\n        address oracle,\r\n        uint256 lpFeeRate,\r\n        uint256 mtFeeRate,\r\n        uint256 k,\r\n        uint256 gasPriceLimit\r\n    ) external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    function claimOwnership() external;\r\n\r\n    function sellBaseToken(\r\n        uint256 amount,\r\n        uint256 minReceiveQuote,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    function buyBaseToken(\r\n        uint256 amount,\r\n        uint256 maxPayQuote,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote);\r\n\r\n    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote);\r\n\r\n    function depositBaseTo(address to, uint256 amount) external returns (uint256);\r\n\r\n    function withdrawBase(uint256 amount) external returns (uint256);\r\n\r\n    function withdrawAllBase() external returns (uint256);\r\n\r\n    function depositQuoteTo(address to, uint256 amount) external returns (uint256);\r\n\r\n    function withdrawQuote(uint256 amount) external returns (uint256);\r\n\r\n    function withdrawAllQuote() external returns (uint256);\r\n\r\n    function _BASE_CAPITAL_TOKEN_() external returns (address);\r\n\r\n    function _QUOTE_CAPITAL_TOKEN_() external returns (address);\r\n\r\n    function _BASE_TOKEN_() external view returns (address);\r\n\r\n    function _QUOTE_TOKEN_() external view returns (address);\r\n\r\n    function _R_STATUS_() external view returns (uint8);\r\n\r\n    function _QUOTE_BALANCE_() external view returns (uint256);\r\n\r\n    function _BASE_BALANCE_() external view returns (uint256);\r\n\r\n    function _K_() external view returns (uint256);\r\n\r\n    function _MT_FEE_RATE_() external view returns (uint256);\r\n\r\n    function _LP_FEE_RATE_() external view returns (uint256);\r\n\r\n    function getExpectedTarget() external view returns (uint256 baseTarget, uint256 quoteTarget);\r\n\r\n    function getOraclePrice() external view returns (uint256);\r\n\r\n    function getMidPrice() external view returns (uint256 midPrice); \r\n}\r\n\r\n// File: contracts/intf/IDODOApprove.sol\r\n\r\n\r\ninterface IDODOApprove {\r\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\r\n    function getDODOProxy() external view returns (address);\r\n}\r\n\r\n// File: contracts/lib/InitializableOwnable.sol\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @author DODO Breeder\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/SmartRoute/DODOApproveProxy.sol\r\n\r\n\r\n\r\ninterface IDODOApproveProxy {\r\n    function isAllowedProxy(address _proxy) external view returns (bool);\r\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @title DODOApproveProxy\r\n * @author DODO Breeder\r\n *\r\n * @notice Allow different version dodoproxy to claim from DODOApprove\r\n */\r\ncontract DODOApproveProxy is InitializableOwnable {\r\n    \r\n    // ============ Storage ============\r\n    uint256 private constant _TIMELOCK_DURATION_ = 3 days;\r\n    mapping (address => bool) public _IS_ALLOWED_PROXY_;\r\n    uint256 public _TIMELOCK_;\r\n    address public _PENDING_ADD_DODO_PROXY_;\r\n    address public immutable _DODO_APPROVE_;\r\n\r\n    // ============ Modifiers ============\r\n    modifier notLocked() {\r\n        require(\r\n            _TIMELOCK_ <= block.timestamp,\r\n            \"SetProxy is timelocked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address dodoApporve) public {\r\n        _DODO_APPROVE_ = dodoApporve;\r\n    }\r\n\r\n    function init(address owner, address[] memory proxies) external {\r\n        initOwner(owner);\r\n        for(uint i = 0; i < proxies.length; i++) \r\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\r\n    }\r\n\r\n    function unlockAddProxy(address newDodoProxy) public onlyOwner {\r\n        _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\r\n        _PENDING_ADD_DODO_PROXY_ = newDodoProxy;\r\n    }\r\n\r\n    function lockAddProxy() public onlyOwner {\r\n       _PENDING_ADD_DODO_PROXY_ = address(0);\r\n       _TIMELOCK_ = 0;\r\n    }\r\n\r\n\r\n    function addDODOProxy() external onlyOwner notLocked() {\r\n        _IS_ALLOWED_PROXY_[_PENDING_ADD_DODO_PROXY_] = true;\r\n        lockAddProxy();\r\n    }\r\n\r\n    function removeDODOProxy (address oldDodoProxy) public onlyOwner {\r\n        _IS_ALLOWED_PROXY_[oldDodoProxy] = false;\r\n    }\r\n    \r\n    function claimTokens(\r\n        address token,\r\n        address who,\r\n        address dest,\r\n        uint256 amount\r\n    ) external {\r\n        require(_IS_ALLOWED_PROXY_[msg.sender], \"DODOApproveProxy:Access restricted\");\r\n        IDODOApprove(_DODO_APPROVE_).claimTokens(\r\n            token,\r\n            who,\r\n            dest,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function isAllowedProxy(address _proxy) external view returns (bool) {\r\n        return _IS_ALLOWED_PROXY_[_proxy];\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/DecimalMath.sol\r\n\r\n\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n}\r\n\r\n// File: contracts/SmartRoute/helper/DODOSellHelper.sol\r\n\r\n\r\n// import {DODOMath} from \"../lib/DODOMath.sol\";\r\n\r\ninterface IDODOSellHelper {\r\n    function querySellQuoteToken(address dodo, uint256 amount) external view returns (uint256);\r\n    \r\n    function querySellBaseToken(address dodo, uint256 amount) external view returns (uint256);\r\n}\r\n\r\nlibrary DODOMath {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n        Integrate dodo curve fron V1 to V2\r\n        require V0>=V1>=V2>0\r\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\r\n        let V1-V2=delta\r\n        res = i*delta*(1-k+k(V0^2/V1/V2))\r\n    */\r\n    function _GeneralIntegrate(\r\n        uint256 V0,\r\n        uint256 V1,\r\n        uint256 V2,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        uint256 fairAmount = DecimalMath.mulFloor(i, V1.sub(V2)); // i*delta\r\n        uint256 V0V0V1V2 = DecimalMath.divCeil(V0.mul(V0).div(V1), V2);\r\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\r\n        return DecimalMath.mulFloor(fairAmount, DecimalMath.ONE.sub(k).add(penalty));\r\n    }\r\n\r\n    /*\r\n        The same with integration expression above, we have:\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Given Q1 and deltaB, solve Q2\r\n        This is a quadratic function and the standard version is\r\n        aQ2^2 + bQ2 + c = 0, where\r\n        a=1-k\r\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\r\n        c=-kQ0^2\r\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\r\n        note: another root is negative, abondan\r\n        if deltaBSig=true, then Q2>Q1\r\n        if deltaBSig=false, then Q2<Q1\r\n    */\r\n    function _SolveQuadraticFunctionForTrade(\r\n        uint256 Q0,\r\n        uint256 Q1,\r\n        uint256 ideltaB,\r\n        bool deltaBSig,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        // calculate -b value and sig\r\n        // -b = (1-k)Q1-kQ0^2/Q1+i*deltaB\r\n        uint256 kQ02Q1 = DecimalMath.mulFloor(k, Q0).mul(Q0).div(Q1); // kQ0^2/Q1\r\n        uint256 b = DecimalMath.mulFloor(DecimalMath.ONE.sub(k), Q1); // (1-k)Q1\r\n        bool minusbSig = true;\r\n        if (deltaBSig) {\r\n            b = b.add(ideltaB); // (1-k)Q1+i*deltaB\r\n        } else {\r\n            kQ02Q1 = kQ02Q1.add(ideltaB); // i*deltaB+kQ0^2/Q1\r\n        }\r\n        if (b >= kQ02Q1) {\r\n            b = b.sub(kQ02Q1);\r\n            minusbSig = true;\r\n        } else {\r\n            b = kQ02Q1.sub(b);\r\n            minusbSig = false;\r\n        }\r\n\r\n        // calculate sqrt\r\n        uint256 squareRoot = DecimalMath.mulFloor(\r\n            DecimalMath.ONE.sub(k).mul(4),\r\n            DecimalMath.mulFloor(k, Q0).mul(Q0)\r\n        ); // 4(1-k)kQ0^2\r\n        squareRoot = b.mul(b).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\r\n\r\n        // final res\r\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\r\n        uint256 numerator;\r\n        if (minusbSig) {\r\n            numerator = b.add(squareRoot);\r\n        } else {\r\n            numerator = squareRoot.sub(b);\r\n        }\r\n\r\n        if (deltaBSig) {\r\n            return DecimalMath.divFloor(numerator, denominator);\r\n        } else {\r\n            return DecimalMath.divCeil(numerator, denominator);\r\n        }\r\n    }\r\n\r\n    /*\r\n        Start from the integration function\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\r\n        let fairAmount = i*deltaB\r\n    */\r\n    function _SolveQuadraticFunctionForTarget(\r\n        uint256 V1,\r\n        uint256 k,\r\n        uint256 fairAmount\r\n    ) internal pure returns (uint256 V0) {\r\n        // V0 = V1+V1*(sqrt-1)/2k\r\n        uint256 sqrt = DecimalMath.divCeil(DecimalMath.mulFloor(k, fairAmount).mul(4), V1);\r\n        sqrt = sqrt.add(DecimalMath.ONE).mul(DecimalMath.ONE).sqrt();\r\n        uint256 premium = DecimalMath.divCeil(sqrt.sub(DecimalMath.ONE), k.mul(2));\r\n        // V0 is greater than or equal to V1 according to the solution\r\n        return DecimalMath.mulFloor(V1, DecimalMath.ONE.add(premium));\r\n    }\r\n}\r\n\r\ncontract DODOSellHelper {\r\n    using SafeMath for uint256;\r\n\r\n    enum RStatus {ONE, ABOVE_ONE, BELOW_ONE}\r\n\r\n    uint256 constant ONE = 10**18;\r\n\r\n    struct DODOState {\r\n        uint256 oraclePrice;\r\n        uint256 K;\r\n        uint256 B;\r\n        uint256 Q;\r\n        uint256 baseTarget;\r\n        uint256 quoteTarget;\r\n        RStatus rStatus;\r\n    }\r\n\r\n    function querySellBaseToken(address dodo, uint256 amount) public view returns (uint256) {\r\n        return IDODOV1(dodo).querySellBaseToken(amount);\r\n    }\r\n\r\n    function querySellQuoteToken(address dodo, uint256 amount) public view returns (uint256) {\r\n        DODOState memory state;\r\n        (state.baseTarget, state.quoteTarget) = IDODOV1(dodo).getExpectedTarget();\r\n        state.rStatus = RStatus(IDODOV1(dodo)._R_STATUS_());\r\n        state.oraclePrice = IDODOV1(dodo).getOraclePrice();\r\n        state.Q = IDODOV1(dodo)._QUOTE_BALANCE_();\r\n        state.B = IDODOV1(dodo)._BASE_BALANCE_();\r\n        state.K = IDODOV1(dodo)._K_();\r\n\r\n        uint256 boughtAmount;\r\n        // Determine the status (RStatus) and calculate the amount\r\n        // based on the state\r\n        if (state.rStatus == RStatus.ONE) {\r\n            boughtAmount = _ROneSellQuoteToken(amount, state);\r\n        } else if (state.rStatus == RStatus.ABOVE_ONE) {\r\n            boughtAmount = _RAboveSellQuoteToken(amount, state);\r\n        } else {\r\n            uint256 backOneBase = state.B.sub(state.baseTarget);\r\n            uint256 backOneQuote = state.quoteTarget.sub(state.Q);\r\n            if (amount <= backOneQuote) {\r\n                boughtAmount = _RBelowSellQuoteToken(amount, state);\r\n            } else {\r\n                boughtAmount = backOneBase.add(\r\n                    _ROneSellQuoteToken(amount.sub(backOneQuote), state)\r\n                );\r\n            }\r\n        }\r\n        // Calculate fees\r\n        return\r\n            DecimalMath.divFloor(\r\n                boughtAmount,\r\n                DecimalMath.ONE.add(IDODOV1(dodo)._MT_FEE_RATE_()).add(\r\n                    IDODOV1(dodo)._LP_FEE_RATE_()\r\n                )\r\n            );\r\n    }\r\n\r\n    function _ROneSellQuoteToken(uint256 amount, DODOState memory state)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveBaseToken)\r\n    {\r\n        uint256 i = DecimalMath.divFloor(ONE, state.oraclePrice);\r\n        uint256 B2 = DODOMath._SolveQuadraticFunctionForTrade(\r\n            state.baseTarget,\r\n            state.baseTarget,\r\n            DecimalMath.mulFloor(i, amount),\r\n            false,\r\n            state.K\r\n        );\r\n        return state.baseTarget.sub(B2);\r\n    }\r\n\r\n    function _RAboveSellQuoteToken(uint256 amount, DODOState memory state)\r\n        internal\r\n        pure\r\n        returns (uint256 receieBaseToken)\r\n    {\r\n        uint256 i = DecimalMath.divFloor(ONE, state.oraclePrice);\r\n        uint256 B2 = DODOMath._SolveQuadraticFunctionForTrade(\r\n            state.baseTarget,\r\n            state.B,\r\n            DecimalMath.mulFloor(i, amount),\r\n            false,\r\n            state.K\r\n        );\r\n        return state.B.sub(B2);\r\n    }\r\n\r\n    function _RBelowSellQuoteToken(uint256 amount, DODOState memory state)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveBaseToken)\r\n    {\r\n        uint256 Q1 = state.Q.add(amount);\r\n        uint256 i = DecimalMath.divFloor(ONE, state.oraclePrice);\r\n        return DODOMath._GeneralIntegrate(state.quoteTarget, Q1, state.Q, i, state.K);\r\n    }\r\n}\r\n\r\n// File: contracts/intf/IERC20.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/intf/IWETH.sol\r\n\r\n\r\n\r\n\r\ninterface IWETH {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 wad\r\n    ) external returns (bool);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n// File: contracts/SmartRoute/intf/IUni.sol\r\n\r\n\r\n\r\ninterface IUni {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function token0() external view returns (address);\r\n    \r\n    function token1() external view returns (address);\r\n}\r\n\r\n// File: contracts/SmartRoute/intf/IChi.sol\r\n\r\n\r\ninterface IChi {\r\n    function freeUpTo(uint256 value) external returns (uint256);\r\n}\r\n\r\n// File: contracts/lib/SafeERC20.sol\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/SmartRoute/lib/UniversalERC20.sol\r\n\r\n\r\n\r\nlibrary UniversalERC20 {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    function universalTransfer(\r\n        IERC20 token,\r\n        address payable to,\r\n        uint256 amount\r\n    ) internal {\r\n        if (amount > 0) {\r\n            if (isETH(token)) {\r\n                to.transfer(amount);\r\n            } else {\r\n                token.safeTransfer(to, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function universalApproveMax(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        uint256 allowance = token.allowance(address(this), to);\r\n        if (allowance < amount) {\r\n            if (allowance > 0) {\r\n                token.safeApprove(to, 0);\r\n            }\r\n            token.safeApprove(to, uint256(-1));\r\n        }\r\n    }\r\n\r\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\r\n        if (isETH(token)) {\r\n            return who.balance;\r\n        } else {\r\n            return token.balanceOf(who);\r\n        }\r\n    }\r\n\r\n    function tokenBalanceOf(IERC20 token, address who) internal view returns (uint256) {\r\n        return token.balanceOf(who);\r\n    }\r\n\r\n    function isETH(IERC20 token) internal pure returns (bool) {\r\n        return token == ETH_ADDRESS;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n * @author DODO Breeder\r\n *\r\n * @notice Protect functions from Reentrancy Attack\r\n */\r\ncontract ReentrancyGuard {\r\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\r\n    // zero-state of _ENTERED_ is false\r\n    bool private _ENTERED_;\r\n\r\n    modifier preventReentrant() {\r\n        require(!_ENTERED_, \"REENTRANT\");\r\n        _ENTERED_ = true;\r\n        _;\r\n        _ENTERED_ = false;\r\n    }\r\n}\r\n\r\n// File: contracts/DODOToken/DODOIncentive.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface IDODOIncentive {\r\n    function triggerIncentive(\r\n        address fromToken,\r\n        address toToken,\r\n        address assetTo\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title DODOIncentive\r\n * @author DODO Breeder\r\n *\r\n * @notice Trade Incentive in DODO platform\r\n */\r\ncontract DODOIncentive is InitializableOwnable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ============ Storage ============\r\n    address public immutable _DODO_TOKEN_;\r\n    address public _DODO_PROXY_;\r\n    uint256 public dodoPerBlock;\r\n    uint256 public defaultRate = 10;\r\n    mapping(address => uint256) public boosts;\r\n\r\n    uint32 public lastRewardBlock;\r\n    uint112 public totalReward;\r\n    uint112 public totalDistribution;\r\n\r\n    // ============ Events ============\r\n\r\n    event SetBoost(address token, uint256 boostRate);\r\n    event SetNewProxy(address dodoProxy);\r\n    event SetPerReward(uint256 dodoPerBlock);\r\n    event SetDefaultRate(uint256 defaultRate);\r\n    event Incentive(address user, uint256 reward);\r\n\r\n    constructor(address _dodoToken) public {\r\n        _DODO_TOKEN_ = _dodoToken;\r\n    }\r\n\r\n    // ============ Ownable ============\r\n\r\n    function changeBoost(address _token, uint256 _boostRate) public onlyOwner {\r\n        require(_token != address(0));\r\n        require(_boostRate + defaultRate <= 1000);\r\n        boosts[_token] = _boostRate;\r\n        emit SetBoost(_token, _boostRate);\r\n    }\r\n\r\n    function changePerReward(uint256 _dodoPerBlock) public onlyOwner {\r\n        _updateTotalReward();\r\n        dodoPerBlock = _dodoPerBlock;\r\n        emit SetPerReward(dodoPerBlock);\r\n    }\r\n\r\n    function changeDefaultRate(uint256 _defaultRate) public onlyOwner {\r\n        defaultRate = _defaultRate;\r\n        emit SetDefaultRate(defaultRate);\r\n    }\r\n\r\n    function changeDODOProxy(address _dodoProxy) public onlyOwner {\r\n        _DODO_PROXY_ = _dodoProxy;\r\n        emit SetNewProxy(_DODO_PROXY_);\r\n    }\r\n\r\n    function emptyReward(address assetTo) public onlyOwner {\r\n        uint256 balance = IERC20(_DODO_TOKEN_).balanceOf(address(this));\r\n        IERC20(_DODO_TOKEN_).transfer(assetTo, balance);\r\n    }\r\n\r\n    // ============ Incentive  function ============\r\n\r\n    function triggerIncentive(\r\n        address fromToken,\r\n        address toToken,\r\n        address assetTo\r\n    ) external {\r\n        require(msg.sender == _DODO_PROXY_, \"DODOIncentive:Access restricted\");\r\n\r\n        uint256 curTotalDistribution = totalDistribution;\r\n        uint256 fromRate = boosts[fromToken];\r\n        uint256 toRate = boosts[toToken];\r\n        uint256 rate = (fromRate >= toRate ? fromRate : toRate) + defaultRate;\r\n        require(rate <= 1000, \"RATE_INVALID\");\r\n        \r\n        uint256 _totalReward = _getTotalReward();\r\n        uint256 reward = ((_totalReward - curTotalDistribution) * rate) / 1000;\r\n        uint256 _totalDistribution = curTotalDistribution + reward;\r\n\r\n        _update(_totalReward, _totalDistribution);\r\n        if (reward != 0) {\r\n            IERC20(_DODO_TOKEN_).transfer(assetTo, reward);\r\n            emit Incentive(assetTo, reward);\r\n        }\r\n    }\r\n\r\n    function _updateTotalReward() internal {\r\n        uint256 _totalReward = _getTotalReward();\r\n        require(_totalReward < uint112(-1), \"OVERFLOW\");\r\n        totalReward = uint112(_totalReward);\r\n        lastRewardBlock = uint32(block.number);\r\n    }\r\n\r\n    function _update(uint256 _totalReward, uint256 _totalDistribution) internal {\r\n        require(\r\n            _totalReward < uint112(-1) && _totalDistribution < uint112(-1) && block.number < uint32(-1),\r\n            \"OVERFLOW\"\r\n        );\r\n        lastRewardBlock = uint32(block.number);\r\n        totalReward = uint112(_totalReward);\r\n        totalDistribution = uint112(_totalDistribution);\r\n    }\r\n\r\n    function _getTotalReward() internal view returns (uint256) {\r\n        if (lastRewardBlock == 0) {\r\n            return totalReward;\r\n        } else {\r\n            return totalReward + (block.number - lastRewardBlock) * dodoPerBlock;\r\n        }\r\n    }\r\n\r\n    // ============= Helper function ===============\r\n\r\n    function incentiveStatus(address fromToken, address toToken)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 reward,\r\n            uint256 baseRate,\r\n            uint256 totalRate,\r\n            uint256 curTotalReward,\r\n            uint256 perBlockReward\r\n        )\r\n    {\r\n        baseRate = defaultRate;\r\n        uint256 fromRate = boosts[fromToken];\r\n        uint256 toRate = boosts[toToken];\r\n        totalRate = (fromRate >= toRate ? fromRate : toRate) + defaultRate;\r\n        uint256 _totalReward = _getTotalReward();\r\n        reward = ((_totalReward - totalDistribution) * totalRate) / 1000;\r\n        curTotalReward = _totalReward - totalDistribution;\r\n        perBlockReward = dodoPerBlock;\r\n    }\r\n}\r\n\r\n// File: contracts/SmartRoute/intf/IDODOAdapter.sol\r\n\r\ninterface IDODOAdapter {\r\n    \r\n    function sellBase(address to, address pool) external;\r\n\r\n    function sellQuote(address to, address pool) external;\r\n}\r\n\r\n// File: contracts/SmartRoute/DODOV2Proxy02.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DODOV2Proxy02\r\n * @author DODO Breeder\r\n *\r\n * @notice Entrance of trading in DODO platform\r\n */\r\ncontract DODOV2Proxy02 is IDODOV2Proxy01, ReentrancyGuard, InitializableOwnable {\r\n    using SafeMath for uint256;\r\n    using UniversalERC20 for IERC20;\r\n\r\n    // ============ Storage ============\r\n\r\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public immutable _WETH_;\r\n    address public immutable _DODO_APPROVE_PROXY_;\r\n    address public immutable _DODO_SELL_HELPER_;\r\n    address public immutable _DVM_FACTORY_;\r\n    address public immutable _DPP_FACTORY_;\r\n    address public immutable _CP_FACTORY_;\r\n    address public immutable _DODO_INCENTIVE_;\r\n    address public immutable _CHI_TOKEN_;\r\n    uint256 public _GAS_DODO_MAX_RETURN_ = 0;\r\n    uint256 public _GAS_EXTERNAL_RETURN_ = 0;\r\n    mapping (address => bool) public isWhiteListed;\r\n\r\n    // ============ Events ============\r\n\r\n    event OrderHistory(\r\n        address fromToken,\r\n        address toToken,\r\n        address sender,\r\n        uint256 fromAmount,\r\n        uint256 returnAmount\r\n    );\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier judgeExpired(uint256 deadLine) {\r\n        require(deadLine >= block.timestamp, \"DODOV2Proxy02: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    receive() external payable {}\r\n\r\n    constructor(\r\n        address dvmFactory,\r\n        address dppFactory,\r\n        address cpFactory,\r\n        address payable weth,\r\n        address dodoApproveProxy,\r\n        address dodoSellHelper,\r\n        address chiToken,\r\n        address dodoIncentive\r\n    ) public {\r\n        _DVM_FACTORY_ = dvmFactory;\r\n        _DPP_FACTORY_ = dppFactory;\r\n        _CP_FACTORY_ = cpFactory;\r\n        _WETH_ = weth;\r\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\r\n        _DODO_SELL_HELPER_ = dodoSellHelper;\r\n        _CHI_TOKEN_ = chiToken;\r\n        _DODO_INCENTIVE_ = dodoIncentive;\r\n    }\r\n\r\n    function addWhiteList (address contractAddr) public onlyOwner {\r\n        isWhiteListed[contractAddr] = true;\r\n    }\r\n\r\n    function removeWhiteList (address contractAddr) public onlyOwner {\r\n        isWhiteListed[contractAddr] = false;\r\n    }\r\n\r\n    function updateGasReturn(uint256 newDodoGasReturn, uint256 newExternalGasReturn) public onlyOwner {\r\n        _GAS_DODO_MAX_RETURN_ = newDodoGasReturn;\r\n        _GAS_EXTERNAL_RETURN_ = newExternalGasReturn;\r\n    }\r\n\r\n    // ============ DVM Functions (create & add liquidity) ============\r\n\r\n    function createDODOVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        preventReentrant\r\n        judgeExpired(deadLine)\r\n        returns (address newVendingMachine, uint256 shares)\r\n    {\r\n        {\r\n            address _baseToken = baseToken == _ETH_ADDRESS_ ? _WETH_ : baseToken;\r\n            address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\r\n            newVendingMachine = IDODOV2(_DVM_FACTORY_).createDODOVendingMachine(\r\n                _baseToken,\r\n                _quoteToken,\r\n                lpFeeRate,\r\n                i,\r\n                k,\r\n                isOpenTWAP\r\n            );\r\n        }\r\n\r\n        {\r\n            address _baseToken = baseToken;\r\n            address _quoteToken = quoteToken;\r\n            _deposit(\r\n                msg.sender,\r\n                newVendingMachine,\r\n                _baseToken,\r\n                baseInAmount,\r\n                _baseToken == _ETH_ADDRESS_\r\n            );\r\n            _deposit(\r\n                msg.sender,\r\n                newVendingMachine,\r\n                _quoteToken,\r\n                quoteInAmount,\r\n                _quoteToken == _ETH_ADDRESS_\r\n            );\r\n        }\r\n\r\n        (shares, , ) = IDODOV2(newVendingMachine).buyShares(msg.sender);\r\n    }\r\n\r\n    function addDVMLiquidity(\r\n        address dvmAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        preventReentrant\r\n        judgeExpired(deadLine)\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseAdjustedInAmount,\r\n            uint256 quoteAdjustedInAmount\r\n        )\r\n    {\r\n        address _dvm = dvmAddress;\r\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _addDVMLiquidity(\r\n            _dvm,\r\n            baseInAmount,\r\n            quoteInAmount\r\n        );\r\n        require(\r\n            baseAdjustedInAmount >= baseMinAmount && quoteAdjustedInAmount >= quoteMinAmount,\r\n            \"DODOV2Proxy02: deposit amount is not enough\"\r\n        );\r\n\r\n        _deposit(msg.sender, _dvm, IDODOV2(_dvm)._BASE_TOKEN_(), baseAdjustedInAmount, flag == 1);\r\n        _deposit(msg.sender, _dvm, IDODOV2(_dvm)._QUOTE_TOKEN_(), quoteAdjustedInAmount, flag == 2);\r\n        \r\n        (shares, , ) = IDODOV2(_dvm).buyShares(msg.sender);\r\n        // refund dust eth\r\n        if (flag == 1 && msg.value > baseAdjustedInAmount) msg.sender.transfer(msg.value - baseAdjustedInAmount);\r\n        if (flag == 2 && msg.value > quoteAdjustedInAmount) msg.sender.transfer(msg.value - quoteAdjustedInAmount);\r\n    }\r\n\r\n    function _addDVMLiquidity(\r\n        address dvmAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount\r\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\r\n        (uint256 baseReserve, uint256 quoteReserve) = IDODOV2(dvmAddress).getVaultReserve();\r\n        if (quoteReserve == 0 && baseReserve == 0) {\r\n            baseAdjustedInAmount = baseInAmount;\r\n            quoteAdjustedInAmount = quoteInAmount;\r\n        }\r\n        if (quoteReserve == 0 && baseReserve > 0) {\r\n            baseAdjustedInAmount = baseInAmount;\r\n            quoteAdjustedInAmount = 0;\r\n        }\r\n        if (quoteReserve > 0 && baseReserve > 0) {\r\n            uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\r\n            uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\r\n            if (baseIncreaseRatio <= quoteIncreaseRatio) {\r\n                baseAdjustedInAmount = baseInAmount;\r\n                quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\r\n            } else {\r\n                quoteAdjustedInAmount = quoteInAmount;\r\n                baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============ DPP Functions (create & reset) ============\r\n\r\n    function createDODOPrivatePool(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTwap,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        preventReentrant\r\n        judgeExpired(deadLine)\r\n        returns (address newPrivatePool)\r\n    {\r\n        newPrivatePool = IDODOV2(_DPP_FACTORY_).createDODOPrivatePool();\r\n\r\n        address _baseToken = baseToken;\r\n        address _quoteToken = quoteToken;\r\n        _deposit(msg.sender, newPrivatePool, _baseToken, baseInAmount, _baseToken == _ETH_ADDRESS_);\r\n        _deposit(\r\n            msg.sender,\r\n            newPrivatePool,\r\n            _quoteToken,\r\n            quoteInAmount,\r\n            _quoteToken == _ETH_ADDRESS_\r\n        );\r\n\r\n        if (_baseToken == _ETH_ADDRESS_) _baseToken = _WETH_;\r\n        if (_quoteToken == _ETH_ADDRESS_) _quoteToken = _WETH_;\r\n\r\n        IDODOV2(_DPP_FACTORY_).initDODOPrivatePool(\r\n            newPrivatePool,\r\n            msg.sender,\r\n            _baseToken,\r\n            _quoteToken,\r\n            lpFeeRate,\r\n            k,\r\n            i,\r\n            isOpenTwap\r\n        );\r\n    }\r\n\r\n    function resetDODOPrivatePool(\r\n        address dppAddress,\r\n        uint256[] memory paramList,  //0 - newLpFeeRate, 1 - newI, 2 - newK\r\n        uint256[] memory amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3- quoteOutAmount\r\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\r\n        uint256 minBaseReserve,\r\n        uint256 minQuoteReserve,\r\n        uint256 deadLine\r\n    ) external override payable preventReentrant judgeExpired(deadLine) {\r\n        _deposit(\r\n            msg.sender,\r\n            dppAddress,\r\n            IDODOV2(dppAddress)._BASE_TOKEN_(),\r\n            amountList[0],\r\n            flag == 1\r\n        );\r\n        _deposit(\r\n            msg.sender,\r\n            dppAddress,\r\n            IDODOV2(dppAddress)._QUOTE_TOKEN_(),\r\n            amountList[1],\r\n            flag == 2\r\n        );\r\n\r\n        require(IDODOV2(IDODOV2(dppAddress)._OWNER_()).reset(\r\n            msg.sender,\r\n            paramList[0],\r\n            paramList[1],\r\n            paramList[2],\r\n            amountList[2],\r\n            amountList[3],\r\n            minBaseReserve,\r\n            minQuoteReserve\r\n        ), \"Reset Failed\");\r\n\r\n        _withdraw(msg.sender, IDODOV2(dppAddress)._BASE_TOKEN_(), amountList[2], flag == 3);\r\n        _withdraw(msg.sender, IDODOV2(dppAddress)._QUOTE_TOKEN_(), amountList[3], flag == 4);\r\n    }\r\n\r\n    // ============ Swap ============\r\n\r\n    function dodoSwapV2ETHToToken(\r\n        address toToken,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\r\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\r\n        uint256 originGas = gasleft();\r\n        \r\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\r\n        IWETH(_WETH_).deposit{value: msg.value}();\r\n        IWETH(_WETH_).transfer(dodoPairs[0], msg.value);\r\n\r\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\r\n            if (i == dodoPairs.length - 1) {\r\n                if (directions & 1 == 0) {\r\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\r\n                } else {\r\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\r\n                }\r\n            } else {\r\n                if (directions & 1 == 0) {\r\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\r\n                } else {\r\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\r\n                }\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n\r\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\r\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\r\n\r\n        _dodoGasReturn(originGas);\r\n\r\n        _execIncentive(isIncentive, _ETH_ADDRESS_, toToken);\r\n\r\n        emit OrderHistory(\r\n            _ETH_ADDRESS_,\r\n            toToken,\r\n            msg.sender,\r\n            msg.value,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    function dodoSwapV2TokenToETH(\r\n        address fromToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\r\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\r\n        uint256 originGas = gasleft();\r\n        \r\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\r\n\r\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\r\n            if (i == dodoPairs.length - 1) {\r\n                if (directions & 1 == 0) {\r\n                    IDODOV2(dodoPairs[i]).sellBase(address(this));\r\n                } else {\r\n                    IDODOV2(dodoPairs[i]).sellQuote(address(this));\r\n                }\r\n            } else {\r\n                if (directions & 1 == 0) {\r\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\r\n                } else {\r\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\r\n                }\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n        returnAmount = IWETH(_WETH_).balanceOf(address(this));\r\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\r\n        IWETH(_WETH_).withdraw(returnAmount);\r\n        msg.sender.transfer(returnAmount);\r\n\r\n        _dodoGasReturn(originGas);\r\n\r\n        _execIncentive(isIncentive, fromToken, _ETH_ADDRESS_);\r\n\r\n        emit OrderHistory(\r\n            fromToken,\r\n            _ETH_ADDRESS_,\r\n            msg.sender,\r\n            fromTokenAmount,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    function dodoSwapV2TokenToToken(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\r\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\r\n        uint256 originGas = gasleft();\r\n\r\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\r\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\r\n\r\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\r\n            if (i == dodoPairs.length - 1) {\r\n                if (directions & 1 == 0) {\r\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\r\n                } else {\r\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\r\n                }\r\n            } else {\r\n                if (directions& 1 == 0) {\r\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\r\n                } else {\r\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\r\n                }\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\r\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\r\n        \r\n        _dodoGasReturn(originGas);\r\n\r\n        _execIncentive(isIncentive, fromToken, toToken);\r\n\r\n        emit OrderHistory(\r\n            fromToken,\r\n            toToken,\r\n            msg.sender,\r\n            fromTokenAmount,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    function externalSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        address approveTarget,\r\n        address swapTarget,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        bytes memory callDataConcat,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\r\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\r\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\r\n        \r\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\r\n        if (fromToken != _ETH_ADDRESS_) {\r\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\r\n                fromToken,\r\n                msg.sender,\r\n                address(this),\r\n                fromTokenAmount\r\n            );\r\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\r\n        }\r\n\r\n        require(isWhiteListed[swapTarget], \"DODOV2Proxy02: Not Whitelist Contract\");\r\n        (bool success, ) = swapTarget.call{value: fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\r\n\r\n        require(success, \"DODOV2Proxy02: External Swap execution Failed\");\r\n\r\n        IERC20(toToken).universalTransfer(\r\n            msg.sender,\r\n            IERC20(toToken).universalBalanceOf(address(this))\r\n        );\r\n\r\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\r\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\r\n\r\n        _externalGasReturn();\r\n\r\n        _execIncentive(isIncentive, fromToken, toToken);\r\n\r\n        emit OrderHistory(\r\n            fromToken,\r\n            toToken,\r\n            msg.sender,\r\n            fromTokenAmount,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    function dodoSwapV1(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory dodoPairs,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\r\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\r\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\r\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\r\n        \r\n        uint256 originGas = gasleft();\r\n\r\n        address _fromToken = fromToken;\r\n        address _toToken = toToken;\r\n        \r\n        _deposit(msg.sender, address(this), _fromToken, fromTokenAmount, _fromToken == _ETH_ADDRESS_);\r\n\r\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\r\n            address curDodoPair = dodoPairs[i];\r\n            if (directions & 1 == 0) {\r\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\r\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\r\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\r\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\r\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\r\n            } else {\r\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\r\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\r\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\r\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\r\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\r\n                    curDodoPair,\r\n                    curAmountIn\r\n                );\r\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n\r\n        \r\n        if (_toToken == _ETH_ADDRESS_) {\r\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\r\n            IWETH(_WETH_).withdraw(returnAmount);\r\n        } else {\r\n            returnAmount = IERC20(_toToken).tokenBalanceOf(address(this));\r\n        }\r\n        \r\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\r\n        IERC20(_toToken).universalTransfer(msg.sender, returnAmount);\r\n\r\n        _dodoGasReturn(originGas);\r\n\r\n        _execIncentive(isIncentive, _fromToken, _toToken);\r\n\r\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\r\n    }\r\n\r\n\r\n    function mixSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory mixAdapters,\r\n        address[] memory mixPairs,\r\n        address[] memory assetTo,\r\n        uint256 directions,\r\n        bool isIncentive,\r\n        uint256 deadLine\r\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\r\n        require(mixPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\r\n        require(mixPairs.length == mixAdapters.length, \"DODOV2Proxy02: PAIR_ADAPTER_NOT_MATCH\");\r\n        require(mixPairs.length == assetTo.length - 1, \"DODOV2Proxy02: PAIR_ASSETTO_NOT_MATCH\");\r\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\r\n\r\n        address _fromToken = fromToken;\r\n        address _toToken = toToken;\r\n        uint256 _fromTokenAmount = fromTokenAmount;\r\n\r\n        require(_fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\r\n        require(_toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\r\n        \r\n        uint256 originGas = gasleft();\r\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\r\n        \r\n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\r\n\r\n        for (uint256 i = 0; i < mixPairs.length; i++) {\r\n            if (directions & 1 == 0) {\r\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1],mixPairs[i]);\r\n            } else {\r\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1],mixPairs[i]);\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n\r\n        if(_toToken == _ETH_ADDRESS_) {\r\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\r\n            IWETH(_WETH_).withdraw(returnAmount);\r\n            msg.sender.transfer(returnAmount);\r\n        }else {\r\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\r\n        }\r\n\r\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\r\n        \r\n        _dodoGasReturn(originGas);\r\n\r\n        _execIncentive(isIncentive, _fromToken, _toToken);\r\n\r\n        emit OrderHistory(\r\n            _fromToken,\r\n            _toToken,\r\n            msg.sender,\r\n            _fromTokenAmount,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    //============ CrowdPooling Functions (create & bid) ============\r\n\r\n    function createCrowdPooling(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256[] memory timeLine,\r\n        uint256[] memory valueList,\r\n        bool isOpenTWAP,\r\n        uint256 deadLine\r\n    ) external override payable preventReentrant judgeExpired(deadLine) returns (address payable newCrowdPooling) {\r\n        address _baseToken = baseToken;\r\n        address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\r\n        \r\n        newCrowdPooling = IDODOV2(_CP_FACTORY_).createCrowdPooling();\r\n\r\n        _deposit(\r\n            msg.sender,\r\n            newCrowdPooling,\r\n            _baseToken,\r\n            baseInAmount,\r\n            false\r\n        );\r\n\r\n        newCrowdPooling.transfer(msg.value);\r\n\r\n        IDODOV2(_CP_FACTORY_).initCrowdPooling(\r\n            newCrowdPooling,\r\n            msg.sender,\r\n            _baseToken,\r\n            _quoteToken,\r\n            timeLine,\r\n            valueList,\r\n            isOpenTWAP\r\n        );\r\n    }\r\n\r\n    function bid(\r\n        address cpAddress,\r\n        uint256 quoteAmount,\r\n        uint8 flag, // 0 - ERC20, 1 - quoteInETH\r\n        uint256 deadLine\r\n    ) external override payable preventReentrant judgeExpired(deadLine) {\r\n        _deposit(msg.sender, cpAddress, IDODOV2(cpAddress)._QUOTE_TOKEN_(), quoteAmount, flag == 1);\r\n        IDODOV2(cpAddress).bid(msg.sender);\r\n    }\r\n\r\n\r\n    function addLiquidityToV1(\r\n        address pair,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        uint256 baseMinShares,\r\n        uint256 quoteMinShares,\r\n        uint8 flag, // 0 erc20 In  1 baseInETH  2 quoteIn ETH \r\n        uint256 deadLine\r\n    ) external override payable preventReentrant judgeExpired(deadLine) returns(uint256 baseShares, uint256 quoteShares) {\r\n        address _baseToken = IDODOV1(pair)._BASE_TOKEN_();\r\n        address _quoteToken = IDODOV1(pair)._QUOTE_TOKEN_();\r\n        \r\n        _deposit(msg.sender, address(this), _baseToken, baseAmount, flag == 1);\r\n        _deposit(msg.sender, address(this), _quoteToken, quoteAmount, flag == 2);\r\n\r\n        \r\n        if(baseAmount > 0) {\r\n            IERC20(_baseToken).universalApproveMax(pair, baseAmount);\r\n            baseShares = IDODOV1(pair).depositBaseTo(msg.sender, baseAmount);\r\n        }\r\n        if(quoteAmount > 0) {\r\n            IERC20(_quoteToken).universalApproveMax(pair, quoteAmount);\r\n            quoteShares = IDODOV1(pair).depositQuoteTo(msg.sender, quoteAmount);\r\n        }\r\n\r\n        require(baseShares >= baseMinShares && quoteShares >= quoteMinShares,\"DODOV2Proxy02: Return DLP is not enough\");\r\n    }\r\n    \r\n\r\n    function _deposit(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint256 amount,\r\n        bool isETH\r\n    ) internal {\r\n        if (isETH) {\r\n            if (amount > 0) {\r\n                IWETH(_WETH_).deposit{value: amount}();\r\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\r\n            }\r\n        } else {\r\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\r\n        }\r\n    }\r\n\r\n    function _withdraw(\r\n        address payable to,\r\n        address token,\r\n        uint256 amount,\r\n        bool isETH\r\n    ) internal {\r\n        if (isETH) {\r\n            if (amount > 0) {\r\n                IWETH(_WETH_).withdraw(amount);\r\n                to.transfer(amount);\r\n            }\r\n        } else {\r\n            if (amount > 0) {\r\n                SafeERC20.safeTransfer(IERC20(token), to, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _dodoGasReturn(uint256 originGas) internal {\r\n        uint256 _gasDodoMaxReturn = _GAS_DODO_MAX_RETURN_;\r\n        if(_gasDodoMaxReturn > 0) {\r\n            uint256 calcGasTokenBurn = originGas.sub(gasleft()) / 65000;\r\n            uint256 gasTokenBurn = calcGasTokenBurn > _gasDodoMaxReturn ? _gasDodoMaxReturn : calcGasTokenBurn;\r\n            if(gasTokenBurn >= 3 && gasleft() > 27710 + gasTokenBurn * 6080)\r\n                IChi(_CHI_TOKEN_).freeUpTo(gasTokenBurn);\r\n        }\r\n    }\r\n\r\n    function _externalGasReturn() internal {\r\n        uint256 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\r\n        if(_gasExternalReturn > 0) {\r\n            if(gasleft() > 27710 + _gasExternalReturn * 6080)\r\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\r\n        }\r\n    }\r\n\r\n    function _execIncentive(bool isIncentive, address fromToken,address toToken) internal {\r\n        if(isIncentive && gasleft() > 30000) {\r\n            IDODOIncentive(_DODO_INCENTIVE_).triggerIncentive(fromToken, toToken, msg.sender);\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dvmFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dppFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cpFactory\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dodoApproveProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dodoSellHelper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chiToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dodoIncentive\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"name\":\"OrderHistory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_CHI_TOKEN_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CP_FACTORY_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_APPROVE_PROXY_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_INCENTIVE_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_SELL_HELPER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DPP_FACTORY_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DVM_FACTORY_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GAS_DODO_MAX_RETURN_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GAS_EXTERNAL_RETURN_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_WETH_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dvmAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseMinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteMinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"addDVMLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseAdjustedInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAdjustedInAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseMinShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteMinShares\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"addLiquidityToV1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteShares\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"timeLine\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"valueList\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"isOpenTWAP\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"createCrowdPooling\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"newCrowdPooling\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpenTwap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"createDODOPrivatePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newPrivatePool\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpenTWAP\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"createDODOVendingMachine\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newVendingMachine\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"dodoPairs\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directions\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isIncentive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"dodoSwapV1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"dodoPairs\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directions\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isIncentive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"dodoSwapV2ETHToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"dodoPairs\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directions\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isIncentive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"dodoSwapV2TokenToETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"dodoPairs\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directions\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isIncentive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"dodoSwapV2TokenToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approveTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callDataConcat\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isIncentive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"externalSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"mixAdapters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"mixPairs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"assetTo\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directions\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isIncentive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"mixSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dppAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"paramList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"minBaseReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"}],\"name\":\"resetDODOPrivatePool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDodoGasReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newExternalGasReturn\",\"type\":\"uint256\"}],\"name\":\"updateGasReturn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DODOV2Proxy02", "CompilerVersion": "v0.6.9+commit.3e3065ac", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000790b4a80fb1094589a3c0efc8740aa9b0c1733fb000000000000000000000000afe0a75dffb395eaabd0a7e1bbbd0b11f8609eef000000000000000000000000778df5b12170e8af8df94356bfc864e57ce185dc000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000b76de21f04f677f07d9881174a1d8e624276314c0000000000000000000000000f859706aee7fcf61d5a8939e8cb9dbb6c1eda3300000000000000000000000000000000000000000000000000000000000000000000000000000000000000004ee6398898f7fc3e648b3f6ba458310ac29cd352", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e0e4332977b9bd0f0a4ced23cda6d5342bc99c6036a424bca0c59481c6adedad"}