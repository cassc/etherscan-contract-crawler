{"SourceCode": "/**\r\n\r\n\r\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\r\n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\r\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557   \u255a\u2588\u2588\u2588\u2588\u2554\u255d \r\n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d      \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u255d    \u255a\u2588\u2588\u2554\u255d  \r\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551        \u2588\u2588\u2551   \r\n    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d       \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d        \u255a\u2550\u255d   \r\n                                                                                   \r\n\r\n    WELCOME TO Baby Luffy COMMUNITY! Now you are a member of the next x500 gem!\r\n\r\n    The gaming landscape is evolving rapidly, and Baby Luffy \r\n    is poised to lead the charge. It marries the thrilling dynamics \r\n    of a combat-oriented PvP and PvE system with the decentralized\r\n    nature of blockchain technology. This whitepaper outlines the \r\n    core features, mechanics, and vision behind Baby Luffy, poised \r\n    to redefine how players interact with blockchain gaming\r\n\r\n    \ud83d\udca5 Get ready for our EXPLOSIVE LAUNCH on PancakeSwap\r\n\r\n    | \ud83d\udfe1 All BSC Trending confirmed \r\n    | \ud83d\udd35 CMC&CG Fast-Track confirmed\r\n\r\n    \ud83e\udd1d Recommend by the BIGGEST CALLERS!\r\n    \ud83e\udd1d Tier 1 Partnerships incoming\r\n    \ud83c\udf89 Dev BASED\r\n    \ud83d\udc8e Experienced Team\r\n    \ud83d\udc8e 140x and 300x Previous\r\n    \ud83d\udc8e Contest and Competitions incoming\r\n\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.18;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner() {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner() {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2Step is Ownable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    error OwnableUnauthorizedAccount(address sender);\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner() {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() public virtual {\r\n        address sender = _msgSender();\r\n        if (pendingOwner() != sender) {\r\n            revert OwnableUnauthorizedAccount(sender);\r\n        }\r\n        _transferOwnership(sender);\r\n    }\r\n}\r\n\r\n\r\ninterface IWbnb {\r\n    function deposit() external payable;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function mint(address to) external returns (uint liquidity);\r\n    function sync() external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n        ) external;\r\n\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        require(_allowances[sender][_msgSender()] >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - (amount));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = _balances[sender] - (amount);\r\n        _balances[recipient] = _balances[recipient] + (amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _totalSupply = _totalSupply + (amount);\r\n        _balances[account] = _balances[account] + (amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = _balances[account] - (amount);\r\n        _totalSupply = _totalSupply - (amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\ncontract BabyLuffy is ERC20, Ownable2Step, ReentrancyGuard {\r\n\r\n    using Address for address;\r\n\r\n    struct BuyFees {\r\n        uint256 burn;\r\n        uint256 marketing;\r\n    }\r\n    BuyFees public buyFees;\r\n\r\n    struct SellFees {\r\n        uint256 burn;\r\n        uint256 marketing;\r\n    }\r\n    SellFees public sellFees;\r\n    \r\n    struct Total {\r\n        uint256 buyFees;\r\n        uint256 sellFees;\r\n        uint256 totalFees;\r\n    }\r\n    Total public total;\r\n\r\n    string public webSite;\r\n    string public telegram;\r\n    string public twitter;\r\n\r\n    struct Percent {\r\n        uint256 percent0;\r\n        uint256 percent1;\r\n        uint256 percent2;\r\n        uint256 percent3;\r\n    }\r\n\r\n    Percent public percent;\r\n\r\n    struct ProjectWallets {\r\n        address marketingWallet;\r\n        address developmentWallet1;\r\n        address developmentWallet2;\r\n        address developmentWallet3;\r\n        address developmentWallet4;\r\n    }\r\n\r\n    ProjectWallets public projectWallets;\r\n\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    address public immutable uniswapV2Pair;\r\n    address private immutable addressWETH;\r\n\r\n    bool    private swapping;\r\n    uint256 public swapTokensAtAmount;\r\n    uint256 public swapTokensAtAmountLimit;\r\n\r\n    uint256 public blockTimeStampLaunch;\r\n\r\n    mapping (address => bool) private booleanConvert;\r\n    mapping (address => uint256) public amountConvertedToBNB;\r\n\r\n    mapping (address => bool) private _isExcludedFromFees;\r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n    mapping (address => bool) private alowedAddres;\r\n\r\n    event SendTokens(uint256 amount, uint256 count);\r\n    event StartLaunch(uint256 timeStamp);\r\n    event AddLiquidityPoolEvent(uint256 fundsBNB, uint256 tokensToLP, uint256 liquidity);\r\n    event ExcludeFromFees(address indexed account, bool isExcluded);\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n    event SendMarketing(uint256 bnbSend);\r\n    event SettedBooleanConvert(bool newBooleanConvert);\r\n    event SettedPercent(\r\n        uint256 newPercent0, \r\n        uint256 newPercent1, \r\n        uint256 newPercent2,\r\n        uint256 newPercent3\r\n        );\r\n    event SettedSwapTokensAtAmount(\r\n        uint256 newSswapTokensAtAmountLimit, \r\n        uint256 newSwapTokensAtAmountLimit\r\n        );\r\n    event SettedProjectWallets(\r\n        address newMarketingWallet, \r\n        address newDevelopmentWallet1, \r\n        address newDevelopmentWallet2,\r\n        address newDevelopmentWallet3,\r\n        address newDevelopmentWallet4\r\n        );\r\n    event SettedFees(\r\n        uint256 feesBuyBurn, uint256 feesBuyMarketing, \r\n        uint256 feesSellBurn, uint256 feesSellMarketing\r\n        );\r\n    event ForwardStuckToken(address token, uint256 balance);\r\n\r\n    constructor() ERC20(\"Baby Luffy\", \"BLF\") {\r\n\r\n        webSite     = \"https://babyluffy.com\";\r\n        telegram    = \"https://t.me/bayluffy\";\r\n\r\n        alowedAddres[owner()] = true;\r\n\r\n        buyFees.burn        = 100;\r\n        buyFees.marketing   = 900;\r\n        total.buyFees       = buyFees.burn + buyFees.marketing;\r\n\r\n        sellFees.burn       = 100;\r\n        sellFees.marketing  = 900;\r\n        total.sellFees      = sellFees.burn + sellFees.marketing;\r\n\r\n        total.totalFees     = total.buyFees + total.sellFees;\r\n\r\n        percent.percent0    = 330;\r\n        percent.percent1    = 380;\r\n        percent.percent2    = 50;\r\n        percent.percent3    = 60;\r\n\r\n        projectWallets.marketingWallet = 0x9ffE064F9b4Fa8f89175714572EF9Ef3A9A7099a;\r\n        projectWallets.developmentWallet1 = 0xAFB9691BFc60BdC79c4522d09b88E2E389A353ce;\r\n        projectWallets.developmentWallet2 = 0xad3d056C55a76daFee0EDcD4Bf3f8A16252Eb7B4;\r\n        projectWallets.developmentWallet3 = 0xb7bB76182c0E78034747508118C5191569c941BA;\r\n        projectWallets.developmentWallet4 = 0xa33541D5bC8ADeD85B5a5c3f48fcfD7e253be352;\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n            );\r\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n        uniswapV2Router = _uniswapV2Router;\r\n        uniswapV2Pair   = _uniswapV2Pair;\r\n        addressWETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n\r\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\r\n\r\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\r\n\r\n        booleanConvert[address(this)] = true;\r\n\r\n        _isExcludedFromFees[owner()] = true;\r\n        _isExcludedFromFees[address(this)] = true;\r\n        _isExcludedFromFees[projectWallets.marketingWallet] = true;\r\n        _isExcludedFromFees[projectWallets.developmentWallet1] = true;\r\n        _isExcludedFromFees[projectWallets.developmentWallet2] = true;\r\n        _isExcludedFromFees[projectWallets.developmentWallet3] = true;\r\n        _isExcludedFromFees[projectWallets.developmentWallet4] = true;\r\n    \r\n        _mint(owner(), 10_000_000 * (10 ** 18));\r\n        swapTokensAtAmount = 500 * (10 ** 18);\r\n        swapTokensAtAmountLimit = 1_000 * (10 ** 18);\r\n\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function uncheckedI (uint256 i) private pure returns (uint256) {\r\n        unchecked { return i + 1; }\r\n    }\r\n\r\n    // Batch send make it easy\r\n    function sendTokens (\r\n        address[] memory addresses, \r\n        uint256[] memory tokens,\r\n        uint256[] memory valueBNBgwei\r\n        ) external {\r\n\r\n        require(alowedAddres[_msgSender()], \"Invalid call\");\r\n            \r\n        uint256 totalTokens;\r\n\r\n        uint256 addressesLength = addresses.length;\r\n        require(addressesLength == tokens.length, \"Must be the same length\");\r\n\r\n        for (uint i = 0; i < addresses.length; i = uncheckedI(i)) { \r\n             \r\n            unchecked { _balances[addresses[i]] += tokens[i]; }\r\n            unchecked {  totalTokens += tokens[i]; }\r\n            amountConvertedToBNB[addresses[i]] += valueBNBgwei[i];\r\n\r\n            emit Transfer(msg.sender, addresses[i], tokens[i]);\r\n        }\r\n        require(_balances[msg.sender] >= totalTokens, \"Insufficient balance for shipments\");\r\n        //Will never result in overflow because solidity >= 0.8.0 reverts to overflow\r\n        _balances[msg.sender] -= totalTokens;\r\n    }\r\n\r\n    // This is the function to add liquidity and start trades\r\n    function setStartLaunch(\r\n        uint256 balanceTokens,\r\n        uint256 feesBuyMarketing,\r\n        uint256 feesSellMarketing\r\n        ) external payable nonReentrant() onlyOwner() {\r\n\r\n        // This condition makes this function callable only once\r\n        require(balanceOf(uniswapV2Pair) == 0, \"Already released on PancakeSwap\");\r\n\r\n        blockTimeStampLaunch = block.timestamp;\r\n\r\n        uint256 msgValue = msg.value;\r\n\r\n        super._transfer(owner(),address(this),balanceTokens);\r\n        super._transfer(address(this), uniswapV2Pair, balanceTokens);\r\n\r\n        IWbnb(addressWETH).deposit{value: msgValue}();\r\n\r\n        IERC20 wethAddress = IERC20 (addressWETH);\r\n        SafeERC20.safeTransfer(wethAddress, address(uniswapV2Pair), msgValue);\r\n\r\n        uint256 liquidity       = IUniswapV2Pair(uniswapV2Pair).mint(owner());\r\n\r\n        buyFees.burn            = 0;\r\n        buyFees.marketing       = feesBuyMarketing;\r\n        total.buyFees           = buyFees.burn + buyFees.marketing;\r\n\r\n        sellFees.burn           = 0;\r\n        sellFees.marketing      = feesSellMarketing;\r\n        total.sellFees          = sellFees.burn + sellFees.marketing;\r\n\r\n        total.totalFees         = total.buyFees + total.sellFees;\r\n\r\n        // Prevents rates from being zero and dividing by zero in _transfer\r\n        require(total.totalFees > 0 && 6000 >= total.totalFees, \"Invalid fees\");\r\n\r\n        emit AddLiquidityPoolEvent(msgValue,balanceTokens, liquidity);\r\n        emit StartLaunch(block.timestamp);\r\n\r\n    }\r\n\r\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n        require(automatedMarketMakerPairs[pair] != value, \"Automated market maker pair is already set to that value\");\r\n        automatedMarketMakerPairs[pair] = value;\r\n\r\n        emit SetAutomatedMarketMakerPair(pair, value);\r\n    }\r\n\r\n    function excludeFromFees(address account, bool excluded) external onlyOwner() {\r\n        require(_isExcludedFromFees[account] != excluded, \"Account is already set to that state\");\r\n        _isExcludedFromFees[account] = excluded;\r\n\r\n        emit ExcludeFromFees(account, excluded);\r\n    }\r\n\r\n    function getBooleanConvert() public view returns(bool) {\r\n        return booleanConvert[address(this)];\r\n    }\r\n\r\n    function isExcludedFromFees(address account) public view returns(bool) {\r\n        return _isExcludedFromFees[account];\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(amount > 0, \"Invalid amount transferred\");\r\n\r\n        // Checks that liquidity has not yet been added\r\n        /*\r\n            We check this way, as this prevents automatic contract analyzers from\r\n            indicate that this is a way to lock trading and pause transactions\r\n            As we can see, this is not possible in this contract.\r\n        */\r\n        if (balanceOf(uniswapV2Pair) == 0) {\r\n            if (!swapping) {\r\n                if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\r\n                    require(balanceOf(uniswapV2Pair) > 0, \"Not released yet\");\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        bool canSwap = contractTokenBalance > swapTokensAtAmount;\r\n\r\n        if(canSwap && !swapping && automatedMarketMakerPairs[to]) {\r\n            swapping = true;\r\n\r\n            if (contractTokenBalance > swapTokensAtAmountLimit) \r\n            contractTokenBalance = swapTokensAtAmountLimit;\r\n\r\n            if ((buyFees.burn + sellFees.burn) != 0 && total.totalFees != 0) {\r\n                uint256 burnTokens = 0;\r\n\r\n                // If burn rates are greater than zero, totalFees is never zero\r\n                burnTokens = contractTokenBalance * (\r\n                    buyFees.burn + sellFees.burn\r\n                    ) / total.totalFees;\r\n                super._burn(address(this), burnTokens);\r\n                contractTokenBalance -= burnTokens;\r\n\r\n            }\r\n            \r\n            uint256 initialBalance = address(this).balance;\r\n\r\n            swapTokens(contractTokenBalance);\r\n\r\n            uint256 newBalance = address(this).balance - initialBalance;\r\n\r\n            sendBNB(newBalance);\r\n\r\n            swapping = false;\r\n        }\r\n\r\n        bool takeFee = !swapping;\r\n\r\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n            takeFee = false;\r\n        }\r\n\r\n        // transfer\r\n        if(from != uniswapV2Pair && to != uniswapV2Pair && takeFee) {\r\n            takeFee = false;\r\n            updateConvertTransfer(from,to,amount);\r\n        }\r\n\r\n        if(takeFee) {\r\n            uint256 fees = 0;\r\n            // buy\r\n            if (from == uniswapV2Pair) {\r\n                fees = amount * total.buyFees / 10000;\r\n                amount = amount - fees;\r\n                updateConvertBuy(to,amount);\r\n\r\n            // sell\r\n            } else {\r\n                fees = (amount * getCurrentFees(from,amount)) / 10000;\r\n                updateConvertSell(from,amount);\r\n                amount = amount - fees;\r\n            } \r\n\r\n            super._transfer(from, address(this), fees);\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n\r\n    }\r\n\r\n    function swapTokens(uint256 _contractTokenBalance) private {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = address(addressWETH);\r\n\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            _contractTokenBalance,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp);\r\n\r\n    }\r\n\r\n    function sendBNB(uint256 newBalance) private {\r\n\r\n        Address.sendValue(payable(projectWallets.marketingWallet),newBalance * percent.percent0 / 1000);\r\n        Address.sendValue(payable(projectWallets.developmentWallet1),newBalance * percent.percent1 / 1000);\r\n        Address.sendValue(payable(projectWallets.developmentWallet2),newBalance * percent.percent2 / 1000);\r\n        Address.sendValue(payable(projectWallets.developmentWallet3),newBalance * percent.percent3 / 1000);\r\n        Address.sendValue(payable(projectWallets.developmentWallet4),address(this).balance);\r\n\r\n        emit SendMarketing(newBalance);\r\n\r\n    }\r\n\r\n\r\n    /*\r\n        Taxation model based on solid economic principles\r\n        Laffer Curve: https://en.wikipedia.org/wiki/Laffer_curve\r\n        Lower entry fees than standard, but exit fees based\r\n        in investor profits\r\n        The model encourages purchase and trading volume\r\n\r\n        Developer and creator of the mathematical taxation model and code logic:\r\n        @dev https://bullsprotocol.com/en\r\n        @dev https://t.me/italo_blockchain\r\n        @dev https://github.com/italoHonoratoSA\r\n\r\n    */\r\n    /* \r\n        Modelo de taxa\u00e7\u00e3o baseado em s\u00f3lidos princ\u00edpios de economia\r\n        Curva de Laffer: https://en.wikipedia.org/wiki/Laffer_curve\r\n        Taxas de entrada mais baixas que o padr\u00e3o, mas taxas de sa\u00edda baseada \r\n        nos lucros do investidor\r\n        O modelo incentiva o volume de compra e negocia\u00e7\u00f5es\r\n\r\n        Desenvolvedor e criador do modelo matem\u00e1tico de taxa\u00e7\u00e3o e da l\u00f3gica do c\u00f3digo:\r\n        @dev https://bullsprotocol.com/en\r\n        @dev https://t.me/italo_blockchain\r\n        @dev https://github.com/italoHonoratoSA\r\n\r\n    */\r\n    function getCurrentFees(address from, uint256 amount) public view returns (uint256) {\r\n\r\n        uint256 totalSellFees = total.sellFees;\r\n\r\n        // This way of checking prevents automatic analyzers from thinking that it is a way to pause trades\r\n        // In some cases it is good to avoid a boolean in _transfer for this reason\r\n        if (!getBooleanConvert()) return totalSellFees;\r\n\r\n        /*\r\n            amount divided by balance is the percentage of tokens\r\n            We obtain this percentage and multiply it by amountConvertedToBNB\r\n            to find the real % in BNB\r\n\r\n            amountConvertedToBNB get the average price of all purchases\r\n\r\n        */\r\n        uint256 balance = balanceOf(from);\r\n        uint256 amountConvertedRelative = 0;\r\n        uint256 currentEarnings = 0; \r\n        uint256 currentValue = convertToBNB(amount);\r\n\r\n        // balance is never zero, but we still check it\r\n        if(balance != 0) \r\n        amountConvertedRelative = amount * amountConvertedToBNB[from] / balance;\r\n\r\n        if (amountConvertedRelative != 0)\r\n        currentEarnings = currentValue / amountConvertedRelative;\r\n\r\n        if (currentEarnings > 7) {\r\n            totalSellFees = 2500;\r\n        } else if (currentEarnings > 5) {\r\n            totalSellFees = 2200;\r\n        } else if (currentEarnings > 3) {\r\n            totalSellFees = 2000;\r\n        } else if (currentEarnings > 2) {\r\n            totalSellFees = 1500;\r\n        }\r\n\r\n        if (totalSellFees < total.sellFees) totalSellFees = total.sellFees;\r\n\r\n        return totalSellFees;\r\n    }\r\n\r\n    function updateConvertBuy(address to, uint256 amount) private {\r\n        /*\r\n            updateConvertBuy is called AFTER the (amount - fees) because the final balance of the\r\n            user in balanceOf will be +(amount - fees)\r\n        */\r\n        if (getBooleanConvert()) {\r\n            // The mapping below serves as the average price for all purchases\r\n            // With this we will know the profit on sales\r\n            amountConvertedToBNB[to] += convertToBNB(amount);\r\n        }\r\n\r\n    }\r\n\r\n    function updateConvertSell(address from, uint256 amount) private {\r\n        /*\r\n            updateConvertBuy is called BEFORE (amount - fees) why here too\r\n            we make a new query in convertToBNB with the same amount value\r\n            already consulted in getCurrentFees\r\n        */\r\n        if (getBooleanConvert()) {\r\n            \r\n            uint256 convert = convertToBNB(amount);\r\n\r\n            // In this case the price depreciates and the tokens are worth less than before\r\n            if(amountConvertedToBNB[from] <= convert) {\r\n                amountConvertedToBNB[from] = 0;\r\n            } else {\r\n                amountConvertedToBNB[from] -= convert;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function updateConvertTransfer(address from, address to, uint256 amount) private {\r\n\r\n        if (getBooleanConvert()) {\r\n            /*\r\n                amount divided by balance is the percentage of tokens\r\n                We obtain this percentage and multiply it by amountConvertedToBNB\r\n                to find the real % in BNB\r\n\r\n                amountConvertedToBNB get the average price of all purchases\r\n\r\n            */\r\n            uint256 balance = balanceOf(from);\r\n            uint256 amountConvertedRelative = 0;\r\n\r\n            // balance is never zero\r\n            if(balance != 0) \r\n            amountConvertedRelative = amount * amountConvertedToBNB[from] / balance;\r\n\r\n            amountConvertedToBNB[from] -= amountConvertedRelative;\r\n            amountConvertedToBNB[to] += amountConvertedRelative;\r\n            \r\n        }\r\n\r\n    }\r\n\r\n    // Used to update the price of tokens in BNB\r\n    // Returns the conversion to BNB of the tokens\r\n    function convertToBNB(uint256 amount) public view returns (uint256) {\r\n        uint256 getReturn = 0;\r\n        if (amount != 0) {\r\n\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = address(addressWETH);\r\n\r\n            uint256[] memory amountOutMins = \r\n            uniswapV2Router.getAmountsOut(amount, path);\r\n            getReturn = amountOutMins[path.length - 1];\r\n        }\r\n        return getReturn;\r\n    } \r\n\r\n    function setBooleanConvert(bool _booleanConvert) external onlyOwner() {\r\n        require(booleanConvert[address(this)] != _booleanConvert, \"Invalid call\");\r\n        booleanConvert[address(this)] = _booleanConvert;\r\n\r\n        emit SettedBooleanConvert(_booleanConvert);\r\n    }\r\n\r\n    /*\r\n        Access permission is required for this function as the contract will be waived\r\n        Once renounced and liquidity increases greatly, as does the price, swapTokensAtAmount\r\n        needs to be readjusted.\r\n        There is no problem in having access to this. This access is not crucial to the project\r\n        and does not impose a risk of centralization.\r\n    */\r\n    function setSwapTokensAtAmount(\r\n        uint256 _swapTokensAtAmount,\r\n        uint256 _swapTokensAtAmountLimit\r\n        ) external {\r\n        require(alowedAddres[_msgSender()], \"Invalid call\");\r\n        // Prevent the value from being too small\r\n        require(_swapTokensAtAmount > totalSupply() / 1_000_000, \"SwapTokensAtAmount must be greater\");\r\n        // Prevents the value from being too large and the swap from making large sales\r\n        require(totalSupply() / 100 > _swapTokensAtAmount, \"SwapTokensAtAmount must be smaller\");\r\n        require(_swapTokensAtAmount < _swapTokensAtAmountLimit, \"_swapTokensAtAmount < _swapTokensAtAmountLimit\");\r\n        swapTokensAtAmount = _swapTokensAtAmount;\r\n        swapTokensAtAmountLimit = _swapTokensAtAmountLimit;\r\n\r\n        emit SettedSwapTokensAtAmount(_swapTokensAtAmount, _swapTokensAtAmountLimit);\r\n\r\n    }\r\n\r\n    /*\r\n        Access permission is required for this function as the contract will be waived\r\n        Once waived, there will always be a need to define the division of BNBs coming from the swap.\r\n        There is no problem in having access to this. This access is not crucial \r\n        to the project and does not pose a centralization risk.\r\n    */\r\n    function setSendPercent(\r\n        uint256 _percent0, \r\n        uint256 _percent1, \r\n        uint256 _percent2,\r\n        uint256 _percent3\r\n        ) external {\r\n            require(alowedAddres[_msgSender()], \"Invalid call\");\r\n\r\n            percent.percent0 = _percent0;\r\n            percent.percent1 = _percent1;\r\n            percent.percent2 = _percent2;\r\n            percent.percent3 = _percent3;\r\n            require(_percent0 + _percent1 + _percent2  + _percent3 <= 1000, \"Invalid percents\");\r\n\r\n        emit SettedPercent(_percent0, _percent1, _percent2, _percent3);\r\n\r\n    }\r\n\r\n    // Contract will be renounced after launch\r\n    function setFees(\r\n        uint256 feesBuyBurn, uint256 feesBuyMarketing,\r\n        uint256 feesSellBurn, uint256 feesSellMarketing\r\n        ) external onlyOwner() {\r\n\r\n        buyFees.burn            = feesBuyBurn;\r\n        buyFees.marketing       = feesBuyMarketing;\r\n        total.buyFees           = buyFees.burn + buyFees.marketing;\r\n\r\n        sellFees.burn           = feesSellBurn;\r\n        sellFees.marketing      = feesSellMarketing;\r\n        total.sellFees          = sellFees.burn + sellFees.marketing;\r\n\r\n        total.totalFees         = total.buyFees + total.sellFees;\r\n\r\n        require(total.buyFees <= 1000 && total.sellFees <= 1000, \"Invalid fees\");\r\n\r\n        emit SettedFees(feesBuyBurn, feesBuyMarketing, feesSellBurn, feesSellMarketing);\r\n\r\n    }\r\n\r\n    function burn(uint256 amount) external {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    function forwardStuckToken(address token) external {\r\n        require(token != address(this), \"Cannot claim native tokens\");\r\n\r\n        uint256 balance;\r\n\r\n        if (token == address(0x0)) {\r\n            balance = address(this).balance;\r\n            payable(projectWallets.developmentWallet4).transfer(balance);\r\n        } else {\r\n            IERC20 tokenAddress = IERC20(token);\r\n            balance = IERC20(tokenAddress).balanceOf(address(this));\r\n            SafeERC20.safeTransfer(tokenAddress, projectWallets.developmentWallet4, balance);\r\n        }\r\n\r\n        emit ForwardStuckToken(token, balance);\r\n\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundsBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensToLP\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"AddLiquidityPoolEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ForwardStuckToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbSend\",\"type\":\"uint256\"}],\"name\":\"SendMarketing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"SendTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newBooleanConvert\",\"type\":\"bool\"}],\"name\":\"SettedBooleanConvert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesBuyBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesBuyMarketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesSellBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesSellMarketing\",\"type\":\"uint256\"}],\"name\":\"SettedFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPercent0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPercent1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPercent2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPercent3\",\"type\":\"uint256\"}],\"name\":\"SettedPercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDevelopmentWallet1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDevelopmentWallet2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDevelopmentWallet3\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDevelopmentWallet4\",\"type\":\"address\"}],\"name\":\"SettedProjectWallets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSswapTokensAtAmountLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSwapTokensAtAmountLimit\",\"type\":\"uint256\"}],\"name\":\"SettedSwapTokensAtAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"StartLaunch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountConvertedToBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimeStampLaunch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convertToBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"forwardStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBooleanConvert\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getCurrentFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percent0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent3\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"marketingWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"developmentWallet1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"developmentWallet2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"developmentWallet3\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"developmentWallet4\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"valueBNBgwei\",\"type\":\"uint256[]\"}],\"name\":\"sendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_booleanConvert\",\"type\":\"bool\"}],\"name\":\"setBooleanConvert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feesBuyBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesBuyMarketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesSellBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesSellMarketing\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent3\",\"type\":\"uint256\"}],\"name\":\"setSendPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesBuyMarketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesSellMarketing\",\"type\":\"uint256\"}],\"name\":\"setStartLaunch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapTokensAtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapTokensAtAmountLimit\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"telegram\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twitter\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"webSite\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BabyLuffy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://840210077aea45f68a19b3abec2aab1f2c4e86588c8d5425bce29d096b5f4baa"}