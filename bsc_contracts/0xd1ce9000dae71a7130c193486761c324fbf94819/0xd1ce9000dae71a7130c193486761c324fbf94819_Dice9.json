{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/BetStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { Math } from \\\"./Math.sol\\\";\\nimport { GameOption, GameOptions } from \\\"./GameOptions.sol\\\";\\nimport { PackedBet, PackedBets } from \\\"./PackedBets.sol\\\";\\n\\n/**\\n * The library provides abstractions to manage contract's bets storage in a code-friendly way.\\n *\\n * The main idea behind the routines is to abuse the fact that a single PackedBet occupies 32 bytes, meaining\\n * that the contract can store 8 of those in a single storage slot. Squeezing multiple bets into a single slots\\n * allows to save on gas tremendeously and requires just a handful of helper routines to make it transparent to the\\n * outer contract.\\n *\\n * The library exports a struct called Bets that is designed to keep track of players' bets \u2013 an instance of this structre,\\n * along with \\\"storage\\\" modifier, is required to invoke libraries' functions.\\n */\\nlibrary BetStorage {\\n  // Extension functions\\n  using PackedBets for PackedBet;\\n\\n  /**\\n   * The structure defining mappings to keep track of players' bets.\\n   * it keeps two separate mappings, one for tracking player nonces (seq numbers of bets being placed),\\n   * the other holds the data itself.\\n   */\\n  struct Bets {\\n    mapping (address => uint) playerNoncesBy8;\\n    mapping (address => mapping (uint => uint)) playerBets;\\n  }\\n\\n  // The bit to be set in playerNoncesBy8 mapping to disable accepting bets from an address\\n  uint constant internal PLAYER_NONCE_ACCOUNT_BANNED_BIT = 1;\\n  // The bit mask selecting the bits so that the number would turn into number mod 8\\n  uint constant internal PLAYER_NONCE_MOD8_MASK = uint(0x7);\\n  // The number of bits to shift the number to divide or multiply by 32 (log2(32))\\n  uint constant internal MULTIPLY_BY_32_BIT_SHIFT = 5;\\n  // The bit mask selecting exactly PackedBets.PACKED_BET_LENGTH bits\\n  uint constant internal PACKED_BET_MASK = 2 ** PackedBets.PACKED_BET_LENGTH - 1;\\n  // The bit mask selecting the bits so that the number would turn into number div 8\\n  uint constant internal PLAYER_NONCE_DIV8_MASK = ~PLAYER_NONCE_MOD8_MASK;\\n  // The number of packed bets stored in a single storage slot\\n  uint constant internal PACKED_BETS_PER_SLOT = 8;\\n\\n  // The bit mask selecting bits from 8 possible PackedBets stored in a single slot. ANDing the slot value with\\n  // this constant allows for quick checks of whether there any PackedBets with non-zero amounts in this slot.\\n  uint constant internal ALL_QUANT_AMOUNTS_MASK =\\n    PackedBets.QUANT_AMOUNT_MASK |\\n    PackedBets.QUANT_AMOUNT_MASK << (PackedBets.PACKED_BET_LENGTH * 1) |\\n    PackedBets.QUANT_AMOUNT_MASK << (PackedBets.PACKED_BET_LENGTH * 2) |\\n    PackedBets.QUANT_AMOUNT_MASK << (PackedBets.PACKED_BET_LENGTH * 3) |\\n    PackedBets.QUANT_AMOUNT_MASK << (PackedBets.PACKED_BET_LENGTH * 4) |\\n    PackedBets.QUANT_AMOUNT_MASK << (PackedBets.PACKED_BET_LENGTH * 5) |\\n    PackedBets.QUANT_AMOUNT_MASK << (PackedBets.PACKED_BET_LENGTH * 6) |\\n    PackedBets.QUANT_AMOUNT_MASK << (PackedBets.PACKED_BET_LENGTH * 7);\\n\\n  // The number indicating the slot is full with bets, i.e. all 8 spots are occupied by instances of PackedBet. The check is based\\n  // on the fact that we fill up the slot from left to right, meaning that placing the 8th PackedBet into a slot will set some bits higher than 224th one.\\n  uint constant internal FULL_SLOT_THRESHOLD = PackedBets.QUANT_AMOUNT_THRESHOLD << (PackedBets.PACKED_BET_LENGTH * 7);\\n\\n  // An error indicating the player's address is not allowed to place the bets\\n  error AccountSuspended();\\n\\n  /**\\n   * Being given the storage-located struct, the routine places PackedBet instance made by a player into a spare slot\\n   * and returns this bet's playerNonce - a seq number of the bet made by the player against this instance of the contract.\\n   *\\n   * @param bets the instance of Bets struct to manipulate.\\n   * @param player the address of the player placing the bet.\\n   * @param packedBet the instance of the PackedBet to place.\\n   *\\n   * @return playerNonce the seq number of the bet made by this player.\\n   */\\n  function storePackedBet(Bets storage bets, address player, PackedBet packedBet) internal returns (uint playerNonce) {\\n    // first off, read the current player's nonce. We are storing the nonces in 8 increments to avoid\\n    // unneccessary storage operations \u2013 in any case, each storage slot contains 8 bets, so we only need to know\\n    // the number / 8 to operate.\\n    uint playerNonceBy8 = bets.playerNoncesBy8[player];\\n\\n    // if the PLAYER_NONCE_ACCOUNT_BANNED_BIT bit is set, it means we do not want to accept the bets from this player's address\\n    if (playerNonceBy8 & PLAYER_NONCE_ACCOUNT_BANNED_BIT != 0) {\\n      revert AccountSuspended();\\n    }\\n\\n    // read the current slot being\\n    uint slot = bets.playerBets[player][playerNonceBy8];\\n\\n    // identify how many 32 bit chunks (i.e. PackedBet) are already stored there\\n    uint betOffsetInSlot = Math.getBitLength32(slot);\\n    // divide this number by 32 (to get from bit offsets to actual number)\\n    uint playerNonceMod8 = betOffsetInSlot >> MULTIPLY_BY_32_BIT_SHIFT;\\n\\n    // modify the slot by placing the current bet into the spare space \u2013 shift the data by freeShift value to achieve this\\n    slot |= (packedBet.toUint() << betOffsetInSlot);\\n\\n    // update the slot in the storage\\n    bets.playerBets[player][playerNonceBy8] = slot;\\n\\n    // IMPORTANT: did we just take the last available spot in the slot?\\n    if (playerNonceMod8 == (PACKED_BETS_PER_SLOT - 1)) {\\n      // if we did, update the player's nonce so that next bets would write to the new slot\\n      bets.playerNoncesBy8[player] = playerNonceBy8 + PACKED_BETS_PER_SLOT;\\n    }\\n\\n    // return full value of player's nonce\\n    playerNonce = playerNonceBy8 + playerNonceMod8;\\n  }\\n\\n  /**\\n   * Being given the storage-located struct, the routine extracts a bet from the storage.\\n   *\\n   * Extracting the bet means the corresponding part of the storage slot is modified so that the amount kept in\\n   * corresponding PackedBet entry is reset to 0 to indicate the bet has been proccessed.\\n   *\\n   * Once ALL of the bets in a slot are marked as processed, the slot is cleared to become 0, allowing us to reclaim a\\n   * bit of gas.\\n   *\\n   * @param bets the instance of Bets struct to manipulate.\\n   * @param player the address of the player placing the bet.\\n   * @param playerNonce the playerNonce to read from the storage.\\n   *\\n   * @return the instance of the PackedBet found in the corresponding slot; might be 0x0 if missing.\\n   */\\n  function ejectPackedBet(Bets storage bets, address player, uint playerNonce) internal returns (PackedBet) {\\n    // compute the playerNonce div 8 \u2013 that's the nonce value we use in the store (see storePackedBet)\\n    uint playerNonceBy8 = playerNonce & PLAYER_NONCE_DIV8_MASK;\\n    // compute the position of the bet in the slot \u2013 it's offset by N PackedBet places, where N = playerNonce mod 8\\n    uint betOffsetInSlot = (playerNonce & PLAYER_NONCE_MOD8_MASK) << MULTIPLY_BY_32_BIT_SHIFT;\\n\\n    // read the current slot's value\\n    uint slot = bets.playerBets[player][playerNonceBy8];\\n\\n    // read the specific PackedBet, ANDing with PACKED_BET_MASK to avoid integer overflows\\n    uint data = (slot >> betOffsetInSlot) & PACKED_BET_MASK;\\n\\n    // compute the positions of the bits where the amount value for the current bet is stored \u2013 it is simply\\n    // QUANT_AMOUNT_MASK shifted into the position of the PackedBet instance within the slot.\\n    uint amountZeroMask = ~(PackedBets.QUANT_AMOUNT_MASK << betOffsetInSlot);\\n\\n    // clear up the bits corresponding to amount of our packed bet, essentially clearing the amount down to 0\\n    slot &= amountZeroMask;\\n\\n    // check if all the spots in the slot contain 0s in amount AND if the slot is full...\\n    if (((slot & ALL_QUANT_AMOUNTS_MASK) == 0) && (slot >= FULL_SLOT_THRESHOLD)) {\\n      // delete the slot's data to get some gas refunded\\n      slot = 0;\\n    }\\n\\n    // update the storage\\n    bets.playerBets[player][playerNonceBy8] = slot;\\n\\n    // produce a PackedBet instance by wrapping the data. Since the data comes from the contract storage, and this library is the\\n    // only one that writes it, we do not need to perform additional validations here\\n    return PackedBet.wrap(data);\\n  }\\n\\n  /**\\n   * Marks the entry in playerNonce with a flag indicating this player address should not be allowed to place new bets.\\n   *\\n   * @param bets the instance of Bets struct to manipulate.\\n   * @param player the address of the player placing the bet.\\n   * @param suspend whether to suspend or un-suspend the player.\\n   */\\n  function suspendPlayer(Bets storage bets, address player, bool suspend) internal {\\n    if (suspend) {\\n      // set 1st bit on the nonce counter\\n      bets.playerNoncesBy8[player] |= PLAYER_NONCE_ACCOUNT_BANNED_BIT;\\n    } else {\\n      // clear 1st bit from the nonce counter\\n      bets.playerNoncesBy8[player] &= ~PLAYER_NONCE_ACCOUNT_BANNED_BIT;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/ContractState.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { Math } from \\\"./Math.sol\\\";\\n\\n/**\\n * The library provides an abstraction to maintain the summary state of the contract.\\n *\\n * The main idea is to aggregate all frequently accessed parameters into a structure called State\\n * which occupies a single 256-bit slot. Frequent mutations on it are performed in memory and only the\\n * final result is committed to storage.\\n *\\n * State also conveniently packs almost all information that is needed to compute locked amounts.\\n */\\nlibrary ContractState {\\n  // Extension functions.\\n  using Math for bool;\\n\\n  // A single 256-bit slot summary state structure. Custom sizes of the member fields are required for packing.\\n  struct State {\\n    // The total number of funds potentially due to be paid if all pending bets win\\n    uint96 lockedInBets;\\n    // The number of not-yet-settled bets that are playing for jackpot\\n    uint48 jackpotBetCount;\\n    // The value indicating the maximum potential win a bet is allowed to make. We have to cap that value to avoid\\n    // draining the contract in a single bet by whales who put huge bets for high odds.\\n    uint80 maxProfit;\\n    // The multiplier of the jackpot payment, set by the house.\\n    uint32 jackpotMultiplier;\\n  }\\n\\n  // The maximum number of jackpot bets to consider when testing for locked funds.\\n  uint constant internal JACKPOT_LOCK_COUNT_CAP = 5;\\n\\n  /**\\n   * Adding a new lock to prevent overcommitting to what the contract can't settle in worst case.\\n   *\\n   * @param lockedAmount newly locked amount.\\n   * @param playsForJackpot whether to account for a potential jackpot win.\\n   */\\n  function lockFunds(State memory self, uint lockedAmount, bool playsForJackpot) internal pure {\\n    // add the potential win to lockedInBets so that the contract always knows how much it owns in the worst case\\n    self.lockedInBets += uint96(lockedAmount);\\n    // increment the number of bets playing for a Jackpot to keep track of those too\\n    self.jackpotBetCount += uint48(playsForJackpot.toUint());\\n  }\\n\\n  /**\\n   * Remove the lock after the bet have been processed (settled/refunded).\\n   *\\n   * @param lockedAmount locked amount.\\n   * @param playsForJackpot whether it was a potential jackpot win.\\n   */\\n  function unlockFunds(State memory self, uint lockedAmount, bool playsForJackpot) internal pure {\\n    // remove the potential win from jackpot\\n    self.lockedInBets -= uint96(lockedAmount);\\n    // ... and decrease the jackpot bet count to reduce the jackpot locked amount as well\\n    self.jackpotBetCount -= uint48(playsForJackpot.toUint());\\n  }\\n\\n  /**\\n   * Remove the lock after the bet have been processed (settled/refunded). Direct storage access.\\n   *\\n   * @param lockedAmount locked amount.\\n   * @param playsForJackpot whether it was a potential jackpot win.\\n   */\\n  function unlockFundsStorage(State storage self, uint lockedAmount, bool playsForJackpot) internal {\\n    self.lockedInBets -= uint96(lockedAmount);\\n    self.jackpotBetCount -= uint48(playsForJackpot.toUint());\\n  }\\n\\n  /**\\n   * Computes the total value the contract currently owes to players in case all the pending bets resolve as winning ones.\\n   *\\n   * The value is composed primarily from the sum of possible wins from every bet and further increased by the current maximum\\n   * Jackpot payout value for every bet playing for Jackpot (capped at 5 since Jackpots are very rare).\\n   *\\n   * Note re lock multiplier: the value should result in the locked amount conforming to the logic of computeJackpotAmount in Dice9.sol.\\n   * This would mean it needs to equal product JACKPOT_FEE and JACK_MODULO and maximum winning per paytable (4) divided\\n   * by the fixed point base of the jackpot multiplier (8).\\n   *\\n   * @param maxJackpotPayment maximum jackpot win amount according to the paytable.\\n   * @param jackpotMultiplierBase the denominator of the jackpotMultiplier value.\\n   *\\n   * @return the total number of funds required to cover the most extreme resolution of pending bets (everything wins everything).\\n   */\\n  function totalLockedInBets(State memory self, uint maxJackpotPayment, uint jackpotMultiplierBase) internal pure returns (uint) {\\n    // cap the amount of jackpot locks as those are rare and locks are too conservative as a result\\n    uint jackpotLocks = Math.min(self.jackpotBetCount, JACKPOT_LOCK_COUNT_CAP);\\n    uint jackpotLockedAmount = jackpotLocks * self.jackpotMultiplier * maxJackpotPayment / jackpotMultiplierBase;\\n\\n    // compute total locked amount (regular bet winnings + jackpot winnings)\\n    return self.lockedInBets + jackpotLockedAmount;\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Dice9.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { TinyStrings, TinyString } from \\\"./TinyStrings.sol\\\";\\nimport { Math } from \\\"./Math.sol\\\";\\nimport { Options } from \\\"./Options.sol\\\";\\nimport { BetStorage } from \\\"./BetStorage.sol\\\";\\nimport { GameOptions, GameOption } from \\\"./GameOptions.sol\\\";\\nimport { PackedBets, PackedBet } from \\\"./PackedBets.sol\\\";\\nimport { ContractState } from \\\"./ContractState.sol\\\";\\nimport { VRF } from \\\"./VRF.sol\\\";\\n\\n/**\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n * *                                                                                                                                   * *\\n * *                                                      Welcome to dice9.win!                                                        * *\\n * *                                                                                                                                   * *\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n *\\n * Summary\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * Inspired by many projects in the Ethereum ecosystem, this smart contract implements a set of robust, provably fair games of chance.\\n * The users can play one of four available games, wagering cryptocurrency at the odds they choose and even take part in Jackpot rolls!\\n *\\n * Coin Flip\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * This game allows to choose a side of the coin \u2013 heads or tails \u2013 and bet on it. Once the bet settles, the winning amount is paid if the\\n * side matches the one chosen by the player.\\n *\\n * Dice\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * This game allows to choose 1 to 5 numbers of a dice cube and wins if a dice roll ends up with one of those numbers. The more numbers\\n * are chosen the higher is the chance of winning, but the multiplier is less.\\n *\\n * Two Dice\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * This game allows to choose 1 to 11 numbers representing the sum of two dice. Similar to Dice game, if two dice add up to one of the\\n * numbers chosen, the winnings are paid back.\\n *\\n * Etheroll\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * This game allows to place a bet on a number in 3 to 97 range, and if the random number produced (from 1..100 range) is less or equal\\n * than the chosen one, the bet is considered a win.\\n *\\n * Winnings\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * If a bet wins, all the funds (including Jackpot payment, if it was eligible and won the Jackpot) are paid back to the address which\\n * made the bet. Due to legal aspects, we do not distribute the winnings to other address(es), other currencies and so on.\\n *\\n * Jackpots\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * If a bet exceeds a certain amount (the UI will display that), a tiny Jackpot fee is taken on top of default House commission and the\\n * bet automatically plays for Jackpot. Jackpots are events that have 0.1% chance of happening, but if they do, the bet gets an extra\\n * portion of the winnings determined by Jackpot logic. The Jackpot rolls are completely independent from the games themselves, meaning\\n * if a bet that lost a game can still get a Jackpot win.\\n *\\n * Commisions\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * In order to maintain the game, which includes paying for bet resolution transactions, servers for the website, our support engineers\\n * and developers, the smart contract takes a fee from every bet. The specific amounts can be seen below in the constants named\\n * HOUSE_EDGE_PERCENT, HOUSE_EDGE_MINIMUM_AMOUNT and JACKPOT_FEE.\\n *\\n * Questions?\\n * ---------------------------------------------------------------------------------------------------------------------------------------\\n * Please feel free to refer to our website at https://dice9.win for instructions on how to play, support channel, legal documents\\n * and other helpful things.\\n *\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n * *                                                                                                                                   * *\\n * *                                               Good luck and see you at the tables!                                                * *\\n * *                                                                                                                                   * *\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\n */\\ncontract Dice9 {\\n  // Extension functions\\n  using TinyStrings for TinyString;\\n  using TinyStrings for string;\\n  using GameOptions for GameOption;\\n  using PackedBets for PackedBet;\\n  using ContractState for ContractState.State;\\n  using Math for bool;\\n\\n  // The minimum amount of the fee the contract takes (this is required to support small bets)\\n  uint constant internal HOUSE_EDGE_MINIMUM_AMOUNT = 0.01 ether;\\n  // The minimum amount wagered that makes the bet play for Jackpot\\n  uint constant internal MIN_JACKPOT_BET = 1 ether;\\n  // The fee taken from player's bet as a contribution to Jackpot fund\\n  uint constant internal JACKPOT_FEE = 0.01 ether;\\n  // The probability of any eligible bet to win a Jackpot\\n  uint constant internal JACKPOT_MODULO = 1000;\\n  // The target number to be rolled to win the jackpot\\n  uint constant internal JACKPOT_WINNING_OUTCOME = 888;\\n  // What percentage does the smart conract take as a processing fee\\n  uint constant internal HOUSE_EDGE_PERCENT = 1;\\n  // The denominator of jackpotMultiplier value\\n  uint constant internal JACKPOT_MULTIPLIER_BASE = 8;\\n  // The paytable of the jackpot: each 2 octets specify the multiplier of the base jackpot to be paid\\n  uint constant internal JACKPOT_PAYTABLE = 0x0000000000000000000000000404040408080808101010101010101010202040;\\n  // The base Jackpot value used for calculations\\n  uint constant internal BASE_JACKPOT_PAYMENT = JACKPOT_MODULO * JACKPOT_FEE;\\n  // The maximum Jackpot payment before applying the multplier (max value from JACKPOT_PAYTABLE is 4).\\n  uint constant internal MAX_JACKPOT_PAYMENT = BASE_JACKPOT_PAYMENT * 4;\\n  // The number of slots in the Jackpot paytable.\\n  uint constant internal JACKPOT_PAYTABLE_SLOTS_COUNT = 20;\\n  // The denominator of the values from JACKPOT_PAYTABLE\\n  uint constant internal JACKPOT_PAYTABLE_BASE = 16;\\n  // The number of epochs to pass before the bet becomes refundable\\n  uint constant internal REFUNDABLE_BET_EPOCHS_DISTANCE = 2;\\n\\n  // The RSA modulus values as 4 uint256 integers.\\n  uint constant internal MODULUS0 = 0xa641af27919c7380efcf44e86253d0cce8cb6d073892955cb0f8d809a40b03db;\\n  uint constant internal MODULUS1 = 0x7b104a8a6a0b39250af38ddfbcd19190c9524de5e43cb4478af7fb168303e047;\\n  uint constant internal MODULUS2 = 0xc89ca488073d59a2d4639162837af22492333fc5822cc48af3caaf55a0571c8d;\\n  uint constant internal MODULUS3 = 0xa50aa0314b9769e3f4c8f9cd462ba858bab3af6cb08202d87a7b3e70ec4b9c99;\\n\\n  // A non-interactive zero knowledge proof of the fact that RSA modulus above creates a permutation (see https://github.com/dice9win/ for further details):\\n  //  nizk:8:0:NZb1WEVQ/q05yDL/rQX9nz2heXgA7+mV0cddUosuHaFoLmCltrUX2z8HiN52HJBwRdt801nUzcL4VTOC4hkGwR6vZVjnmZsZQYPibm4PFaz7egOTD3JzU2zZSIf3elcTmMUTSLXIU8yf/ov9t+Z2SqYIXst1pLZPy2RkzDnb4oc=\\n  //  nizk:8:1:Hd0syQZo2IDZN3kL/9/eNHSpVGjJpuccHJ6f9KFYklA1gdMZKiV/Tl5tcNT+0MmDOkWPNoRLP+kWDooT+x3i0vQbhrrIj7RO/ZhYT8VIt6Nlet+byutIVGzKEky0r+nYudKpxA5WKG+E3w9LGrtJTgcaWGdoXRvvAgIXVghlhKI=\\n  //  nizk:8:2:BYW9SOx+6FpwDj768Ppvg4IIDSQEI0cBFkXgoI/QlhbaKcz4i6q6STj0OUKGFLCHQZ6iB4AmYMpm+zIhv0wOHRi/YSzwKKuVQ37UiQH08iGwT75IeUR/lI8QbvT255seWzQbRGEdKLI4K3JneGiOeWSAGv/aiwmL5SVHuY+wPTw=\\n  //  nizk:8:3:TX77sExWqEzA42PEfa4Vy0bfCjXxH27hYoRrdOxjy+W4L58GtL9KVsbeuEuJSta1uCkLBXbaHeYd+DNfn/4y0ZgQ9ZHinsMsogHuZObEbWzCKgWbrAS8GKYzFTPizTw+zXD279g5W/fx/Yr34QjknD8g95qkqt6S1Sa7+ZC9XlA=\\n  //  nizk:8:4:hGfiiPEW4yHpXEC4Ed+RSqaKxl3At8gGllrjjcOhPBFKiRGno35WzhfBD3e8glfPGIHz1kBSDgh/H/Lfme49RkSuoZPvfue68g7k5Hp9KXe/Fldsnpgfx+Cci9h+R/b3OJ9oSQ3/dJT6hHk93DMECwn1vUtXgcA+vg1+eS2f8qE=\\n  //  nizk:8:5:hmHQESr1PCy1zggnB5FrbYTavsPR4InJlhG0Cavjdd6psc1edZvv0xqTGK5LjgXt/9K5NOwh3d/ElExoI7hkvhj8u5+xIJnoH6oYhYjMHHo9pkuuYfc2AwL9cY4l++G3BSQ4C/eUT/KzaIs+sH2f7i8nDJzn0Xt8uxQKnKelVzQ=\\n  //  nizk:8:6:dJgF6Fi8QVVh/w/P7+gK4K/Btb0Zea5wnve5qkUpETTsWZQ4M3sfaCIZBbpRVssPpvraIWjkd4Ak//2w5CZUadC2GkKcM3AQJ2LxbBXwqpA9VPqpWqJGJftGMVKagctVw+CTLTsMd+unzr65ZVGWB/6fOSLjC1NMU1zhrHIgd/M=\\n  //  nizk:8:7:K3Jg/MJE8dzQv0LfapouDIT/zcWjp4jE1BhnP1xU35Voxs0IqnN+CEUCrhhHlcFFCiFTWu+vOW8v+KFWD/GmMcaJfrSL3IZ+BHVg3F+DoCVQQ/HQDFSJnHyCQm/RajTd3zYXg9AT/EXqlB0YJtMYFfTmKBQUW5fWRvdCHGJo5Rw=\\n\\n  // A structure containing the frequently accessed state of the contract packed into a single 256-bit slot\\n  // to save on storage gas costs.\\n  ContractState.State contractState;\\n\\n  // The address allowed to tweak system settings of the contract.\\n  address payable public owner;\\n\\n  // The to-be-promoted address that would become owner upon approval.\\n  address payable internal nextOwner;\\n\\n  // The bets placed by the players that are kept in contract's storage.\\n  BetStorage.Bets internal bets;\\n\\n  /**\\n   * The event that gets logged when a bet is placed.\\n   *\\n   * @param vrfInputHash the hash of bet attributes (see VRF.sol).\\n   * @param player the address that placed the bet.\\n   * @param playerNonce the seq number of the player's bet against this contract.\\n   * @param amount the amount of bet wagered.\\n   * @param packedBet the game and options chosen (see PackedBet.sol)\\n   * @param humanReadable a human-readable description of bet (e.g. \\\"CoinFlip heads\\\")\\n   */\\n  event Placed(bytes32 indexed vrfInputHash, address player, uint playerNonce, uint amount, uint packedBet, string humanReadable);\\n\\n  /**\\n   * The event that gets logged when a bet is won.\\n   *\\n   * @param vrfInputHash the hash of bet attributes (see VRF.sol).\\n   * @param player the address that placed the bet.\\n   * @param playerNonce the seq number of the player's bet against this contract.\\n   * @param payment the amount the bet pays as winnings.\\n   * @param jackpotPayment the amount the bet pays as jackpot winnings.\\n   * @param humanReadable a human-readable description of outcome (e.g. \\\"CoinFlip heads heads 888\\\")\\n   */\\n  event Won(bytes32 indexed vrfInputHash, address player, uint playerNonce, uint payment, uint jackpotPayment, string humanReadable);\\n\\n  /**\\n   * The event that gets logged when a bet is won.\\n   *\\n   * @param vrfInputHash the hash of bet attributes (see VRF.sol).\\n   * @param player the address that placed the bet.\\n   * @param playerNonce the seq number of the player's bet against this contract.\\n   * @param payment the amount the bet pays as a consolation.\\n   * @param jackpotPayment the amount the bet pays as jackpot winnings.\\n   * @param humanReadable a human-readable description of outcome (e.g. \\\"CoinFlip heads tails 887\\\")\\n   */\\n  event Lost(bytes32 indexed vrfInputHash, address player, uint playerNonce, uint payment, uint jackpotPayment, string humanReadable);\\n\\n  /**\\n   * The event that gets logged when somebody attemps to settle the same bet twice.\\n   *\\n   * @param player the address that placed the bet.\\n   * @param playerNonce the seq number of the player's bet against this contract.\\n   */\\n  event Duplicate(address player, uint playerNonce);\\n\\n  /**\\n   * The event that gets logged when somebody attemps to settle non-existed (already removed?) bet.\\n   *\\n   * @param player the address that placed the bet.\\n   * @param playerNonce the seq number of the player's bet against this contract.\\n   */\\n  event Nonexistent(address player, uint playerNonce);\\n\\n  /**\\n   * The event that gets logged when the House updates the maxProfit cap.\\n   *\\n   * @param value the new maxProfit value.\\n   */\\n  event MaxProfitUpdated(uint value);\\n\\n  /**\\n   * The event that gets logged when the House updates the Jackpot multiplier.\\n   *\\n   * @param value the new jackpotMultiplier value.\\n   */\\n  event JackpotMultiplierUpdated(uint value);\\n\\n  // The error logged when a player attempts to bet on both CoinFlip outcomes at the same time.\\n  error CoinFlipSingleOption();\\n  // The error logged when a player attempts to bet on multiple outcomes in Etheroll.\\n  error EtherollSingleOption();\\n  // The error logged when the contract receives the bet it might be unable to pay out.\\n  error CannotAffordToLoseThisBet();\\n  // The error logged when the contract receives the bet that can win more than maxProfit amount.\\n  error MaxProfitExceeded();\\n  // The error logged when the contract receives malformed batch of ecrypted bets to settle.\\n  error NonFullVRFs();\\n  // The error logged when the contract receives malformed encrypted bet.\\n  error StorageSignatureMismatch(address player, uint playerNonce);\\n  // The error logged when the contract receives a bet with 0 or 100+ winning probability (e.g. betting on all dice outcomes at once)\\n  error WinProbabilityOutOfRange(uint numerator, uint denominator);\\n  // The error logged when somebody attempts to refund the bet at the wrong time.\\n  error RefundEpochMismatch(address player, uint playerNonce, uint betEpoch, uint currentEpoch);\\n\\n  /**\\n   * The modifier checking that the transaction was signed by the creator of the contract.\\n   */\\n  modifier onlyOwner {\\n    require(msg.sender == owner, \\\"Only owner can do this\\\");\\n    _;\\n  }\\n\\n  /**\\n   * Constructs the new instance of the contract by setting the default values for contract settings.\\n   */\\n  constructor() payable {\\n    owner = payable(msg.sender);\\n    nextOwner = payable(0x0);\\n\\n    contractState.maxProfit = 100 ether;\\n    contractState.jackpotMultiplier = 8;\\n  }\\n\\n  /**\\n   * The entry point function to place a bet in a CoinFlip game.\\n   *\\n   * The first parameter is not used in any way by the smart contract and can be ignored \u2013 it's sole purpose\\n   * is to make Dice9 frontend find player's bets faster; it does not affect the logic in any way.\\n   *\\n   * The second parameter is a string containing \\\"heads\\\", \\\"tails\\\", \\\"0\\\" or \\\"1\\\" - indicating the side of the coin\\n   * the player is willing to put a bet on.\\n   *\\n   * @param options human-readable string of options to lace a bet on.\\n   */\\n  function playCoinFlip(uint /* unusedBetId */, string calldata options) external payable {\\n    (uint mask,) = Options.parseOptions(options.toTinyString(), 0, 1);\\n\\n    // make sure there is a single option selected\\n    if (!Math.isPowerOf2(mask)) {\\n      revert CoinFlipSingleOption();\\n    }\\n\\n    placeBet(msg.sender, msg.value, GameOptions.toCoinFlipOptions(mask));\\n  }\\n\\n  /**\\n   * The entry point function to place a bet in a Dice game.\\n   *\\n   * The first parameter is not used in any way by the smart contract and can be ignored \u2013 it's sole purpose\\n   * is to make Dice9 frontend find player's bets faster; it does not affect the logic in any way.\\n   *\\n   * The second parameter is a string containing number(s) in the range of 1..6, e.g. \\\"1\\\" or \\\"4,5,6\\\" indicating\\n   * the dice outcome(s) the user is willing to place a bet on.\\n   *\\n   * @param options human-readable string of options to lace a bet on.\\n   */\\n  function playDice(uint /* unusedBetId */, string calldata options) external payable {\\n    (uint mask,) = Options.parseOptions(options.toTinyString(), 1, 6);\\n    placeBet(msg.sender, msg.value, GameOptions.toDiceOptions(mask));\\n  }\\n\\n  /**\\n   * The entry point function to place a bet in a TwoDice game.\\n   *\\n   * The first parameter is not used in any way by the smart contract and can be ignored \u2013 it's sole purpose\\n   * is to make Dice9 frontend find player's bets faster; it does not affect the logic in any way.\\n   *\\n   * The second parameter is a string containing number(s) in the range of 2..12, e.g. \\\"2\\\" or \\\"8,12\\\" indicating\\n   * the sum of two dice roll(s) the user is willing to place a bet on.\\n   *\\n   * @param options human-readable string of options to lace a bet on.\\n   */\\n  function playTwoDice(uint /* unusedBetId */, string calldata options) external payable {\\n    (uint mask,) = Options.parseOptions(options.toTinyString(), 2, 12);\\n    placeBet(msg.sender, msg.value, GameOptions.toTwoDiceOptions(mask));\\n  }\\n\\n  /**\\n   * The entry point function to place a bet in a Etheroll game.\\n   *\\n   * The first parameter is not used in any way by the smart contract and can be ignored \u2013 it's sole purpose\\n   * is to make Dice9 frontend find player's bets faster; it does not affect the logic in any way.\\n   *\\n   * The second parameter is a string containing number(s) in the range of 3..97, e.g. \\\"5\\\" or \\\"95\\\" indicating\\n   * the number the user is willing to place a bet on.\\n   *\\n   * @param options human-readable string of options to lace a bet on.\\n   */\\n  function playEtheroll(uint /* unusedBetId */, string calldata options) external payable {\\n    (uint mask, uint option) = Options.parseOptions(options.toTinyString(), 3, 97);\\n\\n    // make sure there is a single option selected\\n    if (!Math.isPowerOf2(mask)) {\\n      revert EtherollSingleOption();\\n    }\\n\\n    placeBet(msg.sender, msg.value, GameOptions.toEtherollOptions(option));\\n  }\\n\\n  /**\\n   * The generic all-mighty function processing all the games once the input parameters have been read and validated\\n   * by corresponding playXXX public methods.\\n   *\\n   * Accepting player's address, bet amount and GameOption instance describing the game being played, the function\\n   * stores the bet information in the contract's storage so that it can be settled by a Croupier later down the road.\\n   *\\n   * The function performs a few boring, but very important checks:\\n   *  1. It makes sure that all the bets currently accepted will be payable, even if all of them win (since we do not know upfront).\\n   *     If the contract sees that the potential winnings from pending bets exceed contract's balance, it would refrain from accepting the bet.\\n   *  2. If checks that the current bet will not win \\\"too much\\\" \u2013 a value depicted by maxProfit - a fair limitation kept in place to avoid\\n   *     situations when a single whale drains the contract in one lucky bet and everyone else has to wait until the House tops the contract up.\\n   *     Please mind this value is kept reasonably high so you should rarely run into such a limitation.\\n   *  3. It makes sure the player does not place \\\"non-sensial\\\" bets, like all Dice numbers or no sides in CoinFlip.\\n   *\\n   * If everything goes well, the contract storage is updated with the new bet and a log entry is recorded on the blockchain so that the\\n   * player can validate the parameters of the bet accepted.\\n   *\\n   * @param player the address of the player placing a bit.\\n   * @param amount the amount of the bet the player wagers.\\n   * @param gameOptions the choice(s) and the game type selected by the player.\\n   */\\n  function placeBet(address player, uint amount, GameOption gameOptions) internal {\\n    // check if the bet plays for jackpot\\n    bool playsForJackpot = amount >= MIN_JACKPOT_BET;\\n\\n    // pack the bet into an instance of PackedBet\\n    PackedBet packedBet = PackedBets.pack(amount, gameOptions, playsForJackpot);\\n\\n    // extract the bet information with regards to ods to compute the winAmount\\n    (uint numerator, uint denominator,, TinyString humanReadable) = gameOptions.describe();\\n    // consider this bet wins: how big the win is going to be?\\n    uint winAmount = computeWinAmount(amount, numerator, denominator, playsForJackpot);\\n\\n    // add locks on contract funds arising from having to process this bet\\n    ContractState.State memory updatedContractState = contractState;\\n    updatedContractState.lockFunds(winAmount, playsForJackpot);\\n\\n    // compute the amount the contract has to have available to pay if everyone wins and compare that to the current balance\\n    if (updatedContractState.totalLockedInBets(MAX_JACKPOT_PAYMENT, JACKPOT_MULTIPLIER_BASE) > address(this).balance) {\\n      // ok, we potentially owe too much and cannot accept this bet\\n      revert CannotAffordToLoseThisBet();\\n    }\\n\\n    // check if the winning amount of the bet sans the amount wagered exceeds the maxProfit limit\\n    if (winAmount > amount + updatedContractState.maxProfit) {\\n      // ok, the win seems to be too big - crash away\\n      revert MaxProfitExceeded();\\n    }\\n\\n    // all seems good - just store the bet in contract's storage\\n    uint playerNonce = BetStorage.storePackedBet(bets, player, packedBet);\\n\\n    // append \\\"jckpt\\\" string if the bet plays for jackpot\\n    if (playsForJackpot) {\\n      humanReadable = humanReadable.append(TinyStrings.SPACE).append(GameOptions.JCKPT_STR);\\n    }\\n\\n    // compute VRF input hash - a hash of all bet attributes that would uniquely identify this bet\\n    bytes32 vrfInputHash = VRF.computeVrfInputHash(player, playerNonce, packedBet.withoutEpoch());\\n\\n    // commit fund locks to storage\\n    contractState = updatedContractState;\\n\\n    // log the bet being placed successfully\\n    emit Placed(vrfInputHash, player, playerNonce, amount, packedBet.toUint(), humanReadable.toString());\\n  }\\n\\n  /**\\n   * This is main workhorse of the contract: the routine that settles the bets previously placed by the players.\\n   *\\n   * It is expected that a Croupier (i.e. our software having access to the secret encryption key) would invoke this function,\\n   * passing some number of ecnrypted bets. The RSA VRF utilities (see VRF.sol) would validate the authenticity of the ecrypted data\\n   * received (e.g. check that the bets are encrypted with the specific secret key).\\n   *\\n   * If the authencity is confirmed, the routine would use the encrypted text as the source of entropy \u2013 essentially, treat\\n   * the encrypted bet data as a huge number. Since the contract uses pretty strong and battle-tested encryption (RSA 1024 bits), this\\n   * number is guaranteed to be unpredictable and uniformely distributed. The only party which can produce this number is, of course,\\n   * the Croupier \u2013 the possession of the secret key is required to calculate the number. The Croupier, in its turn, cannot tamper\\n   * with the bet attributes (since the contract keeps track of what players bet on) and has to create a number for every bet submitted.\\n   * Since the key is fixed, every bet attributes get a single, unique number from the croupier.\\n   *\\n   * More technical details are available in VRF.sol.\\n   *\\n   * @param vrfs the blob of VRF(s) chunks to use for bet settlement.\\n   */\\n  function settleBet(bytes calldata vrfs) external {\\n    // first and foremost, make sure there is a whole number of VRF chunks in the calldata\\n    if (vrfs.length % VRF.RSA_CIPHER_TEXT_BYTES != 0) {\\n      // there is not \u2013 just revert, no way to even try, it is coming from a malicious actor\\n      revert NonFullVRFs();\\n    }\\n\\n    // move contract summary state to memory, as it will be updated several times (especially if batching)\\n    ContractState.State memory updatedContractState = contractState;\\n\\n    // iterate over callback bytes in chunks of RSA_CIPHER_TEXT_BYTES size\\n    for (uint start = 0; start < vrfs.length; start += VRF.RSA_CIPHER_TEXT_BYTES) {\\n      // get the current slice of VRF.RSA_CIPHER_TEXT_BYTES bytes\\n      bytes calldata slice = vrfs[start:start+VRF.RSA_CIPHER_TEXT_BYTES];\\n\\n      // use VRF.decrypt library to decrypt, validate and decode bet structure encoded in this particular chunk of calldata\\n      // unless the function reverts (which it would do shall there be anything wrong), it would return a fully decoded bet along\\n      // with vrfHash parameter \u2013 this is going to act as out entropy source\\n      (bytes32 vrfHash, bytes32 vrfInputHash, address player, uint playerNonce, PackedBet packedBet) = VRF.decrypt(MODULUS0, MODULUS1, MODULUS2, MODULUS3, slice);\\n\\n      // get the (supposedly the same) bet from bet storage \u2013 it is trivial since we have both player and playerNonce values\\n      PackedBet ejectedPackedBet = BetStorage.ejectPackedBet(bets, player, playerNonce);\\n\\n      // check if the bet is not blank\\n      if (ejectedPackedBet.isEmpty()) {\\n        // it is blank \u2013 probably already settled, so just carry on\\n        emit Nonexistent(player, playerNonce);\\n        continue;\\n      }\\n\\n      // check if the bet's amount is set to zero \u2013 we are using this trick (see BetStorage.sol) to mark bets\\n      // which have already been handled\\n      if (ejectedPackedBet.hasZeroAmount()) {\\n        // it has been settled already, so just carry on\\n        emit Duplicate(player, playerNonce);\\n        continue;\\n      }\\n\\n      // at this point it looks like the bet is fully valid \u2013 let's make sure the contract storage contains\\n      // exactly the same attributes as the decrypted data; we just need to be mindful that decrypted bets don't\\n      // contain any epoch information, so we ignore it for comparisons\\n      if (!ejectedPackedBet.withoutEpoch().equals(packedBet)) {\\n        // this is a pretty suspicious situation: the decrypted attributes do not match the data in the storage, as if\\n        // someone would try to settle a bet and alter its parameters at the same time. we don't like this and we crash\\n        revert StorageSignatureMismatch(player, playerNonce);\\n      }\\n\\n      // at this point the bet seems valid, matches it decrypted counterpart and is ready to be settled\\n\\n      // first of all, decode the bet into its attributes...\\n      (uint winAmount, bool playsForJackpot, uint betDenominator, uint betMask, TinyString betDescription) = describePackedBet(packedBet);\\n      // ...and pass those attributes to compute the actual outcome\\n      (bool isWin, uint payment, uint jackpotPayment, TinyString outcomeDescription) = computeBetOutcomes(uint(vrfHash), winAmount, playsForJackpot, betDenominator, betMask, betDescription);\\n\\n      // remove fund locks (since we are processing the bet now)\\n      updatedContractState.unlockFunds(winAmount, playsForJackpot);\\n\\n      // did the bet win?\\n      if (isWin) {\\n        // yes! congratulations, log the information onto the blockchain\\n        emit Won(vrfInputHash, player, playerNonce, payment, jackpotPayment, outcomeDescription.toString());\\n      } else {\\n        // nope :( it is ok, you can try again \u2013 log the information onto the blockchain\\n        emit Lost(vrfInputHash, player, playerNonce, payment, jackpotPayment, outcomeDescription.toString());\\n      }\\n\\n      // compute the total payment\\n      uint totalPayment = payment + jackpotPayment;\\n\\n      // invoke the actual funds transfer and revert if it fails for any reason\\n      (bool transferSuccess,) = player.call{value: totalPayment + Math.toUint(totalPayment == 0)}(\\\"\\\");\\n      require(transferSuccess, \\\"Transfer failed!\\\");\\n    }\\n\\n    // commit summary state to storage\\n    contractState = updatedContractState;\\n  }\\n\\n  /**\\n   * A publicly available function used to request a refund on a bet if it was not processed.\\n   *\\n   * The player or the House can refund any unprocessed bet during every other 8-hour window following\\n   * the bet.\\n   *\\n   * The logic of the time constraint is as follows:\\n   *  1. The day is split into 4 hour windows, i.e. 00:00-08:00, 08:00-16:00, 16:00-24:00 etc\\n   *  2. The smart contract keeps track of the window number the bet was placed in. For example, if\\n   *     the bet is placed at 02:15, it will be attributed to 00:00-08:00 window.\\n   *  3. The player can request the refund during every other 8-hour window following the bet.\\n   *     For example, if the bet is placed at 02:15, one can refund it during 16:00-20:00, or\\n   *     during 04:00-12:00 (next day), but not at 12:00 the same day.\\n   *\\n   * The refund window logic is a bit convoluted, but it is kept this way to minimise the gas requirements\\n   * imposed on all the bets going through the system. It is in House's best interests to make sure\\n   * this function is never needed \u2013 if all the bets are processed in a timely manner, noone would ever\\n   * invoke this. We decided to keep this in, however, to assure the players the funds will never end up\\n   * locked up in the contract, even if the Croupier stops revealing all the bets forever.\\n   *\\n   * @param player the address of the player that made the bet. Must match the sender's address or the contract owner.\\n   * @param playerNonce the playerNonce of the bet to refund\\n   */\\n  function refundBet(address player, uint playerNonce) external {\\n    // make sure a legit party is asking for a refund\\n    require(((msg.sender == player) || (msg.sender == owner)), \\\"Only the player or the House can do this.\\\");\\n\\n    // extract the bet from the storage\\n    PackedBet ejectedPackedBet = BetStorage.ejectPackedBet(bets, player, playerNonce);\\n\\n    // check if the bet is not blank\\n    if (ejectedPackedBet.isEmpty()) {\\n      // it is blank \u2013 probably already settled, so just carry on\\n      emit Nonexistent(player, playerNonce);\\n      return;\\n    }\\n\\n    // check if the bet's amount is set to zero \u2013 we are using this trick (see BetStorage.sol) to mark bets\\n    // which have already been handled\\n    if (ejectedPackedBet.hasZeroAmount()) {\\n      // it has been settled already, so just carry on\\n      emit Duplicate(player, playerNonce);\\n      return;\\n    }\\n\\n    // get the bet's and current epochs \u2013 those would be integers from 0..3 range denoting the number of\\n    // the 4 hour windows corresponding to the epochs\\n    (uint betEpoch, uint currentEpoch) = ejectedPackedBet.extractEpochs();\\n    // compute the distance between two epochs mod 4\\n    uint epochDistance = (currentEpoch + PackedBets.EPOCH_NUMBER_MODULO - betEpoch) & PackedBets.EPOCH_NUMBER_MODULO_MASK;\\n\\n    // check if bet's epoch is good for refund\\n    if (epochDistance < REFUNDABLE_BET_EPOCHS_DISTANCE) {\\n      // we actually have to revert here since we have just modified the storage and are no taking any action\\n      revert RefundEpochMismatch(player, playerNonce, betEpoch, currentEpoch & PackedBets.EPOCH_NUMBER_MODULO_MASK);\\n    }\\n\\n    // unlock the funds since the bet is getting refunded\\n    (uint winAmount, bool playsForJackpot,,,) = describePackedBet(ejectedPackedBet);\\n    contractState.unlockFundsStorage(winAmount, playsForJackpot);\\n\\n    // send the funds back\\n    (,uint amount,) = ejectedPackedBet.unpack();\\n    (bool transferSuccess,) = player.call{value: amount}(\\\"\\\");\\n    require(transferSuccess, \\\"Transfer failed!\\\");\\n  }\\n\\n  /**\\n   * Being given an instance of PackedBet, decodes it into a set of parameters, specifically:\\n   *  1. What would the payment amount to if the bet wins.\\n   *  2. Whether the bet should play for Jackpot.\\n   *  3. What is the bet's game's denominator (2 for Coin Flip, 6 for Dice etc).\\n   *  4. What were the options chosen by the user (a.k.a. bet mask).\\n   *  5. What is the human-readable description of this bet.\\n   *\\n   * These parameters can further be utilised during processing or refunding of the bet.\\n   *\\n   * @param packedBet an instance of PackedBet to decode.\\n   *\\n   * @return winAmount how much the bet should pay back if it wins.\\n   *         playsForJackpot whether the bet should take part in a Jackpot roll.\\n   *         betDenominator the denominator of the game described by this bet.\\n   *         betMask the options the user chose in a form of a bitmask.\\n   *         betDescription the human-readable description of the bet.\\n   */\\n  function describePackedBet(PackedBet packedBet) internal pure returns (uint winAmount, bool playsForJackpot, uint betDenominator, uint betMask, TinyString betDescription) {\\n    // unpack the packed bet to get to know its amount, options chosen and whether it should play for Jackpot\\n    (GameOption gameOptions, uint amount, bool isJackpot) = packedBet.unpack();\\n    // unpack the GameOption instance into bet attributes and gather human-readable wager description at the same time\\n    (uint numerator, uint denominator, uint mask, TinyString description) = gameOptions.describe();\\n\\n    // compute the amount of money this bet would pay if it is winning\\n    winAmount = computeWinAmount(amount, numerator, denominator, isJackpot);\\n    // return true if the bet plays for jackpot\\n    playsForJackpot = isJackpot;\\n    // transfer other attributes to the result\\n    betDenominator = denominator;\\n    betMask = mask;\\n    betDescription = description;\\n  }\\n\\n  /**\\n   * Being given the entropy value and bet parameters, computes all the outcomes of the bet, speficically:\\n   *  1. The amount won, if the bet wins\\n   *  2. The amount of Jackpot payment, if the bet wins the jackpot\\n   *  3. The human-readable representation of the outcome (e.g. \\\"Dice 1,2,3 2 888\\\" or \\\"CoinFlip tails heads 555\\\")\\n   *\\n   * The incoming entropy integer is split into 3 chunks: game-dependent entropy, jackpot-dependent entropy and jackpot payment entropy.\\n   * All these values are taken from different parts of the combined entropy to make sure there is no implicit dependency between\\n   * out come values.\\n   *\\n   * @param entropy the RNG value to use for deciding the bet.\\n   * @param winAmount how much the bet should pay back if it wins.\\n   * @param playsForJackpot whether the bet should take part in Jackpot roll.\\n   * @param denominator the denominator of the game described by this bet.\\n   * @param mask the options the user chose in a form of a bitmask.\\n   * @param description the human-readable description of the bet.\\n   *\\n   * @return isWin the flag indicating whether the bet won on the primary wager.\\n   *         payment the amount of the winnings the bet has to pay the player.\\n   *         jackpotPayment the amount of the Jackpot winnings paid by this bet.\\n   *         outcomeDescription the human-readable description of the bet's result.\\n   */\\n  function computeBetOutcomes(uint entropy, uint winAmount, bool playsForJackpot, uint denominator, uint mask, TinyString description) internal view returns (bool isWin, uint payment, uint jackpotPayment, TinyString outcomeDescription) {\\n    // compute game specific entropy\\n    uint gameOutcome = entropy % denominator;\\n\\n    // decide on the game type being played\\n    if (denominator == GameOptions.GAME_OPTIONS_ETHEROLL_MODULO) {\\n      // it is an Etheroll bet; the bet wins if the mask value (which simply holds the number for Etheroll, see GameOption.sol)\\n      // does not exceed the gameOutcome number\\n      isWin = gameOutcome < mask;\\n\\n      // append the actual number (+1 to make it start from 1 instead of 0)\\n      outcomeDescription = description.append(TinyStrings.SPACE).appendNumber(gameOutcome + 1);\\n    } else if (denominator == GameOptions.GAME_OPTIONS_TWO_DICE_MODULO) {\\n      // it is a TwoDice bet; the bet wins if the user has chosen a sum of two dice that we got\\n      // first off, compute the dice outcomes by splitting the game outcome into 2 parts, with 6 possible values in each one\\n      uint firstDice = gameOutcome / GameOptions.GAME_OPTIONS_DICE_MODULO;\\n      uint secondDice = gameOutcome % GameOptions.GAME_OPTIONS_DICE_MODULO;\\n\\n      // compute the sum of two dice\\n      uint twoDiceSum = firstDice + secondDice;\\n      // check if the mask contains the bit set at that position\\n      isWin = (mask >> twoDiceSum) & 1 != 0;\\n\\n      // append the value of the first dice to the human-readable description (+1 to make it start from 1 instead of 0)\\n      outcomeDescription = description.append(TinyStrings.SPACE).appendNumber(firstDice + 1);\\n      // append the value of the second dice to the human-readable description (+1 to make it start from 1 instead of 0)\\n      outcomeDescription = outcomeDescription.append(TinyStrings.PLUS).appendNumber(secondDice + 1);\\n    } else if (denominator == GameOptions.GAME_OPTIONS_DICE_MODULO) {\\n      // it is a dice game \u2013 all is very simple, to win the user should bet on a particular number, thus\\n      // check if the mask has the bit set at the position corresponding to the dice roll\\n      isWin = (mask >> gameOutcome) & 1 != 0;\\n\\n      // append the value of the dice to the human-readable description (+1 to make it start from 1 instead of 0)\\n      outcomeDescription = description.append(TinyStrings.SPACE).appendNumber(gameOutcome + 1);\\n    } else if (denominator == GameOptions.GAME_OPTIONS_COIN_FLIP_MODULO) {\\n      // it is a CoinFlip game - similar to Dice, the player should bet on the correct side to win\\n      isWin = (mask >> gameOutcome) & 1 != 0;\\n\\n      // append the space to the description of the outcome\\n      outcomeDescription = description.append(TinyStrings.SPACE);\\n\\n      // append heads or tails to the description, based on the result\\n      if (gameOutcome == 0) {\\n        outcomeDescription = outcomeDescription.append(GameOptions.HEADS_STR);\\n      } else {\\n        outcomeDescription = outcomeDescription.append(GameOptions.TAILS_STR);\\n      }\\n    }\\n\\n    // now, the payment amount would equal to the winAmount if bet wins, 0 otherwise\\n    payment = isWin.toUint() * winAmount;\\n\\n    // the last bit to check for is the jackpot\\n    if (playsForJackpot) {\\n      // first of all, get a separate chunk of entropy and compute the Jackpot Outcome number, adding\\n      // +1 to convert from 0..999 range to 1..1000\\n      uint jackpotOutcome = (entropy / denominator) % JACKPOT_MODULO + 1;\\n\\n      // append Jackpot Number to the human-readable description of the bet\\n      outcomeDescription = outcomeDescription.append(TinyStrings.SPACE).appendNumber(jackpotOutcome);\\n\\n      // check the Jackpot Number matches the lucky outcome\\n      if (jackpotOutcome == JACKPOT_WINNING_OUTCOME) {\\n        // it does \u2013 compute the jackpot payment entropy chunk\\n        uint jackpotPaymentOutcome = entropy / denominator / JACKPOT_MODULO;\\n        // set the jackpotPayment to the value computed by a dedicated function\\n        jackpotPayment = computeJackpotAmount(jackpotPaymentOutcome);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Computes the amount a bet should pay to the user based on the odds the bet has and whether the bet plays for Jackpot.\\n   *\\n   * The logic of this method is based on the core principle of this smart contract: be fair. The bet ALWAYS pays the amount\\n   * decided by the odds (after the House fees are taken out). If the bet has 1 in 3 chances, the winning amount would be 3x;\\n   * if the bet has 1 in 16 chances of winning, the amount would be 16x.\\n   *\\n   * Running the contract is prety labour-intensive and requires constant investment of both labour and money (to settle the bets,\\n   * pay increased Jackpots and so on), that is why the contract always deducts the fees, calculated as follows:\\n   *  1. The House takes HOUSE_EDGE_PERCENT (1%) from every bet\\n   *  2. The House always takes at least HOUSE_EDGE_MINIMUM_AMOUNT (0.001 Ether) fee - roughly how much it costs to settle the bet.\\n   *  3. If the bet plays for Jackpot, a fixed Jackpot fee is taken to contribute towards the Jackpot payments.\\n   *\\n   * @param amount the amount being wagered in this bet.\\n   * @param numerator the number of possible outcomes chosen by the user.\\n   * @param denominator the total number of possible outcomes\\n   * @param isJackpot the flag indicating whether the bet takes part in Jackpot games.\\n   *\\n   * @return the amount the bet would pay as a win if it settles so.\\n   */\\n  function computeWinAmount(uint amount, uint numerator, uint denominator, bool isJackpot) internal pure returns (uint) {\\n    // range check\\n    if (numerator == 0 || numerator > denominator) {\\n      revert WinProbabilityOutOfRange(numerator, denominator);\\n    }\\n\\n    // house edge clamping\\n    uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\\n\\n    if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\\n      houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\\n    }\\n\\n    // jackpot fee\\n    uint jackpotFee = isJackpot.toUint() * JACKPOT_FEE;\\n\\n    return (amount - houseEdge - jackpotFee) * denominator / numerator;\\n  }\\n\\n  /**\\n   * Computes the amount the bet would pay as the Jackpot if the user wins the Jackpot.\\n   *\\n   * The value is computed in the following way:\\n   *  1. Base Jackpot value is computed by multiplying Jackpot Odds by Jackpot fee.\\n   *  2. A random number is sampled from JACKPOT_PAYTABLE, providing a number between 0.25 and 4.\\n   *  3. A current jackpotMultiplier value is read, providing another mutlplier.\\n   *  4. Everything is multipled together, providing the final Jackpot value.\\n   *\\n   * If the House keeps jackpotMultiplier at a default value (1), the Jackpot would pay between 0.25x and 4x\\n   * of base Jackpot value. During the happy hours this number can go up significantly.\\n   *\\n   * @param jackpotPaymentOutcome the Jackpot payment entropy value to use to sample a slot from the paytable.\\n   *\\n   * @return the jackpot payment value decided by all the attributes.\\n   */\\n  function computeJackpotAmount(uint jackpotPaymentOutcome) internal view returns (uint) {\\n    // compute base jackpot value that would be paid if the paytable was flat and pre-multply it by current\\n    // jackpotMultiplier; we will have to divide by JACKPOT_MULTIPLIER_BASE later.\\n    uint baseJackpotValue = BASE_JACKPOT_PAYMENT * contractState.jackpotMultiplier;\\n    // get random slot from the paytable\\n    uint paytableSlotIndex = jackpotPaymentOutcome % JACKPOT_PAYTABLE_SLOTS_COUNT;\\n    // compute the paytable multiplier based on the slot index\\n    uint paytableMultiplier = ((JACKPOT_PAYTABLE >> (paytableSlotIndex << 3)) & 0xFF);\\n\\n    // the result would be base value times paytable multiplier OVER multipler denominators since\\n    // both paytable and jackpotMultiplier store integers assuming a certain divisor to be applied\\n    return baseJackpotValue * paytableMultiplier / JACKPOT_MULTIPLIER_BASE / JACKPOT_PAYTABLE_BASE;\\n  }\\n\\n  /**\\n   * The total number of funds potentially due to be paid if all pending bets win (sans jackpots).\\n   *\\n   * @return the locked amount.\\n   */\\n  function lockedInBets() public view returns (uint) {\\n    return contractState.lockedInBets;\\n  }\\n\\n  /**\\n   * The total number of funds potentially due to be paid if all pending bets win (including jackpots).\\n   *\\n   * @return the locked amount.\\n   */\\n  function lockedInBetsWithJackpots() public view returns (uint) {\\n    return contractState.totalLockedInBets(MAX_JACKPOT_PAYMENT, JACKPOT_MULTIPLIER_BASE);\\n  }\\n\\n  /**\\n   * The number of not-yet-settled bets that are playing for jackpot.\\n   *\\n   * @return number of bets playing for jackpot.\\n   */\\n  function jackpotBetCount() public view returns (uint) {\\n    return contractState.jackpotBetCount;\\n  }\\n\\n  /**\\n   * The multiplier of the jackpot payment, set by the house.\\n   *\\n   * @return jackpot multiplier.\\n   */\\n  function jackpotMultiplier() public view returns (uint) {\\n    return contractState.jackpotMultiplier;\\n  }\\n\\n  /**\\n   * The value indicating the maximum potential win a bet is allowed to make. We have to cap that value to avoid\\n   * draining the contract in a single bet by whales who put huge bets for high odds.\\n   *\\n   * @return jackpot multiplier.\\n   */\\n  function maxProfit() public view returns (uint) {\\n    return contractState.maxProfit;\\n  }\\n\\n  /**\\n   * A House-controlled function used to modify maxProfit value \u2013 the maximum amount of winnings\\n   * a single bet can take from the contract.\\n   *\\n   * Bets potentially exceedign this value will not be allowed to be placed.\\n   *\\n   * @param newMaxProfit the updated maxProfit value to set.\\n   */\\n  function setMaxProfit(uint newMaxProfit) external onlyOwner {\\n    contractState.maxProfit = uint72(newMaxProfit);\\n    emit MaxProfitUpdated(newMaxProfit);\\n  }\\n\\n  /**\\n   * A House-controlled function used to modify jackpotMultiplier value \u2013 the scale factor\\n   * of the Jackpot payment paid out on Jackpot wins.\\n   *\\n   * The House reserves the right to tweak this value for marketing purposes.\\n   *\\n   * @param newJackpotMultiplier the updated maxProfit value to set.\\n   */\\n  function setJackpotMultiplier(uint newJackpotMultiplier) external onlyOwner  {\\n    contractState.jackpotMultiplier = uint32(newJackpotMultiplier);\\n    emit JackpotMultiplierUpdated(newJackpotMultiplier);\\n  }\\n\\n  /**\\n   * A House-controlled function used to send a portion of contract's balance to an external\\n   * address \u2013 primarily used for bankroll management.\\n   *\\n   * The function DOES NOT allow withdrawing funds from the bets that are currently being\\n   * processed to make sure the house cannot do a bank run.\\n   *\\n   * @param to the address to withdraw the funds to.\\n   * @param amount the amount of funds to withdraw.\\n   */\\n  function withdrawFunds(address to, uint amount) external onlyOwner  {\\n    // make sure there will be at least lockedInBets funds after the withdrawal\\n    require (amount + contractState.lockedInBets <= address(this).balance, \\\"Cannot withdraw funds - pending bets might need the money.\\\");\\n    // transfer the money out\\n    (bool transferSuccess,) = to.call{value: amount}(\\\"\\\");\\n    require (transferSuccess, \\\"Transfer failed!\\\");\\n  }\\n\\n  /**\\n   * A House-controlled function used block a specific address from placing any new bets.\\n   *\\n   * The already-placed bets can still be processed or refunded.\\n   *\\n   * The primary use of this function is to block addresses containing funds associated with\\n   * illegal activity (such as stolen or otherwise acquired in an illegal way).\\n   *\\n   * This is a legal requirement to have this function.\\n   *\\n   * @param player the address of the player to suspend.\\n   * @param suspend whether to suspend or un-suspend the player.\\n   */\\n  function suspendPlayer(address player, bool suspend) external onlyOwner {\\n    BetStorage.suspendPlayer(bets, player, suspend);\\n  }\\n\\n  /**\\n   * A House-controlled function used to destroy the contract.\\n   *\\n   * It would only work if the value of lockedInBets is 0, meaning there are no pending bets\\n   * and the contract destruction would not take any player's money.\\n   */\\n  function destroy() external onlyOwner {\\n    require(contractState.lockedInBets == 0, \\\"There are pending bets\\\");\\n    selfdestruct(owner);\\n  }\\n\\n  /**\\n   * A function used to add funds to the contract.\\n   */\\n  function topUpContract() external payable {\\n  }\\n\\n  /**\\n   * Approves nextOwner address allowing transfer of contract's ownership\\n   * to a new address.\\n   */\\n  function approveNextOwner(address _nextOwner) external onlyOwner {\\n    nextOwner = payable(_nextOwner);\\n  }\\n\\n  /**\\n   * Accepts ownership transfer to the nextOwner address making it the new owner.\\n   * The signer should seek approval from the current owner before calling this method.\\n   */\\n  function acceptNextOwner() external {\\n    require(msg.sender == nextOwner, \\\"nextOwner does not match transaction signer.\\\");\\n    owner = nextOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/GameOptions.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { TinyStrings, TinyString, TinyString5 } from \\\"./TinyStrings.sol\\\";\\nimport { Math } from \\\"./Math.sol\\\";\\n\\n/* GameOption is a custom type that represents a bit mask holding the outcome(s) the player has made a bet on.\\n * The encoding scheme is using lower 12 bits of the integer to keep the flag indicating the\\n * type of bet used along with the options chosen by the user.\\n *\\n * Having this as a separate type allows us to clearly bear the meaining of variables holding game options data\\n * and also be less error-prone to things like implicit casts done by Solidity.\\n *\\n * The type's constructors defined in the library below also perform sanity checks on the values provided;\\n * this way, if there is an instance of GameOptions somewhere, it is guaranteed to be valid and it is not neccessary to\\n * re-validate it on the spot.\\n *\\n * Examples:\\n *  1. Coin Flip bet on tails: 0b000000000010\\n *  2. Dice bet on 1, 2 and 3: 0b010000000111\\n *  3. TwoDice bet on 8 and 9: 0b100011000000\\n *  4. Etheroll bet on <= 55:  0b001000110111\\n */\\ntype GameOption is uint256;\\n\\n/**\\n * This library provides a set of constants (like human-readable strings used for logging) along with\\n * utility methods to abstract away the manipulation of GameOption custom type.\\n */\\nlibrary GameOptions {\\n  // Extension methods\\n  using TinyStrings for TinyString;\\n\\n  // Human-readable representation of \\\"heads\\\" option for CoinFlip game\\n  TinyString5 constant internal HEADS_STR     = TinyString5.wrap(uint40(bytes5(\\\"heads\\\")));\\n  // Human-readable representation of \\\"tails\\\" option for CoinFlip game\\n  TinyString5 constant internal TAILS_STR     = TinyString5.wrap(uint40(bytes5(\\\"tails\\\")));\\n  // Human-readable representation of \\\"jackpot\\\" string\\n  TinyString5 constant internal JCKPT_STR     = TinyString5.wrap(uint40(bytes5(\\\"jckpt\\\")));\\n  // Prefix for logging description of CoinFlip games\\n  TinyString constant internal COINFLIP_STR   = TinyString.wrap(uint72(bytes9(\\\"CoinFlip \\\")));\\n  // Prefix for logging description of Dice games\\n  TinyString constant internal DICE_STR       = TinyString.wrap(uint40(bytes5(\\\"Dice \\\")));\\n  // Prefix for logging description of TwoDice games\\n  TinyString constant internal TWODICE_STR    = TinyString.wrap(uint24(bytes3(\\\"2D \\\")));\\n  // Prefix for logging description of Etheroll games\\n  TinyString constant internal ETHEROLL_STR   = TinyString.wrap(uint88(bytes11(\\\"Etheroll <=\\\")));\\n\\n  // The mask selecting bits of GameOption containing CoinFlip choices \u2013 lower 2 bits\\n  uint constant internal GAME_OPTIONS_COIN_FLIP_MASK_BITS = (1 << 2) - 1;\\n  // The mask selecting bits of GameOption containing Dice choices \u2013 lower 6 bits\\n  uint constant internal GAME_OPTIONS_DICE_MASK_BITS      = (1 << 6) - 1;\\n  // The mask selecting bits of GameOption containing TwoDice choices \u2013 lower 11 bits\\n  uint constant internal GAME_OPTIONS_TWO_DICE_MASK_BITS  = (1 << 11) - 1;\\n  // The mask selecting bits of GameOption containing Etheroll number \u2013 lower 8 bits\\n  uint constant internal GAME_OPTIONS_ETHEROLL_MASK_BITS  = (1 << 8) - 1;\\n  // The maximum number allowed for an Etheroll game\\n  uint constant internal GAME_OPTIONS_ETHEROLL_MASK_MAX   = 99;\\n\\n  // The flag indicating the GameOption describes a Dice game \u2013 10th bit set\\n  uint constant internal GAME_OPTIONS_DICE_FLAG = (1 << 10);\\n  // The flag indicating the GameOption describes a TwoDice game \u2013 11th bit set\\n  uint constant internal GAME_OPTIONS_TWO_DICE_FLAG = (1 << 11);\\n  // The flag indicating the GameOption describes an Etheroll game \u2013 9th bit set\\n  uint constant internal GAME_OPTIONS_ETHEROLL_FLAG = (1 << 9);\\n  // The maximum value of GameOption as an integer \u2013 having higher bits set would mean there was on overflow\\n  uint constant internal GAME_OPTIONS_THRESHOLD = 2 ** 12;\\n\\n  // The number of combinations in CoinFlip game\\n  uint constant internal GAME_OPTIONS_COIN_FLIP_MODULO = 2;\\n  // The number of combinations in Dice game\\n  uint constant internal GAME_OPTIONS_DICE_MODULO = 6;\\n  // The number of combinations in TwoDice game\\n  uint constant internal GAME_OPTIONS_TWO_DICE_MODULO = 36;\\n  // The number of combinations in Etheroll game\\n  uint constant internal GAME_OPTIONS_ETHEROLL_MODULO = 100;\\n\\n  // The number where each hex digit represents the number of 2 dice combinations summing to a specific number\\n  uint constant internal GAME_OPTIONS_TWO_DICE_SUMS = 0x12345654321;\\n  // The number where each hex digit represents the number of dice outcomes representing a specific number (trivial)\\n  uint constant internal GAME_OPTIONS_DICE_SUMS = 0x111111;\\n\\n  /**\\n   * Converts a given mask into a CoinFlip GameOption instance.\\n   *\\n   * @param mask CoinFlip choice(s) to encode.\\n   *\\n   * @return GameOption representing the passed mask.\\n   */\\n  function toCoinFlipOptions(uint mask) internal pure returns (GameOption) {\\n    require(mask > 0 && mask <= GAME_OPTIONS_COIN_FLIP_MASK_BITS, \\\"CoinFlip mask is not valid\\\");\\n    // CoinFlip does not have any dedicated flag set \u2013 thus simply wrap the mask\\n    return GameOption.wrap(mask);\\n  }\\n\\n  /**\\n   * Converts a given mask into a Dice GameOption instance.\\n   *\\n   * @param mask Dice choice(s) to encode.\\n   *\\n   * @return GameOption representing the passed mask.\\n   */\\n  function toDiceOptions(uint mask) internal pure returns (GameOption) {\\n    require(mask > 0 && mask <= GAME_OPTIONS_DICE_MASK_BITS, \\\"Dice mask is not valid\\\");\\n    return GameOption.wrap(GAME_OPTIONS_DICE_FLAG | mask);\\n  }\\n\\n  /**\\n   * Converts a given mask into a TwoDice GameOption instance.\\n   *\\n   * @param mask TwoDice choice(s) to encode.\\n   *\\n   * @return GameOption representing the passed mask.\\n   */\\n  function toTwoDiceOptions(uint mask) internal pure returns (GameOption) {\\n    require(mask > 0 && mask <= GAME_OPTIONS_TWO_DICE_MASK_BITS, \\\"Dice mask is not valid\\\");\\n    return GameOption.wrap(GAME_OPTIONS_TWO_DICE_FLAG | mask);\\n  }\\n\\n  /**\\n   * Converts a given mask into a TwoDice Etheroll instance.\\n   *\\n   * @param option Etheroll choice to encode.\\n   *\\n   * @return GameOption representing the passed mask.\\n   */\\n  function toEtherollOptions(uint option) internal pure returns (GameOption) {\\n    require(option > 0 && option <= GAME_OPTIONS_ETHEROLL_MASK_MAX, \\\"Etheroll mask is not valid\\\");\\n    return GameOption.wrap(GAME_OPTIONS_ETHEROLL_FLAG | option);\\n  }\\n\\n  /**\\n   * As the name suggests, the routine parses the instance of GameOption type and returns a description of what\\n   * kind of bet it represents.\\n   *\\n   * @param self GameOption instance to describe.\\n   *\\n   * @return numerator containing the number of choices selected in this GameOption\\n   *         denominator containing the total number of choices available in the game this GameOption describes\\n   *         bitMask containing bits set at positions where game options were selected by the player\\n   *         humanReadable containing an instance of TinyString describing the bet, e.g. \\\"CoinFlip heads\\\"\\n   */\\n  function describe(GameOption self) internal pure returns (uint numerator, uint denominator, uint mask, TinyString betDescription) {\\n    // we need bare underlying bits, so have to unwrap the GameOption\\n    uint gameOptions = GameOption.unwrap(self);\\n\\n    // check if the game described in TwoDice\\n    if ((gameOptions & GAME_OPTIONS_TWO_DICE_FLAG) != 0) {\\n      // mask out the bit relevant for TwoDice game\\n      mask = gameOptions & GAME_OPTIONS_TWO_DICE_MASK_BITS;\\n      // each bit in the mask can correspond to different number of outcomes: e.g. you can 5 by rolling 1 and 4, or 4 and 1, or 3 and 2 etc.\\n      // to calculate the total number of rolls matching the mask, we simply multiply positions of bits set in the mask with a constant\\n      // containing how many combinations of 2 dice would yield a particular number\\n      numerator = Math.weightedPopCnt(mask, GAME_OPTIONS_TWO_DICE_SUMS);\\n      // denomination is always the same, 36\\n      denominator = GAME_OPTIONS_TWO_DICE_MODULO;\\n      // prepare human-readable string composed of a prefix and numbers of bits set up, with the lowest corresponding\\n      // to 2 (the minimum sum of 2 dice is 2), e.g. \\\"2D 5,6,12\\\"\\n      betDescription = TWODICE_STR.appendBitNumbers(mask, 2);\\n\\n    // check if the game described in Dice\\n    } else if ((gameOptions & GAME_OPTIONS_DICE_FLAG) != 0) {\\n      // mask out the bit relevant for Dice game\\n      mask = gameOptions & GAME_OPTIONS_DICE_MASK_BITS;\\n      // similar to Two Dice game above, but every bit corresponding to a single option\\n      numerator = Math.weightedPopCnt(mask, GAME_OPTIONS_DICE_SUMS);\\n      // denomination is always the same, 6\\n      denominator = GAME_OPTIONS_DICE_MODULO;\\n      // prepare human-readable string composed of a prefix and numbers of bits set up, with the lowest corresponding\\n      // to 1 (the minimum sum of a single dice is 1), e.g. \\\"Dice 1,2,3\\\"\\n      betDescription = DICE_STR.appendBitNumbers(mask, 1);\\n\\n    // check if the game described in Etheroll\\n    } else if ((gameOptions & GAME_OPTIONS_ETHEROLL_FLAG) != 0) {\\n      // mask out the bit relevant for Etheroll game\\n      mask = gameOptions & GAME_OPTIONS_ETHEROLL_MASK_BITS;\\n      // Etheroll lets players bet on a single number, stored \\\"as in\\\" in the mask\\n      numerator = mask;\\n      // denomination is always the same, 100\\n      denominator = GAME_OPTIONS_ETHEROLL_MODULO;\\n      // prepare human-readable string composed of a prefix and the number the player bets on, e.g. \\\"Etheroll <=55\\\"\\n      betDescription = ETHEROLL_STR.appendNumber(mask);\\n\\n    // if none bits match, we are describing a CoinFlip game\\n    } else {\\n      // mask out the bit relevant for CoinFlip game\\n      mask = gameOptions & GAME_OPTIONS_COIN_FLIP_MASK_BITS;\\n      // we only let players bet on a single option in CoinFlip\\n      numerator = 1;\\n      // denomination is always the same, 2\\n      denominator = GAME_OPTIONS_COIN_FLIP_MODULO;\\n      // prepare human-readable string composed of a prefix and the side the player bets on, e.g. \\\"CoinFlip tails\\\"\\n      betDescription = COINFLIP_STR.append(mask == 1 ? HEADS_STR : TAILS_STR);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n/**\\n * Tiny library containing bespoke mathematical functions allowing us to express contract's logic\\n * in a more clear and gas efficient way.\\n */\\nlibrary Math {\\n  // Maximum number represented by 128 bit uint\\n  uint constant internal MAX128 = 2**128 - 1;\\n  // Maximum number represented by 64 bit uint\\n  uint constant internal MAX64  = 2**64  - 1;\\n  // Maximum number represented by 32 bit uint\\n  uint constant internal MAX32  = 2**32  - 1;\\n  // Maximum number represented by 16 bit uint\\n  uint constant internal MAX16  = 2**16  - 1;\\n  // Maximum number represented by 8 bit uint\\n  uint constant internal MAX8   = 2**8   - 1;\\n\\n  /**\\n   * Returns the number of bits set rounded up to the nearest multiple of 32 \u2013 essentially,\\n   * how many whole 4 byte words are required to \\\"fit\\\" the number.\\n   *\\n   * @param number the number to compute the bit length for.\\n   *\\n   * @return length the bit length, rounded up to 32.\\n   */\\n  function getBitLength32(uint number) internal pure returns (uint length) {\\n    // if the number is greater than 2^128, then it is at least 128 bits long\\n    length  = toUint(number > MAX128) << 7;\\n    // if the left-most remaining part is greater than 2^64, then it's at least 64 bits longer\\n    length |= toUint((number >> length) > MAX64) << 6;\\n    // if the left-most remaining part is greater than 2^32, then it's at least 32 bits longer\\n    length |= toUint((number >> length) > MAX32) << 5;\\n\\n    unchecked {\\n      // if there are more bits remaining, then it's at least another 32 bits longer (effectively, ceil())\\n      length += toUint((number >> length) > 0) << 5;\\n    }\\n  }\\n\\n  /**\\n   * Returns the number of bits set rounded up to the nearest multiple of 8 \u2013 essentially,\\n   * how many whole 8-bit bytes are required to \\\"fit\\\" the number.\\n   *\\n   * @param number the number to compute the bit length for.\\n   *\\n   * @return length the bit length, rounded to 8.\\n   */\\n  function getBitLength8(uint number) internal pure returns (uint length) {\\n    // please refer to the explanation of getBitLength32() - the below is similar,\\n    // it just operates in 8 bit increments instead of 32, resulting in two extra steps.\\n    length  = toUint(number > MAX128) << 7;\\n    length |= toUint((number >> length) > MAX64) << 6;\\n    length |= toUint((number >> length) > MAX32) << 5;\\n    length |= toUint((number >> length) > MAX16) << 4;\\n    length |= toUint((number >> length) >  MAX8) << 3;\\n\\n    unchecked {\\n      length += toUint((number >> length) > 0) << 3;\\n    }\\n  }\\n\\n  /**\\n   * Returns 1 for true and 0 for false, as simle as that.\\n   *\\n   * @param boolean the bool to convert into an integer.\\n   * @return integer an integer of 0 or 1.\\n   */\\n  function toUint(bool boolean) internal pure returns (uint integer) {\\n    // As of Solidity 0.8.14, conditionals like (boolean ? 1 : 0) are not\\n    // optimized away, thus inline assembly forced cast is needed to save gas.\\n    assembly {\\n      integer := boolean\\n    }\\n  }\\n\\n  /**\\n   * Returns true if a number is an exact power of 2.\\n   *\\n   * @param number the number to test for 2^N\\n   *\\n   * @return true if the number is an exact power of 2 and is not 0.\\n   */\\n  function isPowerOf2(uint number) internal pure returns (bool) {\\n    unchecked {\\n      return ((number & (number - 1)) == 0) && (number != 0);\\n    }\\n  }\\n\\n  /**\\n   * Returns the minimum of 2 numbers.\\n   *\\n   * @param a the first number.\\n   * @param b the second number.\\n   *\\n   * @return a if it's not greater than b, b otherwise.\\n   */\\n  function min(uint a, uint b) internal pure returns (uint) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * Returns the maximum of 2 numbers.\\n   *\\n   * @param a the first number.\\n   * @param b the second number.\\n   *\\n   * @return a if it's not greater than b, b otherwise.\\n   */\\n  function max(uint a, uint b) internal pure returns (uint) {\\n    return a < b ? b : a;\\n  }\\n\\n  /**\\n   * Multiplies every set bit's number from mask with a hex digit of the second parameter.\\n   * This allows us to easily count the number of bits set (by providing weightNibbles of 0x1111...)\\n   * or to perform a \\\"weighted\\\" population count, where each bit has its own bespoke contribution.\\n   *\\n   * A real-life example would be to count how many combinations of 2 dice would yield one of\\n   * chosen in the mask. Consider the mask of 0b1011 (we bet on 2, 3 and 5) and the weightNibbles\\n   * set to be 0x12345654321 (2 is only 1+1, 3 is either 1+2 or 2+1 and so on). Calling this function\\n   * with the above arguments would return 7 - as there 7 combinations of 2 dice outcomes that would\\n   * yield either 1, 2 or 4.\\n   *\\n   * @param mask the number to get set bits from.\\n   * @param weightNibbles the number to get multiplier from.\\n   *\\n   * @return result the sum of bit position multiplied by custom weight.\\n   */\\n  function weightedPopCnt(uint mask, uint weightNibbles) internal pure returns (uint result) {\\n    result = 0;\\n\\n    // we stop as soon as weightNibbles is zeroed out\\n    while (weightNibbles != 0) {\\n      // check if the lowest bit is set\\n      if ((mask & 1) != 0) {\\n        // it is \u2013 add the lowest hex octet from the nibbles\\n        result += weightNibbles & 0xF;\\n      }\\n\\n      // shift the mask to consider the next bit\\n      mask >>= 1;\\n      // shift the nibbles to consider the next octet\\n      weightNibbles >>= 4;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Options.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { Math } from \\\"./Math.sol\\\";\\nimport { TinyStrings, TinyString } from \\\"./TinyStrings.sol\\\";\\nimport { GameOptions } from \\\"./GameOptions.sol\\\";\\n\\n/**\\n * The library providing helper method to parse user input from a TinyString instance.\\n */\\nlibrary Options {\\n  // Extension functions\\n  using TinyStrings for TinyString;\\n\\n  // The error indicating the option found within a string falls out of min...max range.\\n  error OptionNotInRange(uint option, uint min, uint max);\\n\\n  /**\\n   * Being given an instance of TinyString and min/max constraints, parses the string returning\\n   * the last found option as an integer as well as bit mask with bits set at places corresponding\\n   * to the numbers found in the string.\\n   *\\n   * If the string is \\\"heads\\\" or \\\"tails\\\", it is instantly considered a CoinFlip option description,\\n   * returning hardcoded values for the mask and option parameters.\\n   *\\n   * The string is considered to consist of digits separated by non-digits characters. To save the gas,\\n   * the function does not distinguish between the types of separators; any non-digit character is considered\\n   * a separator.\\n   *\\n   * Examples:\\n   *  1. \\\"heads\\\" -> (1, 0)\\n   *  2. \\\"tails\\\" -> (2, 1)\\n   *  3. \\\"1\\\" -> (0b1, 1)\\n   *  4. \\\"1,2,3\\\" -> (0b111, 3)\\n   *\\n   * @param tinyString an instance of TinyString to parse.\\n   * @param min the minimum allowed number.\\n   * @param max the maximum allowed number.\\n   *\\n   * @return mask the bit mask where the bit is set if the string contains such a number\\n   *         lastOption the last found number.\\n   */\\n  function parseOptions(TinyString tinyString, uint min, uint max) internal pure returns (uint mask, uint lastOption) {\\n    // fast track: is the string \\\"heads\\\"?\\n    if (tinyString.equals(GameOptions.HEADS_STR)) {\\n      return (1, 0);\\n    }\\n\\n    // fast track: is the string \\\"tails\\\"?\\n    if (tinyString.equals(GameOptions.TAILS_STR)) {\\n      return (2, 1);\\n    }\\n\\n    // we parse the string left-to-right, meaning the first digit of a number has to be multipled by 1, the second by 10 etc\\n    uint digitMultiplier = 1;\\n\\n    // we run the whole loop without arithmetic checks since we only use\\n    // functions operating on heavily constrained values\\n    unchecked {\\n      // repeat until stopped explicitly\\n      while (true) {\\n        // classify the last character.\\n        // IMPORTANT: empty string would return isDigit = false\\n        (bool isDigit, uint digit) = tinyString.getLastChar();\\n\\n        // is the last character a digit?\\n        if (isDigit) {\\n          // is it the first digit of a new number? if so, reset the lastOption to 0\\n          lastOption = digitMultiplier == 1 ? 0 : lastOption;\\n          // add the digit multiplied by current multiplier to the lastOption value\\n          lastOption += digitMultiplier * digit;\\n          // the next digit would be 10x\\n          digitMultiplier *= 10;\\n        } else {\\n          // we stumbled upon a separator OR an empty string \u2013 let's validate the computed number\\n          if (lastOption < min || lastOption > max) {\\n            // the number falls out of min..max range, we have to crash\\n            revert OptionNotInRange(lastOption, min, max);\\n          }\\n\\n          // set the bit corresponding to the last found number\\n          mask |= 1 << (lastOption - min);\\n          // reset the digit multiplier to 1 (since the next number will be a new number)\\n          digitMultiplier = 1;\\n        }\\n\\n        // is the string empty?\\n        if (tinyString.isEmpty()) {\\n          // it is \u2013 stop the loop, we are done\\n          break;\\n        }\\n\\n        // remove the last character from the string and repeat\\n        tinyString = tinyString.chop();\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/PackedBets.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { Math } from \\\"./Math.sol\\\";\\nimport { GameOption, GameOptions } from \\\"./GameOptions.sol\\\";\\n\\n/**\\n * PackedBet is a custom type that represents a single bet placed by a player. It encodes the bet amount\\n * (quantized down to a specific increment to save space), the GameOption instance (see ./GameOptions.sol) and\\n * the bit indicating whether the bet was nominated to play for a jackpot.\\n *\\n * The memory layout of the type if pretty straightforward:\\n * 1. Lowest 16 bits hold bet amount (divided by quant constant)\\n * 2. Bit #17 is set to 1 if the bet plays for a jackpot\\n * 3. Bits #18-29 hold GameOption data\\n * 4. Bits #30-32 hold bet time (mod 4 hours).\\n *\\n * The type's constructors defined in the library below also perform sanity checks on the values provided;\\n * this way, if there is an instance of PackedBet somewhere, it is guaranteed to be valid and it is not neccessary to\\n * re-validate it on the spot.\\n */\\ntype PackedBet is uint256;\\n\\n/**\\n * The library containing conversion routines (to pack and unpack bet data into an instance of PackedBet),\\n * as well as basic utilities to compute certain attributes of a PackedBet.\\n */\\nlibrary PackedBets {\\n  // Extension functions\\n  using Math for bool;\\n\\n  // The byte length of the PackedBet type\\n  uint constant internal PACKED_BET_LENGTH = 32;\\n  // The length of the epoch for our contract (4 hours)\\n  uint constant internal EPOCH_LENGTH = 4 * 3600;\\n  // The bit mask selecting the bits allocated to hold quantified amount of the bet\\n  uint constant internal QUANT_AMOUNT_MASK = QUANT_AMOUNT_THRESHOLD - 1;\\n  // The bit mask selecting the bits allocated to hold GameOption data (not shifted)\\n  uint constant internal GAME_OPTIONS_MASK = GameOptions.GAME_OPTIONS_THRESHOLD - 1;\\n  // The maximum amount after quanitification (to avoid bit overflow)\\n  uint constant internal QUANT_AMOUNT_THRESHOLD = 2 ** 17;\\n  // The bit mask selecting all the data but epoch number\\n  uint constant internal ALL_BUT_EPOCH_BITS = 2 ** 30 - 1;\\n  // The value by which we quantify the bets\\n  uint constant internal QUANT_STEP = 0.001 ether;\\n  // The bit number where isJackpot flag is stored\\n  uint constant internal JACKPOT_BIT_OFFSET = 17;\\n  // The bit mask selecting bit representing isJackpot flag (shifted).\\n  uint constant internal JACKPOT_MASK = 1 << JACKPOT_BIT_OFFSET;\\n  // The bit number where GameOption data starts\\n  uint constant internal GAME_OPTIONS_BIT_OFFSET = 18;\\n  // The bit number where epoch number data starts\\n  uint constant internal EPOCH_BIT_OFFSET = 30;\\n  // The modulo of the epoch number \u2013 we only keep 3 bits of epoch number along with the bets\\n  uint constant internal EPOCH_NUMBER_MODULO = 4;\\n  // The bit mask selecting bits for epoch number\\n  uint constant internal EPOCH_NUMBER_MODULO_MASK = 3;\\n\\n  /**\\n   * Packs the given amount (in wei), GameOption instance and a jackpot flag into a instance of a PackedBet.\\n   *\\n   * The routine assumes GameOption passed to it is valid and does not perform any additional checks.\\n   *\\n   * The routine checks that amount does not exceed maximum allowed one and is also an exact multiple of QUANT_STEP,\\n   * to avoid situations where 0.0011 Ethers are wagered and trimmed down to 0.001 in further calculations \u2013 it would\\n   * crash otherwise.\\n   *\\n   * @param amount the amount of wei being wagered.\\n   * @param gameOptions the instance of GameOption to encode.\\n   * @param isJackpot the flag inidicating the jackpot participation.\\n   *\\n   * @return an instance of PackedBet representing all the data passed.\\n   */\\n  function pack(uint amount, GameOption gameOptions, bool isJackpot) internal view returns (PackedBet) {\\n    // calculate quantified amount and the reminder\\n    uint quantAmount = amount / QUANT_STEP;\\n    uint quantReminder = amount % QUANT_STEP;\\n\\n    // make sure the quantAmount does not overflow allowed size and that the reminder is 0\\n    require(quantAmount != 0 && quantAmount < QUANT_AMOUNT_THRESHOLD && quantReminder == 0, \\\"Bet amount not quantifiable\\\");\\n\\n    // take 3 lowest of the current epoch number to keep it along with the PackedBet\\n    uint epochMod4 = getCurrentEpoch() & EPOCH_NUMBER_MODULO_MASK;\\n\\n    // construct the packed bet by:\\n    // 1. Storing the epoch number in bits 30..32\\n    // 2. Storing GameOption in bits 18...29\\n    // 3. Storing isJackpot in bit 17\\n    // 4. Storing quantAmount in bits 0..16\\n    uint packedBet =  epochMod4 << EPOCH_BIT_OFFSET |\\n                      GameOption.unwrap(gameOptions) << GAME_OPTIONS_BIT_OFFSET |\\n                      isJackpot.toUint() << JACKPOT_BIT_OFFSET |\\n                      quantAmount;\\n\\n    return PackedBet.wrap(packedBet);\\n  }\\n\\n  /**\\n   * Checks if the PackedBet instance is empty (does not contain anything).\\n   *\\n   * @param self PackedBet instance to check.\\n   *\\n   * @return true if the PackedBet instance is empty.\\n   */\\n  function isEmpty(PackedBet self) internal pure returns (bool) {\\n    return PackedBet.unwrap(self) == 0;\\n  }\\n\\n  /**\\n   * Converts the PackedBet to an integer representation.\\n   *\\n   * @param self PackedBet instance to convert into an integer.\\n   *\\n   * @return the number representing the PackedBet instance.\\n   */\\n  function toUint(PackedBet self) internal pure returns (uint256) {\\n    return PackedBet.unwrap(self);\\n  }\\n\\n  /**\\n   * Removes all the bits encoding epoch number from the instance of the PackedBet.\\n   * This routine is helpful when two PackedBets need to be checked for equality.\\n   *\\n   * @param self the instance of the PackedBet to remove epoch number from.\\n   *\\n   * @return an instance of the PackedBet with epoch bits set to 0.\\n   */\\n  function withoutEpoch(PackedBet self) internal pure returns (PackedBet) {\\n    return PackedBet.wrap(PackedBet.unwrap(self) & ALL_BUT_EPOCH_BITS);\\n  }\\n\\n  /**\\n   * Returns the number of the current and bet's epochs mod 4.\\n   *\\n   * @param self PackedBet instance to check.\\n   *\\n   * @return betEpoch the bet's epoch mod 4\\n   *         currentEpoch the current epoch mod 4\\n   */\\n  function extractEpochs(PackedBet self) internal view returns (uint betEpoch, uint currentEpoch) {\\n    // get current epoch % 4 value\\n    currentEpoch = getCurrentEpoch() & EPOCH_NUMBER_MODULO_MASK;\\n    // get bet's epoch % 4 value\\n    betEpoch = (PackedBet.unwrap(self) >> EPOCH_BIT_OFFSET) & EPOCH_NUMBER_MODULO_MASK;\\n  }\\n\\n  /**\\n   * Checks if two PackedBet instances are exactly equal.\\n   *\\n   * @param self first instance of the PackedBet.\\n   * @param other second instance of the PackedBet.\\n   *\\n   * @return true if the instances are exactly the same.\\n   */\\n  function equals(PackedBet self, PackedBet other) internal pure returns (bool) {\\n    return PackedBet.unwrap(self) == PackedBet.unwrap(other);\\n  }\\n\\n  /**\\n   * Checks if the PackedBet instance has 0 in the amount portion. This is needed to make\\n   * sure we don't settle the same bet twice (upon resolving a bet we clear the amount bits).\\n   *\\n   * @param self the instance of the PackedBet to check.\\n   *\\n   * @return true if the amount portion of the PackedBet is zero.\\n   */\\n  function hasZeroAmount(PackedBet self) internal pure returns (bool) {\\n    return (PackedBet.unwrap(self) & QUANT_AMOUNT_MASK) == 0;\\n  }\\n\\n  /**\\n   * Unpacks the PackedBet instance into separate values of GameOption, amount used and isJackpot flag.\\n   *\\n   * @param self PackedBet to unpack.\\n   *\\n   * @return gameOptions the instance of GameOption encoded in this packed bet.\\n   *         amount the amount encoded, multiplied by quantification coefficient.\\n   *         isJackpot the flag indicating whether the bet plays for jackpot.\\n   */\\n  function unpack(PackedBet self) internal pure returns (GameOption gameOptions, uint amount, bool isJackpot) {\\n    // we need raw bits, so have to unwrap the bet into an integer\\n    uint data = PackedBet.unwrap(self);\\n\\n    // the amount is essentially quantAmount times QUANT_STEP\\n    amount = (data & QUANT_AMOUNT_MASK) * QUANT_STEP;\\n    isJackpot = (data & JACKPOT_MASK) != 0;\\n    gameOptions = GameOption.wrap((data >> GAME_OPTIONS_BIT_OFFSET) & GAME_OPTIONS_MASK);\\n  }\\n\\n  /**\\n   * Returns the number of the current epoch, expressed as the number of 4 hour interval since the beginning of times.\\n   *\\n   * @return the number of the curret epoch.\\n   */\\n  function getCurrentEpoch() private view returns (uint) {\\n    return block.timestamp / EPOCH_LENGTH;\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/TinyStrings.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { Math } from \\\"./Math.sol\\\";\\n\\n/**\\n * TinyString is a custom type providing an alternative representation of short (up to 32 chars) strings containing\\n * ASCII characters.\\n *\\n * We heavily use this primitive in the contract to keep human-readable logs and input parameters yet avoid overspending\\n * tremendeous amount on gas.\\n */\\ntype TinyString  is uint256;\\n\\n/**\\n * A special case of TinyString - a string that contains a single ASCII character.\\n */\\ntype TinyString1 is uint8;\\n\\n/**\\n * A special case of TinyString - a string that contains 5 ASCII characters.\\n */\\ntype TinyString5 is uint40;\\n\\n/**\\n * The library providing functions for manipulating TinyString instances in a nice and readable way.\\n */\\nlibrary TinyStrings {\\n  // Extension functions\\n  using TinyStrings for TinyString;\\n\\n  // The constant holding \\\",\\\" character\\n  TinyString1 constant internal COMMA = TinyString1.wrap(uint8(bytes1(\\\",\\\")));\\n  // The constant holding \\\"+\\\" character\\n  TinyString1 constant internal PLUS  = TinyString1.wrap(uint8(bytes1(\\\"+\\\")));\\n  // The constant holding \\\" \\\" character\\n  TinyString1 constant internal SPACE = TinyString1.wrap(uint8(bytes1(\\\" \\\")));\\n\\n  // The bit mask selecting 8th bit from every byte of 32 byte integer - used to check whether a string\\n  // contains any characters > 128\\n  uint constant internal MSB_BYTES = 0x8080808080808080808080808080808080808080808080808080808080808080;\\n  // The code of \\\"0\\\" in ASCII \u2013 allows us to do super-cheap parsing by subtracting this from the charCode (1 = 49, 2 = 50 etc)\\n  uint constant internal ZERO_ASCII_CODE = 48;\\n  // How many bit there are in a single ASCII character.\\n  uint constant internal BITS_PER_CHARACTER = 8;\\n  // How many bit there are in 5 ASCII characters.\\n  uint constant internal BITS_PER_FIVE_CHARACTERS = BITS_PER_CHARACTER * 5;\\n  // The maximum possible length in bits of TinyString\\n  uint constant internal TINY_STRING_MAX_LENGTH = 32;\\n  // The maximum possible length of TinyString in bits.\\n  uint constant internal TINY_STRING_MAX_LENGTH_BITS = TINY_STRING_MAX_LENGTH * BITS_PER_CHARACTER;\\n  // Contains the bit mask selecting bits of the very last character in the TinyString - simply the lowest byte\\n  uint constant internal LAST_CHARACTER_MASK_BITS = 0xFF;\\n\\n  // The error indicating a native string passed to the library exceeds 32 characts and cannot be manipulated.\\n  error StringTooLong();\\n  // The error indicating a string contains non-ASCII charactes and cannot be manipulated by the library.\\n  error NotAscii();\\n\\n  /**\\n   * Converts an instance of TinyString into a native string placed in memory so that it can be used in\\n   * logs and other places requiring native string instances.\\n   *\\n   * @param self the instance of TinyString to convert into a native one.\\n   *\\n   * @return result the native string instance containing all characters from the TinyString instance.\\n   */\\n  function toString(TinyString self) internal pure returns (string memory result) {\\n    // convert the string into an integer\\n    uint tinyString = TinyString.unwrap(self);\\n    // calculate the length of the string using the Math library: the length of the string would be\\n    // equivalent to the number of highest bit set divied by 8 (since every character occupy 8 bits) and\\n    // rounded up to nearest multiple of 8.\\n    uint length = Math.getBitLength8(tinyString);\\n\\n    // Allocate a string in memory (divide the length by 8 since it is in bits and we need bytes)\\n    result = new string(length >> 3);\\n\\n    // Copy over character data (situated right after a 32-bit length prefix)\\n    assembly {\\n      // we need to shift the bytes so that the characters reside in the higher bits, with lower set to 0\\n      length := sub(256, length)\\n      tinyString := shl(length, tinyString)\\n      // once we shifted the characters, simply copy the memory over\\n      mstore(add(result, 32), tinyString)\\n    }\\n  }\\n\\n  /**\\n   * Converts a native string into a TinyString instance, performing all required validity checks\\n   * along the way.\\n   *\\n   * @param self a native string instance to convert into TinyString.\\n   *\\n   * @return tinyString an instance of the TinyString type.\\n   */\\n  function toTinyString(string calldata self) internal pure returns (TinyString tinyString) {\\n    // first off, make sure the length does not exceed 32 bytes, since it is the maximum length a\\n    // TinyString can store being backed by uint256\\n    uint length = bytes(self).length;\\n    if (length > TINY_STRING_MAX_LENGTH) {\\n      // the string is too long, we have to crash.\\n      revert StringTooLong();\\n    }\\n\\n    // start unchecked block since we know that length is within [0..32] range\\n    unchecked {\\n      // copying the memory from native string would fill higher bits first, but we want\\n      // TinyString to contain characters in the lowest bits; thus, we need to compute the number\\n      // of bits to shift the data so that bytes like 0xa000 end up 0xa.\\n      uint shift = TINY_STRING_MAX_LENGTH_BITS - (length << 3);\\n\\n      // Using inline assembly to efficiently fetch character data in one go.\\n      assembly {\\n        // simply copy the memory over (we have validated the length already, so all is good)\\n        tinyString := calldataload(self.offset)\\n        // shift the bytes to make sure the data sits in lower bits\\n        tinyString := shr(shift, tinyString)\\n      }\\n    }\\n\\n    // Check that string contains ASCII characters only - i.e. there are no bytes with the value of 128+\\n    if (TinyString.unwrap(tinyString) & MSB_BYTES != 0) {\\n      // there are non-ascii characters \u2013 we have to crash\\n      revert NotAscii();\\n    }\\n  }\\n\\n  /**\\n   * Reads the last character of the string and classifies it as a digit or a non-digit one.\\n   *\\n   * If the string is empty, it would return a tuple of (false, -48).\\n   *\\n   * @param self an instance of TinyString to get the last character from.\\n   *\\n   * @return isDigit flag set to true if the character is a digit (0..9).\\n   *         digit the actual digit value of the charact (valid only is isDigit is true).\\n   */\\n  function getLastChar(TinyString self) internal pure returns (bool isDigit, uint digit) {\\n    // we are operating on a single-byte level and thus do not need integer overflow checks\\n    unchecked {\\n      // get the lowest byte of the string\\n      uint charCode = TinyString.unwrap(self) & LAST_CHARACTER_MASK_BITS;\\n\\n      // compute the digit value, which is simply charCode - 48\\n      digit = charCode - ZERO_ASCII_CODE;\\n      // indicate whether the character is a digit (falls into 0..9 range)\\n      isDigit = digit >= 0 && digit < 10;\\n    }\\n  }\\n\\n  /**\\n   * Checks whether the string contains any characters.\\n   *\\n   * @param self an instance of TinyString to check for emptiness.\\n   *\\n   * @return true if the string is empty.\\n   */\\n  function isEmpty(TinyString self) internal pure returns (bool) {\\n    // as simple as it gets: if there are no characters, the string will be 0x0\\n    return TinyString.unwrap(self) == 0;\\n  }\\n\\n  /**\\n   * Returns a copy of TinyString instance without the last character.\\n   *\\n   * @param self an instance of TinyString to remove the last character from.\\n   *\\n   * @return a new instance of TinyString.\\n   */\\n  function chop(TinyString self) internal pure returns (TinyString) {\\n    // we simply right-shift all the bytes by 8 bits \u2013 and that effectively deletes the last character.\\n    return TinyString.wrap(TinyString.unwrap(self) >> BITS_PER_CHARACTER);\\n  }\\n\\n  /**\\n   * Returns a copy of TinyString instance with TinyString1 attached at the end.\\n   *\\n   * @param self an instance of TinyString to append the TinyString1 to.\\n   * @param chunk an instance of TinyString1 to append.\\n   *\\n   * @return a new instance of TinyString.\\n   */\\n  function append(TinyString self, TinyString1 chunk) internal pure returns (TinyString) {\\n    // we just left-shift the string and OR with the TinyString1 chunk to copy its character over into the lowest byte.\\n    return TinyString.wrap((TinyString.unwrap(self) << BITS_PER_CHARACTER) | TinyString1.unwrap(chunk));\\n  }\\n\\n  /**\\n   * Returns a copy of TinyString instance with TinyString1 attached at the end.\\n   *\\n   * @param self an instance of TinyString to append the TinyString1 to.\\n   * @param chunk an instance of TinyString1 to append.\\n   *\\n   * @return a new instance of TinyString.\\n   */\\n  function append(TinyString self, TinyString5 chunk) internal pure returns (TinyString) {\\n    // we just left-shift the string and OR with the TinyString5 chunk to copy its characters over into the lowest bytes.\\n    return TinyString.wrap((TinyString.unwrap(self) << BITS_PER_FIVE_CHARACTERS) | TinyString5.unwrap(chunk));\\n  }\\n\\n  /**\\n   * Checks whether TinyString contains the same characters as TinyString5.\\n   *\\n   * @param self an instance of TinyString to check.\\n   * @param other an instance of TinyString5 to check.\\n   *\\n   * @return true if the strings are the same.\\n   */\\n  function equals(TinyString self, TinyString5 other) internal pure returns (bool) {\\n    return TinyString.unwrap(self) == TinyString5.unwrap(other);\\n  }\\n\\n  /**\\n   * Appends a number to an instance of a TinyString: \\\"1 + 2 = \\\".toTinyString().append(3) => \\\"1 + 2 = 3\\\".\\n   *\\n   * @param self an instance of TinyString to append the number to.\\n   * @param number the number to append.\\n   *\\n   * @return a new instance of TinyString.\\n   */\\n  function appendNumber(TinyString self, uint number) internal pure returns (TinyString) {\\n    // since we work on character level, we don't need range checks.\\n    unchecked {\\n      uint str = TinyString.unwrap(self);\\n\\n      if (number >= 100) {\\n        // if number is > 100, append number of hundreds\\n        str = (str << BITS_PER_CHARACTER) | (ZERO_ASCII_CODE + number / 100);\\n      }\\n\\n      if (number >= 10) {\\n        // if number is > 100, append number of tens\\n        str = (str << BITS_PER_CHARACTER) | (ZERO_ASCII_CODE + number / 10 % 10);\\n      }\\n\\n      // append any remainder (0..9) to the string\\n      return TinyString.wrap((str << BITS_PER_CHARACTER) | (ZERO_ASCII_CODE + number % 10));\\n    }\\n  }\\n\\n  /**\\n   * Appends the numbers of bits set in the mask, naming them from startNumber.\\n   *\\n   * This is a very specific method that allows us to easily compose strings like \\\"Dice 1,2,5\\\", where 1,2,5 portion\\n   * is coming from a bit mask.\\n   *\\n   * startNumber parameter is required so that every bit of the mask is named properly (i.e. in Dice game the lowest\\n   * bit represents an outcome of 1, whereas in TwoDice game the lowest bit means 2).\\n   *\\n   * @param self an instance of TinyString to append the bit numbers to.\\n   * @param mask the mask to extract bits from to append to the string.\\n   * @param startNumber the value of the lowest bit in the mask.\\n   *\\n   * @return a new instance of TinyString.\\n   */\\n  function appendBitNumbers(TinyString self, uint mask, uint startNumber) internal pure returns (TinyString) {\\n    // repeat while the mask is not empty\\n    while (mask != 0) {\\n      // check if the lowest bit is set\\n      if (mask & 1 != 0) {\\n        // it is set \u2013 append current value of startNumber to the string and add a \\\",\\\"\\n        self = self.appendNumber(startNumber).append(TinyStrings.COMMA);\\n      }\\n\\n      // right-shift the mask to start considering the next bit\\n      mask >>= 1;\\n      // increment the number since the next bit is one higher than the previous one. we don't check for overflows here\\n      // since the loop is guaranteed to end in at most 256 iterations anyway\\n      unchecked {\\n        startNumber++;\\n      }\\n    }\\n\\n    // remove the last character since every bit appends \\\",\\\" after its number\\n    return self.chop();\\n  }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/VRF.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n// Imports\\nimport { Math } from \\\"./Math.sol\\\";\\nimport { PackedBets, PackedBet } from \\\"./PackedBets.sol\\\";\\n\\n/**\\n * The library providing RSA-based Verifiable Random Function utilities.\\n *\\n * The main workhorse of our VRF generation is decrypt() function. Being given RSA modulus chunks and the memory slice\\n * of 256 bytes containing encrypted VRF, it attemps to decrypt the data and expand it into a tuple of bet properties.\\n *\\n * The calling contract can then validate that the bet described by the returned tuple is active and proceed with settling it.\\n *\\n * The random number source is the hash of encrypted data chunk. The players cannot predict that value since they do not know\\n * the secret key corresponding to the RSA modulus hardcoded in the contract; the house cannot tamper with player's bets since\\n * the VRF value that passes all the checks is unique due to RSA being a permutation (see Dice9.sol for the proof).\\n *\\n * The distribution is uniform due to RSA ciphertext being hashed.\\n *\\n * The above properties allow Dice9 to perform robust and verifiable random number generation using a seed value consisting of bet\\n * information such as player address, bet amount, bet options and bet nonce.\\n */\\nlibrary VRF {\\n  // Extension functions\\n  using PackedBets for PackedBet;\\n\\n  // The byte length of the RSA modulus (1024 bits)\\n  uint constant internal RSA_MODULUS_BYTES = 128;\\n  // The byte length of the RSA ciphertext (1024 bits)\\n  uint constant internal RSA_CIPHER_TEXT_BYTES = 128;\\n  // The byte length of the RSA exponent (we use a hardcoded value of 65537)\\n  uint constant internal RSA_EXPONENT_BYTES = 32;\\n  // The RSA exponent value\\n  uint constant internal RSA_EXPONENT = 65537;\\n  // The address of EIP-198 modExp precompile contract, which makes RSA decryption gas cost feasible.\\n  address constant internal EIP198_MODEXP = 0x0000000000000000000000000000000000000005;\\n  // The value that the first 256 bits of the decrypted text must have (254 ones).\\n  uint constant internal P0_PADDING_VALUE = 2 ** 254 - 1;\\n  // The bit number where the contract address value starts in the first 256 bit decoded chunk\\n  uint constant internal P1_CONTRACT_ADDRESS_BIT_OFFSET = 96;\\n  // The bit number where the 30 bit (without 2 epoch bits) packed bet data starts in the first 256 bit decoded chunk\\n  uint constant internal P1_PACKED_BET_BIT_OFFSET = 160;\\n  // The bit number where the player nonce data starts in the first 256 bit decoded chunk\\n  uint constant internal P1_PLAYER_NONCE_BIT_OFFSET = 160 + 30;\\n\\n  // The error indicating that the ciphertext was decrypted into something invalid (e.g. random bytes were submitted to reveal a bet)\\n  error InvalidSignature();\\n\\n  /**\\n   * Being given all the bet attributes, computes a hash sum of the bet, allowing the contract to quickly verify the equivalence\\n   * of the bets being considered as well as providing a unique identifier for any bet ever placed.\\n   *\\n   * @param player the address of the player placing the bet.\\n   * @param playerNonce the seq number of the bet played by this player against this instance of the contract.\\n   * @param packedBet an instance of PackedBet representing a bet placed by the player.\\n   *\\n   * @return the keccak256 hash of all the parameters prefixed by the chain id and contract address to avoid replay and Bleichenbacher-like attacks.\\n   */\\n  function computeVrfInputHash(address player, uint playerNonce, PackedBet packedBet) internal view returns (bytes32) {\\n    return keccak256(abi.encode(block.chainid, address(this), player, playerNonce, packedBet.toUint()));\\n  }\\n\\n  /**\\n   * Performs RSA \\\"decryption\\\" procedure using BigModExp (https://eips.ethereum.org/EIPS/eip-198) to remain gas-efficient.\\n   *\\n   * If the cipherText was produced by a legic signatory (i.e. a party possessing the secret key that corresponds to the hardcoded modulus and exponent),\\n   * the plaintext produced can further be decoded into a set of bet attributes and a number of checksum-like fields, which get validated as well\\n   * to make sure the bet attributes descibed are accurate, have not been taken from previous bets and so on.\\n   *\\n   * As mentioned above, cipherText gets hashed using keccak256 hash function to further be used as a source of entropy by the smart contract\\n   * to determine the outcome of the bet, the amount to be paid out, the jackpot roll value and so on.\\n   *\\n   * Assuming the hardcoded modulus corresponds to a set of valid RSA parameters (see Dice9.sol for the proof), every set of bet attributes would\\n   * produce a single cipherText decrypting into that same bet attributes, meaning that any bet a player places would get a single random number\\n   * associated.\\n   *\\n   * @param modulus0 first 32 bytes of the modulus\\n   * @param modulus1 second 32 bytes of the modulus\\n   * @param modulus2 third 32 bytes of the modulus\\n   * @param modulus3 fourth 32 bytes of the modulus\\n   * @param cipherText the ciphertext received from a Croupier to decrypt.\\n   *\\n   * @return vrfHash the hash of cipherText which can be used as the entropy source\\n   *         vrfInputHash the hash of bet attributes (see computeVrfInputHash() above)\\n   *         player the address of the player of the bet represented by given ciphertext\\n   *         playerNonce the player nonce of the bet represented by given ciphertext\\n   *         packedBet an instance of PackedBet of the bet represented by given ciphertext.\\n   */\\n  function decrypt(uint modulus0, uint modulus1, uint modulus2, uint modulus3, bytes calldata cipherText) internal view returns (bytes32 vrfHash, bytes32 vrfInputHash, address player, uint playerNonce, PackedBet packedBet)  {\\n    vrfHash = keccak256(cipherText);\\n\\n    // RSA decryption\\n    bytes memory precompileParams = abi.encodePacked(\\n      // byte length of the ciphertext\\n      RSA_CIPHER_TEXT_BYTES,\\n      // byte length of the exponent value\\n      RSA_EXPONENT_BYTES,\\n      // byte length of the modulus\\n      RSA_MODULUS_BYTES,\\n      // the ciphertext to decrypt\\n      cipherText,\\n      // exponent value\\n      RSA_EXPONENT,\\n      // modulus values\\n      modulus0,\\n      modulus1,\\n      modulus2,\\n      modulus3\\n    );\\n\\n    // EIP-198 places BigModExp precompile at 0x5\\n    (bool modExpSuccess, bytes memory plainText) = EIP198_MODEXP.staticcall(precompileParams);\\n\\n    // make sure the decryption succeeds\\n    require(modExpSuccess, \\\"EIP-198 precompile failed!\\\");\\n\\n    // unpack the bet attributes from the decrypted text\\n    (player, playerNonce, packedBet, vrfInputHash) = unpack(plainText);\\n  }\\n\\n  /**\\n   * Unpacks the bet attributes from the plaintext (decrypted bytes) presented as an argument.\\n   *\\n   * The routine checks that the leading padding is set to a specific value - to make sure the ciphertext produced was actually created with\\n   * a valid secret key correponding to the contract's public key (RSA modulus).\\n   *\\n   * An additional check tests that the ciphertext was produced for this particular contract on this particular chain by checking decoded\\n   * data \u2013 otherwise it is considered a replay attack with data taken from another chain.\\n   * \\n   * Last but not least, decoded parameters are equality tested against the corresponding vrfInputHash in the lowest 256 bits of the plaintext\\n   * to prevent Bleichenbacher style attacks (bruteforcing the plaintext to obtain a perfect power).\\n   *\\n   * @param plainText the decoded array of bytes as returned during the decryption stage.\\n   *\\n   * @return player the address of the player placing the bet.\\n   *         playerNonce the seq number of the player's bet against this instance of the contract.\\n   *         packedBet the instance of PackedBet describing the bet the player placed.\\n   *         vrfInputHash the hash of the input parameters of the bet prior to encoding.\\n   */\\n  function unpack(bytes memory plainText) private view returns (address player, uint playerNonce, PackedBet packedBet, bytes32 vrfInputHash) {\\n    uint p0;\\n    uint p1;\\n    uint p2;\\n\\n    // decode the plaintext into 4 uint256 chunks\\n    (p0, p1, p2, vrfInputHash) = abi.decode(plainText, (uint, uint, uint, bytes32));\\n\\n    // the first 32 bytes should be equal to a hardcoded value to guarantee the ciphertext was produced by a legit signatory\\n    if (p0 != P0_PADDING_VALUE) {\\n      revert InvalidSignature();\\n    }\\n\\n    // the second 32 bytes should contain the contract's address (bits 96..256) and chain id (bits 0..96)\\n    if (p1 != uint(uint160(address(this))) << P1_CONTRACT_ADDRESS_BIT_OFFSET | block.chainid) {\\n      revert InvalidSignature();\\n    }\\n\\n    // the player address is going to be kept in lowest 160 bits of the next 32 bytes\\n    player = address(uint160(p2));\\n    // the packed bet occupies 30 bits in positions 161..190, the remaining 2 bits are supposed to store epoch value which we simply discard\\n    // by masking the value against PackedBets.ALL_BUT_EPOCH_BITS\\n    packedBet = PackedBet.wrap((p2 >> P1_PACKED_BET_BIT_OFFSET) & PackedBets.ALL_BUT_EPOCH_BITS);\\n    // the player nonce is the easiest, it takes bites 191..256, so just transfer it over\\n    playerNonce = p2 >> P1_PLAYER_NONCE_BIT_OFFSET;\\n\\n    // the last but not least: verify that the ciphertext contained an ecrypted bet attributes for the encoded\\n    // bet attributes \u2013 this disallows the signatory to craft multiple ciphertexts per bet attributes by tampering with vrfInputHash bytes\\n    if (vrfInputHash != VRF.computeVrfInputHash(player, playerNonce, packedBet)) {\\n      revert InvalidSignature();\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountSuspended\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotAffordToLoseThisBet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CoinFlipSingleOption\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EtherollSingleOption\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxProfitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonFullVRFs\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAscii\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"OptionNotInRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentEpoch\",\"type\":\"uint256\"}],\"name\":\"RefundEpochMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"}],\"name\":\"StorageSignatureMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"WinProbabilityOutOfRange\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"}],\"name\":\"Duplicate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"JackpotMultiplierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"vrfInputHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jackpotPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"humanReadable\",\"type\":\"string\"}],\"name\":\"Lost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MaxProfitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"}],\"name\":\"Nonexistent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"vrfInputHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packedBet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"humanReadable\",\"type\":\"string\"}],\"name\":\"Placed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"vrfInputHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jackpotPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"humanReadable\",\"type\":\"string\"}],\"name\":\"Won\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBetCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedInBetsWithJackpots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"options\",\"type\":\"string\"}],\"name\":\"playCoinFlip\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"options\",\"type\":\"string\"}],\"name\":\"playDice\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"options\",\"type\":\"string\"}],\"name\":\"playEtheroll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"options\",\"type\":\"string\"}],\"name\":\"playTwoDice\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"playerNonce\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newJackpotMultiplier\",\"type\":\"uint256\"}],\"name\":\"setJackpotMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"vrfs\",\"type\":\"bytes\"}],\"name\":\"settleBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"suspend\",\"type\":\"bool\"}],\"name\":\"suspendPlayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topUpContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Dice9", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e0d19c532a737d487310f097d5f8d8a4e64b53940d5b58be09c87f76131e6cb8"}