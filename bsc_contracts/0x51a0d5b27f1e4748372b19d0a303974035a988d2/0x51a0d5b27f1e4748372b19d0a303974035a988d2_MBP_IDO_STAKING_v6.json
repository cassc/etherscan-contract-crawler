{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MBP_IDO_STAKING_v6 is Context, IBEP20, Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    // MBP Token address (The Native Token 1)\r\n    address private MBP_TOKEN_ADDRESS = 0xaF2F53cc6cc0384aba52275b0f715851Fb5AFf94;\r\n    // DKS Token address (The Native Token 2)\r\n    address private DKS_TOKEN_ADDRESS = 0x121235cfF4c59EEC80b14c1d38B44e7de3A18287;\r\n\r\n    address WITHDRAWAL_ADDRESS = 0x014c0fBf5E488cf81876EC350b2Aff32F35C4263;\r\n    \r\n    IBEP20  MBP_TOKEN = IBEP20(\r\n        MBP_TOKEN_ADDRESS\r\n    );\r\n    IBEP20  DKS_TOKEN = IBEP20(\r\n        DKS_TOKEN_ADDRESS\r\n    );\r\n\r\n    \r\n    //----------- BEP20 Variables -----------//\r\n    mapping(address => uint256) private _balances;\r\n    uint256 private _totalSupply;\r\n    uint256 private _maxSupply;\r\n    uint8 private _decimals;\r\n    string private _symbol;\r\n    string private _name;\r\n    //---------------------------------------//\r\n    //---------------------------------------//\r\n\r\n    constructor() {\r\n        _name = \"MobiPad IDO Stake\";\r\n        _symbol = \"MBP_IDO_STAKE\";\r\n        _decimals = 18;\r\n        _totalSupply = 1 * (10**18);\r\n        _balances[msg.sender] = _totalSupply;\r\n\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    //----------- BEP20 Functions -----------//\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n    function decimals() external view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        pure\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(recipient != address(0) && amount > 0, \"MBP: Recipient and amount required\");\r\n        return false;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external pure override returns (bool) {\r\n        require(sender != address(0), \"MBP: Sender required\");\r\n        require(recipient != address(0) && amount > 0, \"MBP: Recipient and amount required\");\r\n        return false;\r\n    }\r\n    function burn(uint256 amount) external onlyOwner returns (bool) {\r\n        _burnStakeTokens(_msgSender(), amount);\r\n        return true;\r\n    }\r\n    function _mintStakeTokens(address account, uint256 amount) internal {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n    function _burnStakeTokens(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: burn from the zero address\");\r\n        _balances[account] = _balances[account].sub(\r\n            amount,\r\n            \"BEP20: burn amount exceeds balance\"\r\n        );\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    //---------------------------------------//\r\n    //---------------------------------------//\r\n    \r\n    uint32 constant SECONDS_IN_DAY = 86400 seconds;\r\n\r\n    mapping(address => uint256) private MBP_AMOUNT_STAKED;\r\n    mapping(address => uint256) private DKS_AMOUNT_STAKED;\r\n\r\n    mapping(address => uint256) private MBP_STAKE_DAYS;\r\n    mapping(address => uint256) private DKS_STAKE_DAYS;\r\n\r\n    mapping(address => bool) private MBP_STAKED;\r\n    mapping(address => bool) private DKS_STAKED;\r\n\r\n    uint256 private MBP_TOTAL_STAKERS = 0;\r\n\r\n    uint256 private DKS_TOTAL_STAKERS = 0;\r\n    \r\n    uint256 private MINIMUM_MBP_STAKE = 50_000 * (10**18);\r\n    uint256 private MINIMUM_DKS_STAKE = 50_000 * (10**18);\r\n\r\n    // By setting MINIMUM_DAYS_TO_UNSTAKE and STRICT_NO_UNSTAKE_DAYS to the same value, \r\n    // you create a scenario where the unstaking only checks for the minimum days required \r\n    // (which the the value set for the two) without deducting any fees.\r\n    uint64 private MINIMUM_DAYS_TO_UNSTAKE = 30;\r\n    uint64 private STRICT_NO_UNSTAKE_DAYS = 10;\r\n    \r\n    // Unripe unstake fee in %\r\n    uint256 private UNRIPE_UNSTAKE_1_FEE = 10;\r\n    uint256 private UNRIPE_UNSTAKE_2_FEE = 5;\r\n\r\n    function getMinimum_MBP_Stake() external view returns (uint256) {\r\n        return MINIMUM_MBP_STAKE;\r\n    }\r\n\r\n    function setMinimum_MBP_Stake(uint256 _minimum_MBP_Stake) external onlyOwner {\r\n        MINIMUM_MBP_STAKE = _minimum_MBP_Stake;\r\n    }\r\n\r\n    function getMinimum_DKS_Stake() external view returns (uint256) {\r\n        return MINIMUM_DKS_STAKE;\r\n    }\r\n\r\n    function setMinimum_DKS_Stake(uint256 _minimum_DKS_Stake) external onlyOwner {\r\n        MINIMUM_DKS_STAKE = _minimum_DKS_Stake;\r\n    }\r\n\r\n    function getMinimumDaysToUnStake() external view returns (uint64) {\r\n        return MINIMUM_DAYS_TO_UNSTAKE;\r\n    }\r\n\r\n    function setMinimumDaysToUnStake(uint64 _minimumDaysToUnstake) external onlyOwner {\r\n        MINIMUM_DAYS_TO_UNSTAKE = _minimumDaysToUnstake;\r\n    }\r\n\r\n    function getNoUnStakeDays() external view returns (uint64) {\r\n        return STRICT_NO_UNSTAKE_DAYS;\r\n    }\r\n\r\n    function setNoUnStakeDays(uint64 _noUnstakeDays) external onlyOwner {\r\n        STRICT_NO_UNSTAKE_DAYS = _noUnstakeDays;\r\n    }\r\n\r\n    function getUnripeUnStakeFee1() external view returns (uint256) {\r\n        return UNRIPE_UNSTAKE_1_FEE;\r\n    }\r\n    function getUnripeUnStakeFee2() external view returns (uint256) {\r\n        return UNRIPE_UNSTAKE_2_FEE;\r\n    }\r\n\r\n    function setUnripeUnStakeFee(uint256 _fee1, uint256 _fee2) external onlyOwner {\r\n        UNRIPE_UNSTAKE_1_FEE = _fee1;\r\n        UNRIPE_UNSTAKE_2_FEE = _fee2;\r\n    }\r\n\r\n    function getWithdrawalAddress() external view returns (address) {\r\n        return WITHDRAWAL_ADDRESS;\r\n    }\r\n\r\n    function setWithdrawalAddress(address _addr) external onlyOwner {\r\n        WITHDRAWAL_ADDRESS = _addr;\r\n    }\r\n\r\n    function stakeMBP(uint256 _tokenAmount) external nonReentrant {\r\n        require(_tokenAmount >= MINIMUM_MBP_STAKE, \"MBP: Stake amount too small. Please try a bigger amount\");\r\n\r\n        //Get user stake\r\n        require(\r\n            MBP_TOKEN.transferFrom(msg.sender, address(this), _tokenAmount),\r\n            \"MBP: Error in token transfer\"\r\n        );\r\n\r\n        //hasn't staked before\r\n        if(!MBP_STAKED[msg.sender]){\r\n            MBP_STAKE_DAYS[msg.sender] = block.timestamp;\r\n            MBP_STAKED[msg.sender] = true;\r\n            MBP_TOTAL_STAKERS = MBP_TOTAL_STAKERS.add(1);\r\n        }\r\n\r\n        //add stake detials of user\r\n        MBP_AMOUNT_STAKED[msg.sender] = MBP_AMOUNT_STAKED[msg.sender].add(_tokenAmount);\r\n\r\n        //transfer stake token to user\r\n        _mintStakeTokens(msg.sender, _tokenAmount);\r\n    }\r\n\r\n    function stakeDKS(uint256 _tokenAmount) external nonReentrant {\r\n        require(_tokenAmount >= MINIMUM_DKS_STAKE, \"MBP: Stake amount too small. Please try a bigger amount\");\r\n\r\n        //Get user stake\r\n        require(\r\n            DKS_TOKEN.transferFrom(msg.sender, address(this), _tokenAmount),\r\n            \"MBP: Error in token transfer\"\r\n        );\r\n\r\n        //hasn't staked before\r\n        if(!DKS_STAKED[msg.sender]){\r\n            DKS_STAKE_DAYS[msg.sender] = block.timestamp;\r\n            DKS_STAKED[msg.sender] = true;\r\n            DKS_TOTAL_STAKERS = DKS_TOTAL_STAKERS.add(1);\r\n        }\r\n\r\n        //add stake detials of user\r\n        DKS_AMOUNT_STAKED[msg.sender] = DKS_AMOUNT_STAKED[msg.sender].add(_tokenAmount);\r\n\r\n        //transfer stake token to user\r\n        _mintStakeTokens(msg.sender, _tokenAmount);\r\n    }\r\n\r\n    function unstakeMBP(uint256 _tokenAmount) external nonReentrant {\r\n        require(MBP_STAKED[msg.sender], \"MBP: You didn't stake MBP\");\r\n        require(_tokenAmount <= MBP_AMOUNT_STAKED[msg.sender], \"MBP: Amount exceed stake\");\r\n        //can't unstake less than minimum\r\n        require(_tokenAmount >= MINIMUM_MBP_STAKE, \"MBP: Amount too small. Please try a bigger amount\");\r\n\r\n        uint256 stakeDays = (block.timestamp - MBP_STAKE_DAYS[msg.sender]) / SECONDS_IN_DAY;\r\n        \r\n        //check for minimum day\r\n        require(\r\n            stakeDays > STRICT_NO_UNSTAKE_DAYS, \r\n            \"MBP: Your stake days isn't up to minimum to unstake\"\r\n        );\r\n\r\n        if((MBP_AMOUNT_STAKED[msg.sender] - _tokenAmount) < MINIMUM_MBP_STAKE){\r\n            _tokenAmount = MBP_AMOUNT_STAKED[msg.sender];\r\n        }\r\n\r\n        uint256 userAmount = _tokenAmount;\r\n        uint256 unripeFee = 0;\r\n        \r\n        uint256 UnripeUnstakeCase = (MINIMUM_DAYS_TO_UNSTAKE - STRICT_NO_UNSTAKE_DAYS);\r\n        UnripeUnstakeCase = UnripeUnstakeCase / 2;\r\n\r\n        if (stakeDays > UnripeUnstakeCase && stakeDays <= (UnripeUnstakeCase * 2)) {//  Unripe Unstake case 1\r\n            unripeFee = (_tokenAmount * UNRIPE_UNSTAKE_1_FEE) / 100;\r\n            userAmount = _tokenAmount - unripeFee;\r\n        }\r\n        if (stakeDays > (UnripeUnstakeCase * 2) && stakeDays <= MINIMUM_DAYS_TO_UNSTAKE) {//  Unripe Unstake case 2\r\n            unripeFee = (_tokenAmount * UNRIPE_UNSTAKE_2_FEE) / 100;\r\n            userAmount = _tokenAmount - unripeFee;\r\n        }\r\n\r\n        if(_tokenAmount == MBP_AMOUNT_STAKED[msg.sender]){\r\n            MBP_STAKE_DAYS[msg.sender] = 0;\r\n            MBP_STAKED[msg.sender] = false;\r\n            MBP_TOTAL_STAKERS = MBP_TOTAL_STAKERS.sub(1);\r\n        }\r\n\r\n        //update stake detials of user\r\n        MBP_AMOUNT_STAKED[msg.sender] = MBP_AMOUNT_STAKED[msg.sender].sub(_tokenAmount);\r\n\r\n        //send tokens to the investor\r\n        require(\r\n            MBP_TOKEN.transfer(msg.sender, userAmount),\r\n            \"MBP: Error in token transfer\"\r\n        );\r\n\r\n        //if fee taken then transfer to Withdrawal address\r\n        if (unripeFee > 0) {\r\n            MBP_TOKEN.transfer(WITHDRAWAL_ADDRESS, unripeFee);\r\n        }\r\n\r\n        //burn stake tokens\r\n        _burnStakeTokens(msg.sender, _tokenAmount);\r\n    }\r\n\r\n    function unstakeDKS(uint256 _tokenAmount) external nonReentrant {\r\n        require(DKS_STAKED[msg.sender], \"MBP: You didn't stake DKS\");\r\n        require(_tokenAmount <= DKS_AMOUNT_STAKED[msg.sender], \"MBP: Amount exceed stake\");\r\n        //can't unstake less than minimum\r\n        require(_tokenAmount >= MINIMUM_DKS_STAKE, \"MBP: Amount too small. Please try a bigger amount\");\r\n\r\n         uint256 stakeDays = (block.timestamp - DKS_STAKE_DAYS[msg.sender]) / SECONDS_IN_DAY;\r\n        \r\n        //check for minimum day\r\n        require(\r\n            stakeDays > STRICT_NO_UNSTAKE_DAYS, \r\n            \"MBP: Your stake days isn't up to minimum to unstake\"\r\n        );\r\n\r\n        if((DKS_AMOUNT_STAKED[msg.sender] - _tokenAmount) < MINIMUM_DKS_STAKE){\r\n            _tokenAmount = DKS_AMOUNT_STAKED[msg.sender];\r\n        }\r\n       \r\n        uint256 userAmount = _tokenAmount;\r\n        uint256 unripeFee = 0;\r\n        \r\n        uint256 UnripeUnstakeCase = (MINIMUM_DAYS_TO_UNSTAKE - STRICT_NO_UNSTAKE_DAYS);\r\n        UnripeUnstakeCase = UnripeUnstakeCase / 2;\r\n\r\n        if (stakeDays > UnripeUnstakeCase && stakeDays <= (UnripeUnstakeCase * 2)) {/// Unripe Unstake case 1\r\n            unripeFee = (_tokenAmount * UNRIPE_UNSTAKE_1_FEE) / 100;\r\n            userAmount = _tokenAmount - unripeFee;\r\n        }\r\n        if (stakeDays > (UnripeUnstakeCase * 2) && stakeDays <= MINIMUM_DAYS_TO_UNSTAKE) {// Unripe Unstake case 1\r\n            unripeFee = (_tokenAmount * UNRIPE_UNSTAKE_2_FEE) / 100;\r\n            userAmount = _tokenAmount - unripeFee;\r\n        }\r\n\r\n        if(_tokenAmount == DKS_AMOUNT_STAKED[msg.sender]){\r\n            DKS_STAKE_DAYS[msg.sender] = 0;\r\n            DKS_STAKED[msg.sender] = false;\r\n            DKS_TOTAL_STAKERS = DKS_TOTAL_STAKERS.sub(1);\r\n        }\r\n\r\n        //update stake detials of user\r\n        DKS_AMOUNT_STAKED[msg.sender] = DKS_AMOUNT_STAKED[msg.sender].sub(_tokenAmount);\r\n\r\n        //send tokens to the investor\r\n        require(\r\n            DKS_TOKEN.transfer(msg.sender, userAmount),\r\n            \"MBP: Error in token transfer\"\r\n        );\r\n\r\n        //if fee taken then transfer to Withdrawal address\r\n        if (unripeFee > 0) {\r\n            DKS_TOKEN.transfer(WITHDRAWAL_ADDRESS, unripeFee);\r\n        }\r\n\r\n        //burn stake tokens\r\n        _burnStakeTokens(msg.sender, _tokenAmount);\r\n    }\r\n\r\n    function MBP_StakeDaysCount(address _addr) external view returns (uint64) {\r\n        if(MBP_STAKED[_addr]){\r\n            return uint64((block.timestamp - MBP_STAKE_DAYS[_addr]) / SECONDS_IN_DAY);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function DKS_StakeDaysCount(address _addr) external view returns (uint64) {\r\n        if(DKS_STAKED[_addr]){\r\n            return uint64((block.timestamp - DKS_STAKE_DAYS[_addr]) / SECONDS_IN_DAY);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getUserMBPAmountStaked(address _addr) external view returns (uint256) {\r\n        return MBP_AMOUNT_STAKED[_addr];\r\n    }\r\n\r\n    function getUserDKSAmountStaked(address _addr) external view returns (uint256) {\r\n        return DKS_AMOUNT_STAKED[_addr];\r\n    }\r\n\r\n    function getTotalMBPAmountStaked() external view returns (uint256) {\r\n        return MBP_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    function getTotalDKSAmountStaked() external view returns (uint256) {\r\n        return DKS_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    function getTotalStakersMBP() external view returns (uint256) {\r\n        return MBP_TOTAL_STAKERS;\r\n    }\r\n\r\n    function getTotalStakersDKS() external view returns (uint256) {\r\n        return DKS_TOTAL_STAKERS;\r\n    }\r\n\r\n    function confirmStakeWithDays(\r\n        address _addr, \r\n        uint256 _stakeAmountMBP, \r\n        uint256 _stakeAmountDKS, \r\n        uint64 _days\r\n    ) external view returns (bool) {\r\n        bool passAmount_MBP = MBP_AMOUNT_STAKED[_addr] >= _stakeAmountMBP;\r\n        bool passDays_MBP = ((block.timestamp - MBP_STAKE_DAYS[_addr]) / SECONDS_IN_DAY) >= _days;\r\n\r\n        bool passAmount_DKS = DKS_AMOUNT_STAKED[_addr] >= _stakeAmountDKS;\r\n        bool passDays_DKS = ((block.timestamp - DKS_STAKE_DAYS[_addr]) / SECONDS_IN_DAY) >= _days;\r\n\r\n        if(MBP_STAKED[_addr] && passAmount_MBP && passDays_MBP){\r\n            return true;\r\n        }\r\n\r\n        if(DKS_STAKED[_addr] && passAmount_DKS && passDays_DKS){\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function confirmStakeWithoutDays(\r\n        address _addr, \r\n        uint256 _stakeAmountMBP, \r\n        uint256 _stakeAmountDKS\r\n    ) external view returns (bool) {\r\n        bool passAmount_MBP = MBP_AMOUNT_STAKED[_addr] >= _stakeAmountMBP;\r\n\r\n        bool passAmount_DKS = DKS_AMOUNT_STAKED[_addr] >= _stakeAmountDKS;\r\n\r\n        if(MBP_STAKED[_addr] && passAmount_MBP){\r\n            return true;\r\n        }\r\n\r\n        if(DKS_STAKED[_addr] && passAmount_DKS){\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function rescueStuckBnb(uint256 _amount) external onlyOwner {\r\n        (bool success, ) = WITHDRAWAL_ADDRESS.call{value: _amount}(\"\");\r\n        require(success);\r\n    } \r\n\r\n    function rescueStuckTokens(address _tokenAddress, uint256 _amount) external onlyOwner {\r\n        IBEP20 BEP20token = IBEP20(_tokenAddress);\r\n        BEP20token.transfer(WITHDRAWAL_ADDRESS, _amount);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"DKS_StakeDaysCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"MBP_StakeDaysCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmountMBP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmountDKS\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_days\",\"type\":\"uint64\"}],\"name\":\"confirmStakeWithDays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmountMBP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmountDKS\",\"type\":\"uint256\"}],\"name\":\"confirmStakeWithoutDays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumDaysToUnStake\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimum_DKS_Stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimum_MBP_Stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNoUnStakeDays\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDKSAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMBPAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakersDKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakersMBP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnripeUnStakeFee1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnripeUnStakeFee2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserDKSAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserMBPAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawalAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rescueStuckBnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rescueStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_minimumDaysToUnstake\",\"type\":\"uint64\"}],\"name\":\"setMinimumDaysToUnStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimum_DKS_Stake\",\"type\":\"uint256\"}],\"name\":\"setMinimum_DKS_Stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimum_MBP_Stake\",\"type\":\"uint256\"}],\"name\":\"setMinimum_MBP_Stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_noUnstakeDays\",\"type\":\"uint64\"}],\"name\":\"setNoUnStakeDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee2\",\"type\":\"uint256\"}],\"name\":\"setUnripeUnStakeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWithdrawalAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"stakeDKS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"stakeMBP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"unstakeDKS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"unstakeMBP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MBP_IDO_STAKING_v6", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dfb36e9e4573a469f0a12bb284a3e98d89da596e1b1cd8e99f6112ffb9a74009"}