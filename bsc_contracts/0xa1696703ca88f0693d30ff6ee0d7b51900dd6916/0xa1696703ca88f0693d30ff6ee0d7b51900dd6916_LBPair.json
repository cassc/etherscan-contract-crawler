{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LBErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./interfaces/ILBPair.sol\\\";\\n\\n/** LBRouter errors */\\n\\nerror LBRouter__SenderIsNotWAVAX();\\nerror LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\\nerror LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\\nerror LBRouter__SwapOverflows(uint256 id);\\nerror LBRouter__BrokenSwapSafetyCheck();\\nerror LBRouter__NotFactoryOwner();\\nerror LBRouter__TooMuchTokensIn(uint256 excess);\\nerror LBRouter__BinReserveOverflows(uint256 id);\\nerror LBRouter__IdOverflows(int256 id);\\nerror LBRouter__LengthsMismatch();\\nerror LBRouter__WrongTokenOrder();\\nerror LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\\nerror LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\\nerror LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\\nerror LBRouter__FailedToSendAVAX(address recipient, uint256 amount);\\nerror LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\\nerror LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\\nerror LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\\nerror LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\\nerror LBRouter__InvalidTokenPath(address wrongToken);\\nerror LBRouter__InvalidVersion(uint256 version);\\nerror LBRouter__WrongAvaxLiquidityParameters(\\n    address tokenX,\\n    address tokenY,\\n    uint256 amountX,\\n    uint256 amountY,\\n    uint256 msgValue\\n);\\n\\n/** LBToken errors */\\n\\nerror LBToken__SpenderNotApproved(address owner, address spender);\\nerror LBToken__TransferFromOrToAddress0();\\nerror LBToken__MintToAddress0();\\nerror LBToken__BurnFromAddress0();\\nerror LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\\nerror LBToken__LengthMismatch(uint256 accountsLength, uint256 idsLength);\\nerror LBToken__SelfApproval(address owner);\\nerror LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\\nerror LBToken__TransferToSelf();\\n\\n/** LBFactory errors */\\n\\nerror LBFactory__IdenticalAddresses(IERC20 token);\\nerror LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\\nerror LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\\nerror LBFactory__AddressZero();\\nerror LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\\nerror LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\\nerror LBFactory__DecreasingPeriods(uint16 filterPeriod, uint16 decayPeriod);\\nerror LBFactory__ReductionFactorOverflows(uint16 reductionFactor, uint256 max);\\nerror LBFactory__VariableFeeControlOverflows(uint16 variableFeeControl, uint256 max);\\nerror LBFactory__BaseFeesBelowMin(uint256 baseFees, uint256 minBaseFees);\\nerror LBFactory__FeesAboveMax(uint256 fees, uint256 maxFees);\\nerror LBFactory__FlashLoanFeeAboveMax(uint256 fees, uint256 maxFees);\\nerror LBFactory__BinStepRequirementsBreached(uint256 lowerBound, uint16 binStep, uint256 higherBound);\\nerror LBFactory__ProtocolShareOverflows(uint16 protocolShare, uint256 max);\\nerror LBFactory__FunctionIsLockedForUsers(address user);\\nerror LBFactory__FactoryLockIsAlreadyInTheSameState();\\nerror LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\\nerror LBFactory__BinStepHasNoPreset(uint256 binStep);\\nerror LBFactory__SameFeeRecipient(address feeRecipient);\\nerror LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\\nerror LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\\nerror LBFactory__SameImplementation(address LBPairImplementation);\\nerror LBFactory__ImplementationNotSet();\\n\\n/** LBPair errors */\\n\\nerror LBPair__InsufficientAmounts();\\nerror LBPair__AddressZero();\\nerror LBPair__AddressZeroOrThis();\\nerror LBPair__CompositionFactorFlawed(uint256 id);\\nerror LBPair__InsufficientLiquidityMinted(uint256 id);\\nerror LBPair__InsufficientLiquidityBurned(uint256 id);\\nerror LBPair__WrongLengths();\\nerror LBPair__OnlyStrictlyIncreasingId();\\nerror LBPair__OnlyFactory();\\nerror LBPair__DistributionsOverflow();\\nerror LBPair__OnlyFeeRecipient(address feeRecipient, address sender);\\nerror LBPair__OracleNotEnoughSample();\\nerror LBPair__AlreadyInitialized();\\nerror LBPair__OracleNewSizeTooSmall(uint256 newSize, uint256 oracleSize);\\nerror LBPair__FlashLoanCallbackFailed();\\nerror LBPair__FlashLoanInvalidBalance();\\nerror LBPair__FlashLoanInvalidToken();\\n\\n/** BinHelper errors */\\n\\nerror BinHelper__BinStepOverflows(uint256 bp);\\nerror BinHelper__IdOverflows();\\n\\n/** Math128x128 errors */\\n\\nerror Math128x128__PowerUnderflow(uint256 x, int256 y);\\nerror Math128x128__LogUnderflow();\\n\\n/** Math512Bits errors */\\n\\nerror Math512Bits__MulDivOverflow(uint256 prod1, uint256 denominator);\\nerror Math512Bits__ShiftDivOverflow(uint256 prod1, uint256 denominator);\\nerror Math512Bits__MulShiftOverflow(uint256 prod1, uint256 offset);\\nerror Math512Bits__OffsetOverflows(uint256 offset);\\n\\n/** Oracle errors */\\n\\nerror Oracle__AlreadyInitialized(uint256 _index);\\nerror Oracle__LookUpTimestampTooOld(uint256 _minTimestamp, uint256 _lookUpTimestamp);\\nerror Oracle__NotInitialized();\\n\\n/** PendingOwnable errors */\\n\\nerror PendingOwnable__NotOwner();\\nerror PendingOwnable__NotPendingOwner();\\nerror PendingOwnable__PendingOwnerAlreadySet();\\nerror PendingOwnable__NoPendingOwner();\\nerror PendingOwnable__AddressZero();\\n\\n/** ReentrancyGuardUpgradeable errors */\\n\\nerror ReentrancyGuardUpgradeable__ReentrantCall();\\nerror ReentrancyGuardUpgradeable__AlreadyInitialized();\\n\\n/** SafeCast errors */\\n\\nerror SafeCast__Exceeds256Bits(uint256 x);\\nerror SafeCast__Exceeds248Bits(uint256 x);\\nerror SafeCast__Exceeds240Bits(uint256 x);\\nerror SafeCast__Exceeds232Bits(uint256 x);\\nerror SafeCast__Exceeds224Bits(uint256 x);\\nerror SafeCast__Exceeds216Bits(uint256 x);\\nerror SafeCast__Exceeds208Bits(uint256 x);\\nerror SafeCast__Exceeds200Bits(uint256 x);\\nerror SafeCast__Exceeds192Bits(uint256 x);\\nerror SafeCast__Exceeds184Bits(uint256 x);\\nerror SafeCast__Exceeds176Bits(uint256 x);\\nerror SafeCast__Exceeds168Bits(uint256 x);\\nerror SafeCast__Exceeds160Bits(uint256 x);\\nerror SafeCast__Exceeds152Bits(uint256 x);\\nerror SafeCast__Exceeds144Bits(uint256 x);\\nerror SafeCast__Exceeds136Bits(uint256 x);\\nerror SafeCast__Exceeds128Bits(uint256 x);\\nerror SafeCast__Exceeds120Bits(uint256 x);\\nerror SafeCast__Exceeds112Bits(uint256 x);\\nerror SafeCast__Exceeds104Bits(uint256 x);\\nerror SafeCast__Exceeds96Bits(uint256 x);\\nerror SafeCast__Exceeds88Bits(uint256 x);\\nerror SafeCast__Exceeds80Bits(uint256 x);\\nerror SafeCast__Exceeds72Bits(uint256 x);\\nerror SafeCast__Exceeds64Bits(uint256 x);\\nerror SafeCast__Exceeds56Bits(uint256 x);\\nerror SafeCast__Exceeds48Bits(uint256 x);\\nerror SafeCast__Exceeds40Bits(uint256 x);\\nerror SafeCast__Exceeds32Bits(uint256 x);\\nerror SafeCast__Exceeds24Bits(uint256 x);\\nerror SafeCast__Exceeds16Bits(uint256 x);\\nerror SafeCast__Exceeds8Bits(uint256 x);\\n\\n/** TreeMath errors */\\n\\nerror TreeMath__ErrorDepthSearch();\\n\\n/** JoeLibrary errors */\\n\\nerror JoeLibrary__IdenticalAddresses();\\nerror JoeLibrary__AddressZero();\\nerror JoeLibrary__InsufficientAmount();\\nerror JoeLibrary__InsufficientLiquidity();\\n\\n/** TokenHelper errors */\\n\\nerror TokenHelper__NonContract();\\nerror TokenHelper__CallFailed();\\nerror TokenHelper__TransferFailed();\\n\\n/** LBQuoter errors */\\n\\nerror LBQuoter_InvalidLength();\\n\"\r\n    },\r\n    \"src/LBPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/** Imports **/\\n\\nimport \\\"./LBErrors.sol\\\";\\nimport \\\"./LBToken.sol\\\";\\nimport \\\"./libraries/BinHelper.sol\\\";\\nimport \\\"./libraries/Constants.sol\\\";\\nimport \\\"./libraries/Decoder.sol\\\";\\nimport \\\"./libraries/FeeDistributionHelper.sol\\\";\\nimport \\\"./libraries/Math512Bits.sol\\\";\\nimport \\\"./libraries/Oracle.sol\\\";\\nimport \\\"./libraries/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"./libraries/SafeCast.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/SwapHelper.sol\\\";\\nimport \\\"./libraries/TokenHelper.sol\\\";\\nimport \\\"./libraries/TreeMath.sol\\\";\\nimport \\\"./interfaces/ILBPair.sol\\\";\\n\\n/// @title Liquidity Book Pair\\n/// @author Trader Joe\\n/// @notice This contract is the implementation of Liquidity Book Pair that also acts as the receipt token for liquidity positions\\ncontract LBPair is LBToken, ReentrancyGuardUpgradeable, ILBPair {\\n    /** Libraries **/\\n\\n    using Math512Bits for uint256;\\n    using TreeMath for mapping(uint256 => uint256)[3];\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n    using TokenHelper for IERC20;\\n    using FeeHelper for FeeHelper.FeeParameters;\\n    using SwapHelper for Bin;\\n    using Decoder for bytes32;\\n    using FeeDistributionHelper for FeeHelper.FeesDistribution;\\n    using Oracle for bytes32[65_535];\\n\\n    /** Modifiers **/\\n\\n    /// @notice Checks if the caller is the factory\\n    modifier onlyFactory() {\\n        if (msg.sender != address(factory)) revert LBPair__OnlyFactory();\\n        _;\\n    }\\n\\n    /** Public immutable variables **/\\n\\n    /// @notice The factory contract that created this pair\\n    ILBFactory public immutable override factory;\\n\\n    /** Public variables **/\\n\\n    /// @notice The token that is used as the base currency for the pair\\n    IERC20 public override tokenX;\\n\\n    /// @notice The token that is used as the quote currency for the pair\\n    IERC20 public override tokenY;\\n\\n    /** Private variables **/\\n\\n    /// @dev The pair information that is used to track reserves, active ids,\\n    /// fees and oracle parameters\\n    PairInformation private _pairInformation;\\n\\n    /// @dev The fee parameters that are used to calculate fees\\n    FeeHelper.FeeParameters private _feeParameters;\\n\\n    /// @dev The reserves of tokens for every bin. This is the amount\\n    /// of tokenY if `id < _pairInformation.activeId`; of tokenX if `id > _pairInformation.activeId`\\n    /// and a mix of both if `id == _pairInformation.activeId`\\n    mapping(uint256 => Bin) private _bins;\\n\\n    /// @dev Tree to find bins with non zero liquidity\\n\\n    /// @dev The tree that is used to find the first bin with non zero liquidity\\n    mapping(uint256 => uint256)[3] private _tree;\\n\\n    /// @dev The mapping from account to user's unclaimed fees. The first 128 bits are tokenX and the last are for tokenY\\n    mapping(address => bytes32) private _unclaimedFees;\\n\\n    /// @dev The mapping from account to id to user's accruedDebt\\n    mapping(address => mapping(uint256 => Debts)) private _accruedDebts;\\n\\n    /// @dev The oracle samples that are used to calculate the time weighted average data\\n    bytes32[65_535] private _oracle;\\n\\n    /** OffSets */\\n\\n    uint256 private constant _OFFSET_PAIR_RESERVE_X = 24;\\n    uint256 private constant _OFFSET_PROTOCOL_FEE = 128;\\n    uint256 private constant _OFFSET_BIN_RESERVE_Y = 112;\\n    uint256 private constant _OFFSET_VARIABLE_FEE_PARAMETERS = 144;\\n    uint256 private constant _OFFSET_ORACLE_SAMPLE_LIFETIME = 136;\\n    uint256 private constant _OFFSET_ORACLE_SIZE = 152;\\n    uint256 private constant _OFFSET_ORACLE_ACTIVE_SIZE = 168;\\n    uint256 private constant _OFFSET_ORACLE_LAST_TIMESTAMP = 184;\\n    uint256 private constant _OFFSET_ORACLE_ID = 224;\\n\\n    /** Constructor **/\\n\\n    /// @notice Set the factory address\\n    /// @param _factory The address of the factory\\n    constructor(ILBFactory _factory) LBToken() {\\n        if (address(_factory) == address(0)) revert LBPair__AddressZero();\\n        factory = _factory;\\n    }\\n\\n    /// @notice Initialize the parameters of the LBPair\\n    /// @dev The different parameters needs to be validated very cautiously\\n    /// It is highly recommended to never call this function directly, use the factory\\n    /// as it validates the different parameters\\n    /// @param _tokenX The address of the tokenX. Can't be address 0\\n    /// @param _tokenY The address of the tokenY. Can't be address 0\\n    /// @param _activeId The active id of the pair\\n    /// @param _sampleLifetime The lifetime of a sample. It's the min time between 2 oracle's sample\\n    /// @param _packedFeeParameters The fee parameters packed in a single 256 bits slot\\n    function initialize(\\n        IERC20 _tokenX,\\n        IERC20 _tokenY,\\n        uint24 _activeId,\\n        uint16 _sampleLifetime,\\n        bytes32 _packedFeeParameters\\n    ) external override onlyFactory {\\n        if (address(_tokenX) == address(0) || address(_tokenY) == address(0)) revert LBPair__AddressZero();\\n        if (address(tokenX) != address(0)) revert LBPair__AlreadyInitialized();\\n\\n        __ReentrancyGuard_init();\\n\\n        tokenX = _tokenX;\\n        tokenY = _tokenY;\\n\\n        _pairInformation.activeId = _activeId;\\n        _pairInformation.oracleSampleLifetime = _sampleLifetime;\\n\\n        _setFeesParameters(_packedFeeParameters);\\n        _increaseOracle(2);\\n    }\\n\\n    /** External View Functions **/\\n\\n    /// @notice View function to get the reserves and active id\\n    /// @return reserveX The reserve of asset X\\n    /// @return reserveY The reserve of asset Y\\n    /// @return activeId The active id of the pair\\n    function getReservesAndId()\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 reserveX,\\n            uint256 reserveY,\\n            uint256 activeId\\n        )\\n    {\\n        return _getReservesAndId();\\n    }\\n\\n    /// @notice View function to get the total fees and the protocol fees of each tokens\\n    /// @return feesXTotal The total fees of tokenX\\n    /// @return feesYTotal The total fees of tokenY\\n    /// @return feesXProtocol The protocol fees of tokenX\\n    /// @return feesYProtocol The protocol fees of tokenY\\n    function getGlobalFees()\\n        external\\n        view\\n        override\\n        returns (\\n            uint128 feesXTotal,\\n            uint128 feesYTotal,\\n            uint128 feesXProtocol,\\n            uint128 feesYProtocol\\n        )\\n    {\\n        return _getGlobalFees();\\n    }\\n\\n    /// @notice View function to get the oracle parameters\\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\\n    /// @return oracleSize The size of the oracle (last ids can be empty)\\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\\n    /// @return oracleId The index of the oracle's latest sample\\n    /// @return min The min delta time of two samples\\n    /// @return max The safe max delta time of two samples\\n    function getOracleParameters()\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 oracleSampleLifetime,\\n            uint256 oracleSize,\\n            uint256 oracleActiveSize,\\n            uint256 oracleLastTimestamp,\\n            uint256 oracleId,\\n            uint256 min,\\n            uint256 max\\n        )\\n    {\\n        (oracleSampleLifetime, oracleSize, oracleActiveSize, oracleLastTimestamp, oracleId) = _getOracleParameters();\\n        min = oracleActiveSize == 0 ? 0 : oracleSampleLifetime;\\n        max = oracleSampleLifetime * oracleActiveSize;\\n    }\\n\\n    /// @notice View function to get the oracle's sample at `_timeDelta` seconds\\n    /// @dev Return a linearized sample, the weighted average of 2 neighboring samples\\n    /// @param _timeDelta The number of seconds before the current timestamp\\n    /// @return cumulativeId The weighted average cumulative id\\n    /// @return cumulativeVolatilityAccumulated The weighted average cumulative volatility accumulated\\n    /// @return cumulativeBinCrossed The weighted average cumulative bin crossed\\n    function getOracleSampleFrom(uint256 _timeDelta)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 cumulativeId,\\n            uint256 cumulativeVolatilityAccumulated,\\n            uint256 cumulativeBinCrossed\\n        )\\n    {\\n        uint256 _lookUpTimestamp = block.timestamp - _timeDelta;\\n\\n        (, , uint256 _oracleActiveSize, , uint256 _oracleId) = _getOracleParameters();\\n\\n        uint256 timestamp;\\n        (timestamp, cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed) = _oracle.getSampleAt(\\n            _oracleActiveSize,\\n            _oracleId,\\n            _lookUpTimestamp\\n        );\\n\\n        if (timestamp < _lookUpTimestamp) {\\n            FeeHelper.FeeParameters memory _fp = _feeParameters;\\n            uint256 _activeId = _pairInformation.activeId;\\n            _fp.updateVariableFeeParameters(_activeId);\\n\\n            unchecked {\\n                uint256 _deltaT = _lookUpTimestamp - timestamp;\\n\\n                cumulativeId += _activeId * _deltaT;\\n                cumulativeVolatilityAccumulated += uint256(_fp.volatilityAccumulated) * _deltaT;\\n            }\\n        }\\n    }\\n\\n    /// @notice View function to get the fee parameters\\n    /// @return The fee parameters\\n    function feeParameters() external view override returns (FeeHelper.FeeParameters memory) {\\n        return _feeParameters;\\n    }\\n\\n    /// @notice View function to get the first bin that isn't empty, will not be `_id` itself\\n    /// @param _id The bin id\\n    /// @param _swapForY Whether you've swapping token X for token Y (true) or token Y for token X (false)\\n    /// @return The id of the non empty bin\\n    function findFirstNonEmptyBinId(uint24 _id, bool _swapForY) external view override returns (uint24) {\\n        return _tree.findFirstBin(_id, _swapForY);\\n    }\\n\\n    /// @notice View function to get the bin at `id`\\n    /// @param _id The bin id\\n    /// @return reserveX The reserve of tokenX of the bin\\n    /// @return reserveY The reserve of tokenY of the bin\\n    function getBin(uint24 _id) external view override returns (uint256 reserveX, uint256 reserveY) {\\n        return _getBin(_id);\\n    }\\n\\n    /// @notice View function to get the pending fees of a user\\n    /// @dev The array must be strictly increasing to ensure uniqueness\\n    /// @param _account The address of the user\\n    /// @param _ids The list of ids\\n    /// @return amountX The amount of tokenX pending\\n    /// @return amountY The amount of tokenY pending\\n    function pendingFees(address _account, uint256[] calldata _ids)\\n        external\\n        view\\n        override\\n        returns (uint256 amountX, uint256 amountY)\\n    {\\n        if (_account == address(this) || _account == address(0)) return (0, 0);\\n\\n        bytes32 _unclaimedData = _unclaimedFees[_account];\\n\\n        amountX = _unclaimedData.decode(type(uint128).max, 0);\\n        amountY = _unclaimedData.decode(type(uint128).max, 128);\\n\\n        uint256 _lastId;\\n        // Iterate over the ids to get the pending fees of the user for each bin\\n        unchecked {\\n            for (uint256 i; i < _ids.length; ++i) {\\n                uint256 _id = _ids[i];\\n\\n                // Ensures uniqueness of ids\\n                if (_lastId >= _id && i != 0) revert LBPair__OnlyStrictlyIncreasingId();\\n\\n                uint256 _balance = balanceOf(_account, _id);\\n\\n                if (_balance != 0) {\\n                    Bin memory _bin = _bins[_id];\\n\\n                    (uint128 _amountX, uint128 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\\n\\n                    amountX += _amountX;\\n                    amountY += _amountY;\\n                }\\n\\n                _lastId = _id;\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns whether this contract implements the interface defined by\\n    /// `interfaceId` (true) or not (false)\\n    /// @param _interfaceId The interface identifier\\n    /// @return Whether the interface is supported (true) or not (false)\\n    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\\n        return super.supportsInterface(_interfaceId) || _interfaceId == type(ILBPair).interfaceId;\\n    }\\n\\n    /** External Functions **/\\n\\n    /// @notice Swap tokens iterating over the bins until the entire amount is swapped.\\n    /// Will swap token X for token Y if `_swapForY` is true, and token Y for token X if `_swapForY` is false.\\n    /// This function will not transfer the tokens from the caller, it is expected that the tokens have already been\\n    /// transferred to this contract through another contract.\\n    /// That is why this function shouldn't be called directly, but through one of the swap functions of the router\\n    /// that will also perform safety checks.\\n    ///\\n    /// The variable fee is updated throughout the swap, it increases with the number of bins crossed.\\n    /// @param _swapForY Whether you've swapping token X for token Y (true) or token Y for token X (false)\\n    /// @param _to The address to send the tokens to\\n    /// @return amountXOut The amount of token X sent to `_to`\\n    /// @return amountYOut The amount of token Y sent to `_to`\\n    function swap(bool _swapForY, address _to)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 amountXOut, uint256 amountYOut)\\n    {\\n        PairInformation memory _pair = _pairInformation;\\n\\n        uint256 _amountIn = _swapForY\\n            ? tokenX.received(_pair.reserveX, _pair.feesX.total)\\n            : tokenY.received(_pair.reserveY, _pair.feesY.total);\\n\\n        if (_amountIn == 0) revert LBPair__InsufficientAmounts();\\n\\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\\n\\n        uint256 _startId = _pair.activeId;\\n        _fp.updateVariableFeeParameters(_startId);\\n\\n        uint256 _amountOut;\\n        /// Performs the actual swap, iterating over the bins until the entire amount is swapped.\\n        /// It uses the tree to find the next bin to have a non zero reserve of the token we're swapping for.\\n        /// It will also update the variable fee parameters.\\n        while (true) {\\n            Bin memory _bin = _bins[_pair.activeId];\\n            if ((!_swapForY && _bin.reserveX != 0) || (_swapForY && _bin.reserveY != 0)) {\\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\\n                    .getAmounts(_fp, _pair.activeId, _swapForY, _amountIn);\\n\\n                _bin.updateFees(_swapForY ? _pair.feesX : _pair.feesY, _fees, _swapForY, totalSupply(_pair.activeId));\\n\\n                _bin.updateReserves(_pair, _swapForY, _amountInToBin.safe112(), _amountOutOfBin.safe112());\\n\\n                _amountIn -= _amountInToBin + _fees.total;\\n                _amountOut += _amountOutOfBin;\\n\\n                _bins[_pair.activeId] = _bin;\\n\\n                // Avoids stack too deep error\\n                _emitSwap(\\n                    _to,\\n                    _pair.activeId,\\n                    _swapForY,\\n                    _amountInToBin,\\n                    _amountOutOfBin,\\n                    _fp.volatilityAccumulated,\\n                    _fees.total\\n                );\\n            }\\n\\n            /// If the amount in is not 0, it means that we haven't swapped the entire amount yet.\\n            /// We need to find the next bin to swap for.\\n            if (_amountIn != 0) {\\n                _pair.activeId = _tree.findFirstBin(_pair.activeId, _swapForY);\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        // Update the oracle and return the updated oracle id. It uses the oracle size to start filling the new slots.\\n        uint256 _updatedOracleId = _oracle.update(\\n            _pair.oracleSize,\\n            _pair.oracleSampleLifetime,\\n            _pair.oracleLastTimestamp,\\n            _pair.oracleId,\\n            _pair.activeId,\\n            _fp.volatilityAccumulated,\\n            _startId.absSub(_pair.activeId)\\n        );\\n\\n        // Update the oracleId and lastTimestamp if the sample write on another slot\\n        if (_updatedOracleId != _pair.oracleId || _pair.oracleLastTimestamp == 0) {\\n            // Can't overflow as the updatedOracleId < oracleSize\\n            _pair.oracleId = uint16(_updatedOracleId);\\n            _pair.oracleLastTimestamp = block.timestamp.safe40();\\n\\n            // Increase the activeSize if the updated sample is written in a new slot\\n            // Can't overflow as _updatedOracleId < maxSize = 2**16-1\\n            unchecked {\\n                if (_updatedOracleId == _pair.oracleActiveSize) ++_pair.oracleActiveSize;\\n            }\\n        }\\n\\n        /// Update the fee parameters and the pair information\\n        _feeParameters = _fp;\\n        _pairInformation = _pair;\\n\\n        if (_swapForY) {\\n            amountYOut = _amountOut;\\n            tokenY.safeTransfer(_to, _amountOut);\\n        } else {\\n            amountXOut = _amountOut;\\n            tokenX.safeTransfer(_to, _amountOut);\\n        }\\n    }\\n\\n    /// @notice Perform a flashloan on one of the tokens of the pair. The flashloan will call the `_receiver` contract\\n    /// to perform the desired operations. The `_receiver` contract is expected to transfer the `amount + fee` of the\\n    /// token to this contract.\\n    /// @param _receiver The contract that will receive the flashloan and execute the callback\\n    /// @param _token The address of the token to flashloan\\n    /// @param _amount The amount of token to flashloan\\n    /// @param _data The call data that will be forwarded to the `_receiver` contract during the callback\\n    function flashLoan(\\n        ILBFlashLoanCallback _receiver,\\n        IERC20 _token,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external override nonReentrant {\\n        IERC20 _tokenX = tokenX;\\n        if ((_token != _tokenX && _token != tokenY)) revert LBPair__FlashLoanInvalidToken();\\n\\n        uint256 _totalFee = _getFlashLoanFee(_amount);\\n\\n        FeeHelper.FeesDistribution memory _fees = FeeHelper.FeesDistribution({\\n            total: _totalFee.safe128(),\\n            protocol: uint128((_totalFee * _feeParameters.protocolShare) / Constants.BASIS_POINT_MAX)\\n        });\\n\\n        uint256 _balanceBefore = _token.balanceOf(address(this));\\n\\n        _token.safeTransfer(address(_receiver), _amount);\\n\\n        if (\\n            _receiver.LBFlashLoanCallback(msg.sender, _token, _amount, _fees.total, _data) != Constants.CALLBACK_SUCCESS\\n        ) revert LBPair__FlashLoanCallbackFailed();\\n\\n        uint256 _balanceAfter = _token.balanceOf(address(this));\\n\\n        if (_balanceAfter != _balanceBefore + _fees.total) revert LBPair__FlashLoanInvalidBalance();\\n\\n        uint256 _activeId = _pairInformation.activeId;\\n        uint256 _totalSupply = totalSupply(_activeId);\\n\\n        if (_totalFee > 0) {\\n            if (_token == _tokenX) {\\n                (uint128 _feesXTotal, , uint128 _feesXProtocol, ) = _getGlobalFees();\\n\\n                _setFees(_pairInformation.feesX, _feesXTotal + _fees.total, _feesXProtocol + _fees.protocol);\\n                _bins[_activeId].accTokenXPerShare += _fees.getTokenPerShare(_totalSupply);\\n            } else {\\n                (, uint128 _feesYTotal, , uint128 _feesYProtocol) = _getGlobalFees();\\n\\n                _setFees(_pairInformation.feesY, _feesYTotal + _fees.total, _feesYProtocol + _fees.protocol);\\n                _bins[_activeId].accTokenYPerShare += _fees.getTokenPerShare(_totalSupply);\\n            }\\n        }\\n\\n        emit FlashLoan(msg.sender, _receiver, _token, _amount, _fees.total);\\n    }\\n\\n    /// @notice Mint new LB tokens for each bins where the user adds liquidity.\\n    /// This function will not transfer the tokens from the caller, it is expected that the tokens have already been\\n    /// transferred to this contract through another contract.\\n    /// That is why this function shouldn't be called directly, but through one of the add liquidity functions of the\\n    /// router that will also perform safety checks.\\n    /// @dev Any excess amount of token will be sent to the `to` address. The lengths of the arrays must be the same.\\n    /// @param _ids The ids of the bins where the liquidity will be added. It will mint LB tokens for each of these bins.\\n    /// @param _distributionX The percentage of token X to add to each bin. The sum of all the values must not exceed 100%,\\n    /// that is 1e18.\\n    /// @param _distributionY The percentage of token Y to add to each bin. The sum of all the values must not exceed 100%,\\n    /// that is 1e18.\\n    /// @param _to The address that will receive the LB tokens and the excess amount of tokens.\\n    /// @return The amount of token X added to the pair\\n    /// @return The amount of token Y added to the pair\\n    /// @return liquidityMinted The amounts of LB tokens minted for each bin\\n    function mint(\\n        uint256[] calldata _ids,\\n        uint256[] calldata _distributionX,\\n        uint256[] calldata _distributionY,\\n        address _to\\n    )\\n        external\\n        override\\n        nonReentrant\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256[] memory liquidityMinted\\n        )\\n    {\\n        if (_ids.length == 0 || _ids.length != _distributionX.length || _ids.length != _distributionY.length)\\n            revert LBPair__WrongLengths();\\n\\n        PairInformation memory _pair = _pairInformation;\\n\\n        FeeHelper.FeeParameters memory _fp = _feeParameters;\\n\\n        MintInfo memory _mintInfo;\\n\\n        _mintInfo.amountXIn = tokenX.received(_pair.reserveX, _pair.feesX.total).safe112();\\n        _mintInfo.amountYIn = tokenY.received(_pair.reserveY, _pair.feesY.total).safe112();\\n\\n        liquidityMinted = new uint256[](_ids.length);\\n\\n        // Iterate over the ids to calculate the amount of LB tokens to mint for each bin\\n        for (uint256 i; i < _ids.length; ) {\\n            _mintInfo.id = _ids[i].safe24();\\n            Bin memory _bin = _bins[_mintInfo.id];\\n\\n            if (_bin.reserveX == 0 && _bin.reserveY == 0) _tree.addToTree(_mintInfo.id);\\n\\n            _mintInfo.totalDistributionX += _distributionX[i];\\n            _mintInfo.totalDistributionY += _distributionY[i];\\n\\n            // Can't overflow as amounts are uint112 and total distributions will be checked to be smaller or equal than 1e18\\n            unchecked {\\n                _mintInfo.amountX = (_mintInfo.amountXIn * _distributionX[i]) / Constants.PRECISION;\\n                _mintInfo.amountY = (_mintInfo.amountYIn * _distributionY[i]) / Constants.PRECISION;\\n            }\\n\\n            uint256 _price = BinHelper.getPriceFromId(_mintInfo.id, _fp.binStep);\\n            if (_mintInfo.id >= _pair.activeId) {\\n                // The active bin is the only bin that can have a non-zero reserve of the two tokens. When adding liquidity\\n                // with a different ratio than the active bin, the user would actually perform a swap without paying any\\n                // fees. This is why we calculate the fees for the active bin here.\\n                if (_mintInfo.id == _pair.activeId) {\\n                    if (_bin.reserveX != 0 || _bin.reserveY != 0) {\\n                        uint256 _totalSupply = totalSupply(_mintInfo.id);\\n\\n                        uint256 _receivedX;\\n                        uint256 _receivedY;\\n\\n                        {\\n                            uint256 _userL = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\\n                                _mintInfo.amountY;\\n\\n                            uint256 _supply = _totalSupply + _userL;\\n\\n                            // Calculate the amounts received by the user if he were to burn its liquidity directly after adding\\n                            // it. These amounts will be used to calculate the fees.\\n                            _receivedX = _userL.mulDivRoundDown(uint256(_bin.reserveX) + _mintInfo.amountX, _supply);\\n                            _receivedY = _userL.mulDivRoundDown(uint256(_bin.reserveY) + _mintInfo.amountY, _supply);\\n                        }\\n\\n                        _fp.updateVariableFeeParameters(_mintInfo.id);\\n\\n                        FeeHelper.FeesDistribution memory _fees;\\n\\n                        // Checks if the amount of tokens received after burning its liquidity is greater than the amount of\\n                        // tokens sent by the user. If it is, we add a composition fee of the difference between the two amounts.\\n                        if (_mintInfo.amountX > _receivedX) {\\n                            unchecked {\\n                                _fees = _fp.getFeeAmountDistribution(\\n                                    _fp.getFeeAmountForC(_mintInfo.amountX - _receivedX)\\n                                );\\n                            }\\n\\n                            _mintInfo.amountX -= _fees.total;\\n                            _mintInfo.activeFeeX += _fees.total;\\n\\n                            _bin.updateFees(_pair.feesX, _fees, true, _totalSupply);\\n                        }\\n                        if (_mintInfo.amountY > _receivedY) {\\n                            unchecked {\\n                                _fees = _fp.getFeeAmountDistribution(\\n                                    _fp.getFeeAmountForC(_mintInfo.amountY - _receivedY)\\n                                );\\n                            }\\n\\n                            _mintInfo.amountY -= _fees.total;\\n                            _mintInfo.activeFeeY += _fees.total;\\n\\n                            _bin.updateFees(_pair.feesY, _fees, false, _totalSupply);\\n                        }\\n\\n                        if (_mintInfo.activeFeeX > 0 || _mintInfo.activeFeeY > 0)\\n                            emit CompositionFee(\\n                                msg.sender,\\n                                _to,\\n                                _mintInfo.id,\\n                                _mintInfo.activeFeeX,\\n                                _mintInfo.activeFeeY\\n                            );\\n                    }\\n                } else if (_mintInfo.amountY != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\\n            } else if (_mintInfo.amountX != 0) revert LBPair__CompositionFactorFlawed(_mintInfo.id);\\n\\n            // Calculate the amount of LB tokens to mint for this bin\\n            uint256 _liquidity = _price.mulShiftRoundDown(_mintInfo.amountX, Constants.SCALE_OFFSET) +\\n                _mintInfo.amountY;\\n\\n            if (_liquidity == 0) revert LBPair__InsufficientLiquidityMinted(_mintInfo.id);\\n\\n            liquidityMinted[i] = _liquidity;\\n\\n            // Cast can't overflow as amounts are smaller than amountsIn as totalDistribution will be checked to be smaller than 1e18\\n            _bin.reserveX += uint112(_mintInfo.amountX);\\n            _bin.reserveY += uint112(_mintInfo.amountY);\\n\\n            // The addition or the cast can't overflow as it would have reverted during the previous 2 lines if\\n            // amounts were greater than uint112\\n            unchecked {\\n                _pair.reserveX += uint112(_mintInfo.amountX);\\n                _pair.reserveY += uint112(_mintInfo.amountY);\\n\\n                _mintInfo.amountXAddedToPair += _mintInfo.amountX;\\n                _mintInfo.amountYAddedToPair += _mintInfo.amountY;\\n            }\\n\\n            _bins[_mintInfo.id] = _bin;\\n\\n            _mint(_to, _mintInfo.id, _liquidity);\\n\\n            emit DepositedToBin(msg.sender, _to, _mintInfo.id, _mintInfo.amountX, _mintInfo.amountY);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Assert that the distributions don't exceed 100%\\n        if (_mintInfo.totalDistributionX > Constants.PRECISION || _mintInfo.totalDistributionY > Constants.PRECISION)\\n            revert LBPair__DistributionsOverflow();\\n\\n        _pairInformation = _pair;\\n\\n        // Send back the excess of tokens to `_to`\\n        unchecked {\\n            uint256 _amountXAddedPlusFee = _mintInfo.amountXAddedToPair + _mintInfo.activeFeeX;\\n            if (_mintInfo.amountXIn > _amountXAddedPlusFee) {\\n                tokenX.safeTransfer(_to, _mintInfo.amountXIn - _amountXAddedPlusFee);\\n            }\\n\\n            uint256 _amountYAddedPlusFee = _mintInfo.amountYAddedToPair + _mintInfo.activeFeeY;\\n            if (_mintInfo.amountYIn > _amountYAddedPlusFee) {\\n                tokenY.safeTransfer(_to, _mintInfo.amountYIn - _amountYAddedPlusFee);\\n            }\\n        }\\n\\n        return (_mintInfo.amountXAddedToPair, _mintInfo.amountYAddedToPair, liquidityMinted);\\n    }\\n\\n    /// @notice Burns LB tokens and sends the corresponding amounts of tokens to `_to`. The amount of tokens sent is\\n    /// determined by the ratio of the amount of LB tokens burned to the total supply of LB tokens in the bin.\\n    /// This function will not transfer the LB Tokens from the caller, it is expected that the tokens have already been\\n    /// transferred to this contract through another contract.\\n    /// That is why this function shouldn't be called directly, but through one of the remove liquidity functions of the router\\n    /// that will also perform safety checks.\\n    /// @param _ids The ids of the bins from which to remove liquidity\\n    /// @param _amounts The amounts of LB tokens to burn\\n    /// @param _to The address that will receive the tokens\\n    /// @return amountX The amount of token X sent to `_to`\\n    /// @return amountY The amount of token Y sent to `_to`\\n    function burn(\\n        uint256[] calldata _ids,\\n        uint256[] calldata _amounts,\\n        address _to\\n    ) external override nonReentrant returns (uint256 amountX, uint256 amountY) {\\n        if (_ids.length == 0 || _ids.length != _amounts.length) revert LBPair__WrongLengths();\\n\\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _getReservesAndId();\\n\\n        // Iterate over the ids to burn the LB tokens\\n        unchecked {\\n            for (uint256 i; i < _ids.length; ++i) {\\n                uint24 _id = _ids[i].safe24();\\n                uint256 _amountToBurn = _amounts[i];\\n\\n                if (_amountToBurn == 0) revert LBPair__InsufficientLiquidityBurned(_id);\\n\\n                (uint256 _reserveX, uint256 _reserveY) = _getBin(_id);\\n\\n                uint256 _totalSupply = totalSupply(_id);\\n\\n                uint256 _amountX;\\n                uint256 _amountY;\\n\\n                if (_id <= _activeId) {\\n                    _amountY = _amountToBurn.mulDivRoundDown(_reserveY, _totalSupply);\\n\\n                    amountY += _amountY;\\n                    _reserveY -= _amountY;\\n                    _pairReserveY -= _amountY;\\n                }\\n                if (_id >= _activeId) {\\n                    _amountX = _amountToBurn.mulDivRoundDown(_reserveX, _totalSupply);\\n\\n                    amountX += _amountX;\\n                    _reserveX -= _amountX;\\n                    _pairReserveX -= _amountX;\\n                }\\n\\n                if (_reserveX == 0 && _reserveY == 0) _tree.removeFromTree(_id);\\n\\n                // Optimized `_bins[_id] = _bin` to do only 1 sstore\\n                assembly {\\n                    mstore(0, _id)\\n                    mstore(32, _bins.slot)\\n                    let slot := keccak256(0, 64)\\n\\n                    let reserves := add(shl(_OFFSET_BIN_RESERVE_Y, _reserveY), _reserveX)\\n                    sstore(slot, reserves)\\n                }\\n\\n                _burn(address(this), _id, _amountToBurn);\\n\\n                emit WithdrawnFromBin(msg.sender, _to, _id, _amountX, _amountY);\\n            }\\n        }\\n\\n        // Optimization to do only 2 sstore\\n        _pairInformation.reserveX = uint136(_pairReserveX);\\n        _pairInformation.reserveY = uint136(_pairReserveY);\\n\\n        tokenX.safeTransfer(_to, amountX);\\n        tokenY.safeTransfer(_to, amountY);\\n    }\\n\\n    /// @notice Increases the length of the oracle to the given `_newLength` by adding empty samples to the end of the oracle.\\n    /// The samples are however initialized to reduce the gas cost of the updates during a swap.\\n    /// @param _newLength The new length of the oracle\\n    function increaseOracleLength(uint16 _newLength) external override {\\n        _increaseOracle(_newLength);\\n    }\\n\\n    /// @notice Collect the fees accumulated by a user.\\n    /// @param _account The address of the user\\n    /// @param _ids The ids of the bins for which to collect the fees\\n    /// @return amountX The amount of token X collected and sent to `_account`\\n    /// @return amountY The amount of token Y collected and sent to `_account`\\n    function collectFees(address _account, uint256[] calldata _ids)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 amountX, uint256 amountY)\\n    {\\n        if (_account == address(0) || _account == address(this)) revert LBPair__AddressZeroOrThis();\\n\\n        bytes32 _unclaimedData = _unclaimedFees[_account];\\n        delete _unclaimedFees[_account];\\n\\n        amountX = _unclaimedData.decode(type(uint128).max, 0);\\n        amountY = _unclaimedData.decode(type(uint128).max, 128);\\n\\n        // Iterate over the ids to collect the fees\\n        for (uint256 i; i < _ids.length; ) {\\n            uint256 _id = _ids[i];\\n            uint256 _balance = balanceOf(_account, _id);\\n\\n            if (_balance != 0) {\\n                Bin memory _bin = _bins[_id];\\n\\n                (uint256 _amountX, uint256 _amountY) = _getPendingFees(_bin, _account, _id, _balance);\\n                _updateUserDebts(_bin, _account, _id, _balance);\\n\\n                amountX += _amountX;\\n                amountY += _amountY;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (amountX != 0) {\\n            _pairInformation.feesX.total -= uint128(amountX);\\n        }\\n        if (amountY != 0) {\\n            _pairInformation.feesY.total -= uint128(amountY);\\n        }\\n\\n        tokenX.safeTransfer(_account, amountX);\\n        tokenY.safeTransfer(_account, amountY);\\n\\n        emit FeesCollected(msg.sender, _account, amountX, amountY);\\n    }\\n\\n    /// @notice Collect the protocol fees and send them to the fee recipient.\\n    /// @dev The protocol fees are not set to zero to save gas by not resetting the storage slot.\\n    /// @return amountX The amount of token X collected and sent to the fee recipient\\n    /// @return amountY The amount of token Y collected and sent to the fee recipient\\n    function collectProtocolFees() external override nonReentrant returns (uint128 amountX, uint128 amountY) {\\n        address _feeRecipient = factory.feeRecipient();\\n\\n        if (msg.sender != _feeRecipient) revert LBPair__OnlyFeeRecipient(_feeRecipient, msg.sender);\\n\\n        (uint128 _feesXTotal, uint128 _feesYTotal, uint128 _feesXProtocol, uint128 _feesYProtocol) = _getGlobalFees();\\n\\n        // The protocol fees are not set to 0 to reduce the gas cost during a swap\\n        if (_feesXProtocol > 1) {\\n            amountX = _feesXProtocol - 1;\\n            _feesXTotal -= amountX;\\n\\n            _setFees(_pairInformation.feesX, _feesXTotal, 1);\\n\\n            tokenX.safeTransfer(_feeRecipient, amountX);\\n        }\\n\\n        if (_feesYProtocol > 1) {\\n            amountY = _feesYProtocol - 1;\\n            _feesYTotal -= amountY;\\n\\n            _setFees(_pairInformation.feesY, _feesYTotal, 1);\\n\\n            tokenY.safeTransfer(_feeRecipient, amountY);\\n        }\\n\\n        emit ProtocolFeesCollected(msg.sender, _feeRecipient, amountX, amountY);\\n    }\\n\\n    /// @notice Set the fees parameters\\n    /// @dev Needs to be called by the factory that will validate the values\\n    /// The bin step will not change\\n    /// Only callable by the factory\\n    /// @param _packedFeeParameters The packed fee parameters\\n    function setFeesParameters(bytes32 _packedFeeParameters) external override onlyFactory {\\n        _setFeesParameters(_packedFeeParameters);\\n    }\\n\\n    /// @notice Force the decaying of the references for volatility and index\\n    /// @dev Only callable by the factory\\n    function forceDecay() external override onlyFactory {\\n        _feeParameters.volatilityReference = uint24(\\n            (uint256(_feeParameters.reductionFactor) * _feeParameters.volatilityReference) / Constants.BASIS_POINT_MAX\\n        );\\n        _feeParameters.indexRef = _pairInformation.activeId;\\n    }\\n\\n    /** Internal Functions **/\\n\\n    /// @notice Cache the accrued fees for a user before any transfer, mint or burn of LB tokens.\\n    /// The tokens are not transferred to reduce the gas cost and to avoid reentrancy.\\n    /// @param _from The address of the sender of the tokens\\n    /// @param _to The address of the receiver of the tokens\\n    /// @param _id The id of the bin\\n    /// @param _amount The amount of LB tokens transferred\\n    function _beforeTokenTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _amount\\n    ) internal override(LBToken) {\\n        super._beforeTokenTransfer(_from, _to, _id, _amount);\\n\\n        if (_from != _to) {\\n            Bin memory _bin = _bins[_id];\\n            if (_from != address(0) && _from != address(this)) {\\n                uint256 _balanceFrom = balanceOf(_from, _id);\\n\\n                _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);\\n            }\\n\\n            if (_to != address(0) && _to != address(this)) {\\n                uint256 _balanceTo = balanceOf(_to, _id);\\n\\n                _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);\\n            }\\n        }\\n    }\\n\\n    /** Private Functions **/\\n\\n    /// @notice View function to get the pending fees of an account on a given bin\\n    /// @param _bin The bin data where the user is collecting fees\\n    /// @param _account The address of the user\\n    /// @param _id The id where the user is collecting fees\\n    /// @param _balance The previous balance of the user\\n    /// @return amountX The amount of token X not collected yet by `_account`\\n    /// @return amountY The amount of token Y not collected yet by `_account`\\n    function _getPendingFees(\\n        Bin memory _bin,\\n        address _account,\\n        uint256 _id,\\n        uint256 _balance\\n    ) private view returns (uint128 amountX, uint128 amountY) {\\n        Debts memory _debts = _accruedDebts[_account][_id];\\n\\n        amountX = (_bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX).safe128();\\n        amountY = (_bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY).safe128();\\n    }\\n\\n    /// @notice Update the user debts of a user on a given bin\\n    /// @param _bin The bin data where the user has collected fees\\n    /// @param _account The address of the user\\n    /// @param _id The id where the user has collected fees\\n    /// @param _balance The new balance of the user\\n    function _updateUserDebts(\\n        Bin memory _bin,\\n        address _account,\\n        uint256 _id,\\n        uint256 _balance\\n    ) private {\\n        uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\\n        uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);\\n\\n        _accruedDebts[_account][_id].debtX = _debtX;\\n        _accruedDebts[_account][_id].debtY = _debtY;\\n    }\\n\\n    /// @notice Cache the accrued fees for a user.\\n    /// @param _bin The bin data where the user is receiving LB tokens\\n    /// @param _user The address of the user\\n    /// @param _id The id where the user is receiving LB tokens\\n    /// @param _previousBalance The previous balance of the user\\n    /// @param _newBalance The new balance of the user\\n    function _cacheFees(\\n        Bin memory _bin,\\n        address _user,\\n        uint256 _id,\\n        uint256 _previousBalance,\\n        uint256 _newBalance\\n    ) private {\\n        bytes32 _unclaimedData = _unclaimedFees[_user];\\n\\n        uint128 amountX = uint128(_unclaimedData.decode(type(uint128).max, 0));\\n        uint128 amountY = uint128(_unclaimedData.decode(type(uint128).max, 128));\\n\\n        (uint128 _amountX, uint128 _amountY) = _getPendingFees(_bin, _user, _id, _previousBalance);\\n        _updateUserDebts(_bin, _user, _id, _newBalance);\\n\\n        amountX += _amountX;\\n        amountY += _amountY;\\n\\n        _unclaimedFees[_user] = bytes32(uint256((uint256(amountY) << 128) | amountX));\\n    }\\n\\n    /// @notice Set the fee parameters of the pair.\\n    /// @dev Only the first 112 bits can be set, as the last 144 bits are reserved for the variables parameters\\n    /// @param _packedFeeParameters The packed fee parameters\\n    function _setFeesParameters(bytes32 _packedFeeParameters) private {\\n        bytes32 _feeStorageSlot;\\n        assembly {\\n            _feeStorageSlot := sload(_feeParameters.slot)\\n        }\\n\\n        uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);\\n        uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\\n\\n        assembly {\\n            sstore(_feeParameters.slot, or(_newFeeParameters, shl(_OFFSET_VARIABLE_FEE_PARAMETERS, _varParameters)))\\n        }\\n    }\\n\\n    /// @notice Increases the length of the oracle to the given `_newSize` by adding empty samples to the end of the oracle.\\n    /// The samples are however initialized to reduce the gas cost of the updates during a swap.\\n    /// @param _newSize The new size of the oracle. Needs to be bigger than current one\\n    function _increaseOracle(uint16 _newSize) private {\\n        uint256 _oracleSize = _pairInformation.oracleSize;\\n\\n        if (_oracleSize >= _newSize) revert LBPair__OracleNewSizeTooSmall(_newSize, _oracleSize);\\n\\n        _pairInformation.oracleSize = _newSize;\\n\\n        // Iterate over the uninitialized oracle samples and initialize them\\n        for (uint256 _id = _oracleSize; _id < _newSize; ) {\\n            _oracle.initialize(_id);\\n\\n            unchecked {\\n                ++_id;\\n            }\\n        }\\n\\n        emit OracleSizeIncreased(_oracleSize, _newSize);\\n    }\\n\\n    /// @notice Return the oracle's parameters\\n    /// @return oracleSampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\\n    /// @return oracleSize The size of the oracle (last ids can be empty)\\n    /// @return oracleActiveSize The active size of the oracle (no empty data)\\n    /// @return oracleLastTimestamp The timestamp of the creation of the oracle's latest sample\\n    /// @return oracleId The index of the oracle's latest sample\\n    function _getOracleParameters()\\n        private\\n        view\\n        returns (\\n            uint256 oracleSampleLifetime,\\n            uint256 oracleSize,\\n            uint256 oracleActiveSize,\\n            uint256 oracleLastTimestamp,\\n            uint256 oracleId\\n        )\\n    {\\n        bytes32 _slot;\\n        assembly {\\n            _slot := sload(add(_pairInformation.slot, 1))\\n        }\\n        oracleSampleLifetime = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SAMPLE_LIFETIME);\\n        oracleSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_SIZE);\\n        oracleActiveSize = _slot.decode(type(uint16).max, _OFFSET_ORACLE_ACTIVE_SIZE);\\n        oracleLastTimestamp = _slot.decode(type(uint40).max, _OFFSET_ORACLE_LAST_TIMESTAMP);\\n        oracleId = _slot.decode(type(uint16).max, _OFFSET_ORACLE_ID);\\n    }\\n\\n    /// @notice Return the reserves and the active id of the pair\\n    /// @return reserveX The reserve of token X\\n    /// @return reserveY The reserve of token Y\\n    /// @return activeId The active id of the pair\\n    function _getReservesAndId()\\n        private\\n        view\\n        returns (\\n            uint256 reserveX,\\n            uint256 reserveY,\\n            uint256 activeId\\n        )\\n    {\\n        uint256 _mask24 = type(uint24).max;\\n        uint256 _mask136 = type(uint136).max;\\n        assembly {\\n            let slot := sload(add(_pairInformation.slot, 1))\\n            reserveY := and(slot, _mask136)\\n\\n            slot := sload(_pairInformation.slot)\\n            activeId := and(slot, _mask24)\\n            reserveX := and(shr(_OFFSET_PAIR_RESERVE_X, slot), _mask136)\\n        }\\n    }\\n\\n    /// @notice Return the reserves of the bin at index `_id`\\n    /// @param _id The id of the bin\\n    /// @return reserveX The reserve of token X in the bin\\n    /// @return reserveY The reserve of token Y in the bin\\n    function _getBin(uint24 _id) private view returns (uint256 reserveX, uint256 reserveY) {\\n        bytes32 _data;\\n        uint256 _mask112 = type(uint112).max;\\n        // low level read of mapping to only load 1 storage slot\\n        assembly {\\n            mstore(0, _id)\\n            mstore(32, _bins.slot)\\n            _data := sload(keccak256(0, 64))\\n\\n            reserveX := and(_data, _mask112)\\n            reserveY := shr(_OFFSET_BIN_RESERVE_Y, _data)\\n        }\\n\\n        return (reserveX.safe112(), reserveY.safe112());\\n    }\\n\\n    /// @notice Return the total fees and the protocol fees of the pair\\n    /// @dev The fees for users can be computed by subtracting the protocol fees from the total fees\\n    /// @return feesXTotal The total fees of token X\\n    /// @return feesYTotal The total fees of token Y\\n    /// @return feesXProtocol The protocol fees of token X\\n    /// @return feesYProtocol The protocol fees of token Y\\n    function _getGlobalFees()\\n        private\\n        view\\n        returns (\\n            uint128 feesXTotal,\\n            uint128 feesYTotal,\\n            uint128 feesXProtocol,\\n            uint128 feesYProtocol\\n        )\\n    {\\n        bytes32 _slotX;\\n        bytes32 _slotY;\\n        assembly {\\n            _slotX := sload(add(_pairInformation.slot, 2))\\n            _slotY := sload(add(_pairInformation.slot, 3))\\n        }\\n\\n        feesXTotal = uint128(_slotX.decode(type(uint128).max, 0));\\n        feesYTotal = uint128(_slotY.decode(type(uint128).max, 0));\\n\\n        feesXProtocol = uint128(_slotX.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE));\\n        feesYProtocol = uint128(_slotY.decode(type(uint128).max, _OFFSET_PROTOCOL_FEE));\\n    }\\n\\n    /// @notice Return the fee added to a flashloan\\n    /// @dev Rounds up the amount of fees\\n    /// @param _amount The amount of the flashloan\\n    /// @return The fee added to the flashloan\\n    function _getFlashLoanFee(uint256 _amount) private view returns (uint256) {\\n        uint256 _fee = factory.flashLoanFee();\\n        return (_amount * _fee + Constants.PRECISION - 1) / Constants.PRECISION;\\n    }\\n\\n    /// @notice Set the total and protocol fees\\n    /// @dev The assembly block does:\\n    /// _pairFees = FeeHelper.FeesDistribution({total: _totalFees, protocol: _protocolFees});\\n    /// @param _pairFees The storage slot of the fees\\n    /// @param _totalFees The new total fees\\n    /// @param _protocolFees The new protocol fees\\n    function _setFees(\\n        FeeHelper.FeesDistribution storage _pairFees,\\n        uint128 _totalFees,\\n        uint128 _protocolFees\\n    ) private {\\n        assembly {\\n            sstore(_pairFees.slot, or(shl(_OFFSET_PROTOCOL_FEE, _protocolFees), _totalFees))\\n        }\\n    }\\n\\n    /// @notice Emit the Swap event and avoid stack too deep error\\n    /// if `swapForY` is:\\n    /// - true: tokenIn is tokenX, and tokenOut is tokenY\\n    /// - false: tokenIn is tokenY, and tokenOut is tokenX\\n    /// @param _to The address of the recipient of the swap\\n    /// @param _swapForY Whether the `amountInToBin` is tokenX (true) or tokenY (false),\\n    /// and if `amountOutOfBin` is tokenY (true) or tokenX (false)\\n    /// @param _amountInToBin The amount of tokenIn sent by the user\\n    /// @param _amountOutOfBin The amount of tokenOut received by the user\\n    /// @param _volatilityAccumulated The volatility accumulated number\\n    /// @param _fees The amount of fees, always denominated in tokenIn\\n    function _emitSwap(\\n        address _to,\\n        uint24 _activeId,\\n        bool _swapForY,\\n        uint256 _amountInToBin,\\n        uint256 _amountOutOfBin,\\n        uint256 _volatilityAccumulated,\\n        uint256 _fees\\n    ) private {\\n        emit Swap(\\n            msg.sender,\\n            _to,\\n            _activeId,\\n            _swapForY,\\n            _amountInToBin,\\n            _amountOutOfBin,\\n            _volatilityAccumulated,\\n            _fees\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/LBToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"openzeppelin/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"./LBErrors.sol\\\";\\nimport \\\"./interfaces/ILBToken.sol\\\";\\n\\n/// @title Liquidity Book Token\\n/// @author Trader Joe\\n/// @notice The LBToken is an implementation of a multi-token.\\n/// It allows to create multi-ERC20 represented by their ids\\ncontract LBToken is ILBToken {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /// @dev Mapping from token id to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    /// @dev Mapping from account to spender approvals\\n    mapping(address => mapping(address => bool)) private _spenderApprovals;\\n\\n    /// @dev Mapping from token id to total supplies\\n    mapping(uint256 => uint256) private _totalSupplies;\\n\\n    string private constant _NAME = \\\"Liquidity Book Token\\\";\\n    string private constant _SYMBOL = \\\"LBT\\\";\\n\\n    modifier checkApproval(address _from, address _spender) {\\n        if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender);\\n        _;\\n    }\\n\\n    modifier checkAddresses(address _from, address _to) {\\n        if (_from == address(0) || _to == address(0)) revert LBToken__TransferFromOrToAddress0();\\n        if (_from == _to) revert LBToken__TransferToSelf();\\n        _;\\n    }\\n\\n    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {\\n        if (_lengthA != _lengthB) revert LBToken__LengthMismatch(_lengthA, _lengthB);\\n        _;\\n    }\\n\\n    /// @notice Returns the name of the token\\n    /// @return The name of the token\\n    function name() public pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    /// @notice Returns the symbol of the token, usually a shorter version of the name\\n    /// @return The symbol of the token\\n    function symbol() public pure virtual override returns (string memory) {\\n        return _SYMBOL;\\n    }\\n\\n    /// @notice Returns the total supply of token of type `id`\\n    /// @dev This is the amount of token of type `id` minted minus the amount burned\\n    /// @param _id The token id\\n    /// @return The total supply of that token id\\n    function totalSupply(uint256 _id) public view virtual override returns (uint256) {\\n        return _totalSupplies[_id];\\n    }\\n\\n    /// @notice Returns the amount of tokens of type `id` owned by `_account`\\n    /// @param _account The address of the owner\\n    /// @param _id The token id\\n    /// @return The amount of tokens of type `id` owned by `_account`\\n    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {\\n        return _balances[_id][_account];\\n    }\\n\\n    /// @notice Return the balance of multiple (account/id) pairs\\n    /// @param _accounts The addresses of the owners\\n    /// @param _ids The token ids\\n    /// @return batchBalances The balance for each (account, id) pair\\n    function balanceOfBatch(address[] calldata _accounts, uint256[] calldata _ids)\\n        public\\n        view\\n        virtual\\n        override\\n        checkLength(_accounts.length, _ids.length)\\n        returns (uint256[] memory batchBalances)\\n    {\\n        batchBalances = new uint256[](_accounts.length);\\n\\n        unchecked {\\n            for (uint256 i; i < _accounts.length; ++i) {\\n                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens\\n    /// @param _owner The address of the owner\\n    /// @param _spender The address of the spender\\n    /// @return True if `spender` is approved to transfer `_account`'s tokens\\n    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {\\n        return _isApprovedForAll(_owner, _spender);\\n    }\\n\\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\\n    /// @param _spender The address of the spender\\n    /// @param _approved The boolean value to grant or revoke permission\\n    function setApprovalForAll(address _spender, bool _approved) public virtual override {\\n        _setApprovalForAll(msg.sender, _spender, _approved);\\n    }\\n\\n    /// @notice Transfers `_amount` token of type `_id` from `_from` to `_to`\\n    /// @param _from The address of the owner of the token\\n    /// @param _to The address of the recipient\\n    /// @param _id The token id\\n    /// @param _amount The amount to send\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _amount\\n    ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) {\\n        address _spender = msg.sender;\\n\\n        _transfer(_from, _to, _id, _amount);\\n\\n        emit TransferSingle(_spender, _from, _to, _id, _amount);\\n    }\\n\\n    /// @notice Batch transfers `_amount` tokens of type `_id` from `_from` to `_to`\\n    /// @param _from The address of the owner of the tokens\\n    /// @param _to The address of the recipient\\n    /// @param _ids The list of token ids\\n    /// @param _amounts The list of amounts to send\\n    function safeBatchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _amounts\\n    )\\n        public\\n        virtual\\n        override\\n        checkLength(_ids.length, _amounts.length)\\n        checkAddresses(_from, _to)\\n        checkApproval(_from, msg.sender)\\n    {\\n        unchecked {\\n            for (uint256 i; i < _ids.length; ++i) {\\n                _transfer(_from, _to, _ids[i], _amounts[i]);\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\\n    }\\n\\n    /// @notice Returns whether this contract implements the interface defined by\\n    /// `interfaceId` (true) or not (false)\\n    /// @param _interfaceId The interface identifier\\n    /// @return Whether the interface is supported (true) or not (false)\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n        return _interfaceId == type(ILBToken).interfaceId || _interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /// @notice Internal function to transfer `_amount` tokens of type `_id` from `_from` to `_to`\\n    /// @param _from The address of the owner of the token\\n    /// @param _to The address of the recipient\\n    /// @param _id The token id\\n    /// @param _amount The amount to send\\n    function _transfer(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _amount\\n    ) internal virtual {\\n        uint256 _fromBalance = _balances[_id][_from];\\n        if (_fromBalance < _amount) revert LBToken__TransferExceedsBalance(_from, _id, _amount);\\n\\n        _beforeTokenTransfer(_from, _to, _id, _amount);\\n\\n        unchecked {\\n            _balances[_id][_from] = _fromBalance - _amount;\\n            _balances[_id][_to] += _amount;\\n        }\\n    }\\n\\n    /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account`\\n    /// @param _account The address of the recipient\\n    /// @param _id The token id\\n    /// @param _amount The amount to mint\\n    function _mint(\\n        address _account,\\n        uint256 _id,\\n        uint256 _amount\\n    ) internal virtual {\\n        if (_account == address(0)) revert LBToken__MintToAddress0();\\n\\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\\n\\n        _totalSupplies[_id] += _amount;\\n\\n        unchecked {\\n            _balances[_id][_account] += _amount;\\n        }\\n\\n        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);\\n    }\\n\\n    /// @dev Destroys `_amount` tokens of type `_id` from `_account`\\n    /// @param _account The address of the owner\\n    /// @param _id The token id\\n    /// @param _amount The amount to destroy\\n    function _burn(\\n        address _account,\\n        uint256 _id,\\n        uint256 _amount\\n    ) internal virtual {\\n        if (_account == address(0)) revert LBToken__BurnFromAddress0();\\n\\n        uint256 _accountBalance = _balances[_id][_account];\\n        if (_accountBalance < _amount) revert LBToken__BurnExceedsBalance(_account, _id, _amount);\\n\\n        _beforeTokenTransfer(_account, address(0), _id, _amount);\\n\\n        unchecked {\\n            _balances[_id][_account] = _accountBalance - _amount;\\n            _totalSupplies[_id] -= _amount;\\n        }\\n\\n        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);\\n    }\\n\\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\\n    /// @param _owner The address of the owner\\n    /// @param _spender The address of the spender\\n    /// @param _approved The boolean value to grant or revoke permission\\n    function _setApprovalForAll(\\n        address _owner,\\n        address _spender,\\n        bool _approved\\n    ) internal virtual {\\n        if (_owner == _spender) revert LBToken__SelfApproval(_owner);\\n\\n        _spenderApprovals[_owner][_spender] = _approved;\\n        emit ApprovalForAll(_owner, _spender, _approved);\\n    }\\n\\n    /// @notice Returns true if `spender` is approved to transfer `owner`'s tokens\\n    /// or if `sender` is the `owner`\\n    /// @param _owner The address of the owner\\n    /// @param _spender The address of the spender\\n    /// @return True if `spender` is approved to transfer `owner`'s tokens\\n    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {\\n        return _owner == _spender || _spenderApprovals[_owner][_spender];\\n    }\\n\\n    /// @notice Hook that is called before any token transfer. This includes minting\\n    /// and burning.\\n    ///\\n    /// Calling conditions (for each `id` and `amount` pair):\\n    ///\\n    /// - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n    /// of token type `id` will be  transferred to `to`.\\n    /// - When `from` is zero, `amount` tokens of token type `id` will be minted\\n    /// for `to`.\\n    /// - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n    /// will be burned.\\n    /// - `from` and `to` are never both zero.\\n    /// @param from The address of the owner of the token\\n    /// @param to The address of the recipient of the  token\\n    /// @param id The id of the token\\n    /// @param amount The amount of token of type `id`\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./ILBPair.sol\\\";\\nimport \\\"./IPendingOwnable.sol\\\";\\n\\n/// @title Liquidity Book Factory Interface\\n/// @author Trader Joe\\n/// @notice Required interface of LBFactory contract\\ninterface ILBFactory is IPendingOwnable {\\n    /// @dev Structure to store the LBPair information, such as:\\n    /// - binStep: The bin step of the LBPair\\n    /// - LBPair: The address of the LBPair\\n    /// - createdByOwner: Whether the pair was created by the owner of the factory\\n    /// - ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\\n    struct LBPairInformation {\\n        uint16 binStep;\\n        ILBPair LBPair;\\n        bool createdByOwner;\\n        bool ignoredForRouting;\\n    }\\n\\n    event LBPairCreated(\\n        IERC20 indexed tokenX,\\n        IERC20 indexed tokenY,\\n        uint256 indexed binStep,\\n        ILBPair LBPair,\\n        uint256 pid\\n    );\\n\\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\\n\\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\\n\\n    event FeeParametersSet(\\n        address indexed sender,\\n        ILBPair indexed LBPair,\\n        uint256 binStep,\\n        uint256 baseFactor,\\n        uint256 filterPeriod,\\n        uint256 decayPeriod,\\n        uint256 reductionFactor,\\n        uint256 variableFeeControl,\\n        uint256 protocolShare,\\n        uint256 maxVolatilityAccumulated\\n    );\\n\\n    event FactoryLockedStatusUpdated(bool unlocked);\\n\\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\\n\\n    event LBPairIgnoredStateChanged(ILBPair indexed LBPair, bool ignored);\\n\\n    event PresetSet(\\n        uint256 indexed binStep,\\n        uint256 baseFactor,\\n        uint256 filterPeriod,\\n        uint256 decayPeriod,\\n        uint256 reductionFactor,\\n        uint256 variableFeeControl,\\n        uint256 protocolShare,\\n        uint256 maxVolatilityAccumulated,\\n        uint256 sampleLifetime\\n    );\\n\\n    event PresetRemoved(uint256 indexed binStep);\\n\\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\\n\\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\\n\\n    function MAX_FEE() external pure returns (uint256);\\n\\n    function MIN_BIN_STEP() external pure returns (uint256);\\n\\n    function MAX_BIN_STEP() external pure returns (uint256);\\n\\n    function MAX_PROTOCOL_SHARE() external pure returns (uint256);\\n\\n    function LBPairImplementation() external view returns (address);\\n\\n    function getNumberOfQuoteAssets() external view returns (uint256);\\n\\n    function getQuoteAsset(uint256 index) external view returns (IERC20);\\n\\n    function isQuoteAsset(IERC20 token) external view returns (bool);\\n\\n    function feeRecipient() external view returns (address);\\n\\n    function flashLoanFee() external view returns (uint256);\\n\\n    function creationUnlocked() external view returns (bool);\\n\\n    function allLBPairs(uint256 id) external returns (ILBPair);\\n\\n    function getNumberOfLBPairs() external view returns (uint256);\\n\\n    function getLBPairInformation(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint256 binStep\\n    ) external view returns (LBPairInformation memory);\\n\\n    function getPreset(uint16 binStep)\\n        external\\n        view\\n        returns (\\n            uint256 baseFactor,\\n            uint256 filterPeriod,\\n            uint256 decayPeriod,\\n            uint256 reductionFactor,\\n            uint256 variableFeeControl,\\n            uint256 protocolShare,\\n            uint256 maxAccumulator,\\n            uint256 sampleLifetime\\n        );\\n\\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\\n\\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\\n        external\\n        view\\n        returns (LBPairInformation[] memory LBPairsBinStep);\\n\\n    function setLBPairImplementation(address LBPairImplementation) external;\\n\\n    function createLBPair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint24 activeId,\\n        uint16 binStep\\n    ) external returns (ILBPair pair);\\n\\n    function setLBPairIgnored(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint256 binStep,\\n        bool ignored\\n    ) external;\\n\\n    function setPreset(\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulated,\\n        uint16 sampleLifetime\\n    ) external;\\n\\n    function removePreset(uint16 binStep) external;\\n\\n    function setFeesParametersOnPair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulated\\n    ) external;\\n\\n    function setFeeRecipient(address feeRecipient) external;\\n\\n    function setFlashLoanFee(uint256 flashLoanFee) external;\\n\\n    function setFactoryLockedState(bool locked) external;\\n\\n    function addQuoteAsset(IERC20 quoteAsset) external;\\n\\n    function removeQuoteAsset(IERC20 quoteAsset) external;\\n\\n    function forceDecay(ILBPair LBPair) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBFlashLoanCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Liquidity Book Flashloan Callback Interface\\n/// @author Trader Joe\\n/// @notice Required interface to interact with LB flash loans\\ninterface ILBFlashLoanCallback {\\n    function LBFlashLoanCallback(\\n        address sender,\\n        IERC20 token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../libraries/FeeHelper.sol\\\";\\nimport \\\"./ILBFactory.sol\\\";\\nimport \\\"./ILBFlashLoanCallback.sol\\\";\\n\\n/// @title Liquidity Book Pair Interface\\n/// @author Trader Joe\\n/// @notice Required interface of LBPair contract\\ninterface ILBPair {\\n    /// @dev Structure to store the reserves of bins:\\n    /// - reserveX: The current reserve of tokenX of the bin\\n    /// - reserveY: The current reserve of tokenY of the bin\\n    struct Bin {\\n        uint112 reserveX;\\n        uint112 reserveY;\\n        uint256 accTokenXPerShare;\\n        uint256 accTokenYPerShare;\\n    }\\n\\n    /// @dev Structure to store the information of the pair such as:\\n    /// slot0:\\n    /// - activeId: The current id used for swaps, this is also linked with the price\\n    /// - reserveX: The sum of amounts of tokenX across all bins\\n    /// slot1:\\n    /// - reserveY: The sum of amounts of tokenY across all bins\\n    /// - oracleSampleLifetime: The lifetime of an oracle sample\\n    /// - oracleSize: The current size of the oracle, can be increase by users\\n    /// - oracleActiveSize: The current active size of the oracle, composed only from non empty data sample\\n    /// - oracleLastTimestamp: The current last timestamp at which a sample was added to the circular buffer\\n    /// - oracleId: The current id of the oracle\\n    /// slot2:\\n    /// - feesX: The current amount of fees to distribute in tokenX (total, protocol)\\n    /// slot3:\\n    /// - feesY: The current amount of fees to distribute in tokenY (total, protocol)\\n    struct PairInformation {\\n        uint24 activeId;\\n        uint136 reserveX;\\n        uint136 reserveY;\\n        uint16 oracleSampleLifetime;\\n        uint16 oracleSize;\\n        uint16 oracleActiveSize;\\n        uint40 oracleLastTimestamp;\\n        uint16 oracleId;\\n        FeeHelper.FeesDistribution feesX;\\n        FeeHelper.FeesDistribution feesY;\\n    }\\n\\n    /// @dev Structure to store the debts of users\\n    /// - debtX: The tokenX's debt\\n    /// - debtY: The tokenY's debt\\n    struct Debts {\\n        uint256 debtX;\\n        uint256 debtY;\\n    }\\n\\n    /// @dev Structure to store fees:\\n    /// - tokenX: The amount of fees of token X\\n    /// - tokenY: The amount of fees of token Y\\n    struct Fees {\\n        uint128 tokenX;\\n        uint128 tokenY;\\n    }\\n\\n    /// @dev Structure to minting informations:\\n    /// - amountXIn: The amount of token X sent\\n    /// - amountYIn: The amount of token Y sent\\n    /// - amountXAddedToPair: The amount of token X that have been actually added to the pair\\n    /// - amountYAddedToPair: The amount of token Y that have been actually added to the pair\\n    /// - activeFeeX: Fees X currently generated\\n    /// - activeFeeY: Fees Y currently generated\\n    /// - totalDistributionX: Total distribution of token X. Should be 1e18 (100%) or 0 (0%)\\n    /// - totalDistributionY: Total distribution of token Y. Should be 1e18 (100%) or 0 (0%)\\n    /// - id: Id of the current working bin when looping on the distribution array\\n    /// - amountX: The amount of token X deposited in the current bin\\n    /// - amountY: The amount of token Y deposited in the current bin\\n    /// - distributionX: Distribution of token X for the current working bin\\n    /// - distributionY: Distribution of token Y for the current working bin\\n    struct MintInfo {\\n        uint256 amountXIn;\\n        uint256 amountYIn;\\n        uint256 amountXAddedToPair;\\n        uint256 amountYAddedToPair;\\n        uint256 activeFeeX;\\n        uint256 activeFeeY;\\n        uint256 totalDistributionX;\\n        uint256 totalDistributionY;\\n        uint256 id;\\n        uint256 amountX;\\n        uint256 amountY;\\n        uint256 distributionX;\\n        uint256 distributionY;\\n    }\\n\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 indexed id,\\n        bool swapForY,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        uint256 volatilityAccumulated,\\n        uint256 fees\\n    );\\n\\n    event FlashLoan(\\n        address indexed sender,\\n        ILBFlashLoanCallback indexed receiver,\\n        IERC20 token,\\n        uint256 amount,\\n        uint256 fee\\n    );\\n\\n    event CompositionFee(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 indexed id,\\n        uint256 feesX,\\n        uint256 feesY\\n    );\\n\\n    event DepositedToBin(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 indexed id,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    event WithdrawnFromBin(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 indexed id,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    event FeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\\n\\n    event ProtocolFeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\\n\\n    event OracleSizeIncreased(uint256 previousSize, uint256 newSize);\\n\\n    function tokenX() external view returns (IERC20);\\n\\n    function tokenY() external view returns (IERC20);\\n\\n    function factory() external view returns (ILBFactory);\\n\\n    function getReservesAndId()\\n        external\\n        view\\n        returns (\\n            uint256 reserveX,\\n            uint256 reserveY,\\n            uint256 activeId\\n        );\\n\\n    function getGlobalFees()\\n        external\\n        view\\n        returns (\\n            uint128 feesXTotal,\\n            uint128 feesYTotal,\\n            uint128 feesXProtocol,\\n            uint128 feesYProtocol\\n        );\\n\\n    function getOracleParameters()\\n        external\\n        view\\n        returns (\\n            uint256 oracleSampleLifetime,\\n            uint256 oracleSize,\\n            uint256 oracleActiveSize,\\n            uint256 oracleLastTimestamp,\\n            uint256 oracleId,\\n            uint256 min,\\n            uint256 max\\n        );\\n\\n    function getOracleSampleFrom(uint256 timeDelta)\\n        external\\n        view\\n        returns (\\n            uint256 cumulativeId,\\n            uint256 cumulativeAccumulator,\\n            uint256 cumulativeBinCrossed\\n        );\\n\\n    function feeParameters() external view returns (FeeHelper.FeeParameters memory);\\n\\n    function findFirstNonEmptyBinId(uint24 id_, bool sentTokenY) external view returns (uint24 id);\\n\\n    function getBin(uint24 id) external view returns (uint256 reserveX, uint256 reserveY);\\n\\n    function pendingFees(address account, uint256[] memory ids)\\n        external\\n        view\\n        returns (uint256 amountX, uint256 amountY);\\n\\n    function swap(bool sentTokenY, address to) external returns (uint256 amountXOut, uint256 amountYOut);\\n\\n    function flashLoan(\\n        ILBFlashLoanCallback receiver,\\n        IERC20 token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function mint(\\n        uint256[] calldata ids,\\n        uint256[] calldata distributionX,\\n        uint256[] calldata distributionY,\\n        address to\\n    )\\n        external\\n        returns (\\n            uint256 amountXAddedToPair,\\n            uint256 amountYAddedToPair,\\n            uint256[] memory liquidityMinted\\n        );\\n\\n    function burn(\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        address to\\n    ) external returns (uint256 amountX, uint256 amountY);\\n\\n    function increaseOracleLength(uint16 newSize) external;\\n\\n    function collectFees(address account, uint256[] calldata ids) external returns (uint256 amountX, uint256 amountY);\\n\\n    function collectProtocolFees() external returns (uint128 amountX, uint128 amountY);\\n\\n    function setFeesParameters(bytes32 packedFeeParameters) external;\\n\\n    function forceDecay() external;\\n\\n    function initialize(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint24 activeId,\\n        uint16 sampleLifetime,\\n        bytes32 packedFeeParameters\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILBToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"openzeppelin/utils/introspection/IERC165.sol\\\";\\n\\n/// @title Liquidity Book Token Interface\\n/// @author Trader Joe\\n/// @notice Required interface of LBToken contract\\ninterface ILBToken is IERC165 {\\n    event TransferSingle(address indexed sender, address indexed from, address indexed to, uint256 id, uint256 amount);\\n\\n    event TransferBatch(\\n        address indexed sender,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory batchBalances);\\n\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\\n\\n    function setApprovalForAll(address sender, bool approved) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata id,\\n        uint256[] calldata amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPendingOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @title Liquidity Book Pending Ownable Interface\\n/// @author Trader Joe\\n/// @notice Required interface of Pending Ownable contract used for LBFactory\\ninterface IPendingOwnable {\\n    event PendingOwnerSet(address indexed pendingOwner);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function setPendingOwner(address pendingOwner) external;\\n\\n    function revokePendingOwner() external;\\n\\n    function becomeOwner() external;\\n\\n    function renounceOwnership() external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/BinHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\nimport \\\"./Math128x128.sol\\\";\\n\\n/// @title Liquidity Book Bin Helper Library\\n/// @author Trader Joe\\n/// @notice Contract used to convert bin ID to price and back\\nlibrary BinHelper {\\n    using Math128x128 for uint256;\\n\\n    int256 private constant REAL_ID_SHIFT = 1 << 23;\\n\\n    /// @notice Returns the id corresponding to the given price\\n    /// @dev The id may be inaccurate due to rounding issues, always trust getPriceFromId rather than\\n    /// getIdFromPrice\\n    /// @param _price The price of y per x as a 128.128-binary fixed-point number\\n    /// @param _binStep The bin step\\n    /// @return The id corresponding to this price\\n    function getIdFromPrice(uint256 _price, uint256 _binStep) internal pure returns (uint24) {\\n        unchecked {\\n            uint256 _binStepValue = _getBPValue(_binStep);\\n\\n            // can't overflow as `2**23 + log2(price) < 2**23 + 2**128 < max(uint256)`\\n            int256 _id = REAL_ID_SHIFT + _price.log2() / _binStepValue.log2();\\n\\n            if (_id < 0 || uint256(_id) > type(uint24).max) revert BinHelper__IdOverflows();\\n            return uint24(uint256(_id));\\n        }\\n    }\\n\\n    /// @notice Returns the price corresponding to the given ID, as a 128.128-binary fixed-point number\\n    /// @dev This is the trusted function to link id to price, the other way may be inaccurate\\n    /// @param _id The id\\n    /// @param _binStep The bin step\\n    /// @return The price corresponding to this id, as a 128.128-binary fixed-point number\\n    function getPriceFromId(uint256 _id, uint256 _binStep) internal pure returns (uint256) {\\n        if (_id > uint256(type(uint24).max)) revert BinHelper__IdOverflows();\\n        unchecked {\\n            int256 _realId = int256(_id) - REAL_ID_SHIFT;\\n\\n            return _getBPValue(_binStep).power(_realId);\\n        }\\n    }\\n\\n    /// @notice Returns the (1 + bp) value as a 128.128-decimal fixed-point number\\n    /// @param _binStep The bp value in [1; 100] (referring to 0.01% to 1%)\\n    /// @return The (1+bp) value as a 128.128-decimal fixed-point number\\n    function _getBPValue(uint256 _binStep) internal pure returns (uint256) {\\n        if (_binStep == 0 || _binStep > Constants.BASIS_POINT_MAX) revert BinHelper__BinStepOverflows(_binStep);\\n\\n        unchecked {\\n            // can't overflow as `max(result) = 2**128 + 10_000 << 128 / 10_000 < max(uint256)`\\n            return Constants.SCALE + (_binStep << Constants.SCALE_OFFSET) / Constants.BASIS_POINT_MAX;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/BitMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @title Liquidity Book Bit Math Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for bit calculations\\nlibrary BitMath {\\n    /// @notice Returns the closest non-zero bit of `integer` to the right (of left) of the `bit` bits that is not `bit`\\n    /// @param _integer The integer as a uint256\\n    /// @param _bit The bit index\\n    /// @param _rightSide Whether we're searching in the right side of the tree (true) or the left side (false)\\n    /// @return The index of the closest non-zero bit. If there is no closest bit, it returns max(uint256)\\n    function closestBit(\\n        uint256 _integer,\\n        uint8 _bit,\\n        bool _rightSide\\n    ) internal pure returns (uint256) {\\n        return _rightSide ? closestBitRight(_integer, _bit - 1) : closestBitLeft(_integer, _bit + 1);\\n    }\\n\\n    /// @notice Returns the most (or least) significant bit of `_integer`\\n    /// @param _integer The integer\\n    /// @param _isMostSignificant Whether we want the most (true) or the least (false) significant bit\\n    /// @return The index of the most (or least) significant bit\\n    function significantBit(uint256 _integer, bool _isMostSignificant) internal pure returns (uint8) {\\n        return _isMostSignificant ? mostSignificantBit(_integer) : leastSignificantBit(_integer);\\n    }\\n\\n    /// @notice Returns the index of the closest bit on the right of x that is non null\\n    /// @param x The value as a uint256\\n    /// @param bit The index of the bit to start searching at\\n    /// @return id The index of the closest non null bit on the right of x.\\n    /// If there is no closest bit, it returns max(uint256)\\n    function closestBitRight(uint256 x, uint8 bit) internal pure returns (uint256 id) {\\n        unchecked {\\n            uint256 _shift = 255 - bit;\\n            x <<= _shift;\\n\\n            // can't overflow as it's non-zero and we shifted it by `_shift`\\n            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - _shift;\\n        }\\n    }\\n\\n    /// @notice Returns the index of the closest bit on the left of x that is non null\\n    /// @param x The value as a uint256\\n    /// @param bit The index of the bit to start searching at\\n    /// @return id The index of the closest non null bit on the left of x.\\n    /// If there is no closest bit, it returns max(uint256)\\n    function closestBitLeft(uint256 x, uint8 bit) internal pure returns (uint256 id) {\\n        unchecked {\\n            x >>= bit;\\n\\n            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;\\n        }\\n    }\\n\\n    /// @notice Returns the index of the most significant bit of x\\n    /// @param x The value as a uint256\\n    /// @return msb The index of the most significant bit of x\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 msb) {\\n        unchecked {\\n            if (x >= 1 << 128) {\\n                x >>= 128;\\n                msb = 128;\\n            }\\n            if (x >= 1 << 64) {\\n                x >>= 64;\\n                msb += 64;\\n            }\\n            if (x >= 1 << 32) {\\n                x >>= 32;\\n                msb += 32;\\n            }\\n            if (x >= 1 << 16) {\\n                x >>= 16;\\n                msb += 16;\\n            }\\n            if (x >= 1 << 8) {\\n                x >>= 8;\\n                msb += 8;\\n            }\\n            if (x >= 1 << 4) {\\n                x >>= 4;\\n                msb += 4;\\n            }\\n            if (x >= 1 << 2) {\\n                x >>= 2;\\n                msb += 2;\\n            }\\n            if (x >= 1 << 1) {\\n                msb += 1;\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns the index of the least significant bit of x\\n    /// @param x The value as a uint256\\n    /// @return lsb The index of the least significant bit of x\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 lsb) {\\n        unchecked {\\n            if (x << 128 != 0) {\\n                x <<= 128;\\n                lsb = 128;\\n            }\\n            if (x << 64 != 0) {\\n                x <<= 64;\\n                lsb += 64;\\n            }\\n            if (x << 32 != 0) {\\n                x <<= 32;\\n                lsb += 32;\\n            }\\n            if (x << 16 != 0) {\\n                x <<= 16;\\n                lsb += 16;\\n            }\\n            if (x << 8 != 0) {\\n                x <<= 8;\\n                lsb += 8;\\n            }\\n            if (x << 4 != 0) {\\n                x <<= 4;\\n                lsb += 4;\\n            }\\n            if (x << 2 != 0) {\\n                x <<= 2;\\n                lsb += 2;\\n            }\\n            if (x << 1 != 0) {\\n                lsb += 1;\\n            }\\n\\n            return 255 - lsb;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Buffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @title Liquidity Book Buffer Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for modulo calculation\\nlibrary Buffer {\\n    /// @notice Internal function to do positive (x - 1) % n\\n    /// @param x The value\\n    /// @param n The modulo value\\n    /// @return result The result\\n    function before(uint256 x, uint256 n) internal pure returns (uint256 result) {\\n        assembly {\\n            if gt(n, 0) {\\n                switch x\\n                case 0 {\\n                    result := sub(n, 1)\\n                }\\n                default {\\n                    result := mod(sub(x, 1), n)\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @title Liquidity Book Constants Library\\n/// @author Trader Joe\\n/// @notice Set of constants for Liquidity Book contracts\\nlibrary Constants {\\n    uint256 internal constant SCALE_OFFSET = 128;\\n    uint256 internal constant SCALE = 1 << SCALE_OFFSET;\\n\\n    uint256 internal constant PRECISION = 1e18;\\n    uint256 internal constant BASIS_POINT_MAX = 10_000;\\n\\n    /// @dev The expected return after a successful flash loan\\n    bytes32 internal constant CALLBACK_SUCCESS = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n}\\n\"\r\n    },\r\n    \"src/libraries/Decoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @title Liquidity Book Decoder Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for decoding bytes32 sample\\nlibrary Decoder {\\n    /// @notice Internal function to decode a bytes32 sample using a mask and offset\\n    /// @dev This function can overflow\\n    /// @param _sample The sample as a bytes32\\n    /// @param _mask The mask\\n    /// @param _offset The offset\\n    /// @return value The decoded value\\n    function decode(\\n        bytes32 _sample,\\n        uint256 _mask,\\n        uint256 _offset\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := and(shr(_offset, _sample), _mask)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Encoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @title Liquidity Book Encoder Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for encoding uint256 value\\nlibrary Encoder {\\n    /// @notice Internal function to encode a uint256 value using a mask and offset\\n    /// @dev This function can underflow\\n    /// @param _value The value as a uint256\\n    /// @param _mask The mask\\n    /// @param _offset The offset\\n    /// @return sample The encoded bytes32 sample\\n    function encode(\\n        uint256 _value,\\n        uint256 _mask,\\n        uint256 _offset\\n    ) internal pure returns (bytes32 sample) {\\n        assembly {\\n            sample := shl(_offset, and(_value, _mask))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/FeeDistributionHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./FeeHelper.sol\\\";\\n\\n/// @title Liquidity Book Fee Distribution Helper Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for fees distribution calculations\\nlibrary FeeDistributionHelper {\\n    /// @notice Calculate the tokenPerShare when fees are added\\n    /// @param _fees The fees received by the pair\\n    /// @param _totalSupply the total supply of a specific bin\\n    function getTokenPerShare(FeeHelper.FeesDistribution memory _fees, uint256 _totalSupply)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            // This can't overflow as `totalFees >= protocolFees`,\\n            // shift can't overflow as we shift fees that are a uint128, by 128 bits.\\n            // The result will always be smaller than max(uint256)\\n            return ((uint256(_fees.total) - _fees.protocol) << Constants.SCALE_OFFSET) / _totalSupply;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/FeeHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/// @title Liquidity Book Fee Helper Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for fees calculation\\nlibrary FeeHelper {\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n\\n    /// @dev Structure to store the protocol fees:\\n    /// - binStep: The bin step\\n    /// - baseFactor: The base factor\\n    /// - filterPeriod: The filter period, where the fees stays constant\\n    /// - decayPeriod: The decay period, where the fees are halved\\n    /// - reductionFactor: The reduction factor, used to calculate the reduction of the accumulator\\n    /// - variableFeeControl: The variable fee control, used to control the variable fee, can be 0 to disable them\\n    /// - protocolShare: The share of fees sent to protocol\\n    /// - maxVolatilityAccumulated: The max value of volatility accumulated\\n    /// - volatilityAccumulated: The value of volatility accumulated\\n    /// - volatilityReference: The value of volatility reference\\n    /// - indexRef: The index reference\\n    /// - time: The last time the accumulator was called\\n    struct FeeParameters {\\n        // 144 lowest bits in slot\\n        uint16 binStep;\\n        uint16 baseFactor;\\n        uint16 filterPeriod;\\n        uint16 decayPeriod;\\n        uint16 reductionFactor;\\n        uint24 variableFeeControl;\\n        uint16 protocolShare;\\n        uint24 maxVolatilityAccumulated;\\n        // 112 highest bits in slot\\n        uint24 volatilityAccumulated;\\n        uint24 volatilityReference;\\n        uint24 indexRef;\\n        uint40 time;\\n    }\\n\\n    /// @dev Structure used during swaps to distributes the fees:\\n    /// - total: The total amount of fees\\n    /// - protocol: The amount of fees reserved for protocol\\n    struct FeesDistribution {\\n        uint128 total;\\n        uint128 protocol;\\n    }\\n\\n    /// @notice Update the value of the volatility accumulated\\n    /// @param _fp The current fee parameters\\n    /// @param _activeId The current active id\\n    function updateVariableFeeParameters(FeeParameters memory _fp, uint256 _activeId) internal view {\\n        uint256 _deltaT = block.timestamp - _fp.time;\\n\\n        if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {\\n            _fp.indexRef = uint24(_activeId);\\n            if (_deltaT < _fp.decayPeriod) {\\n                unchecked {\\n                    // This can't overflow as `reductionFactor <= BASIS_POINT_MAX`\\n                    _fp.volatilityReference = uint24(\\n                        (uint256(_fp.reductionFactor) * _fp.volatilityAccumulated) / Constants.BASIS_POINT_MAX\\n                    );\\n                }\\n            } else {\\n                _fp.volatilityReference = 0;\\n            }\\n        }\\n\\n        _fp.time = (block.timestamp).safe40();\\n\\n        updateVolatilityAccumulated(_fp, _activeId);\\n    }\\n\\n    /// @notice Update the volatility accumulated\\n    /// @param _fp The fee parameter\\n    /// @param _activeId The current active id\\n    function updateVolatilityAccumulated(FeeParameters memory _fp, uint256 _activeId) internal pure {\\n        uint256 volatilityAccumulated = (_activeId.absSub(_fp.indexRef) * Constants.BASIS_POINT_MAX) +\\n            _fp.volatilityReference;\\n        _fp.volatilityAccumulated = volatilityAccumulated > _fp.maxVolatilityAccumulated\\n            ? _fp.maxVolatilityAccumulated\\n            : uint24(volatilityAccumulated);\\n    }\\n\\n    /// @notice Returns the base fee added to a swap, with 18 decimals\\n    /// @param _fp The current fee parameters\\n    /// @return The fee with 18 decimals precision\\n    function getBaseFee(FeeParameters memory _fp) internal pure returns (uint256) {\\n        unchecked {\\n            return uint256(_fp.baseFactor) * _fp.binStep * 1e10;\\n        }\\n    }\\n\\n    /// @notice Returns the variable fee added to a swap, with 18 decimals\\n    /// @param _fp The current fee parameters\\n    /// @return variableFee The variable fee with 18 decimals precision\\n    function getVariableFee(FeeParameters memory _fp) internal pure returns (uint256 variableFee) {\\n        if (_fp.variableFeeControl != 0) {\\n            // Can't overflow as the max value is `max(uint24) * (max(uint24) * max(uint16)) ** 2 < max(uint104)`\\n            // It returns 18 decimals as:\\n            // decimals(variableFeeControl * (volatilityAccumulated * binStep)**2 / 100) = 4 + (4 + 4) * 2 - 2 = 18\\n            unchecked {\\n                uint256 _prod = uint256(_fp.volatilityAccumulated) * _fp.binStep;\\n                variableFee = (_prod * _prod * _fp.variableFeeControl + 99) / 100;\\n            }\\n        }\\n    }\\n\\n    /// @notice Return the amount of fees from an amount\\n    /// @dev Rounds amount up, follows `amount = amountWithFees - getFeeAmountFrom(fp, amountWithFees)`\\n    /// @param _fp The current fee parameter\\n    /// @param _amountWithFees The amount of token sent\\n    /// @return The fee amount from the amount sent\\n    function getFeeAmountFrom(FeeParameters memory _fp, uint256 _amountWithFees) internal pure returns (uint256) {\\n        return (_amountWithFees * getTotalFee(_fp) + Constants.PRECISION - 1) / (Constants.PRECISION);\\n    }\\n\\n    /// @notice Return the fees to add to an amount\\n    /// @dev Rounds amount up, follows `amountWithFees = amount + getFeeAmount(fp, amount)`\\n    /// @param _fp The current fee parameter\\n    /// @param _amount The amount of token sent\\n    /// @return The fee amount to add to the amount\\n    function getFeeAmount(FeeParameters memory _fp, uint256 _amount) internal pure returns (uint256) {\\n        uint256 _fee = getTotalFee(_fp);\\n        uint256 _denominator = Constants.PRECISION - _fee;\\n        return (_amount * _fee + _denominator - 1) / _denominator;\\n    }\\n\\n    /// @notice Return the fees added when an user adds liquidity and change the ratio in the active bin\\n    /// @dev Rounds amount up\\n    /// @param _fp The current fee parameter\\n    /// @param _amountWithFees The amount of token sent\\n    /// @return The fee amount\\n    function getFeeAmountForC(FeeParameters memory _fp, uint256 _amountWithFees) internal pure returns (uint256) {\\n        uint256 _fee = getTotalFee(_fp);\\n        uint256 _denominator = Constants.PRECISION * Constants.PRECISION;\\n        return (_amountWithFees * _fee * (_fee + Constants.PRECISION) + _denominator - 1) / _denominator;\\n    }\\n\\n    /// @notice Return the fees distribution added to an amount\\n    /// @param _fp The current fee parameter\\n    /// @param _fees The fee amount\\n    /// @return fees The fee distribution\\n    function getFeeAmountDistribution(FeeParameters memory _fp, uint256 _fees)\\n        internal\\n        pure\\n        returns (FeesDistribution memory fees)\\n    {\\n        fees.total = _fees.safe128();\\n        // unsafe math is fine because total >= protocol\\n        unchecked {\\n            fees.protocol = uint128((_fees * _fp.protocolShare) / Constants.BASIS_POINT_MAX);\\n        }\\n    }\\n\\n    /// @notice Return the total fee, i.e. baseFee + variableFee\\n    /// @param _fp The current fee parameter\\n    /// @return The total fee, with 18 decimals\\n    function getTotalFee(FeeParameters memory _fp) private pure returns (uint256) {\\n        unchecked {\\n            return getBaseFee(_fp) + getVariableFee(_fp);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Math128x128.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\nimport \\\"./BitMath.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./Math512Bits.sol\\\";\\n\\n/// @title Liquidity Book Math Helper Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for power and log calculations\\nlibrary Math128x128 {\\n    using Math512Bits for uint256;\\n    using BitMath for uint256;\\n\\n    uint256 constant LOG_SCALE_OFFSET = 127;\\n    uint256 constant LOG_SCALE = 1 << LOG_SCALE_OFFSET;\\n    uint256 constant LOG_SCALE_SQUARED = LOG_SCALE * LOG_SCALE;\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than zero.\\n    ///\\n    /// Caveats:\\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation\\n    /// Also because x is converted to an unsigned 129.127-binary fixed-point number during the operation to optimize the multiplication\\n    ///\\n    /// @param x The unsigned 128.128-binary fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as a signed 128.128-binary fixed-point number.\\n    function log2(uint256 x) internal pure returns (int256 result) {\\n        // Convert x to a unsigned 129.127-binary fixed-point number to optimize the multiplication.\\n        // If we use an offset of 128 bits, y would need 129 bits and y**2 would would overflow and we would have to\\n        // use mulDiv, by reducing x to 129.127-binary fixed-point number we assert that y will use 128 bits, and we\\n        // can use the regular multiplication\\n\\n        if (x == 1) return -128;\\n        if (x == 0) revert Math128x128__LogUnderflow();\\n\\n        x >>= 1;\\n\\n        unchecked {\\n            // This works because log2(x) = -log2(1/x).\\n            int256 sign;\\n            if (x >= LOG_SCALE) {\\n                sign = 1;\\n            } else {\\n                sign = -1;\\n                // Do the fixed-point inversion inline to save gas\\n                x = LOG_SCALE_SQUARED / x;\\n            }\\n\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = (x >> LOG_SCALE_OFFSET).mostSignificantBit();\\n\\n            // The integer part of the logarithm as a signed 129.127-binary fixed-point number. The operation can't overflow\\n            // because n is maximum 255, LOG_SCALE_OFFSET is 127 bits and sign is either 1 or -1.\\n            result = int256(n) << LOG_SCALE_OFFSET;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y != LOG_SCALE) {\\n                // Calculate the fractional part via the iterative approximation.\\n                // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {\\n                    y = (y * y) >> LOG_SCALE_OFFSET;\\n\\n                    // Is y^2 > 2 and so in the range [2,4)?\\n                    if (y >= 1 << (LOG_SCALE_OFFSET + 1)) {\\n                        // Add the 2^(-m) factor to the logarithm.\\n                        result += delta;\\n\\n                        // Corresponds to z/2 on Wikipedia.\\n                        y >>= 1;\\n                    }\\n                }\\n            }\\n            // Convert x back to unsigned 128.128-binary fixed-point number\\n            result = (result * sign) << 1;\\n        }\\n    }\\n\\n    /// @notice Returns the value of x^y. It calculates `1 / x^abs(y)` if x is bigger than 2^128.\\n    /// At the end of the operations, we invert the result if needed.\\n    /// @param x The unsigned 128.128-binary fixed-point number for which to calculate the power\\n    /// @param y A relative number without any decimals, needs to be between ]2^20; 2^20[\\n    /// @return result The result of `x^y`\\n    function power(uint256 x, int256 y) internal pure returns (uint256 result) {\\n        bool invert;\\n        uint256 absY;\\n\\n        if (y == 0) return Constants.SCALE;\\n\\n        assembly {\\n            absY := y\\n            if slt(absY, 0) {\\n                absY := sub(0, absY)\\n                invert := iszero(invert)\\n            }\\n        }\\n\\n        if (absY < 0x100000) {\\n            result = Constants.SCALE;\\n            assembly {\\n                let pow := x\\n                if gt(x, 0xffffffffffffffffffffffffffffffff) {\\n                    pow := div(not(0), pow)\\n                    invert := iszero(invert)\\n                }\\n\\n                if and(absY, 0x1) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x2) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x4) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x8) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x10) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x20) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x40) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x80) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x100) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x200) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x400) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x800) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x1000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x2000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x4000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x8000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x10000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x20000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x40000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n                pow := shr(128, mul(pow, pow))\\n                if and(absY, 0x80000) {\\n                    result := shr(128, mul(result, pow))\\n                }\\n            }\\n        }\\n\\n        // revert if y is too big or if x^y underflowed\\n        if (result == 0) revert Math128x128__PowerUnderflow(x, y);\\n\\n        return invert ? type(uint256).max / result : result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Math512Bits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\nimport \\\"./BitMath.sol\\\";\\n\\n/// @title Liquidity Book Math Helper Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for full precision calculations\\nlibrary Math512Bits {\\n    using BitMath for uint256;\\n\\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision\\n    /// The result will be rounded down\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero\\n    /// - The result must fit within uint256\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers\\n    ///\\n    /// @param x The multiplicand as an uint256\\n    /// @param y The multiplier as an uint256\\n    /// @param denominator The divisor as an uint256\\n    /// @return result The result as an uint256\\n    function mulDivRoundDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\\n\\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\\n    }\\n\\n    /// @notice Calculates x * y >> offset with full precision\\n    /// The result will be rounded down\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    ///\\n    /// Requirements:\\n    /// - The offset needs to be strictly lower than 256\\n    /// - The result must fit within uint256\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers\\n    ///\\n    /// @param x The multiplicand as an uint256\\n    /// @param y The multiplier as an uint256\\n    /// @param offset The offset as an uint256, can't be greater than 256\\n    /// @return result The result as an uint256\\n    function mulShiftRoundDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 offset\\n    ) internal pure returns (uint256 result) {\\n        if (offset > 255) revert Math512Bits__OffsetOverflows(offset);\\n\\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\\n\\n        if (prod0 != 0) result = prod0 >> offset;\\n        if (prod1 != 0) {\\n            // Make sure the result is less than 2^256.\\n            if (prod1 >= 1 << offset) revert Math512Bits__MulShiftOverflow(prod1, offset);\\n\\n            unchecked {\\n                result += prod1 << (256 - offset);\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates x * y >> offset with full precision\\n    /// The result will be rounded up\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    ///\\n    /// Requirements:\\n    /// - The offset needs to be strictly lower than 256\\n    /// - The result must fit within uint256\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers\\n    ///\\n    /// @param x The multiplicand as an uint256\\n    /// @param y The multiplier as an uint256\\n    /// @param offset The offset as an uint256, can't be greater than 256\\n    /// @return result The result as an uint256\\n    function mulShiftRoundUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 offset\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulShiftRoundDown(x, y, offset);\\n            if (mulmod(x, y, 1 << offset) != 0) result += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates x << offset / y with full precision\\n    /// The result will be rounded down\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    ///\\n    /// Requirements:\\n    /// - The offset needs to be strictly lower than 256\\n    /// - The result must fit within uint256\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers\\n    ///\\n    /// @param x The multiplicand as an uint256\\n    /// @param offset The number of bit to shift x as an uint256\\n    /// @param denominator The divisor as an uint256\\n    /// @return result The result as an uint256\\n    function shiftDivRoundDown(\\n        uint256 x,\\n        uint256 offset,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        if (offset > 255) revert Math512Bits__OffsetOverflows(offset);\\n        uint256 prod0;\\n        uint256 prod1;\\n\\n        prod0 = x << offset; // Least significant 256 bits of the product\\n        unchecked {\\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\\n        }\\n\\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\\n    }\\n\\n    /// @notice Calculates x << offset / y with full precision\\n    /// The result will be rounded up\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    ///\\n    /// Requirements:\\n    /// - The offset needs to be strictly lower than 256\\n    /// - The result must fit within uint256\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers\\n    ///\\n    /// @param x The multiplicand as an uint256\\n    /// @param offset The number of bit to shift x as an uint256\\n    /// @param denominator The divisor as an uint256\\n    /// @return result The result as an uint256\\n    function shiftDivRoundUp(\\n        uint256 x,\\n        uint256 offset,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = shiftDivRoundDown(x, offset, denominator);\\n        unchecked {\\n            if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\\n        }\\n    }\\n\\n    /// @notice Helper function to return the result of `x * y` as 2 uint256\\n    /// @param x The multiplicand as an uint256\\n    /// @param y The multiplier as an uint256\\n    /// @return prod0 The least significant 256 bits of the product\\n    /// @return prod1 The most significant 256 bits of the product\\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n    }\\n\\n    /// @notice Helper function to return the result of `x * y / denominator` with full precision\\n    /// @param x The multiplicand as an uint256\\n    /// @param y The multiplier as an uint256\\n    /// @param denominator The divisor as an uint256\\n    /// @param prod0 The least significant 256 bits of the product\\n    /// @param prod1 The most significant 256 bits of the product\\n    /// @return result The result as an uint256\\n    function _getEndOfDivRoundDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        uint256 prod0,\\n        uint256 prod1\\n    ) private pure returns (uint256 result) {\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n        } else {\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\\n            if (prod1 >= denominator) revert Math512Bits__MulDivOverflow(prod1, denominator);\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\\n            // See https://cs.stackexchange.com/q/138556/92363\\n            unchecked {\\n                // Does not overflow because the denominator cannot be zero at this stage in the function\\n                uint256 lpotdod = denominator & (~denominator + 1);\\n                assembly {\\n                    // Divide denominator by lpotdod.\\n                    denominator := div(denominator, lpotdod)\\n\\n                    // Divide [prod1 prod0] by lpotdod.\\n                    prod0 := div(prod0, lpotdod)\\n\\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n                }\\n\\n                // Shift in bits from prod1 into prod0\\n                prod0 |= prod1 * lpotdod;\\n\\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n                // four bits. That is, denominator * inv = 1 mod 2^4\\n                uint256 inverse = (3 * denominator) ^ 2;\\n\\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n                // in modular arithmetic, doubling the correct bits in each step\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n                // is no longer required.\\n                result = prod0 * inverse;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\nimport \\\"./Buffer.sol\\\";\\nimport \\\"./Samples.sol\\\";\\n\\n/// @title Liquidity Book Oracle Library\\n/// @author Trader Joe\\n/// @notice Helper contract for oracle\\nlibrary Oracle {\\n    using Samples for bytes32;\\n    using Buffer for uint256;\\n\\n    struct Sample {\\n        uint256 timestamp;\\n        uint256 cumulativeId;\\n        uint256 cumulativeVolatilityAccumulated;\\n        uint256 cumulativeBinCrossed;\\n    }\\n\\n    /// @notice View function to get the oracle's sample at `_ago` seconds\\n    /// @dev Return a linearized sample, the weighted average of 2 neighboring samples\\n    /// @param _oracle The oracle storage pointer\\n    /// @param _activeSize The size of the oracle (without empty data)\\n    /// @param _activeId The active index of the oracle\\n    /// @param _lookUpTimestamp The looked up date\\n    /// @return timestamp The timestamp of the sample\\n    /// @return cumulativeId The weighted average cumulative id\\n    /// @return cumulativeVolatilityAccumulated The weighted average cumulative volatility accumulated\\n    /// @return cumulativeBinCrossed The weighted average cumulative bin crossed\\n    function getSampleAt(\\n        bytes32[65_535] storage _oracle,\\n        uint256 _activeSize,\\n        uint256 _activeId,\\n        uint256 _lookUpTimestamp\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 timestamp,\\n            uint256 cumulativeId,\\n            uint256 cumulativeVolatilityAccumulated,\\n            uint256 cumulativeBinCrossed\\n        )\\n    {\\n        if (_activeSize == 0) revert Oracle__NotInitialized();\\n\\n        // Oldest sample\\n        uint256 _nextId;\\n        assembly {\\n            _nextId := addmod(_activeId, 1, _activeSize)\\n        }\\n        bytes32 _sample = _oracle[_nextId];\\n        timestamp = _sample.timestamp();\\n        if (timestamp > _lookUpTimestamp) revert Oracle__LookUpTimestampTooOld(timestamp, _lookUpTimestamp);\\n\\n        // Most recent sample\\n        if (_activeSize != 1) {\\n            _sample = _oracle[_activeId];\\n            timestamp = _sample.timestamp();\\n\\n            if (timestamp > _lookUpTimestamp) {\\n                bytes32 _next;\\n                (_sample, _next) = binarySearch(_oracle, _activeId, _lookUpTimestamp, _activeSize);\\n\\n                if (_sample != _next) {\\n                    uint256 _weightPrev = _next.timestamp() - _lookUpTimestamp; // _next.timestamp() - _sample.timestamp() - (_lookUpTimestamp - _sample.timestamp())\\n                    uint256 _weightNext = _lookUpTimestamp - _sample.timestamp(); // _next.timestamp() - _sample.timestamp() - (_next.timestamp() - _lookUpTimestamp)\\n                    uint256 _totalWeight = _weightPrev + _weightNext; // _next.timestamp() - _sample.timestamp()\\n\\n                    cumulativeId =\\n                        (_sample.cumulativeId() * _weightPrev + _next.cumulativeId() * _weightNext) /\\n                        _totalWeight;\\n                    cumulativeVolatilityAccumulated =\\n                        (_sample.cumulativeVolatilityAccumulated() *\\n                            _weightPrev +\\n                            _next.cumulativeVolatilityAccumulated() *\\n                            _weightNext) /\\n                        _totalWeight;\\n                    cumulativeBinCrossed =\\n                        (_sample.cumulativeBinCrossed() * _weightPrev + _next.cumulativeBinCrossed() * _weightNext) /\\n                        _totalWeight;\\n                    return (_lookUpTimestamp, cumulativeId, cumulativeVolatilityAccumulated, cumulativeBinCrossed);\\n                }\\n            }\\n        }\\n\\n        timestamp = _sample.timestamp();\\n        cumulativeId = _sample.cumulativeId();\\n        cumulativeVolatilityAccumulated = _sample.cumulativeVolatilityAccumulated();\\n        cumulativeBinCrossed = _sample.cumulativeBinCrossed();\\n    }\\n\\n    /// @notice Function to update a sample\\n    /// @param _oracle The oracle storage pointer\\n    /// @param _size The size of the oracle (last ids can be empty)\\n    /// @param _sampleLifetime The lifetime of a sample, it accumulates information for up to this timestamp\\n    /// @param _lastTimestamp The timestamp of the creation of the oracle's latest sample\\n    /// @param _lastIndex The index of the oracle's latest sample\\n    /// @param _activeId The active index of the pair during the latest swap\\n    /// @param _volatilityAccumulated The volatility accumulated of the pair during the latest swap\\n    /// @param _binCrossed The bin crossed during the latest swap\\n    /// @return updatedIndex The oracle updated index, it is either the same as before, or the next one\\n    function update(\\n        bytes32[65_535] storage _oracle,\\n        uint256 _size,\\n        uint256 _sampleLifetime,\\n        uint256 _lastTimestamp,\\n        uint256 _lastIndex,\\n        uint256 _activeId,\\n        uint256 _volatilityAccumulated,\\n        uint256 _binCrossed\\n    ) internal returns (uint256 updatedIndex) {\\n        bytes32 _updatedPackedSample = _oracle[_lastIndex].update(_activeId, _volatilityAccumulated, _binCrossed);\\n\\n        if (block.timestamp - _lastTimestamp >= _sampleLifetime && _lastTimestamp != 0) {\\n            assembly {\\n                updatedIndex := addmod(_lastIndex, 1, _size)\\n            }\\n        } else updatedIndex = _lastIndex;\\n\\n        _oracle[updatedIndex] = _updatedPackedSample;\\n    }\\n\\n    /// @notice Initialize the sample\\n    /// @param _oracle The oracle storage pointer\\n    /// @param _index The index to initialize\\n    function initialize(bytes32[65_535] storage _oracle, uint256 _index) internal {\\n        _oracle[_index] |= bytes32(uint256(1));\\n    }\\n\\n    /// @notice Binary search on oracle samples and return the 2 samples (as bytes32) that surrounds the `lookUpTimestamp`\\n    /// @dev The oracle needs to be in increasing order `{_index + 1, _index + 2 ..., _index + _activeSize} % _activeSize`.\\n    /// The sample that aren't initialized yet will be skipped as _activeSize only contains the samples that are initialized.\\n    /// This function works only if `timestamp(_oracle[_index + 1 % _activeSize] <= _lookUpTimestamp <= timestamp(_oracle[_index]`.\\n    /// The edge cases needs to be handled before\\n    /// @param _oracle The oracle storage pointer\\n    /// @param _index The current index of the oracle\\n    /// @param _lookUpTimestamp The looked up timestamp\\n    /// @param _activeSize The size of the oracle (without empty data)\\n    /// @return prev The last sample with a timestamp lower than the lookUpTimestamp\\n    /// @return next The first sample with a timestamp greater than the lookUpTimestamp\\n    function binarySearch(\\n        bytes32[65_535] storage _oracle,\\n        uint256 _index,\\n        uint256 _lookUpTimestamp,\\n        uint256 _activeSize\\n    ) private view returns (bytes32 prev, bytes32 next) {\\n        // The sample with the lowest timestamp is the one right after _index\\n        uint256 _low = 1;\\n        uint256 _high = _activeSize;\\n\\n        uint256 _middle;\\n        uint256 _id;\\n\\n        bytes32 _sample;\\n        uint256 _sampleTimestamp;\\n        while (_high >= _low) {\\n            unchecked {\\n                _middle = (_low + _high) >> 1;\\n                assembly {\\n                    _id := addmod(_middle, _index, _activeSize)\\n                }\\n                _sample = _oracle[_id];\\n                _sampleTimestamp = _sample.timestamp();\\n                if (_sampleTimestamp < _lookUpTimestamp) {\\n                    _low = _middle + 1;\\n                } else if (_sampleTimestamp > _lookUpTimestamp) {\\n                    _high = _middle - 1;\\n                } else {\\n                    return (_sample, _sample);\\n                }\\n            }\\n        }\\n        if (_sampleTimestamp < _lookUpTimestamp) {\\n            assembly {\\n                _id := addmod(_id, 1, _activeSize)\\n            }\\n            (prev, next) = (_sample, _oracle[_id]);\\n        } else (prev, next) = (_oracle[_id.before(_activeSize)], _sample);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\n\\n/// @title Reentrancy Guard\\n/// @author Trader Joe\\n/// @notice Contract module that helps prevent reentrant calls to a function\\nabstract contract ReentrancyGuardUpgradeable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal {\\n        if (_status != 0) revert ReentrancyGuardUpgradeable__AlreadyInitialized();\\n\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /// @notice Prevents a contract from calling itself, directly or indirectly.\\n    /// Calling a `nonReentrant` function from another `nonReentrant`\\n    /// function is not supported. It is possible to prevent this from happening\\n    /// by making the `nonReentrant` function external, and making it call a\\n    /// `private` function that does the actual work\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        if (_status != _NOT_ENTERED) revert ReentrancyGuardUpgradeable__ReentrantCall();\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\n\\n/// @title Liquidity Book Safe Cast Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for converting uint values safely\\nlibrary SafeCast {\\n    /// @notice Returns x on uint248 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint248\\n    function safe248(uint256 x) internal pure returns (uint248 y) {\\n        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint240 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint240\\n    function safe240(uint256 x) internal pure returns (uint240 y) {\\n        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint232 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint232\\n    function safe232(uint256 x) internal pure returns (uint232 y) {\\n        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint224 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint224\\n    function safe224(uint256 x) internal pure returns (uint224 y) {\\n        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint216 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint216\\n    function safe216(uint256 x) internal pure returns (uint216 y) {\\n        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint208 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint208\\n    function safe208(uint256 x) internal pure returns (uint208 y) {\\n        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint200 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint200\\n    function safe200(uint256 x) internal pure returns (uint200 y) {\\n        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint192 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint192\\n    function safe192(uint256 x) internal pure returns (uint192 y) {\\n        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint184 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint184\\n    function safe184(uint256 x) internal pure returns (uint184 y) {\\n        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint176 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint176\\n    function safe176(uint256 x) internal pure returns (uint176 y) {\\n        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint168 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint168\\n    function safe168(uint256 x) internal pure returns (uint168 y) {\\n        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint160 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint160\\n    function safe160(uint256 x) internal pure returns (uint160 y) {\\n        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint152 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint152\\n    function safe152(uint256 x) internal pure returns (uint152 y) {\\n        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint144 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint144\\n    function safe144(uint256 x) internal pure returns (uint144 y) {\\n        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint136 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint136\\n    function safe136(uint256 x) internal pure returns (uint136 y) {\\n        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint128 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint128\\n    function safe128(uint256 x) internal pure returns (uint128 y) {\\n        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint120 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint120\\n    function safe120(uint256 x) internal pure returns (uint120 y) {\\n        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint112 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint112\\n    function safe112(uint256 x) internal pure returns (uint112 y) {\\n        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint104 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint104\\n    function safe104(uint256 x) internal pure returns (uint104 y) {\\n        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint96 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint96\\n    function safe96(uint256 x) internal pure returns (uint96 y) {\\n        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint88 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint88\\n    function safe88(uint256 x) internal pure returns (uint88 y) {\\n        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint80 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint80\\n    function safe80(uint256 x) internal pure returns (uint80 y) {\\n        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint72 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint72\\n    function safe72(uint256 x) internal pure returns (uint72 y) {\\n        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint64 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint64\\n    function safe64(uint256 x) internal pure returns (uint64 y) {\\n        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint56 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint56\\n    function safe56(uint256 x) internal pure returns (uint56 y) {\\n        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint48 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint48\\n    function safe48(uint256 x) internal pure returns (uint48 y) {\\n        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint40 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint40\\n    function safe40(uint256 x) internal pure returns (uint40 y) {\\n        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint32 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint32\\n    function safe32(uint256 x) internal pure returns (uint32 y) {\\n        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint24 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint24\\n    function safe24(uint256 x) internal pure returns (uint24 y) {\\n        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint16 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint16\\n    function safe16(uint256 x) internal pure returns (uint16 y) {\\n        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits(x);\\n    }\\n\\n    /// @notice Returns x on uint8 and check that it does not overflow\\n    /// @param x The value as an uint256\\n    /// @return y The value as an uint8\\n    function safe8(uint256 x) internal pure returns (uint8 y) {\\n        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/// @title Liquidity Book Safe Math Helper Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for calculating absolute value safely\\nlibrary SafeMath {\\n    /// @notice absSub, can't underflow or overflow\\n    /// @param x The first value\\n    /// @param y The second value\\n    /// @return The result of abs(x - y)\\n    function absSub(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            return x > y ? x - y : y - x;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Samples.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./Decoder.sol\\\";\\nimport \\\"./Encoder.sol\\\";\\n\\n/// @title Liquidity Book Sample Helper Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for oracle samples operations\\nlibrary Samples {\\n    using Encoder for uint256;\\n    using Decoder for bytes32;\\n\\n    ///  [ cumulativeBinCrossed | cumulativeVolatilityAccumulated | cumulativeId | timestamp | initialized ]\\n    ///  [        uint87        |              uint64             |    uint64    |   uint40  |    bool1    ]\\n    /// MSB                                                                                               LSB\\n\\n    uint256 private constant _OFFSET_INITIALIZED = 0;\\n    uint256 private constant _MASK_INITIALIZED = 1;\\n\\n    uint256 private constant _OFFSET_TIMESTAMP = 1;\\n    uint256 private constant _MASK_TIMESTAMP = type(uint40).max;\\n\\n    uint256 private constant _OFFSET_CUMULATIVE_ID = 41;\\n    uint256 private constant _MASK_CUMULATIVE_ID = type(uint64).max;\\n\\n    uint256 private constant _OFFSET_CUMULATIVE_VolatilityAccumulated = 105;\\n    uint256 private constant _MASK_CUMULATIVE_VolatilityAccumulated = type(uint64).max;\\n\\n    uint256 private constant _OFFSET_CUMULATIVE_BIN_CROSSED = 169;\\n    uint256 private constant _MASK_CUMULATIVE_BIN_CROSSED = 0x7fffffffffffffffffffff;\\n\\n    /// @notice Function to update a sample\\n    /// @param _lastSample The latest sample of the oracle\\n    /// @param _activeId The active index of the pair during the latest swap\\n    /// @param _volatilityAccumulated The volatility accumulated of the pair during the latest swap\\n    /// @param _binCrossed The bin crossed during the latest swap\\n    /// @return packedSample The packed sample as bytes32\\n    function update(\\n        bytes32 _lastSample,\\n        uint256 _activeId,\\n        uint256 _volatilityAccumulated,\\n        uint256 _binCrossed\\n    ) internal view returns (bytes32 packedSample) {\\n        uint256 _deltaTime = block.timestamp - timestamp(_lastSample);\\n\\n        // cumulative can overflow without any issue as what matter is the delta cumulative.\\n        // It would be an issue if 2 overflows would happen but way too much time should elapsed for it to happen.\\n        // The delta calculation needs to be unchecked math to allow for it to overflow again.\\n        unchecked {\\n            uint256 _cumulativeId = cumulativeId(_lastSample) + _activeId * _deltaTime;\\n            uint256 _cumulativeVolatilityAccumulated = cumulativeVolatilityAccumulated(_lastSample) +\\n                _volatilityAccumulated *\\n                _deltaTime;\\n            uint256 _cumulativeBinCrossed = cumulativeBinCrossed(_lastSample) + _binCrossed * _deltaTime;\\n\\n            return pack(_cumulativeBinCrossed, _cumulativeVolatilityAccumulated, _cumulativeId, block.timestamp, 1);\\n        }\\n    }\\n\\n    /// @notice Function to pack cumulative values\\n    /// @param _cumulativeBinCrossed The cumulative bin crossed\\n    /// @param _cumulativeVolatilityAccumulated The cumulative volatility accumulated\\n    /// @param _cumulativeId The cumulative index\\n    /// @param _timestamp The timestamp\\n    /// @param _initialized The initialized value\\n    /// @return packedSample The packed sample as bytes32\\n    function pack(\\n        uint256 _cumulativeBinCrossed,\\n        uint256 _cumulativeVolatilityAccumulated,\\n        uint256 _cumulativeId,\\n        uint256 _timestamp,\\n        uint256 _initialized\\n    ) internal pure returns (bytes32 packedSample) {\\n        return\\n            _cumulativeBinCrossed.encode(_MASK_CUMULATIVE_BIN_CROSSED, _OFFSET_CUMULATIVE_BIN_CROSSED) |\\n            _cumulativeVolatilityAccumulated.encode(\\n                _MASK_CUMULATIVE_VolatilityAccumulated,\\n                _OFFSET_CUMULATIVE_VolatilityAccumulated\\n            ) |\\n            _cumulativeId.encode(_MASK_CUMULATIVE_ID, _OFFSET_CUMULATIVE_ID) |\\n            _timestamp.encode(_MASK_TIMESTAMP, _OFFSET_TIMESTAMP) |\\n            _initialized.encode(_MASK_INITIALIZED, _OFFSET_INITIALIZED);\\n    }\\n\\n    /// @notice View function to return the initialized value\\n    /// @param _packedSample The packed sample\\n    /// @return The initialized value\\n    function initialized(bytes32 _packedSample) internal pure returns (uint256) {\\n        return _packedSample.decode(_MASK_INITIALIZED, _OFFSET_INITIALIZED);\\n    }\\n\\n    /// @notice View function to return the timestamp value\\n    /// @param _packedSample The packed sample\\n    /// @return The timestamp value\\n    function timestamp(bytes32 _packedSample) internal pure returns (uint256) {\\n        return _packedSample.decode(_MASK_TIMESTAMP, _OFFSET_TIMESTAMP);\\n    }\\n\\n    /// @notice View function to return the cumulative id value\\n    /// @param _packedSample The packed sample\\n    /// @return The cumulative id value\\n    function cumulativeId(bytes32 _packedSample) internal pure returns (uint256) {\\n        return _packedSample.decode(_MASK_CUMULATIVE_ID, _OFFSET_CUMULATIVE_ID);\\n    }\\n\\n    /// @notice View function to return the cumulative volatility accumulated value\\n    /// @param _packedSample The packed sample\\n    /// @return The cumulative volatility accumulated value\\n    function cumulativeVolatilityAccumulated(bytes32 _packedSample) internal pure returns (uint256) {\\n        return _packedSample.decode(_MASK_CUMULATIVE_VolatilityAccumulated, _OFFSET_CUMULATIVE_VolatilityAccumulated);\\n    }\\n\\n    /// @notice View function to return the cumulative bin crossed value\\n    /// @param _packedSample The packed sample\\n    /// @return The cumulative bin crossed value\\n    function cumulativeBinCrossed(bytes32 _packedSample) internal pure returns (uint256) {\\n        return _packedSample.decode(_MASK_CUMULATIVE_BIN_CROSSED, _OFFSET_CUMULATIVE_BIN_CROSSED);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SwapHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./BinHelper.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./FeeDistributionHelper.sol\\\";\\nimport \\\"./FeeHelper.sol\\\";\\nimport \\\"./Math512Bits.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"../interfaces/ILBPair.sol\\\";\\n\\n/// @title Liquidity Book Swap Helper Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for calculating swaps, fees and reserves changes\\nlibrary SwapHelper {\\n    using Math512Bits for uint256;\\n    using FeeHelper for FeeHelper.FeeParameters;\\n    using SafeMath for uint256;\\n    using FeeDistributionHelper for FeeHelper.FeesDistribution;\\n\\n    /// @notice Returns the swap amounts in the current bin\\n    /// @param bin The bin information\\n    /// @param fp The fee parameters\\n    /// @param activeId The active id of the pair\\n    /// @param swapForY Whether you've swapping token X for token Y (true) or token Y for token X (false)\\n    /// @param amountIn The amount sent by the user\\n    /// @return amountInToBin The amount of token that is added to the bin without the fees\\n    /// @return amountOutOfBin The amount of token that is removed from the bin\\n    /// @return fees The swap fees\\n    function getAmounts(\\n        ILBPair.Bin memory bin,\\n        FeeHelper.FeeParameters memory fp,\\n        uint256 activeId,\\n        bool swapForY,\\n        uint256 amountIn\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256 amountInToBin,\\n            uint256 amountOutOfBin,\\n            FeeHelper.FeesDistribution memory fees\\n        )\\n    {\\n        uint256 _price = BinHelper.getPriceFromId(activeId, fp.binStep);\\n\\n        uint256 _reserve;\\n        uint256 _maxAmountInToBin;\\n        if (swapForY) {\\n            _reserve = bin.reserveY;\\n            _maxAmountInToBin = _reserve.shiftDivRoundUp(Constants.SCALE_OFFSET, _price);\\n        } else {\\n            _reserve = bin.reserveX;\\n            _maxAmountInToBin = _price.mulShiftRoundUp(_reserve, Constants.SCALE_OFFSET);\\n        }\\n\\n        fp.updateVolatilityAccumulated(activeId);\\n        fees = fp.getFeeAmountDistribution(fp.getFeeAmount(_maxAmountInToBin));\\n\\n        if (_maxAmountInToBin + fees.total <= amountIn) {\\n            amountInToBin = _maxAmountInToBin;\\n            amountOutOfBin = _reserve;\\n        } else {\\n            fees = fp.getFeeAmountDistribution(fp.getFeeAmountFrom(amountIn));\\n            amountInToBin = amountIn - fees.total;\\n            amountOutOfBin = swapForY\\n                ? _price.mulShiftRoundDown(amountInToBin, Constants.SCALE_OFFSET)\\n                : amountInToBin.shiftDivRoundDown(Constants.SCALE_OFFSET, _price);\\n            // Safety check in case rounding returns a higher value than expected\\n            if (amountOutOfBin > _reserve) amountOutOfBin = _reserve;\\n        }\\n    }\\n\\n    /// @notice Update the fees of the pair and accumulated token per share of the bin\\n    /// @param bin The bin information\\n    /// @param pairFees The current fees of the pair information\\n    /// @param fees The fees amounts added to the pairFees\\n    /// @param swapForY whether the token sent was Y (true) or X (false)\\n    /// @param totalSupply The total supply of the token id\\n    function updateFees(\\n        ILBPair.Bin memory bin,\\n        FeeHelper.FeesDistribution memory pairFees,\\n        FeeHelper.FeesDistribution memory fees,\\n        bool swapForY,\\n        uint256 totalSupply\\n    ) internal pure {\\n        pairFees.total += fees.total;\\n        // unsafe math is fine because total >= protocol\\n        unchecked {\\n            pairFees.protocol += fees.protocol;\\n        }\\n\\n        if (swapForY) {\\n            bin.accTokenXPerShare += fees.getTokenPerShare(totalSupply);\\n        } else {\\n            bin.accTokenYPerShare += fees.getTokenPerShare(totalSupply);\\n        }\\n    }\\n\\n    /// @notice Update reserves\\n    /// @param bin The bin information\\n    /// @param pair The pair information\\n    /// @param swapForY whether the token sent was Y (true) or X (false)\\n    /// @param amountInToBin The amount of token that is added to the bin without fees\\n    /// @param amountOutOfBin The amount of token that is removed from the bin\\n    function updateReserves(\\n        ILBPair.Bin memory bin,\\n        ILBPair.PairInformation memory pair,\\n        bool swapForY,\\n        uint112 amountInToBin,\\n        uint112 amountOutOfBin\\n    ) internal pure {\\n        if (swapForY) {\\n            bin.reserveX += amountInToBin;\\n\\n            unchecked {\\n                bin.reserveY -= amountOutOfBin;\\n                pair.reserveX += uint136(amountInToBin);\\n                pair.reserveY -= uint136(amountOutOfBin);\\n            }\\n        } else {\\n            bin.reserveY += amountInToBin;\\n\\n            unchecked {\\n                bin.reserveX -= amountOutOfBin;\\n                pair.reserveX -= uint136(amountOutOfBin);\\n                pair.reserveY += uint136(amountInToBin);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/TokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../LBErrors.sol\\\";\\n\\n/// @title Safe Transfer\\n/// @author Trader Joe\\n/// @notice Wrappers around ERC20 operations that throw on failure (when the token\\n/// contract returns false). Tokens that return no value (and instead revert or\\n/// throw on failure) are also supported, non-reverting calls are assumed to be\\n/// successful.\\n/// To use this library you can add a `using TokenHelper for IERC20;` statement to your contract,\\n/// which allows you to call the safe operation as `token.safeTransfer(...)`\\nlibrary TokenHelper {\\n    /// @notice Transfers token only if the amount is greater than zero\\n    /// @param token The address of the token\\n    /// @param owner The owner of the tokens\\n    /// @param recipient The address of the recipient\\n    /// @param amount The amount to send\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address owner,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        if (amount != 0) {\\n            bytes memory data = abi.encodeWithSelector(token.transferFrom.selector, owner, recipient, amount);\\n\\n            bytes memory returnData = _callAndCatchError(address(token), data);\\n\\n            if (returnData.length > 0 && !abi.decode(returnData, (bool))) revert TokenHelper__TransferFailed();\\n        }\\n    }\\n\\n    /// @notice Transfers token only if the amount is greater than zero\\n    /// @param token The address of the token\\n    /// @param recipient The address of the recipient\\n    /// @param amount The amount to send\\n    function safeTransfer(\\n        IERC20 token,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        if (amount != 0) {\\n            bytes memory data = abi.encodeWithSelector(token.transfer.selector, recipient, amount);\\n\\n            bytes memory returnData = _callAndCatchError(address(token), data);\\n\\n            if (returnData.length > 0 && !abi.decode(returnData, (bool))) revert TokenHelper__TransferFailed();\\n        }\\n    }\\n\\n    /// @notice Returns the amount of token received by the pair\\n    /// @param token The address of the token\\n    /// @param reserve The total reserve of token\\n    /// @param fees The total fees of token\\n    /// @return The amount received by the pair\\n    function received(\\n        IERC20 token,\\n        uint256 reserve,\\n        uint256 fees\\n    ) internal view returns (uint256) {\\n        uint256 _internalBalance;\\n        unchecked {\\n            _internalBalance = reserve + fees;\\n        }\\n        return token.balanceOf(address(this)) - _internalBalance;\\n    }\\n\\n    /// @notice Private view function to perform a low level call on `target`\\n    /// @dev Revert if the call doesn't succeed\\n    /// @param target The address of the account\\n    /// @param data The data to execute on `target`\\n    /// @return returnData The data returned by the call\\n    function _callAndCatchError(address target, bytes memory data) private returns (bytes memory) {\\n        (bool success, bytes memory returnData) = target.call(data);\\n\\n        if (success) {\\n            if (returnData.length == 0 && !_isContract(target)) revert TokenHelper__NonContract();\\n        } else {\\n            if (returnData.length == 0) revert TokenHelper__CallFailed();\\n            else {\\n                // Look for revert reason and bubble it up if present\\n                assembly {\\n                    revert(add(32, returnData), mload(returnData))\\n                }\\n            }\\n        }\\n\\n        return returnData;\\n    }\\n\\n    /// @notice Private view function to return if an address is a contract\\n    /// @dev It is unsafe to assume that an address for which this function returns\\n    /// false is an externally-owned account (EOA) and not a contract.\\n    ///\\n    /// Among others, `isContract` will return false for the following\\n    /// types of addresses:\\n    ///  - an externally-owned account\\n    ///  - a contract in construction\\n    ///  - an address where a contract will be created\\n    ///  - an address where a contract lived, but was destroyed\\n    /// @param account The address of the account\\n    /// @return Whether the account is a contract (true) or not (false)\\n    function _isContract(address account) private view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/TreeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../LBErrors.sol\\\";\\nimport \\\"./BitMath.sol\\\";\\n\\n/// @title Liquidity Book Tree Math Library\\n/// @author Trader Joe\\n/// @notice Helper contract used for finding closest bin with liquidity\\nlibrary TreeMath {\\n    using BitMath for uint256;\\n\\n    /// @notice Returns the first id that is non zero, corresponding to a bin with\\n    /// liquidity in it\\n    /// @param _tree The storage slot of the tree\\n    /// @param _binId the binId to start searching\\n    /// @param _rightSide Whether we're searching in the right side of the tree (true) or the left side (false)\\n    /// for the closest non zero bit on the right or the left\\n    /// @return The closest non zero bit on the right (or left) side of the tree\\n    function findFirstBin(\\n        mapping(uint256 => uint256)[3] storage _tree,\\n        uint24 _binId,\\n        bool _rightSide\\n    ) internal view returns (uint24) {\\n        unchecked {\\n            uint256 current;\\n            uint256 bit;\\n\\n            (_binId, bit) = _getIdsFromAbove(_binId);\\n\\n            // Search in depth 2\\n            if ((_rightSide && bit != 0) || (!_rightSide && bit != 255)) {\\n                current = _tree[2][_binId];\\n                bit = current.closestBit(uint8(bit), _rightSide);\\n\\n                if (bit != type(uint256).max) {\\n                    return _getBottomId(_binId, uint24(bit));\\n                }\\n            }\\n\\n            (_binId, bit) = _getIdsFromAbove(_binId);\\n\\n            // Search in depth 1\\n            if ((_rightSide && bit != 0) || (!_rightSide && bit != 255)) {\\n                current = _tree[1][_binId];\\n                bit = current.closestBit(uint8(bit), _rightSide);\\n\\n                if (bit != type(uint256).max) {\\n                    _binId = _getBottomId(_binId, uint24(bit));\\n                    current = _tree[2][_binId];\\n\\n                    return _getBottomId(_binId, current.significantBit(_rightSide));\\n                }\\n            }\\n\\n            // Search in depth 0\\n            current = _tree[0][0];\\n            bit = current.closestBit(uint8(_binId), _rightSide);\\n            if (bit == type(uint256).max) revert TreeMath__ErrorDepthSearch();\\n\\n            current = _tree[1][bit];\\n            _binId = _getBottomId(uint24(bit), current.significantBit(_rightSide));\\n\\n            current = _tree[2][_binId];\\n            return _getBottomId(_binId, current.significantBit(_rightSide));\\n        }\\n    }\\n\\n    function addToTree(mapping(uint256 => uint256)[3] storage _tree, uint256 _id) internal {\\n        // add 1 at the right indices\\n        uint256 _idDepth2 = _id >> 8;\\n        uint256 _idDepth1 = _id >> 16;\\n\\n        _tree[2][_idDepth2] |= 1 << (_id & 255);\\n        _tree[1][_idDepth1] |= 1 << (_idDepth2 & 255);\\n        _tree[0][0] |= 1 << _idDepth1;\\n    }\\n\\n    function removeFromTree(mapping(uint256 => uint256)[3] storage _tree, uint256 _id) internal {\\n        unchecked {\\n            // removes 1 at the right indices\\n            uint256 _idDepth2 = _id >> 8;\\n            // Optimization of `_tree[2][_idDepth2] & (type(uint256).max - (1 << (_id & 255)))`\\n            uint256 _newLeafValue = _tree[2][_idDepth2] & (type(uint256).max ^ (1 << (_id & 255)));\\n            _tree[2][_idDepth2] = _newLeafValue;\\n            if (_newLeafValue == 0) {\\n                uint256 _idDepth1 = _id >> 16;\\n                // Optimization of `_tree[1][_idDepth1] & (type(uint256).max - (1 << (_idDepth2 & 255)))`\\n                _newLeafValue = _tree[1][_idDepth1] & (type(uint256).max ^ (1 << (_idDepth2 & 255)));\\n                _tree[1][_idDepth1] = _newLeafValue;\\n                if (_newLeafValue == 0) {\\n                    // Optimization of `type(uint256).max - (1 << _idDepth1)`\\n                    _tree[0][0] &= type(uint256).max ^ (1 << _idDepth1);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Private pure function to return the ids from above\\n    /// @param _id The current id\\n    /// @return The branch id from above\\n    /// @return The leaf id from above\\n    function _getIdsFromAbove(uint24 _id) private pure returns (uint24, uint24) {\\n        // Optimization of `(_id / 256, _id % 256)`\\n        return (_id >> 8, _id & 255);\\n    }\\n\\n    /// @notice Private pure function to return the bottom id\\n    /// @param _branchId The branch id\\n    /// @param _leafId The leaf id\\n    /// @return The bottom branchId\\n    function _getBottomId(uint24 _branchId, uint24 _leafId) private pure returns (uint24) {\\n        // Optimization of `_branchId * 256 + _leafId`\\n        // Can't overflow as _leafId would fit in uint8, but kept as uint24 to optimize castings\\n        unchecked {\\n            return (_branchId << 8) + _leafId;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ILBFactory\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bp\",\"type\":\"uint256\"}],\"name\":\"BinHelper__BinStepOverflows\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BinHelper__IdOverflows\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__AddressZeroOrThis\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LBPair__CompositionFactorFlawed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__DistributionsOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__FlashLoanCallbackFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__FlashLoanInvalidBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__FlashLoanInvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__InsufficientAmounts\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LBPair__InsufficientLiquidityBurned\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LBPair__InsufficientLiquidityMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__OnlyFactory\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"LBPair__OnlyFeeRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__OnlyStrictlyIncreasingId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleSize\",\"type\":\"uint256\"}],\"name\":\"LBPair__OracleNewSizeTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBPair__WrongLengths\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LBToken__BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBToken__BurnFromAddress0\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idsLength\",\"type\":\"uint256\"}],\"name\":\"LBToken__LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBToken__MintToAddress0\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LBToken__SelfApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"LBToken__SpenderNotApproved\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LBToken__TransferExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBToken__TransferFromOrToAddress0\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LBToken__TransferToSelf\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"Math128x128__PowerUnderflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"Math512Bits__MulDivOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"Math512Bits__MulShiftOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"Math512Bits__OffsetOverflows\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lookUpTimestamp\",\"type\":\"uint256\"}],\"name\":\"Oracle__LookUpTimestampTooOld\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Oracle__NotInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardUpgradeable__AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardUpgradeable__ReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"SafeCast__Exceeds112Bits\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"SafeCast__Exceeds128Bits\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"SafeCast__Exceeds24Bits\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"SafeCast__Exceeds40Bits\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenHelper__CallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenHelper__NonContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenHelper__TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TreeMath__ErrorDepthSearch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesY\",\"type\":\"uint256\"}],\"name\":\"CompositionFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"DepositedToBin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"FeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ILBFlashLoanCallback\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSize\",\"type\":\"uint256\"}],\"name\":\"OracleSizeIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"swapForY\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"volatilityAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"WithdrawnFromBin\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"batchBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"collectFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectProtocolFees\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amountX\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amountY\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract ILBFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeParameters\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"baseFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"filterPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"decayPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"reductionFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"variableFeeControl\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"protocolShare\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"maxVolatilityAccumulated\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"volatilityAccumulated\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"volatilityReference\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"indexRef\",\"type\":\"uint24\"},{\"internalType\":\"uint40\",\"name\":\"time\",\"type\":\"uint40\"}],\"internalType\":\"struct FeeHelper.FeeParameters\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_id\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"_swapForY\",\"type\":\"bool\"}],\"name\":\"findFirstNonEmptyBinId\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILBFlashLoanCallback\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceDecay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_id\",\"type\":\"uint24\"}],\"name\":\"getBin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveY\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalFees\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"feesXTotal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"feesYTotal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"feesXProtocol\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"feesYProtocol\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOracleParameters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"oracleSampleLifetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleActiveSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleLastTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeDelta\",\"type\":\"uint256\"}],\"name\":\"getOracleSampleFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeVolatilityAccumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeBinCrossed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReservesAndId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newLength\",\"type\":\"uint16\"}],\"name\":\"increaseOracleLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_tokenY\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_activeId\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"_sampleLifetime\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_packedFeeParameters\",\"type\":\"bytes32\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_distributionX\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_distributionY\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"liquidityMinted\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"pendingFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_packedFeeParameters\",\"type\":\"bytes32\"}],\"name\":\"setFeesParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapForY\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountXOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountYOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenX\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenY\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LBPair", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000043646a8e839b2f2766392c1bf8f60f6e587b6960", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}