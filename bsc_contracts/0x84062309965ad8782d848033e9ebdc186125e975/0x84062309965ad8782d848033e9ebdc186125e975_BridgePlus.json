{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/BridgePlus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface IERC20 {\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address to, uint256 amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\\ninterface IWETH is IERC20 {\\n  function deposit() external payable;\\n  function withdraw(uint amount) external;\\n}\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n  }\\n\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _transferOwnership(newOwner);\\n  }\\n\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    return account.code.length > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  function functionCall(\\n      address target,\\n      bytes memory data,\\n      string memory errorMessage\\n  ) internal returns (bytes memory) {\\n      return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n      address target,\\n      bytes memory data,\\n      uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    if (returndata.length > 0) {\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\\ninterface IERC20Permit {\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n  function nonces(address owner) external view returns (uint256);\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n      uint256 newAllowance = oldAllowance - value;\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\\ninterface ISwapPlusv1 {\\n  struct swapRouter {\\n    string platform;\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amountOutMin;\\n    uint256 meta; // fee, flag(stable), 0=v2\\n    uint256 percent;\\n  }\\n  struct swapLine {\\n    swapRouter[] swaps;\\n  }\\n  struct swapBlock {\\n    swapLine[] lines;\\n  }\\n\\n  function swap(address tokenIn, uint256 amount, address tokenOut, address recipient, swapBlock[] calldata swBlocks) external payable returns(uint256, uint256);\\n}\\n\\ninterface ILCBridgev2 {\\n  function swap(address _to, address _refund, uint256 _outChainID) external payable returns(uint256);\\n  function redeem(address account, uint256 amount, uint256 srcChainId, uint256 _swapIndex, uint256 operatorFee) external returns(uint256);\\n  function refund(uint256 _index, uint256 _fee) external returns(uint256);\\n}\\n\\ninterface ILCBridgev2Token {\\n  function swap(address _to, uint256 _amount, address _refund, uint256 _outChainID) external payable returns(uint256);\\n  function redeem(address account, uint256 amount, uint256 srcChainId, uint256 _swapIndex, uint256 operatorFee) external returns(uint256);\\n  function refund(uint256 _index) external returns(uint256);\\n}\\n\\ninterface IBridge {\\n  function addNativeLiquidity(uint256 _amount)\\n    external payable;\\n  \\n  function send(\\n    address _receiver,\\n    address _token,\\n    uint256 _amount,\\n    uint64 _dstChainId,\\n    uint64 _nonce,\\n    uint32 _maxSlippage // slippage * 1M, eg. 0.5% -> 5000\\n  ) external;\\n\\n  function sendNative(\\n    address _receiver,\\n    uint256 _amount,\\n    uint64 _dstChainId,\\n    uint64 _nonce,\\n    uint32 _maxSlippage\\n  ) external payable;\\n\\n  function withdraw(\\n    bytes calldata _wdmsg,\\n    bytes[] calldata _sigs,\\n    address[] calldata _signers,\\n    uint256[] calldata _powers\\n  ) external;\\n}\\n\\ninterface IStargateRouter {\\n  struct lzTxObj {\\n    uint256 dstGasForCall;\\n    uint256 dstNativeAmount;\\n    bytes dstNativeAddr;\\n  }\\n\\n  function addLiquidity(uint256 _poolId, uint256 _amountLD, address to) external payable;\\n  function instantRedeemLocal(uint16 _srcPoolId, uint256 _amountLD, address to) external payable;\\n\\n  function swap(\\n    uint16 _dstChainId,\\n    uint256 _srcPoolId,\\n    uint256 _dstPoolId,\\n    address payable _refundAddress,\\n    uint256 _amountLD,\\n    uint256 _minAmountLD,\\n    lzTxObj memory _lzTxParams,\\n    bytes calldata _to,\\n    bytes calldata _payload\\n  ) external payable;\\n\\n  function quoteLayerZeroFee(\\n    uint16 _dstChainId,\\n    uint8 _functionType,\\n    bytes calldata _toAddress,\\n    bytes calldata _transferAndCallPayload,\\n    lzTxObj memory _lzTxParams\\n  ) external view returns (uint256, uint256);\\n}\\n\\ncontract BridgePlus is Ownable {\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public chainId;\\n  address public WETH;\\n  address public treasury;\\n  address public swapRouter;\\n  uint256 public swapFee = 3000;\\n  uint256 public coreDecimal = 1000000;\\n  uint256 public stargateSwapFeeMultipler = 1400000;\\n  uint256 public stargateSwapFeeDivider = 1000000;\\n\\n  mapping (address => bool) public noFeeWallets;\\n  mapping (address => bool) public managers;\\n  mapping (address => bool) public operators;\\n\\n  struct Operator {\\n    address bridge;\\n    address inToken;\\n    address token;\\n    uint256 amount;\\n    address dstAddress;\\n    address receiver;\\n    address refund;\\n    uint256 desChainId;\\n    address dstToken;\\n    address receiveToken;\\n    uint256 bridgeType;\\n    uint256 basketId;\\n  }\\n\\n  struct swapPath {\\n    ISwapPlusv1.swapBlock[] path;\\n  }\\n\\n  event BridgePlusFee(address token, uint256 fee, address treasury);\\n  event BridgePlusSwap(address dstAddress, address receiver, uint256 srcChainId, address srcToken, uint256 amount, uint256 dstChainId, address dstToken, address receiveToken, uint256 bridgeType, uint256 basketId);\\n\\n  constructor(\\n    uint256 _chainId,\\n    address _swapRouter,\\n    address _WETH,\\n    address _treasury\\n  ) {\\n    require(_swapRouter != address(0), \\\"BridgePlus: swap router\\\");\\n    require(_WETH != address(0), \\\"BridgePlus: WETH\\\");\\n    require(_treasury != address(0), \\\"BridgePlus: Treasury\\\");\\n\\n    chainId = _chainId;\\n    swapRouter = _swapRouter;\\n    WETH = _WETH;\\n    treasury = _treasury;\\n    managers[msg.sender] = true;\\n  }\\n\\n  modifier onlyManager() {\\n    require(managers[msg.sender], \\\"BridgePlus: !manager\\\");\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    require(operators[msg.sender], \\\"BridgePlus: !operator\\\");\\n    _;\\n  }\\n\\n  receive() external payable {\\n  }\\n\\n  function swap(Operator calldata info, swapPath calldata paths, uint256[] calldata metadata) public payable {\\n    uint256 amount = info.amount;\\n    if (info.inToken != address(0)) {\\n      amount = IERC20(info.inToken).balanceOf(address(this));\\n      IERC20(info.inToken).safeTransferFrom(msg.sender, address(this), info.amount);\\n      amount = IERC20(info.inToken).balanceOf(address(this)) - amount;\\n    }\\n    else if (info.bridgeType == 2) {\\n      uint256 fee = getStgSwapFee(info.bridge, uint16(info.desChainId));\\n      amount -= fee;\\n    }\\n    if (noFeeWallets[msg.sender] == false && info.bridgeType != 0 && info.bridgeType != 4) {\\n      amount = _cutFee(info.inToken, amount);\\n    }\\n    \\n    if (paths.path.length > 0) {\\n      address tokenI = info.inToken;\\n      address tokenO = info.token == address(0) ? WETH : info.token;\\n      if (tokenI == address(0)) {\\n        tokenI = WETH;\\n        IWETH(WETH).deposit{value: amount}();\\n      }\\n      _approveTokenIfNeeded(tokenI, swapRouter, amount);\\n      (, amount) = ISwapPlusv1(swapRouter).swap(tokenI, amount, tokenO, address(this), paths.path);\\n\\n      if (info.token == address(0)) {\\n        IWETH(WETH).withdraw(amount);\\n      }\\n    }\\n\\n    if (info.bridgeType == 0) { // LC bridge\\n      if (info.token != address(0)) {\\n        IWETH(WETH).withdraw(amount);\\n      }\\n      ILCBridgev2(info.bridge).swap{value: amount}(info.dstAddress, info.refund, info.desChainId);\\n    }\\n    else {\\n      _approveTokenIfNeeded(info.token, info.bridge, amount);\\n      if (info.bridgeType == 1) { // CBridge\\n        uint64 nonce = uint64(block.timestamp);\\n        IBridge(info.bridge).send(info.dstAddress, info.token, amount, uint64(info.desChainId), nonce, 1000000);\\n      }\\n      else if (info.bridgeType == 2) { // Stargate\\n        uint256 fee = getStgSwapFee(info.bridge, uint16(info.desChainId));\\n        IStargateRouter(info.bridge).swap{value: fee}(\\n          uint16(info.desChainId),\\n          metadata[0],\\n          metadata[1],\\n          payable(msg.sender),\\n          amount,\\n          0,\\n          IStargateRouter.lzTxObj(0, 0, \\\"0x\\\"),\\n          abi.encodePacked(info.dstAddress),\\n          bytes(\\\"\\\")\\n        );\\n      }\\n      else if (info.bridgeType == 4) {\\n        ILCBridgev2Token(info.bridge).swap{value: 0}(info.dstAddress, amount, info.refund, info.desChainId);\\n      }\\n    }\\n\\n    emit BridgePlusSwap(info.dstAddress, info.receiver, chainId, info.token, amount, info.desChainId, info.dstToken, info.receiveToken, info.bridgeType, info.basketId);\\n  }\\n\\n  function redeem(address bridge, address receiver, address tokenO, address tokenR, uint256 amount, uint256 bridgeType, swapPath[2] calldata paths, uint256[] memory metadata) public payable onlyOperator returns(uint256) {\\n    if (bridgeType == 0 || bridgeType == 4) { // LC bridge\\n      amount = ILCBridgev2(bridge).redeem(address(this), amount, metadata[0], metadata[1], metadata[2]);\\n      if (metadata[2] > 0) {\\n        (bool success, ) = payable(msg.sender).call{value: metadata[2]}(\\\"\\\");\\n        require(success, \\\"BridgePlus: Failed refund oeprator fee\\\");\\n      }\\n    }\\n\\n    if (metadata[3] > 0) { // operator fee\\n      amount -= metadata[3];\\n      if (paths[1].path.length > 0) {\\n        _approveTokenIfNeeded(tokenO, swapRouter, metadata[3]);\\n        (, metadata[3]) = ISwapPlusv1(swapRouter).swap(tokenO, metadata[3], WETH, address(this), paths[1].path);\\n      }\\n      if (tokenO != address(0)) {\\n        IWETH(WETH).withdraw(metadata[3]);\\n      }\\n      (bool success, ) = payable(msg.sender).call{value: metadata[3]}(\\\"\\\");\\n      require(success, \\\"BridgePlus: Failed operator fee\\\");\\n    }\\n\\n    if (paths[0].path.length > 0) {\\n      address tokenI = tokenO;\\n      address tokenSO = tokenR == address(0) ? WETH : tokenR;\\n      if (tokenI == address(0)) {\\n        tokenI = WETH;\\n        IWETH(WETH).deposit{value: amount}();\\n      }\\n      _approveTokenIfNeeded(tokenI, swapRouter, amount);\\n      (, amount) = ISwapPlusv1(swapRouter).swap(tokenI, amount, tokenSO, address(this), paths[0].path);\\n    }\\n\\n    if (tokenR == address(0)) {\\n      if (tokenO != address(0)) {\\n        IWETH(WETH).withdraw(amount);\\n      }\\n      (bool success, ) = payable(receiver).call{value: amount}(\\\"\\\");\\n      require(success, \\\"BridgePlus: Failed redeem\\\");\\n    }\\n    else {\\n      IERC20(tokenR).safeTransfer(receiver, amount);\\n    }\\n    return amount;\\n  }\\n\\n  function refundCbridge(\\n    address cbridge,\\n    bytes calldata _wdmsg,\\n    bytes[] calldata _sigs,\\n    address[] calldata _signers,\\n    uint256[] calldata _powers,\\n    address account,\\n    address _token\\n  ) public {\\n    IBridge(cbridge).withdraw(_wdmsg, _sigs, _signers, _powers);\\n\\n    if (_token == address(0)) {\\n      (bool success, ) = payable(account).call{value: address(this).balance}(\\\"\\\");\\n      require(success, \\\"BridgePlus: refund cbrdige\\\");\\n    }\\n    else {\\n      IERC20(_token).safeTransfer(account, IERC20(_token).balanceOf(address(this)));\\n    }\\n  }\\n\\n  function getStgSwapFee(address bridge, uint16 _desChain) public view returns(uint256) {\\n    (uint256 swFee, ) = IStargateRouter(bridge).quoteLayerZeroFee(\\n      _desChain,\\n      1,\\n      bytes(\\\"0x\\\"),\\n      bytes(\\\"0x\\\"),\\n      IStargateRouter.lzTxObj(0, 0, \\\"0x\\\")\\n    );\\n    return swFee * stargateSwapFeeMultipler / stargateSwapFeeDivider;\\n  }\\n\\n  function setManager(address account, bool access) public onlyOwner {\\n    managers[account] = access;\\n  }\\n\\n  function setOperator(address account, bool access) public onlyOwner {\\n    operators[account] = access;\\n  }\\n\\n  function setNoFeeWallets(address account, bool access) public onlyManager {\\n    noFeeWallets[account] = access;\\n  }\\n\\n  function setSwapFee(uint256 _swapFee) public onlyManager {\\n    swapFee = _swapFee;\\n  }\\n\\n  function setTreasury(address _treasury) public onlyManager {\\n    treasury = _treasury;\\n  }\\n\\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) private {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).safeApprove(spender, 0);\\n      IERC20(token).safeApprove(spender, type(uint256).max);\\n    }\\n  }\\n\\n  function _cutFee(address _token, uint256 _amount) internal returns(uint256) {\\n    if (_amount > 0) {\\n      uint256 fee = _amount * swapFee / coreDecimal;\\n      if (fee > 0) {\\n        if (_token == address(0)) {\\n          (bool success, ) = payable(treasury).call{value: fee}(\\\"\\\");\\n          require(success, \\\"BridgePlus: Failed cut fee\\\");\\n        }\\n        else {\\n          IERC20(_token).safeTransfer(treasury, fee);\\n        }\\n        emit BridgePlusFee(_token, fee, treasury);\\n      }\\n      return _amount - fee;\\n    }\\n    return 0;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"BridgePlusFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"}],\"name\":\"BridgePlusSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coreDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_desChain\",\"type\":\"uint16\"}],\"name\":\"getStgSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noFeeWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenR\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeType\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BridgePlus.swapPath[2]\",\"name\":\"paths\",\"type\":\"tuple[2]\"},{\"internalType\":\"uint256[]\",\"name\":\"metadata\",\"type\":\"uint256[]\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cbridge\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_wdmsg\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"refundCbridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setNoFeeWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateSwapFeeDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateSwapFeeMultipler\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"desChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bridgeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"}],\"internalType\":\"struct BridgePlus.Operator\",\"name\":\"info\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BridgePlus.swapPath\",\"name\":\"paths\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"metadata\",\"type\":\"uint256[]\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BridgePlus", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000380000000000000000000000004444457406b815253080bc38b084aa1a14faadbf000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000e839eb365cad6ca88b8d519d1475fa74eb9e8485", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}