{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/pokedx-imports.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n */\\n\\npragma solidity ^0.8.7;\\n\\n//////////////////////////////////////////////////////////////////////////////////////////\\n ///////////////////////////////Necessary imports////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                \\\"Address: low-level delegate call failed\\\"\\n            );\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    uint256 private _lockTime;\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    function getUnlockTime() public view returns (uint256) {\\n        return _lockTime;\\n    }\\n\\n    function lock(uint256 time) public virtual onlyOwner {\\n        _previousOwner = _owner;\\n        _owner = address(0);\\n        _lockTime = block.timestamp + time;\\n        emit OwnershipTransferred(_owner, address(0));\\n    }\\n\\n    function unlock() public virtual {\\n        require(\\n            _previousOwner == msg.sender,\\n            \\\"Only the previous owner can unlock onwership\\\"\\n        );\\n        require(block.timestamp > _lockTime, \\\"The contract is still locked\\\");\\n        emit OwnershipTransferred(_owner, _previousOwner);\\n        _owner = _previousOwner;\\n    }\\n}\\n\\n\\ninterface IPancakeV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\ninterface IPancakeV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\nabstract contract Pausable is Context {\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\"\r\n    },\r\n    \"/contracts/pokedx-token.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * \\n *\\n * author: 0xSharp, PokeDX <cryptosharp91@gmail.com>\\n * discord: https://discord.gg/hfrT7fK4\\n * telegram: https://t.me/dextalks\\n * website: https://pokedx.app\\n * twitter: https://twitter.com/pokedxapp\\n * PokeDX v1.0\\n *\\n * This contract is inspired by and in part a rewrite a of reflect.finance and Safemoon, that aims to:\\n * - fix a majority of the issues reported in the Certik Safemoon audit (e.g. SSL-03)\\n *      https://www.certik.org/projects/safemoon\\n * - Improve the reflection mechanism \\n * - exclude burn wallet from reflection\\n * - time-lock lp tokens from auto lp\\n * - Add flexibility to the contract for future governance compatibility\\n * - make it easier to maintain the code and develop it further\\n * - remove redundant code\\n * - optimize gas\\n *\\n *\\n *    __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___        _______/\\\\\\\\\\\\\\\\\\\\______        __/\\\\\\\\\\\\________/\\\\\\\\\\\\_        __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_        __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\____        __/\\\\\\\\\\\\_______/\\\\\\\\\\\\_\\n *     _\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_        _____/\\\\\\\\\\\\///\\\\\\\\\\\\____        _\\\\/\\\\\\\\\\\\_____/\\\\\\\\\\\\//__        _\\\\/\\\\\\\\\\\\///////////__        _\\\\/\\\\\\\\\\\\////////\\\\\\\\\\\\__        _\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\n *      _\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_        ___/\\\\\\\\\\\\/__\\\\///\\\\\\\\\\\\__        _\\\\/\\\\\\\\\\\\__/\\\\\\\\\\\\//_____        _\\\\/\\\\\\\\\\\\_____________        _\\\\/\\\\\\\\\\\\______\\\\//\\\\\\\\\\\\_        ___\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/____\\n *       _\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__        __/\\\\\\\\\\\\______\\\\//\\\\\\\\\\\\_        _\\\\/\\\\\\\\\\\\\\\\\\\\\\\\//\\\\\\\\\\\\_____        _\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____        _\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_        _____\\\\//\\\\\\\\\\\\\\\\______\\n *        _\\\\/\\\\\\\\\\\\/////////____        _\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_        _\\\\/\\\\\\\\\\\\//_\\\\//\\\\\\\\\\\\____        _\\\\/\\\\\\\\\\\\///////______        _\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_        ______\\\\/\\\\\\\\\\\\\\\\______\\n *         _\\\\/\\\\\\\\\\\\_____________        _\\\\//\\\\\\\\\\\\______/\\\\\\\\\\\\__        _\\\\/\\\\\\\\\\\\____\\\\//\\\\\\\\\\\\___        _\\\\/\\\\\\\\\\\\_____________        _\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_        ______/\\\\\\\\\\\\\\\\\\\\\\\\_____\\n *          _\\\\/\\\\\\\\\\\\_____________        __\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\____        _\\\\/\\\\\\\\\\\\_____\\\\//\\\\\\\\\\\\__        _\\\\/\\\\\\\\\\\\_____________        _\\\\/\\\\\\\\\\\\_______/\\\\\\\\\\\\__        ____/\\\\\\\\\\\\////\\\\\\\\\\\\___\\n *           _\\\\/\\\\\\\\\\\\_____________        ____\\\\///\\\\\\\\\\\\\\\\\\\\/_____        _\\\\/\\\\\\\\\\\\______\\\\//\\\\\\\\\\\\_        _\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_        _\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/___        __/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\_\\n *            _\\\\///______________        ______\\\\/////_______        _\\\\///________\\\\///__        _\\\\///////////////__        _\\\\////////////_____        _\\\\///_______\\\\///__\\n*\\n* SPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./pokedx-imports.sol\\\";\\n\\nabstract contract Tokenomics {\\n\\n    // --------------------- Token Settings ------------------- //\\n\\n    string internal constant NAME = \\\"PokeDX\\\";\\n    string internal constant SYMBOL = \\\"PDX\\\";\\n\\n    uint16 internal constant FEES_DIVISOR = 10**3;\\n    uint8 internal constant DECIMALS = 9;\\n    uint256 internal constant ZEROES = 10**DECIMALS;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 internal constant TOTAL_SUPPLY = 30000000 * ZEROES;\\n    uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\\n\\n    /**\\n     * @dev Set the maximum transaction amount allowed in a transfer.\\n     */\\n    uint256 internal constant maxTransactionAmount = TOTAL_SUPPLY / 200; // 0.5% of the total supply(150,000)\\n\\n    /**\\n     * @dev Set the number of tokens to swap and add to liquidity.\\n     *\\n     * Whenever the contract's balance reaches 30,000 PDX the swap & liquify will be\\n     * executed in the very next transfer.\\n     *\\n     */\\n    uint256 internal constant numberOfTokensToSwapToLiquidity =\\n        TOTAL_SUPPLY / 1000; // 0.1% of the total supply\\n\\n    // --------------------- Fees Settings ------------------- //\\n\\n    address internal burnAddress = 0x000000000000000000000000000000000000dEaD;\\n\\n    enum FeeType {\\n        Liquidity,\\n        Rfi,\\n        Burn\\n    }\\n    struct Fee {\\n        uint256 position;\\n        FeeType name;\\n        uint256 value;\\n        address recipient;\\n        uint256 total;\\n    }\\n\\n    Fee[] internal fees;\\n    uint256 public sumOfFees;\\n\\n    constructor() {\\n        _addFees();\\n    }\\n\\n    function _addFee(\\n        uint256 position,\\n        FeeType name,\\n        uint256 value,\\n        address recipient\\n    ) private {\\n        fees.push(Fee(position, name, value, recipient, 0));\\n        sumOfFees += value;\\n    }\\n\\n    function _addFees() private {\\n        /**\\n         * The value of fees is given in part per 1000 (based on the value of FEES_DIVISOR),\\n         * e.g. for 5% use 50, for 3.5% use 35, etc.\\n         */\\n        _addFee(1,FeeType.Rfi, 20, address(this));\\n        _addFee(2,FeeType.Liquidity, 20, address(this));\\n        _addFee(3,FeeType.Burn, 0, burnAddress );\\n    }\\n\\n    function _getFeesCount() internal view returns (uint256) {\\n        return fees.length;\\n    }\\n\\n    function _getFeeStruct(uint256 index) private view returns (Fee storage) {\\n        require(\\n            index >= 0 && index < fees.length,\\n            \\\"FeesSettings._getFeeStruct: Fee index out of bounds\\\"\\n        );\\n        return fees[index];\\n    }\\n\\n    function _getFee(uint256 index)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            FeeType,\\n            uint256,\\n            address,\\n            uint256\\n        )\\n    {\\n        Fee memory fee = _getFeeStruct(index);\\n        return (fee.position,fee.name, fee.value, fee.recipient, fee.total);\\n    }\\n\\n    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\\n        Fee storage fee = _getFeeStruct(index);\\n        fee.total = fee.total + amount;\\n    }\\n\\n    // function getCollectedFeeTotal(uint256 index) external view returns (uint256){\\n    function getCollectedFeeTotal(uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Fee memory fee = _getFeeStruct(index);\\n        return fee.total;\\n    }\\n\\n\\n}\\n\\n//////////////////////////////////////////////////////////////////////////////////////////\\n ///////////////////////////////BaseRfiToken START HERE////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////\\n\\nabstract contract BaseRfiToken is\\n    IERC20,\\n    IERC20Metadata,\\n    Ownable,\\n    Pausable,\\n    Tokenomics\\n{\\n    using Address for address;\\n    \\n    mapping(address => uint256) internal _reflectedBalances;\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => mapping(address => uint256)) internal _allowances;\\n\\n    mapping(address => bool) internal _isExcludedFromFee;\\n    mapping(address => bool) internal _isExcludedFromRewards;\\n    address[] private _excluded;\\n    bool private _paused;\\n\\n    constructor() {\\n        _reflectedBalances[owner()] = _reflectedSupply;\\n\\n        // exclude owner and this contract from fee\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n\\n        // exclude the owner and this contract from rewards\\n        _exclude(owner());\\n        _exclude(address(this));\\n\\n        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\\n    }\\n\\n    /** Functions required by IERC20Metadat **/\\n    function name() external pure override returns (string memory) {\\n        return NAME;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return SYMBOL;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    /** Functions required by IERC20Metadat - END **/\\n    /** Functions required by IERC20 **/\\n    function totalSupply() external pure override returns (uint256) {\\n        return TOTAL_SUPPLY;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcludedFromRewards[account]) return _balances[account];\\n        return tokenFromReflection(_reflectedBalances[account]);\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()] -\\n                amount\\n        );\\n        return true;\\n    }\\n\\n    /** Functions required by IERC20 - END **/\\n\\n    /**\\n     * @dev this is really a \\\"soft\\\" burn (total supply is not reduced). RFI holders\\n     * get two benefits from burning tokens:\\n     *\\n     * 1) Tokens in the burn address increase the % of tokens held by holders not\\n     *    excluded from rewards (assuming the burn address is excluded)\\n     * 2) Tokens in the burn address cannot be sold (which in turn draing the\\n     *    liquidity pool)\\n     *\\n     *\\n     * In RFI holders already get % of each transaction so the value of their tokens\\n     * increases (in a way). Therefore there is really no need to do a \\\"hard\\\" burn\\n     * (reduce the total supply). What matters (in RFI) is to make sure that a large\\n     * amount of tokens cannot be sold = draining the liquidity pool = lowering the\\n     * value of tokens holders own. For this purpose, transfering tokens to a (vanity)\\n     * burn address is the most appropriate way to \\\"burn\\\".\\n     *\\n     * There is an extra check placed into the `transfer` function to make sure the\\n     * burn address cannot withdraw the tokens is has (although the chance of someone\\n     * having/finding the private key is virtually zero).\\n     */\\n    function burn(uint256 amount) external {\\n        address sender = _msgSender();\\n        require(\\n            sender != address(0),\\n            \\\"BaseRfiToken: burn from the zero address\\\"\\n        );\\n        require(\\n            sender != address(burnAddress),\\n            \\\"BaseRfiToken: burn from the burn address\\\"\\n        );\\n\\n        uint256 balance = balanceOf(sender);\\n        require(balance >= amount, \\\"BaseRfiToken: burn amount exceeds balance\\\");\\n\\n        uint256 reflectedAmount = amount * _getCurrentRate();\\n\\n        // remove the amount from the sender's balance first\\n        _reflectedBalances[sender] = _reflectedBalances[sender] -\\n            reflectedAmount;\\n        if (_isExcludedFromRewards[sender])\\n            _balances[sender] = _balances[sender] - amount;\\n\\n        _burnTokens(sender, amount, reflectedAmount);\\n    }\\n\\n    /**\\n     * @dev \\\"Soft\\\" burns the specified amount of tokens by sending them\\n     * to the burn address\\n     */\\n    function _burnTokens(\\n        address sender,\\n        uint256 tBurn,\\n        uint256 rBurn\\n    ) internal {\\n        /**\\n         * @dev Do not reduce _totalSupply and/or _reflectedSupply. (soft) burning by sending\\n         * tokens to the burn address (which should be excluded from rewards) is sufficient\\n         * in RFI\\n         */\\n        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress] +\\n            rBurn;\\n        if (_isExcludedFromRewards[burnAddress])\\n            _balances[burnAddress] = _balances[burnAddress] + tBurn;\\n\\n        /**\\n         * @dev Emit the event so that the burn address balance is updated (on bscscan)\\n         */\\n        emit Transfer(sender, burnAddress, tBurn);\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] -\\n                subtractedValue\\n        );\\n        return true;\\n    }\\n\\n    function isExcludedFromReward(address account)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return _isExcludedFromRewards[account];\\n    }\\n\\n    /**\\n     * @dev Calculates and returns the reflected amount for the given amount with or without\\n     * the transfer fees (deductTransferFee true/false)\\n     */\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(tAmount <= TOTAL_SUPPLY, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , , ) = _getValues(tAmount, 0);\\n            return rAmount;\\n        } else {\\n            (, uint256 rTransferAmount, , , ) = _getValues(\\n                tAmount,\\n                _getSumOfFees()\\n            );\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\\n     */\\n    function tokenFromReflection(uint256 rAmount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(\\n            rAmount <= _reflectedSupply,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getCurrentRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function excludeFromReward(address account) external onlyOwner {\\n        require(!_isExcludedFromRewards[account], \\\"Account is not included\\\");\\n        _exclude(account);\\n    }\\n\\n    function _exclude(address account) internal {\\n        if (_reflectedBalances[account] > 0) {\\n            _balances[account] = tokenFromReflection(\\n                _reflectedBalances[account]\\n            );\\n        }\\n        _isExcludedFromRewards[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner {\\n        require(_isExcludedFromRewards[account], \\\"Account is not excluded\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _balances[account] = 0;\\n                _isExcludedFromRewards[account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function setExcludedFromFee(address account, bool value)\\n        external\\n        onlyOwner\\n    {\\n        _isExcludedFromFee[account] = value;\\n    }\\n\\n    function isExcludedFromFee(address account) public view returns (bool) {\\n        return _isExcludedFromFee[account];\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(\\n            owner != address(0),\\n            \\\"BaseRfiToken: approve from the zero address\\\"\\n        );\\n        require(\\n            spender != address(0),\\n            \\\"BaseRfiToken: approve to the zero address\\\"\\n        );\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     */\\n    function _isUnlimitedSender(address account) internal view returns (bool) {\\n        // the owner should be the only whitelisted sender\\n        return (account == owner());\\n    }\\n\\n    /**\\n     */\\n    function _isUnlimitedRecipient(address account)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // the owner should be a white-listed recipient\\n        // and anyone should be able to burn as many tokens as\\n        // he/she wants\\n        return (account == owner() || account == burnAddress);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        require(\\n            sender != address(0),\\n            \\\"BaseRfiToken: transfer from the zero address\\\"\\n        );\\n        require(\\n            recipient != address(0),\\n            \\\"BaseRfiToken: transfer to the zero address\\\"\\n        );\\n        require(\\n            sender != address(burnAddress),\\n            \\\"BaseRfiToken: transfer from the burn address\\\"\\n        );\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n\\n        // indicates whether or not feee should be deducted from the transfer\\n        bool takeFee = true;\\n\\n        if (paused()) {\\n            takeFee = false;\\n        } else {\\n            /**\\n             * Check the amount is within the max allowed limit as long as a\\n             * unlimited sender/recepient is not involved in the transaction\\n             */\\n            if (\\n                amount > maxTransactionAmount &&\\n                !_isUnlimitedSender(sender) &&\\n                !_isUnlimitedRecipient(recipient)\\n            ) {\\n                revert(\\\"Transfer amount exceeds the maxTxAmount.\\\");\\n            }\\n        }\\n\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {\\n            takeFee = false;\\n        }\\n\\n        _beforeTokenTransfer(sender, recipient, amount, takeFee);\\n        _transferTokens(sender, recipient, amount, takeFee);\\n    }\\n\\n    function _transferTokens(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) private {\\n        /**\\n         * We don't need to know anything about the individual fees here\\n         * (like Safemoon does with `_getValues`). All that is required\\n         * for the transfer is the sum of all fees to calculate the % of the total\\n         * transaction amount which should be transferred to the recipient.\\n         *\\n         * The `_takeFees` call will/should take care of the individual fees\\n         */\\n        uint256 sumOfFees = _getSumOfFees();\\n        if (!takeFee) {\\n            sumOfFees = 0;\\n        }\\n\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 tAmount,\\n            uint256 tTransferAmount,\\n            uint256 currentRate\\n        ) = _getValues(amount, sumOfFees);\\n\\n        /**\\n         * Sender's and Recipient's reflected balances must be always updated regardless of\\n         * whether they are excluded from rewards or not.\\n         */\\n        _reflectedBalances[sender] = _reflectedBalances[sender] - rAmount;\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient] +\\n            rTransferAmount;\\n\\n        /**\\n         * Update the true/nominal balances for excluded accounts\\n         */\\n        if (_isExcludedFromRewards[sender]) {\\n            _balances[sender] = _balances[sender] - tAmount;\\n        }\\n        if (_isExcludedFromRewards[recipient]) {\\n            _balances[recipient] = _balances[recipient] + tTransferAmount;\\n        }\\n\\n        _takeFees(amount, currentRate, sumOfFees);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _takeFees(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 sumOfFees\\n    ) private {\\n        if (sumOfFees > 0 && !paused()) {\\n            _takeTransactionFees(amount, currentRate);\\n        }\\n    }\\n\\n    function _getValues(uint256 tAmount, uint256 feesSum)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 tTotalFees = tAmount * feesSum / FEES_DIVISOR;\\n        uint256 tTransferAmount = tAmount - tTotalFees;\\n        uint256 currentRate = _getCurrentRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rTotalFees = tTotalFees * currentRate;\\n        uint256 rTransferAmount = rAmount - rTotalFees;\\n\\n        return (\\n            rAmount,\\n            rTransferAmount,\\n            tAmount,\\n            tTransferAmount,\\n            currentRate\\n        );\\n    }\\n\\n    function _getCurrentRate() internal view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply / tSupply;\\n    }\\n\\n    function _getCurrentSupply() internal view returns (uint256, uint256) {\\n        uint256 rSupply = _reflectedSupply;\\n        uint256 tSupply = TOTAL_SUPPLY;\\n\\n        /**\\n         * The code below removes balances of addresses excluded from rewards from\\n         * rSupply and tSupply, which effectively increases the % of transaction fees\\n         * delivered to non-excluded holders\\n         */\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (\\n                _reflectedBalances[_excluded[i]] > rSupply ||\\n                _balances[_excluded[i]] > tSupply\\n            ) return (_reflectedSupply, TOTAL_SUPPLY);\\n            rSupply = rSupply - _reflectedBalances[_excluded[i]];\\n            tSupply = tSupply - _balances[_excluded[i]];\\n        }\\n        if (tSupply == 0 || rSupply < _reflectedSupply / TOTAL_SUPPLY)\\n            return (_reflectedSupply, TOTAL_SUPPLY);\\n        return (rSupply, tSupply);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens.\\n     */\\n    function _beforeTokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) internal virtual;\\n\\n    /**\\n     * @dev Returns the total sum of fees to be processed in each transaction.\\n     *\\n     * To separate concerns this contract (class) will take care of ONLY handling RFI, i.e.\\n     * changing the rates and updating the holder's balance (via `_redistribute`).\\n     * It is the responsibility of the dev/user to handle all other fees and taxes\\n     * in the appropriate contracts (classes).\\n     */\\n    function _getSumOfFees()\\n        internal\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    /**\\n     * @dev A delegate which should return true if the given address is the V2 Pair and false otherwise\\n     */\\n    function _isV2Pair(address account) internal view virtual returns (bool);\\n\\n    /**\\n     * @dev Redistributes the specified amount among the current holders via the reflect.finance\\n     * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\\n     * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`.\\n     * This is the bit of clever math which allows rfi to redistribute the fee without\\n     * having to iterate through all holders.\\n     *\\n     * Visit our discord at https://discord.gg/dAmr6eUTpM\\n     */\\n    function _redistribute(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 fee,\\n        uint256 index\\n    ) internal {\\n        uint256 tFee = amount * fee / FEES_DIVISOR;\\n        uint256 rFee = tFee * currentRate;\\n\\n        _reflectedSupply = _reflectedSupply - rFee;\\n        _addFeeCollectedAmount(index, tFee);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before the `Transfer` event is emitted if fees are enabled for the transfer\\n     */\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate)\\n        internal\\n        virtual;\\n\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n}\\n\\n\\n//////////////////////////////////////////////////////////////////////////////////////////\\n ///////////////////////////////Liquifier START HERE////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////\\n\\nabstract contract Liquifier is Ownable {\\n\\n    uint256 private withdrawableBalance;\\n    \\n    address private _routerAddress;\\n\\n    IPancakeV2Router internal _router;\\n    address internal _pair;\\n\\n    bool private inSwapAndLiquify;\\n    bool private swapAndLiquifyEnabled = true;\\n\\n    uint256 private maxTransactionAmount;\\n    uint256 private numberOfTokensToSwapToLiquidity;\\n\\n    address private LPReceiver;\\n\\n    modifier lockTheSwap() {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    event RouterSet(address indexed router);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiquidity\\n    );\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event LiquidityAdded(\\n        uint256 tokenAmountSent,\\n        uint256 ethAmountSent,\\n        uint256 liquidity\\n    );\\n    event LPReceiverChanged(address LPReceiver);\\n    event NumberOfTokensToSwapToLiquidityChanged(uint256 tokenAmount);\\n\\n    receive() external payable {}\\n\\n    function _setNumberOfTokensToSwapToLiquidity(uint256 tokenAmount) external onlyOwner{\\n        numberOfTokensToSwapToLiquidity = tokenAmount;\\n        emit NumberOfTokensToSwapToLiquidityChanged(tokenAmount);\\n\\n    }\\n    function showNumberOfTokensToSwapToLiquidity() external view returns(uint256) {\\n        return numberOfTokensToSwapToLiquidity;\\n    }\\n\\n    function initializeLiquiditySwapper(\\n        address env,\\n        uint256 maxTx,\\n        uint256 liquifyAmount\\n    ) internal {\\n            _setRouterAddress(env);\\n        \\n\\n        maxTransactionAmount = maxTx;\\n        numberOfTokensToSwapToLiquidity = liquifyAmount;\\n    }\\n\\n    /**\\n     * NOTE: passing the `contractTokenBalance` here is preferred to creating `balanceOfDelegate`\\n     */\\n    function liquify(uint256 contractTokenBalance, address sender) internal {\\n        if (contractTokenBalance >= maxTransactionAmount)\\n            contractTokenBalance = maxTransactionAmount;\\n\\n        bool isOverRequiredTokenBalance = (contractTokenBalance >=\\n            numberOfTokensToSwapToLiquidity);\\n\\n        /**\\n         * - first check if the contract has collected enough tokens to swap and liquify\\n         * - then check swap and liquify is enabled\\n         * - then make sure not to get caught in a circular liquidity event\\n         * - finally, don't swap & liquify if the sender is the uniswap pair\\n         */\\n        if (\\n            isOverRequiredTokenBalance &&\\n            swapAndLiquifyEnabled &&\\n            !inSwapAndLiquify &&\\n            (sender != _pair)\\n        ) {\\n            // TODO check if the `(sender != _pair)` is necessary because that basically\\n            // stops swap and liquify for all \\\"buy\\\" transactions\\n            _swapAndLiquify(contractTokenBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev sets the router address and created the router, factory pair to enable\\n     * swapping and liquifying (contract) tokens\\n     */\\n    function _setRouterAddress(address router) private {\\n        IPancakeV2Router _newPancakeRouter = IPancakeV2Router(router);\\n        _pair = IPancakeV2Factory(_newPancakeRouter.factory()).createPair(\\n            address(this),\\n            _newPancakeRouter.WETH()\\n        );\\n        _router = _newPancakeRouter;\\n        emit RouterSet(router);\\n    }\\n\\n    function _swapAndLiquify(uint256 amount) private lockTheSwap {\\n        // split the contract balance into halves\\n        uint256 half = amount / 2;\\n        uint256 otherHalf = amount - half;\\n\\n        // capture the contract's current ETH balance.\\n        // this is so that we can capture exactly the amount of ETH that the\\n        // swap creates, and not make the liquidity event include any ETH that\\n        // has been manually sent to the contract\\n        uint256 initialBalance = address(this).balance;\\n\\n        // swap tokens for ETH\\n        _swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\\n\\n        // how much ETH did we just swap into?\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        // add liquidity to uniswap\\n        _addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function _swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _router.WETH();\\n\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\n\\n        // make the swap\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            // The minimum amount of output tokens that must be received for the transaction not to revert.\\n            // 0 = accept any amount (slippage is inevitable)\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function setLPReceiver(address receiver) external onlyOwner{\\n        LPReceiver = receiver;\\n        emit LPReceiverChanged(LPReceiver);\\n    }\\n    function showLPReceiver() external view returns(address){\\n        return LPReceiver;\\n    }\\n\\n    \\n\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        // approve token transfer to cover all possible scenarios\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\n\\n        // add the liquidity\\n        (uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity) = _router\\n            .addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            // Bounds the extent to which the WETH/token price can go up before the transaction reverts.\\n            // Must be <= amountTokenDesired; 0 = accept any amount (slippage is inevitable)\\n            0,\\n            // Bounds the extent to which the token/WETH price can go up before the transaction reverts.\\n            // 0 = accept any amount (slippage is inevitable)\\n            0,\\n            // this is a centralized risk if the owner's account is ever compromised (see Certik SSL-04)\\n            // owner(),\\n            LPReceiver,\\n            block.timestamp\\n        );\\n\\n        // fix the forever locked BNBs as per the certik's audit\\n        /**\\n         * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB.\\n         * For every swapAndLiquify function call, a small amount of BNB remains in the contract.\\n         * This amount grows over time with the swapAndLiquify function being called throughout the life\\n         * of the contract. The Safemoon contract does not contain a method to withdraw these funds,\\n         * and the BNB will be locked in the Safemoon contract forever.\\n         */\\n        withdrawableBalance = address(this).balance;\\n        emit LiquidityAdded(tokenAmountSent, ethAmountSent, liquidity);\\n    }\\n\\n    /**\\n     * @dev Sets the uniswapV2 pair (router & factory) for swapping and liquifying tokens\\n     */\\n    function setRouterAddress(address router) external onlyOwner {\\n        _setRouterAddress(router);\\n    }\\n\\n    /**\\n     * @dev Sends the swap and liquify flag to the provided value. If set to `false` tokens collected in the contract will\\n     * NOT be converted into liquidity.\\n     */\\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyOwner {\\n        swapAndLiquifyEnabled = enabled;\\n        emit SwapAndLiquifyEnabledUpdated(swapAndLiquifyEnabled);\\n    }\\n\\n    /**\\n     * @dev The owner can withdraw ETH(BNB) collected in the contract from `swapAndLiquify`\\n     * or if someone (accidentally) sends ETH/BNB directly to the contract.\\n     *\\n     * Note: This addresses the contract flaw pointed out in the Certik Audit of Safemoon (SSL-03):\\n     *\\n     * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB.\\n     * For every swapAndLiquify function call, a small amount of BNB remains in the contract.\\n     * This amount grows over time with the swapAndLiquify function being called\\n     * throughout the life of the contract. The Safemoon contract does not contain a method\\n     * to withdraw these funds, and the BNB will be locked in the Safemoon contract forever.\\n     * https://www.certik.org/projects/safemoon\\n     */\\n    function withdrawLockedBNB(address payable recipient) external onlyOwner {\\n        require(\\n            recipient != address(0),\\n            \\\"Cannot withdraw the BNB balance to the zero address\\\"\\n        );\\n        require(\\n            withdrawableBalance > 0,\\n            \\\"The BNB balance must be greater than 0\\\"\\n        );\\n\\n        // prevent re-entrancy attacks\\n        uint256 amount = withdrawableBalance;\\n        withdrawableBalance = 0;\\n        recipient.transfer(amount);\\n    }\\n\\n    /**\\n     * @dev Use this delegate instead of having (unnecessarily) extend `BaseRfiToken` to gained access\\n     * to the `_approve` function.\\n     */\\n    function _approveDelegate(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual;\\n}\\n\\n//////////////////////////////////////////////////////////////////////////////////////////\\n ///////////////////////////////PokeDX START HERE////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////\\n\\ncontract PokeDX is BaseRfiToken, Liquifier {\\n\\n    event FeeIncreased(uint256 FeePosition, uint256 AddedValue, uint256 FeeTotal);\\n    event FeeDecreased(uint256 FeePosition, uint256 AddedValue, uint256 FeeTotal);\\n\\n\\n    constructor(address _env) { \\n        initializeLiquiditySwapper(\\n            _env,\\n            maxTransactionAmount,\\n            numberOfTokensToSwapToLiquidity\\n        );\\n\\n        // exclude the pair address from rewards - we don't want to redistribute\\n        // tx fees to these two; redistribution is only for holders, dah!\\n        _exclude(_pair);\\n        _exclude(burnAddress);\\n        _approve(owner(),address(_router), ~uint256(0));\\n    }\\n\\n    function _isV2Pair(address account) internal view override returns (bool) {\\n        return (account == _pair);\\n    }\\n\\n    function _getSumOfFees()\\n        internal\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return sumOfFees;\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address sender,\\n        address,\\n        uint256,\\n        bool\\n    ) internal override {\\n        if (!paused()) {\\n            uint256 contractTokenBalance = balanceOf(address(this));\\n            liquify(contractTokenBalance, sender);\\n        }\\n    }\\n\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate)\\n        internal\\n        override\\n    {\\n        if (paused()) {\\n            return;\\n        }\\n\\n        uint256 feesCount = _getFeesCount();\\n        for (uint256 index = 0; index < feesCount; index++) {\\n            (,FeeType name, uint256 value, address recipient, ) = _getFee(index);\\n            // no need to check value < 0 as the value is uint (i.e. from 0 to 2^256-1)\\n            if (value == 0) continue;\\n\\n            if (name == FeeType.Rfi) {\\n                _redistribute(amount, currentRate, value, index);\\n            } else if (name == FeeType.Burn) {\\n                _burn(amount, currentRate, value, index);\\n            } else {\\n                _takeFee(amount, currentRate, value, recipient, index);\\n            }\\n        }\\n    }\\n\\n    function _burn(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 fee,\\n        uint256 index\\n    ) private {\\n        uint256 tBurn = amount *fee / FEES_DIVISOR;\\n        uint256 rBurn = tBurn * currentRate;\\n\\n        _burnTokens(address(this), tBurn, rBurn);\\n        _addFeeCollectedAmount(index, tBurn);\\n    }\\n\\n    function _takeFee(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 fee,\\n        address recipient,\\n        uint256 index\\n    ) private {\\n        uint256 tAmount = amount * fee / FEES_DIVISOR;\\n        uint256 rAmount = tAmount * currentRate;\\n\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient] +\\n            rAmount;\\n        if (_isExcludedFromRewards[recipient])\\n            _balances[recipient] = _balances[recipient] + tAmount;\\n\\n        _addFeeCollectedAmount(index, tAmount);\\n    }\\n\\n\\n    function _approveDelegate(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal override {\\n        _approve(owner, spender, amount);\\n    }\\n\\n    function showFee(uint256 index) external view returns(uint256,\\n            FeeType,\\n            uint256,\\n            address,\\n            uint256){\\n        return _getFee(index);\\n    }\\n\\n    function increaseFee(uint256 index, uint256 addedValue ) external onlyOwner{\\n        require ((_getSumOfFees() + addedValue) <= 80, \\\"Maximum 8% fee is allowed!\\\" );\\n        uint256 _sumOfFees = sumOfFees;\\n        uint256 updatedSumOfFees = _sumOfFees + addedValue;\\n        sumOfFees = updatedSumOfFees;\\n        fees[index].value += addedValue;\\n        emit FeeIncreased(index,  addedValue,  sumOfFees);\\n    }\\n    function decreaseFee(uint256 index, uint256 subtractedValue ) external onlyOwner{\\n        require((_getSumOfFees() - subtractedValue ) >= 0, \\\"Can't really go negative in there...\\\" );\\n        uint256 _sumOfFees = sumOfFees;\\n        uint256 updatedSumOfFees = _sumOfFees - subtractedValue; \\n        sumOfFees = updatedSumOfFees;\\n        fees[index].value -= subtractedValue;\\n        emit FeeDecreased( index,  subtractedValue,  sumOfFees);\\n        \\n    }\\n\\n    \\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_env\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"FeePosition\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"AddedValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"FeeTotal\",\"type\":\"uint256\"}],\"name\":\"FeeDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"FeePosition\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"AddedValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"FeeTotal\",\"type\":\"uint256\"}],\"name\":\"FeeIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"LPReceiver\",\"type\":\"address\"}],\"name\":\"LPReceiverChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"NumberOfTokensToSwapToLiquidityChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"RouterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_setNumberOfTokensToSwapToLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setLPReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"showFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum Tokenomics.FeeType\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showLPReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showNumberOfTokensToSwapToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawLockedBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PokeDX", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}