{"SourceCode": "{\"Dao.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\ncontract Dao{\\n    address public __owner;\\n    constructor(){\\n         __owner = msg.sender;\\n    }\\n\\n\\n    modifier onlyOwner() {\\n        require(__owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function withdraw(uint256 amount) \\n        external\\n        onlyOwner\\n    {\\n        payable(msg.sender).transfer(amount);\\n    }\\n\\n    function withdrawToken(IERC20 __token, uint256 amount) \\n        external \\n        onlyOwner\\n    {\\n        IERC20(__token).transfer(msg.sender, amount);\\n    }\\n\\n    receive() external payable{}\\n\\n}\"},\"DRCStruct.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport {IDRCStruct} from \\\"./IDRCStruct.sol\\\";\\ncontract DRCStruct is IDRCStruct{\\n\\n    struct AccountStruct{\\n        address parent;\\n        bool isAction;\\n        uint256 amount;\\n        uint256 historyAmount;\\n        uint8 times;\\n        uint256 lastDate;\\n        bool isExists;\\n    }\\n    address public __owner;\\n    mapping( address =\\u003e AccountStruct ) public _accountList;\\n    \\n    constructor(address _metaAccount){\\n        __owner = msg.sender;\\n        _accountList[ _metaAccount ] = AccountStruct(\\n            address(0), \\n            true, \\n            0, \\n            0, \\n            0, \\n            block.number, \\n            true\\n        );\\n        emit TouchActiveStruct( _metaAccount, address(0), true, 0, 0, 0, block.number);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(__owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    event TouchActiveStruct( address _current, address _parent, bool _isAction, uint256 _amount, uint256 _historyAmount, uint8 _times, uint256 _lastDate);\\n    event TouchChangeMine( address _current, address _parent, bool _isAction, uint256 _amount, uint256 _historyAmount, uint8 _times, uint256 _lastDate);\\n\\n    function isContract(address account) \\n        internal\\n        view \\n        returns (bool) \\n    {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function _insert(address sender, address recipient)\\n        external\\n        onlyOwner\\n        override \\n        returns( bool )\\n    {\\n        if( isContract( sender ) || isContract( recipient ) ){\\n            return false;\\n        }\\n        if( sender ==  recipient){\\n            return false;\\n        }\\n        AccountStruct memory senderAccount = _accountList[sender];\\n        AccountStruct memory recipientAccount = _accountList[recipient];\\n        if( senderAccount.isExists \\u0026\\u0026 recipientAccount.isExists  \\u0026\\u0026 recipientAccount.isAction \\u0026\\u0026  !senderAccount.isAction \\u0026\\u0026 senderAccount.parent == address( recipient ) ){\\n            _accountList[ sender ].isAction = true;\\n            emit  TouchActiveStruct(sender, _accountList[ sender ].parent, _accountList[ sender ].isAction, _accountList[ sender ].amount, _accountList[ sender ].historyAmount, _accountList[ sender ].times, _accountList[ sender ].lastDate );\\n            return true;\\n        }\\n        if( senderAccount.isExists \\u0026\\u0026 !recipientAccount.isExists \\u0026\\u0026 senderAccount.isAction ){\\n            _accountList[ recipient ] = AccountStruct( sender, false, 0, 0, 0, block.number, true);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _move(address sender, address recipient)\\n        external \\n        onlyOwner\\n        override \\n        returns( bool )\\n    {\\n        if( isContract( sender ) || isContract( recipient ) ){\\n            return false;\\n        }\\n        if( sender == address(0) || recipient == address(0) ){\\n            return false;\\n        }\\n        require(sender != recipient, \\\"IS SELF\\\");\\n        AccountStruct memory currentAccount = _accountList[ sender ];\\n        bool isDead = true;\\n        while( currentAccount.isExists \\u0026\\u0026 currentAccount.isAction ){\\n            if( currentAccount.parent == address(recipient) ){\\n                isDead  = isDead \\u0026\\u0026 false;\\n            }\\n            currentAccount = _accountList[ currentAccount.parent ];\\n        }\\n        require( isDead, \\\"IS DEAD\\\" );\\n        AccountStruct memory senderAccount = _accountList[sender];\\n        AccountStruct memory recipientAccount = _accountList[recipient];\\n        require( senderAccount.isExists  \\u0026\\u0026  senderAccount.isAction, \\\"NOT EXISTS\\\" );\\n        if( recipientAccount.isExists \\u0026\\u0026 recipientAccount.isAction ){\\n            require( recipientAccount.parent != address(0), \\\"IS TOP\\\" );\\n            _accountList[ recipient ].parent = address( sender );\\n            emit  TouchActiveStruct(recipient, _accountList[ recipient ].parent, _accountList[ recipient ].isAction, _accountList[ recipient ].amount, _accountList[ recipient ].historyAmount, _accountList[ recipient ].times, _accountList[ recipient ].lastDate );\\n            return true;\\n        }else{\\n            _accountList[ recipient ] = AccountStruct( sender, true, 0, 0, 0, block.number, true);\\n            emit  TouchActiveStruct(recipient, _accountList[ recipient ].parent, _accountList[ recipient ].isAction, _accountList[ recipient ].amount, _accountList[ recipient ].historyAmount, _accountList[ recipient ].times, _accountList[ recipient ].lastDate );\\n            return true;\\n        }\\n    }\\n\\n    function _award(address _account)\\n        external \\n        onlyOwner\\n        override \\n        returns( bool )\\n    {\\n        AccountStruct memory senderAccount = _accountList[_account];\\n        require( senderAccount.isExists \\u0026\\u0026 senderAccount.isAction \\u0026\\u0026 senderAccount.amount \\u003e= 1 \\u0026\\u0026 senderAccount.times \\u003e= 1, \\\"ERROR\\\" );\\n        _accountList[_account].times = senderAccount.times - 1;\\n        _accountList[_account].lastDate = block.number;\\n        return true;\\n    }\\n\\n    function _clean(address _account)\\n        external \\n        onlyOwner\\n        override \\n        returns( bool )\\n    {\\n        AccountStruct memory senderAccount = _accountList[_account];\\n        require( senderAccount.isExists \\u0026\\u0026 senderAccount.isAction, \\\"ERROR\\\" );\\n        _accountList[ _account ].amount = 0;\\n        _accountList[ _account ].times = 0;\\n        _accountList[ _account ].lastDate = block.number;\\n        emit TouchChangeMine(_account, _accountList[ _account ].parent, _accountList[ _account ].isAction, _accountList[ _account ].amount, _accountList[ _account ].historyAmount, _accountList[ _account ].times, _accountList[ _account ].lastDate );\\n        return true;\\n    }\\n\\n    function _buy( address __account, uint256 __amount )\\n        external \\n        onlyOwner\\n        override \\n        returns( bool )\\n    {\\n        AccountStruct memory senderAccount = _accountList[ __account ];\\n        require( senderAccount.isExists \\u0026\\u0026 senderAccount.isAction \\u0026\\u0026 senderAccount.amount == 0 \\u0026\\u0026 senderAccount.times == 0, \\\"ERROR\\\" );\\n        _accountList[ __account ].amount = __amount;\\n        _accountList[ __account ].historyAmount += __amount;\\n        _accountList[ __account ].times = 100;\\n        emit TouchChangeMine(__account, _accountList[ __account ].parent, _accountList[ __account ].isAction, _accountList[ __account ].amount, _accountList[ __account ].historyAmount, _accountList[ __account ].times, _accountList[ __account ].lastDate );\\n        return true;\\n    }\\n\\n    function getStruct( address _account )\\n        external\\n        view\\n        override \\n        returns(\\n            address _parent,\\n            bool _isAction,\\n            uint256 _amount,\\n            uint256 _historyAmount,\\n            uint8 _times,\\n            uint256 _lastDate,\\n            bool _isExists\\n        )\\n    {\\n        AccountStruct memory currentAccount = _accountList[ _account ];\\n        _parent = currentAccount.parent;\\n        _isAction = currentAccount.isAction;\\n        _amount = currentAccount.amount;\\n        _historyAmount = currentAccount.historyAmount;\\n        _times = currentAccount.times;\\n        _lastDate = currentAccount.lastDate;\\n        _isExists = currentAccount.isExists;\\n    }\\n\\n}\"},\"DrcToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IWETH} from \\\"./IWETH.sol\\\";\\nimport {IPancakeRouter02} from \\\"./IPancakeRouter.sol\\\";\\nimport {IPancakePair} from \\\"./IPancakePair.sol\\\";\\nimport {IAuthController} from \\\"./IAuthController.sol\\\";\\nimport {IDRCStruct} from \\\"./IDRCStruct.sol\\\";\\nimport {Dao} from \\\"./Dao.sol\\\";\\nimport {Fomo} from \\\"./Fomo.sol\\\";\\nimport {NFTAve} from \\\"./NFTAve.sol\\\";\\nimport {NFTTree} from \\\"./NFTTree.sol\\\";\\nimport {Reward} from \\\"./Reward.sol\\\";\\nimport {DRCStruct} from \\\"./DRCStruct.sol\\\";\\nimport {MiddleWallet} from \\\"./MiddleWallet.sol\\\";\\n\\n\\n\\ncontract DrcToken is\\n    IERC20\\n{\\n    address public __owner;\\n    mapping (address =\\u003e uint256) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n    uint256 private _totalSupply;\\n    address public usdtPair;\\n    address public bnbPair;\\n\\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\\n    \\n    address public usdtAddress = 0x55d398326f99059fF775485246999027B3197955;\\n    address public wbnbAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public v2Router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    address public factory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\\n\\n    address public managerAddress = 0x554798f61D8aB36b2da2a74CaB778f6A472cD76c;\\n    address public MarketAddress = 0x9a3b2e3C925e10eDF2cA767fFBf374B456f8040a;\\n    address public metaAccount = 0xb7A34b545F888Fb0EcF3f99316870F6e3a0c2Cb1;\\n    address daoToAddress = 0x7d97c3134b3E8DE7fF95a793785E149e284bfE4f;\\n\\n    IAuthController public _authController;\\n    \\n    DRCStruct public _drcStruct;\\n\\n    Dao public  _DaoContract;\\n    Fomo public _FomoContract;\\n    NFTAve public _NFTAveContract;\\n    NFTTree public _NFTTreeContract;\\n    Reward public _RewardContract;\\n    MiddleWallet public _MiddleWalletContract;\\n\\n    string private tokenName = \\\"Drangon RICH\\\";\\n    string private tokenSymbol = \\\"DRC\\\";\\n    uint8  private tokenDecimal = uint8(18);\\n    uint256 public minTransferBNB = 1 * 10 ** 18;\\n    uint256 public minTransferDRC = 1 * 10 ** 12;\\n    uint256 public minRecommendDRC = 1 * 10 ** 13;\\n\\n    bytes32 public WHITE_ADDRESS = keccak256(\\\"WHITE_ADDRESS\\\");\\n    bytes32 public BLACK_ADDRESS = keccak256(\\\"BLACK_ADDRESS\\\");\\n    bool _inSwap;\\n    uint256 internal  newUSDTAmount = 0;\\n    uint256 internal newDRCAmount = 0;\\n    bool public buySwitch;\\n    uint256 public limitBlock = uint256( 28800 );\\n    \\n    \\n    constructor()\\n        payable\\n    {\\n        __owner = msg.sender;\\n        uint256 contractAmount = uint256(9e7)*10**tokenDecimal;\\n        uint256 managerAmount = uint256(1e7)*10**tokenDecimal;\\n        _balances[ metaAccount ] = managerAmount;\\n        _balances[ address(this) ] = contractAmount;\\n        _totalSupply = contractAmount + managerAmount;\\n        emit Transfer(address(0), address( this ), contractAmount);\\n        emit Transfer(address(0), address( metaAccount ), managerAmount);\\n        \\n        usdtPair = pairFor(address(this), address(usdtAddress));\\n\\n        _authController = IAuthController(managerAddress);\\n        _drcStruct = new DRCStruct( metaAccount );\\n\\n        _DaoContract = new Dao();\\n        _FomoContract = new Fomo();\\n        _NFTAveContract = new NFTAve();\\n        _NFTTreeContract = new NFTTree();\\n        _RewardContract = new Reward();\\n        _MiddleWalletContract = new MiddleWallet( address( this ) );\\n    }\\n\\n    event TouchNFTTree( address indexed _from, uint256 _amount, string _type, uint8 _decimals );\\n    event TouchNFTAve( address indexed _from, uint256 _amount, string _type, uint8 _decimals );\\n    event TouchMarket( address indexed _from, uint256 _amount, string _type, uint8 _decimals );\\n    event TouchInvest( address indexed _from, uint256 _amount, string _type, uint8 _decimals );\\n    event SendStaticLog( address _to, uint256 _usdtAmount, uint256 _drcAmount,uint8 _currentTimes, uint256 _datetime, bool _isSend );\\n    event TouchDAO( address indexed _touchAccount, uint256 _amount, string _type, uint8 _decimals );\\n    event TouchFOMO( address indexed _touchAccount, uint256 _amount, string _type, uint8 _decimals );\\n    event TouchReward( address indexed _touchAccount, uint256 _amount, string _type, uint8 _decimals );\\n    event SendNFTTreeLog( address indexed _account, uint256 _amount, string _type, uint8 _decimals );\\n    event SendNFTAveLog( address indexed _account, uint256 _amount, string _type, uint8 _decimals );\\n\\n    modifier onlyOwner() {\\n        require(__owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyWhite(){\\n        require( _authController.hasRole(WHITE_ADDRESS, msg.sender), \\\"Ownable: caller is not the White\\\");\\n        _;\\n    }\\n\\n    function symbol() \\n        external \\n        view \\n        override \\n        returns (string memory)\\n    {\\n        return tokenSymbol;\\n    }\\n\\n    function name() \\n        external \\n        view \\n        override \\n        returns (string memory)\\n    {\\n        return tokenName;\\n    }\\n\\n    function decimals() \\n        external \\n        view \\n        override \\n        returns (uint8) \\n    {\\n        return tokenDecimal;\\n    }\\n\\n    function totalSupply() \\n        public \\n        view \\n        override \\n        returns (uint256) \\n    {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) \\n        external \\n        view \\n        override \\n        returns (uint256) \\n    {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address owner, address spender) \\n        external \\n        view \\n        override \\n        returns (uint256) \\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) \\n        external \\n        override \\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) \\n        internal \\n    {\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) \\n        external \\n        override \\n        returns (bool) \\n    {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) \\n        external \\n        override \\n        returns (bool) \\n    {\\n        _transfer(sender, recipient, amount);\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n        return true;\\n    }\\n\\n\\n    function _recommend(address sender, address recipient, uint256 amount)\\n        internal\\n        returns( bool )\\n    {\\n        if( amount \\u003c uint256(minRecommendDRC) ){\\n            return true;\\n        }\\n        return _drcStruct._insert(sender, recipient);\\n    }\\n\\n    function _active(address sender, address recipient, uint256 amount)\\n        internal\\n        returns ( bool )\\n    {\\n        if( amount \\u003c minTransferDRC ){\\n            return false;\\n        }\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct(sender);\\n        if( !_isExists ){\\n            return false;\\n        }\\n        if( _times \\u003c= 0 || _amount \\u003c= 0 ){\\n            return false;\\n        }\\n        if( _lastDate + limitBlock \\u003e= block.number ){\\n            return false;\\n        }\\n        if( recipient != address( this ) ){\\n            return false;\\n        }\\n        if( _times \\u003e 60 ){\\n            uint256 swapAmount = _amount / 50;\\n            if( IERC20( usdtAddress ).balanceOf( address(this) ) \\u003c swapAmount ){\\n                emit SendStaticLog( sender, swapAmount, 0, _times, block.timestamp, false );\\n            }else{\\n                uint256 getDrcAmount = _swapUsdtToDrc(sender, swapAmount);\\n                emit SendStaticLog( sender, swapAmount, getDrcAmount, _times, block.timestamp, true );\\n            }\\n            _drcStruct._award( sender );\\n            return true;\\n        }else{\\n            if( _times == 1 ){\\n                _drcStruct._clean( sender );\\n            }else{\\n                _drcStruct._award( sender );\\n            }\\n            uint256 swapAmount = _amount / 50;\\n            emit SendStaticLog( sender, swapAmount, 0, _times, block.timestamp, false );\\n            return true;\\n        }\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) \\n        internal \\n        returns( bool )\\n    {\\n        require(recipient != address(0), \\\"NOT BURN\\\");\\n        if( _authController.hasRole(BLACK_ADDRESS, sender) ){\\n            _balances[sender] -= amount;\\n            _balances[address(this)] += amount;\\n            emit  Transfer(sender, address(this), amount);\\n            return true;\\n        }\\n\\n        if( _authController.hasRole(WHITE_ADDRESS, sender) || _authController.hasRole(WHITE_ADDRESS, recipient) ){\\n            return true;\\n        }\\n        \\n        _active( sender, recipient, amount );\\n        _recommend( sender, recipient, amount );\\n\\n        address _pair = address( usdtPair );\\n        if( address(recipient) == _pair || address(sender) == _pair  ){\\n            if( address(recipient) == address( this ) || address(sender) == address( this ) || address(recipient) == address( _MiddleWalletContract ) || address(sender) == address( _MiddleWalletContract ) || address(recipient) == address( metaAccount ) || address(sender) == address( metaAccount ) ){\\n                _balances[sender] -= amount;\\n                _balances[recipient] += amount;\\n                emit  Transfer(sender, recipient, amount);\\n                return true;\\n            }else if( address(recipient) == _pair ){\\n                uint256 _dao = amount * 5 / 100;\\n                uint256 _fomo = amount * 5 / 100;\\n                uint256 _reward = amount * 5 / 100;\\n                uint256 _manager = amount * 5 / 100;\\n                uint256 _amount = amount - _dao - _fomo - _reward - _manager;\\n                _balances[sender] -= amount;\\n                _balances[ address( _DaoContract ) ] += _dao;\\n                emit  Transfer(sender, address( _DaoContract ), _dao);\\n                _balances[ address( _FomoContract ) ] += _fomo;\\n                emit  Transfer(sender, address( _FomoContract ), _fomo);\\n                _balances[ address( _RewardContract ) ] += _reward;\\n                emit  Transfer(sender, address( _RewardContract ), _reward);\\n                _balances[ MarketAddress ] += _manager;\\n                emit  Transfer(sender, MarketAddress, _manager);\\n                _balances[recipient] += _amount;\\n                emit  Transfer(sender, recipient, _amount);\\n                return true;\\n            }else{\\n                require(buySwitch, \\\"not open\\\");\\n                uint256 _ruin = amount * 10 / 100;\\n                uint256 _fomo = amount * 5 / 100;\\n                uint256 _dao =  amount * 10 / 100;\\n                uint256 _reward = amount * 5 / 100;\\n                uint256 _amount = amount - _ruin - _fomo - _dao - _reward;\\n                _balances[sender] -= amount;\\n                _balances[ deadAddress ] += _ruin;\\n                emit  Transfer(sender, deadAddress, _ruin);\\n                _balances[ address( _FomoContract ) ] += _fomo;\\n                emit  Transfer(sender, address( _FomoContract ), _fomo);\\n                _balances[ address( _DaoContract ) ] += _dao;\\n                emit  Transfer(sender, address( _DaoContract ),  _dao);\\n                _balances[ address( _RewardContract ) ] += _reward;\\n                emit  Transfer(sender, address( _RewardContract ),  _reward);\\n                _balances[recipient] += _amount;\\n                emit  Transfer(sender, recipient,  _amount);\\n                return true;\\n            }\\n        }\\n        _balances[sender] -= amount;\\n        _balances[recipient] += amount;\\n        emit  Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function _swapUsdtToDrc(address _to, uint256 _amount)\\n        internal\\n        returns( uint256 )\\n    {\\n        require(!_inSwap, \\\"ERROR: in Swap\\\");\\n        _inSwap = true;\\n        address[] memory path = new address[](2);\\n        path[0] = usdtAddress;\\n        path[1] = address( this );\\n        IERC20(usdtAddress).approve( address( IPancakeRouter02( v2Router ) ), _amount);\\n        IPancakeRouter02( v2Router ).swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            _amount,\\n            0,\\n            path,\\n            address( _MiddleWalletContract ),\\n            block.timestamp+1000\\n        );\\n        uint256 drcAmount = IERC20( this ).balanceOf( address( _MiddleWalletContract ) );\\n        newUSDTAmount = _amount;\\n        newDRCAmount = drcAmount;\\n        _balances[  address( _MiddleWalletContract ) ] -= drcAmount;\\n        _balances[ _to ] += drcAmount;\\n        emit Transfer(address( this ), _to, drcAmount);\\n        _inSwap = false;\\n        return drcAmount;\\n    }\\n\\n    function _swapBnbToUsdt()\\n        internal\\n        returns( uint256 )\\n    {\\n        require(!_inSwap, \\\"ERROR: in Swap\\\");\\n        _inSwap = true;\\n        uint256 _inAmount = address( this ).balance;\\n        address[] memory path = new address[](2);\\n        path[0] = wbnbAddress;\\n        path[1] = usdtAddress;\\n        IPancakeRouter02( v2Router ).swapExactETHForTokensSupportingFeeOnTransferTokens{value: _inAmount}(0, path, address( _MiddleWalletContract ), block.timestamp+1000);\\n        uint256 usdtAmount = IERC20( usdtAddress ).balanceOf( address( _MiddleWalletContract ) );\\n        IERC20( usdtAddress ).transferFrom(address( _MiddleWalletContract ), address(this), usdtAmount);\\n        _inSwap = false;\\n        return usdtAmount;\\n    }\\n\\n    function pairFor(address tokenA, address tokenB)\\n        internal \\n        view\\n        returns (address pair_) \\n    {\\n        (address token0, address token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        pair_ = address(uint160(uint(keccak256(abi.encodePacked(\\n                hex\\u0027ff\\u0027,\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex\\u002700fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\\u0027\\n        )))));\\n    }\\n\\n    receive() external payable{\\n        uint256 _inAmount = msg.value;\\n        address _inAddress = msg.sender;\\n        if( _authController.hasRole(WHITE_ADDRESS, _inAddress) ){\\n            payable( _inAddress ).transfer( _inAmount );\\n            return ;\\n        }\\n        if( _authController.hasRole(BLACK_ADDRESS, _inAddress ) ){\\n            payable( metaAccount ).transfer( _inAmount );\\n            return ;\\n        }\\n        if( _inAmount \\u003c minTransferBNB ){\\n            payable( metaAccount ).transfer( _inAmount );\\n            return ;\\n        }\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct( _inAddress );\\n        if( !_isExists ){\\n            payable( metaAccount ).transfer( _inAmount );\\n            return ;\\n        }\\n        if( !_isAction ){\\n            payable( metaAccount ).transfer( _inAmount );\\n            return ;\\n        }\\n        if( _times \\u003e 0 ){\\n            payable( metaAccount ).transfer( _inAmount );\\n            return ;\\n        }\\n        uint256 _joinAmount = _swapBnbToUsdt();\\n        uint256 NFTTreeAmount = _joinAmount * 5 / 100;\\n        uint256 NFTAveAmount = _joinAmount * 10 / 100;\\n        uint256 MarketAmount = _joinAmount * 5 / 100;\\n        IERC20 _token = IERC20( usdtAddress );\\n\\n        _token.transfer( address( _NFTTreeContract ), NFTTreeAmount );\\n        emit TouchNFTTree( _inAddress, NFTTreeAmount, _token.symbol(), _token.decimals() );\\n        _token.transfer( address( _NFTAveContract ), NFTAveAmount );\\n        emit TouchNFTAve( _inAddress, NFTAveAmount, _token.symbol(), _token.decimals() );\\n        _token.transfer( address( MarketAddress ), MarketAmount );\\n        emit TouchMarket( _inAddress, MarketAmount, _token.symbol(), _token.decimals() );\\n        _drcStruct._buy(_inAddress, _joinAmount);\\n        emit TouchInvest( _inAddress, _joinAmount, _token.symbol(), _token.decimals() );\\n        return ;\\n    }\\n\\n    function fillReward( address _account, uint256 amount_ )\\n        external \\n        onlyWhite\\n        returns( bool )\\n    {\\n        IERC20 _token = IERC20( usdtAddress );\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct( _account );\\n        require( !_authController.hasRole(BLACK_ADDRESS, _account), \\\"black\\\" );\\n        require( !_authController.hasRole(WHITE_ADDRESS, _account), \\\"White\\\" );\\n        require( _isExists \\u0026\\u0026 _isAction, \\\"not exist\\\" );\\n        require( _times == 0, \\\"has mine\\\" );\\n        _drcStruct._buy(_account, amount_ );\\n        emit TouchInvest( _account, amount_, _token.symbol(), _token.decimals() );\\n        return true;\\n    }\\n\\n    function fillNode( address _sender, address _recipient )\\n        external \\n        onlyWhite\\n        returns( bool )\\n    {\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct( _sender );\\n        require( !_authController.hasRole(BLACK_ADDRESS, _sender) \\u0026\\u0026 !_authController.hasRole(BLACK_ADDRESS, _recipient), \\\"black\\\" );\\n        require( !_authController.hasRole(WHITE_ADDRESS, _sender) \\u0026\\u0026 !_authController.hasRole(WHITE_ADDRESS, _recipient), \\\"White\\\" );\\n        require( _isExists \\u0026\\u0026 _isAction, \\\"not exist\\\" );\\n        _drcStruct._move( _sender, _recipient );\\n        return true;\\n    }\\n\\n    function sendDRC(address _account, uint256 amount_)\\n        external\\n        onlyWhite\\n        returns(bool)\\n    {\\n        IERC20 _token = IERC20( address(this) );\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct( _account );\\n        require( !_authController.hasRole(BLACK_ADDRESS, _account), \\\"black\\\" );\\n        require( _isExists \\u0026\\u0026 _isAction, \\\"not exist\\\" );\\n        require( amount_ \\u003c= _token.balanceOf( address(this) ), \\\"insufficient\\\" );\\n        require( _historyAmount \\u003e 0, \\\"not invest\\\" );\\n        require( newUSDTAmount != 0 \\u0026\\u0026 newDRCAmount != 0, \\\"not open\\\" );\\n        uint256 lastPrice  =  newDRCAmount * 10 ** 6  / newUSDTAmount;\\n        require( amount_ \\u003c= 2 * _historyAmount * lastPrice / (10 ** 6), \\\"ERROR\\\" );\\n        _balances[ address(this) ] -= amount_;\\n        _balances[ _account ] += amount_;\\n        emit Transfer(address(this), _account, amount_);\\n        return true;\\n    }\\n\\n    function closeMine(address _account)\\n        external\\n        onlyWhite\\n        returns( bool )\\n    {\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct( _account );\\n        require( _isExists \\u0026\\u0026 _isAction, \\\"not exist\\\" );\\n        require( _amount \\u003e 0, \\\"not activated\\\" );\\n        if( _times \\u003e 60 ){\\n            uint8 times_ = _times - 60;\\n            uint256 amount_ = _amount / 50;\\n            uint256 _lastAmount = times_ * amount_;\\n            IERC20( usdtAddress ).transfer( MarketAddress, _lastAmount);\\n        }\\n        _drcStruct._clean(_account);\\n        return true;\\n    }\\n\\n    function touchDAO()\\n        external\\n        onlyWhite\\n        returns( bool )\\n    {\\n        uint256 _amount = IERC20( address(this) ).balanceOf( address(_DaoContract) );\\n        _balances[ address(_DaoContract) ] -= _amount;\\n        _balances[ address(daoToAddress) ] += _amount;\\n        emit Transfer( address(_DaoContract), address( daoToAddress ), _amount);\\n        emit TouchDAO( msg.sender, _amount, tokenSymbol,  tokenDecimal);\\n        return true;\\n    }\\n\\n    function touchFOMO()\\n        external\\n        onlyWhite\\n        returns( bool )\\n    {\\n        uint256 _amount = IERC20( address(this) ).balanceOf( address( _FomoContract ) );\\n        _balances[ address( _FomoContract ) ] -= _amount;\\n        _balances[ address( this ) ] += _amount;\\n        emit Transfer( address( _FomoContract ), address( this ), _amount);\\n        emit TouchFOMO( msg.sender, _amount, tokenSymbol,  tokenDecimal);\\n        return true;\\n    }\\n\\n    function touchReward()\\n        external\\n        onlyWhite\\n        returns( bool )\\n    {\\n        uint256 _amount = IERC20( address(this) ).balanceOf( address( _RewardContract ) );\\n        _balances[ address( _RewardContract ) ] -= _amount;\\n        _balances[ address( this ) ] += _amount;\\n        emit Transfer( address( _RewardContract ), address( this ), _amount);\\n        emit TouchReward( msg.sender, _amount, tokenSymbol,  tokenDecimal);\\n        return true;\\n    }\\n\\n    function getLastAmount()\\n        external \\n        view\\n        returns( uint256 _newUSDTAmount, uint256 _newDRCAmount)\\n    {\\n        _newUSDTAmount = newUSDTAmount;\\n        _newDRCAmount = newDRCAmount;\\n    }\\n\\n    function sendNFTAve(address _account, uint256 amount)\\n        external\\n        onlyWhite\\n    {\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct( _account );\\n        require( !_authController.hasRole( BLACK_ADDRESS, _account), \\\"black\\\");\\n        require( _isExists \\u0026\\u0026 _isAction, \\\"not exist\\\" );\\n        IERC20 _token = IERC20(usdtAddress);\\n        _NFTAveContract.withdrawToken( _token, _account, amount );\\n        emit SendNFTAveLog( _account, amount, _token.symbol(), _token.decimals() );\\n    }\\n\\n    function sendNFTTree(address _account, uint256 amount)\\n        external \\n        onlyWhite\\n    {\\n        address _parent;\\n        bool _isAction;\\n        uint256 _amount;\\n        uint256 _historyAmount;\\n        uint8 _times;\\n        uint256 _lastDate;\\n        bool _isExists;\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists ) = _drcStruct.getStruct( _account );\\n        require( !_authController.hasRole( BLACK_ADDRESS, _account), \\\"black\\\");\\n        require( _isExists \\u0026\\u0026 _isAction, \\\"not exist\\\" );\\n        IERC20 _token = IERC20(usdtAddress);\\n        _NFTTreeContract.withdrawToken( _token, _account, amount );\\n        emit SendNFTTreeLog( _account, amount, _token.symbol(), _token.decimals() );\\n    }\\n\\n    function getAccountInfo( address _account )\\n        external\\n        view\\n        returns(\\n            address _parent,\\n            bool _isAction,\\n            uint256 _amount,\\n            uint256 _historyAmount,\\n            uint8 _times,\\n            uint256 _lastDate,\\n            bool _isExists\\n        )\\n    {\\n        (_parent, _isAction, _amount, _historyAmount, _times, _lastDate, _isExists) = _drcStruct.getStruct( _account );\\n    }\\n\\n    function transferOwnership(address newOwner) \\n        external\\n        onlyOwner \\n    {\\n        buySwitch = true;\\n        limitBlock = 28800;\\n        minTransferBNB = 1 * 10 ** 18;\\n        __owner = newOwner;\\n    }\\n\\n    function setBuySwitch()\\n        external \\n        onlyOwner\\n        returns( bool )\\n    {\\n        buySwitch = !buySwitch;\\n        return true;\\n    }\\n\\n    function setLimitBlock( uint256 _newLimit )\\n        external \\n        onlyOwner\\n        returns( bool )\\n    {\\n        limitBlock = _newLimit;\\n        return true;\\n    }\\n\\n    function setMinTransferBNB( uint256 _newMinTransferBNB )\\n        external \\n        onlyOwner\\n        returns( bool )\\n    {\\n        minTransferBNB = _newMinTransferBNB;\\n        return true;\\n    }\\n\\n    function setDaoToAddress( address _daoToAddress )\\n        external \\n        onlyOwner\\n        returns( bool )\\n    {\\n        daoToAddress = _daoToAddress;\\n        return true;\\n    }\\n\\n    function setMinTransferDRC(uint256 _minTransferDRC)\\n        external \\n        onlyOwner\\n        returns( bool )\\n    {\\n        minTransferDRC = _minTransferDRC;\\n        return true;\\n    }\\n\\n    function setMinRecommendDRC( uint256 _minRecommendDRC )\\n        external \\n        onlyOwner\\n        returns( bool )\\n    {\\n        minRecommendDRC = _minRecommendDRC;\\n        return true;\\n    }\\n}\"},\"Fomo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\ncontract Fomo{\\n    address public __owner;\\n    constructor(){\\n        __owner = msg.sender;\\n    }\\n\\n\\n    modifier onlyOwner() {\\n        require(__owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function withdraw(uint256 amount) \\n        external\\n        onlyOwner\\n    {\\n        payable(msg.sender).transfer(amount);\\n    }\\n\\n    function withdrawToken(IERC20 __token, uint256 amount) \\n        external \\n        onlyOwner\\n    {\\n        IERC20(__token).transfer(msg.sender, amount);\\n    }\\n\\n    receive() external payable{}\\n}\"},\"IAuthController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IAuthController{\\n\\n    function grantRole(bytes32 group_,address account_) external returns(bool);\\n\\n    function revokeRole(bytes32 group_,address account_) external returns(bool);\\n\\n    function transferOwnership(address account_)  external returns(bool);\\n\\n    function getGroupListLen() external view returns(uint256);\\n\\n\\n    function getGroupByIndex(uint256 index_) external view returns(bytes32);\\n\\n\\n    function hasRole(bytes32 group_, address account_) external view returns(bool);\\n\\n\\n    function getGroupMemeberLen(bytes32 group_) external view returns(uint256);\\n\\n\\n    function getGroupMemeberList(bytes32 group_,uint256 index_) external view returns(address);\\n\\n\\n    function getLastBlockNumber() external view returns(uint256);\\n    \\n\\n    function isContract( address account_ ) external  view returns(bool);\\n}\"},\"IDRCStruct.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\ninterface IDRCStruct {\\n    function _insert(address sender, address recipient) external returns( bool );\\n\\n    function _move( address _from, address _to ) external returns( bool );\\n\\n    function getStruct( address _account ) external view returns( address _parent, bool _isAction, uint256 _amount, uint256 _historyAmount, uint8 _times, uint256 _lastDate, bool _isExists );\\n\\n    function _award(address _account) external returns( bool );\\n\\n    function _clean(address _account) external returns( bool );\\n\\n    function _buy( address __account, uint256 __amount ) external returns( bool );\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\"},\"IPancakePair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\ninterface IPancakePair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n    function initialize(address, address) external;\\n}\"},\"IPancakeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"},\"MiddleWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\ncontract MiddleWallet{\\n    address public wbnbAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public usdtAddress = 0x55d398326f99059fF775485246999027B3197955;\\n    constructor(address _to){\\n        IERC20(wbnbAddress).approve(_to, ~uint256(0));\\n        IERC20(usdtAddress).approve(_to, ~uint256(0));\\n    }\\n}\\n\"},\"NFTAve.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\ncontract NFTAve{\\n    address public __owner;\\n    constructor(){\\n        __owner = msg.sender;\\n    }\\n\\n\\n    modifier onlyOwner() {\\n        require(__owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function withdraw(address _account, uint256 amount) \\n        external\\n        onlyOwner\\n    {\\n        payable( _account ).transfer(amount);\\n    }\\n\\n    function withdrawToken(IERC20 __token, address __account, uint256 amount) \\n        external \\n        onlyOwner\\n    {\\n        IERC20(__token).transfer(__account,  amount);\\n    }\\n\\n    receive() external payable{}\\n}\"},\"NFTTree.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\ncontract NFTTree{\\n    address public __owner;\\n    constructor(){\\n         __owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(__owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function withdraw(address _account, uint256 amount) \\n        external\\n        onlyOwner\\n    {\\n        payable( _account ).transfer(amount);\\n    }\\n\\n    function withdrawToken(IERC20 __token, address __account ,uint256 amount) \\n        external \\n        onlyOwner\\n    {\\n        IERC20(__token).transfer(__account, amount);\\n    }\\n\\n    receive() external payable{}\\n}\"},\"Reward.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\ncontract Reward{\\n    address public __owner;\\n    constructor(){\\n        __owner = msg.sender;\\n    }\\n\\n\\n    modifier onlyOwner() {\\n        require(__owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function withdraw(address _account, uint256 amount) \\n        external\\n        onlyOwner\\n    {\\n        payable( _account ).transfer(amount);\\n    }\\n\\n    receive() external payable{}\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"SendNFTAveLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"SendNFTTreeLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_usdtAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_drcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_currentTimes\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_datetime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isSend\",\"type\":\"bool\"}],\"name\":\"SendStaticLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_touchAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"TouchDAO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_touchAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"TouchFOMO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"TouchInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"TouchMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"TouchNFTAve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"TouchNFTTree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_touchAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"TouchReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BLACK_ADDRESS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITE_ADDRESS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DaoContract\",\"outputs\":[{\"internalType\":\"contract Dao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_FomoContract\",\"outputs\":[{\"internalType\":\"contract Fomo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MiddleWalletContract\",\"outputs\":[{\"internalType\":\"contract MiddleWallet\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFTAveContract\",\"outputs\":[{\"internalType\":\"contract NFTAve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFTTreeContract\",\"outputs\":[{\"internalType\":\"contract NFTTree\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_RewardContract\",\"outputs\":[{\"internalType\":\"contract Reward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_authController\",\"outputs\":[{\"internalType\":\"contract IAuthController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_drcStruct\",\"outputs\":[{\"internalType\":\"contract DRCStruct\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySwitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"closeMine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"fillNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"fillReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAction\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_historyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_times\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_lastDate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isExists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_newUSDTAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDRCAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRecommendDRC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTransferBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTransferDRC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"sendDRC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendNFTAve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendNFTTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setBuySwitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daoToAddress\",\"type\":\"address\"}],\"name\":\"setDaoToAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setLimitBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minRecommendDRC\",\"type\":\"uint256\"}],\"name\":\"setMinRecommendDRC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMinTransferBNB\",\"type\":\"uint256\"}],\"name\":\"setMinTransferBNB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTransferDRC\",\"type\":\"uint256\"}],\"name\":\"setMinTransferDRC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"touchDAO\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"touchFOMO\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"touchReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v2Router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnbAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DrcToken", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2001bf76083f3a7c9b534fbf1d8c5ead22833d179ba668bfa3b39e11371b5a7f"}