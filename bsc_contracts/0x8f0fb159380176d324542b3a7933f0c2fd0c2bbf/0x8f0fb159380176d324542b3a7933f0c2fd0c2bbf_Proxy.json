{"SourceCode": "{\"owned.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./storage.sol\\\";\\n\\ncontract Owned is Storage {\\n    \\n    // -----------------------------------------------------\\n    // Usual storage\\n    // -----------------------------------------------------\\n\\n    // mapping(address =\\u003e bool) public owner;\\n\\n    // -----------------------------------------------------\\n    // Events\\n    // -----------------------------------------------------\\n\\n    event AddedOwner(address newOwner);\\n    event RemovedOwner(address removedOwner);\\n\\n    // -----------------------------------------------------\\n    // storage utilities\\n    // -----------------------------------------------------\\n\\n    function _isOwner(address _caller) internal view returns (bool) {\\n        return getBool(keccak256(abi.encode(\\\"owner\\\",_caller)));\\n    }\\n\\n    function _addOwner(address _newOwner) internal {\\n        // Add owner to list\\n        address[] storage owners = getOwners();\\n        owners.push(_newOwner);\\n        setOwners(owners);\\n\\n        // Set owner bool in storage\\n        setBool(keccak256(abi.encode(\\\"owner\\\", _newOwner)), true);\\n    }\\n\\n    function _deleteOwner(address _owner) internal {\\n        // Remove owner from list\\n        address[] storage owners = getOwners();\\n        for (uint i=0; i\\u003cowners.length - 1; i++)\\n            if (owners[i] == _owner) {\\n                owners[i] = owners[owners.length - 1];\\n                break;\\n            }\\n        owners.pop();\\n        setOwners(owners);\\n\\n        // Delete owner bool from storage\\n        deleteBool(keccak256(abi.encode(\\\"owner\\\", _owner)));\\n    }\\n\\n    function setOwners(address[] storage _addresses) internal {\\n        setAddresses(keccak256(abi.encode(\\\"owners\\\")), _addresses);\\n    }\\n\\n    function getOwners() internal view returns (address[] storage) {\\n        return getAddresses(keccak256(abi.encode(\\\"owners\\\")));\\n    }\\n\\n    // -----------------------------------------------------\\n    // Main contract\\n    // -----------------------------------------------------\\n\\n    constructor() {\\n        _addOwner(msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_isOwner(msg.sender));\\n        _;\\n    }\\n\\n    function addOwner(address _newOwner) onlyOwner public {\\n        require(!_isOwner(_newOwner));\\n        require(_newOwner != address(0));\\n        _addOwner(_newOwner);\\n        emit AddedOwner(_newOwner);\\n    }\\n\\n    function removeOwner(address _toRemove) onlyOwner public {\\n        require(_isOwner(_toRemove));\\n        require(_toRemove != address(0));\\n        require(_toRemove != msg.sender);\\n        _deleteOwner(_toRemove);\\n        emit RemovedOwner(_toRemove);\\n    }\\n\\n    function owners_list() public view returns (address[] memory) {\\n        return getOwners();\\n    }\\n\\n    function is_owner(address owner) public view returns (bool) {\\n        return _isOwner(owner);\\n    }\\n}\"},\"owned_upgradeable_token_storage.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./token_storage.sol\\\";\\nimport \\\"./upgradeable.sol\\\";\\n\\ncontract OwnedUpgradeableTokenStorage is TokenStorage, Upgradeable {}\"},\"proxy.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./token_storage.sol\\\";\\nimport \\\"./owned.sol\\\";\\n\\n// inherit from TokenStorage so we have the constructor, since the token variables need to be stored in the\\n// proxy\\u0027s storage\\ncontract Proxy is TokenStorage, Owned {\\n    fallback () external payable {\\n        // directly get the implementation contract address from the storage. This way we don\\u0027t need to depend\\n        // on the upgradeable contract\\n        address _impl = getAddress(keccak256(abi.encode(\\\"implementation\\\")));\\n        require(_impl != address(0), \\\"The implementation address can\\u0027t be the zero address\\\");\\n        bytes memory data = msg.data;\\n\\n        assembly {\\n            let result := delegatecall(gas(), _impl, add(data, 0x20), mload(data), 0, 0)\\n            let size := returndatasize()\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n            switch result\\n            case 0 { revert(ptr, size) }\\n            default { return(ptr, size) }\\n        }\\n    }\\n\\n    constructor() {\\n        //set initial contract address, needs to be hardcoded\\n        // TODO: Set correct address\\n        address impl_addr = address(0xE160c705696F89277d06F26215A799bb068F61CB);\\n        require(impl_addr != address(0), \\\"implementation address can not be the zero address\\\");\\n        setAddress(keccak256(abi.encode(\\\"implementation\\\")), impl_addr);\\n        setString(keccak256(abi.encode(\\\"version\\\")),\\\"0\\\");\\n\\n        // set initial owner\\n        setBool(keccak256(abi.encode(\\\"owner\\\", msg.sender)), true);\\n    }\\n}\"},\"storage.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ncontract Storage {\\n\\n\\n    /**** Storage Types *******/\\n\\n    mapping(bytes32 =\\u003e uint256)    private uIntStorage;\\n    mapping(bytes32 =\\u003e string)     private stringStorage;\\n    mapping(bytes32 =\\u003e address)    private addressStorage;\\n    mapping(bytes32 =\\u003e address[])  private addressesStorage;\\n    mapping(bytes32 =\\u003e bytes)      private bytesStorage;\\n    mapping(bytes32 =\\u003e bool)       private boolStorage;\\n    mapping(bytes32 =\\u003e int256)     private intStorage;\\n\\n    /**** Get Methods ***********/\\n\\n    /// @param _key The key for the record\\n    function getAddress(bytes32 _key) internal view returns (address) {\\n        return addressStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getAddresses(bytes32 _key) internal view returns (address[] storage) {\\n        return addressesStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getUint(bytes32 _key) internal view returns (uint) {\\n        return uIntStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getString(bytes32 _key) internal view returns (string memory) {\\n        return stringStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getBytes(bytes32 _key) internal view returns (bytes memory) {\\n        return bytesStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getBool(bytes32 _key) internal view returns (bool) {\\n        return boolStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getInt(bytes32 _key) internal view returns (int) {\\n        return intStorage[_key];\\n    }\\n\\n\\n    /**** Set Methods ***********/\\n\\n\\n    /// @param _key The key for the record\\n    function setAddress(bytes32 _key, address _value) internal {\\n        addressStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setAddresses(bytes32 _key, address[] storage _value) internal {\\n        addressesStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setUint(bytes32 _key, uint _value) internal {\\n        uIntStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setString(bytes32 _key, string memory _value) internal {\\n        stringStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setBytes(bytes32 _key, bytes memory _value) internal {\\n        bytesStorage[_key] = _value;\\n    }\\n    \\n    /// @param _key The key for the record\\n    function setBool(bytes32 _key, bool _value) internal {\\n        boolStorage[_key] = _value;\\n    }\\n    \\n    /// @param _key The key for the record\\n    function setInt(bytes32 _key, int _value) internal {\\n        intStorage[_key] = _value;\\n    }\\n\\n\\n    /**** Delete Methods ***********/\\n    \\n    /// @param _key The key for the record\\n    function deleteAddress(bytes32 _key) internal {\\n        delete addressStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function deleteUint(bytes32 _key) internal {\\n        delete uIntStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function deleteString(bytes32 _key) internal {\\n        delete stringStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function deleteBytes(bytes32 _key) internal {\\n        delete bytesStorage[_key];\\n    }\\n    \\n    /// @param _key The key for the record\\n    function deleteBool(bytes32 _key) internal {\\n        delete boolStorage[_key];\\n    }\\n    \\n    /// @param _key The key for the record\\n    function deleteInt(bytes32 _key) internal {\\n        delete intStorage[_key];\\n    }\\n\\n}\"},\"tokenV0.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./owned_upgradeable_token_storage.sol\\\";\\n\\n// ----------------------------------------------------------------------------\\n// Safe maths\\n// ----------------------------------------------------------------------------\\nlibrary SafeMath {\\n    function add(uint a, uint b) internal pure returns (uint c) {\\n        c = a + b;\\n        require(c \\u003e= a);\\n    }\\n    function sub(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003c= a);\\n        c = a - b;\\n    }\\n    function mul(uint a, uint b) internal pure returns (uint c) {\\n        c = a * b;\\n        require(a == 0 || c / a == b);\\n    }\\n    function div(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003e 0);\\n        c = a / b;\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n// ERC20 Token, with the addition of a symbol, name and decimals \\n// ----------------------------------------------------------------------------\\ncontract TFT is OwnedUpgradeableTokenStorage {\\n    using SafeMath for uint;\\n\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n\\n    // Lets mint some tokens, also index the TFT tx id\\n    event Mint(address indexed receiver, uint tokens, string indexed txid);\\n    // Burn tokens in a withdrawal, user chooses how much tokens\\n    event Withdraw(address indexed receiver, uint tokens, string blockchain_address, string network);\\n\\n    // name, symbol and decimals getters are optional per the ERC20 spec. Normally auto generated from public variables\\n    // but that is obviously not going to work for us\\n\\n    function name() public view returns (string memory) {\\n        return getName();\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return getSymbol();\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return getDecimals();\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Total supply\\n    // ------------------------------------------------------------------------\\n    function totalSupply() public view returns (uint) {\\n        return getTotalSupply().sub(getBalance(address(0)));\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Get the token balance for account `tokenOwner`\\n    // ------------------------------------------------------------------------\\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\\n        return getBalance(tokenOwner);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transfer(address to, uint tokens) public returns (bool success) {\\n        setBalance(msg.sender, getBalance(msg.sender).sub(tokens));\\n        setBalance(to, getBalance(to).add(tokens));\\n        emit Transfer(msg.sender, to, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner\\u0027s account\\n    //\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n    // recommends that there are no checks for the approval double-spend attack\\n    // as this should be implemented in user interfaces \\n    // ------------------------------------------------------------------------\\n    function approve(address spender, uint tokens) public returns (bool success) {\\n        setAllowed(msg.sender, spender, tokens);\\n        emit Approval(msg.sender, spender, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer `tokens` from the `from` account to the `to` account\\n    // \\n    // The calling account must already have sufficient tokens approve(...)-d\\n    // for spending from the `from` account and\\n    // - From account must have sufficient balance to transfer\\n    // - Spender must have sufficient allowance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\\n        setAllowed(from, msg.sender, getAllowed(from, msg.sender).sub(tokens));\\n        setBalance(from, getBalance(from).sub(tokens));\\n        setBalance(to, getBalance(to).add(tokens));\\n        emit Transfer(from, to, tokens);\\n        return true;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // Owner can withdraw and amount of tokens to another network, these tokens will be burned.\\n    // -----------------------------------------------------------------------\\n    function withdraw(uint tokens, string memory blockchain_address, string memory network) public returns (bool success) {\\n        setBalance(msg.sender, getBalance(msg.sender).sub(tokens));\\n        setTotalSupply(getTotalSupply().sub(tokens));\\n        emit Withdraw(msg.sender, tokens, blockchain_address, network);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Returns the amount of tokens approved by the owner that can be\\n    // transferred to the spender\\u0027s account\\n    // ------------------------------------------------------------------------\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\\n        return getAllowed(tokenOwner, spender);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Don\\u0027t accept ETH\\n    // ------------------------------------------------------------------------\\n    receive() external payable { }\\n\\n    // -----------------------------------------------------------------------\\n    // Owner can mint tokens. Although minting tokens to a withdraw address\\n    // is just an expensive tft transaction, it is possible, so after minting\\n    // attemt to withdraw.\\n    // -----------------------------------------------------------------------\\n    function mintTokens(address receiver, uint tokens, string memory txid) public onlyOwner {\\n        // check if the txid is already known\\n        require(!_isMintID(txid), \\\"TFT transacton ID already known\\\");\\n        _setMintID(txid);\\n        setBalance(receiver, getBalance(receiver).add(tokens));\\n        setTotalSupply(getTotalSupply().add(tokens));\\n        emit Mint(receiver, tokens, txid);\\n    }\\n\\n    function isMintID(string memory _txid) public view returns (bool) {\\n        return _isMintID(_txid);\\n    }\\n\\n    function _setMintID(string memory _txid) internal {\\n        setBool(keccak256(abi.encode(\\\"mint\\\",\\\"transaction\\\",\\\"id\\\",_txid)), true);\\n    }\\n\\n    function _isMintID(string memory _txid) internal view returns (bool) {\\n        return getBool(keccak256(abi.encode(\\\"mint\\\",\\\"transaction\\\",\\\"id\\\", _txid)));\\n    }\\n}\"},\"token_storage.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./storage.sol\\\";\\n\\ncontract TokenStorage is Storage {\\n\\n    // -----------------------------------------------------\\n    // Usual storage\\n    // -----------------------------------------------------\\n\\n    // string public symbol;\\n    // string public  name;\\n    // uint8 public decimals;\\n    // uint _totalSupply;\\n\\n    // mapping(address =\\u003e uint) balances;\\n    // mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\n\\n    // -----------------------------------------------------\\n    // getter utilities\\n    // -----------------------------------------------------\\n    function getSymbol() internal view returns (string memory) {\\n        return getString(keccak256(abi.encode(\\\"symbol\\\")));\\n    }\\n\\n    function getName() internal view returns (string memory) {\\n        return getString(keccak256(abi.encode(\\\"name\\\")));\\n    }\\n\\n    function getDecimals() internal view returns (uint8) {\\n        return uint8(getUint(keccak256(abi.encode(\\\"decimals\\\"))))    ;\\n    }\\n\\n    function getTotalSupply() internal view returns (uint) {\\n        return getUint(keccak256(abi.encode(\\\"totalSupply\\\")));\\n    }\\n\\n    function getBalance(address _account) internal view returns (uint) {\\n        return getUint(keccak256(abi.encode(\\\"balance\\\", _account)));\\n    }\\n\\n    function getAllowed(address _account, address _spender) internal view returns (uint) {\\n        return getUint(keccak256(abi.encode(\\\"allowed\\\", _account, _spender)));\\n    }\\n\\n    // -----------------------------------------------------\\n    // setter utilities\\n    // -----------------------------------------------------\\n    function setSymbol(string memory _symbol) internal {\\n        setString(keccak256(abi.encode(\\\"symbol\\\")), _symbol);\\n    }\\n\\n    function setName(string memory _name) internal {\\n        setString(keccak256(abi.encode(\\\"name\\\")), _name);\\n    }\\n\\n    function setDecimals(uint8 _decimals) internal {\\n        setUint(keccak256(abi.encode(\\\"decimals\\\")), _decimals);\\n    }\\n\\n    function setTotalSupply(uint _totalSupply) internal {\\n        setUint(keccak256(abi.encode(\\\"totalSupply\\\")), _totalSupply);\\n    }\\n\\n    function setBalance(address _account, uint _balance) internal {\\n        setUint(keccak256(abi.encode(\\\"balance\\\", _account)), _balance);\\n    }\\n\\n    function setAllowed(address _account, address _spender, uint _allowance) internal {\\n        setUint(keccak256(abi.encode(\\\"allowed\\\", _account, _spender)), _allowance);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    // Token constructor here so it is also inheritted by our proxy. Needed to set some constants\\n    constructor() {\\n        setSymbol(\\\"TFT\\\");\\n        setName(\\\"TFT on BSC\\\");\\n\\n        // Use 7 decimals instead of 9, this way we have the same amount of decimals in both TFT and this Token\\n        uint8 _decimals = 7;\\n        setDecimals(_decimals);\\n\\n        // Set initial supply to 0\\n        setTotalSupply(0);\\n    }\\n}\"},\"upgradeable.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./owned.sol\\\";\\n\\ncontract Upgradeable is Owned {\\n    // -----------------------------------------------------\\n    // Usual storage\\n    // -----------------------------------------------------\\n\\n    // string internal _version;\\n    // address internal _implementation;\\n\\n    // -----------------------------------------------------\\n    // Events\\n    // -----------------------------------------------------\\n\\n    event Upgraded(string indexed version, address indexed implementation);\\n\\n    // -----------------------------------------------------\\n    // storage utilities\\n    // -----------------------------------------------------\\n\\n    function _getVersion() internal view returns (string memory) {\\n        return getString(keccak256(abi.encode(\\\"version\\\")));\\n    }\\n\\n    function _setVersion(string memory _version) internal {\\n        setString(keccak256(abi.encode(\\\"version\\\")), _version);\\n    }\\n\\n    function _getImplementation() internal view returns (address) {\\n        return getAddress(keccak256(abi.encode(\\\"implementation\\\")));\\n    }\\n\\n    function _setImplementation(address _implementation) internal {\\n        setAddress(keccak256(abi.encode(\\\"implementation\\\")), _implementation);\\n    }\\n\\n    // -----------------------------------------------------\\n    // Main contract\\n    // -----------------------------------------------------\\n\\n    function version() public view returns (string memory) {\\n        return _getVersion();\\n    }\\n\\n    function implementation() public view returns (address) {\\n        return _getImplementation();\\n    }\\n\\n\\n    function upgradeTo(string memory _version, address _implementation) public onlyOwner {\\n        require(_getImplementation() != _implementation);\\n        _setVersion(_version);\\n        _setImplementation(_implementation);\\n        emit Upgraded(_version, _implementation);\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedOwner\",\"type\":\"address\"}],\"name\":\"RemovedOwner\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"is_owner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owners_list\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toRemove\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "1", "Implementation": "0xe160c705696f89277d06f26215a799bb068f61cb", "SwarmSource": "ipfs://1f1c4e13b129ac7817773b21ce6bd0e616ee075e48763fe69f98aff6fa0d1aa4"}