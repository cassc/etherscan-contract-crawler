{"SourceCode": "// SPDX-License-Identifier: Unlicensed \r\n// This contract is not open source and can not be used/forked without permission\r\n// Contract created at tokensbygen.com\r\n\r\n\r\n/*\r\n\r\n\r\nSTANDARD TOKEN FACTORY \r\n\r\nCreated by Gen - www.TokensByGen.com\r\n\r\nVisit our website to create your token in minutes\r\nOr contact us for a fully customized contract via Telegram: https://t.me/GenTokens_GEN\r\n\r\nNOT OPEN SOURCE! DO NOT COPY!\r\n\r\n\r\n*/\r\n\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;}\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;}\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;}\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;}\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {require(b <= a, errorMessage);\r\n            return a - b;}}\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {require(b > 0, errorMessage);\r\n            return a / b;}}\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"unable to send, recipient reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"insufficient balance for call\");\r\n        require(isContract(target), \"call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                 assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract TokensByGEN_STANDARD_TOKEN is Context {\r\n\r\n    address payable private COLLECTOR = payable(0xde491C65E507d281B6a3688d11e8fC222eee0975);\r\n\r\n    function CreateToken(string memory Token_Name, \r\n                         string memory Token_Symbol, \r\n                         uint256 Total_Supply, \r\n                         uint256 Number_Of_Decimals) public {\r\n\r\n        // Min 2, max 18 decimals required\r\n        if (Number_Of_Decimals < 2) {\r\n\r\n            Number_Of_Decimals = 2;\r\n\r\n            } else if (Number_Of_Decimals > 18) {\r\n\r\n            Number_Of_Decimals = 18;\r\n        }\r\n\r\n\r\n    new STANDARD_TOKEN(Token_Name,\r\n                      Token_Symbol,\r\n                      Total_Supply, \r\n                      Number_Of_Decimals,\r\n                      payable(msg.sender));\r\n    \r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // Purge BNB\r\n    function Purge_BNB() external {\r\n        \r\n        send_BNB(COLLECTOR, address(this).balance);\r\n    }\r\n\r\n    // Purge Tokens\r\n    function Purge_Tokens(address random_Token_Address, uint256 percent_of_Tokens) external {\r\n        uint256 totalRandom = IERC20(random_Token_Address).balanceOf(address(this));\r\n        uint256 removeRandom = totalRandom * percent_of_Tokens / 100;\r\n        IERC20(random_Token_Address).transfer(COLLECTOR, removeRandom);\r\n    }\r\n\r\n    // Send BNB\r\n    function send_BNB(address _to, uint256 _amount) internal returns (bool Sent) {\r\n                                \r\n        (Sent,) = payable(_to).call{value: _amount}(\"\");\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract STANDARD_TOKEN is Context, IERC20 { \r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Contract Wallets\r\n    address private _owner;\r\n    address public Wallet_Tokens;\r\n    address public Wallet_Liquidity;\r\n    address payable public Wallet_Marketing;\r\n    address payable private constant Wallet_Fee = payable(0xde491C65E507d281B6a3688d11e8fC222eee0975);\r\n    address private constant Wallet_Burn = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // Token Info\r\n    string private  _name;\r\n    string private  _symbol;\r\n    uint256 private _decimals;\r\n    uint256 private _tTotal;\r\n\r\n    // Project Links\r\n    string private _Website;\r\n    string private _Telegram;\r\n    string private _LP_Lock;\r\n\r\n    // Limits\r\n    uint256 private max_Hold;\r\n    uint256 private max_Tran;\r\n\r\n    // Fees\r\n    uint256 public _Fee__Buy_Burn;\r\n    uint256 public _Fee__Buy_Contract;\r\n    uint256 public _Fee__Buy_Liquidity;\r\n    uint256 public _Fee__Buy_Marketing;\r\n    uint256 public _Fee__Buy_Tokens;\r\n\r\n    uint256 public _Fee__Sell_Burn;\r\n    uint256 public _Fee__Sell_Contract;\r\n    uint256 public _Fee__Sell_Liquidity;\r\n    uint256 public _Fee__Sell_Marketing;\r\n    uint256 public _Fee__Sell_Tokens;\r\n\r\n    // Total Fee for Swap\r\n    uint256 private _SwapFeeTotal_Buy;\r\n    uint256 private _SwapFeeTotal_Sell;\r\n\r\n    // Factory\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\r\n    constructor (string memory      _TokenName, \r\n                 string memory      _TokenSymbol,  \r\n                 uint256            _TotalSupply, \r\n                 uint256            _Decimals, \r\n                 address payable    _OwnerWallet) {\r\n\r\n    // Owner\r\n    _owner              = _OwnerWallet;\r\n\r\n    // Token Info\r\n    _name               = _TokenName;\r\n    _symbol             = _TokenSymbol;\r\n    _decimals           = _Decimals;\r\n    _tTotal             = _TotalSupply * 10**_decimals;\r\n\r\n    // Wallet Limits\r\n    max_Hold            = _tTotal;\r\n    max_Tran            = _tTotal;\r\n\r\n    // Set Contract Fee\r\n    _Fee__Buy_Contract  = 1;\r\n    _Fee__Sell_Contract = 1;\r\n\r\n    // Project Wallets Set to Owner\r\n    Wallet_Marketing    = payable(_OwnerWallet);\r\n    Wallet_Tokens       = _OwnerWallet;\r\n    Wallet_Liquidity    = _OwnerWallet;\r\n\r\n    // Transfer Supply To Owner\r\n    _tOwned[_owner]     = _tTotal;\r\n\r\n    // Set PancakeSwap Router Address\r\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    \r\n    // Create Initial Pair With BNB\r\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n    uniswapV2Router = _uniswapV2Router;\r\n\r\n    // Set Initial LP Pair\r\n    _isPair[uniswapV2Pair] = true;   \r\n\r\n    // Wallets Excluded From Limits\r\n    _isLimitExempt[address(this)] = true;\r\n    _isLimitExempt[Wallet_Burn] = true;\r\n    _isLimitExempt[uniswapV2Pair] = true;\r\n    _isLimitExempt[_owner] = true;\r\n    _isLimitExempt[Wallet_Tokens] = true;\r\n\r\n    // Wallets With Pre-Launch Access\r\n    _isWhiteListed[_owner] = true;\r\n\r\n    // Wallets Excluded From Fees\r\n    _isExcludedFromFee[address(this)] = true;\r\n    _isExcludedFromFee[Wallet_Burn] = true;\r\n    _isExcludedFromFee[_owner] = true;\r\n\r\n    // Emit Supply Transfer to Owner\r\n    emit Transfer(address(0), _owner, _tTotal);\r\n\r\n    // Emit Ownership Transfer\r\n    emit OwnershipTransferred(address(0), _owner);\r\n\r\n    }\r\n\r\n    // Events\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event updated_Wallet_Limits(uint256 max_Tran, uint256 max_Hold);\r\n    event updated_Buy_fees(uint256 Marketing, uint256 Liquidity, uint256 Burn, uint256 Tokens, uint256 Dev);\r\n    event updated_Sell_fees(uint256 Marketing, uint256 Liquidity, uint256 Burn, uint256 Tokens, uint256 Dev);\r\n    event updated_SwapAndLiquify_Enabled(bool Swap_and_Liquify_Enabled);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\r\n\r\n    // Restrict Function to Current Owner\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Mappings\r\n    mapping (address => uint256) private _tOwned;                               // Tokens Owned\r\n    mapping (address => mapping (address => uint256)) private _allowances;      // Allowance to spend another wallets tokens\r\n    mapping (address => bool) public _isExcludedFromFee;                        // Wallets that do not pay fees\r\n    mapping (address => bool) public _isLimitExempt;                            // Wallets that are excluded from HOLD and TRANSFER limits\r\n    mapping (address => bool) public _isPair;                                   // Address is liquidity pair\r\n    mapping (address => bool) public _isEarlyBuyer;                             // Early Buyers \r\n    mapping (address => bool) public _isWhiteListed;                            // Pre-Launch Access\r\n    mapping (address => bool) public _isBlackListed;                            // Blacklisted wallets\r\n\r\n    // Fee Processing Triggers\r\n    uint256 private swapTrigger = 11;   \r\n    uint256 private swapCounter = 1;    \r\n    \r\n    // SwapAndLiquify Switch                  \r\n    bool public inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled; \r\n\r\n    // Launch Settings\r\n    uint256 private LaunchTime;\r\n    uint256 private EarlyBuyTime;\r\n    bool public launchMode;\r\n    bool public trade_Open;\r\n    bool public freeWalletTransfers = true;\r\n    bool public blacklistPossible = true;\r\n    bool public blockInitialBuys = false;\r\n    bool public burnFromSupply = false;\r\n\r\n    // Fee Tracker\r\n    bool private takeFee;\r\n\r\n    // Project info\r\n    function Project_Information() external view returns(address Owner_Wallet,\r\n                                                       uint256 Transaction_Limit,\r\n                                                       uint256 Max_Wallet,\r\n                                                       uint256 Fee_When_Buying,\r\n                                                       uint256 Fee_When_Selling,\r\n                                                       bool Blacklist_Possible,\r\n                                                       string memory Website,\r\n                                                       string memory Telegram,\r\n                                                       string memory Liquidity_Lock,\r\n                                                       string memory Contract_Created_By) {\r\n                                                           \r\n        string memory Creator = \"https://tokensbygen.com\";\r\n\r\n        uint256 Total_buy =  _Fee__Buy_Burn         +\r\n                             _Fee__Buy_Contract     +\r\n                             _Fee__Buy_Liquidity    +\r\n                             _Fee__Buy_Marketing    +\r\n                             _Fee__Buy_Tokens       ;\r\n\r\n        uint256 Total_sell = _Fee__Sell_Burn        +\r\n                             _Fee__Sell_Contract    +\r\n                             _Fee__Sell_Liquidity   +\r\n                             _Fee__Sell_Marketing   +\r\n                             _Fee__Sell_Tokens      ;\r\n\r\n        uint256 _max_Hold = max_Hold / 10 ** _decimals;\r\n        uint256 _max_Tran = max_Tran / 10 ** _decimals;\r\n\r\n        if (_max_Tran > _max_Hold) {\r\n\r\n            _max_Tran = _max_Hold;\r\n        }\r\n\r\n\r\n        // Return Token Data\r\n        return (_owner,\r\n                _max_Tran,\r\n                _max_Hold,\r\n                Total_buy,\r\n                Total_sell,\r\n                blacklistPossible,\r\n                _Website,\r\n                _Telegram,\r\n                _LP_Lock,\r\n                Creator);\r\n\r\n    }\r\n    \r\n    // Prepare the contract for pre-sale\r\n    function Contract_SetUp_01__Presale_Address(\r\n\r\n        address Presale_Contract_Address\r\n\r\n        ) external onlyOwner {\r\n\r\n        _isExcludedFromFee[Presale_Contract_Address] = true; \r\n        _isLimitExempt[Presale_Contract_Address] = true;\r\n        _isWhiteListed[Presale_Contract_Address] = true;\r\n\r\n    }\r\n\r\n    // Set buy fees\r\n    function Contract_SetUp_02__Fees_on_Buy(\r\n\r\n        uint256 Marketing_on_BUY, \r\n        uint256 Liquidity_on_BUY, \r\n        uint256 Burn_on_BUY,  \r\n        uint256 Tokens_on_BUY\r\n\r\n        ) external onlyOwner {\r\n\r\n        // Buyer Protection: Max Fee 15% (Includes 1% Contract Fee)\r\n        require (Marketing_on_BUY    + \r\n                 Liquidity_on_BUY    + \r\n                 Burn_on_BUY         + \r\n                 Tokens_on_BUY       +\r\n                 _Fee__Buy_Contract <= 15, \"E01\"); // Total buy fee (including 1% contract fee if applicable) must be 15 or less \r\n\r\n        // Update Fees\r\n        _Fee__Buy_Marketing  = Marketing_on_BUY;\r\n        _Fee__Buy_Liquidity  = Liquidity_on_BUY;\r\n        _Fee__Buy_Burn       = Burn_on_BUY;\r\n        _Fee__Buy_Tokens     = Tokens_on_BUY;\r\n\r\n        // Fees For Processing\r\n        _SwapFeeTotal_Buy    = _Fee__Buy_Marketing + _Fee__Buy_Liquidity + _Fee__Buy_Contract;\r\n\r\n        emit updated_Buy_fees(_Fee__Buy_Marketing, _Fee__Buy_Liquidity, _Fee__Buy_Burn, _Fee__Buy_Tokens, _Fee__Buy_Contract);\r\n    }\r\n\r\n    // Set sell fees\r\n    function Contract_SetUp_03__Fees_on_Sell(\r\n\r\n        uint256 Marketing_on_SELL,\r\n        uint256 Liquidity_on_SELL, \r\n        uint256 Burn_on_SELL,\r\n        uint256 Tokens_on_SELL\r\n\r\n        ) external onlyOwner {\r\n\r\n        // Seller Protection: Max Fee 15% (Includes 1% Contract Fee)\r\n        require (Marketing_on_SELL  + \r\n                 Liquidity_on_SELL  + \r\n                 Burn_on_SELL       + \r\n                 Tokens_on_SELL     +\r\n                 _Fee__Sell_Contract <= 15, \"E02\"); // Total sell fee (including 1% contract fee if applicable) must be 15 or less \r\n\r\n        // Update Fees\r\n        _Fee__Sell_Marketing  = Marketing_on_SELL;\r\n        _Fee__Sell_Liquidity  = Liquidity_on_SELL;\r\n        _Fee__Sell_Burn       = Burn_on_SELL;\r\n        _Fee__Sell_Tokens     = Tokens_on_SELL;\r\n\r\n\r\n        // Fees For Processing\r\n        _SwapFeeTotal_Sell    = _Fee__Sell_Marketing + _Fee__Sell_Liquidity + _Fee__Sell_Contract;\r\n\r\n        emit updated_Sell_fees(_Fee__Sell_Marketing, _Fee__Sell_Liquidity, _Fee__Sell_Burn, _Fee__Sell_Tokens,  _Fee__Sell_Contract);\r\n    }\r\n\r\n    /*\r\n    \r\n    ------------------------------------------\r\n    SET MAX TRANSACTION AND MAX HOLDING LIMITS\r\n    ------------------------------------------\r\n\r\n    Wallet limits are set as a number of tokens, not as a percent of supply!\r\n\r\n    If you want to limit people to 2% of supply and your supply is 1,000,000 tokens then you \r\n    will need to enter 20000\r\n\r\n    */\r\n\r\n    function Contract_SetUp_04__Wallet_Limits(\r\n\r\n        uint256 Max_Tokens_Each_Transaction,\r\n        uint256 Max_Total_Tokens_Per_Wallet \r\n\r\n        ) external onlyOwner {\r\n\r\n        if (launchMode || !trade_Open){\r\n\r\n            // Before opening trade, and during Launch Mode, wallets can be limited to 0.05% of initial supply\r\n            require(Max_Tokens_Each_Transaction >= _tTotal / 2000 / 10**_decimals, \"E03\"); // 0.05% minimum limit\r\n            require(Max_Total_Tokens_Per_Wallet >= _tTotal / 2000 / 10**_decimals, \"E04\"); // 0.05% minimum limit\r\n\r\n\r\n        } else {\r\n\r\n            // Buyer protection - Minimum limits after Launch Mode 0.1% Transaction, 0.5% wallet\r\n            require(Max_Tokens_Each_Transaction >= _tTotal / 1000 / 10**_decimals, \"E05\"); // 0.1% minimum limit\r\n            require(Max_Total_Tokens_Per_Wallet >= _tTotal / 200 / 10**_decimals, \"E06\"); // 0.5% minimum limit\r\n        \r\n\r\n        }\r\n        \r\n        max_Tran = Max_Tokens_Each_Transaction * 10**_decimals;\r\n        max_Hold = Max_Total_Tokens_Per_Wallet * 10**_decimals;\r\n\r\n        emit updated_Wallet_Limits(max_Tran, max_Hold);\r\n\r\n    }\r\n\r\n    /*\r\n    \r\n    ---------------------\r\n    SNIPER BOT PROTECTION\r\n    ---------------------\r\n    \r\n    The EarlyBuyTime can be set to a maximum of 60 seconds\r\n    Any people buying within this many seconds of trade being opened will be blocked from selling \r\n    during Launch Mode if Block_Early_Buyer_Sells is set to true.\r\n\r\n    These wallets can then be checked for bot activity and blacklisted (and refunded) if required.\r\n    Block_Early_Buyer_Sells can be set to false to allow early buyers to sell normally during Launch mode.\r\n    When Launch Mode ends, early buyers can sell normally.\r\n\r\n    Launch Mode will end automatically after 1 hour. It can also be ended manually at any time. \r\n\r\n    */\r\n\r\n    function Contract_SetUp_05__Bot_Protection(\r\n\r\n        uint256 Early_Buy_Timer_in_Seconds,\r\n        bool Block_Early_Buyer_Sells\r\n\r\n        ) external onlyOwner {\r\n\r\n        require (Early_Buy_Timer_in_Seconds <= 60, \"E07\"); // Max early buy timer is 60 seconds \r\n        EarlyBuyTime = Early_Buy_Timer_in_Seconds;\r\n\r\n        blockInitialBuys = Block_Early_Buyer_Sells;\r\n\r\n    }\r\n\r\n    // Open Trade\r\n    function Contract_SetUp_06__Open_Trade() external onlyOwner {\r\n\r\n        // Can only use once to prevent resetting LaunchTime\r\n        require(!trade_Open);\r\n\r\n        swapAndLiquifyEnabled = true;\r\n        LaunchTime = block.timestamp;\r\n        launchMode = true;\r\n        trade_Open = true;\r\n\r\n    }\r\n\r\n    // Blacklist Bots - Can only blacklist during launch mode (max 1 hour)\r\n    function Contract_SetUp_07__Blacklist_Bots(address Wallet, bool true_or_false) external onlyOwner {\r\n        \r\n        if (true_or_false) {\r\n\r\n            require(blacklistPossible, \"E08\"); // Blacklisting is no longer possible\r\n        }\r\n\r\n        _isBlackListed[Wallet] = true_or_false;\r\n\r\n    }\r\n\r\n    // Deactivate Launch Mode\r\n    function Contract_SetUp_08__Deactivate_Launch_Mode() external onlyOwner {\r\n\r\n        launchMode = false;\r\n        blacklistPossible = false;\r\n        blockInitialBuys = false;\r\n\r\n        // Check max transaction limit is greater than 0.1% of initial supply\r\n        if (max_Tran < _tTotal / 1000) {\r\n\r\n            max_Tran = _tTotal / 1000;\r\n        }\r\n\r\n        // Check max holding limit is greater than 0.5% of initial supply\r\n        if (max_Hold < _tTotal / 200) {\r\n\r\n            max_Hold = _tTotal / 200;\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n\r\n    ----------------------\r\n    UPDATE PROJECT WALLETS\r\n    ----------------------\r\n\r\n    */\r\n\r\n    function Contract_SetUp_09__Update_Wallets(\r\n\r\n        address Token_Fee_Wallet,\r\n        address Liquidity_Collection_Wallet,\r\n        address payable Marketing_Fee_Wallet\r\n\r\n        ) external onlyOwner {\r\n\r\n        // Update Token Fee Wallet\r\n        require(Token_Fee_Wallet != address(0), \"E09\"); // Enter a valid BSC wallet\r\n        Wallet_Tokens = Token_Fee_Wallet;\r\n\r\n        // Update LP Collection Wallet\r\n        require(Liquidity_Collection_Wallet != address(0), \"E10\"); // Enter a valid BSC wallet\r\n        Wallet_Liquidity = Liquidity_Collection_Wallet;\r\n\r\n        // Update BNB Fee Wallet\r\n        require(Marketing_Fee_Wallet != address(0), \"E11\"); // Enter a valid BSC wallet\r\n        Wallet_Marketing = payable(Marketing_Fee_Wallet);\r\n\r\n\r\n    }\r\n\r\n    /*\r\n\r\n    --------------------\r\n    UPDATE PROJECT LINKS\r\n    --------------------\r\n\r\n    */\r\n\r\n    function Contract_SetUp_10__Update_Links(\r\n\r\n        string memory Website_URL, \r\n        string memory Telegram_URL,\r\n        string memory LP_Lock_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _Website    = Website_URL;\r\n        _Telegram   = Telegram_URL;\r\n        _LP_Lock    = LP_Lock_URL;\r\n\r\n    }\r\n\r\n    /*\r\n    \r\n    ----------------\r\n    BURN FROM SUPPLY\r\n    ----------------\r\n\r\n    Default = false\r\n    \r\n    When true, if tokens are sent to the burn wallet they will instead be removed\r\n    from the senders balance and removed from the total supply.\r\n\r\n    When this is set to false, any tokens sent to the burn wallet will not\r\n    be removed from total supply and will be added to the burn wallet balance.\r\n\r\n    */\r\n\r\n    function Contract__Options__Burn_From_Supply(bool true_or_false) external onlyOwner {\r\n\r\n        burnFromSupply = true_or_false;\r\n\r\n    }\r\n\r\n    /*\r\n    \r\n    ---------------------------------\r\n    NO FEE WALLET TO WALLET TRANSFERS \r\n    ---------------------------------\r\n\r\n    Default = true\r\n\r\n    Having no fee on wallet-to-wallet transfers means that people can move tokens between wallets, \r\n    or send them to friends etc without incurring a fee. \r\n\r\n    If false, the 'Buy' fee will apply to all wallet to wallet transfers.\r\n\r\n    */\r\n\r\n    function Contract__Options__Free_Wallet_Transfers(bool true_or_false) public onlyOwner {\r\n\r\n        freeWalletTransfers = true_or_false;\r\n\r\n    }\r\n\r\n    // Add Liquidity Pair - required for correct fee calculations \r\n    function Maintenance__Add_Liquidity_Pair(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false)\r\n\r\n        external onlyOwner {\r\n\r\n        _isPair[Wallet_Address] = true_or_false;\r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n    } \r\n\r\n    /* \r\n\r\n    ----------------------------\r\n    CONTRACT OWNERSHIP FUNCTIONS\r\n    ----------------------------\r\n\r\n    Before renouncing ownership, set the freeWalletTransfers to false \r\n\r\n    */\r\n  \r\n    // Renounce Ownership - To prevent accidental renounce, you must enter the Confirmation_Code: 1234\r\n    function Maintenance__Ownership_RENOUNCE(uint256 Confirmation_Code) public virtual onlyOwner {\r\n\r\n        require(Confirmation_Code == 1234, \"E12\"); // Renounce confirmation not correct\r\n\r\n        // Remove old owner status \r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    // Transfer to New Owner - To prevent accidental transfer, you must enter the Confirmation_Code: 1234\r\n    function Maintenance__Ownership_TRANSFER(address payable newOwner, uint256 Confirmation_Code) public onlyOwner {\r\n\r\n        require(Confirmation_Code == 1234, \"E12\"); // Transfer confirmation not correct\r\n        require(newOwner != address(0), \"E13\"); // Enter a valid BSC wallet\r\n\r\n        // Revoke old owner status\r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n\r\n        // Set up new owner status \r\n        _isLimitExempt[owner()]     = true;\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isWhiteListed[owner()]     = true;\r\n\r\n    }\r\n\r\n    /*\r\n\r\n    -------------------\r\n    REMOVE CONTRACT FEE\r\n    -------------------\r\n\r\n    Removal of the 1% Contract Fee Costs 2 BNB \r\n\r\n    */\r\n\r\n    function Maintenance__Remove_Contract_Fee() external payable {\r\n\r\n        require(msg.value == 2*10**18, \"E14\"); // Need to enter 2, and pay 2 BNB\r\n\r\n        send_BNB(Wallet_Fee, msg.value);\r\n\r\n        // Remove Contract Fee\r\n        _Fee__Buy_Contract  = 0;\r\n        _Fee__Sell_Contract = 0;\r\n\r\n        // Update Swap Fees\r\n        _SwapFeeTotal_Buy   = _Fee__Buy_Liquidity + _Fee__Buy_Marketing;\r\n        _SwapFeeTotal_Sell  = _Fee__Sell_Liquidity + _Fee__Sell_Marketing;\r\n    }\r\n\r\n    /*\r\n\r\n    --------------\r\n    FEE PROCESSING\r\n    --------------\r\n\r\n    */\r\n\r\n    // Auto Fee Processing Switch (SwapAndLiquify)\r\n    function Processing__Auto_Process(bool true_or_false) external onlyOwner {\r\n        swapAndLiquifyEnabled = true_or_false;\r\n        emit updated_SwapAndLiquify_Enabled(true_or_false);\r\n    }\r\n\r\n    // Manually Process Fees\r\n    function Processing__Process_Now (uint256 Percent_of_Tokens_to_Process) external onlyOwner {\r\n\r\n        require(!inSwapAndLiquify, \"E15\"); // Already in swap, try later\r\n\r\n        if (Percent_of_Tokens_to_Process > 100){Percent_of_Tokens_to_Process = 100;}\r\n        uint256 tokensOnContract = balanceOf(address(this));\r\n        uint256 sendTokens = tokensOnContract * Percent_of_Tokens_to_Process / 100;\r\n        swapAndLiquify(sendTokens);\r\n\r\n    }\r\n\r\n    // Update Swap Count Trigger\r\n    function Processing__Swap_Trigger_Count(uint256 Transaction_Count) external onlyOwner {\r\n\r\n        swapTrigger = Transaction_Count + 1; // Reset to 1 (not 0) to save gas\r\n    }\r\n\r\n    // Remove Random Tokens\r\n    function Processing__Remove_Random_Tokens(\r\n\r\n        address random_Token_Address,\r\n        uint256 number_of_Tokens\r\n\r\n        ) external onlyOwner {\r\n\r\n            require (random_Token_Address != address(this), \"E16\"); // Can not remove the native token\r\n            IERC20(random_Token_Address).transfer(msg.sender, number_of_Tokens);\r\n            \r\n    }\r\n\r\n    /*\r\n\r\n    ---------------\r\n    WALLET SETTINGS\r\n    ---------------\r\n\r\n    */\r\n\r\n    // Exclude From Fees\r\n    function Wallet_Settings__Exclude_From_Fees(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {\r\n        _isExcludedFromFee[Wallet_Address] = true_or_false;\r\n\r\n    }\r\n\r\n    // Exclude From Transaction and Holding Limits\r\n    function Wallet_Settings__Exempt_From_Limits(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {  \r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n    // Grant Pre-Launch Access (Whitelist) - Whitelisted wallets can only buy, Nobody can sell before trade is open! \r\n    function Wallet_Settings__Pre_Launch_Access(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {    \r\n        _isWhiteListed[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n    // Remove early buyer tag from wallet \r\n    function Wallet_Settings__Remove_Early_Buyer_Tag(\r\n\r\n        address Wallet_Address\r\n\r\n        ) external onlyOwner {    \r\n        _isEarlyBuyer[Wallet_Address] = false;\r\n    }\r\n\r\n    \r\n    /*\r\n\r\n    -----------------------------\r\n    BEP20 STANDARD AND COMPLIANCE\r\n    -----------------------------\r\n\r\n    */\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _tOwned[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"Decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"Allowance exceeded\"));\r\n        return true;\r\n    }\r\n\r\n    function send_BNB(address _to, uint256 _amount) internal returns (bool SendSuccess) {\r\n        (SendSuccess,) = payable(_to).call{value: _amount}(\"\");\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return (_tTotal - balanceOf(address(Wallet_Burn)));\r\n    }\r\n\r\n    /*\r\n\r\n    ---------------\r\n    TOKEN TRANSFERS\r\n    ---------------\r\n\r\n    */\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n      ) private {\r\n\r\n        require(balanceOf(from) >= amount, \"E19\"); // Sender does not have enough tokens!\r\n\r\n        if (!trade_Open){\r\n\r\n            /* \r\n\r\n            Before trade is open, the initial liquidity can be added by a whitelisted wallet or contract (owner is whitelisted by default)\r\n            This prevents a non-whitelisted token holder from a pre-sale or airdrop from maliciously setting the token price\r\n            Once the initially liquidity is added, tokens can not move to the LP pair, this prevents anybody from selling tokens before trade is open\r\n\r\n            NB: After setting the price and adding the initial liquidity, more LP can not be added until trade is open\r\n\r\n            */\r\n\r\n            require(_isWhiteListed[from] || _isWhiteListed[to], \"E20\");\r\n\r\n            uint LP_Supply = IERC20(uniswapV2Pair).totalSupply();\r\n\r\n            if(LP_Supply > 0){\r\n\r\n                require(to != uniswapV2Pair, \"Whitelisted wallets can not sell tokens before trade is open\");\r\n\r\n            } \r\n\r\n\r\n        }\r\n\r\n        // Launch Mode\r\n        if (launchMode) {\r\n\r\n            // Auto End Launch Mode After One Hour\r\n            if (block.timestamp > LaunchTime + (1 * 1 hours)){\r\n\r\n                launchMode = false;\r\n                blacklistPossible = false;\r\n\r\n                // Check max transaction limit is greater than 0.1% of initial supply\r\n                if (max_Tran < _tTotal / 1000) {\r\n\r\n                    max_Tran = _tTotal / 1000;\r\n                }\r\n\r\n                // Check max holding limit is greater than 0.5% of initial supply\r\n                if (max_Hold < _tTotal / 200) {\r\n\r\n                    max_Hold = _tTotal / 200;\r\n                }\r\n            \r\n            } else {\r\n\r\n                // Stop Early Buyers Selling During Launch Phase - NOTE: THEY ARE NOT AUTOMATICALLY BLACKLISTED! \r\n                if (blockInitialBuys){\r\n                    require(!_isEarlyBuyer[from], \"E21\"); // Early buyer can not sell during launch mode\r\n                }\r\n\r\n                // Tag Early Buyers - People that buy early can not sell or move tokens during launchMode (Max EarlyBuyTime is 60 seconds)\r\n                if (to != owner() && _isPair[from] && block.timestamp <= LaunchTime + EarlyBuyTime) {\r\n\r\n                    _isEarlyBuyer[to] = true;\r\n\r\n                } \r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Blacklisted Wallets Can Only Send Tokens to Owner\r\n        if (to != owner()) {\r\n                require(!_isBlackListed[to] && !_isBlackListed[from],\"E22\"); // Blacklisted wallets can not buy or sell (only send tokens to owner)\r\n            }\r\n\r\n        // Wallet Limit\r\n        if (!_isLimitExempt[to]) {\r\n\r\n            uint256 heldTokens = balanceOf(to);\r\n            require((heldTokens + amount) <= max_Hold, \"E23\"); // Over max wallet limit\r\n            \r\n        }\r\n\r\n        // Transaction limit - To send over the transaction limit the sender AND the recipient must be limit exempt\r\n        if (!_isLimitExempt[to] || !_isLimitExempt[from]) {\r\n\r\n            require(amount <= max_Tran, \"E24\"); // Over max transaction limit\r\n        \r\n        }\r\n\r\n        // Compliance and Safety Checks\r\n        require(from != address(0), \"E25\"); // Not a valid BSC wallet address\r\n        require(to != address(0), \"E26\"); // Not a valid BSC wallet address\r\n        require(amount > 0, \"E27\"); // Amount must be greater than 0\r\n\r\n        // Trigger Fee Processing\r\n        if (_isPair[to] && !inSwapAndLiquify && swapAndLiquifyEnabled) {\r\n\r\n            // Check Transaction Count\r\n            if(swapCounter >= swapTrigger){\r\n\r\n                // Check Contract Tokens\r\n                uint256 contractTokens = balanceOf(address(this));\r\n\r\n                if (contractTokens > 0) {\r\n\r\n                    // Limit Swap to Max Transaction\r\n                    if (contractTokens <= max_Tran) {\r\n\r\n                        swapAndLiquify (contractTokens);\r\n\r\n                        } else {\r\n\r\n                        swapAndLiquify (max_Tran);\r\n\r\n                    }\r\n                }\r\n            }  \r\n        }\r\n\r\n        // Check Fee Status\r\n        takeFee = true;\r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (freeWalletTransfers && !_isPair[to] && !_isPair[from])){\r\n            takeFee = false;\r\n        }\r\n\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n\r\n    }\r\n\r\n    /*\r\n    \r\n    ------------\r\n    PROCESS FEES\r\n    ------------\r\n\r\n    */\r\n\r\n    function swapAndLiquify(uint256 Tokens) private {\r\n\r\n        // Lock Swap\r\n        inSwapAndLiquify        = true;  \r\n\r\n        // Calculate Tokens for Swap\r\n        uint256 _FeesTotal      = _SwapFeeTotal_Buy + _SwapFeeTotal_Sell;\r\n        uint256 LP_Tokens       = Tokens * (_Fee__Buy_Liquidity + _Fee__Sell_Liquidity) / _FeesTotal / 2;\r\n        uint256 Swap_Tokens     = Tokens - LP_Tokens;\r\n\r\n        // Swap Tokens\r\n        uint256 contract_BNB    = address(this).balance;\r\n        swapTokensForBNB(Swap_Tokens);\r\n        uint256 returned_BNB    = address(this).balance - contract_BNB;\r\n\r\n        // Avoid Rounding Errors on LP Fee if Odd Number\r\n        uint256 fee_Split       = _FeesTotal * 2 - (_Fee__Buy_Liquidity + _Fee__Sell_Liquidity);\r\n\r\n        // Calculate BNB Values\r\n        uint256 BNB_Liquidity   = returned_BNB * (_Fee__Buy_Liquidity   + _Fee__Sell_Liquidity)       / fee_Split;\r\n        uint256 BNB_Contract    = returned_BNB * (_Fee__Buy_Contract    + _Fee__Sell_Contract)    * 2 / fee_Split;\r\n\r\n        // Add Liquidity \r\n        if (LP_Tokens > 0){\r\n            addLiquidity(LP_Tokens, BNB_Liquidity);\r\n            emit SwapAndLiquify(LP_Tokens, BNB_Liquidity, LP_Tokens);\r\n        }\r\n\r\n        // Take Contract Fee\r\n        if(BNB_Contract > 0){\r\n\r\n            send_BNB(Wallet_Fee, BNB_Contract);\r\n\r\n        }\r\n        \r\n        // Flush remaining BNB into marketing wallet\r\n        contract_BNB = address(this).balance;\r\n\r\n        if (contract_BNB > 0){\r\n\r\n            send_BNB(Wallet_Marketing, contract_BNB);\r\n        }\r\n\r\n        // Reset Counter\r\n        swapCounter = 1;\r\n\r\n        // Unlock Swap\r\n        inSwapAndLiquify = false;\r\n\r\n    }\r\n\r\n    // Swap Tokens\r\n    function swapTokensForBNB(uint256 tokenAmount) private {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // Add Liquidity\r\n    function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.addLiquidityETH{value: BNBAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, \r\n            0,\r\n            Wallet_Liquidity, \r\n            block.timestamp\r\n        );\r\n    } \r\n\r\n    /*\r\n    \r\n    ----------------------------------\r\n    TRANSFER TOKENS AND CALCULATE FEES\r\n    ----------------------------------\r\n\r\n    */\r\n\r\n    uint256 private tBurn;\r\n    uint256 private tTokens;\r\n    uint256 private tSwapFeeTotal;\r\n    uint256 private tTransferAmount;\r\n\r\n    // Transfer Tokens and Calculate Fees\r\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool Fee) private {\r\n        \r\n        if (Fee){\r\n\r\n            if(_isPair[recipient]){\r\n\r\n                // Sell Fees\r\n                tBurn           = tAmount * _Fee__Sell_Burn       / 100;\r\n                tTokens         = tAmount * _Fee__Sell_Tokens     / 100;\r\n                tSwapFeeTotal   = tAmount * _SwapFeeTotal_Sell    / 100;\r\n\r\n            } else {\r\n\r\n                // Buy Fees\r\n                tBurn           = tAmount * _Fee__Buy_Burn        / 100;\r\n                tTokens         = tAmount * _Fee__Buy_Tokens      / 100;\r\n                tSwapFeeTotal   = tAmount * _SwapFeeTotal_Buy     / 100;\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n                // No Fees\r\n                tBurn           = 0;\r\n                tTokens         = 0;\r\n                tSwapFeeTotal   = 0;\r\n\r\n        }\r\n\r\n        tTransferAmount = tAmount - (tBurn + tTokens + tSwapFeeTotal);\r\n        \r\n        // Remove Tokens from Sender\r\n        _tOwned[sender] -= tAmount;\r\n\r\n        // Check for Deflationary Burn\r\n        if (burnFromSupply && recipient == Wallet_Burn) {\r\n\r\n                // Remove Tokens from Total Supply \r\n                _tTotal -= tTransferAmount;\r\n\r\n            } else {\r\n\r\n                // Give Tokens to Recipient\r\n                _tOwned[recipient] += tTransferAmount;\r\n\r\n            }\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        // Process Token Fee\r\n        if(tTokens > 0){\r\n\r\n            _tOwned[Wallet_Tokens] += tTokens;          \r\n\r\n        }\r\n\r\n        // Take Fees for BNB Processing\r\n        if(tSwapFeeTotal > 0){\r\n\r\n            _tOwned[address(this)] += tSwapFeeTotal;\r\n\r\n            // Increase Transaction Counter\r\n            swapCounter++;\r\n                \r\n        }\r\n\r\n        // Process Burn\r\n        if(tBurn > 0){\r\n\r\n            if (burnFromSupply){\r\n\r\n                // Reduce Supply\r\n                _tTotal = _tTotal - tBurn;\r\n\r\n            } else {\r\n\r\n                _tOwned[Wallet_Burn] += tBurn;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // This function is required so that the contract can receive BNB during fee processing\r\n    receive() external payable {}\r\n\r\n\r\n}\r\n\r\n\r\n/*\r\n\r\n\r\nSTANDARD BSC BEP20 TOKEN - Contract by Gen\r\n\r\n    Website: https://TokensByGen.com\r\n    Telegram: https://t.me/GenTokens_GEN\r\n\r\n    This contract is not open source - Can not be used or forked without permission.\r\n    Fees from the creation of this token help to support GEN - https://gentokens.com\r\n\r\n\r\n*/", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Token_Name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Token_Symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"Total_Supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Number_Of_Decimals\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Purge_BNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent_of_Tokens\",\"type\":\"uint256\"}],\"name\":\"Purge_Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokensByGEN_STANDARD_TOKEN", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://41adfe3a368f86f00ece897a1130ef4e5aa8a2b7950ac97b8c70a4288c53dddb"}