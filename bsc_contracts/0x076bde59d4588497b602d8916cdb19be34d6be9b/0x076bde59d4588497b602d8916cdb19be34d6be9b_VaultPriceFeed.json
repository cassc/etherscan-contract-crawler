{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/amm/interfaces/IPancakePair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPancakePair {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/core/VaultPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./interfaces/IVaultPriceFeed.sol\\\";\\nimport \\\"../oracle/interfaces/IPriceFeed.sol\\\";\\nimport \\\"../oracle/interfaces/ISecondaryPriceFeed.sol\\\";\\nimport \\\"../amm/interfaces/IPancakePair.sol\\\";\\n\\npragma solidity 0.8.19;\\n\\ncontract VaultPriceFeed is Ownable, IVaultPriceFeed {\\n    uint256 public constant PRICE_PRECISION = 10**30;\\n    uint256 public constant ONE_USD = PRICE_PRECISION;\\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\\n    uint256 public constant MAX_SPREAD_BASIS_POINTS = 50;\\n    uint256 public constant MAX_ADJUSTMENT_INTERVAL = 2 hours;\\n    uint256 public constant MAX_ADJUSTMENT_BASIS_POINTS = 20;\\n\\n    bool public isAmmEnabled = true;\\n    bool public isSecondaryPriceEnabled = true;\\n    bool public useV2Pricing = false;\\n    bool public favorPrimaryPrice = false;\\n    uint256 public priceSampleSpace = 3;\\n    uint256 public maxStrictPriceDeviation = 0;\\n    address public secondaryPriceFeed;\\n    uint256 public spreadThresholdBasisPoints = 30;\\n\\n    address public btc;\\n    address public eth;\\n    address public bnb;\\n    address public bnbBusd;\\n    address public ethBnb;\\n    address public btcBnb;\\n\\n    mapping(address => address) public priceFeeds;\\n    mapping(address => uint256) public priceDecimals;\\n    mapping(address => uint256) public spreadBasisPoints;\\n    // Chainlink can return prices for stablecoins\\n    // that differs from 1 USD by a larger percentage than stableSwapFeeBasisPoints\\n    // we use strictStableTokens to cap the price to 1 USD\\n    // this allows us to configure stablecoins like DAI as being a stableToken\\n    // while not being a strictStableToken\\n    mapping(address => bool) public strictStableTokens;\\n\\n    mapping(address => uint256) public override adjustmentBasisPoints;\\n    mapping(address => bool) public override isAdjustmentAdditive;\\n    mapping(address => uint256) public lastAdjustmentTimings;\\n    mapping(address => uint256) public stalePriceThresholds;\\n\\n    function setAdjustment(\\n        address _token,\\n        bool _isAdditive,\\n        uint256 _adjustmentBps\\n    ) external override onlyOwner {\\n        require(\\n            lastAdjustmentTimings[_token] + MAX_ADJUSTMENT_INTERVAL <\\n                block.timestamp,\\n            \\\"VaultPriceFeed: adjustment frequency exceeded\\\"\\n        );\\n        require(\\n            _adjustmentBps <= MAX_ADJUSTMENT_BASIS_POINTS,\\n            \\\"invalid _adjustmentBps\\\"\\n        );\\n        isAdjustmentAdditive[_token] = _isAdditive;\\n        adjustmentBasisPoints[_token] = _adjustmentBps;\\n        lastAdjustmentTimings[_token] = block.timestamp;\\n    }\\n\\n    function setUseV2Pricing(bool _useV2Pricing) external override onlyOwner {\\n        useV2Pricing = _useV2Pricing;\\n    }\\n\\n    function setIsAmmEnabled(bool _isEnabled) external override onlyOwner {\\n        isAmmEnabled = _isEnabled;\\n    }\\n\\n    function setIsSecondaryPriceEnabled(bool _isEnabled)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        isSecondaryPriceEnabled = _isEnabled;\\n    }\\n\\n    function setSecondaryPriceFeed(address _secondaryPriceFeed)\\n        external\\n        onlyOwner\\n    {\\n        secondaryPriceFeed = _secondaryPriceFeed;\\n    }\\n\\n    function setTokens(\\n        address _btc,\\n        address _eth,\\n        address _bnb\\n    ) external onlyOwner {\\n        btc = _btc;\\n        eth = _eth;\\n        bnb = _bnb;\\n    }\\n\\n    function setPairs(\\n        address _bnbBusd,\\n        address _ethBnb,\\n        address _btcBnb\\n    ) external onlyOwner {\\n        bnbBusd = _bnbBusd;\\n        ethBnb = _ethBnb;\\n        btcBnb = _btcBnb;\\n    }\\n\\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        require(\\n            _spreadBasisPoints <= MAX_SPREAD_BASIS_POINTS,\\n            \\\"VaultPriceFeed: invalid _spreadBasisPoints\\\"\\n        );\\n        spreadBasisPoints[_token] = _spreadBasisPoints;\\n    }\\n\\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        spreadThresholdBasisPoints = _spreadThresholdBasisPoints;\\n    }\\n\\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        favorPrimaryPrice = _favorPrimaryPrice;\\n    }\\n\\n    function setPriceSampleSpace(uint256 _priceSampleSpace)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        require(\\n            _priceSampleSpace > 0,\\n            \\\"VaultPriceFeed: invalid _priceSampleSpace\\\"\\n        );\\n        priceSampleSpace = _priceSampleSpace;\\n    }\\n\\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        maxStrictPriceDeviation = _maxStrictPriceDeviation;\\n    }\\n\\n    function setTokenConfig(\\n        address _token,\\n        address _priceFeed,\\n        uint256 _priceDecimals,\\n        bool _isStrictStable,\\n        uint256 _stalePriceThreshold\\n    ) external override onlyOwner {\\n        priceFeeds[_token] = _priceFeed;\\n        priceDecimals[_token] = _priceDecimals;\\n        strictStableTokens[_token] = _isStrictStable;\\n        stalePriceThresholds[_token] = _stalePriceThreshold;\\n    }\\n\\n    function getPrice(\\n        address _token,\\n        bool _maximise,\\n        bool _includeAmmPrice,\\n        bool /* _useSwapPricing */\\n    ) public view override returns (uint256) {\\n        uint256 price = useV2Pricing\\n            ? getPriceV2(_token, _maximise, _includeAmmPrice)\\n            : getPriceV1(_token, _maximise, _includeAmmPrice);\\n\\n        uint256 adjustmentBps = adjustmentBasisPoints[_token];\\n        if (adjustmentBps > 0) {\\n            bool isAdditive = isAdjustmentAdditive[_token];\\n            if (isAdditive) {\\n                price =\\n                    (price * (BASIS_POINTS_DIVISOR + adjustmentBps)) /\\n                    BASIS_POINTS_DIVISOR;\\n            } else {\\n                price =\\n                    (price * (BASIS_POINTS_DIVISOR - adjustmentBps)) /\\n                    BASIS_POINTS_DIVISOR;\\n            }\\n        }\\n\\n        return price;\\n    }\\n\\n    function getPriceV1(\\n        address _token,\\n        bool _maximise,\\n        bool _includeAmmPrice\\n    ) public view returns (uint256) {\\n        uint256 price = getPrimaryPrice(_token, _maximise);\\n\\n        if (_includeAmmPrice && isAmmEnabled) {\\n            uint256 ammPrice = getAmmPrice(_token);\\n            if (ammPrice > 0) {\\n                if (_maximise && ammPrice > price) {\\n                    price = ammPrice;\\n                }\\n                if (!_maximise && ammPrice < price) {\\n                    price = ammPrice;\\n                }\\n            }\\n        }\\n\\n        if (isSecondaryPriceEnabled) {\\n            price = getSecondaryPrice(_token, price, _maximise);\\n        }\\n\\n        if (strictStableTokens[_token]) {\\n            uint256 delta = price > ONE_USD ? price - ONE_USD : ONE_USD - price;\\n            if (delta <= maxStrictPriceDeviation) {\\n                return ONE_USD;\\n            }\\n\\n            // if _maximise and price is e.g. 1.02, return 1.02\\n            if (_maximise && price > ONE_USD) {\\n                return price;\\n            }\\n\\n            // if !_maximise and price is e.g. 0.98, return 0.98\\n            if (!_maximise && price < ONE_USD) {\\n                return price;\\n            }\\n\\n            return ONE_USD;\\n        }\\n\\n        uint256 _spreadBasisPoints = spreadBasisPoints[_token];\\n\\n        if (_maximise) {\\n            return\\n                (price * (BASIS_POINTS_DIVISOR + _spreadBasisPoints)) /\\n                BASIS_POINTS_DIVISOR;\\n        }\\n\\n        return\\n            (price * (BASIS_POINTS_DIVISOR - _spreadBasisPoints)) /\\n            BASIS_POINTS_DIVISOR;\\n    }\\n\\n    function getPriceV2(\\n        address _token,\\n        bool _maximise,\\n        bool _includeAmmPrice\\n    ) public view returns (uint256) {\\n        uint256 price = getPrimaryPrice(_token, _maximise);\\n\\n        if (_includeAmmPrice && isAmmEnabled) {\\n            price = getAmmPriceV2(_token, _maximise, price);\\n        }\\n\\n        if (isSecondaryPriceEnabled) {\\n            price = getSecondaryPrice(_token, price, _maximise);\\n        }\\n\\n        if (strictStableTokens[_token]) {\\n            uint256 delta = price > ONE_USD ? price - ONE_USD : ONE_USD - price;\\n            if (delta <= maxStrictPriceDeviation) {\\n                return ONE_USD;\\n            }\\n\\n            // if _maximise and price is e.g. 1.02, return 1.02\\n            if (_maximise && price > ONE_USD) {\\n                return price;\\n            }\\n\\n            // if !_maximise and price is e.g. 0.98, return 0.98\\n            if (!_maximise && price < ONE_USD) {\\n                return price;\\n            }\\n\\n            return ONE_USD;\\n        }\\n\\n        uint256 _spreadBasisPoints = spreadBasisPoints[_token];\\n\\n        if (_maximise) {\\n            return\\n                (price * (BASIS_POINTS_DIVISOR + _spreadBasisPoints)) /\\n                BASIS_POINTS_DIVISOR;\\n        }\\n\\n        return\\n            (price * (BASIS_POINTS_DIVISOR - _spreadBasisPoints)) /\\n            BASIS_POINTS_DIVISOR;\\n    }\\n\\n    function getAmmPriceV2(\\n        address _token,\\n        bool _maximise,\\n        uint256 _primaryPrice\\n    ) public view returns (uint256) {\\n        uint256 ammPrice = getAmmPrice(_token);\\n        if (ammPrice == 0) {\\n            return _primaryPrice;\\n        }\\n\\n        uint256 diff = ammPrice > _primaryPrice\\n            ? ammPrice - _primaryPrice\\n            : _primaryPrice - ammPrice;\\n        if (\\n            diff * BASIS_POINTS_DIVISOR <\\n            _primaryPrice * spreadThresholdBasisPoints\\n        ) {\\n            if (favorPrimaryPrice) {\\n                return _primaryPrice;\\n            }\\n            return ammPrice;\\n        }\\n\\n        if (_maximise && ammPrice > _primaryPrice) {\\n            return ammPrice;\\n        }\\n\\n        if (!_maximise && ammPrice < _primaryPrice) {\\n            return ammPrice;\\n        }\\n\\n        return _primaryPrice;\\n    }\\n\\n    function getLatestPrimaryPrice(address _token)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        address priceFeedAddress = priceFeeds[_token];\\n        require(\\n            priceFeedAddress != address(0),\\n            \\\"VaultPriceFeed: invalid price feed\\\"\\n        );\\n\\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\\n\\n        (, int256 price, , uint256 updatedAt, ) = priceFeed.latestRoundData();\\n        require(\\n            stalePriceThresholds[_token] == 0 ||\\n                updatedAt >= block.timestamp - stalePriceThresholds[_token],\\n            \\\"VaultPriceFeed: stale price\\\"\\n        );\\n\\n        require(price > 0, \\\"VaultPriceFeed: invalid price\\\");\\n\\n        return uint256(price);\\n    }\\n\\n    function getPrimaryPrice(address _token, bool _maximise)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        address priceFeedAddress = priceFeeds[_token];\\n        require(\\n            priceFeedAddress != address(0),\\n            \\\"VaultPriceFeed: invalid price feed\\\"\\n        );\\n\\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\\n\\n        uint256 price = 0;\\n        uint80 roundId = priceFeed.latestRound();\\n\\n        uint256 stalePriceThreshold = stalePriceThresholds[_token];\\n        uint256 lastUpdatedAt = block.timestamp;\\n\\n        for (uint80 i = 0; i < priceSampleSpace; i++) {\\n            if (roundId <= i) {\\n                break;\\n            }\\n            uint256 p;\\n\\n            (, int256 _p, , uint256 updatedAt, ) = priceFeed.getRoundData(\\n                roundId - i\\n            );\\n            require(\\n                stalePriceThreshold == 0 ||\\n                    updatedAt >= lastUpdatedAt - stalePriceThreshold,\\n                \\\"VaultPriceFeed: stale price\\\"\\n            );\\n            require(_p > 0, \\\"VaultPriceFeed: invalid price\\\");\\n            lastUpdatedAt = updatedAt;\\n            p = uint256(_p);\\n\\n            if (price == 0) {\\n                price = p;\\n                continue;\\n            }\\n\\n            if (_maximise && p > price) {\\n                price = p;\\n                continue;\\n            }\\n\\n            if (!_maximise && p < price) {\\n                price = p;\\n            }\\n        }\\n\\n        require(price > 0, \\\"VaultPriceFeed: could not fetch price\\\");\\n        // normalise price precision\\n        uint256 _priceDecimals = priceDecimals[_token];\\n        return (price * PRICE_PRECISION) / (10**_priceDecimals);\\n    }\\n\\n    function getSecondaryPrice(\\n        address _token,\\n        uint256 _referencePrice,\\n        bool _maximise\\n    ) public view returns (uint256) {\\n        if (secondaryPriceFeed == address(0)) {\\n            return _referencePrice;\\n        }\\n        return\\n            ISecondaryPriceFeed(secondaryPriceFeed).getPrice(\\n                _token,\\n                _referencePrice,\\n                _maximise\\n            );\\n    }\\n\\n    function getAmmPrice(address _token)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (_token == bnb) {\\n            // for bnbBusd, reserve0: BNB, reserve1: BUSD\\n            return getPairPrice(bnbBusd, true);\\n        }\\n\\n        if (_token == eth) {\\n            uint256 price0 = getPairPrice(bnbBusd, true);\\n            // for ethBnb, reserve0: ETH, reserve1: BNB\\n            uint256 price1 = getPairPrice(ethBnb, true);\\n            // this calculation could overflow if (price0 / 10**30) * (price1 / 10**30) is more than 10**17\\n            return (price0 * price1) / PRICE_PRECISION;\\n        }\\n\\n        if (_token == btc) {\\n            uint256 price0 = getPairPrice(bnbBusd, true);\\n            // for btcBnb, reserve0: BTC, reserve1: BNB\\n            uint256 price1 = getPairPrice(btcBnb, true);\\n            // this calculation could overflow if (price0 / 10**30) * (price1 / 10**30) is more than 10**17\\n            return (price0 * price1) / PRICE_PRECISION;\\n        }\\n\\n        return 0;\\n    }\\n\\n    // if divByReserve0: calculate price as reserve1 / reserve0\\n    // if !divByReserve1: calculate price as reserve0 / reserve1\\n    function getPairPrice(address _pair, bool _divByReserve0)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        (uint256 reserve0, uint256 reserve1, ) = IPancakePair(_pair)\\n            .getReserves();\\n        if (_divByReserve0) {\\n            if (reserve0 == 0) {\\n                return 0;\\n            }\\n            return (reserve1 * PRICE_PRECISION) / reserve0;\\n        }\\n        if (reserve1 == 0) {\\n            return 0;\\n        }\\n        return (reserve0 * PRICE_PRECISION) / reserve1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IVaultPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IVaultPriceFeed {\\n    function adjustmentBasisPoints(address _token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function isAdjustmentAdditive(address _token) external view returns (bool);\\n\\n    function setAdjustment(\\n        address _token,\\n        bool _isAdditive,\\n        uint256 _adjustmentBps\\n    ) external;\\n\\n    function setUseV2Pricing(bool _useV2Pricing) external;\\n\\n    function setIsAmmEnabled(bool _isEnabled) external;\\n\\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\\n\\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints)\\n        external;\\n\\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints)\\n        external;\\n\\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\\n\\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\\n\\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation)\\n        external;\\n\\n    function getPrice(\\n        address _token,\\n        bool _maximise,\\n        bool _includeAmmPrice,\\n        bool _useSwapPricing\\n    ) external view returns (uint256);\\n\\n    function getAmmPrice(address _token) external view returns (uint256);\\n\\n    function getLatestPrimaryPrice(address _token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPrimaryPrice(address _token, bool _maximise)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function setTokenConfig(\\n        address _token,\\n        address _priceFeed,\\n        uint256 _priceDecimals,\\n        bool _isStrictStable,\\n        uint256 _stalePriceThreshold\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IPriceFeed {\\n    function description() external view returns (string memory);\\n\\n    function aggregator() external view returns (address);\\n\\n    function latestAnswer() external view returns (int256);\\n\\n    function latestRound() external view returns (uint80);\\n\\n    function getRoundData(uint80 roundId)\\n        external\\n        view\\n        returns (\\n            uint80,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint80\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint80\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/ISecondaryPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface ISecondaryPriceFeed {\\n    function getPrice(\\n        address _token,\\n        uint256 _referencePrice,\\n        bool _maximise\\n    ) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASIS_POINTS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ADJUSTMENT_BASIS_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ADJUSTMENT_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SPREAD_BASIS_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_USD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"adjustmentBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnb\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbBusd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"btc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"btcBnb\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBnb\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"favorPrimaryPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getAmmPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_maximise\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_primaryPrice\",\"type\":\"uint256\"}],\"name\":\"getAmmPriceV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getLatestPrimaryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_divByReserve0\",\"type\":\"bool\"}],\"name\":\"getPairPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_maximise\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_includeAmmPrice\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_maximise\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_includeAmmPrice\",\"type\":\"bool\"}],\"name\":\"getPriceV1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_maximise\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_includeAmmPrice\",\"type\":\"bool\"}],\"name\":\"getPriceV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_maximise\",\"type\":\"bool\"}],\"name\":\"getPrimaryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referencePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_maximise\",\"type\":\"bool\"}],\"name\":\"getSecondaryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdjustmentAdditive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAmmEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSecondaryPriceEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastAdjustmentTimings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStrictPriceDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceFeeds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceSampleSpace\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAdditive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_adjustmentBps\",\"type\":\"uint256\"}],\"name\":\"setAdjustment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_favorPrimaryPrice\",\"type\":\"bool\"}],\"name\":\"setFavorPrimaryPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setIsAmmEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setIsSecondaryPriceEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxStrictPriceDeviation\",\"type\":\"uint256\"}],\"name\":\"setMaxStrictPriceDeviation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bnbBusd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ethBnb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_btcBnb\",\"type\":\"address\"}],\"name\":\"setPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceSampleSpace\",\"type\":\"uint256\"}],\"name\":\"setPriceSampleSpace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_secondaryPriceFeed\",\"type\":\"address\"}],\"name\":\"setSecondaryPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_spreadBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setSpreadBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_spreadThresholdBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setSpreadThresholdBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_priceDecimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isStrictStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_stalePriceThreshold\",\"type\":\"uint256\"}],\"name\":\"setTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_btc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bnb\",\"type\":\"address\"}],\"name\":\"setTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_useV2Pricing\",\"type\":\"bool\"}],\"name\":\"setUseV2Pricing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"spreadBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spreadThresholdBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stalePriceThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strictStableTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useV2Pricing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VaultPriceFeed", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}