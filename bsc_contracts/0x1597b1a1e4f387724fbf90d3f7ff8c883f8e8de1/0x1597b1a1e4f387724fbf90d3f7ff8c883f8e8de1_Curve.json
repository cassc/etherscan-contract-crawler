{"SourceCode": "// File: contracts/lib/ABDKMath64x64.sol\r\n\r\n// SPDX-License-Identifier: BSD-4-Clause\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /*\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /*\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x >= 0);\r\n    return uint64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) >> 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m >= 0);\r\n    require (m <\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m)));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x >= 0) {\r\n      absoluteResult = powu (uint256 (x) << 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n      negativeResult = y & 1 > 0;\r\n    }\r\n\r\n    absoluteResult >>= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x >= 0);\r\n    return int128 (sqrtu (uint256 (x) << 64));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 << 64;\r\n    uint256 ux = uint256 (x) << uint256 (127 - msb);\r\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux >> 255;\r\n      ux >>= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= uint256 (63 - (x >> 64));\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x >> 192;\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe > 0) x >>= uint256 (xe);\r\n      else x <<= uint256 (-xe);\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= uint256 (re);\r\n      else if (re < 0) result >>= uint256 (-re);\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      uint256 xx = x;\r\n      uint256 r = 1;\r\n      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n      if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n      if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n      if (xx >= 0x8) { r <<= 1; }\r\n      r = (r + x / r) >> 1;\r\n      r = (r + x / r) >> 1;\r\n      r = (r + x / r) >> 1;\r\n      r = (r + x / r) >> 1;\r\n      r = (r + x / r) >> 1;\r\n      r = (r + x / r) >> 1;\r\n      r = (r + x / r) >> 1; // Seven iterations should be enough\r\n      uint256 r1 = x / r;\r\n      return uint128 (r < r1 ? r : r1);\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IOracle.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\ninterface IOracle {\r\n    function acceptOwnership() external;\r\n\r\n    function accessController() external view returns (address);\r\n\r\n    function aggregator() external view returns (address);\r\n\r\n    function confirmAggregator(address _aggregator) external;\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function getAnswer(uint256 _roundId) external view returns (int256);\r\n\r\n    function getRoundData(uint80 _roundId)\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function getTimestamp(uint256 _roundId) external view returns (uint256);\r\n\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    function latestRound() external view returns (uint256);\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestTimestamp() external view returns (uint256);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function phaseAggregators(uint16) external view returns (address);\r\n\r\n    function phaseId() external view returns (uint16);\r\n\r\n    function proposeAggregator(address _aggregator) external;\r\n\r\n    function proposedAggregator() external view returns (address);\r\n\r\n    function proposedGetRoundData(uint80 _roundId)\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function proposedLatestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function setController(address _accessController) external;\r\n\r\n    function transferOwnership(address _to) external;\r\n\r\n    function version() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IAssimilator.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\ninterface IAssimilator {\r\n    function getRate() external view returns (uint256);\r\n\r\n    function intakeRaw(uint256 amount) external returns (int128);\r\n\r\n    function intakeRawAndGetBalance(uint256 amount) external returns (int128, int128);\r\n\r\n    function intakeNumeraire(int128 amount) external returns (uint256);\r\n\r\n    function intakeNumeraireLPRatio(\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        int128\r\n    ) external returns (uint256);\r\n\r\n    function outputRaw(address dst, uint256 amount) external returns (int128);\r\n\r\n    function outputRawAndGetBalance(address dst, uint256 amount) external returns (int128, int128);\r\n\r\n    function outputNumeraire(address dst, int128 amount) external returns (uint256);\r\n\r\n    function viewRawAmount(int128) external view returns (uint256);\r\n\r\n    function viewRawAmountLPRatio(\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        int128\r\n    ) external view returns (uint256);\r\n\r\n    function viewNumeraireAmount(uint256) external view returns (int128);\r\n\r\n    function viewNumeraireBalanceLPRatio(\r\n        uint256,\r\n        uint256,\r\n        address\r\n    ) external view returns (int128);\r\n\r\n    function viewNumeraireBalance(address) external view returns (int128);\r\n\r\n    function viewNumeraireAmountAndBalance(address, uint256) external view returns (int128, int128);\r\n}\r\n\r\n// File: contracts/Assimilators.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\n\r\nlibrary Assimilators {\r\n    using ABDKMath64x64 for int128;\r\n    using Address for address;\r\n\r\n    IAssimilator public constant iAsmltr = IAssimilator(address(0));\r\n\r\n    function delegate(address _callee, bytes memory _data) internal returns (bytes memory) {\r\n        require(_callee.isContract(), \"Assimilators/callee-is-not-a-contract\");\r\n\r\n        // solhint-disable-next-line\r\n        (bool _success, bytes memory returnData_) = _callee.delegatecall(_data);\r\n\r\n        // solhint-disable-next-line\r\n        assembly {\r\n            if eq(_success, 0) {\r\n                revert(add(returnData_, 0x20), returndatasize())\r\n            }\r\n        }\r\n\r\n        return returnData_;\r\n    }\r\n\r\n    function getRate(address _assim) internal view returns (uint256 amount_) {\r\n        amount_ = IAssimilator(_assim).getRate();\r\n    }\r\n\r\n    function viewRawAmount(address _assim, int128 _amt) internal view returns (uint256 amount_) {\r\n        amount_ = IAssimilator(_assim).viewRawAmount(_amt);\r\n    }\r\n\r\n    function viewRawAmountLPRatio(\r\n        address _assim,\r\n        uint256 _baseWeight,\r\n        uint256 _quoteWeight,\r\n        int128 _amount\r\n    ) internal view returns (uint256 amount_) {\r\n        amount_ = IAssimilator(_assim).viewRawAmountLPRatio(_baseWeight, _quoteWeight, address(this), _amount);\r\n    }\r\n\r\n    function viewNumeraireAmount(address _assim, uint256 _amt) internal view returns (int128 amt_) {\r\n        amt_ = IAssimilator(_assim).viewNumeraireAmount(_amt);\r\n    }\r\n\r\n    function viewNumeraireAmountAndBalance(address _assim, uint256 _amt)\r\n        internal\r\n        view\r\n        returns (int128 amt_, int128 bal_)\r\n    {\r\n        (amt_, bal_) = IAssimilator(_assim).viewNumeraireAmountAndBalance(address(this), _amt);\r\n    }\r\n\r\n    function viewNumeraireBalance(address _assim) internal view returns (int128 bal_) {\r\n        bal_ = IAssimilator(_assim).viewNumeraireBalance(address(this));\r\n    }\r\n\r\n    function viewNumeraireBalanceLPRatio(\r\n        uint256 _baseWeight,\r\n        uint256 _quoteWeight,\r\n        address _assim\r\n    ) internal view returns (int128 bal_) {\r\n        bal_ = IAssimilator(_assim).viewNumeraireBalanceLPRatio(_baseWeight, _quoteWeight, address(this));\r\n    }\r\n\r\n    function intakeRaw(address _assim, uint256 _amt) internal returns (int128 amt_) {\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.intakeRaw.selector, _amt);\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (int128));\r\n    }\r\n\r\n    function intakeRawAndGetBalance(address _assim, uint256 _amt) internal returns (int128 amt_, int128 bal_) {\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.intakeRawAndGetBalance.selector, _amt);\r\n\r\n        (amt_, bal_) = abi.decode(delegate(_assim, data), (int128, int128));\r\n    }\r\n\r\n    function intakeNumeraire(address _assim, int128 _amt) internal returns (uint256 amt_) {\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.intakeNumeraire.selector, _amt);\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (uint256));\r\n    }\r\n\r\n    function intakeNumeraireLPRatio(\r\n        address _assim,\r\n        uint256 _baseWeight,\r\n        uint256 _quoteWeight,\r\n        int128 _amount\r\n    ) internal returns (uint256 amt_) {\r\n        bytes memory data =\r\n            abi.encodeWithSelector(\r\n                iAsmltr.intakeNumeraireLPRatio.selector,\r\n                _baseWeight,\r\n                _quoteWeight,\r\n                address(this),\r\n                _amount\r\n            );\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (uint256));\r\n    }\r\n\r\n    function outputRaw(\r\n        address _assim,\r\n        address _dst,\r\n        uint256 _amt\r\n    ) internal returns (int128 amt_) {\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.outputRaw.selector, _dst, _amt);\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (int128));\r\n\r\n        amt_ = amt_.neg();\r\n    }\r\n\r\n    function outputRawAndGetBalance(\r\n        address _assim,\r\n        address _dst,\r\n        uint256 _amt\r\n    ) internal returns (int128 amt_, int128 bal_) {\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.outputRawAndGetBalance.selector, _dst, _amt);\r\n\r\n        (amt_, bal_) = abi.decode(delegate(_assim, data), (int128, int128));\r\n\r\n        amt_ = amt_.neg();\r\n    }\r\n\r\n    function outputNumeraire(\r\n        address _assim,\r\n        address _dst,\r\n        int128 _amt\r\n    ) internal returns (uint256 amt_) {\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.outputNumeraire.selector, _dst, _amt.abs());\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (uint256));\r\n    }\r\n}\r\n\r\n// File: contracts/Storage.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\ncontract Storage {\r\n    struct Curve {\r\n        // Curve parameters\r\n        int128 alpha;\r\n        int128 beta;\r\n        int128 delta;\r\n        int128 epsilon;\r\n        int128 lambda;\r\n        int128[] weights;\r\n        // Assets and their assimilators\r\n        Assimilator[] assets;\r\n        mapping(address => Assimilator) assimilators;\r\n        // Oracles to determine the price\r\n        // Note that 0'th index should always be USDC 1e18\r\n        // Oracle's pricing should be denominated in Currency/USDC\r\n        mapping(address => IOracle) oracles;\r\n        // ERC20 Interface\r\n        uint256 totalSupply;\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) allowances;\r\n    }\r\n\r\n    struct Assimilator {\r\n        address addr;\r\n        uint8 ix;\r\n    }\r\n\r\n    // Curve parameters\r\n    Curve public curve;\r\n\r\n    // Ownable\r\n    address public owner;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n\r\n    address[] public derivatives;\r\n    address[] public numeraires;\r\n    address[] public reserves;\r\n\r\n    // Curve operational state\r\n    bool public frozen = false;\r\n    bool public emergency = false;\r\n    bool public whitelistingStage = true;\r\n    bool internal notEntered = true;\r\n\r\n    mapping(address => uint256) public whitelistedDeposited;\r\n}\r\n\r\n// File: contracts/lib/UnsafeMath64x64.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.3;\r\n\r\nlibrary UnsafeMath64x64 {\r\n\r\n  /**\r\n   * Calculate x * y rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n\r\n  function us_mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n\r\n  function us_div (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = (int256 (x) << 64) / y;\r\n    return int128 (result);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/CurveMath.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\n\r\nlibrary CurveMath {\r\n    int128 private constant ONE = 0x10000000000000000;\r\n    int128 private constant MAX = 0x4000000000000000; // .25 in layman's terms\r\n    int128 private constant MAX_DIFF = -0x10C6F7A0B5EE;\r\n    int128 private constant ONE_WEI = 0x12;\r\n\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n    using ABDKMath64x64 for uint256;\r\n\r\n    // This is used to prevent stack too deep errors\r\n    function calculateFee(\r\n        int128 _gLiq,\r\n        int128[] memory _bals,\r\n        Storage.Curve storage curve,\r\n        int128[] memory _weights\r\n    ) internal view returns (int128 psi_) {\r\n        int128 _beta = curve.beta;\r\n        int128 _delta = curve.delta;\r\n\r\n        psi_ = calculateFee(_gLiq, _bals, _beta, _delta, _weights);\r\n    }\r\n\r\n    function calculateFee(\r\n        int128 _gLiq,\r\n        int128[] memory _bals,\r\n        int128 _beta,\r\n        int128 _delta,\r\n        int128[] memory _weights\r\n    ) internal pure returns (int128 psi_) {\r\n        uint256 _length = _bals.length;\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            int128 _ideal = _gLiq.mul(_weights[i]);\r\n            psi_ += calculateMicroFee(_bals[i], _ideal, _beta, _delta);\r\n        }\r\n    }\r\n\r\n    function calculateMicroFee(\r\n        int128 _bal,\r\n        int128 _ideal,\r\n        int128 _beta,\r\n        int128 _delta\r\n    ) private pure returns (int128 fee_) {\r\n        if (_bal < _ideal) {\r\n            int128 _threshold = _ideal.mul(ONE - _beta);\r\n\r\n            if (_bal < _threshold) {\r\n                int128 _feeMargin = _threshold - _bal;\r\n\r\n                fee_ = _feeMargin.div(_ideal);\r\n                fee_ = fee_.mul(_delta);\r\n\r\n                if (fee_ > MAX) fee_ = MAX;\r\n\r\n                fee_ = fee_.mul(_feeMargin);\r\n            } else fee_ = 0;\r\n        } else {\r\n            int128 _threshold = _ideal.mul(ONE + _beta);\r\n\r\n            if (_bal > _threshold) {\r\n                int128 _feeMargin = _bal - _threshold;\r\n\r\n                fee_ = _feeMargin.div(_ideal);\r\n                fee_ = fee_.mul(_delta);\r\n\r\n                if (fee_ > MAX) fee_ = MAX;\r\n\r\n                fee_ = fee_.mul(_feeMargin);\r\n            } else fee_ = 0;\r\n        }\r\n    }\r\n\r\n    function calculateTrade(\r\n        Storage.Curve storage curve,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128[] memory _oBals,\r\n        int128[] memory _nBals,\r\n        int128 _inputAmt,\r\n        uint256 _outputIndex\r\n    ) internal view returns (int128 outputAmt_) {\r\n        outputAmt_ = -_inputAmt;\r\n\r\n        int128 _lambda = curve.lambda;\r\n        int128[] memory _weights = curve.weights;\r\n\r\n        int128 _omega = calculateFee(_oGLiq, _oBals, curve, _weights);\r\n        int128 _psi;\r\n\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            _psi = calculateFee(_nGLiq, _nBals, curve, _weights);\r\n\r\n            int128 prevAmount;\r\n            {\r\n                prevAmount = outputAmt_;\r\n                outputAmt_ = _omega < _psi ? -(_inputAmt + _omega - _psi) : -(_inputAmt + _lambda.mul(_omega - _psi));\r\n            }\r\n\r\n            if (outputAmt_ / 1e13 == prevAmount / 1e13) {\r\n                _nGLiq = _oGLiq + _inputAmt + outputAmt_;\r\n\r\n                _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;\r\n\r\n                enforceHalts(curve, _oGLiq, _nGLiq, _oBals, _nBals, _weights);\r\n\r\n                enforceSwapInvariant(_oGLiq, _omega, _nGLiq, _psi);\r\n\r\n                return outputAmt_;\r\n            } else {\r\n                _nGLiq = _oGLiq + _inputAmt + outputAmt_;\r\n\r\n                _nBals[_outputIndex] = _oBals[_outputIndex].add(outputAmt_);\r\n            }\r\n        }\r\n\r\n        revert(\"Curve/swap-convergence-failed\");\r\n    }\r\n\r\n    function calculateLiquidityMembrane(\r\n        Storage.Curve storage curve,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128[] memory _oBals,\r\n        int128[] memory _nBals\r\n    ) internal view returns (int128 curves_) {\r\n        enforceHalts(curve, _oGLiq, _nGLiq, _oBals, _nBals, curve.weights);\r\n\r\n        int128 _omega;\r\n        int128 _psi;\r\n\r\n        {\r\n            int128 _beta = curve.beta;\r\n            int128 _delta = curve.delta;\r\n            int128[] memory _weights = curve.weights;\r\n\r\n            _omega = calculateFee(_oGLiq, _oBals, _beta, _delta, _weights);\r\n            _psi = calculateFee(_nGLiq, _nBals, _beta, _delta, _weights);\r\n        }\r\n\r\n        int128 _feeDiff = _psi.sub(_omega);\r\n        int128 _liqDiff = _nGLiq.sub(_oGLiq);\r\n        int128 _oUtil = _oGLiq.sub(_omega);\r\n        int128 _totalShells = curve.totalSupply.divu(1e18);\r\n        int128 _curveMultiplier;\r\n\r\n        if (_totalShells == 0) {\r\n            curves_ = _nGLiq.sub(_psi);\r\n        } else if (_feeDiff >= 0) {\r\n            _curveMultiplier = _liqDiff.sub(_feeDiff).div(_oUtil);\r\n        } else {\r\n            _curveMultiplier = _liqDiff.sub(curve.lambda.mul(_feeDiff));\r\n\r\n            _curveMultiplier = _curveMultiplier.div(_oUtil);\r\n        }\r\n\r\n        if (_totalShells != 0) {\r\n            curves_ = _totalShells.mul(_curveMultiplier);\r\n\r\n            enforceLiquidityInvariant(_totalShells, curves_, _oGLiq, _nGLiq, _omega, _psi);\r\n        }\r\n    }\r\n\r\n    function enforceSwapInvariant(\r\n        int128 _oGLiq,\r\n        int128 _omega,\r\n        int128 _nGLiq,\r\n        int128 _psi\r\n    ) private pure {\r\n        int128 _nextUtil = _nGLiq - _psi;\r\n\r\n        int128 _prevUtil = _oGLiq - _omega;\r\n\r\n        int128 _diff = _nextUtil - _prevUtil;\r\n\r\n        require(0 < _diff || _diff >= MAX_DIFF, \"Curve/swap-invariant-violation\");\r\n    }\r\n\r\n    function enforceLiquidityInvariant(\r\n        int128 _totalShells,\r\n        int128 _newShells,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128 _omega,\r\n        int128 _psi\r\n    ) internal pure {\r\n        if (_totalShells == 0 || 0 == _totalShells + _newShells) return;\r\n\r\n        int128 _prevUtilPerShell = _oGLiq.sub(_omega).div(_totalShells);\r\n\r\n        int128 _nextUtilPerShell = _nGLiq.sub(_psi).div(_totalShells.add(_newShells));\r\n\r\n        int128 _diff = _nextUtilPerShell - _prevUtilPerShell;\r\n\r\n        require(0 < _diff || _diff >= MAX_DIFF, \"Curve/liquidity-invariant-violation\");\r\n    }\r\n\r\n    function enforceHalts(\r\n        Storage.Curve storage curve,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128[] memory _oBals,\r\n        int128[] memory _nBals,\r\n        int128[] memory _weights\r\n    ) private view {\r\n        uint256 _length = _nBals.length;\r\n        int128 _alpha = curve.alpha;\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            int128 _nIdeal = _nGLiq.mul(_weights[i]);\r\n\r\n            if (_nBals[i] > _nIdeal) {\r\n                int128 _upperAlpha = ONE + _alpha;\r\n\r\n                int128 _nHalt = _nIdeal.mul(_upperAlpha);\r\n\r\n                if (_nBals[i] > _nHalt) {\r\n                    int128 _oHalt = _oGLiq.mul(_weights[i]).mul(_upperAlpha);\r\n\r\n                    if (_oBals[i] < _oHalt) revert(\"Curve/upper-halt\");\r\n                    if (_nBals[i] - _nHalt > _oBals[i] - _oHalt) revert(\"Curve/upper-halt\");\r\n                }\r\n            } else {\r\n                int128 _lowerAlpha = ONE - _alpha;\r\n\r\n                int128 _nHalt = _nIdeal.mul(_lowerAlpha);\r\n\r\n                if (_nBals[i] < _nHalt) {\r\n                    int128 _oHalt = _oGLiq.mul(_weights[i]);\r\n                    _oHalt = _oHalt.mul(_lowerAlpha);\r\n\r\n                    if (_oBals[i] > _oHalt) revert(\"Curve/lower-halt\");\r\n                    if (_nHalt - _nBals[i] > _oHalt - _oBals[i]) revert(\"Curve/lower-halt\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Orchestrator.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Orchestrator {\r\n    using SafeERC20 for IERC20;\r\n    using ABDKMath64x64 for int128;\r\n    using ABDKMath64x64 for uint256;\r\n\r\n    int128 private constant ONE_WEI = 0x12;\r\n\r\n    event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\r\n\r\n    event AssetIncluded(address indexed numeraire, address indexed reserve, uint256 weight);\r\n\r\n    event AssimilatorIncluded(\r\n        address indexed derivative,\r\n        address indexed numeraire,\r\n        address indexed reserve,\r\n        address assimilator\r\n    );\r\n\r\n    function setParams(\r\n        Storage.Curve storage curve,\r\n        uint256 _alpha,\r\n        uint256 _beta,\r\n        uint256 _feeAtHalt,\r\n        uint256 _epsilon,\r\n        uint256 _lambda\r\n    ) external {\r\n        require(0 < _alpha && _alpha < 1e18, \"Curve/parameter-invalid-alpha\");\r\n\r\n        require(_beta < _alpha, \"Curve/parameter-invalid-beta\");\r\n\r\n        require(_feeAtHalt <= 5e17, \"Curve/parameter-invalid-max\");\r\n\r\n        require(_epsilon <= 1e16, \"Curve/parameter-invalid-epsilon\");\r\n\r\n        require(_lambda <= 1e18, \"Curve/parameter-invalid-lambda\");\r\n\r\n        int128 _omega = getFee(curve);\r\n\r\n        curve.alpha = (_alpha + 1).divu(1e18);\r\n\r\n        curve.beta = (_beta + 1).divu(1e18);\r\n\r\n        curve.delta = (_feeAtHalt).divu(1e18).div(uint256(2).fromUInt().mul(curve.alpha.sub(curve.beta))) + ONE_WEI;\r\n\r\n        curve.epsilon = (_epsilon + 1).divu(1e18);\r\n\r\n        curve.lambda = (_lambda + 1).divu(1e18);\r\n\r\n        int128 _psi = getFee(curve);\r\n\r\n        require(_omega >= _psi, \"Curve/parameters-increase-fee\");\r\n\r\n        emit ParametersSet(_alpha, _beta, curve.delta.mulu(1e18), _epsilon, _lambda);\r\n    }\r\n\r\n    function getFee(Storage.Curve storage curve) private view returns (int128 fee_) {\r\n        int128 _gLiq;\r\n\r\n        // Always pairs\r\n        int128[] memory _bals = new int128[](2);\r\n\r\n        for (uint256 i = 0; i < _bals.length; i++) {\r\n            int128 _bal = Assimilators.viewNumeraireBalance(curve.assets[i].addr);\r\n\r\n            _bals[i] = _bal;\r\n\r\n            _gLiq += _bal;\r\n        }\r\n\r\n        fee_ = CurveMath.calculateFee(_gLiq, _bals, curve.beta, curve.delta, curve.weights);\r\n    }\r\n\r\n    function initialize(\r\n        Storage.Curve storage curve,\r\n        address[] storage numeraires,\r\n        address[] storage reserves,\r\n        address[] storage derivatives,\r\n        address[] calldata _assets,\r\n        uint256[] calldata _assetWeights\r\n    ) external {\r\n        require(_assetWeights.length == 2, \"Curve/assetWeights-must-be-length-two\");\r\n        require(_assets.length % 5 == 0, \"Curve/assets-must-be-divisible-by-five\");\r\n\r\n        for (uint256 i = 0; i < _assetWeights.length; i++) {\r\n            uint256 ix = i * 5;\r\n\r\n            numeraires.push(_assets[ix]);\r\n            derivatives.push(_assets[ix]);\r\n\r\n            reserves.push(_assets[2 + ix]);\r\n            if (_assets[ix] != _assets[2 + ix]) derivatives.push(_assets[2 + ix]);\r\n\r\n            includeAsset(\r\n                curve,\r\n                _assets[ix], // numeraire\r\n                _assets[1 + ix], // numeraire assimilator\r\n                _assets[2 + ix], // reserve\r\n                _assets[3 + ix], // reserve assimilator\r\n                _assets[4 + ix], // reserve approve to\r\n                _assetWeights[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function includeAsset(\r\n        Storage.Curve storage curve,\r\n        address _numeraire,\r\n        address _numeraireAssim,\r\n        address _reserve,\r\n        address _reserveAssim,\r\n        address _reserveApproveTo,\r\n        uint256 _weight\r\n    ) private {\r\n        require(_numeraire != address(0), \"Curve/numeraire-cannot-be-zeroth-address\");\r\n\r\n        require(_numeraireAssim != address(0), \"Curve/numeraire-assimilator-cannot-be-zeroth-address\");\r\n\r\n        require(_reserve != address(0), \"Curve/reserve-cannot-be-zeroth-address\");\r\n\r\n        require(_reserveAssim != address(0), \"Curve/reserve-assimilator-cannot-be-zeroth-address\");\r\n\r\n        require(_weight < 1e18, \"Curve/weight-must-be-less-than-one\");\r\n\r\n        if (_numeraire != _reserve) IERC20(_numeraire).safeApprove(_reserveApproveTo, uint256(-1));\r\n\r\n        Storage.Assimilator storage _numeraireAssimilator = curve.assimilators[_numeraire];\r\n\r\n        _numeraireAssimilator.addr = _numeraireAssim;\r\n\r\n        _numeraireAssimilator.ix = uint8(curve.assets.length);\r\n\r\n        Storage.Assimilator storage _reserveAssimilator = curve.assimilators[_reserve];\r\n\r\n        _reserveAssimilator.addr = _reserveAssim;\r\n\r\n        _reserveAssimilator.ix = uint8(curve.assets.length);\r\n\r\n        int128 __weight = _weight.divu(1e18).add(uint256(1).divu(1e18));\r\n\r\n        curve.weights.push(__weight);\r\n\r\n        curve.assets.push(_numeraireAssimilator);\r\n\r\n        emit AssetIncluded(_numeraire, _reserve, _weight);\r\n\r\n        emit AssimilatorIncluded(_numeraire, _numeraire, _reserve, _numeraireAssim);\r\n\r\n        if (_numeraireAssim != _reserveAssim) {\r\n            emit AssimilatorIncluded(_reserve, _numeraire, _reserve, _reserveAssim);\r\n        }\r\n    }\r\n\r\n    function includeAssimilator(\r\n        Storage.Curve storage curve,\r\n        address _derivative,\r\n        address _numeraire,\r\n        address _reserve,\r\n        address _assimilator,\r\n        address _derivativeApproveTo\r\n    ) private {\r\n        require(_derivative != address(0), \"Curve/derivative-cannot-be-zeroth-address\");\r\n\r\n        require(_numeraire != address(0), \"Curve/numeraire-cannot-be-zeroth-address\");\r\n\r\n        require(_reserve != address(0), \"Curve/numeraire-cannot-be-zeroth-address\");\r\n\r\n        require(_assimilator != address(0), \"Curve/assimilator-cannot-be-zeroth-address\");\r\n\r\n        IERC20(_numeraire).safeApprove(_derivativeApproveTo, uint256(-1));\r\n\r\n        Storage.Assimilator storage _numeraireAssim = curve.assimilators[_numeraire];\r\n\r\n        curve.assimilators[_derivative] = Storage.Assimilator(_assimilator, _numeraireAssim.ix);\r\n\r\n        emit AssimilatorIncluded(_derivative, _numeraire, _reserve, _assimilator);\r\n    }\r\n\r\n    function viewCurve(Storage.Curve storage curve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 alpha_,\r\n            uint256 beta_,\r\n            uint256 delta_,\r\n            uint256 epsilon_,\r\n            uint256 lambda_\r\n        )\r\n    {\r\n        alpha_ = curve.alpha.mulu(1e18);\r\n\r\n        beta_ = curve.beta.mulu(1e18);\r\n\r\n        delta_ = curve.delta.mulu(1e18);\r\n\r\n        epsilon_ = curve.epsilon.mulu(1e18);\r\n\r\n        lambda_ = curve.lambda.mulu(1e18);\r\n    }\r\n}\r\n\r\n// File: contracts/ProportionalLiquidity.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary ProportionalLiquidity {\r\n    using ABDKMath64x64 for uint256;\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    int128 public constant ONE = 0x10000000000000000;\r\n    int128 public constant ONE_WEI = 0x12;\r\n\r\n    function proportionalDeposit(Storage.Curve storage curve, uint256 _deposit)\r\n        external\r\n        returns (uint256 curves_, uint256[] memory)\r\n    {\r\n        int128 __deposit = _deposit.divu(1e18);\r\n\r\n        uint256 _length = curve.assets.length;\r\n\r\n        uint256[] memory deposits_ = new uint256[](_length);\r\n\r\n        (int128 _oGLiq, int128[] memory _oBals) = getGrossLiquidityAndBalancesForDeposit(curve);\r\n\r\n        // Needed to calculate liquidity invariant\r\n        (int128 _oGLiqProp, int128[] memory _oBalsProp) = getGrossLiquidityAndBalances(curve);\r\n\r\n        // No liquidity, oracle sets the ratio\r\n        if (_oGLiq == 0) {\r\n            for (uint256 i = 0; i < _length; i++) {\r\n                // Variable here to avoid stack-too-deep errors\r\n                int128 _d = __deposit.mul(curve.weights[i]);\r\n                deposits_[i] = Assimilators.intakeNumeraire(curve.assets[i].addr, _d.add(ONE_WEI));\r\n            }\r\n        } else {\r\n            // We already have an existing pool ratio\r\n            // which must be respected\r\n            int128 _multiplier = __deposit.div(_oGLiq);\r\n\r\n            uint256 _baseWeight = curve.weights[0].mulu(1e18);\r\n            uint256 _quoteWeight = curve.weights[1].mulu(1e18);\r\n\r\n            for (uint256 i = 0; i < _length; i++) {\r\n                deposits_[i] = Assimilators.intakeNumeraireLPRatio(\r\n                    curve.assets[i].addr,\r\n                    _baseWeight,\r\n                    _quoteWeight,\r\n                    _oBals[i].mul(_multiplier).add(ONE_WEI)\r\n                );\r\n            }\r\n        }\r\n\r\n        int128 _totalShells = curve.totalSupply.divu(1e18);\r\n\r\n        int128 _newShells = __deposit;\r\n\r\n        if (_totalShells > 0) {\r\n            _newShells = __deposit.div(_oGLiq);\r\n            _newShells = _newShells.mul(_totalShells);\r\n        }\r\n\r\n        requireLiquidityInvariant(curve, _totalShells, _newShells, _oGLiqProp, _oBalsProp);\r\n\r\n        mint(curve, msg.sender, curves_ = _newShells.mulu(1e18));\r\n\r\n        return (curves_, deposits_);\r\n    }\r\n\r\n    function viewProportionalDeposit(Storage.Curve storage curve, uint256 _deposit)\r\n        external\r\n        view\r\n        returns (uint256 curves_, uint256[] memory)\r\n    {\r\n        int128 __deposit = _deposit.divu(1e18);\r\n\r\n        uint256 _length = curve.assets.length;\r\n\r\n        (int128 _oGLiq, int128[] memory _oBals) = getGrossLiquidityAndBalancesForDeposit(curve);\r\n\r\n        uint256[] memory deposits_ = new uint256[](_length);\r\n\r\n        // No liquidity\r\n        if (_oGLiq == 0) {\r\n            for (uint256 i = 0; i < _length; i++) {\r\n                deposits_[i] = Assimilators.viewRawAmount(\r\n                    curve.assets[i].addr,\r\n                    __deposit.mul(curve.weights[i]).add(ONE_WEI)\r\n                );\r\n            }\r\n        } else {\r\n            // We already have an existing pool ratio\r\n            // this must be respected\r\n            int128 _multiplier = __deposit.div(_oGLiq);\r\n\r\n            uint256 _baseWeight = curve.weights[0].mulu(1e18);\r\n            uint256 _quoteWeight = curve.weights[1].mulu(1e18);\r\n\r\n            // Deposits into the pool is determined by existing LP ratio\r\n            for (uint256 i = 0; i < _length; i++) {\r\n                deposits_[i] = Assimilators.viewRawAmountLPRatio(\r\n                    curve.assets[i].addr,\r\n                    _baseWeight,\r\n                    _quoteWeight,\r\n                    _oBals[i].mul(_multiplier).add(ONE_WEI)\r\n                );\r\n            }\r\n        }\r\n\r\n        int128 _totalShells = curve.totalSupply.divu(1e18);\r\n\r\n        int128 _newShells = __deposit;\r\n\r\n        if (_totalShells > 0) {\r\n            _newShells = __deposit.div(_oGLiq);\r\n            _newShells = _newShells.mul(_totalShells);\r\n        }\r\n\r\n        curves_ = _newShells.mulu(1e18);\r\n\r\n        return (curves_, deposits_);\r\n    }\r\n\r\n    function emergencyProportionalWithdraw(Storage.Curve storage curve, uint256 _withdrawal)\r\n        external\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        (, int128[] memory _oBals) = getGrossLiquidityAndBalances(curve);\r\n\r\n        uint256[] memory withdrawals_ = new uint256[](_length);\r\n\r\n        int128 _totalShells = curve.totalSupply.divu(1e18);\r\n        int128 __withdrawal = _withdrawal.divu(1e18);\r\n\r\n        int128 _multiplier = __withdrawal.div(_totalShells);\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            withdrawals_[i] = Assimilators.outputNumeraire(\r\n                curve.assets[i].addr,\r\n                msg.sender,\r\n                _oBals[i].mul(_multiplier)\r\n            );\r\n        }\r\n\r\n        burn(curve, msg.sender, _withdrawal);\r\n\r\n        return withdrawals_;\r\n    }\r\n\r\n    function proportionalWithdraw(Storage.Curve storage curve, uint256 _withdrawal)\r\n        external\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        (int128 _oGLiq, int128[] memory _oBals) = getGrossLiquidityAndBalances(curve);\r\n\r\n        uint256[] memory withdrawals_ = new uint256[](_length);\r\n\r\n        int128 _totalShells = curve.totalSupply.divu(1e18);\r\n        int128 __withdrawal = _withdrawal.divu(1e18);\r\n\r\n        int128 _multiplier = __withdrawal.div(_totalShells);\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            withdrawals_[i] = Assimilators.outputNumeraire(\r\n                curve.assets[i].addr,\r\n                msg.sender,\r\n                _oBals[i].mul(_multiplier)\r\n            );\r\n        }\r\n\r\n        requireLiquidityInvariant(curve, _totalShells, __withdrawal.neg(), _oGLiq, _oBals);\r\n\r\n        burn(curve, msg.sender, _withdrawal);\r\n\r\n        return withdrawals_;\r\n    }\r\n\r\n    function viewProportionalWithdraw(Storage.Curve storage curve, uint256 _withdrawal)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        (, int128[] memory _oBals) = getGrossLiquidityAndBalances(curve);\r\n\r\n        uint256[] memory withdrawals_ = new uint256[](_length);\r\n\r\n        int128 _multiplier = _withdrawal.divu(1e18).div(curve.totalSupply.divu(1e18));\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            withdrawals_[i] = Assimilators.viewRawAmount(curve.assets[i].addr, _oBals[i].mul(_multiplier));\r\n        }\r\n\r\n        return withdrawals_;\r\n    }\r\n\r\n    function getGrossLiquidityAndBalancesForDeposit(Storage.Curve storage curve)\r\n        internal\r\n        view\r\n        returns (int128 grossLiquidity_, int128[] memory)\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        int128[] memory balances_ = new int128[](_length);\r\n        uint256 _baseWeight = curve.weights[0].mulu(1e18);\r\n        uint256 _quoteWeight = curve.weights[1].mulu(1e18);\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            int128 _bal = Assimilators.viewNumeraireBalanceLPRatio(_baseWeight, _quoteWeight, curve.assets[i].addr);\r\n\r\n            balances_[i] = _bal;\r\n            grossLiquidity_ += _bal;\r\n        }\r\n\r\n        return (grossLiquidity_, balances_);\r\n    }\r\n\r\n    function getGrossLiquidityAndBalances(Storage.Curve storage curve)\r\n        internal\r\n        view\r\n        returns (int128 grossLiquidity_, int128[] memory)\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        int128[] memory balances_ = new int128[](_length);\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            int128 _bal = Assimilators.viewNumeraireBalance(curve.assets[i].addr);\r\n\r\n            balances_[i] = _bal;\r\n            grossLiquidity_ += _bal;\r\n        }\r\n\r\n        return (grossLiquidity_, balances_);\r\n    }\r\n\r\n    function requireLiquidityInvariant(\r\n        Storage.Curve storage curve,\r\n        int128 _curves,\r\n        int128 _newShells,\r\n        int128 _oGLiq,\r\n        int128[] memory _oBals\r\n    ) private view {\r\n        (int128 _nGLiq, int128[] memory _nBals) = getGrossLiquidityAndBalances(curve);\r\n\r\n        int128 _beta = curve.beta;\r\n        int128 _delta = curve.delta;\r\n        int128[] memory _weights = curve.weights;\r\n\r\n        int128 _omega = CurveMath.calculateFee(_oGLiq, _oBals, _beta, _delta, _weights);\r\n\r\n        int128 _psi = CurveMath.calculateFee(_nGLiq, _nBals, _beta, _delta, _weights);\r\n\r\n        CurveMath.enforceLiquidityInvariant(_curves, _newShells, _oGLiq, _nGLiq, _omega, _psi);\r\n    }\r\n\r\n    function burn(\r\n        Storage.Curve storage curve,\r\n        address account,\r\n        uint256 amount\r\n    ) private {\r\n        curve.balances[account] = burnSub(curve.balances[account], amount);\r\n\r\n        curve.totalSupply = burnSub(curve.totalSupply, amount);\r\n\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n\r\n    function mint(\r\n        Storage.Curve storage curve,\r\n        address account,\r\n        uint256 amount\r\n    ) private {\r\n        curve.totalSupply = mintAdd(curve.totalSupply, amount);\r\n\r\n        curve.balances[account] = mintAdd(curve.balances[account], amount);\r\n\r\n        emit Transfer(address(0), msg.sender, amount);\r\n    }\r\n\r\n    function mintAdd(uint256 x, uint256 y) private pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"Curve/mint-overflow\");\r\n    }\r\n\r\n    function burnSub(uint256 x, uint256 y) private pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"Curve/burn-underflow\");\r\n    }\r\n}\r\n\r\n// File: contracts/Swaps.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Swaps {\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n    using ABDKMath64x64 for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    event Trade(\r\n        address indexed trader,\r\n        address indexed origin,\r\n        address indexed target,\r\n        uint256 originAmount,\r\n        uint256 targetAmount\r\n    );\r\n\r\n    int128 public constant ONE = 0x10000000000000000;\r\n\r\n    function getOriginAndTarget(\r\n        Storage.Curve storage curve,\r\n        address _o,\r\n        address _t\r\n    ) private view returns (Storage.Assimilator memory, Storage.Assimilator memory) {\r\n        Storage.Assimilator memory o_ = curve.assimilators[_o];\r\n        Storage.Assimilator memory t_ = curve.assimilators[_t];\r\n\r\n        require(o_.addr != address(0), \"Curve/origin-not-supported\");\r\n        require(t_.addr != address(0), \"Curve/target-not-supported\");\r\n\r\n        return (o_, t_);\r\n    }\r\n\r\n    function originSwap(\r\n        Storage.Curve storage curve,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _originAmount,\r\n        address _recipient\r\n    ) external returns (uint256 tAmt_) {\r\n        (Storage.Assimilator memory _o, Storage.Assimilator memory _t) = getOriginAndTarget(curve, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix)\r\n            return Assimilators.outputNumeraire(_t.addr, _recipient, Assimilators.intakeRaw(_o.addr, _originAmount));\r\n\r\n        (int128 _amt, int128 _oGLiq, int128 _nGLiq, int128[] memory _oBals, int128[] memory _nBals) =\r\n            getOriginSwapData(curve, _o.ix, _t.ix, _o.addr, _originAmount);\r\n\r\n        _amt = CurveMath.calculateTrade(curve, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _t.ix);\r\n\r\n        _amt = _amt.us_mul(ONE - curve.epsilon);\r\n\r\n        tAmt_ = Assimilators.outputNumeraire(_t.addr, _recipient, _amt);\r\n\r\n        emit Trade(msg.sender, _origin, _target, _originAmount, tAmt_);\r\n    }\r\n\r\n    function viewOriginSwap(\r\n        Storage.Curve storage curve,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _originAmount\r\n    ) external view returns (uint256 tAmt_) {\r\n        (Storage.Assimilator memory _o, Storage.Assimilator memory _t) = getOriginAndTarget(curve, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix)\r\n            return Assimilators.viewRawAmount(_t.addr, Assimilators.viewNumeraireAmount(_o.addr, _originAmount));\r\n\r\n        (int128 _amt, int128 _oGLiq, int128 _nGLiq, int128[] memory _nBals, int128[] memory _oBals) =\r\n            viewOriginSwapData(curve, _o.ix, _t.ix, _originAmount, _o.addr);\r\n\r\n        _amt = CurveMath.calculateTrade(curve, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _t.ix);\r\n\r\n        _amt = _amt.us_mul(ONE - curve.epsilon);\r\n\r\n        tAmt_ = Assimilators.viewRawAmount(_t.addr, _amt.abs());\r\n    }\r\n\r\n    function targetSwap(\r\n        Storage.Curve storage curve,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _targetAmount,\r\n        address _recipient\r\n    ) external returns (uint256 oAmt_) {\r\n        (Storage.Assimilator memory _o, Storage.Assimilator memory _t) = getOriginAndTarget(curve, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix)\r\n            return Assimilators.intakeNumeraire(_o.addr, Assimilators.outputRaw(_t.addr, _recipient, _targetAmount));\r\n\r\n        // If the origin is the quote currency (i.e. usdc)\r\n        // we need to make sure to massage the _targetAmount\r\n        // by dividing it by the exchange rate (so it gets\r\n        // multiplied later to reach the same target amount).\r\n        // Inelegant solution, but this way we don't need to\r\n        // re-write large chunks of the code-base\r\n\r\n        // curve.assets[1].addr = quoteCurrency\r\n        // no variable assignment due to stack too deep\r\n        if (curve.assets[1].addr == _o.addr) {\r\n            _targetAmount = _targetAmount.mul(1e8).div(Assimilators.getRate(_t.addr));\r\n        }\r\n\r\n        (int128 _amt, int128 _oGLiq, int128 _nGLiq, int128[] memory _oBals, int128[] memory _nBals) =\r\n            getTargetSwapData(curve, _t.ix, _o.ix, _t.addr, _recipient, _targetAmount);\r\n\r\n        _amt = CurveMath.calculateTrade(curve, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _o.ix);\r\n\r\n        // If the origin is the quote currency (i.e. usdc)\r\n        // we need to make sure to massage the _amt too\r\n\r\n        // curve.assets[1].addr = quoteCurrency\r\n        if (curve.assets[1].addr == _o.addr) {\r\n            _amt = _amt.mul(Assimilators.getRate(_t.addr).divu(1e8));\r\n        }\r\n\r\n        _amt = _amt.us_mul(ONE + curve.epsilon);\r\n\r\n        oAmt_ = Assimilators.intakeNumeraire(_o.addr, _amt);\r\n\r\n        emit Trade(msg.sender, _origin, _target, oAmt_, _targetAmount);\r\n    }\r\n\r\n    function viewTargetSwap(\r\n        Storage.Curve storage curve,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _targetAmount\r\n    ) external view returns (uint256 oAmt_) {\r\n        (Storage.Assimilator memory _o, Storage.Assimilator memory _t) = getOriginAndTarget(curve, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix)\r\n            return Assimilators.viewRawAmount(_o.addr, Assimilators.viewNumeraireAmount(_t.addr, _targetAmount));\r\n\r\n        // If the origin is the quote currency (i.e. usdc)\r\n        // we need to make sure to massage the _targetAmount\r\n        // by dividing it by the exchange rate (so it gets\r\n        // multiplied later to reach the same target amount).\r\n        // Inelegant solution, but this way we don't need to\r\n        // re-write large chunks of the code-base\r\n\r\n        // curve.assets[1].addr = quoteCurrency\r\n        // no variable assignment due to stack too deep\r\n        if (curve.assets[1].addr == _o.addr) {\r\n            _targetAmount = _targetAmount.mul(1e8).div(Assimilators.getRate(_t.addr));\r\n        }\r\n\r\n        (int128 _amt, int128 _oGLiq, int128 _nGLiq, int128[] memory _nBals, int128[] memory _oBals) =\r\n            viewTargetSwapData(curve, _t.ix, _o.ix, _targetAmount, _t.addr);\r\n\r\n        _amt = CurveMath.calculateTrade(curve, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _o.ix);\r\n\r\n        // If the origin is the quote currency (i.e. usdc)\r\n        // we need to make sure to massage the _amt too\r\n\r\n        // curve.assets[1].addr = quoteCurrency\r\n        if (curve.assets[1].addr == _o.addr) {\r\n            _amt = _amt.mul(Assimilators.getRate(_t.addr).divu(1e8));\r\n        }\r\n\r\n        _amt = _amt.us_mul(ONE + curve.epsilon);\r\n\r\n        oAmt_ = Assimilators.viewRawAmount(_o.addr, _amt);\r\n    }\r\n\r\n    function getOriginSwapData(\r\n        Storage.Curve storage curve,\r\n        uint256 _inputIx,\r\n        uint256 _outputIx,\r\n        address _assim,\r\n        uint256 _amt\r\n    )\r\n        private\r\n        returns (\r\n            int128 amt_,\r\n            int128 oGLiq_,\r\n            int128 nGLiq_,\r\n            int128[] memory,\r\n            int128[] memory\r\n        )\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        Storage.Assimilator[] memory _reserves = curve.assets;\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(_reserves[i].addr);\r\n            else {\r\n                int128 _bal;\r\n                (amt_, _bal) = Assimilators.intakeRawAndGetBalance(_assim, _amt);\r\n\r\n                oBals_[i] = _bal.sub(amt_);\r\n                nBals_[i] = _bal;\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n        return (amt_, oGLiq_, nGLiq_, oBals_, nBals_);\r\n    }\r\n\r\n    function getTargetSwapData(\r\n        Storage.Curve storage curve,\r\n        uint256 _inputIx,\r\n        uint256 _outputIx,\r\n        address _assim,\r\n        address _recipient,\r\n        uint256 _amt\r\n    )\r\n        private\r\n        returns (\r\n            int128 amt_,\r\n            int128 oGLiq_,\r\n            int128 nGLiq_,\r\n            int128[] memory,\r\n            int128[] memory\r\n        )\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        Storage.Assimilator[] memory _reserves = curve.assets;\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(_reserves[i].addr);\r\n            else {\r\n                int128 _bal;\r\n                (amt_, _bal) = Assimilators.outputRawAndGetBalance(_assim, _recipient, _amt);\r\n\r\n                oBals_[i] = _bal.sub(amt_);\r\n                nBals_[i] = _bal;\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n        return (amt_, oGLiq_, nGLiq_, oBals_, nBals_);\r\n    }\r\n\r\n    function viewOriginSwapData(\r\n        Storage.Curve storage curve,\r\n        uint256 _inputIx,\r\n        uint256 _outputIx,\r\n        uint256 _amt,\r\n        address _assim\r\n    )\r\n        private\r\n        view\r\n        returns (\r\n            int128 amt_,\r\n            int128 oGLiq_,\r\n            int128 nGLiq_,\r\n            int128[] memory,\r\n            int128[] memory\r\n        )\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        int128[] memory oBals_ = new int128[](_length);\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(curve.assets[i].addr);\r\n            else {\r\n                int128 _bal;\r\n                (amt_, _bal) = Assimilators.viewNumeraireAmountAndBalance(_assim, _amt);\r\n\r\n                oBals_[i] = _bal;\r\n                nBals_[i] = _bal.add(amt_);\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n        return (amt_, oGLiq_, nGLiq_, nBals_, oBals_);\r\n    }\r\n\r\n    function viewTargetSwapData(\r\n        Storage.Curve storage curve,\r\n        uint256 _inputIx,\r\n        uint256 _outputIx,\r\n        uint256 _amt,\r\n        address _assim\r\n    )\r\n        private\r\n        view\r\n        returns (\r\n            int128 amt_,\r\n            int128 oGLiq_,\r\n            int128 nGLiq_,\r\n            int128[] memory,\r\n            int128[] memory\r\n        )\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        int128[] memory oBals_ = new int128[](_length);\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(curve.assets[i].addr);\r\n            else {\r\n                int128 _bal;\r\n                (amt_, _bal) = Assimilators.viewNumeraireAmountAndBalance(_assim, _amt);\r\n                amt_ = amt_.neg();\r\n\r\n                oBals_[i] = _bal;\r\n                nBals_[i] = _bal.add(amt_);\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n        return (amt_, oGLiq_, nGLiq_, nBals_, oBals_);\r\n    }\r\n}\r\n\r\n// File: contracts/ViewLiquidity.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\n\r\nlibrary ViewLiquidity {\r\n    using ABDKMath64x64 for int128;\r\n\r\n    function viewLiquidity(Storage.Curve storage curve)\r\n        external\r\n        view\r\n        returns (uint256 total_, uint256[] memory individual_)\r\n    {\r\n        uint256 _length = curve.assets.length;\r\n\r\n        individual_ = new uint256[](_length);\r\n\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            uint256 _liquidity = Assimilators.viewNumeraireBalance(curve.assets[i].addr).mulu(1e18);\r\n\r\n            total_ += _liquidity;\r\n            individual_[i] = _liquidity;\r\n        }\r\n\r\n        return (total_, individual_);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/cryptography/MerkleProof.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n// File: contracts/MerkleProver.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\ncontract MerkleProver {\r\n    bytes32 public immutable merkleRoot = bytes32(0xf4dbd0fb1957570029a847490cb3d731a45962072953ba7da80ff132ccd97d51);\r\n\r\n    function isWhitelisted(\r\n        uint256 index,\r\n        address account,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) public view returns (bool) {\r\n        // Verify the merkle proof.\r\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\r\n        return MerkleProof.verify(merkleProof, merkleRoot, node);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IFreeFromUpTo.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\ninterface IFreeFromUpTo {\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n}\r\n\r\n// File: contracts/Curve.sol\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Curves {\r\n    using ABDKMath64x64 for int128;\r\n\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function add(\r\n        uint256 x,\r\n        uint256 y,\r\n        string memory errorMessage\r\n    ) private pure returns (uint256 z) {\r\n        require((z = x + y) >= x, errorMessage);\r\n    }\r\n\r\n    function sub(\r\n        uint256 x,\r\n        uint256 y,\r\n        string memory errorMessage\r\n    ) private pure returns (uint256 z) {\r\n        require((z = x - y) <= x, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(\r\n        Storage.Curve storage curve,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        _transfer(curve, msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(\r\n        Storage.Curve storage curve,\r\n        address spender,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        _approve(curve, msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`\r\n     */\r\n    function transferFrom(\r\n        Storage.Curve storage curve,\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        _transfer(curve, sender, recipient, amount);\r\n        _approve(\r\n            curve,\r\n            sender,\r\n            msg.sender,\r\n            sub(curve.allowances[sender][msg.sender], amount, \"Curve/insufficient-allowance\")\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(\r\n        Storage.Curve storage curve,\r\n        address spender,\r\n        uint256 addedValue\r\n    ) external returns (bool) {\r\n        _approve(\r\n            curve,\r\n            msg.sender,\r\n            spender,\r\n            add(curve.allowances[msg.sender][spender], addedValue, \"Curve/approval-overflow\")\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(\r\n        Storage.Curve storage curve,\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) external returns (bool) {\r\n        _approve(\r\n            curve,\r\n            msg.sender,\r\n            spender,\r\n            sub(curve.allowances[msg.sender][spender], subtractedValue, \"Curve/allowance-decrease-underflow\")\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is public function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        Storage.Curve storage curve,\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        curve.balances[sender] = sub(curve.balances[sender], amount, \"Curve/insufficient-balance\");\r\n        curve.balances[recipient] = add(curve.balances[recipient], amount, \"Curve/transfer-overflow\");\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `_owner`s tokens.\r\n     *\r\n     * This is public function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        Storage.Curve storage curve,\r\n        address _owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        curve.allowances[_owner][spender] = amount;\r\n        emit Approval(_owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract Curve is Storage, MerkleProver {\r\n    using SafeMath for uint256;\r\n\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n\r\n    event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\r\n\r\n    event AssetIncluded(address indexed numeraire, address indexed reserve, uint256 weight);\r\n\r\n    event AssimilatorIncluded(\r\n        address indexed derivative,\r\n        address indexed numeraire,\r\n        address indexed reserve,\r\n        address assimilator\r\n    );\r\n\r\n    event PartitionRedeemed(address indexed token, address indexed redeemer, uint256 value);\r\n\r\n    event OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event FrozenSet(bool isFrozen);\r\n\r\n    event EmergencyAlarm(bool isEmergency);\r\n\r\n    event WhitelistingStopped();\r\n\r\n    event Trade(\r\n        address indexed trader,\r\n        address indexed origin,\r\n        address indexed target,\r\n        uint256 originAmount,\r\n        uint256 targetAmount\r\n    );\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Curve/caller-is-not-owner\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(notEntered, \"Curve/re-entered\");\r\n        notEntered = false;\r\n        _;\r\n        notEntered = true;\r\n    }\r\n\r\n    modifier transactable() {\r\n        require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\r\n        _;\r\n    }\r\n\r\n    modifier isEmergency() {\r\n        require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\r\n        _;\r\n    }\r\n\r\n    modifier deadline(uint256 _deadline) {\r\n        require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\r\n        _;\r\n    }\r\n\r\n    modifier inWhitelistingStage() {\r\n        require(whitelistingStage, \"Curve/whitelist-stage-on-going\");\r\n        _;\r\n    }\r\n\r\n    modifier notInWhitelistingStage() {\r\n        require(!whitelistingStage, \"Curve/whitelist-stage-stopped\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address[] memory _assets,\r\n        uint256[] memory _assetWeights\r\n    ) {\r\n        owner = msg.sender;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        emit OwnershipTransfered(address(0), msg.sender);\r\n\r\n        Orchestrator.initialize(curve, numeraires, reserves, derivatives, _assets, _assetWeights);\r\n    }\r\n\r\n    /// @notice sets the parameters for the pool\r\n    /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\r\n    /// @param _beta the value for beta must be less than alpha and greater than 0\r\n    /// @param _feeAtHalt the maximum value for the fee at the halt point\r\n    /// @param _epsilon the base fee for the pool\r\n    /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\r\n    function setParams(\r\n        uint256 _alpha,\r\n        uint256 _beta,\r\n        uint256 _feeAtHalt,\r\n        uint256 _epsilon,\r\n        uint256 _lambda\r\n    ) external onlyOwner {\r\n        Orchestrator.setParams(curve, _alpha, _beta, _feeAtHalt, _epsilon, _lambda);\r\n    }\r\n\r\n    /// @notice excludes an assimilator from the curve\r\n    /// @param _derivative the address of the assimilator to exclude\r\n    function excludeDerivative(address _derivative) external onlyOwner {\r\n        for (uint256 i = 0; i < numeraires.length; i++) {\r\n            if (_derivative == numeraires[i]) revert(\"Curve/cannot-delete-numeraire\");\r\n            if (_derivative == reserves[i]) revert(\"Curve/cannot-delete-reserve\");\r\n        }\r\n\r\n        delete curve.assimilators[_derivative];\r\n    }\r\n\r\n    /// @notice view the current parameters of the curve\r\n    /// @return alpha_ the current alpha value\r\n    ///  beta_ the current beta value\r\n    ///  delta_ the current delta value\r\n    ///  epsilon_ the current epsilon value\r\n    ///  lambda_ the current lambda value\r\n    ///  omega_ the current omega value\r\n    function viewCurve()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 alpha_,\r\n            uint256 beta_,\r\n            uint256 delta_,\r\n            uint256 epsilon_,\r\n            uint256 lambda_\r\n        )\r\n    {\r\n        return Orchestrator.viewCurve(curve);\r\n    }\r\n\r\n    function turnOffWhitelisting() external onlyOwner {\r\n        emit WhitelistingStopped();\r\n\r\n        whitelistingStage = false;\r\n    }\r\n\r\n    function setEmergency(bool _emergency) external onlyOwner {\r\n        emit EmergencyAlarm(_emergency);\r\n\r\n        emergency = _emergency;\r\n    }\r\n\r\n    function setFrozen(bool _toFreezeOrNotToFreeze) external onlyOwner {\r\n        emit FrozenSet(_toFreezeOrNotToFreeze);\r\n\r\n        frozen = _toFreezeOrNotToFreeze;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Curve/new-owner-cannot-be-zeroth-address\");\r\n\r\n        emit OwnershipTransfered(owner, _newOwner);\r\n\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @notice swap a dynamic origin amount for a fixed target amount\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _originAmount the origin amount\r\n    /// @param _minTargetAmount the minimum target amount\r\n    /// @param _deadline deadline in block number after which the trade will not execute\r\n    /// @return targetAmount_ the amount of target that has been swapped for the origin amount\r\n    function originSwap(\r\n        address _origin,\r\n        address _target,\r\n        uint256 _originAmount,\r\n        uint256 _minTargetAmount,\r\n        uint256 _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant returns (uint256 targetAmount_) {\r\n        targetAmount_ = Swaps.originSwap(curve, _origin, _target, _originAmount, msg.sender);\r\n\r\n        require(targetAmount_ >= _minTargetAmount, \"Curve/below-min-target-amount\");\r\n    }\r\n\r\n    /// @notice view how much target amount a fixed origin amount will swap for\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _originAmount the origin amount\r\n    /// @return targetAmount_ the target amount that would have been swapped for the origin amount\r\n    function viewOriginSwap(\r\n        address _origin,\r\n        address _target,\r\n        uint256 _originAmount\r\n    ) external view transactable returns (uint256 targetAmount_) {\r\n        targetAmount_ = Swaps.viewOriginSwap(curve, _origin, _target, _originAmount);\r\n    }\r\n\r\n    /// @notice swap a dynamic origin amount for a fixed target amount\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _maxOriginAmount the maximum origin amount\r\n    /// @param _targetAmount the target amount\r\n    /// @param _deadline deadline in block number after which the trade will not execute\r\n    /// @return originAmount_ the amount of origin that has been swapped for the target\r\n    function targetSwap(\r\n        address _origin,\r\n        address _target,\r\n        uint256 _maxOriginAmount,\r\n        uint256 _targetAmount,\r\n        uint256 _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant returns (uint256 originAmount_) {\r\n        originAmount_ = Swaps.targetSwap(curve, _origin, _target, _targetAmount, msg.sender);\r\n\r\n        require(originAmount_ <= _maxOriginAmount, \"Curve/above-max-origin-amount\");\r\n    }\r\n\r\n    /// @notice view how much of the origin currency the target currency will take\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _targetAmount the target amount\r\n    /// @return originAmount_ the amount of target that has been swapped for the origin\r\n    function viewTargetSwap(\r\n        address _origin,\r\n        address _target,\r\n        uint256 _targetAmount\r\n    ) external view transactable returns (uint256 originAmount_) {\r\n        originAmount_ = Swaps.viewTargetSwap(curve, _origin, _target, _targetAmount);\r\n    }\r\n\r\n    /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\r\n    /// @param  index Index corresponding to the merkleProof\r\n    /// @param  account Address coorresponding to the merkleProof\r\n    /// @param  amount Amount coorresponding to the merkleProof, should always be 1\r\n    /// @param  merkleProof Merkle proof\r\n    /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\r\n    ///                  the numeraire assets of the pool\r\n    /// @return (the amount of curves you receive in return for your deposit,\r\n    ///          the amount deposited for each numeraire)\r\n    function depositWithWhitelist(\r\n        uint256 index,\r\n        address account,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof,\r\n        uint256 _deposit,\r\n        uint256 _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant inWhitelistingStage returns (uint256, uint256[] memory) {\r\n        require(isWhitelisted(index, account, amount, merkleProof), \"Curve/not-whitelisted\");\r\n        require(msg.sender == account, \"Curve/not-approved-user\");\r\n\r\n        (uint256 curvesMinted_, uint256[] memory deposits_) =\r\n            ProportionalLiquidity.proportionalDeposit(curve, _deposit);\r\n\r\n        whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].add(curvesMinted_);\r\n\r\n        // 10k max deposit\r\n        if (whitelistedDeposited[msg.sender] > 10000e18) {\r\n            revert(\"Curve/exceed-whitelist-maximum-deposit\");\r\n        }\r\n\r\n        return (curvesMinted_, deposits_);\r\n    }\r\n\r\n    /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\r\n    /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\r\n    ///                  the numeraire assets of the pool\r\n    /// @return (the amount of curves you receive in return for your deposit,\r\n    ///          the amount deposited for each numeraire)\r\n    function deposit(uint256 _deposit, uint256 _deadline)\r\n        external\r\n        deadline(_deadline)\r\n        transactable\r\n        nonReentrant\r\n        notInWhitelistingStage\r\n        returns (uint256, uint256[] memory)\r\n    {\r\n        // (curvesMinted_,  deposits_)\r\n        return ProportionalLiquidity.proportionalDeposit(curve, _deposit);\r\n    }\r\n\r\n    /// @notice view deposits and curves minted a given deposit would return\r\n    /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the\r\n    ///                 prevailing proportions of the numeraire assets of the pool\r\n    /// @return (the amount of curves you receive in return for your deposit,\r\n    ///          the amount deposited for each numeraire)\r\n    function viewDeposit(uint256 _deposit) external view transactable returns (uint256, uint256[] memory) {\r\n        // curvesToMint_, depositsToMake_\r\n        return ProportionalLiquidity.viewProportionalDeposit(curve, _deposit);\r\n    }\r\n\r\n    /// @notice  Emergency withdraw tokens in the event that the oracle somehow bugs out\r\n    ///          and no one is able to withdraw due to the invariant check\r\n    /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\r\n    ///                        numeraire assets of the pool\r\n    /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\r\n    function emergencyWithdraw(uint256 _curvesToBurn, uint256 _deadline)\r\n        external\r\n        isEmergency\r\n        deadline(_deadline)\r\n        nonReentrant\r\n        returns (uint256[] memory withdrawals_)\r\n    {\r\n        return ProportionalLiquidity.emergencyProportionalWithdraw(curve, _curvesToBurn);\r\n    }\r\n\r\n    /// @notice  withdrawas amount of curve tokens from the the pool equally from the numeraire assets of the pool with no slippage\r\n    /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\r\n    ///                        numeraire assets of the pool\r\n    /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\r\n    function withdraw(uint256 _curvesToBurn, uint256 _deadline)\r\n        external\r\n        deadline(_deadline)\r\n        nonReentrant\r\n        returns (uint256[] memory withdrawals_)\r\n    {\r\n        if (whitelistingStage) {\r\n            whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].sub(_curvesToBurn);\r\n        }\r\n\r\n        return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\r\n    }\r\n\r\n    /// @notice  views the withdrawal information from the pool\r\n    /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\r\n    ///                        numeraire assets of the pool\r\n    /// @return the amonnts of numeraire assets withdrawn from the pool\r\n    function viewWithdraw(uint256 _curvesToBurn) external view transactable returns (uint256[] memory) {\r\n        return ProportionalLiquidity.viewProportionalWithdraw(curve, _curvesToBurn);\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interface) public pure returns (bool supports_) {\r\n        supports_ =\r\n            this.supportsInterface.selector == _interface || // erc165\r\n            bytes4(0x7f5828d0) == _interface || // eip173\r\n            bytes4(0x36372b07) == _interface; // erc20\r\n    }\r\n\r\n    /// @notice transfers curve tokens\r\n    /// @param _recipient the address of where to send the curve tokens\r\n    /// @param _amount the amount of curve tokens to send\r\n    /// @return success_ the success bool of the call\r\n    function transfer(address _recipient, uint256 _amount) public nonReentrant returns (bool success_) {\r\n        success_ = Curves.transfer(curve, _recipient, _amount);\r\n    }\r\n\r\n    /// @notice transfers curve tokens from one address to another address\r\n    /// @param _sender the account from which the curve tokens will be sent\r\n    /// @param _recipient the account to which the curve tokens will be sent\r\n    /// @param _amount the amount of curve tokens to transfer\r\n    /// @return success_ the success bool of the call\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) public nonReentrant returns (bool success_) {\r\n        success_ = Curves.transferFrom(curve, _sender, _recipient, _amount);\r\n    }\r\n\r\n    /// @notice approves a user to spend curve tokens on their behalf\r\n    /// @param _spender the account to allow to spend from msg.sender\r\n    /// @param _amount the amount to specify the spender can spend\r\n    /// @return success_ the success bool of this call\r\n    function approve(address _spender, uint256 _amount) public nonReentrant returns (bool success_) {\r\n        success_ = Curves.approve(curve, _spender, _amount);\r\n    }\r\n\r\n    /// @notice view the curve token balance of a given account\r\n    /// @param _account the account to view the balance of\r\n    /// @return balance_ the curve token ballance of the given account\r\n    function balanceOf(address _account) public view returns (uint256 balance_) {\r\n        balance_ = curve.balances[_account];\r\n    }\r\n\r\n    /// @notice views the total curve supply of the pool\r\n    /// @return totalSupply_ the total supply of curve tokens\r\n    function totalSupply() public view returns (uint256 totalSupply_) {\r\n        totalSupply_ = curve.totalSupply;\r\n    }\r\n\r\n    /// @notice views the total allowance one address has to spend from another address\r\n    /// @param _owner the address of the owner\r\n    /// @param _spender the address of the spender\r\n    /// @return allowance_ the amount the owner has allotted the spender\r\n    function allowance(address _owner, address _spender) public view returns (uint256 allowance_) {\r\n        allowance_ = curve.allowances[_owner][_spender];\r\n    }\r\n\r\n    /// @notice views the total amount of liquidity in the curve in numeraire value and format - 18 decimals\r\n    /// @return total_ the total value in the curve\r\n    /// @return individual_ the individual values in the curve\r\n    function liquidity() public view returns (uint256 total_, uint256[] memory individual_) {\r\n        return ViewLiquidity.viewLiquidity(curve);\r\n    }\r\n\r\n    /// @notice view the assimilator address for a derivative\r\n    /// @return assimilator_ the assimilator address\r\n    function assimilator(address _derivative) public view returns (address assimilator_) {\r\n        assimilator_ = curve.assimilators[_derivative].addr;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_assetWeights\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"numeraire\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"AssetIncluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"numeraire\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assimilator\",\"type\":\"address\"}],\"name\":\"AssimilatorIncluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEmergency\",\"type\":\"bool\"}],\"name\":\"EmergencyAlarm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"}],\"name\":\"FrozenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alpha\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epsilon\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lambda\",\"type\":\"uint256\"}],\"name\":\"ParametersSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PartitionRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"WhitelistingStopped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success_\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_derivative\",\"type\":\"address\"}],\"name\":\"assimilator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"assimilator_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curve\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"alpha\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"beta\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"delta\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"epsilon\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"lambda\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"depositWithWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"derivatives\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_curvesToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"withdrawals_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_derivative\",\"type\":\"address\"}],\"name\":\"excludeDerivative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"individual_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numeraires\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTargetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"originSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"targetAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserves\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergency\",\"type\":\"bool\"}],\"name\":\"setEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_toFreezeOrNotToFreeze\",\"type\":\"bool\"}],\"name\":\"setFrozen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_beta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeAtHalt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_epsilon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lambda\",\"type\":\"uint256\"}],\"name\":\"setParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interface\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supports_\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxOriginAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"targetSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"originAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success_\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success_\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnOffWhitelisting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"alpha_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beta_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delta_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epsilon_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lambda_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"}],\"name\":\"viewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_originAmount\",\"type\":\"uint256\"}],\"name\":\"viewOriginSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"targetAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_targetAmount\",\"type\":\"uint256\"}],\"name\":\"viewTargetSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"originAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_curvesToBurn\",\"type\":\"uint256\"}],\"name\":\"viewWithdraw\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistingStage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_curvesToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"withdrawals_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Curve", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000000104f43502042555344205553444f204c500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064f4350204c500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000d4aabe1a428ea36cb836db2248b4ac68537ed108000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000d4aabe1a428ea36cb836db2248b4ac68537ed108000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000005801d0e1c7d977d78e4890880b8e579eb49432760000000000000000000000006e7d90feffdf7e90dab19caf213ce64f28d0ce600000000000000000000000005801d0e1c7d977d78e4890880b8e579eb49432760000000000000000000000006e7d90feffdf7e90dab19caf213ce64f28d0ce600000000000000000000000005801d0e1c7d977d78e4890880b8e579eb4943276000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000006f05b59d3b20000", "EVMVersion": "Default", "Library": "Curves:4c88b75e7080f4b046edb8c6ac5305deb39bc6b8;Orchestrator:942f681e53fc2aa8beb49d47e95eb93426339669;ProportionalLiquidity:c0362732344483b26b6a1e5e7b5aed1feacb325e;Swaps:2fbabbf03550cc04a8bd2e27743e538681d8d7b6;ViewLiquidity:52b1ac50d54460dddd391b3e5b8e50d2f2d438ae", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://eefe8fa02de9d7d7c82bfc7d14eef3c5014833baaa79096c43eab329c3aaa5ba"}