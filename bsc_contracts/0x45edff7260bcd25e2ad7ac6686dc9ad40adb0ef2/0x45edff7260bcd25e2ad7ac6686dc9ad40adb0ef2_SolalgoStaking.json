{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, 'SafeMath: subtraction overflow');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, 'SafeMath: division by zero');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, 'SafeMath: modulo by zero');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    /**\r\n     * @dev Multiplies two int256 variables and fails on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Division of two int256 variables and fails on overflow.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two int256 variables and fails on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two int256 variables and fails on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts to absolute value, and fails on overflow.\r\n     */\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n\r\n\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\nlibrary SafeMathUint {\r\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n    int256 b = int256(a);\r\n    require(b >= 0);\r\n    return b;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}('');\r\n        require(success, 'Address: unable to send value, recipient may have reverted');\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, 'Address: low-level call failed');\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), 'Address: call to non-contract');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface DividendPayingTokenOptionalInterface {\r\n  /// @notice View the amount of dividend in wei that an address can withdraw.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\r\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\r\n\r\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\r\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\r\n\r\n  /// @notice View the amount of dividend in wei that an address has earned in total.\r\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\r\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\r\n}\r\n\r\ninterface DividendPayingTokenInterface {\r\n  /// @notice View the amount of dividend in wei that an address can withdraw.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\r\n  function dividendOf(address _owner) external view returns(uint256);\r\n\r\n  /// @notice Distributes ether to token holders as dividends.\r\n  /// @dev SHOULD distribute the paid ether to token holders as dividends.\r\n  ///  SHOULD NOT directly transfer ether to token holders in this function.\r\n  ///  MUST emit a `DividendsDistributed` event when the amount of distributed ether is greater than 0.\r\n  function distributeDividends() external payable;\r\n\r\n  /// @notice Withdraws the ether distributed to the sender.\r\n  /// @dev SHOULD transfer `dividendOf(msg.sender)` wei to `msg.sender`, and `dividendOf(msg.sender)` SHOULD be 0 after the transfer.\r\n  ///  MUST emit a `DividendWithdrawn` event if the amount of ether transferred is greater than 0.\r\n  function withdrawDividend() external;\r\n\r\n  /// @dev This event MUST emit when ether is distributed to token holders.\r\n  /// @param from The address which sends ether to this contract.\r\n  /// @param weiAmount The amount of distributed ether in wei.\r\n  event DividendsDistributed(\r\n    address indexed from,\r\n    uint256 weiAmount\r\n  );\r\n\r\n  /// @dev This event MUST emit when an address withdraws their dividend.\r\n  /// @param to The address which withdraws ether from this contract.\r\n  /// @param weiAmount The amount of withdrawn ether in wei.\r\n  event DividendWithdrawn(\r\n    address indexed to,\r\n    uint256 weiAmount\r\n  );\r\n}\r\n\r\ncontract DividendPayingToken is DividendPayingTokenInterface, DividendPayingTokenOptionalInterface, Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeMathUint for uint256;\r\n  using SafeMathInt for int256;\r\n\r\n  // With `magnitude`, we can properly distribute dividends even if the amount of received ether is small.\r\n  // For more discussion about choosing the value of `magnitude`,\r\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\r\n  uint256 constant internal magnitude = 2**128;\r\n\r\n  uint256 internal magnifiedDividendPerShare;\r\n                                                                                    \r\n  // About dividendCorrection:\r\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\r\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\r\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\r\n  //   `dividendOf(_user)` should not be changed,\r\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\r\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\r\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\r\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\r\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\r\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\r\n  mapping(address => int256) internal magnifiedDividendCorrections;\r\n  mapping(address => uint256) internal withdrawnDividends;\r\n  \r\n  mapping (address => uint256) public holderBalance;\r\n  uint256 public totalBalance;\r\n\r\n  uint256 public totalDividendsDistributed;\r\n\r\n  /// @dev Distributes dividends whenever ether is paid to this contract.\r\n  receive() external payable {\r\n    distributeDividends();\r\n  }\r\n\r\n  /// @notice Distributes ether to token holders as dividends.\r\n  /// @dev It reverts if the total supply of tokens is 0.\r\n  /// It emits the `DividendsDistributed` event if the amount of received ether is greater than 0.\r\n  /// About undistributed ether:\r\n  ///   In each distribution, there is a small amount of ether not distributed,\r\n  ///     the magnified amount of which is\r\n  ///     `(msg.value * magnitude) % totalSupply()`.\r\n  ///   With a well-chosen `magnitude`, the amount of undistributed ether\r\n  ///     (de-magnified) in a distribution can be less than 1 wei.\r\n  ///   We can actually keep track of the undistributed ether in a distribution\r\n  ///     and try to distribute it in the next distribution,\r\n  ///     but keeping track of such data on-chain costs much more than\r\n  ///     the saved ether, so we don't do that.\r\n    \r\n  function distributeDividends() public override payable {\r\n    if(totalBalance > 0 && msg.value > 0){\r\n        magnifiedDividendPerShare = magnifiedDividendPerShare.add(\r\n            (msg.value).mul(magnitude) / totalBalance\r\n        );\r\n        emit DividendsDistributed(msg.sender, msg.value);\r\n\r\n        totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\r\n    } else {\r\n        bool success;\r\n        (success,) = address(tx.origin).call{value: msg.value}(\"\"); // send ETH back if no stakers\r\n    }\r\n  }\r\n\r\n  /// @notice Withdraws the ether distributed to the sender.\r\n  /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n  function withdrawDividend() external virtual override {\r\n    _withdrawDividendOfUser(payable(msg.sender));\r\n  }\r\n\r\n  /// @notice Withdraws the ether distributed to the sender.\r\n  /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n  function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\r\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\r\n    if (_withdrawableDividend > 0) {\r\n      withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\r\n\r\n      emit DividendWithdrawn(user, _withdrawableDividend);\r\n      (bool success,) = user.call{value: _withdrawableDividend}(\"\");\r\n\r\n      if(!success) {\r\n        withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\r\n        return 0;\r\n      }\r\n\r\n      return _withdrawableDividend;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n\r\n  /// @notice View the amount of dividend in wei that an address can withdraw.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\r\n  function dividendOf(address _owner) external view override returns(uint256) {\r\n    return withdrawableDividendOf(_owner);\r\n  }\r\n\r\n  /// @notice View the amount of dividend in wei that an address can withdraw.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\r\n  function withdrawableDividendOf(address _owner) public view override returns(uint256) {\r\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\r\n  }\r\n\r\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\r\n  function withdrawnDividendOf(address _owner) external view override returns(uint256) {\r\n    return withdrawnDividends[_owner];\r\n  }\r\n\r\n\r\n  /// @notice View the amount of dividend in wei that an address has earned in total.\r\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\r\n  /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\r\n  function accumulativeDividendOf(address _owner) public view override returns(uint256) {\r\n    return magnifiedDividendPerShare.mul(holderBalance[_owner]).toInt256Safe()\r\n      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\r\n  }\r\n\r\n  /// @dev Internal function that increases tokens to an account.\r\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\r\n  /// @param account The account that will receive the created tokens.\r\n  /// @param value The amount that will be created.\r\n  function _increase(address account, uint256 value) internal {\r\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n      .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n  }\r\n\r\n  /// @dev Internal function that reduces an amount of the token of a given account.\r\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\r\n  /// @param account The account whose tokens will be burnt.\r\n  /// @param value The amount that will be burnt.\r\n  function _reduce(address account, uint256 value) internal {\r\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n      .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n  }\r\n\r\n  function _setBalance(address account, uint256 newBalance) internal {\r\n    uint256 currentBalance = holderBalance[account];\r\n    holderBalance[account] = newBalance;\r\n    if(newBalance > currentBalance) {\r\n      uint256 increaseAmount = newBalance.sub(currentBalance);\r\n      _increase(account, increaseAmount);\r\n      totalBalance += increaseAmount;\r\n    } else if(newBalance < currentBalance) {\r\n      uint256 reduceAmount = currentBalance.sub(newBalance);\r\n      _reduce(account, reduceAmount);\r\n      totalBalance -= reduceAmount;\r\n    }\r\n  }\r\n}\r\n\r\n\r\ncontract DividendTracker is DividendPayingToken {\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    struct Map {\r\n        address[] keys;\r\n        mapping(address => uint) values;\r\n        mapping(address => uint) indexOf;\r\n        mapping(address => bool) inserted;\r\n    }\r\n\r\n    function get(address key) private view returns (uint) {\r\n        return tokenHoldersMap.values[key];\r\n    }\r\n\r\n    function getIndexOfKey(address key) private view returns (int) {\r\n        if(!tokenHoldersMap.inserted[key]) {\r\n            return -1;\r\n        }\r\n        return int(tokenHoldersMap.indexOf[key]);\r\n    }\r\n\r\n    function getKeyAtIndex(uint index) private view returns (address) {\r\n        return tokenHoldersMap.keys[index];\r\n    }\r\n\r\n\r\n\r\n    function size() private view returns (uint) {\r\n        return tokenHoldersMap.keys.length;\r\n    }\r\n\r\n    function set(address key, uint val) private {\r\n        if (tokenHoldersMap.inserted[key]) {\r\n            tokenHoldersMap.values[key] = val;\r\n        } else {\r\n            tokenHoldersMap.inserted[key] = true;\r\n            tokenHoldersMap.values[key] = val;\r\n            tokenHoldersMap.indexOf[key] = tokenHoldersMap.keys.length;\r\n            tokenHoldersMap.keys.push(key);\r\n        }\r\n    }\r\n\r\n    function remove(address key) private {\r\n        if (!tokenHoldersMap.inserted[key]) {\r\n            return;\r\n        }\r\n\r\n        delete tokenHoldersMap.inserted[key];\r\n        delete tokenHoldersMap.values[key];\r\n\r\n        uint index = tokenHoldersMap.indexOf[key];\r\n        uint lastIndex = tokenHoldersMap.keys.length - 1;\r\n        address lastKey = tokenHoldersMap.keys[lastIndex];\r\n\r\n        tokenHoldersMap.indexOf[lastKey] = index;\r\n        delete tokenHoldersMap.indexOf[key];\r\n\r\n        tokenHoldersMap.keys[index] = lastKey;\r\n        tokenHoldersMap.keys.pop();\r\n    }\r\n\r\n    Map private tokenHoldersMap;\r\n    uint256 public lastProcessedIndex;\r\n\r\n    mapping (address => bool) public excludedFromDividends;\r\n\r\n    mapping (address => uint256) public lastClaimTimes;\r\n\r\n    uint256 public claimWait;\r\n    uint256 public immutable minimumTokenBalanceForDividends;\r\n\r\n    event ExcludeFromDividends(address indexed account);\r\n    event IncludeInDividends(address indexed account);\r\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\r\n\r\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\r\n\r\n    constructor() {\r\n    \tclaimWait = 1;\r\n        minimumTokenBalanceForDividends = 1;\r\n    }\r\n\r\n    function excludeFromDividends(address account) external onlyOwner {\r\n    \texcludedFromDividends[account] = true;\r\n\r\n    \t_setBalance(account, 0);\r\n    \tremove(account);\r\n\r\n    \temit ExcludeFromDividends(account);\r\n    }\r\n    \r\n    function includeInDividends(address account) external onlyOwner {\r\n    \trequire(excludedFromDividends[account]);\r\n    \texcludedFromDividends[account] = false;\r\n\r\n    \temit IncludeInDividends(account);\r\n    }\r\n\r\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\r\n        require(newClaimWait >= 1200 && newClaimWait <= 86400, \"Dividend_Tracker: claimWait must be updated to between 1 and 24 hours\");\r\n        require(newClaimWait != claimWait, \"Dividend_Tracker: Cannot update claimWait to same value\");\r\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\r\n        claimWait = newClaimWait;\r\n    }\r\n\r\n    function getLastProcessedIndex() external view returns(uint256) {\r\n    \treturn lastProcessedIndex;\r\n    }\r\n\r\n    function getNumberOfTokenHolders() external view returns(uint256) {\r\n        return tokenHoldersMap.keys.length;\r\n    }\r\n    function getAccount(address _account)\r\n        public view returns (\r\n            address account,\r\n            int256 index,\r\n            int256 iterationsUntilProcessed,\r\n            uint256 withdrawableDividends,\r\n            uint256 totalDividends,\r\n            uint256 lastClaimTime,\r\n            uint256 nextClaimTime,\r\n            uint256 secondsUntilAutoClaimAvailable) {\r\n        account = _account;\r\n\r\n        index = getIndexOfKey(account);\r\n\r\n        iterationsUntilProcessed = -1;\r\n\r\n        if(index >= 0) {\r\n            if(uint256(index) > lastProcessedIndex) {\r\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\r\n            }\r\n            else {\r\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ?\r\n                                                        tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\r\n                                                        0;\r\n\r\n\r\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\r\n            }\r\n        }\r\n\r\n\r\n        withdrawableDividends = withdrawableDividendOf(account);\r\n        totalDividends = accumulativeDividendOf(account);\r\n\r\n        lastClaimTime = lastClaimTimes[account];\r\n\r\n        nextClaimTime = lastClaimTime > 0 ?\r\n                                    lastClaimTime.add(claimWait) :\r\n                                    0;\r\n\r\n        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ?\r\n                                                    nextClaimTime.sub(block.timestamp) :\r\n                                                    0;\r\n    }\r\n\r\n    function getAccountAtIndex(uint256 index)\r\n        external view returns (\r\n            address,\r\n            int256,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256) {\r\n    \tif(index >= size()) {\r\n            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\r\n        }\r\n\r\n        address account = getKeyAtIndex(index);\r\n\r\n        return getAccount(account);\r\n    }\r\n\r\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\r\n    \tif(lastClaimTime > block.timestamp)  {\r\n    \t\treturn false;\r\n    \t}\r\n\r\n    \treturn block.timestamp.sub(lastClaimTime) >= claimWait;\r\n    }\r\n\r\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\r\n    \tif(excludedFromDividends[account]) {\r\n    \t\treturn;\r\n    \t}\r\n\r\n    \tif(newBalance >= minimumTokenBalanceForDividends) {\r\n            _setBalance(account, newBalance);\r\n    \t\tset(account, newBalance);\r\n    \t}\r\n    \telse {\r\n            _setBalance(account, 0);\r\n    \t\tremove(account);\r\n    \t}\r\n\r\n    \tprocessAccount(account, true);\r\n    }\r\n    \r\n    \r\n    function process(uint256 gas) external returns (uint256, uint256, uint256) {\r\n    \tuint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\r\n\r\n    \tif(numberOfTokenHolders == 0) {\r\n    \t\treturn (0, 0, lastProcessedIndex);\r\n    \t}\r\n\r\n    \tuint256 _lastProcessedIndex = lastProcessedIndex;\r\n\r\n    \tuint256 gasUsed = 0;\r\n\r\n    \tuint256 gasLeft = gasleft();\r\n\r\n    \tuint256 iterations = 0;\r\n    \tuint256 claims = 0;\r\n\r\n    \twhile(gasUsed < gas && iterations < numberOfTokenHolders) {\r\n    \t\t_lastProcessedIndex++;\r\n\r\n    \t\tif(_lastProcessedIndex >= tokenHoldersMap.keys.length) {\r\n    \t\t\t_lastProcessedIndex = 0;\r\n    \t\t}\r\n\r\n    \t\taddress account = tokenHoldersMap.keys[_lastProcessedIndex];\r\n\r\n    \t\tif(canAutoClaim(lastClaimTimes[account])) {\r\n    \t\t\tif(processAccount(payable(account), true)) {\r\n    \t\t\t\tclaims++;\r\n    \t\t\t}\r\n    \t\t}\r\n\r\n    \t\titerations++;\r\n\r\n    \t\tuint256 newGasLeft = gasleft();\r\n\r\n    \t\tif(gasLeft > newGasLeft) {\r\n    \t\t\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\r\n    \t\t}\r\n    \t\tgasLeft = newGasLeft;\r\n    \t}\r\n\r\n    \tlastProcessedIndex = _lastProcessedIndex;\r\n\r\n    \treturn (iterations, claims, lastProcessedIndex);\r\n    }\r\n\r\n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\r\n        uint256 amount = _withdrawDividendOfUser(account);\r\n\r\n    \tif(amount > 0) {\r\n    \t\tlastClaimTimes[account] = block.timestamp;\r\n            emit Claim(account, amount, automatic);\r\n    \t\treturn true;\r\n    \t}\r\n\r\n    \treturn false;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract SolalgoStaking is Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    uint256 public immutable stakingDecimals;\r\n\r\n    DividendTracker public immutable tier1DividendTracker;\r\n    DividendTracker public immutable tier2DividendTracker;\r\n    DividendTracker public immutable tier3DividendTracker;\r\n    DividendTracker public immutable tier4DividendTracker;\r\n    DividendTracker public immutable tier5DividendTracker;\r\n\r\n    uint256 public tier1Percent;\r\n    uint256 public tier2Percent;\r\n    uint256 public tier3Percent;\r\n    uint256 public tier4Percent;\r\n    uint256 public tier5Percent;\r\n\r\n    uint256 public immutable tier1Threshold;\r\n    uint256 public immutable tier2Threshold;\r\n    uint256 public immutable tier3Threshold;\r\n    uint256 public immutable tier4Threshold;\r\n    uint256 public immutable tier5Threshold;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 multipliedAmount;\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        uint256 claimedRewards;\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;           // Address of LP token contract.\r\n        uint256 lastRewardTimestamp;  // Last block number that Tokens distribution occurs.\r\n        uint256 accTokensPerShare; // Accumulated Tokens per share, times 1e12. See below.\r\n    }\r\n\r\n    IERC20 public immutable stakingToken;\r\n    IERC20 public immutable rewardToken;\r\n    mapping (address => uint256) public holderUnlockTime;\r\n    IERC721 public nftAddress;\r\n\r\n    mapping (address => EnumerableSet.UintSet) private holderNftsStaked;\r\n\r\n    uint256 public totalStaked;\r\n    uint256 public totalStakedMultiplied;\r\n    uint256 public apr;\r\n    uint256 public lockDuration;\r\n    uint256 public exitPenaltyPerc;\r\n\r\n    uint256 public percBoostPerNft;\r\n    uint256 public maxStakedNftsAllowed;\r\n    \r\n\r\n    // Info of each pool.\r\n    PoolInfo public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping (address => UserInfo) public userInfo;\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n    event StakedNFT(address indexed nftAddress, uint256 indexed tokenId, address indexed sender);\r\n    event UnstakedNFT(address indexed nftAddress, uint256 indexed tokenId, address indexed sender);\r\n\r\n    constructor(address _stakingToken, uint256 _apr) {\r\n        require(_stakingToken != address(0), \"cannot be 0 address\");\r\n        stakingToken = IERC20(_stakingToken);\r\n        rewardToken = IERC20(_stakingToken);\r\n\r\n        stakingDecimals = 10 ** IERC20Metadata(_stakingToken).decimals();\r\n        tier5DividendTracker = new DividendTracker();\r\n        tier4DividendTracker = new DividendTracker();\r\n        tier3DividendTracker = new DividendTracker();\r\n        tier2DividendTracker = new DividendTracker();\r\n        tier1DividendTracker = new DividendTracker();\r\n\r\n        tier1Threshold = 100000 * stakingDecimals;\r\n        tier2Threshold = 50000 * stakingDecimals;\r\n        tier3Threshold = 25000 * stakingDecimals;\r\n        tier4Threshold = 10000 * stakingDecimals;\r\n        tier5Threshold = 0;\r\n\r\n        tier5Percent = 10;\r\n        tier4Percent = 15;\r\n        tier3Percent = 20;\r\n        tier2Percent = 25;\r\n        tier1Percent = 30;\r\n        require(tier5Percent + tier4Percent + tier3Percent + tier2Percent + tier1Percent == 100, \"Must equal 100%\");\r\n\r\n        maxStakedNftsAllowed = 0;\r\n\r\n        apr = _apr;\r\n        lockDuration = 30 days;\r\n        exitPenaltyPerc = 10;\r\n        percBoostPerNft = 0;\r\n\r\n        // staking pool\r\n        poolInfo.lpToken = stakingToken;\r\n        poolInfo.lastRewardTimestamp = block.timestamp;\r\n        poolInfo.accTokensPerShare = 0;\r\n    }\r\n\r\n    receive() external payable {\r\n        uint256 amount = msg.value;\r\n        (bool success,) = address(tier5DividendTracker).call{value: amount * tier5Percent / 100}(\"\");\r\n        (success,) = address(tier4DividendTracker).call{value: amount * tier4Percent / 100}(\"\");\r\n        (success,) = address(tier3DividendTracker).call{value: amount * tier3Percent / 100}(\"\");\r\n        (success,) = address(tier2DividendTracker).call{value: amount * tier2Percent / 100}(\"\");\r\n        (success,) = address(tier1DividendTracker).call{value: amount * tier1Percent / 100}(\"\");\r\n        if(address(this).balance > 0){\r\n            (success,) = address(tier1DividendTracker).call{value: address(this).balance / 100}(\"\");\r\n        }\r\n    }\r\n\r\n    function getHolderNfts(address wallet) external view returns (uint256[] memory){\r\n        return holderNftsStaked[wallet].values();\r\n    }\r\n\r\n    function stopReward() external onlyOwner {\r\n        updatePool();\r\n        apr = 0;\r\n    }\r\n\r\n    function updatePercentages(uint256 _tier1Perc, uint256 _tier2Perc, uint256 _tier3Perc, uint256 _tier4Perc, uint256 _tier5Perc) external onlyOwner {\r\n        tier5Percent = _tier5Perc;\r\n        tier4Percent = _tier4Perc;\r\n        tier3Percent = _tier3Perc;\r\n        tier2Percent = _tier2Perc;\r\n        tier1Percent = _tier1Perc;\r\n        require(tier5Percent + tier4Percent + tier3Percent + tier2Percent + tier1Percent == 100, \"Must equal 100%\");\r\n    }\r\n    \r\n    function setNftAddress(address _nftAddress) external onlyOwner {\r\n        require(address(nftAddress) == address(0), \"cannot set new Nft Address\");\r\n        require(_nftAddress != address(0), \"Cannot set to zero Address\");\r\n        nftAddress = IERC721(_nftAddress);\r\n    }\r\n\r\n    function setMaxStakedNfts(uint256 maxNfts) external onlyOwner {\r\n        maxStakedNftsAllowed = maxNfts;\r\n    }\r\n\r\n    function stakeNfts(uint256[] calldata tokenIds) external nonReentrant {\r\n        require(address(nftAddress) != address(0), \"Nft Address not set\");\r\n        clearBalance(msg.sender);\r\n        \r\n        UserInfo storage user = userInfo[msg.sender];\r\n        PoolInfo storage pool = poolInfo;\r\n\r\n        require(tokenIds.length + holderNftsStaked[msg.sender].length() <= maxStakedNftsAllowed, \"can't stake this many NFTs\");\r\n\r\n        updatePool();\r\n\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12).sub(user.rewardDebt);\r\n            if(pending >= rewardsRemaining()){\r\n                pending = rewardsRemaining();\r\n            }\r\n            if(pending > 0) {\r\n                rewardToken.transfer(address(msg.sender), pending);\r\n                user.claimedRewards += pending;\r\n            }\r\n        }\r\n\r\n        for (uint256 i=0; i<tokenIds.length; i++){\r\n            require(nftAddress.getApproved(tokenIds[i]) == address(this) || nftAddress.isApprovedForAll(msg.sender, address(this)), \"Must approve token to be sent\");\r\n            nftAddress.transferFrom(msg.sender, address(this), tokenIds[i]);\r\n            holderNftsStaked[msg.sender].add(tokenIds[i]);\r\n            emit StakedNFT(address(nftAddress), tokenIds[i], msg.sender);        \r\n        }\r\n\r\n        totalStakedMultiplied -= user.multipliedAmount;\r\n        user.multipliedAmount = user.amount * getStakingMultiplier(msg.sender) / 100;\r\n        totalStakedMultiplied += user.multipliedAmount;\r\n\r\n        user.rewardDebt = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12);\r\n        setBalance(msg.sender);\r\n    }\r\n\r\n    function unstakeNfts(uint256[] calldata tokenIds) external nonReentrant {\r\n        \r\n        UserInfo storage user = userInfo[msg.sender];\r\n        PoolInfo storage pool = poolInfo;\r\n\r\n        updatePool();\r\n        clearBalance(msg.sender);\r\n\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12).sub(user.rewardDebt);\r\n            if(pending >= rewardsRemaining()){\r\n                pending = rewardsRemaining();\r\n            }\r\n            if(pending > 0) {\r\n                rewardToken.transfer(address(msg.sender), pending);\r\n                user.claimedRewards += pending;\r\n            }\r\n        }\r\n\r\n        for (uint256 i=0; i<tokenIds.length; i++){\r\n            require(holderNftsStaked[msg.sender].contains(tokenIds[i]), \"token not owned\");\r\n            require(nftAddress.getApproved(tokenIds[i]) == address(this) || nftAddress.isApprovedForAll(msg.sender, address(this)), \"Must approve token to be sent\");\r\n            nftAddress.transferFrom(address(this), msg.sender, tokenIds[i]);\r\n            holderNftsStaked[msg.sender].remove(tokenIds[i]);\r\n            emit UnstakedNFT(address(nftAddress), tokenIds[i], msg.sender);        \r\n        }\r\n\r\n        totalStakedMultiplied -= user.multipliedAmount;\r\n        user.multipliedAmount = user.amount * getStakingMultiplier(msg.sender) / 100;\r\n        totalStakedMultiplied += user.multipliedAmount;\r\n\r\n        user.rewardDebt = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12);\r\n        setBalance(msg.sender);\r\n    }\r\n\r\n    // @dev note that you must divide this by 100 after multiplying against tokens.\r\n    function getStakingMultiplier(address holder) public view returns (uint256) {\r\n        if(holderNftsStaked[holder].length() == 0){\r\n            return 100;\r\n        }\r\n        return 100 + (holderNftsStaked[holder].length()*percBoostPerNft);\r\n    }\r\n\r\n    function setPercBoostPerNft(uint256 perc) external onlyOwner {\r\n        require(perc <= 100, \"Cannot set boost over 100% per NFT\");\r\n        percBoostPerNft = perc;\r\n    }\r\n\r\n    // View function to see pending Reward on frontend.\r\n    function pendingReward(address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[_user];\r\n        if(pool.lastRewardTimestamp == 99999999999){\r\n            return 0;\r\n        }\r\n        uint256 accTokensPerShare = pool.accTokensPerShare;\r\n        uint256 lpSupply = totalStakedMultiplied;\r\n        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {\r\n            uint256 tokenReward = calculateNewRewards();\r\n            accTokensPerShare = accTokensPerShare.add(tokenReward.mul(1e12).div(lpSupply));\r\n        }\r\n        return user.multipliedAmount.mul(accTokensPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool() internal {\r\n\r\n        PoolInfo storage pool = poolInfo;\r\n        if (block.timestamp <= pool.lastRewardTimestamp) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = totalStakedMultiplied;\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n        uint256 tokenReward = calculateNewRewards();\r\n        pool.accTokensPerShare = pool.accTokensPerShare.add(tokenReward.mul(1e12).div(lpSupply));\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n    }\r\n\r\n    // Stake primary tokens\r\n    function deposit(uint256 _amount) public nonReentrant {\r\n        if(holderUnlockTime[msg.sender] == 0){\r\n            holderUnlockTime[msg.sender] = block.timestamp + lockDuration;\r\n        }\r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        clearBalance(msg.sender);\r\n\r\n        updatePool();\r\n\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12).sub(user.rewardDebt);\r\n            require(rewardsRemaining() >= pending, \"Not enough tokens for reward, use emergency exit to withdraw\");\r\n            if(pending > 0) {\r\n                rewardToken.transfer(address(msg.sender), pending);\r\n                user.claimedRewards += pending;\r\n            }\r\n        }\r\n\r\n        uint256 amountTransferred = 0;\r\n        if(_amount > 0) {\r\n            uint256 initialBalance = pool.lpToken.balanceOf(address(this));\r\n            pool.lpToken.transferFrom(address(msg.sender), address(this), _amount);\r\n            amountTransferred = pool.lpToken.balanceOf(address(this)) - initialBalance;\r\n            totalStakedMultiplied -= user.multipliedAmount;\r\n            user.amount = user.amount.add(amountTransferred);\r\n            user.multipliedAmount = user.amount * getStakingMultiplier(msg.sender) / 100;\r\n            totalStaked += amountTransferred;\r\n            totalStakedMultiplied += user.multipliedAmount;\r\n        }\r\n\r\n        setBalance(msg.sender);\r\n        user.rewardDebt = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12);\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw primary tokens from STAKING.\r\n\r\n    function withdraw(uint256 _amount) public nonReentrant {\r\n\r\n        require(holderUnlockTime[msg.sender] <= block.timestamp, \"May not do normal withdraw early\");\r\n        clearBalance(msg.sender);\r\n        \r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        require(user.amount >= _amount, \"Not enough stake\");\r\n\r\n        updatePool();\r\n        uint256 pending = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12).sub(user.rewardDebt);\r\n        require(rewardsRemaining() >= pending, \"Not enough tokens for reward, use emergency exit to withdraw\");\r\n        if(pending > 0) {\r\n            rewardToken.transfer(address(msg.sender), pending);\r\n            user.claimedRewards += pending;\r\n        }\r\n\r\n        if(_amount > 0) {\r\n            user.amount -= _amount;\r\n            user.multipliedAmount = user.amount * getStakingMultiplier(msg.sender) / 100;\r\n            totalStaked -= _amount;\r\n            totalStakedMultiplied -= _amount * getStakingMultiplier(msg.sender) / 100;\r\n            pool.lpToken.transfer(address(msg.sender), _amount);\r\n        }\r\n\r\n        setBalance(msg.sender);\r\n        user.rewardDebt = user.multipliedAmount.mul(pool.accTokensPerShare).div(1e12);\r\n        \r\n        if(user.amount > 0){\r\n            holderUnlockTime[msg.sender] = block.timestamp + lockDuration;\r\n        } else {\r\n            holderUnlockTime[msg.sender] = 0;\r\n        }\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() external nonReentrant {\r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 _amount = user.amount;\r\n        totalStaked -= _amount;\r\n        totalStakedMultiplied -= user.multipliedAmount;\r\n        // exit penalty for early unstakers, penalty held on contract as rewards.\r\n        if(holderUnlockTime[msg.sender] >= block.timestamp){\r\n            _amount -= _amount * exitPenaltyPerc / 100;\r\n        }\r\n        holderUnlockTime[msg.sender] = 0;\r\n        pool.lpToken.transfer(address(msg.sender), _amount);\r\n        user.amount = 0;\r\n        user.multipliedAmount = 0;\r\n        user.rewardDebt = 0;\r\n        setBalance(msg.sender);\r\n        emit EmergencyWithdraw(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw reward. EMERGENCY ONLY. This allows the owner to migrate rewards to a new staking pool since we are not minting new tokens.\r\n    function emergencyRewardWithdraw(uint256 _amount) external onlyOwner {\r\n        require(_amount <= rewardsRemaining(), 'not enough tokens to take out');\r\n        rewardToken.transfer(address(msg.sender), _amount);\r\n    }\r\n\r\n    function calculateNewRewards() public view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo;\r\n        if(pool.lastRewardTimestamp > block.timestamp){\r\n            return 0;\r\n        }\r\n        return (((block.timestamp - pool.lastRewardTimestamp) * totalStakedMultiplied) * apr / 100 / 365 days);\r\n    }\r\n\r\n    function rewardsRemaining() public view returns (uint256){\r\n        if(rewardToken == stakingToken){\r\n            return rewardToken.balanceOf(address(this)) - totalStaked;\r\n        } else {\r\n            return rewardToken.balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function updateApr(uint256 newApr) external onlyOwner {\r\n        require(newApr <= 1000, \"APR must be below 1000%\");\r\n        updatePool();\r\n        apr = newApr;\r\n    }\r\n\r\n    function updateLockDuration(uint256 daysForLock) external onlyOwner {\r\n        require(daysForLock <= 365, \"Lock must be 365 days or less.\");\r\n        lockDuration = daysForLock * 1 days;\r\n    }\r\n\r\n    function updateExitPenalty(uint256 newPenaltyPerc) external onlyOwner {\r\n        require(newPenaltyPerc <= 20, \"May not set higher than 20%\");\r\n        exitPenaltyPerc = newPenaltyPerc;\r\n    }\r\n\r\n    function claimDividendsOnly() external nonReentrant {\r\n        uint256 tier = getTier(msg.sender);\r\n        if(tier == 5){\r\n            tier5DividendTracker.processAccount(payable(msg.sender), false);\r\n        } else if (tier == 4){\r\n            tier4DividendTracker.processAccount(payable(msg.sender), false);\r\n        } else if (tier == 3){\r\n            tier3DividendTracker.processAccount(payable(msg.sender), false);\r\n        } else if (tier == 2){\r\n            tier2DividendTracker.processAccount(payable(msg.sender), false);\r\n        } else if (tier == 1){\r\n            tier1DividendTracker.processAccount(payable(msg.sender), false);\r\n        }\r\n    }\r\n\r\n    function getTotalDividendsDistributed() external view returns (uint256) {\r\n        return tier5DividendTracker.totalDividendsDistributed() + tier4DividendTracker.totalDividendsDistributed() + tier3DividendTracker.totalDividendsDistributed() + tier2DividendTracker.totalDividendsDistributed() + tier1DividendTracker.totalDividendsDistributed();\r\n    }\r\n\r\n    function withdrawableDividendOf(address account) public view returns(uint256 withdrawableAmount) {\r\n        uint256 tier = getTier(account);\r\n        if(tier == 5){\r\n            withdrawableAmount = tier5DividendTracker.withdrawableDividendOf(account);\r\n        } else if (tier == 4){\r\n            withdrawableAmount = tier4DividendTracker.withdrawableDividendOf(account);\r\n        } else if (tier == 3){\r\n            withdrawableAmount = tier3DividendTracker.withdrawableDividendOf(account);\r\n        } else if (tier == 2){\r\n            withdrawableAmount = tier2DividendTracker.withdrawableDividendOf(account);\r\n        } else if (tier == 1){\r\n            withdrawableAmount = tier1DividendTracker.withdrawableDividendOf(account);\r\n        }\r\n  \t}\r\n\r\n\tfunction dividendTokenBalanceOf(address account) public view returns (uint256 holderbalance) {\r\n        uint256 tier = getTier(account);\r\n        if(tier == 5){\r\n            holderbalance = tier5DividendTracker.holderBalance(account);\r\n        } else if (tier == 4){\r\n            holderbalance = tier4DividendTracker.holderBalance(account);\r\n        } else if (tier == 3){\r\n            holderbalance = tier3DividendTracker.holderBalance(account);\r\n        } else if (tier == 2){\r\n            holderbalance = tier2DividendTracker.holderBalance(account);\r\n        } else if (tier == 1){\r\n            holderbalance = tier1DividendTracker.holderBalance(account);\r\n        }\r\n\t}\r\n\r\n    function getAccountTotalEarned(address account) external view returns (uint256) {\r\n        return tier5DividendTracker.accumulativeDividendOf(account) + tier4DividendTracker.accumulativeDividendOf(account) + tier3DividendTracker.accumulativeDividendOf(account)  + tier2DividendTracker.accumulativeDividendOf(account)  + tier1DividendTracker.accumulativeDividendOf(account);\r\n    }\r\n\r\n    function getAccountTotalClaimed(address account) external view returns (uint256) {\r\n        return tier5DividendTracker.withdrawnDividendOf(account) + tier4DividendTracker.withdrawnDividendOf(account) + tier3DividendTracker.withdrawnDividendOf(account)  + tier2DividendTracker.withdrawnDividendOf(account)  + tier1DividendTracker.withdrawnDividendOf(account);\r\n    }\r\n\r\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\r\n        return tier5DividendTracker.getNumberOfTokenHolders() + tier4DividendTracker.getNumberOfTokenHolders() + tier3DividendTracker.getNumberOfTokenHolders() + tier2DividendTracker.getNumberOfTokenHolders() + tier1DividendTracker.getNumberOfTokenHolders();\r\n    }\r\n    \r\n    function getNumberOfDividends() external view returns(uint256) {\r\n        return tier5DividendTracker.totalBalance() + tier4DividendTracker.totalBalance() + tier3DividendTracker.totalBalance() + tier2DividendTracker.totalBalance() + tier1DividendTracker.totalBalance();\r\n    }\r\n\r\n    function getTier(address wallet) public view returns (uint256) {\r\n        UserInfo memory user = userInfo[wallet];\r\n        uint256 amount = user.multipliedAmount;\r\n        if(amount >= tier1Threshold){\r\n            return 1;\r\n        } else if (amount >= tier2Threshold){\r\n            return 2;            \r\n        } else if (amount >= tier3Threshold){\r\n            return 3;            \r\n        } else if (amount >= tier4Threshold){\r\n            return 4;            \r\n        } else if (amount > tier5Threshold) {\r\n            return 5;            \r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function setBalance(address account) internal {\r\n        UserInfo memory user = userInfo[account];\r\n        uint256 tier = getTier(account);\r\n        if(tier == 5){\r\n            tier5DividendTracker.setBalance(payable(account), user.multipliedAmount);\r\n        } else if (tier == 4){\r\n            tier4DividendTracker.setBalance(payable(account), user.multipliedAmount);\r\n        } else if (tier == 3){\r\n            tier3DividendTracker.setBalance(payable(account), user.multipliedAmount);\r\n        } else if (tier == 2){\r\n            tier2DividendTracker.setBalance(payable(account), user.multipliedAmount);\r\n        } else if (tier == 1){\r\n            tier1DividendTracker.setBalance(payable(account), user.multipliedAmount);\r\n        }\r\n    }\r\n\r\n    function clearBalance(address account) internal {\r\n        uint256 tier = getTier(account);\r\n        if(tier == 5){\r\n            tier5DividendTracker.setBalance(payable(account), 0);\r\n        } else if (tier == 4){\r\n            tier4DividendTracker.setBalance(payable(account), 0);\r\n        } else if (tier == 3){\r\n            tier3DividendTracker.setBalance(payable(account), 0);\r\n        } else if (tier == 2){\r\n            tier2DividendTracker.setBalance(payable(account), 0);\r\n        } else if (tier == 1){\r\n            tier1DividendTracker.setBalance(payable(account), 0);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_apr\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"StakedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UnstakedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"apr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateNewRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDividendsOnly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"holderbalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRewardWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitPenaltyPerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountTotalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountTotalEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getHolderNfts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getStakingMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakedNftsAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percBoostPerNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokensPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxNfts\",\"type\":\"uint256\"}],\"name\":\"setMaxStakedNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"setNftAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"perc\",\"type\":\"uint256\"}],\"name\":\"setPercBoostPerNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier1DividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier1Percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier1Threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier2DividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier2Percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier2Threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier3DividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier3Percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier3Threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier4DividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier4Percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier4Threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier5DividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier5Percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier5Threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedMultiplied\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newApr\",\"type\":\"uint256\"}],\"name\":\"updateApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPenaltyPerc\",\"type\":\"uint256\"}],\"name\":\"updateExitPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daysForLock\",\"type\":\"uint256\"}],\"name\":\"updateLockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tier1Perc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tier2Perc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tier3Perc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tier4Perc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tier5Perc\",\"type\":\"uint256\"}],\"name\":\"updatePercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multipliedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawableAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SolalgoStaking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000940580db429da7fa8662d66f7a4d312443f09f520000000000000000000000000000000000000000000000000000000000000004", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a5efd948b37092125b4bc3058e1c2b88a048e9ab3a61e014125fd4c078ab5453"}