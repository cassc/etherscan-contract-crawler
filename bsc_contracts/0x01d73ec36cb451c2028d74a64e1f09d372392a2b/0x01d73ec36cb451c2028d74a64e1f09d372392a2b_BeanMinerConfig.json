{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/current/BeanMinerConfig.sol\": {\r\n      \"content\": \"/*\\r\\n    BeanMiner Miner config - BSC Miner\\r\\n    Developed by Kerry <TG: campermon>\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./BasicLibraries/SafeMath.sol\\\";\\r\\nimport \\\"./BasicLibraries/Auth.sol\\\";\\r\\nimport \\\"./Libraries/Testable.sol\\\";\\r\\n\\r\\ncontract BeanMinerConfig is Auth, Testable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    //External config of the miner\\r\\n\\r\\n    constructor(address minerAddress, address timerAddr) Auth(msg.sender) Testable(timerAddr) {\\r\\n        minerAdd = minerAddress;\\r\\n    }\\r\\n\\r\\n    address minerAdd = address(0);\\r\\n\\r\\n    //Set miner address\\r\\n    function setMinerAddress(address adr) public authorized { minerAdd = adr; }\\r\\n\\r\\n    //CUSTOM (ROI events)//\\r\\n    //One time event\\r\\n    uint256 internal roiEventBoostPercentage = 0;\\r\\n    uint256 internal roiEventDuration = 1 days;\\r\\n    uint256 internal timestampRoiEventBegins = 0; //when roi event begins, 0 means disabled\\r\\n\\r\\n    function getOneTimeEventBoostPercentage(uint256 _currentEventBoostPercentage) public view returns (uint256) {\\r\\n        uint256 eventBoostPercentage = _currentEventBoostPercentage;\\r\\n\\r\\n        //One time event\\r\\n        if(timestampRoiEventBegins != 0 && getCurrentTime() > timestampRoiEventBegins){\\r\\n            if(getCurrentTime() < timestampRoiEventBegins.add(roiEventDuration)){\\r\\n                if(roiEventBoostPercentage > eventBoostPercentage){\\r\\n                    eventBoostPercentage = roiEventBoostPercentage;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return eventBoostPercentage;\\r\\n    }\\r\\n\\r\\n    function setOneTimeEventBoost(uint256 _roiEventBoostPercentage, uint256 _roiEventDuration, uint256 _timestampRoiEventBegins) public authorized {\\r\\n        roiEventBoostPercentage = _roiEventBoostPercentage;\\r\\n        roiEventDuration = _roiEventDuration.mul(1 days);\\r\\n        timestampRoiEventBegins = _timestampRoiEventBegins;\\r\\n    }\\r\\n\\r\\n    //Periodic event\\r\\n    uint256 internal roiPeriodicEventBoostPercentage = 0;\\r\\n    uint256 internal roiPeriodicEventDuration = 1 days;\\r\\n    uint256 internal timestampRoiEventPeriodicityBegins = 0; //when periodic events begins, 0 means disabled\\r\\n    uint256 internal roiEventPeriodicity = 7 days;\\r\\n\\r\\n    function getPeriodicEventBoostPercentage(uint256 _currentEventBoostPercentage) public view returns (uint256) {\\r\\n        uint256 eventBoostPercentage = _currentEventBoostPercentage;\\r\\n\\r\\n        //Periodic events\\r\\n        if(timestampRoiEventPeriodicityBegins != 0 && getCurrentTime() > timestampRoiEventPeriodicityBegins){\\r\\n            //Formula to check if we are on event period\\r\\n            //(currentTimestamp - timestampInit) % (duration + restPeriod) < duration\\r\\n            if(getCurrentTime().sub(timestampRoiEventPeriodicityBegins).mod(roiEventPeriodicity.add(roiPeriodicEventDuration)) < roiPeriodicEventDuration){\\r\\n                if(roiPeriodicEventBoostPercentage > eventBoostPercentage){\\r\\n                    eventBoostPercentage = roiPeriodicEventBoostPercentage;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return eventBoostPercentage;\\r\\n    }\\r\\n\\r\\n    function setPeriodicEventBoost(uint256 _roiPeriodicEventBoostPercentage, uint256 _roiPeriodicEventDuration, uint256 _timestampRoiEventPeriodicityBegins, uint256 _roiEventPeriodicity) public authorized {\\r\\n        roiPeriodicEventBoostPercentage = _roiPeriodicEventBoostPercentage;\\r\\n        roiPeriodicEventDuration = _roiPeriodicEventDuration.mul(1 days);\\r\\n        timestampRoiEventPeriodicityBegins = _timestampRoiEventPeriodicityBegins;\\r\\n        roiEventPeriodicity = _roiEventPeriodicity.mul(1 days);\\r\\n    }\\r\\n\\r\\n    //Milestone event\\r\\n    uint256 public ntvlMilestoneSteps;\\r\\n    mapping(uint256 => uint256) internal tvlMilestoneSteps;\\r\\n    mapping(uint256 => uint256) internal tvlMilestoneBoostPercentages;\\r\\n    uint256 internal tvlMilestonesEventDuration = 1 days;\\r\\n    mapping(uint256 => uint256) internal tvlMilestoneStepsTimestampBegin; //when step begins, 0 means still not started\\r\\n\\r\\n    function getMilestoneEventBoostPercentage(uint256 _currentEventBoostPercentage) public view returns (uint256) {\\r\\n        uint256 eventBoostPercentage = _currentEventBoostPercentage;\\r\\n\\r\\n        //Milestone events \\r\\n        if(ntvlMilestoneSteps > 0){\\r\\n            //We get current milestone\\r\\n            uint256 _milestoneBoostPercentage = 0;\\r\\n            uint256 _stepTimestampBegin = 0;\\r\\n            for(uint256 i = 0; i < ntvlMilestoneSteps; i++){\\r\\n                if(address(minerAdd).balance > tvlMilestoneSteps[i].mul(10 ** 18)){\\r\\n                    _milestoneBoostPercentage = tvlMilestoneBoostPercentages[i];\\r\\n                    _stepTimestampBegin = tvlMilestoneStepsTimestampBegin[i];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if(getCurrentTime() > _stepTimestampBegin && getCurrentTime() < _stepTimestampBegin.add(tvlMilestonesEventDuration)){\\r\\n                if(_milestoneBoostPercentage > eventBoostPercentage){\\r\\n                    eventBoostPercentage = _milestoneBoostPercentage;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return eventBoostPercentage;\\r\\n    }\\r\\n\\r\\n    function setMilestoneEventBoost(uint256 [] memory _tvlMilestoneSteps, uint256 [] memory _tvlMilestoneBoostPercentages, uint256 _tvlMilestonesEventDuration, uint256 [] memory _tvlMilestoneStepsTimestampBegin) public authorized {\\r\\n        require(_tvlMilestoneSteps.length == _tvlMilestoneBoostPercentages.length, 'Arrays of different size');\\r\\n        require(_tvlMilestoneSteps.length == _tvlMilestoneStepsTimestampBegin.length, 'Arrays of different size');\\r\\n\\r\\n        ntvlMilestoneSteps = _tvlMilestoneSteps.length;\\r\\n        \\r\\n        for(uint256 i = 0; i < ntvlMilestoneSteps; i++){\\r\\n            tvlMilestoneSteps[i] = _tvlMilestoneSteps[i];\\r\\n            tvlMilestoneBoostPercentages[i] = _tvlMilestoneBoostPercentages[i];\\r\\n            tvlMilestonesEventDuration = _tvlMilestonesEventDuration.mul(1 days);\\r\\n            tvlMilestoneStepsTimestampBegin[i] = _tvlMilestoneStepsTimestampBegin[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateMilestoneEventBoostTimestamp() internal {\\r\\n        for(uint256 i = 0; i < ntvlMilestoneSteps; i++){\\r\\n            if(address(minerAdd).balance > tvlMilestoneSteps[i].mul(10**18)){\\r\\n                if(tvlMilestoneStepsTimestampBegin[i] == 0){\\r\\n                    tvlMilestoneStepsTimestampBegin[i] = getCurrentTime(); //Timestamp update\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function checkNeedUpdateMilestoneEventBoostTimestamp() internal view returns (bool) {\\r\\n        bool needUpdate = false;\\r\\n\\r\\n        for(uint256 i = 0; i < ntvlMilestoneSteps; i++){\\r\\n            if(address(minerAdd).balance > tvlMilestoneSteps[i].mul(10**18)){\\r\\n                if(tvlMilestoneStepsTimestampBegin[i] == 0){\\r\\n                    needUpdate = true;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return needUpdate;\\r\\n    }\\r\\n\\r\\n    //General\\r\\n    function getEventsBoostPercentage() public view returns (uint256) {\\r\\n\\r\\n        uint256 eventBoostPercentage = getMilestoneEventBoostPercentage(getPeriodicEventBoostPercentage(getOneTimeEventBoostPercentage(0)));\\r\\n\\r\\n        //Limited, security meassure\\r\\n        if(eventBoostPercentage > 1000){\\r\\n            eventBoostPercentage = 1000;\\r\\n        }\\r\\n\\r\\n        return eventBoostPercentage;\\r\\n    }\\r\\n\\r\\n    function needUpdateEventBoostTimestamps() external view returns (bool) {\\r\\n        return checkNeedUpdateMilestoneEventBoostTimestamp();\\r\\n    }\\r\\n\\r\\n    function updateEventsBoostTimestamps() external {\\r\\n        updateMilestoneEventBoostTimestamp();\\r\\n    }\\r\\n\\r\\n    function applyROIEventBoost(uint256 amount) external view returns (uint256) {\\r\\n        return amount.add(amount.mul(getEventsBoostPercentage()).div(100));\\r\\n    }    \\r\\n\\r\\n    //ALGORITHM(?)//\\r\\n\\r\\n    ////////////////\\r\\n}\"\r\n    },\r\n    \"/contracts/current/Timer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./BasicLibraries/Auth.sol\\\";\\r\\nimport \\\"./BasicLibraries/SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Universal store of current contract time for testing environments.\\r\\n */\\r\\ncontract Timer is Auth {\\r\\n    using SafeMath for uint256;\\r\\n    uint256 private currentTime;\\r\\n\\r\\n    bool enabled = false;\\r\\n\\r\\n    constructor() Auth(msg.sender) { }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the current time.\\r\\n     * @dev Will revert if not running in test mode.\\r\\n     * @param time timestamp to set `currentTime` to.\\r\\n     */\\r\\n    function setCurrentTime(uint256 time) external authorized {\\r\\n        require(time >= currentTime, \\\"Return to the future Doc!\\\");\\r\\n        currentTime = time;\\r\\n    }\\r\\n\\r\\n    function enable(bool _enabled) external authorized {\\r\\n        require(enabled == false, 'Can not be disabled');\\r\\n        enabled = _enabled;\\r\\n    }\\r\\n\\r\\n    function increaseDays(uint256 _days) external authorized {\\r\\n        currentTime = getCurrentTime().add(uint256(1 days).mul(_days));\\r\\n    }\\r\\n\\r\\n    function increaseMinutes(uint256 _minutes) external authorized {\\r\\n        currentTime = getCurrentTime().add(uint256(1 minutes).mul(_minutes));\\r\\n    }\\r\\n\\r\\n    function increaseSeconds(uint256 _seconds) external authorized {\\r\\n        currentTime = getCurrentTime().add(uint256(1 seconds).mul(_seconds));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\\r\\n     * Otherwise, it will return the block timestamp.\\r\\n     * @return uint256 for the current Testable timestamp.\\r\\n     */\\r\\n    function getCurrentTime() public view returns (uint256) {\\r\\n        if(enabled){\\r\\n            return currentTime;\\r\\n        }\\r\\n        else{\\r\\n            return block.timestamp;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/current/Libraries/Testable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./../Timer.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Base class that provides time overrides, but only if being run in test mode.\\r\\n */\\r\\nabstract contract Testable {\\r\\n    // If the contract is being run on the test network, then `timerAddress` will be the 0x0 address.\\r\\n    // Note: this variable should be set on construction and never modified.\\r\\n    address public timerAddress;\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs the Testable contract. Called by child contracts.\\r\\n     * @param _timerAddress Contract that stores the current time in a testing environment.\\r\\n     * Must be set to 0x0 for production environments that use live time.\\r\\n     */\\r\\n    constructor(address _timerAddress) {\\r\\n        timerAddress = _timerAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if not running in test mode.\\r\\n     */\\r\\n    modifier onlyIfTest {\\r\\n        require(timerAddress != address(0x0));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the current time.\\r\\n     * @dev Will revert if not running in test mode.\\r\\n     * @param time timestamp to set current Testable time to.\\r\\n     */\\r\\n    // function setCurrentTime(uint256 time) external onlyIfTest {\\r\\n    //     Timer(timerAddress).setCurrentTime(time);\\r\\n    // }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\\r\\n     * Otherwise, it will return the block timestamp.\\r\\n     * @return uint for the current Testable timestamp.\\r\\n     */\\r\\n    function getCurrentTime() public view returns (uint256) {\\r\\n        if (timerAddress != address(0x0)) {\\r\\n            return Timer(timerAddress).getCurrentTime();\\r\\n        } else {\\r\\n            return block.timestamp;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/current/BasicLibraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b <= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/current/BasicLibraries/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nabstract contract Auth {\\r\\n    address internal owner;\\r\\n    mapping (address => bool) internal authorizations;\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n        authorizations[_owner] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be contract owner\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender), \\\"!OWNER\\\"); _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be authorized\\r\\n     */\\r\\n    modifier authorized() {\\r\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\"); _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Authorize address. Owner only\\r\\n     */\\r\\n    function authorize(address adr) public onlyOwner {\\r\\n        authorizations[adr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Remove address' authorization. Owner only\\r\\n     */\\r\\n    function unauthorize(address adr) public onlyOwner {\\r\\n        authorizations[adr] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Check if address is owner\\r\\n     */\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return account == owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Return address' authorization status\\r\\n     */\\r\\n    function isAuthorized(address adr) public view returns (bool) {\\r\\n        return authorizations[adr];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\r\\n     */\\r\\n    function transferOwnership(address payable adr) public onlyOwner {\\r\\n        owner = adr;\\r\\n        authorizations[adr] = true;\\r\\n        emit OwnershipTransferred(adr);\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address owner);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"timerAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"applyROIEventBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEventsBoostPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentEventBoostPercentage\",\"type\":\"uint256\"}],\"name\":\"getMilestoneEventBoostPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentEventBoostPercentage\",\"type\":\"uint256\"}],\"name\":\"getOneTimeEventBoostPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentEventBoostPercentage\",\"type\":\"uint256\"}],\"name\":\"getPeriodicEventBoostPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needUpdateEventBoostTimestamps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ntvlMilestoneSteps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tvlMilestoneSteps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tvlMilestoneBoostPercentages\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_tvlMilestonesEventDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_tvlMilestoneStepsTimestampBegin\",\"type\":\"uint256[]\"}],\"name\":\"setMilestoneEventBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setMinerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roiEventBoostPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roiEventDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRoiEventBegins\",\"type\":\"uint256\"}],\"name\":\"setOneTimeEventBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roiPeriodicEventBoostPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roiPeriodicEventDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRoiEventPeriodicityBegins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roiEventPeriodicity\",\"type\":\"uint256\"}],\"name\":\"setPeriodicEventBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateEventsBoostTimestamps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BeanMinerConfig", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "999", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}