{"SourceCode": "/**\r\n * RisingSun's INF token.\r\n * Controlled time based and auth based emission.\r\n * Both quantities limited by the contract.\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IAuth {\r\n    function authorizeFor(address adr, string memory permissionName) external;\r\n    function authorizeForMultiplePermissions(address adr, string[] calldata permissionNames) external;\r\n    function authorizeForAllPermissions(address adr) external;\r\n}\r\n\r\nenum Permission {\r\n    Authorize,\r\n    Unauthorize,\r\n    LockPermissions,\r\n\r\n    AdjustVariables,\r\n    Emission,\r\n\tAdjustMinting,\r\n\tGameEmission\r\n}\r\n\r\nabstract contract Auth is IAuth {\r\n    struct PermissionLock {\r\n        bool isLocked;\r\n        uint64 expiryTime;\r\n    }\r\n\r\n    address public owner;\r\n    mapping(address => mapping(uint => bool)) private authorizations; // uint is permission index\r\n    \r\n    uint constant NUM_PERMISSIONS = 7; // always has to be adjusted when Permission element is added or removed\r\n    mapping(string => uint) permissionNameToIndex;\r\n    mapping(uint => string) permissionIndexToName;\r\n\r\n    mapping(uint => PermissionLock) lockedPermissions;\r\n\r\n    constructor(address owner_) {\r\n        owner = owner_;\r\n        for (uint i; i < NUM_PERMISSIONS; i++) {\r\n            authorizations[owner_][i] = true;\r\n        }\r\n\r\n        permissionNameToIndex[\"Authorize\"] = uint(Permission.Authorize);\r\n        permissionNameToIndex[\"Unauthorize\"] = uint(Permission.Unauthorize);\r\n        permissionNameToIndex[\"LockPermissions\"] = uint(Permission.LockPermissions);\r\n        permissionNameToIndex[\"AdjustVariables\"] = uint(Permission.AdjustVariables);\r\n        permissionNameToIndex[\"Emission\"] = uint(Permission.Emission);\r\n\t\tpermissionNameToIndex[\"AdjustMinting\"] = uint(Permission.AdjustMinting);\r\n\t\tpermissionNameToIndex[\"GameEmission\"] = uint(Permission.GameEmission);\r\n\r\n        permissionIndexToName[uint(Permission.Authorize)] = \"Authorize\";\r\n        permissionIndexToName[uint(Permission.Unauthorize)] = \"Unauthorize\";\r\n        permissionIndexToName[uint(Permission.LockPermissions)] = \"LockPermissions\";\r\n        permissionIndexToName[uint(Permission.AdjustVariables)] = \"AdjustVariables\";\r\n        permissionIndexToName[uint(Permission.Emission)] = \"Emission\";\r\n\t\tpermissionIndexToName[uint(Permission.AdjustMinting)] = \"AdjustMinting\";\r\n\t\tpermissionIndexToName[uint(Permission.GameEmission)] = \"GameEmission\";\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"Ownership required.\"); _;\r\n    }\r\n\r\n    function authorizedFor(Permission permission) internal view {\r\n        require(!lockedPermissions[uint(permission)].isLocked, \"Permission is locked.\");\r\n        require(isAuthorizedFor(msg.sender, permission), string(abi.encodePacked(\"Not authorized. You need the permission \", permissionIndexToName[uint(permission)])));\r\n    }\r\n\r\n    function authorizeFor(address adr, string memory permissionName) public override {\r\n        authorizedFor(Permission.Authorize);\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        authorizations[adr][permIndex] = true;\r\n        emit AuthorizedFor(adr, permissionName, permIndex);\r\n    }\r\n\r\n    function authorizeForMultiplePermissions(address adr, string[] calldata permissionNames) public override {\r\n        authorizedFor(Permission.Authorize);\r\n        for (uint i; i < permissionNames.length; i++) {\r\n            uint permIndex = permissionNameToIndex[permissionNames[i]];\r\n            authorizations[adr][permIndex] = true;\r\n            emit AuthorizedFor(adr, permissionNames[i], permIndex);\r\n        }\r\n    }\r\n\r\n    function authorizeForAllPermissions(address adr) public override {\r\n        authorizedFor(Permission.Authorize);\r\n        for (uint i; i < NUM_PERMISSIONS; i++) {\r\n            authorizations[adr][i] = true;\r\n        }\r\n    }\r\n\r\n    function unauthorizeFor(address adr, string memory permissionName) public {\r\n        authorizedFor(Permission.Unauthorize);\r\n        require(adr != owner, \"Can't unauthorize owner\");\r\n\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        authorizations[adr][permIndex] = false;\r\n        emit UnauthorizedFor(adr, permissionName, permIndex);\r\n    }\r\n\r\n    function unauthorizeForMultiplePermissions(address adr, string[] calldata permissionNames) public {\r\n        authorizedFor(Permission.Unauthorize);\r\n        require(adr != owner, \"Can't unauthorize owner\");\r\n\r\n        for (uint i; i < permissionNames.length; i++) {\r\n            uint permIndex = permissionNameToIndex[permissionNames[i]];\r\n            authorizations[adr][permIndex] = false;\r\n            emit UnauthorizedFor(adr, permissionNames[i], permIndex);\r\n        }\r\n    }\r\n\r\n    function unauthorizeForAllPermissions(address adr) public {\r\n        authorizedFor(Permission.Unauthorize);\r\n        for (uint i; i < NUM_PERMISSIONS; i++) {\r\n            authorizations[adr][i] = false;\r\n        }\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorizedFor(address adr, string memory permissionName) public view returns (bool) {\r\n        return authorizations[adr][permissionNameToIndex[permissionName]];\r\n    }\r\n\r\n    function isAuthorizedFor(address adr, Permission permission) public view returns (bool) {\r\n        return authorizations[adr][uint(permission)];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        address oldOwner = owner;\r\n        owner = adr;\r\n        for (uint i; i < NUM_PERMISSIONS; i++) {\r\n            authorizations[oldOwner][i] = false;\r\n            authorizations[owner][i] = true;\r\n        }\r\n        emit OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    function getPermissionNameToIndex(string memory permissionName) public view returns (uint) {\r\n        return permissionNameToIndex[permissionName];\r\n    }\r\n\r\n    function getPermissionUnlockTime(string memory permissionName) public view returns (uint) {\r\n        return lockedPermissions[permissionNameToIndex[permissionName]].expiryTime;\r\n    }\r\n\r\n    function isLocked(string memory permissionName) public view returns (bool) {\r\n        return lockedPermissions[permissionNameToIndex[permissionName]].isLocked;\r\n    }\r\n\r\n    function lockPermission(string memory permissionName, uint64 time) public virtual {\r\n        authorizedFor(Permission.LockPermissions);\r\n\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        uint64 expiryTime = uint64(block.timestamp) + time;\r\n        lockedPermissions[permIndex] = PermissionLock(true, expiryTime);\r\n        emit PermissionLocked(permissionName, permIndex, expiryTime);\r\n    }\r\n\r\n    function unlockPermission(string memory permissionName) public virtual {\r\n        require(block.timestamp > getPermissionUnlockTime(permissionName) , \"Permission is locked until the expiry time.\");\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        lockedPermissions[permIndex].isLocked = false;\r\n        emit PermissionUnlocked(permissionName, permIndex);\r\n    }\r\n\r\n    event PermissionLocked(string permissionName, uint permissionIndex, uint64 expiryTime);\r\n    event PermissionUnlocked(string permissionName, uint permissionIndex);\r\n    event OwnershipTransferred(address from, address to);\r\n    event AuthorizedFor(address adr, string permissionName, uint permissionIndex);\r\n    event UnauthorizedFor(address adr, string permissionName, uint permissionIndex);\r\n}\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDexFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract Influence is Auth, IBEP20 {\r\n\r\n\tstring constant _name = \"Influence\";\r\n    string constant _symbol = \"INF\";\r\n    uint8 constant _decimals = 9;\r\n\tuint256 _totalSupply = 0;\r\n\r\n\tmapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n\tmapping (address => bool) isFeeExempt;\r\n\r\n\tuint256 stakingFee = 0;\r\n\taddress stakingAddress;\r\n    uint256 feeDenominator = 1000;\r\n\tbool public feeOnNonTrade = false;\r\n\r\n\tIDexRouter public router;\r\n\taddress pairToken; // Token to be paired with\r\n    address tokenPair; // LP Pair with the token\r\n\tmapping (address => bool) public isPair;  // Taxable pairs\r\n\r\n\t// Emissions\r\n\tbool public emissionActive = false; // Whether regular emission is active\r\n\tuint64 _lastMint; // Last mint from regular emission\r\n\tuint256 _tokensEmittedPerSecond = 0 gwei; // Tokens minted per second on regular emission\r\n\r\n\tuint64 _lastAdminMint; // Last admin special mint\r\n\tuint256 _specialTokensPerSecond = 0.05 gwei; // Seconds it takes to be able for admin to mint a new token.\r\n\tuint256 _maxSpecialMint = 1_000_000 gwei; // Max tokens that can be minted at once from special mint. Limits in case long time without minting.\r\n\r\n\tuint64 _lastGameMint; // Last game mint\r\n\tuint256 _gameTokensPerSecond = 10 gwei; // Seconds it takes for the game to generate a token.\r\n\tuint256 _maxGameMint = 1_000_000 gwei; // Max tokens that can be minted at once from game rewards.\r\n\r\n\t// Rewards\r\n\tuint256 public winnerAward = 50 gwei;\r\n\tuint256 public loserAward = 10 gwei;\r\n\r\n\tconstructor(uint256 initialMint, address _router, address _token) Auth(msg.sender) {\r\n\t\trouter = IDexRouter(_router);\r\n\t\tpairToken = _token;\r\n        tokenPair = IDexFactory(router.factory()).createPair(_token, address(this));\r\n\t\tisPair[tokenPair] = true;\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n\t\t// Should the tax be activated.\r\n\t\tisFeeExempt[msg.sender] = true;\r\n        isFeeExempt[address(this)] = true;\r\n\r\n\t\t// Token emision starts counting from the moment the contract is created.\r\n\t\t_lastMint = uint64(block.timestamp);\r\n\r\n\t\t_mint(msg.sender, initialMint);\r\n\t}\r\n\r\n\t// IBEP20 implementations\r\n\treceive() external payable {}\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n\tfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n\t\t\trequire(_allowances[sender][msg.sender] >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n\tfunction _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n\t\trequire(amount > 0, \"Amount can't be 0\");\r\n\t\trequire(amount <= _balances[sender], \"Insufficient Balance\");\r\n\r\n\t\tif (emissionActive && stakingAddress != address(0)) {\r\n\t\t\temissionForStaking();\r\n\t\t}\r\n\r\n        _balances[sender] -= amount;\r\n\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\r\n        _balances[recipient] += amountReceived;\r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n\r\n\tfunction _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n\t\trequire(amount <= _balances[sender], \"Insufficient Balance\");\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\tfunction shouldTakeFee(address sender, address recipient) internal view returns(bool) {\r\n\t\tif (stakingFee == 0 || stakingAddress == address(0) || isFeeExempt[sender] || isFeeExempt[recipient]) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn isPair[tokenPair] || feeOnNonTrade;\r\n\t}\r\n\r\n\tfunction takeFee(address sender, uint256 amount) internal returns(uint256) {\r\n\t\tuint256 feeAmount = amount * stakingFee / feeDenominator;\r\n\r\n        _balances[stakingAddress] += feeAmount;\r\n        emit Transfer(sender, stakingAddress, feeAmount);\r\n\r\n        return amount - feeAmount;\r\n\t}\r\n\r\n\tfunction setPair(address pair) external {\r\n\t\tauthorizedFor(Permission.AdjustVariables);\r\n        isPair[pair] = true;\r\n    }\r\n    \r\n    function removePair(address pair) external {\r\n\t\tauthorizedFor(Permission.AdjustVariables);\r\n        isPair[pair] = false;\r\n    }\r\n\r\n\t/**\r\n\t * This is an INTERNAL function, that means it can NOT be called from outside the contract.\r\n\t */\r\n\tfunction _mint(address to, uint256 amount) internal {\r\n\t\trequire(to != address(0), \"ERC20: mint to the zero address\");\r\n\r\n\t\t_totalSupply += amount;\r\n        _balances[to] += amount;\r\n        emit Transfer(address(0), to, amount);\r\n\t}\r\n\r\n\tfunction setWinnerAward(uint256 award) external {\r\n\t\tauthorizedFor(Permission.AdjustVariables);\r\n\t\twinnerAward = award;\r\n\t}\r\n    \r\n    function setLoserAward(uint256 award) external {\r\n\t\tauthorizedFor(Permission.AdjustVariables);\r\n\t\tloserAward = award;\r\n\t}\r\n\r\n\tfunction setEmissionActive(bool active) external {\r\n\t\tauthorizedFor(Permission.AdjustMinting);\r\n\t\temissionActive = active;\r\n\t}\r\n\r\n\tfunction setStakingAddress(address addy) external {\r\n\t\tauthorizedFor(Permission.AdjustVariables);\r\n\t\tstakingAddress = addy;\r\n\t}\r\n\r\n\tfunction setSpecialMintLimit(uint256 limit) external {\r\n\t\tauthorizedFor(Permission.AdjustMinting);\r\n\t\t_maxSpecialMint = limit;\r\n\t}\r\n\r\n\tfunction setTokensEmittedPerSecond(uint256 amount) external {\r\n\t\tauthorizedFor(Permission.AdjustMinting);\r\n\t\t_tokensEmittedPerSecond = amount;\r\n\t}\r\n\r\n\tfunction setSpecialTokensPerSecond(uint256 amount) external {\r\n\t\tauthorizedFor(Permission.AdjustMinting);\r\n\t\t_specialTokensPerSecond = amount;\r\n\t}\r\n\r\n\tfunction setGameTokensPerSecond(uint256 amount) external {\r\n\t\tauthorizedFor(Permission.AdjustMinting);\r\n\t\t_gameTokensPerSecond = amount;\r\n\t}\r\n\r\n\tfunction setGameMintLimit(uint256 limit) external {\r\n\t\tauthorizedFor(Permission.AdjustMinting);\r\n\t\t_maxGameMint = limit;\r\n\t}\r\n    \r\n    function setFeeOnNonTrade(bool fee) external {\r\n\t\tauthorizedFor(Permission.AdjustVariables);\r\n\t\tfeeOnNonTrade = fee;\r\n\t}\r\n\r\n    function setFees(uint stakingFee_, uint denom_) external {\r\n\t\tauthorizedFor(Permission.AdjustVariables);\r\n\t\t\r\n        require(stakingFee_ <= denom_ * 5 / 100, \"Fee too high\");\r\n        \r\n        stakingFee = stakingFee_;\r\n        feeDenominator = denom_;\r\n\t}\r\n\r\n\t/**\r\n\t * Emits the token to the staking contract that should have been minted up to now.\r\n\t * Public because it can either be called internally or by the staking contract when checking rewards.\r\n\t */\r\n\tfunction emissionForStaking() public {\r\n\t\trequire(emissionActive, \"Emission is not active.\");\r\n\t\trequire(stakingAddress != address(0), \"Staking is not set up.\");\r\n\t\tuint256 secs = block.timestamp - _lastMint;\r\n\t\t_lastMint = uint64(block.timestamp);\r\n\t\t_mint(stakingAddress, secs * _tokensEmittedPerSecond);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Given a number of tokens per second, calculates how many is possible to mint since a specific set time.\r\n\t */\r\n\tfunction getMintableTokensFromTime(uint64 timestamp, uint256 tokenPerSecond, uint256 maxTokens) public view returns (uint256) {\r\n\t\tif (timestamp > block.timestamp) {\r\n        \treturn 0;\r\n\t\t}\r\n\r\n    \tuint256 tokens = (block.timestamp - timestamp) * tokenPerSecond;\r\n\t\tif (tokens > maxTokens) {\r\n\t\t\ttokens = maxTokens;\r\n\t\t}\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tfunction getSpecialMintableTokensFromTime(uint64 timestamp) public view returns (uint256) {\r\n\t\treturn getMintableTokensFromTime(timestamp, _specialTokensPerSecond, _maxSpecialMint);\r\n\t}\r\n\r\n\tfunction specialEmission(uint256 amount) external {\r\n\t\tauthorizedFor(Permission.Emission);\r\n\t\tuint256 mintableTokens = getSpecialMintableTokensFromTime(_lastAdminMint);\r\n\t\trequire(mintableTokens > 0, \"Nothing to mint yet.\");\r\n\t\trequire(amount <= mintableTokens, \"You cannot mint that much now!\");\r\n\t\tuint64 timeToTake = uint64(amount / _specialTokensPerSecond);\r\n\t\tif (mintableTokens >= _maxSpecialMint) {\r\n\t\t\t_lastAdminMint = uint64(block.timestamp - uint64(_maxSpecialMint / _specialTokensPerSecond) + timeToTake);\r\n\t\t} else {\r\n\t\t\t_lastAdminMint = uint64(_lastAdminMint + timeToTake);\r\n\t\t}\r\n\r\n\t\t_mint(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction getGameMintableTokensFromTime(uint64 timestamp) public view returns (uint256) {\r\n\t\treturn getMintableTokensFromTime(timestamp, _gameTokensPerSecond, _maxGameMint);\r\n\t}\r\n\r\n\tfunction incrementBalancesWithAvailable(address[] calldata addresses, uint256[] calldata values) external {\r\n\t\tauthorizedFor(Permission.GameEmission);\r\n\t\trequire(addresses.length == values.length, \"Addresses and rewards must be the same!\");\r\n\t\tuint256 mintableTokens = getGameMintableTokensFromTime(_lastGameMint);\r\n\t\trequire(mintableTokens > 0, \"Nothing to mint yet.\");\r\n\t\tuint256 amount = 0;\r\n\t\tfor (uint256 i = 0; i < addresses.length; i++) {\r\n\t\t\t// If the next mint would get us above mint limit, break and keep mints done.\r\n\t\t\t// This ensures a fair distribution within limits, next ones can be called after.\r\n\t\t\tif (amount + values[i] > mintableTokens) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t_mint(addresses[i], values[i]);\r\n\t\t\tamount += values[i];\r\n\t\t}\r\n\t\t_takeGameMintTime(mintableTokens, amount);\r\n\t}\r\n\t\r\n\tfunction incrementBalances(address[] calldata addresses, uint256[] calldata values, uint valuesTotal) external {\r\n\t\tauthorizedFor(Permission.GameEmission);\r\n\t\trequire(addresses.length == values.length, \"Addresses and rewards must be the same!\");\r\n\t\tuint256 mintableTokens = getGameMintableTokensFromTime(_lastGameMint);\r\n\t\trequire(mintableTokens > 0, \"Nothing to mint yet.\");\r\n\t\t// sanity check from user-provided valuesTotal to avoid a revert later\r\n\t\trequire(valuesTotal <= mintableTokens, \"You cannot mint that much now!\");\r\n\t\tuint256 amount = 0;\r\n\t\tfor (uint256 i = 0; i < addresses.length; i++) {\r\n\t\t\tif (amount + values[i] > mintableTokens) {\r\n\t\t\t\trevert('You cannot mint that much now, reverting.');\r\n\t\t\t}\r\n\t\t\t_mint(addresses[i], values[i]);\r\n\t\t\tamount += values[i];\r\n\t\t}\r\n\t\t_takeGameMintTime(mintableTokens, amount);\r\n\t}\r\n\r\n\tfunction incrementWinnerBalances(address[] calldata addresses) external {\r\n\t\tauthorizedFor(Permission.GameEmission);\r\n\t\t// Calculate how many tokens the game has mint from the allowed per day.\r\n\t\tuint256 mintableTokens = getGameMintableTokensFromTime(_lastGameMint);\r\n\t\t// The called rewards must be within bounds of tokens allowed to mint since last mint.\r\n\t\trequire(mintableTokens > 0, \"Nothing to mint yet.\");\r\n\t\tuint256 amount = addresses.length * winnerAward;\r\n\t\trequire(amount <= mintableTokens, \"You cannot mint that much now!\");\r\n\t\t// Mint all winner awards.\r\n\t\tfor (uint256 i = 0; i < addresses.length; i++) {\r\n\t\t\t_mint(addresses[i], winnerAward);\r\n\t\t}\r\n\t\t_takeGameMintTime(mintableTokens, amount);\r\n\t}\r\n    \r\n    function incrementLoserBalances(address[] calldata addresses) external {\r\n\t\tauthorizedFor(Permission.GameEmission);\r\n\t\t// Calculate how many tokens the game has mint from the allowed per day.\r\n\t\tuint256 mintableTokens = getGameMintableTokensFromTime(_lastGameMint);\r\n\t\t// The called rewards must be within bounds of tokens allowed to mint since last mint.\r\n\t\trequire(mintableTokens > 0, \"Nothing to mint yet.\");\r\n\t\tuint256 amount = addresses.length * loserAward;\r\n\t\trequire(amount <= mintableTokens, \"You cannot mint that much now!\");\r\n\t\t// Mint all winner awards.\r\n\t\tfor (uint256 i = 0; i < addresses.length; i++) {\r\n\t\t\t_mint(addresses[i], loserAward);\r\n\t\t}\r\n\t\t_takeGameMintTime(mintableTokens, amount);\r\n\t}\r\n\r\n\tfunction _takeGameMintTime(uint256 mintableTokens, uint256 amount) internal {\r\n\t\t// Take time from available time for mint so next call considers these minted tokens on the total mintable.\r\n\t\tuint64 timeToTake = uint64(amount / _gameTokensPerSecond);\r\n\t\tif (mintableTokens >= _maxGameMint) {\r\n\t\t\t_lastGameMint = uint64(block.timestamp - uint64(_maxGameMint / _gameTokensPerSecond) + timeToTake);\r\n\t\t} else {\r\n\t\t\t_lastGameMint = uint64(_lastGameMint + timeToTake);\r\n\t\t}\r\n\t}\r\n\t\r\n    function rescueStuckTokens(address tokenAdr, uint256 amount) external {\r\n        authorizedFor(Permission.AdjustVariables);\r\n        require(IBEP20(tokenAdr).transfer(msg.sender, amount), \"Transfer failed\");\r\n    }\r\n\r\n    function rescueStuckBNB(uint256 amount) external {\r\n        authorizedFor(Permission.AdjustVariables);\r\n        (bool success,) = payable(msg.sender).call{ value: amount }(\"\");\r\n        require(success, \"Failed to send BNB\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialMint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"}],\"name\":\"AuthorizedFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expiryTime\",\"type\":\"uint64\"}],\"name\":\"PermissionLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"}],\"name\":\"PermissionUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"}],\"name\":\"UnauthorizedFor\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"authorizeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorizeForAllPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"permissionNames\",\"type\":\"string[]\"}],\"name\":\"authorizeForMultiplePermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionForStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOnNonTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"getGameMintableTokensFromTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"tokenPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"}],\"name\":\"getMintableTokensFromTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"getPermissionNameToIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"getPermissionUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"getSpecialMintableTokensFromTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"valuesTotal\",\"type\":\"uint256\"}],\"name\":\"incrementBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"incrementBalancesWithAvailable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"incrementLoserBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"incrementWinnerBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"enum Permission\",\"name\":\"permission\",\"type\":\"uint8\"}],\"name\":\"isAuthorizedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"isAuthorizedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"lockPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loserAward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"removePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueStuckBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAdr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setEmissionActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"fee\",\"type\":\"bool\"}],\"name\":\"setFeeOnNonTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denom_\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setGameMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setGameTokensPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"award\",\"type\":\"uint256\"}],\"name\":\"setLoserAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setSpecialMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSpecialTokensPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTokensEmittedPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"award\",\"type\":\"uint256\"}],\"name\":\"setWinnerAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"specialEmission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"unauthorizeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorizeForAllPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"permissionNames\",\"type\":\"string[]\"}],\"name\":\"unauthorizeForMultiplePermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"unlockPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winnerAward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Influence", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000011c37937e08000000000000000000000000000cf0febd3f17cef5b47b0cd257acf6025c5bff3b7000000000000000000000000917841c010b3d86ed886f36f2c9807e07a2e3093", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bc35474f6dd43b6fffe1c164fe908a5cdc6f5e83c02a6a846f03c32ef6282263"}