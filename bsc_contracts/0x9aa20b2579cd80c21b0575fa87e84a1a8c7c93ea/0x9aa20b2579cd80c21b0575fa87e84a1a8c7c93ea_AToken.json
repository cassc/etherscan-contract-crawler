{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IOwnable {\r\n    function owner() external view returns (address);\r\n\r\n    function _checkOwner(address sender) external view returns (bool);\r\n}\r\n\r\ncontract ContractToken {\r\n    using SafeMath for uint256;\r\n    IOwnable ownable;\r\n    address public Owner;\r\n    IERC20 tokenERC20; \r\n    IERC20 LPTokenERC20; \r\n    uint256 public constant second = 86400; \r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            Owner == msg.sender || ownable._checkOwner(msg.sender),\r\n            \"Ownable: caller is not the owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    struct UserDetail {\r\n        uint256 amount; \r\n        uint256 timestamp; \r\n        uint256 redeemStamp; \r\n    }\r\n    struct Staked {\r\n        uint256 totalLP; \r\n        UserDetail[] userDetail; \r\n        uint256 lastClaimDay; \r\n        uint256 rewards; \r\n        uint256 index;\r\n        uint256 noRewards; \r\n        uint256 rewardDebt; \r\n    }\r\n    mapping(address => Staked) public stakedLP; \r\n    address[] public stakedList; \r\n    event puyLog(address adr, uint256 amount); \r\n    event removeLog(address adr, uint256 amount); \r\n    event upDaysBigLog(uint256 timestamp, uint256 amount);\r\n    event claimRewardsLog(address msgSender, uint256 amount);\r\n    bool public inLock = true;\r\n    uint256 public size = 5;\r\n    uint256 public denominator = 1000000; \r\n    uint256 public rewardPerTokenStored; \r\n    uint256 public _totalSupply; \r\n    uint256 public lastUpdateTime;\r\n    bool public inStop = false;\r\n    uint256 public stakingFinishTime; \r\n    bool private lock;\r\n    bool public inWithdrawLock = true; \r\n    uint256 public bigTotal; \r\n    bool public inClaminLock = true;\r\n\r\n    modifier onLock() {\r\n        lock = true;\r\n        _;\r\n        lock = false;\r\n    }\r\n\r\n    function getUserDetail(address adr, uint256 index)\r\n        public\r\n        view\r\n        returns (UserDetail memory userDetail)\r\n    {\r\n        Staked memory staked = stakedLP[adr];\r\n        require(staked.userDetail.length > index, \"index out of bounds\");\r\n        userDetail = staked.userDetail[index];\r\n        return userDetail;\r\n    }\r\n\r\n    function getgetUserDetailLength(address adr) public view returns (uint256) {\r\n        Staked memory staked = stakedLP[adr];\r\n        return staked.userDetail.length;\r\n    }\r\n\r\n    function getUserStaked(address adr)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalLP,\r\n            uint256 rewards,\r\n            uint256 index,\r\n            uint256 noRewards,\r\n            uint256 rewardDebt\r\n        )\r\n    {\r\n        Staked memory staked = stakedLP[adr];\r\n        totalLP = staked.totalLP;\r\n        rewards = staked.rewards;\r\n        index = staked.index;\r\n        noRewards = staked.noRewards;\r\n        rewardDebt = staked.rewardDebt;\r\n        return (totalLP, rewards, index, noRewards, rewardDebt);\r\n    }\r\n\r\n    function getStakedLength() public view returns (uint256) {\r\n        return stakedList.length;\r\n    }\r\n\r\n    function update(address owner) private {\r\n        require(owner != address(0), \"zero address operation\");\r\n        rewardPerTokenStored = rewardPerToken();\r\n        stakedLP[owner].rewardDebt = rewardPerTokenStored;\r\n        lastUpdateTime = getLastTime();\r\n    }\r\n\r\n    function snapshotStake(\r\n        address[] memory adrList,\r\n        uint256[] memory timeStampList,\r\n        uint256[] memory boolList,\r\n        uint256[] memory amountlist\r\n    ) external virtual onlyOwner {\r\n        for (uint256 i = 0; i < adrList.length; i++) {\r\n            Staked storage userStaked = stakedLP[adrList[i]];\r\n            if (amountlist[i] == 0) {\r\n                uint256 amount;\r\n                for (uint256 j = 0; j < userStaked.userDetail.length; j++) {\r\n                    UserDetail storage userDetail = userStaked.userDetail[j];\r\n                    if (userDetail.redeemStamp != 0) {\r\n                        continue;\r\n                    }\r\n                    amount = amount.add(userDetail.amount);\r\n                    userDetail.redeemStamp = timeStampList[i];\r\n                }\r\n                userStaked.noRewards = snapshotAllRewardsOfUser(\r\n                    adrList[i],\r\n                    timeStampList[i]\r\n                );\r\n                userStaked.totalLP = userStaked.totalLP.sub(amount);\r\n                _totalSupply = _totalSupply.sub(amount);\r\n                rewardPerTokenStored = snapshotRewardPerToken(timeStampList[i]);\r\n                userStaked.rewardDebt = rewardPerTokenStored;\r\n                lastUpdateTime = timeStampList[i];\r\n                continue;\r\n            }\r\n\r\n            if (boolList[i] == 0) {\r\n                userStaked.totalLP = userStaked.totalLP.add(amountlist[i]);\r\n                userStaked.userDetail.push(\r\n                    UserDetail(amountlist[i], timeStampList[i], 0)\r\n                );\r\n                if (userStaked.totalLP > amountlist[i]) {\r\n                    userStaked.noRewards = snapshotAllRewardsOfUser(\r\n                        adrList[i],\r\n                        timeStampList[i]\r\n                    );\r\n                }\r\n                _totalSupply = _totalSupply + amountlist[i];\r\n                rewardPerTokenStored = snapshotRewardPerToken(timeStampList[i]);\r\n                userStaked.rewardDebt = rewardPerTokenStored;\r\n                lastUpdateTime = timeStampList[i];\r\n                if (stakedList.length == 0) {\r\n                    userStaked.index = 0;\r\n                    stakedList.push(adrList[i]);\r\n                } else {\r\n                    if (userStaked.index == 0 && stakedList[0] != adrList[i]) {\r\n                        userStaked.index = stakedList.length;\r\n                        stakedList.push(adrList[i]);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            userStaked.noRewards = snapshotAllRewardsOfUser(\r\n                adrList[i],\r\n                timeStampList[i]\r\n            );\r\n            rewardPerTokenStored = snapshotRewardPerToken(timeStampList[i]);\r\n            userStaked.rewardDebt = rewardPerTokenStored;\r\n            lastUpdateTime = timeStampList[i];\r\n            uint256 userAmount = userStaked.noRewards > amountlist[i]\r\n                ? amountlist[i]\r\n                : userStaked.noRewards;\r\n            userStaked.noRewards = userStaked.noRewards.sub(userAmount);\r\n            userStaked.rewards = userStaked.rewards.add(amountlist[i]);\r\n        }\r\n    }\r\n\r\n    function allRewardsOfUser(address account) public view returns (uint256) {\r\n        return snapshotAllRewardsOfUser(account, getLastTime());\r\n    }\r\n\r\n    function snapshotAllRewardsOfUser(address account, uint256 lastTime)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Staked memory staked = stakedLP[account];\r\n        return\r\n            staked\r\n                .totalLP\r\n                .mul(snapshotRewardPerToken(lastTime).sub(staked.rewardDebt))\r\n                .div(denominator)\r\n                .add(staked.noRewards);\r\n    }\r\n\r\n    function getRewardRate() public view returns (uint256) {\r\n        return bigTotal.div(second);\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint256) {\r\n        return snapshotRewardPerToken(getLastTime());\r\n    }\r\n\r\n    function snapshotRewardPerToken(uint256 lastTime)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_totalSupply == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n        return\r\n            rewardPerTokenStored.add(\r\n                lastTime\r\n                    .sub(lastUpdateTime)\r\n                    .mul(getRewardRate())\r\n                    .mul(denominator)\r\n                    .div(_totalSupply)\r\n            );\r\n    }\r\n\r\n    function getLastTime() public view returns (uint256) {\r\n        return inStop ? stakingFinishTime : block.timestamp;\r\n    }\r\n\r\n    function OwGetUserNoRewardsTotal()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256 total)\r\n    {\r\n        for (uint256 i = 0; i < stakedList.length; i++) {\r\n            total = total.add(allRewardsOfUser(stakedList[i]));\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function OwGetUserInfo(uint256 page)\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (\r\n            address[] memory addressResult,\r\n            uint256[] memory totalLpResult,\r\n            uint256[] memory rewardsResult\r\n        )\r\n    {\r\n        require(page > 0, \"Page number should be greater than 0\");\r\n        uint256 stakedListLength = stakedList.length;\r\n        uint256 max = (page - 1) * size;\r\n        if (stakedListLength == 0 || stakedListLength <= max) {\r\n            return (new address[](0), new uint256[](0), new uint256[](0));\r\n        }\r\n        uint256 start = stakedListLength - max - 1;\r\n        uint256 end = start >= size ? start - size + 1 : 0;\r\n        uint256 itemCount = start - end + 1;\r\n        addressResult = new address[](itemCount);\r\n        totalLpResult = new uint256[](itemCount);\r\n        rewardsResult = new uint256[](itemCount);\r\n        for (uint256 i = start; i >= end; i--) {\r\n            address userAdr = stakedList[i];\r\n            Staked memory staked = stakedLP[userAdr];\r\n            addressResult[start - i] = userAdr;\r\n            totalLpResult[start - i] = staked.totalLP;\r\n            rewardsResult[start - i] = staked.rewards;\r\n            if (i == 0) {\r\n                break; \r\n            }\r\n        }\r\n        return (addressResult, totalLpResult, rewardsResult);\r\n    }\r\n\r\n    function claimRewards() public virtual {\r\n        require(!inClaminLock, \"claim stopped\");\r\n        address msgSender = msg.sender;\r\n        updateRewards(msgSender);\r\n        update(msgSender);\r\n        Staked storage staked = stakedLP[msgSender];\r\n        uint256 amount = staked.noRewards;\r\n        require(amount > 0, \"rewards is 0\");\r\n        uint256 tokenAmount = tokenERC20.balanceOf(address(this));\r\n        require(tokenAmount >= amount, \"insufficient contract amount\");\r\n        staked.noRewards = 0;\r\n        staked.rewards = staked.rewards.add(amount);\r\n        tokenERC20.transfer(msgSender, amount);\r\n        emit claimRewardsLog(msgSender, amount);\r\n    }\r\n\r\n    function getUserInfo(address sender)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        Staked memory staked = stakedLP[sender];\r\n        uint256 scale = 0;\r\n        if (staked.totalLP != 0) {\r\n            scale = (staked.totalLP * denominator) / _totalSupply;\r\n        }\r\n        return (\r\n            staked.totalLP,\r\n            staked.lastClaimDay,\r\n            staked.rewards,\r\n            scale,\r\n            bigTotal\r\n        );\r\n    }\r\n\r\n    function getUserDetail(uint256 page, address sender)\r\n        public\r\n        view\r\n        returns (\r\n            uint256[] memory amountResult,\r\n            uint256[] memory timestampResult,\r\n            uint256[] memory redeemStampResult,\r\n            uint256[] memory indexResult\r\n        )\r\n    {\r\n        require(page > 0, \"Page number should be greater than 0\");\r\n        Staked memory staked = stakedLP[sender];\r\n        UserDetail[] memory userDetailList = staked.userDetail;\r\n        uint256 max = (page - 1) * size;\r\n        if (userDetailList.length == 0 || userDetailList.length <= max) {\r\n            return (\r\n                new uint256[](0),\r\n                new uint256[](0),\r\n                new uint256[](0),\r\n                new uint256[](0)\r\n            );\r\n        }\r\n        uint256 start = userDetailList.length - max - 1;\r\n        uint256 end = start >= size ? start - size + 1 : 0;\r\n        uint256 itemCount = start - end + 1;\r\n        amountResult = new uint256[](itemCount);\r\n        timestampResult = new uint256[](itemCount);\r\n        redeemStampResult = new uint256[](itemCount);\r\n        indexResult = new uint256[](itemCount);\r\n        for (uint256 i = start; i >= end; i--) {\r\n            UserDetail memory userDetail = userDetailList[i];\r\n            amountResult[start - i] = userDetail.amount;\r\n            timestampResult[start - i] = userDetail.timestamp;\r\n            redeemStampResult[start - i] = userDetail.redeemStamp;\r\n            indexResult[start - i] = i;\r\n            if (i == 0) {\r\n                break; \r\n            }\r\n        }\r\n        return (amountResult, timestampResult, redeemStampResult, indexResult);\r\n    }\r\n\r\n    function updateRewards(address owner_) private {\r\n        stakedLP[owner_].noRewards = allRewardsOfUser(owner_);\r\n    }\r\n\r\n    function stake(uint256 amount) external virtual {\r\n        address msgSender = msg.sender;\r\n        require(!inLock, \"lock\");\r\n        require(amount > 0, \"ERC20: transfer amount 0\");\r\n        uint256 LpAmount = LPTokenERC20.balanceOf(msgSender);\r\n        require(amount <= LpAmount, \"ERC20: transfer amount exceeds balance\");\r\n        LPTokenERC20.transferFrom(msgSender, address(this), amount);\r\n        updateRewards(msgSender);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        update(msgSender);\r\n        Staked storage userStaked = stakedLP[msgSender];\r\n        userStaked.totalLP = userStaked.totalLP.add(amount);\r\n        userStaked.userDetail.push(UserDetail(amount, block.timestamp, 0));\r\n        if (stakedList.length == 0) {\r\n            userStaked.index = 0;\r\n            stakedList.push(msgSender);\r\n        } else {\r\n            if (userStaked.index == 0 && stakedList[0] != msgSender) {\r\n                userStaked.index = stakedList.length;\r\n                stakedList.push(msgSender);\r\n            }\r\n        }\r\n        emit puyLog(msgSender, amount);\r\n    }\r\n\r\n    function withdraw(uint256 index) external virtual {\r\n        require(!inWithdrawLock, \"!withdraw\");\r\n        address msgSender = msg.sender;\r\n        updateRewards(msgSender);\r\n        Staked storage userStaked = stakedLP[msgSender];\r\n        require(\r\n            userStaked.userDetail.length > index,\r\n            \"index should be less than length\"\r\n        );\r\n        UserDetail storage userDetail = userStaked.userDetail[index];\r\n        require(userDetail.redeemStamp == 0, \"redeemed\");\r\n        userDetail.redeemStamp = block.timestamp;\r\n        uint256 amount = userDetail.amount;\r\n        require(userStaked.totalLP >= amount, \"numeric error\");\r\n        userStaked.totalLP = userStaked.totalLP.sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        update(msgSender);\r\n        uint256 thatAmount = LPTokenERC20.balanceOf(address(this));\r\n        require(thatAmount >= amount, \"insufficient contract balance\");\r\n        LPTokenERC20.transfer(msgSender, amount);\r\n        emit removeLog(msgSender, amount);\r\n    }\r\n\r\n    function withdrawAll() external virtual {\r\n        require(!inWithdrawLock, \"!withdraw\");\r\n        address msgSender = msg.sender;\r\n        updateRewards(msgSender);\r\n        Staked storage userStaked = stakedLP[msgSender];\r\n        uint256 amount;\r\n        for (uint256 i = 0; i < userStaked.userDetail.length; i++) {\r\n            UserDetail storage userDetail = userStaked.userDetail[i];\r\n            if (userDetail.redeemStamp != 0) {\r\n                continue;\r\n            }\r\n            amount = amount.add(userDetail.amount);\r\n            userDetail.redeemStamp = block.timestamp;\r\n        }\r\n        require(userStaked.totalLP >= amount, \"numeric error\");\r\n        userStaked.totalLP = userStaked.totalLP.sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        uint256 thatAmount = LPTokenERC20.balanceOf(address(this));\r\n        require(thatAmount >= amount, \"insufficient contract balance\");\r\n        LPTokenERC20.transfer(msgSender, amount);\r\n        emit removeLog(msgSender, amount);\r\n    }\r\n\r\n    constructor(\r\n        address ownable_,\r\n        address contractToken_,\r\n        address LPToken_,\r\n        uint256 daysBigTotal_\r\n    ) {\r\n        ownable = IOwnable(ownable_);\r\n        Owner = msg.sender;\r\n        tokenERC20 = IERC20(contractToken_);\r\n        LPTokenERC20 = IERC20(LPToken_);\r\n        bigTotal = daysBigTotal_ * 10**IERC20(contractToken_).decimals();\r\n    }\r\n\r\n    function setOwnable(address ownable_) external virtual onlyOwner {\r\n        ownable = IOwnable(ownable_);\r\n    }\r\n\r\n    function setClaimLock(bool bl) external virtual onlyOwner {\r\n        inClaminLock = bl;\r\n    }\r\n\r\n    function setSize(uint256 size_) external virtual onlyOwner {\r\n        size = size_;\r\n    }\r\n\r\n    function setInLock(bool bl) external virtual onlyOwner {\r\n        inLock = bl;\r\n    }\r\n\r\n    function setInStop(bool bl) external virtual onlyOwner {\r\n        inStop = bl;\r\n        stakingFinishTime = block.timestamp;\r\n    }\r\n\r\n    function setInWithdrawLock(bool bl) external virtual onlyOwner {\r\n        inWithdrawLock = bl;\r\n    }\r\n\r\n    function setStakeLPToken(address token_) external virtual onlyOwner {\r\n        LPTokenERC20 = IERC20(token_);\r\n    }\r\n\r\n    function setDaysBig(uint256 amount) external virtual onlyOwner {\r\n        amount = amount * 10**tokenERC20.decimals();\r\n        bigTotal = amount;\r\n        lastUpdateTime = getLastTime();\r\n        rewardPerTokenStored = rewardPerToken();\r\n        emit upDaysBigLog(block.timestamp, amount);\r\n    }\r\n\r\n    function claimBalance(uint256 amount, address to) external onlyOwner {\r\n        payable(to).transfer(amount);\r\n    }\r\n\r\n    function claimToken(\r\n        address token_,\r\n        uint256 amount_,\r\n        address to_\r\n    ) external onlyOwner {\r\n        IERC20(token_).transfer(to_, amount_);\r\n    }\r\n\r\n    function claimLPToken(address adr) external onlyOwner {\r\n        LPTokenERC20.transfer(adr, LPTokenERC20.balanceOf(address(this)));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external virtual onlyOwner {\r\n        require(newOwner != address(0), \"new 0\");\r\n        Owner = newOwner;\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\ncontract AToken is ContractToken {\r\n    constructor()\r\n        ContractToken(\r\n            address(0x385cdB44F79af4245Dc13657d11c101d067810ed),\r\n            address(0x08801120Ab610F42Eaa5c573112EEc68C19cbD9c),\r\n            address(0xAD5D013A307d6DC3aA2A1c908633a69813c8a282),\r\n            20000\r\n        )\r\n    {}\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimRewardsLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"puyLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"upDaysBigLog\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"OwGetUserInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addressResult\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalLpResult\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardsResult\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OwGetUserNoRewardsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"allRewardsOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bigTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"claimLPToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakedLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserDetail\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemStamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ContractToken.UserDetail\",\"name\":\"userDetail\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getUserDetail\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountResult\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"timestampResult\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"redeemStampResult\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"indexResult\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getUserStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getgetUserDetailLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inClaminLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inStop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inWithdrawLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"second\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bl\",\"type\":\"bool\"}],\"name\":\"setClaimLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setDaysBig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bl\",\"type\":\"bool\"}],\"name\":\"setInLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bl\",\"type\":\"bool\"}],\"name\":\"setInStop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bl\",\"type\":\"bool\"}],\"name\":\"setInWithdrawLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownable_\",\"type\":\"address\"}],\"name\":\"setOwnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size_\",\"type\":\"uint256\"}],\"name\":\"setSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"setStakeLPToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastTime\",\"type\":\"uint256\"}],\"name\":\"snapshotAllRewardsOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTime\",\"type\":\"uint256\"}],\"name\":\"snapshotRewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"adrList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"timeStampList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"boolList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountlist\",\"type\":\"uint256[]\"}],\"name\":\"snapshotStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingFinishTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ed2e86cf67fa15fb3d36e9f73134601df864addaaf879b1df531aabaddd92d87"}