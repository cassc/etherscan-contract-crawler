{"SourceCode": "{\"golden.sol\":{\"content\":\"/**\\r\\n * Safetoken Fork (added Antiwhale, Antibot, Antidump Fuction) thx to 0f0crypto for a Safetoken rewrite!\\r\\n * \\r\\n * SPDX-License-Identifier: MIT\\r\\n */\\r\\n \\r\\n /**\\r\\n  * \\r\\n  * Super Low Liquidity Token\\r\\n  * \\r\\n\ud83d\udc8eSuper Low Liquidity Token\\r\\n\u2705 Total Supply : 100.000.000\\r\\n\u2705 Initial Liquidity : 0.2BNB\\r\\n\u2705 First Buy Max Transaction Around : 0,002 BNB\\r\\n\\r\\n\ud83d\udc8e Fee:\\r\\n\u2705 4% Liquidity\\r\\n\u2705 4% Redistribution\\r\\n\u2705 1% Burn           \\r\\n\u2705 1% Tip to the Dev\\r\\n\u2705 5% Whale Only Fee (Only when your balance is \\u003e capWhaleWalletBalance)\\r\\n\u2705 Max Transaction : 2% From Total Supply (2.000.000)\\r\\n\u2705 Max Wallet Balance : 3 times Max Transaction (6.000.000)\\r\\n\\r\\n\ud83d\udc8e AntiWhale\\r\\n\u2705 CapWhaleWalletBalance : 80% From Max Wallet Balance (Balance \\u003e 48,000,000)\\r\\n\\r\\n\ud83d\udc8e AntiBot and Dump\\r\\n\u2705 15 seconds between each transaction per wallet.\\r\\n\u2705 Cant send multiple transaction in one block per wallet.\\r\\n\\r\\n\ud83d\udc8e AntiDump\\r\\n\u2705 Fee Multiplier after release only sell\\r\\n\u2705 x2 in 24 hours after released\\r\\n\u2705 x1 after 24 hours after released\\r\\n\\r\\n\ud83d\udc8e Security\\r\\n\u2705 LP Burn 100%\\r\\n\\r\\n\\r\\n\\r\\nTG: https://t.me/wolfclaw\\r\\n\\r\\n */\\r\\n \\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n\\r\\n\\r\\nimport \\\"./safetoken-imports.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev If I did a good job you should not need to change anything apart from the values in the `Tokenomics`,\\r\\n * the actual name of the contract `SafeTokenV1Beta` at the very bottom **and** the `environment` into which\\r\\n * you are deploying the contract `SafeToken(Env.Testnet)` or `SafeToken(Env.MainnetV2)` etc.\\r\\n * \\r\\n * If you wish to disable a particular tax/fee just set it to zero (or comment it out/remove it).\\r\\n * \\r\\n * You can add (in theory) as many custom taxes/fees with dedicated wallet addresses if you want. \\r\\n * Nevertheless, I do not recommend using more than a few as the contract has not been tested \\r\\n * for more than the original number of taxes/fees, which is 6 (liquidity, redistribution, burn, \\r\\n * marketing, charity \\u0026 tip to the dev). Furthermore, exchanges may impose a limit on the total\\r\\n * transaction fee (so that, for example, you cannot claim 100%). Usually this is done by limiting the \\r\\n * max value of slippage, for example, PancakeSwap max slippage is 49.9% and the fees total of more than\\r\\n * 35% will most likely fail there.\\r\\n * \\r\\n * NOTE: You shouldn\\u0027t really remove the Rfi fee. If you do not wish to use RFI for your token, \\r\\n * you shouldn\\u0027t be using this contract at all (you\\u0027re just wasting gas if you do).\\r\\n *\\r\\n * NOTE: ignore the note below (anti-whale mech is not implemented yet)\\r\\n * If you wish to modify the anti-whale mech (progressive taxation) it will require a bit of coding. \\r\\n * I tried to make the integration as simple as possible via the `Antiwhale` contract, so the devs \\r\\n * know exactly where to look and what/how to make the necessary changes. There are many possibilites,\\r\\n * such as modifying the fees based on the tx amount (as % of TOTAL_SUPPLY), or sender\\u0027s wallet balance \\r\\n * (as % of TOTAL_SUPPLY), including (but not limited to):\\r\\n * - progressive taxation by tax brackets (e.g \\u003c1%, 1-2%, 2-5%, 5-10%)\\r\\n * - progressive taxation by the % over a threshold (e.g. 1%)\\r\\n * - extra fee (e.g. double) over a threshold \\r\\n */\\r\\nabstract contract Tokenomics {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    // --------------------- Token Settings ------------------- //\\r\\n\\r\\n    string internal constant NAME = \\\"GoldenWspp\\\";\\r\\n    string internal constant SYMBOL = \\\"GWSPP\\\";\\r\\n    \\r\\n    uint16 internal constant FEES_DIVISOR = 10**3;\\r\\n    uint8 internal constant DECIMALS = 6;\\r\\n    uint256 internal constant ZEROES = 10**DECIMALS;\\r\\n    \\r\\n    uint256 private constant MAX = ~uint256(0);\\r\\n    uint256 internal constant TOTAL_SUPPLY = ZEROES;\\r\\n    uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\\r\\n    \\r\\n    uint internal TIME_LIMIT_TRANSACTION = 15 seconds;\\r\\n    uint internal TimeContractStart = block.timestamp;\\r\\n    bool internal ANTI_DUMP_MULTIPLAYER = true;\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the maximum transaction amount allowed in a transfer.\\r\\n     * \\r\\n     * The default value is 1% of the total supply. \\r\\n     * \\r\\n     * NOTE: set the value to `TOTAL_SUPPLY` to have an unlimited max, i.e.\\r\\n     * `maxTransactionAmount = TOTAL_SUPPLY;`\\r\\n     */\\r\\n    uint256 internal constant maxTransactionAmount = (TOTAL_SUPPLY / 100); // 2% of the total supply\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the maximum allowed balance in a wallet.\\r\\n     * \\r\\n     * The default value is 2% of the total supply. \\r\\n     * \\r\\n     * NOTE: set the value to 0 to have an unlimited max.\\r\\n     *\\r\\n     * IMPORTANT: This value MUST be greater than `numberOfTokensToSwapToLiquidity` set below,\\r\\n     * otherwise the liquidity swap will never be executed\\r\\n     */\\r\\n    uint256 internal maxWalletBalance = maxTransactionAmount * 3; // 10 * maxTransactionAmount\\r\\n\\r\\n    /**\\r\\n     * @dev Set the Cap balance in a wallet to identification Whale.\\r\\n     * \\r\\n     * The default value is 75% of the maxWalletBalance. \\r\\n     * \\r\\n     * NOTE: set the value to maxWalletBalance to disable.\\r\\n     *\\r\\n     * IMPORTANT: This value MUST be greater than `numberOfTokensToSwapToLiquidity` set below,\\r\\n     * otherwise the liquidity swap will never be executed\\r\\n     */\\r\\n     uint16 internal constant WHALE_FEE_IN_PERCENT = 50;\\r\\n     uint256 internal capWhaleWalletBalance = (80 * maxWalletBalance) / 100; // 80% of the maxWalletBalance\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the number of tokens to swap and add to liquidity. \\r\\n     * \\r\\n     * Whenever the contract\\u0027s balance reaches this number of tokens, swap \\u0026 liquify will be \\r\\n     * executed in the very next transfer (via the `_beforeTokenTransfer`)\\r\\n     * \\r\\n     * If the `FeeType.Liquidity` is enabled in `FeesSettings`, the given % of each transaction will be first\\r\\n     * sent to the contract address. Once the contract\\u0027s balance reaches `numberOfTokensToSwapToLiquidity` the\\r\\n     * `swapAndLiquify` of `Liquifier` will be executed. Half of the tokens will be swapped for ETH \\r\\n     * (or BNB on BSC) and together with the other half converted into a Token-ETH/Token-BNB LP Token.\\r\\n     * \\r\\n     * See: `Liquifier`\\r\\n     */\\r\\n    uint256 internal constant numberOfTokensToSwapToLiquidity = TOTAL_SUPPLY / 1000; // 0.1% of the total supply\\r\\n\\r\\n    // --------------------- Fees Settings ------------------- //\\r\\n\\r\\n    /**\\r\\n     * @dev To add/edit/remove fees scroll down to the `addFees` function below\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @dev You can change the value of the burn address to pretty much anything\\r\\n     * that\\u0027s (clearly) a non-random address, i.e. for which the probability of \\r\\n     * someone having the private key is (virtually) 0. For example, 0x00.....1, \\r\\n     * 0x111...111, 0x12345.....12345, etc.\\r\\n     *\\r\\n     * NOTE: This does NOT need to be the zero address, adress(0) = 0x000...000;\\r\\n     *\\r\\n     * Trasfering tokens to the burn address is good for optics/marketing. Nevertheless\\r\\n     * if the burn address is excluded from rewards (unlike in Safemoon), sending tokens\\r\\n     * to the burn address actually improves redistribution to holders (as they will\\r\\n     * have a larger % of tokens in non-excluded accounts)\\r\\n     *\\r\\n     * p.s. the address below is the speed of light in vacuum in m/s (expressed in decimals),\\r\\n     * the hex value is 0x0000000000000000000000000000000011dE784A; :)\\r\\n     *\\r\\n     * Here are the values of some other fundamental constants to use:\\r\\n     * 0x0000000000000000000000000000000602214076 (Avogardo constant)\\r\\n     * 0x0000000000000000000000000000000001380649 (Boltzmann constant)\\r\\n     * 0x2718281828459045235360287471352662497757 (e)\\r\\n     * 0x0000000000000000000000000000001602176634 (elementary charge)\\r\\n     * 0x0000000000000000000000000200231930436256 (electron g-factor)\\r\\n     * 0x0000000000000000000000000000091093837015 (electron mass)\\r\\n     * 0x0000000000000000000000000000137035999084 (fine structure constant)\\r\\n     * 0x0577215664901532860606512090082402431042 (Euler-Mascheroni constant)\\r\\n     * 0x1618033988749894848204586834365638117720 (golden ratio)\\r\\n     * 0x0000000000000000000000000000009192631770 (hyperfine transition fq)\\r\\n     * 0x0000000000000000000000000000010011659208 (muom g-2)\\r\\n     * 0x3141592653589793238462643383279502884197 (pi)\\r\\n     * 0x0000000000000000000000000000000662607015 (Planck\\u0027s constant)\\r\\n     * 0x0000000000000000000000000000001054571817 (reduced Planck\\u0027s constant)\\r\\n     * 0x1414213562373095048801688724209698078569 (sqrt(2))\\r\\n     */\\r\\n    address internal burnAddress = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    /**\\r\\n     * @dev You can disable this but if you feel generous I\\u0027d appreciate the 0.1%\\r\\n     * donation for rewriting Safemoon and making everyone\\u0027s life a little easier\\r\\n     *\\r\\n     * If you keep this tip enabled, let me know in Discord: https://discord.gg/zn86MDCQcM\\r\\n     * and you\\u0027ll be added to the partners section to promote your token. \\r\\n     */\\r\\n    address internal tipToTheDev = 0x5fd3d666afA636dD70A9d33Ef20799aa53DcbB37;\\r\\n\\r\\n    enum FeeType { Antiwhale, Burn, Liquidity, Rfi, External, ExternalToETH }\\r\\n    struct Fee {\\r\\n        FeeType name;\\r\\n        uint256 value;\\r\\n        address recipient;\\r\\n        uint256 total;\\r\\n    }\\r\\n\\r\\n    Fee[] internal fees;\\r\\n    uint256 internal sumOfFees;\\r\\n\\r\\n    constructor() {\\r\\n        _addFees();\\r\\n    }\\r\\n\\r\\n    function _addFee(FeeType name, uint256 value, address recipient) private {\\r\\n        fees.push( Fee(name, value, recipient, 0 ) );\\r\\n        sumOfFees += value;\\r\\n    }\\r\\n\\r\\n    function _addFees() private {\\r\\n\\r\\n        /**\\r\\n         * The RFI recipient is ignored but we need to give a valid address value\\r\\n         *\\r\\n         * CAUTION: If you don\\u0027t want to use RFI this implementation isn\\u0027t really for you!\\r\\n         *      There are much more efficient and cleaner token contracts without RFI \\r\\n         *      so you should use one of those\\r\\n         *\\r\\n         * The value of fees is given in part per 1000 (based on the value of FEES_DIVISOR),\\r\\n         * e.g. for 5% use 50, for 3.5% use 35, etc. \\r\\n         */ \\r\\n        _addFee(FeeType.Rfi, 40, address(this) ); // 4% Redistribute to holders\\r\\n        _addFee(FeeType.Burn, 10, burnAddress ); // 1% Burn\\r\\n        _addFee(FeeType.Liquidity, 40, address(this) ); // 4% added to liquidity\\r\\n        _addFee(FeeType.ExternalToETH, 10, tipToTheDev ); // 1% Tips to the Dev\\r\\n        _addFee(FeeType.Antiwhale, WHALE_FEE_IN_PERCENT, tipToTheDev ); // 5% if you have balance more than capWhaleWalletBalance\\r\\n        \\r\\n    }\\r\\n\\r\\n    function _getFeesCount() internal view returns (uint256){ return fees.length; }\\r\\n\\r\\n    function _getFeeStruct(uint256 index) private view returns(Fee storage){\\r\\n        require( index \\u003e= 0 \\u0026\\u0026 index \\u003c fees.length, \\\"FeesSettings._getFeeStruct: Fee index out of bounds\\\");\\r\\n        return fees[index];\\r\\n    }\\r\\n    function _getFee(uint256 index) internal view returns (FeeType, uint256, address, uint256){\\r\\n        Fee memory fee = _getFeeStruct(index);\\r\\n        return ( fee.name, fee.value, fee.recipient, fee.total );\\r\\n    }\\r\\n    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\\r\\n        Fee storage fee = _getFeeStruct(index);\\r\\n        fee.total = fee.total.add(amount);\\r\\n    }\\r\\n\\r\\n    // function getCollectedFeeTotal(uint256 index) external view returns (uint256){\\r\\n    function getCollectedFeeTotal(uint256 index) internal view returns (uint256){\\r\\n        Fee memory fee = _getFeeStruct(index);\\r\\n        return fee.total;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Presaleable is Manageable {\\r\\n    bool internal isInPresale;\\r\\n    function setPreseableEnabled(bool value) external onlyManager {\\r\\n        isInPresale = value;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract BaseRfiToken is IERC20, IERC20Metadata, Ownable, Presaleable, Tokenomics {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _reflectedBalances;\\r\\n    mapping (address =\\u003e uint256) internal _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\r\\n    \\r\\n    mapping (address =\\u003e bool) internal _isExcludedFromFee;\\r\\n    mapping (address =\\u003e bool) internal _isExcludedFromRewards;\\r\\n    address[] private _excluded;\\r\\n    \\r\\n    constructor() {\\r\\n        \\r\\n        _reflectedBalances[owner()] = _reflectedSupply;\\r\\n        \\r\\n        // exclude owner and this contract from fee\\r\\n        _isExcludedFromFee[owner()] = true;\\r\\n        _isExcludedFromFee[address(this)] = true;\\r\\n        \\r\\n        // exclude the owner and this contract from rewards\\r\\n        _exclude(owner());\\r\\n        _exclude(address(this));\\r\\n\\r\\n        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    /** Functions required by IERC20Metadat **/\\r\\n        function name() external pure override returns (string memory) { return NAME; }\\r\\n        function symbol() external pure override returns (string memory) { return SYMBOL; }\\r\\n        function decimals() external pure override returns (uint8) { return DECIMALS; }\\r\\n        \\r\\n    /** Functions required by IERC20Metadat - END **/\\r\\n    /** Functions required by IERC20 **/\\r\\n        function totalSupply() external pure override returns (uint256) {\\r\\n            return TOTAL_SUPPLY;\\r\\n        }\\r\\n        \\r\\n        function balanceOf(address account) public view override returns (uint256){\\r\\n            if (_isExcludedFromRewards[account]) return _balances[account];\\r\\n            return tokenFromReflection(_reflectedBalances[account]);\\r\\n        }\\r\\n        \\r\\n        function transfer(address recipient, uint256 amount) external override returns (bool){\\r\\n            _transfer(_msgSender(), recipient, amount);\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        function allowance(address owner, address spender) external view override returns (uint256){\\r\\n            return _allowances[owner][spender];\\r\\n        }\\r\\n    \\r\\n        function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n            _approve(_msgSender(), spender, amount);\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        function getAddressLastTransaction(address owner ) external view returns(uint)\\r\\n        {\\r\\n            return _getLastTransaction(owner);\\r\\n        }\\r\\n        \\r\\n        function getContractStartTime() external view returns(uint){\\r\\n            return TimeContractStart;\\r\\n        }\\r\\n        \\r\\n        function setTimeLimitTransaction(uint inSecond) external onlyManager{\\r\\n            TIME_LIMIT_TRANSACTION = inSecond;\\r\\n        }\\r\\n        \\r\\n        function getTimeLimitTransaction() external view returns(uint) {\\r\\n            return TIME_LIMIT_TRANSACTION;\\r\\n        }\\r\\n        \\r\\n        function setMaxWalletBalance(uint256 amount) external onlyManager{\\r\\n            maxWalletBalance = amount;\\r\\n        }\\r\\n        \\r\\n        function getMaxWalletBalance() external view returns(uint256)\\r\\n        {\\r\\n            return maxWalletBalance;\\r\\n        }\\r\\n        \\r\\n        function setCapWhaleWalletBalance(uint256 amount) external onlyManager{\\r\\n            capWhaleWalletBalance = amount;\\r\\n        }\\r\\n        \\r\\n        function getCapWhaleWalletBalance() external view returns(uint256)\\r\\n        {\\r\\n            return capWhaleWalletBalance;\\r\\n        }\\r\\n        \\r\\n        function setIsAntiDump(bool isActive) external onlyManager{\\r\\n            ANTI_DUMP_MULTIPLAYER = isActive;\\r\\n        }\\r\\n        \\r\\n        function getAntiDump() external view returns(bool)\\r\\n        {\\r\\n            return ANTI_DUMP_MULTIPLAYER;\\r\\n        }\\r\\n        \\r\\n        function checkAddress(address checkAdd) external view returns(uint256)\\r\\n        {\\r\\n           return _getLastTransaction(checkAdd);\\r\\n        }\\r\\n        \\r\\n        function checkAddress2(address checkAdd) external view returns(uint256)\\r\\n        {\\r\\n           return _getLastBlock(checkAdd);\\r\\n        }\\r\\n        \\r\\n        function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool){\\r\\n            _transfer(sender, recipient, amount);\\r\\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n            return true;\\r\\n        }\\r\\n    /** Functions required by IERC20 - END **/\\r\\n\\r\\n    /**\\r\\n     * @dev this is really a \\\"soft\\\" burn (total supply is not reduced). RFI holders\\r\\n     * get two benefits from burning tokens:\\r\\n     *\\r\\n     * 1) Tokens in the burn address increase the % of tokens held by holders not\\r\\n     *    excluded from rewards (assuming the burn address is excluded)\\r\\n     * 2) Tokens in the burn address cannot be sold (which in turn draing the \\r\\n     *    liquidity pool)\\r\\n     *\\r\\n     *\\r\\n     * In RFI holders already get % of each transaction so the value of their tokens \\r\\n     * increases (in a way). Therefore there is really no need to do a \\\"hard\\\" burn \\r\\n     * (reduce the total supply). What matters (in RFI) is to make sure that a large\\r\\n     * amount of tokens cannot be sold = draining the liquidity pool = lowering the\\r\\n     * value of tokens holders own. For this purpose, transfering tokens to a (vanity)\\r\\n     * burn address is the most appropriate way to \\\"burn\\\". \\r\\n     *\\r\\n     * There is an extra check placed into the `transfer` function to make sure the\\r\\n     * burn address cannot withdraw the tokens is has (although the chance of someone\\r\\n     * having/finding the private key is virtually zero).\\r\\n     */\\r\\n    function burn(uint256 amount) external {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n        require(sender != address(0), \\\"BaseRfiToken: burn from the zero address\\\");\\r\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: burn from the burn address\\\");\\r\\n\\r\\n        uint256 balance = balanceOf(sender);\\r\\n        require(balance \\u003e= amount, \\\"BaseRfiToken: burn amount exceeds balance\\\");\\r\\n\\r\\n        uint256 reflectedAmount = amount.mul(_getCurrentRate());\\r\\n\\r\\n        // remove the amount from the sender\\u0027s balance first\\r\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(reflectedAmount);\\r\\n        if (_isExcludedFromRewards[sender])\\r\\n            _balances[sender] = _balances[sender].sub(amount);\\r\\n\\r\\n        _burnTokens( sender, amount, reflectedAmount );\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev \\\"Soft\\\" burns the specified amount of tokens by sending them \\r\\n     * to the burn address\\r\\n     */\\r\\n    function _burnTokens(address sender, uint256 tBurn, uint256 rBurn) internal {\\r\\n\\r\\n        /**\\r\\n         * @dev Do not reduce _totalSupply and/or _reflectedSupply. (soft) burning by sending\\r\\n         * tokens to the burn address (which should be excluded from rewards) is sufficient\\r\\n         * in RFI\\r\\n         */ \\r\\n        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(rBurn);\\r\\n        if (_isExcludedFromRewards[burnAddress])\\r\\n            _balances[burnAddress] = _balances[burnAddress].add(tBurn);\\r\\n\\r\\n        /**\\r\\n         * @dev Emit the event so that the burn address balance is updated (on bscscan)\\r\\n         */\\r\\n        emit Transfer(sender, burnAddress, tBurn);\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function isExcludedFromReward(address account) external view returns (bool) {\\r\\n        return _isExcludedFromRewards[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates and returns the reflected amount for the given amount with or without \\r\\n     * the transfer fees (deductTransferFee true/false)\\r\\n     */\\r\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\r\\n        require(tAmount \\u003c= TOTAL_SUPPLY, \\\"Amount must be less than supply\\\");\\r\\n        if (!deductTransferFee) {\\r\\n            (uint256 rAmount,,,,) = _getValues(tAmount,0);\\r\\n            return rAmount;\\r\\n        } else {\\r\\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount,_getSumOfFees(_msgSender(), tAmount));\\r\\n            return rTransferAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\\r\\n     */\\r\\n    function tokenFromReflection(uint256 rAmount) internal view returns(uint256) {\\r\\n        require(rAmount \\u003c= _reflectedSupply, \\\"Amount must be less than total reflections\\\");\\r\\n        uint256 currentRate = _getCurrentRate();\\r\\n        return rAmount.div(currentRate);\\r\\n    }\\r\\n    \\r\\n    function excludeFromReward(address account) external onlyOwner() {\\r\\n        require(!_isExcludedFromRewards[account], \\\"Account is not included\\\");\\r\\n        _exclude(account);\\r\\n    }\\r\\n    \\r\\n    function _exclude(address account) internal {\\r\\n        if(_reflectedBalances[account] \\u003e 0) {\\r\\n            _balances[account] = tokenFromReflection(_reflectedBalances[account]);\\r\\n        }\\r\\n        _isExcludedFromRewards[account] = true;\\r\\n        _excluded.push(account);\\r\\n    }\\r\\n\\r\\n    function includeInReward(address account) external onlyOwner() {\\r\\n        require(_isExcludedFromRewards[account], \\\"Account is not excluded\\\");\\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_excluded[i] == account) {\\r\\n                _excluded[i] = _excluded[_excluded.length - 1];\\r\\n                _balances[account] = 0;\\r\\n                _isExcludedFromRewards[account] = false;\\r\\n                _excluded.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function setExcludedFromFee(address account, bool value) external onlyOwner { _isExcludedFromFee[account] = value; }\\r\\n    function isExcludedFromFee(address account) public view returns(bool) { return _isExcludedFromFee[account]; }\\r\\n    \\r\\n    function _approve(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"BaseRfiToken: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"BaseRfiToken: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     */\\r\\n    function _isUnlimitedSender(address account) internal view returns(bool){\\r\\n        // the owner should be the only whitelisted sender\\r\\n        return (account == owner());\\r\\n    }\\r\\n    /**\\r\\n     */\\r\\n    function _isUnlimitedRecipient(address account) internal view returns(bool){\\r\\n        // the owner should be a white-listed recipient\\r\\n        // and anyone should be able to burn as many tokens as \\r\\n        // he/she wants\\r\\n        return (account == owner() || account == burnAddress);\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\r\\n        require(sender != address(0), \\\"BaseRfiToken: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"BaseRfiToken: transfer to the zero address\\\");\\r\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: transfer from the burn address\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        \\r\\n        // indicates whether or not feee should be deducted from the transfer\\r\\n        bool takeFee = true;\\r\\n\\r\\n        if ( isInPresale ){ takeFee = false; }\\r\\n        else {\\r\\n            /**\\r\\n            * Check the amount is within the max allowed limit as long as a\\r\\n            * unlimited sender/recepient is not involved in the transaction\\r\\n            */\\r\\n            if ( amount \\u003e maxTransactionAmount \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) ){\\r\\n                revert(\\\"Transfer amount exceeds the maxTxAmount.\\\");\\r\\n            }\\r\\n            /**\\r\\n            * The pair needs to excluded from the max wallet balance check; \\r\\n            * selling tokens is sending them back to the pair (without this\\r\\n            * check, selling tokens would not work if the pair\\u0027s balance \\r\\n            * was over the allowed max)\\r\\n            *\\r\\n            * Note: This does NOT take into account the fees which will be deducted \\r\\n            *       from the amount. As such it could be a bit confusing \\r\\n            */\\r\\n            if ( maxWalletBalance \\u003e 0 \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) \\u0026\\u0026 !_isV2Pair(recipient)){\\r\\n                uint256 recipientBalance = balanceOf(recipient);\\r\\n                require(recipientBalance + amount \\u003c= maxWalletBalance, \\\"New balance would exceed the maxWalletBalance\\\");\\r\\n            }\\r\\n            \\r\\n            if(TIME_LIMIT_TRANSACTION \\u003e 0 \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) \\u0026\\u0026 sender != address(this))\\r\\n            {\\r\\n                //AntiBot Using Block Check\\r\\n                require(block.number \\u003e _getLastBlock(tx.origin), \\\"You cant send more than one transaction in one block.\\\");\\r\\n                _setLastBlock(tx.origin);\\r\\n                \\r\\n                //AntiBot Using Time Between Transaction\\r\\n                if(_getLastTransaction(tx.origin) \\u003e 0)\\r\\n                {\\r\\n                    require(_getLastTransaction(tx.origin) \\u003c= block.timestamp, \\\"You need to wait TIME_LIMIT_TRANSACTION before perform another transaction.\\\");\\r\\n                }\\r\\n                _setLastTransaction(tx.origin);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){ takeFee = false; }\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount, takeFee);\\r\\n        _transferTokens(sender, recipient, amount, takeFee);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function _transferTokens(address sender, address recipient, uint256 amount, bool takeFee) private {\\r\\n    \\r\\n        /**\\r\\n         * We don\\u0027t need to know anything about the individual fees here \\r\\n         * (like Safemoon does with `_getValues`). All that is required \\r\\n         * for the transfer is the sum of all fees to calculate the % of the total \\r\\n         * transaction amount which should be transferred to the recipient. \\r\\n         *\\r\\n         * The `_takeFees` call will/should take care of the individual fees\\r\\n         */\\r\\n        uint256 sumOfFees = _getSumOfFees(sender, amount);\\r\\n        \\r\\n        //Remove Whale Fee if sender is not whale\\r\\n        bool isWhale = true;\\r\\n        if(capWhaleWalletBalance \\u003e 0)\\r\\n        {\\r\\n            if(balanceOf(sender) \\u003c capWhaleWalletBalance || balanceOf(recipient) \\u003c capWhaleWalletBalance)\\r\\n            {\\r\\n                sumOfFees = sumOfFees - WHALE_FEE_IN_PERCENT;\\r\\n                isWhale = false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        /**\\r\\n         * Only ANTI_DUMP_MULTIPLAYER when selling\\r\\n         * */\\r\\n        uint multiplier = 1 ;\\r\\n        if(_isV2Pair(recipient))\\r\\n        {\\r\\n            multiplier = _multiplier();\\r\\n            sumOfFees = sumOfFees.mul(multiplier);\\r\\n        }\\r\\n        \\r\\n        if ( !takeFee ){ sumOfFees = 0; }\\r\\n        \\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, uint256 tTransferAmount, uint256 currentRate ) = _getValues(amount, sumOfFees);\\r\\n        \\r\\n        /** \\r\\n         * Sender\\u0027s and Recipient\\u0027s reflected balances must be always updated regardless of\\r\\n         * whether they are excluded from rewards or not.\\r\\n         */ \\r\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\\r\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rTransferAmount);\\r\\n\\r\\n        /**\\r\\n         * Update the true/nominal balances for excluded accounts\\r\\n         */        \\r\\n        if (_isExcludedFromRewards[sender]){ _balances[sender] = _balances[sender].sub(tAmount); }\\r\\n        if (_isExcludedFromRewards[recipient] ){ _balances[recipient] = _balances[recipient].add(tTransferAmount); }\\r\\n        \\r\\n         tokenFromReflection(_reflectedBalances[sender]) \\u003e= capWhaleWalletBalance;\\r\\n        \\r\\n        _takeFees( amount, currentRate, sumOfFees, isWhale, multiplier);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _takeFees(uint256 amount, uint256 currentRate, uint256 sumOfFees, bool isWhale, uint multiplier ) private {\\r\\n        if ( sumOfFees \\u003e 0 \\u0026\\u0026 !isInPresale ){\\r\\n            _takeTransactionFees(amount, currentRate, isWhale, multiplier);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getValues(uint256 tAmount, uint256 feesSum) internal view returns (uint256, uint256, uint256, uint256, uint256) {\\r\\n        \\r\\n        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\\r\\n        uint256 tTransferAmount = tAmount.sub(tTotalFees);\\r\\n        uint256 currentRate = _getCurrentRate();\\r\\n        uint256 rAmount = tAmount.mul(currentRate);\\r\\n        uint256 rTotalFees = tTotalFees.mul(currentRate);\\r\\n        uint256 rTransferAmount = rAmount.sub(rTotalFees);\\r\\n        \\r\\n        return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\\r\\n    }\\r\\n    \\r\\n    function _getCurrentRate() internal view returns(uint256) {\\r\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n        return rSupply.div(tSupply);\\r\\n    }\\r\\n    \\r\\n    function _getCurrentSupply() internal view returns(uint256, uint256) {\\r\\n        uint256 rSupply = _reflectedSupply;\\r\\n        uint256 tSupply = TOTAL_SUPPLY;  \\r\\n\\r\\n        /**\\r\\n         * The code below removes balances of addresses excluded from rewards from\\r\\n         * rSupply and tSupply, which effectively increases the % of transaction fees\\r\\n         * delivered to non-excluded holders\\r\\n         */    \\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_reflectedBalances[_excluded[i]] \\u003e rSupply || _balances[_excluded[i]] \\u003e tSupply) return (_reflectedSupply, TOTAL_SUPPLY);\\r\\n            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\\r\\n            tSupply = tSupply.sub(_balances[_excluded[i]]);\\r\\n        }\\r\\n        if (tSupply == 0 || rSupply \\u003c _reflectedSupply.div(TOTAL_SUPPLY)) return (_reflectedSupply, TOTAL_SUPPLY);\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens.\\r\\n     */\\r\\n    function _beforeTokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the total sum of fees to be processed in each transaction. \\r\\n     * \\r\\n     * To separate concerns this contract (class) will take care of ONLY handling RFI, i.e. \\r\\n     * changing the rates and updating the holder\\u0027s balance (via `_redistribute`). \\r\\n     * It is the responsibility of the dev/user to handle all other fees and taxes \\r\\n     * in the appropriate contracts (classes).\\r\\n     */ \\r\\n    function _getSumOfFees(address sender, uint256 amount) internal view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev A delegate which should return true if the given address is the V2 Pair and false otherwise\\r\\n     */\\r\\n    function _isV2Pair(address account) internal view virtual returns(bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Redistributes the specified amount among the current holders via the reflect.finance\\r\\n     * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\\r\\n     * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`. \\r\\n     * This is the bit of clever math which allows rfi to redistribute the fee without \\r\\n     * having to iterate through all holders. \\r\\n     * \\r\\n     * Visit our discord at https://discord.gg/dAmr6eUTpM\\r\\n     */\\r\\n    function _redistribute(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) internal {\\r\\n        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rFee = tFee.mul(currentRate);\\r\\n\\r\\n        _reflectedSupply = _reflectedSupply.sub(rFee);\\r\\n        _addFeeCollectedAmount(index, tFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted if fees are enabled for the transfer\\r\\n     */\\r\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate, bool isWhale, uint multiplier) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _getLastTransaction(address sender) internal view virtual returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _setLastTransaction(address sender) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _getLastBlock(address sender) internal view virtual returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _setLastBlock(address sender) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _multiplier() internal  view virtual returns (uint);\\r\\n}\\r\\n\\r\\nabstract contract Liquifier is Ownable, Manageable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 private withdrawableBalance;\\r\\n\\r\\n    enum Env {Testnet, MainnetV1, MainnetV2}\\r\\n    Env private _env;\\r\\n\\r\\n    // PancakeSwap V1\\r\\n    address private _mainnetRouterV1Address = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\\r\\n    // PancakeSwap V2\\r\\n    address private _mainnetRouterV2Address = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    // Testnet\\r\\n    // address private _testnetRouterAddress = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\r\\n    // PancakeSwap Testnet = https://pancake.kiemtienonline360.com/\\r\\n    address private _testnetRouterAddress = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\\r\\n\\r\\n    IPancakeV2Router internal _router;\\r\\n    address internal _pair;\\r\\n    \\r\\n    bool private inSwapAndLiquify;\\r\\n    bool private swapAndLiquifyEnabled = true;\\r\\n\\r\\n    uint256 private maxTransactionAmount;\\r\\n    uint256 private numberOfTokensToSwapToLiquidity;\\r\\n\\r\\n    modifier lockTheSwap {\\r\\n        inSwapAndLiquify = true;\\r\\n        _;\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n\\r\\n    event RouterSet(address indexed router);\\r\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\\r\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\r\\n    event LiquidityAdded(uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity);\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function initializeLiquiditySwapper(Env env, uint256 maxTx, uint256 liquifyAmount) internal {\\r\\n        _env = env;\\r\\n        if (_env == Env.MainnetV1){ _setRouterAddress(_mainnetRouterV1Address); }\\r\\n        else if (_env == Env.MainnetV2){ _setRouterAddress(_mainnetRouterV2Address); }\\r\\n        else /*(_env == Env.Testnet)*/{ _setRouterAddress(_testnetRouterAddress); }\\r\\n\\r\\n        maxTransactionAmount = maxTx;\\r\\n        numberOfTokensToSwapToLiquidity = liquifyAmount;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * NOTE: passing the `contractTokenBalance` here is preferred to creating `balanceOfDelegate`\\r\\n     */\\r\\n    function liquify(uint256 contractTokenBalance, address sender) internal {\\r\\n\\r\\n        if (contractTokenBalance \\u003e= maxTransactionAmount) contractTokenBalance = maxTransactionAmount;\\r\\n        \\r\\n        bool isOverRequiredTokenBalance = ( contractTokenBalance \\u003e= numberOfTokensToSwapToLiquidity );\\r\\n        \\r\\n        /**\\r\\n         * - first check if the contract has collected enough tokens to swap and liquify\\r\\n         * - then check swap and liquify is enabled\\r\\n         * - then make sure not to get caught in a circular liquidity event\\r\\n         * - finally, don\\u0027t swap \\u0026 liquify if the sender is the uniswap pair\\r\\n         */\\r\\n        if ( isOverRequiredTokenBalance \\u0026\\u0026 swapAndLiquifyEnabled \\u0026\\u0026 !inSwapAndLiquify \\u0026\\u0026 (sender != _pair) ){\\r\\n            // TODO check if the `(sender != _pair)` is necessary because that basically\\r\\n            // stops swap and liquify for all \\\"buy\\\" transactions\\r\\n            _swapAndLiquify(contractTokenBalance);            \\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets the router address and created the router, factory pair to enable\\r\\n     * swapping and liquifying (contract) tokens\\r\\n     */\\r\\n    function _setRouterAddress(address router) private {\\r\\n        IPancakeV2Router _newPancakeRouter = IPancakeV2Router(router);\\r\\n        _pair = IPancakeV2Factory(_newPancakeRouter.factory()).createPair(address(this), _newPancakeRouter.WETH());\\r\\n        _router = _newPancakeRouter;\\r\\n        emit RouterSet(router);\\r\\n    }\\r\\n    \\r\\n    function _swapAndLiquify(uint256 amount) private lockTheSwap {\\r\\n        \\r\\n        // split the contract balance into halves\\r\\n        uint256 half = amount.div(2);\\r\\n        uint256 otherHalf = amount.sub(half);\\r\\n        \\r\\n        // capture the contract\\u0027s current ETH balance.\\r\\n        // this is so that we can capture exactly the amount of ETH that the\\r\\n        // swap creates, and not make the liquidity event include any ETH that\\r\\n        // has been manually sent to the contract\\r\\n        uint256 initialBalance = address(this).balance;\\r\\n        \\r\\n        // swap tokens for ETH\\r\\n        _swapTokensForEth(half); // \\u003c- this breaks the ETH -\\u003e HATE swap when swap+liquify is triggered\\r\\n\\r\\n        // how much ETH did we just swap into?\\r\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\r\\n\\r\\n        // add liquidity to uniswap\\r\\n        _addLiquidity(otherHalf, newBalance);\\r\\n        \\r\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\r\\n    }\\r\\n    \\r\\n    function _swapTokensForEth(uint256 tokenAmount) private {\\r\\n        \\r\\n        // generate the uniswap pair path of token -\\u003e weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _router.WETH();\\r\\n\\r\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            // The minimum amount of output tokens that must be received for the transaction not to revert.\\r\\n            // 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        (uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity) = _router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            // Bounds the extent to which the WETH/token price can go up before the transaction reverts. \\r\\n            // Must be \\u003c= amountTokenDesired; 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            // Bounds the extent to which the token/WETH price can go up before the transaction reverts.\\r\\n            // 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            // this is a centralized risk if the owner\\u0027s account is ever compromised (see Certik SSL-04)\\r\\n            owner(),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        // fix the forever locked BNBs as per the certik\\u0027s audit\\r\\n        /**\\r\\n         * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB. \\r\\n         * For every swapAndLiquify function call, a small amount of BNB remains in the contract. \\r\\n         * This amount grows over time with the swapAndLiquify function being called throughout the life \\r\\n         * of the contract. The Safemoon contract does not contain a method to withdraw these funds, \\r\\n         * and the BNB will be locked in the Safemoon contract forever.\\r\\n         */\\r\\n        withdrawableBalance = address(this).balance;\\r\\n        emit LiquidityAdded(tokenAmountSent, ethAmountSent, liquidity);\\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n    * @dev Sets the uniswapV2 pair (router \\u0026 factory) for swapping and liquifying tokens\\r\\n    */\\r\\n    function setRouterAddress(address router) external onlyManager() {\\r\\n        _setRouterAddress(router);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sends the swap and liquify flag to the provided value. If set to `false` tokens collected in the contract will\\r\\n     * NOT be converted into liquidity.\\r\\n     */\\r\\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyManager {\\r\\n        swapAndLiquifyEnabled = enabled;\\r\\n        emit SwapAndLiquifyEnabledUpdated(swapAndLiquifyEnabled);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The owner can withdraw ETH(BNB) collected in the contract from `swapAndLiquify`\\r\\n     * or if someone (accidentally) sends ETH/BNB directly to the contract.\\r\\n     *\\r\\n     * Note: This addresses the contract flaw pointed out in the Certik Audit of Safemoon (SSL-03):\\r\\n     * \\r\\n     * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB. \\r\\n     * For every swapAndLiquify function call, a small amount of BNB remains in the contract. \\r\\n     * This amount grows over time with the swapAndLiquify function being called \\r\\n     * throughout the life of the contract. The Safemoon contract does not contain a method \\r\\n     * to withdraw these funds, and the BNB will be locked in the Safemoon contract forever.\\r\\n     * https://www.certik.org/projects/safemoon\\r\\n     */\\r\\n    function withdrawLockedEth(address payable recipient) external onlyManager(){\\r\\n        require(recipient != address(0), \\\"Cannot withdraw the ETH balance to the zero address\\\");\\r\\n        require(withdrawableBalance \\u003e 0, \\\"The ETH balance must be greater than 0\\\");\\r\\n\\r\\n        // prevent re-entrancy attacks\\r\\n        uint256 amount = withdrawableBalance;\\r\\n        withdrawableBalance = 0;\\r\\n        recipient.transfer(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Use this delegate instead of having (unnecessarily) extend `BaseRfiToken` to gained access \\r\\n     * to the `_approve` function.\\r\\n     */\\r\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal virtual;\\r\\n\\r\\n}\\r\\n\\r\\n//////////////////////////////////////////////////////////////////////////\\r\\nabstract contract Antiwhale is Tokenomics {\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total sum of fees (in percents / per-mille - this depends on the FEES_DIVISOR value)\\r\\n     *\\r\\n     * NOTE: Currently this is just a placeholder. The parameters passed to this function are the\\r\\n     *      sender\\u0027s token balance and the transfer amount. An *antiwhale* mechanics can use these \\r\\n     *      values to adjust the fees total for each tx\\r\\n     */\\r\\n    // function _getAntiwhaleFees(uint256 sendersBalance, uint256 amount) internal view returns (uint256){\\r\\n    function _getAntiwhaleFees(uint256, uint256) internal view returns (uint256){\\r\\n        return sumOfFees;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract AntiBot is Tokenomics {\\r\\n    mapping (address =\\u003e uint) internal _lastTransaction;\\r\\n    mapping (address =\\u003e uint) internal _LastBlock;\\r\\n    /**\\r\\n     * @dev Returns the total sum of fees (in percents / per-mille - this depends on the FEES_DIVISOR value)\\r\\n     *\\r\\n     * NOTE: Currently this is just a placeholder. The parameters passed to this function are the\\r\\n     *      sender\\u0027s token balance and the transfer amount. An *antiwhale* mechanics can use these \\r\\n     *      values to adjust the fees total for each tx\\r\\n     */\\r\\n}\\r\\n\\r\\nabstract contract AntiDump is Tokenomics{\\r\\n    \\r\\n    function _getMultiplier() internal view returns (uint) {\\r\\n        uint multiplier = 1;\\r\\n        if(ANTI_DUMP_MULTIPLAYER == true){\\r\\n            if( block.timestamp \\u003c TimeContractStart + 24 * 1 hours)\\r\\n            {\\r\\n                multiplier = 2;\\r\\n            }\\r\\n        }\\r\\n        return multiplier;\\r\\n    }\\r\\n    \\r\\n}\\r\\n//////////////////////////////////////////////////////////////////////////\\r\\n\\r\\nabstract contract SafeToken is BaseRfiToken, Liquifier, Antiwhale, AntiBot, AntiDump {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // constructor(string memory _name, string memory _symbol, uint8 _decimals){\\r\\n    constructor(Env _env){\\r\\n\\r\\n        initializeLiquiditySwapper(_env, maxTransactionAmount, numberOfTokensToSwapToLiquidity);\\r\\n\\r\\n        // exclude the pair address from rewards - we don\\u0027t want to redistribute\\r\\n        // tx fees to these two; redistribution is only for holders, dah!\\r\\n        _exclude(_pair);\\r\\n        _exclude(burnAddress);\\r\\n    }\\r\\n    \\r\\n    function _isV2Pair(address account) internal view override returns(bool){\\r\\n        return (account == _pair);\\r\\n    }\\r\\n\\r\\n    function _getSumOfFees(address sender, uint256 amount) internal view override returns (uint256){ \\r\\n        return _getAntiwhaleFees(balanceOf(sender), amount); \\r\\n    }\\r\\n    \\r\\n    function _getLastTransaction(address sender) internal view override returns (uint256) {\\r\\n        return _lastTransaction[sender];\\r\\n    }\\r\\n    \\r\\n    function _setLastTransaction(address sender) internal override {\\r\\n        //_setLastTransaction(sender,block.timestamp + TIME_LIMIT_TRANSACTION);\\r\\n        _lastTransaction[sender] = block.timestamp + TIME_LIMIT_TRANSACTION;\\r\\n    }\\r\\n    \\r\\n    function _getLastBlock(address sender) internal view override returns (uint256) {\\r\\n        return _LastBlock[sender];\\r\\n    }\\r\\n    \\r\\n    function _setLastBlock(address sender) internal override {\\r\\n        _LastBlock[sender] = block.number;\\r\\n    }\\r\\n    \\r\\n    function _multiplier() internal  view override returns (uint multiplier){\\r\\n        return _getMultiplier();\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // function _beforeTokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) internal override {\\r\\n    function _beforeTokenTransfer(address sender, address , uint256 , bool ) internal override {\\r\\n        if ( !isInPresale ){\\r\\n            uint256 contractTokenBalance = balanceOf(address(this));\\r\\n            liquify( contractTokenBalance, sender );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate, bool isWhale, uint multiplier) internal override {\\r\\n        \\r\\n        if( isInPresale ){ return; }\\r\\n\\r\\n        uint256 feesCount = _getFeesCount();\\r\\n        for (uint256 index = 0; index \\u003c feesCount; index++ ){\\r\\n            (FeeType name, uint256 value, address recipient,) = _getFee(index);\\r\\n            // no need to check value \\u003c 0 as the value is uint (i.e. from 0 to 2^256-1)\\r\\n            if ( value == 0 ) continue;\\r\\n\\r\\n            if ( name == FeeType.Rfi ){\\r\\n                _redistribute( amount.mul(multiplier), currentRate, value, index );\\r\\n            }\\r\\n            else if ( name == FeeType.Burn ){\\r\\n                _burn( amount.mul(multiplier), currentRate, value, index );\\r\\n            }\\r\\n            else if ( name == FeeType.Antiwhale){\\r\\n                if(isWhale)\\r\\n                {\\r\\n                    _takeFeeToETH( amount.mul(multiplier), currentRate, value, recipient, index );\\r\\n                }\\r\\n            }\\r\\n            else if ( name == FeeType.ExternalToETH){\\r\\n                _takeFeeToETH( amount.mul(multiplier), currentRate, value, recipient, index );\\r\\n            }\\r\\n            else {\\r\\n                _takeFee( amount.mul(multiplier), currentRate, value, recipient, index );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _burn(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) private {\\r\\n        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rBurn = tBurn.mul(currentRate);\\r\\n\\r\\n        _burnTokens(address(this), tBurn, rBurn);\\r\\n        _addFeeCollectedAmount(index, tBurn);\\r\\n    }\\r\\n\\r\\n    function _takeFee(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\r\\n\\r\\n        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rAmount = tAmount.mul(currentRate);\\r\\n\\r\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\\r\\n        if(_isExcludedFromRewards[recipient])\\r\\n            _balances[recipient] = _balances[recipient].add(tAmount);\\r\\n\\r\\n        _addFeeCollectedAmount(index, tAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev When implemented this will convert the fee amount of tokens into ETH/BNB\\r\\n     * and send to the recipient\\u0027s wallet. Note that this reduces liquidity so it \\r\\n     * might be a good idea to add a % into the liquidity fee for % you take our through\\r\\n     * this method (just a suggestions)\\r\\n     */\\r\\n    function _takeFeeToETH(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\r\\n        _takeFee(amount, currentRate, fee, recipient, index);        \\r\\n    }\\r\\n\\r\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal override {\\r\\n        _approve(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract SafeTokenV1Beta is SafeToken{\\r\\n\\r\\n    constructor() SafeToken(Env.MainnetV2) {\\r\\n        // pre-approve the initial liquidity supply (to safe a bit of time)\\r\\n        _approve(owner(),address(_router), ~uint256(0));\\r\\n    }\\r\\n}\\r\\n \\r\\n// MASTER CHEF Testne\\r\\ncontract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract MasterChef is Ownable, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    // Info of each user.\\r\\n    struct UserInfo {\\r\\n        uint256 amount;         // How many LP tokens the user has provided.\\r\\n        uint256 rewardDebt;     // Reward debt. See explanation below.\\r\\n    }\\r\\n\\r\\n    // Info of each pool.\\r\\n    struct PoolInfo {\\r\\n        IERC20 lpToken;           // Address of LP token contract.\\r\\n        uint256 allocPoint;       // How many allocation points assigned to this pool. GWSPP to distribute per block.\\r\\n        uint256 lastRewardBlock;  // Last block number that GWSPP distribution occurs.\\r\\n        uint256 accGwsppPerShare;   // Accumulated GWSPP per share, times 1e12. See below.\\r\\n    }\\r\\n\\r\\n    SafeTokenV1Beta public gwspp;\\r\\n    address public devaddr;\\r\\n    uint256 public gwsppPerBlock;\\r\\n    uint256 public constant BONUS_MULTIPLIER = 1;\\r\\n\\r\\n    PoolInfo[] public poolInfo;\\r\\n    mapping(uint256 =\\u003e mapping(address =\\u003e UserInfo)) public userInfo;\\r\\n    uint256 public totalAllocPoint = 0;\\r\\n    uint256 public startBlock;\\r\\n\\r\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n    event SetDevAddress(address indexed user, address indexed newAddress);\\r\\n    event UpdateEmissionRate(address indexed user, uint256 gwsppPerBlock);\\r\\n\\r\\n    constructor(\\r\\n        SafeTokenV1Beta _gwspp,\\r\\n        address _devaddr,\\r\\n        uint256 _gwsppPerBlock,\\r\\n        uint256 _startBlock\\r\\n    ) public {\\r\\n        gwspp = _gwspp;\\r\\n        devaddr = _devaddr;\\r\\n        gwsppPerBlock = _gwsppPerBlock;\\r\\n        startBlock = _startBlock;\\r\\n    }\\r\\n\\r\\n    function poolLength() external view returns (uint256) {\\r\\n        return poolInfo.length;\\r\\n    }\\r\\n\\r\\n    mapping(IERC20 =\\u003e bool) public poolExistence;\\r\\n    modifier nonDuplicated(IERC20 _lpToken) {\\r\\n        require(poolExistence[_lpToken] == false, \\\"nonDuplicated: duplicated\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier poolExists(uint256 pid) {\\r\\n        require(pid \\u003c poolInfo.length, \\\"pool inexistent\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Add a new lp to the pool. Can only be called by the owner.\\r\\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner nonDuplicated(_lpToken) {\\r\\n        if (_withUpdate) {\\r\\n            massUpdatePools();\\r\\n        }\\r\\n        uint256 lastRewardBlock = block.number \\u003e startBlock ? block.number : startBlock;\\r\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\r\\n        poolExistence[_lpToken] = true;\\r\\n        poolInfo.push(PoolInfo({\\r\\n        lpToken : _lpToken,\\r\\n        allocPoint : _allocPoint,\\r\\n        lastRewardBlock : lastRewardBlock,\\r\\n        accGwsppPerShare : 0\\r\\n        }));\\r\\n    }\\r\\n\\r\\n    // Update the given pool\\u0027s GWSPP allocation point and deposit fee. Can only be called by the owner.\\r\\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner poolExists(_pid) {\\r\\n        if (_withUpdate) {\\r\\n            massUpdatePools();\\r\\n        }\\r\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\r\\n        poolInfo[_pid].allocPoint = _allocPoint;\\r\\n    }\\r\\n\\r\\n    // Return reward multiplier over the given _from to _to block.\\r\\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\\r\\n        return _to.sub(_from).mul(BONUS_MULTIPLIER);\\r\\n    }\\r\\n\\r\\n    // View function to see pending GWSPPs on frontend.\\r\\n    function pendingGwspp(uint256 _pid, address _user) external view returns (uint256) {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][_user];\\r\\n        uint256 accGwsppPerShare = pool.accGwsppPerShare;\\r\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\r\\n        if (block.number \\u003e pool.lastRewardBlock \\u0026\\u0026 lpSupply != 0) {\\r\\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\r\\n            uint256 gwsppReward = multiplier.mul(gwsppPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\r\\n            accGwsppPerShare = accGwsppPerShare.add(gwsppReward.mul(1e12).div(lpSupply));\\r\\n        }\\r\\n        return user.amount.mul(accGwsppPerShare).div(1e12).sub(user.rewardDebt);\\r\\n    }\\r\\n\\r\\n    // Update reward variables for all pools. Be careful of gas spending!\\r\\n    function massUpdatePools() public {\\r\\n        uint256 length = poolInfo.length;\\r\\n        for (uint256 pid = 0; pid \\u003c length; ++pid) {\\r\\n            updatePool(pid);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Update reward variables of the given pool to be up-to-date.\\r\\n    function updatePool(uint256 _pid) public {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        if (block.number \\u003c= pool.lastRewardBlock) {\\r\\n            return;\\r\\n        }\\r\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\r\\n        if (lpSupply == 0 || pool.allocPoint == 0) {\\r\\n            pool.lastRewardBlock = block.number;\\r\\n            return;\\r\\n        }\\r\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\r\\n        uint256 gwsppReward = multiplier.mul(gwsppPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\r\\n        pool.accGwsppPerShare = pool.accGwsppPerShare.add(gwsppReward.mul(1e12).div(lpSupply));\\r\\n        pool.lastRewardBlock = block.number;\\r\\n    }\\r\\n\\r\\n    // Deposit LP tokens to MasterChef for GWSPP allocation.\\r\\n    function deposit(uint256 _pid, uint256 _amount) public nonReentrant poolExists(_pid) {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        updatePool(_pid);\\r\\n        if (user.amount \\u003e 0) {\\r\\n            uint256 pending = user.amount.mul(pool.accGwsppPerShare).div(1e12).sub(user.rewardDebt);\\r\\n            if (pending \\u003e 0) {\\r\\n                safeGwsppTransfer(msg.sender, pending);\\r\\n            }\\r\\n        }\\r\\n        if (_amount \\u003e 0) {\\r\\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\r\\n            user.amount = user.amount.add(_amount);\\r\\n        }\\r\\n        user.rewardDebt = user.amount.mul(pool.accGwsppPerShare).div(1e12);\\r\\n        emit Deposit(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    // Withdraw LP tokens from MasterChef.\\r\\n    function withdraw(uint256 _pid, uint256 _amount) public nonReentrant poolExists(_pid) {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        require(user.amount \\u003e= _amount, \\\"withdraw: not good\\\");\\r\\n        updatePool(_pid);\\r\\n        uint256 pending = user.amount.mul(pool.accGwsppPerShare).div(1e12).sub(user.rewardDebt);\\r\\n        if (pending \\u003e 0) {\\r\\n            safeGwsppTransfer(msg.sender, pending);\\r\\n        }\\r\\n        if (_amount \\u003e 0) {\\r\\n            user.amount = user.amount.sub(_amount);\\r\\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\\r\\n        }\\r\\n        user.rewardDebt = user.amount.mul(pool.accGwsppPerShare).div(1e12);\\r\\n        emit Withdraw(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\r\\n    function emergencyWithdraw(uint256 _pid) public nonReentrant poolExists(_pid) {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        uint256 amount = user.amount;\\r\\n        user.amount = 0;\\r\\n        user.rewardDebt = 0;\\r\\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\\r\\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\\r\\n    }\\r\\n\\r\\n    // Safe GWSPP transfer function, just in case if rounding error causes pool to not have enough GWSPPs.\\r\\n    function safeGwsppTransfer(address _to, uint256 _amount) internal {\\r\\n        uint256 gwsppBal = gwspp.balanceOf(address(this));\\r\\n        bool transferSuccess = false;\\r\\n        if (_amount \\u003e gwsppBal) {\\r\\n            transferSuccess = gwspp.transfer(_to, gwsppBal);\\r\\n        } else {\\r\\n            transferSuccess = gwspp.transfer(_to, _amount);\\r\\n        }\\r\\n        require(transferSuccess, \\\"safeGwsppTransfer: transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    // Update dev address by the previous dev.\\r\\n    function dev(address _devaddr) public {\\r\\n        require(msg.sender == devaddr, \\\"dev: wat?\\\");\\r\\n        devaddr = _devaddr;\\r\\n        emit SetDevAddress(msg.sender, _devaddr);\\r\\n    }\\r\\n}\"},\"safetoken-imports.sol\":{\"content\":\"/**\\r\\n * SPDX-License-Identifier: MIT\\r\\n */ \\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\\r\\n}\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked { require(b \\u003c= a, errorMessage); return a - b; }\\r\\n    }\\r\\n}\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size \\u003e 0;}\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {return functionCall(target, data, \\\"Address: low-level call failed\\\");}\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return functionCallWithValue(target, data, 0, errorMessage);}\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");}\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) { return returndata; } else {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {revert(errorMessage);}\\r\\n        }\\r\\n    }\\r\\n}\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n    address private _previousOwner;\\r\\n    uint256 private _lockTime;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    function getUnlockTime() public view returns (uint256) {\\r\\n        return _lockTime;\\r\\n    }\\r\\n    function lock(uint256 time) public virtual onlyOwner {\\r\\n        _previousOwner = _owner;\\r\\n        _owner = address(0);\\r\\n        _lockTime = block.timestamp + time;\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n    }\\r\\n    function unlock() public virtual {\\r\\n        require(_previousOwner == msg.sender, \\\"Only the previous owner can unlock onwership\\\");\\r\\n        require(block.timestamp \\u003e _lockTime , \\\"The contract is still locked\\\");\\r\\n        emit OwnershipTransferred(_owner, _previousOwner);\\r\\n        _owner = _previousOwner;\\r\\n    }\\r\\n}\\r\\nabstract contract Manageable is Context {\\r\\n    address private _manager;\\r\\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\\r\\n    constructor(){\\r\\n        address msgSender = _msgSender();\\r\\n        _manager = msgSender;\\r\\n        emit ManagementTransferred(address(0), msgSender);\\r\\n    }\\r\\n    function manager() public view returns(address){ return _manager; }\\r\\n    modifier onlyManager(){\\r\\n        require(_manager == _msgSender(), \\\"Manageable: caller is not the manager\\\");\\r\\n        _;\\r\\n    }\\r\\n    function transferManagement(address newManager) external virtual onlyManager {\\r\\n        emit ManagementTransferred(_manager, newManager);\\r\\n        _manager = newManager;\\r\\n    }\\r\\n}\\r\\ninterface IPancakeV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\ninterface IPancakeV2Router {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n        \\r\\n        \\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract SafeTokenV1Beta\",\"name\":\"_gwspp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gwsppPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"SetDevAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gwsppPerBlock\",\"type\":\"uint256\"}],\"name\":\"UpdateEmissionRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devaddr\",\"type\":\"address\"}],\"name\":\"dev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devaddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gwspp\",\"outputs\":[{\"internalType\":\"contract SafeTokenV1Beta\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gwsppPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingGwspp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolExistence\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accGwsppPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MasterChef", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cccbf2248ef3bd8d475ea5de8cb06e19f4591a8e000000000000000000000000c55a7183f6d060271010a4441c106f6a81d46e34000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000008bf038", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://332869aa510b5a6f97db27491a95a1a4f46c74b241bc4fa12c1a09f1e41d4891"}