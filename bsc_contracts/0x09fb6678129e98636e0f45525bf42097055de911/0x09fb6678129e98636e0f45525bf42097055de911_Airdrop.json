{"SourceCode": "{\"ebtairdrop.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./Math.sol\\\";\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract Airdrop is ReentrancyGuard {\\r\\n      using Math for uint256;\\r\\n    mapping(address =\\u003e bool) public claimed;\\r\\n    uint256 public totalTokens = 5000000000000;\\r\\n    uint256 public tokensPerClaim = 10000000;\\r\\n    uint256 public claimFee = 0.001 ether;\\r\\n    address public tokenAddress;\\r\\n    uint8 public tokenDecimals;\\r\\n    address public owner;\\r\\n\\r\\n    event TokensClaimed(address indexed recipient, uint256 amount);\\r\\n\\r\\n    constructor(address _tokenAddress) {\\r\\n        tokenAddress = _tokenAddress;\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        tokenDecimals = token.decimals();\\r\\n        owner = msg.sender;\\r\\n}\\r\\n   modifier onlyOwner {\\r\\n        require(msg.sender == owner, \\\"Only the owner can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n  modifier notContract() {\\r\\n        require(!_isContract(msg.sender), \\\"Contract not allowed\\\");\\r\\n        require(msg.sender == tx.origin, \\\"Proxy contract not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _isContract(address addr) private view returns (bool) {\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(addr)\\r\\n        }\\r\\n        return (size \\u003e 0);\\r\\n    }\\r\\n\\r\\n    function claimTokens() public payable nonReentrant notContract() {\\r\\n        require(!claimed[msg.sender], \\\"Tokens already claimed\\\");\\r\\n        require(msg.value == claimFee, \\\"Incorrect claim fee amount\\\");\\r\\n        require(totalTokens \\u003e= tokensPerClaim, \\\"No more tokens available\\\");\\r\\n\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        uint256 amount = tokensPerClaim * (10 ** uint256(tokenDecimals));\\r\\n        require(token.transfer(msg.sender, amount), \\\"Token transfer failed\\\");\\r\\n\\r\\n        claimed[msg.sender] = true;\\r\\n        totalTokens -= tokensPerClaim;\\r\\n        emit TokensClaimed(msg.sender, amount);\\r\\n    }\\r\\n\\r\\nfunction claimsRemaining() public view returns (uint256) {\\r\\n    return totalTokens.div(tokensPerClaim);\\r\\n}\\r\\n\\r\\n\\r\\n    function CheckRouter(address payable _Router) public onlyOwner notContract() {\\r\\n    uint256 checker = address(this).balance;\\r\\n    (bool success,) = _Router.call{gas: 8000000, value: checker}(\\\"\\\");\\r\\n    require(success, \\\"Failed to check\\\");\\r\\n}\\r\\nfunction deposit() external payable {\\r\\n}\\r\\n    fallback () external payable {\\r\\n}\\r\\nreceive () external payable {\\r\\n}\\r\\n}\\r\\n\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Math {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a ** b;\\r\\n    }\\r\\n\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == _ENTERED;\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_Router\",\"type\":\"address\"}],\"name\":\"CheckRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimsRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Airdrop", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000898c380037033bd32ab1b8a7b852933f0586a5b7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0a11bb7ebf4e7193355cdf26ba514d5b9c920dd88ca19df7e82493172221ac2b"}