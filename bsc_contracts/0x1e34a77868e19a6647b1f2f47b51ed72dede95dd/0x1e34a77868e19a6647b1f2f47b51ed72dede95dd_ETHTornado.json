{"SourceCode": "// File: contracts/MerkleTreeWithHistory.sol\r\n\r\n// https://tornado.cash\r\n/*\r\n * d888888P                                           dP              a88888b.                   dP\r\n *    88                                              88             d8'   `88                   88\r\n *    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n *    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n *    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n *    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n * ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\ninterface IHasher {\r\n  function MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR);\r\n}\r\n\r\ncontract MerkleTreeWithHistory {\r\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\r\n\r\n  IHasher public immutable hasher;\r\n  uint32 public immutable levels;\r\n\r\n  // the following variables are made public for easier testing and debugging and\r\n  // are not supposed to be accessed in regular code\r\n\r\n  // filledSubtrees, zeros, and roots could be bytes32[size], but using mappings makes it cheaper because\r\n  // it removes index range check on every interaction\r\n  mapping(uint256 => bytes32) public filledSubtrees;\r\n  mapping(uint256 => bytes32) public zeros;\r\n  mapping(uint256 => bytes32) public roots;\r\n  uint32 public constant ROOT_HISTORY_SIZE = 30;\r\n  uint32 public currentRootIndex = 0;\r\n  uint32 public nextIndex = 0;\r\n\r\n  constructor(uint32 _levels, IHasher _hasher) {\r\n    require(_levels > 0, \"_levels should be greater than zero\");\r\n    require(_levels < 32, \"_levels should be less than 32\");\r\n    levels = _levels;\r\n    hasher = _hasher;\r\n\r\n    bytes32 currentZero = bytes32(ZERO_VALUE);\r\n    for (uint32 i = 0; i < _levels; i++) {\r\n      zeros[i] = currentZero;\r\n      filledSubtrees[i] = currentZero;\r\n      currentZero = hashLeftRight(_hasher, currentZero, currentZero);\r\n    }\r\n\r\n    roots[0] = currentZero;\r\n  }\r\n\r\n  /**\r\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\r\n  */\r\n  function hashLeftRight(\r\n    IHasher _hasher,\r\n    bytes32 _left,\r\n    bytes32 _right\r\n  ) public pure returns (bytes32) {\r\n    require(uint256(_left) < FIELD_SIZE, \"_left should be inside the field\");\r\n    require(uint256(_right) < FIELD_SIZE, \"_right should be inside the field\");\r\n    uint256 R = uint256(_left);\r\n    uint256 C = 0;\r\n    (R, C) = _hasher.MiMCSponge(R, C);\r\n    R = addmod(R, uint256(_right), FIELD_SIZE);\r\n    (R, C) = _hasher.MiMCSponge(R, C);\r\n    return bytes32(R);\r\n  }\r\n\r\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\r\n    uint32 _nextIndex = nextIndex;\r\n    require(_nextIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\r\n    uint32 currentIndex = _nextIndex;\r\n    bytes32 currentLevelHash = _leaf;\r\n    bytes32 left;\r\n    bytes32 right;\r\n\r\n    for (uint32 i = 0; i < levels; i++) {\r\n      if (currentIndex % 2 == 0) {\r\n        left = currentLevelHash;\r\n        right = zeros[i];\r\n        filledSubtrees[i] = currentLevelHash;\r\n      } else {\r\n        left = filledSubtrees[i];\r\n        right = currentLevelHash;\r\n      }\r\n      currentLevelHash = hashLeftRight(hasher, left, right);\r\n      currentIndex /= 2;\r\n    }\r\n\r\n    uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\r\n    currentRootIndex = newRootIndex;\r\n    roots[newRootIndex] = currentLevelHash;\r\n    nextIndex = _nextIndex + 1;\r\n    return _nextIndex;\r\n  }\r\n\r\n  /**\r\n    @dev Whether the root is present in the root history\r\n  */\r\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\r\n    if (_root == 0) {\r\n      return false;\r\n    }\r\n    uint32 _currentRootIndex = currentRootIndex;\r\n    uint32 i = _currentRootIndex;\r\n    do {\r\n      if (_root == roots[i]) {\r\n        return true;\r\n      }\r\n      if (i == 0) {\r\n        i = ROOT_HISTORY_SIZE;\r\n      }\r\n      i--;\r\n    } while (i != _currentRootIndex);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n    @dev Returns the last root\r\n  */\r\n  function getLastRoot() public view returns (bytes32) {\r\n    return roots[currentRootIndex];\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: contracts/Tornado.sol\r\n\r\n// https://tornado.cash\r\n/*\r\n * d888888P                                           dP              a88888b.                   dP\r\n *    88                                              88             d8'   `88                   88\r\n *    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n *    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n *    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n *    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n * ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n */\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\ninterface IVerifier {\r\n  function verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool);\r\n}\r\n\r\nabstract contract Tornado is MerkleTreeWithHistory, ReentrancyGuard {\r\n  IVerifier public immutable verifier;\r\n  uint256 public immutable denomination;\r\n\r\n  mapping(bytes32 => bool) public nullifierHashes;\r\n  // we store all commitments just to prevent accidental deposits with the same commitment\r\n  mapping(bytes32 => bool) public commitments;\r\n\r\n  event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);\r\n  event Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee);\r\n\r\n  /**\r\n    @dev The constructor\r\n    @param _verifier the address of SNARK verifier for this contract\r\n    @param _hasher the address of MiMC hash contract\r\n    @param _denomination transfer amount for each deposit\r\n    @param _merkleTreeHeight the height of deposits' Merkle Tree\r\n  */\r\n  constructor(\r\n    IVerifier _verifier,\r\n    IHasher _hasher,\r\n    uint256 _denomination,\r\n    uint32 _merkleTreeHeight\r\n  ) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) {\r\n    require(_denomination > 0, \"denomination should be greater than 0\");\r\n    verifier = _verifier;\r\n    denomination = _denomination;\r\n  }\r\n\r\n  /**\r\n    @dev Deposit funds into the contract. The caller must send (for ETH) or approve (for ERC20) value equal to or `denomination` of this instance.\r\n    @param _commitment the note commitment, which is PedersenHash(nullifier + secret)\r\n  */\r\n  function deposit(bytes32 _commitment) external payable nonReentrant {\r\n    require(!commitments[_commitment], \"The commitment has been submitted\");\r\n\r\n    uint32 insertedIndex = _insert(_commitment);\r\n    commitments[_commitment] = true;\r\n    _processDeposit();\r\n\r\n    emit Deposit(_commitment, insertedIndex, block.timestamp);\r\n  }\r\n\r\n  /** @dev this function is defined in a child contract */\r\n  function _processDeposit() internal virtual;\r\n\r\n  /**\r\n    @dev Withdraw a deposit from the contract. `proof` is a zkSNARK proof data, and input is an array of circuit public inputs\r\n    `input` array consists of:\r\n      - merkle root of all deposits in the contract\r\n      - hash of unique deposit nullifier to prevent double spends\r\n      - the recipient of funds\r\n      - optional fee that goes to the transaction sender (usually a relay)\r\n  */\r\n  function withdraw(\r\n    bytes calldata _proof,\r\n    bytes32 _root,\r\n    bytes32 _nullifierHash,\r\n    address payable _recipient,\r\n    address payable _relayer,\r\n    uint256 _fee,\r\n    uint256 _refund\r\n  ) external payable nonReentrant {\r\n    require(_fee <= denomination, \"Fee exceeds transfer value\");\r\n    require(!nullifierHashes[_nullifierHash], \"The note has been already spent\");\r\n    require(isKnownRoot(_root), \"Cannot find your merkle root\"); // Make sure to use a recent one\r\n    require(\r\n      verifier.verifyProof(\r\n        _proof,\r\n        [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _fee, _refund]\r\n      ),\r\n      \"Invalid withdraw proof\"\r\n    );\r\n\r\n    nullifierHashes[_nullifierHash] = true;\r\n    _processWithdraw(_recipient, _relayer, _fee, _refund);\r\n    emit Withdrawal(_recipient, _nullifierHash, _relayer, _fee);\r\n  }\r\n\r\n  /** @dev this function is defined in a child contract */\r\n  function _processWithdraw(\r\n    address payable _recipient,\r\n    address payable _relayer,\r\n    uint256 _fee,\r\n    uint256 _refund\r\n  ) internal virtual;\r\n\r\n  /** @dev whether a note is already spent */\r\n  function isSpent(bytes32 _nullifierHash) public view returns (bool) {\r\n    return nullifierHashes[_nullifierHash];\r\n  }\r\n\r\n  /** @dev whether an array of notes is already spent */\r\n  function isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) {\r\n    spent = new bool[](_nullifierHashes.length);\r\n    for (uint256 i = 0; i < _nullifierHashes.length; i++) {\r\n      if (isSpent(_nullifierHashes[i])) {\r\n        spent[i] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ETHTornado.sol\r\n\r\n// https://tornado.cash\r\n/*\r\n * d888888P                                           dP              a88888b.                   dP\r\n *    88                                              88             d8'   `88                   88\r\n *    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n *    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n *    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n *    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n * ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n */\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\ncontract ETHTornado is Tornado {\r\n  constructor(\r\n    IVerifier _verifier,\r\n    IHasher _hasher,\r\n    uint256 _denomination,\r\n    uint32 _merkleTreeHeight\r\n  ) Tornado(_verifier, _hasher, _denomination, _merkleTreeHeight) {}\r\n\r\n  function _processDeposit() internal override {\r\n    require(msg.value == denomination, \"Please send `mixDenomination` ETH along with transaction\");\r\n  }\r\n\r\n  function _processWithdraw(\r\n    address payable _recipient,\r\n    address payable _relayer,\r\n    uint256 _fee,\r\n    uint256 _refund\r\n  ) internal override {\r\n    // sanity checks\r\n    require(msg.value == 0, \"Message value is supposed to be zero for ETH instance\");\r\n    require(_refund == 0, \"Refund value is supposed to be zero for ETH instance\");\r\n\r\n    (bool success, ) = _recipient.call{ value: denomination - _fee }(\"\");\r\n    require(success, \"payment to _recipient did not go thru\");\r\n    if (_fee > 0) {\r\n      (success, ) = _relayer.call{ value: _fee }(\"\");\r\n      require(success, \"payment to _relayer did not go thru\");\r\n    }\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"contract IHasher\",\"name\":\"_hasher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_denomination\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_merkleTreeHeight\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"leafIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nullifierHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FIELD_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_HISTORY_SIZE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRootIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denomination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"filledSubtrees\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IHasher\",\"name\":\"_hasher\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_left\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_right\",\"type\":\"bytes32\"}],\"name\":\"hashLeftRight\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasher\",\"outputs\":[{\"internalType\":\"contract IHasher\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"isKnownRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_nullifierHashes\",\"type\":\"bytes32[]\"}],\"name\":\"isSpentArray\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"spent\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nullifierHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"zeros\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ETHTornado", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fc9859303c0ac1a7721ece639f2e249d8fd72ac6000000000000000000000000baffbe0e6c73d4dad3f813194695fdc5829c962a0000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000000000000000000014", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8ceda25717bed5d981a763bf8fc532aaf1c7aafa06a512f58b473b522acadc99"}