{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC20/LLAW.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport \\\"../pancakeswap_interface/IPancakeRouter.sol\\\";\\n\\nimport \\\"../pancakeswap_interface/IPancakeFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IStakePool {\\n    function updateReward(uint256 burnAmount) external returns (bool);\\n}\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\ncontract LLAW is Ownable {\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n    event UpdateReward(uint256 updateAmount, uint256 updateTime);\\n    string public name;\\n\\n    string public symbol;\\n    uint8 public immutable decimals;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n    mapping(address => uint256) public nonces;\\n    address public DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\n    address public pairAddress;\\n    address public stakingPoolAddress;\\n\\n    address private whitelistAddress;\\n    address private liquidityAddress;\\n    address private devAddress;\\n    address private operatorAddress;\\n    address private airdropLockAddress;\\n    address private superNodeAddress;\\n    address private mainNodeAddress;\\n    address private richNodeAddress;\\n    mapping(address => bool) public feeWhitelist;\\n    mapping(address => address) public inviter; //user=> inviter\\n    uint256 public destroyAmount;\\n    uint256 public startTime;\\n    uint256 public dayDestroyAmount;\\n    uint256 public totalDestroyAmount;\\n\\n    constructor(\\n        address _stakingPoolAddress,\\n        address _whitelistAddress,\\n        address _liquidityAddress,\\n        address _devAddress,\\n        address _operatorAddress,\\n        address _airdropLockAddress,\\n        address _superNodeAddress,\\n        address _mainNodeAddress,\\n        address _richNodeAddress\\n    ) {\\n        name = \\\"LIVING LAW DAO\\\";\\n        symbol = \\\"LLAWDAO\\\";\\n        decimals = 18;\\n\\n        _mint(_stakingPoolAddress, 2000_0000 ether);\\n        _mint(_whitelistAddress, 20_0000 ether);\\n        _mint(_liquidityAddress, 20_0000 ether);\\n        _mint(_devAddress, 5_0000  ether);\\n        _mint(_operatorAddress, 5_0000 ether);\\n        _mint(_airdropLockAddress, 50_0000 ether);\\n        superNodeAddress = _superNodeAddress;\\n        mainNodeAddress = _mainNodeAddress;\\n        richNodeAddress = _richNodeAddress;\\n        liquidityAddress = _liquidityAddress;\\n        whitelistAddress = _whitelistAddress;\\n        stakingPoolAddress = _stakingPoolAddress;\\n        devAddress = _devAddress;\\n        operatorAddress = _operatorAddress;\\n        airdropLockAddress = _airdropLockAddress;\\n\\n        // Mainnet\\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\\n        );\\n        pairAddress = IPancakeFactory(pancakeRouter.factory()).createPair(\\n            address(this),\\n            0x55d398326f99059fF775485246999027B3197955\\n        );\\n        //Testnet\\n        // IPancakeRouter02 pancakeRouter = IPancakeRouter02(\\n        //     0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\\n        // );\\n        // //\\n        // pairAddress = IPancakeFactory(pancakeRouter.factory()).createPair(\\n        //     address(this),\\n        //     0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684\\n        // );\\n        feeWhitelist[liquidityAddress] = true;\\n        feeWhitelist[msg.sender] = true;\\n        feeWhitelist[whitelistAddress] = true;\\n        feeWhitelist[stakingPoolAddress] = true;\\n        feeWhitelist[airdropLockAddress] = true;\\n        feeWhitelist[superNodeAddress] = true;\\n        feeWhitelist[mainNodeAddress] = true;\\n        feeWhitelist[richNodeAddress] = true;\\n        feeWhitelist[devAddress] = true;\\n        feeWhitelist[operatorAddress] = true;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    function setPairAddress(address addr) public onlyOwner {\\n        pairAddress = addr;\\n    }\\n\\n    function addWhiteList(address addr) public onlyOwner {\\n        feeWhitelist[addr] = true;\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender];\\n        // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max)\\n            allowance[from][msg.sender] = allowed - amount;\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(\\n                recoveredAddress != address(0) && recoveredAddress == owner,\\n                \\\"INVALID_SIGNER\\\"\\n            );\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return\\n            block.chainid == INITIAL_CHAIN_ID\\n                ? INITIAL_DOMAIN_SEPARATOR\\n                : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        totalDestroyAmount += amount;\\n        destroyAmount += amount;\\n        if (block.timestamp > startTime + 1 days) {\\n            dayDestroyAmount = destroyAmount;\\n            destroyAmount = 0;\\n            startTime = block.timestamp;\\n            if (IStakePool(stakingPoolAddress).updateReward(dayDestroyAmount)) {\\n                emit UpdateReward(dayDestroyAmount, block.timestamp);\\n            }\\n        }\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, DEAD_ADDRESS, amount);\\n    }\\n\\n    function setStartTime(uint256 _startTime) public onlyOwner {\\n        startTime = _startTime;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(balanceOf[from] >= amount, \\\"TRANSFER_NOT_ENOUGH_FUNDS\\\");\\n        if (totalSupply < 21000 ether) {\\n            balanceOf[from] -= amount;\\n            balanceOf[to] += amount;\\n            emit Transfer(from, to, amount);\\n            return;\\n        }\\n        if (to == DEAD_ADDRESS) {\\n            balanceOf[from] -= amount;\\n            _burn(from, amount);\\n            return;\\n        }\\n        if (to != pairAddress && from != pairAddress) {\\n            if (\\n                from != address(0) &&\\n                from != stakingPoolAddress &&\\n                from != superNodeAddress &&\\n                from != mainNodeAddress &&\\n                from != richNodeAddress &&\\n                from != airdropLockAddress &&\\n                inviter[to] == address(0)\\n            ) {\\n                inviter[to] = from;\\n            }\\n            balanceOf[from] -= amount;\\n            balanceOf[to] += amount;\\n            emit Transfer(from, to, amount);\\n        } else {\\n            if (feeWhitelist[from]) {\\n                balanceOf[from] -= amount;\\n                balanceOf[to] += amount;\\n                emit Transfer(from, to, amount);\\n            } else {\\n                uint256 toBurn = (amount * 2) / 100;\\n                uint256 toSuperNodeFee = (amount * 1) / 100;\\n                uint256 toMainNodeFee = (amount * 75) / 10000;\\n                uint256 toRichNodeFee = (amount * 75) / 10000;\\n                uint256 toInviterFee = (amount * 5) / 1000;\\n                uint256 receiveAmount = (amount * 95) / 100;\\n                balanceOf[from] -= amount;\\n                _burn(from, toBurn);\\n                balanceOf[superNodeAddress] += toSuperNodeFee;\\n                emit Transfer(from, superNodeAddress, toSuperNodeFee);\\n                balanceOf[richNodeAddress] += toRichNodeFee;\\n                emit Transfer(from, richNodeAddress, toRichNodeFee);\\n                balanceOf[mainNodeAddress] += toMainNodeFee;\\n                emit Transfer(from, mainNodeAddress, toMainNodeFee);\\n                if (from == pairAddress) {\\n                    if (inviter[to] != address(0)) {\\n                        balanceOf[inviter[to]] += toInviterFee;\\n                        emit Transfer(from, inviter[to], toInviterFee);\\n                    } else {\\n                        _burn(from, toInviterFee);\\n                    }\\n                } else if (to == pairAddress) {\\n                    if (inviter[from] != address(0)) {\\n                        balanceOf[inviter[from]] += toInviterFee;\\n                        emit Transfer(from, inviter[from], toInviterFee);\\n                    } else {\\n                        _burn(from, toInviterFee);\\n                    }\\n                }\\n                balanceOf[to] += receiveAmount;\\n                emit Transfer(from, to, receiveAmount);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pancakeswap_interface/IPancakeRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/pancakeswap_interface/IPancakeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\ninterface IPancakeFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n\\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingPoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_airdropLockAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_superNodeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mainNodeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_richNodeAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updateAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"name\":\"UpdateReward\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dayDestroyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDestroyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LLAW", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000767e4f6e75f5331c67334a77102520a4ea38c90a00000000000000000000000037a7ceb8bd64da89d06380227e3db136c5d71a83000000000000000000000000ada4f12af1d2ff77fc21734292d2b470a71108fa0000000000000000000000008bcdc7b54b773e977013ea6cb01e93779ac4a321000000000000000000000000298a0b7372af0f4eb0224c22c432e42773b9e0440000000000000000000000003fde7cc39daeda88ac05fa2743aaafc2df78eaa5000000000000000000000000890b8c272cf6db5e99a3be66545329509fe6427f000000000000000000000000fac90e43cb4d900d5547b049c1877a761bfcbf99000000000000000000000000e834b924c434bd23a5a0626517951e6e6d442a9f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}