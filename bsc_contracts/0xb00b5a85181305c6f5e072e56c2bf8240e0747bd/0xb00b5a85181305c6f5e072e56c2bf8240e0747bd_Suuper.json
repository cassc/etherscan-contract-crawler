{"SourceCode": "{\"Libraries.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n//\\r\\n\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) \\u003c\\u003c 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) \\u003c\\u003c 255);\\r\\n\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n\\r\\n        require(c != MIN_INT256 || (a \\u0026 MIN_INT256) != (b \\u0026 MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a \\u003c 0 ? -a : a;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapPair {\\r\\n\\t\\tevent Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\t\\tevent Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n\\t\\tfunction name() external pure returns (string memory);\\r\\n\\t\\tfunction symbol() external pure returns (string memory);\\r\\n\\t\\tfunction decimals() external pure returns (uint8);\\r\\n\\t\\tfunction totalSupply() external view returns (uint);\\r\\n\\t\\tfunction balanceOf(address owner) external view returns (uint);\\r\\n\\t\\tfunction allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n\\t\\tfunction approve(address spender, uint value) external returns (bool);\\r\\n\\t\\tfunction transfer(address to, uint value) external returns (bool);\\r\\n\\t\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n\\t\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\t\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\t\\tfunction nonces(address owner) external view returns (uint);\\r\\n\\r\\n\\t\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n\\t\\tevent Mint(address indexed sender, uint amount0, uint amount1);\\r\\n\\t\\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n\\t\\tevent Swap(\\r\\n\\t\\t\\t\\taddress indexed sender,\\r\\n\\t\\t\\t\\tuint amount0In,\\r\\n\\t\\t\\t\\tuint amount1In,\\r\\n\\t\\t\\t\\tuint amount0Out,\\r\\n\\t\\t\\t\\tuint amount1Out,\\r\\n\\t\\t\\t\\taddress indexed to\\r\\n\\t\\t);\\r\\n\\t\\tevent Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n\\t\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\t\\tfunction factory() external view returns (address);\\r\\n\\t\\tfunction token0() external view returns (address);\\r\\n\\t\\tfunction token1() external view returns (address);\\r\\n\\t\\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\t\\tfunction price0CumulativeLast() external view returns (uint);\\r\\n\\t\\tfunction price1CumulativeLast() external view returns (uint);\\r\\n\\t\\tfunction kLast() external view returns (uint);\\r\\n\\r\\n\\t\\tfunction mint(address to) external returns (uint liquidity);\\r\\n\\t\\tfunction burn(address to) external returns (uint amount0, uint amount1);\\r\\n\\t\\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n\\t\\tfunction skim(address to) external;\\r\\n\\t\\tfunction sync() external;\\r\\n\\r\\n\\t\\tfunction initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapRouter{\\r\\n\\t\\tfunction factory() external pure returns (address);\\r\\n\\t\\tfunction WETH() external pure returns (address);\\r\\n\\r\\n\\t\\tfunction addLiquidity(\\r\\n\\t\\t\\t\\taddress tokenA,\\r\\n\\t\\t\\t\\taddress tokenB,\\r\\n\\t\\t\\t\\tuint amountADesired,\\r\\n\\t\\t\\t\\tuint amountBDesired,\\r\\n\\t\\t\\t\\tuint amountAMin,\\r\\n\\t\\t\\t\\tuint amountBMin,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline\\r\\n\\t\\t) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\t\\tfunction addLiquidityETH(\\r\\n\\t\\t\\t\\taddress token,\\r\\n\\t\\t\\t\\tuint amountTokenDesired,\\r\\n\\t\\t\\t\\tuint amountTokenMin,\\r\\n\\t\\t\\t\\tuint amountETHMin,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline\\r\\n\\t\\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\t\\tfunction removeLiquidity(\\r\\n\\t\\t\\t\\taddress tokenA,\\r\\n\\t\\t\\t\\taddress tokenB,\\r\\n\\t\\t\\t\\tuint liquidity,\\r\\n\\t\\t\\t\\tuint amountAMin,\\r\\n\\t\\t\\t\\tuint amountBMin,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline\\r\\n\\t\\t) external returns (uint amountA, uint amountB);\\r\\n\\t\\tfunction removeLiquidityETH(\\r\\n\\t\\t\\t\\taddress token,\\r\\n\\t\\t\\t\\tuint liquidity,\\r\\n\\t\\t\\t\\tuint amountTokenMin,\\r\\n\\t\\t\\t\\tuint amountETHMin,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline\\r\\n\\t\\t) external returns (uint amountToken, uint amountETH);\\r\\n\\t\\tfunction removeLiquidityWithPermit(\\r\\n\\t\\t\\t\\taddress tokenA,\\r\\n\\t\\t\\t\\taddress tokenB,\\r\\n\\t\\t\\t\\tuint liquidity,\\r\\n\\t\\t\\t\\tuint amountAMin,\\r\\n\\t\\t\\t\\tuint amountBMin,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline,\\r\\n\\t\\t\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t\\t) external returns (uint amountA, uint amountB);\\r\\n\\t\\tfunction removeLiquidityETHWithPermit(\\r\\n\\t\\t\\t\\taddress token,\\r\\n\\t\\t\\t\\tuint liquidity,\\r\\n\\t\\t\\t\\tuint amountTokenMin,\\r\\n\\t\\t\\t\\tuint amountETHMin,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline,\\r\\n\\t\\t\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t\\t) external returns (uint amountToken, uint amountETH);\\r\\n\\t\\tfunction swapExactTokensForTokens(\\r\\n\\t\\t\\t\\tuint amountIn,\\r\\n\\t\\t\\t\\tuint amountOutMin,\\r\\n\\t\\t\\t\\taddress[] calldata path,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline\\r\\n\\t\\t) external returns (uint[] memory amounts);\\r\\n\\t\\tfunction swapTokensForExactTokens(\\r\\n\\t\\t\\t\\tuint amountOut,\\r\\n\\t\\t\\t\\tuint amountInMax,\\r\\n\\t\\t\\t\\taddress[] calldata path,\\r\\n\\t\\t\\t\\taddress to,\\r\\n\\t\\t\\t\\tuint deadline\\r\\n\\t\\t) external returns (uint[] memory amounts);\\r\\n\\t\\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n\\t\\t\\t\\texternal\\r\\n\\t\\t\\t\\tpayable\\r\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\r\\n\\t\\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n\\t\\t\\t\\texternal\\r\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\r\\n\\t\\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n\\t\\t\\t\\texternal\\r\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\r\\n\\t\\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n\\t\\t\\t\\texternal\\r\\n\\t\\t\\t\\tpayable\\r\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\r\\n\\r\\n\\t\\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n\\t\\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n\\t\\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n\\t\\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\t\\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\t\\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n\\t\\t\\taddress token,\\r\\n\\t\\t\\tuint liquidity,\\r\\n\\t\\t\\tuint amountTokenMin,\\r\\n\\t\\t\\tuint amountETHMin,\\r\\n\\t\\t\\taddress to,\\r\\n\\t\\t\\tuint deadline\\r\\n\\t\\t) external returns (uint amountETH);\\r\\n\\t\\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n\\t\\t\\taddress token,\\r\\n\\t\\t\\tuint liquidity,\\r\\n\\t\\t\\tuint amountTokenMin,\\r\\n\\t\\t\\tuint amountETHMin,\\r\\n\\t\\t\\taddress to,\\r\\n\\t\\t\\tuint deadline,\\r\\n\\t\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t\\t) external returns (uint amountETH);\\r\\n\\t\\r\\n\\t\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n\\t\\t\\tuint amountIn,\\r\\n\\t\\t\\tuint amountOutMin,\\r\\n\\t\\t\\taddress[] calldata path,\\r\\n\\t\\t\\taddress to,\\r\\n\\t\\t\\tuint deadline\\r\\n\\t\\t) external;\\r\\n\\t\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n\\t\\t\\tuint amountOutMin,\\r\\n\\t\\t\\taddress[] calldata path,\\r\\n\\t\\t\\taddress to,\\r\\n\\t\\t\\tuint deadline\\r\\n\\t\\t) external payable;\\r\\n\\t\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n\\t\\t\\tuint amountIn,\\r\\n\\t\\t\\tuint amountOutMin,\\r\\n\\t\\t\\taddress[] calldata path,\\r\\n\\t\\t\\taddress to,\\r\\n\\t\\t\\tuint deadline\\r\\n\\t\\t) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapFactory {\\r\\n\\t\\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n\\t\\tfunction feeTo() external view returns (address);\\r\\n\\t\\tfunction feeToSetter() external view returns (address);\\r\\n\\r\\n\\t\\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n\\t\\tfunction allPairs(uint) external view returns (address pair);\\r\\n\\t\\tfunction allPairsLength() external view returns (uint);\\r\\n\\r\\n\\t\\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n\\t\\tfunction setFeeTo(address) external;\\r\\n\\t\\tfunction setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipRenounced(address indexed previousOwner);\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipRenounced(_owner);\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract ERC20Detailed is IERC20 {\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    constructor(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_\\r\\n    ) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _decimals = decimals_;\\r\\n    }\\r\\n\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n}\\r\\n\"},\"SUUPER.sol\":{\"content\":\"\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n//\\r\\n\\r\\npragma solidity ^0.7.4;\\r\\nimport \\\"./Libraries.sol\\\";\\r\\ncontract Suuper is ERC20Detailed, Ownable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMathInt for int256;\\r\\n\\r\\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\\r\\n\\r\\n    string public _name = \\\"Suuper\\\";\\r\\n    string public _symbol = \\\"SUUPER\\\";\\r\\n    uint8 public _decimals = 5;\\r\\n\\r\\n    IPancakeSwapPair public pairContract;\\r\\n    mapping(address =\\u003e bool) _isFeeExempt;\\r\\n\\r\\n    modifier validRecipient(address to) {\\r\\n        require(to != address(0x0));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    uint256 public constant DECIMALS = 5;\\r\\n    uint256 public constant MAX_UINT256 = ~uint256(0);\\r\\n    uint8 public constant RATE_DECIMALS = 7;\\r\\n\\r\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY =\\r\\n        500000 * 10**DECIMALS;\\r\\n\\r\\n    uint256 public liquidityFee = 40;\\r\\n    uint256 public treasuryAndTeamFee = 50;\\r\\n    uint256 public RFV = 50;\\r\\n    uint256 public sellFee = 20;\\r\\n    uint256 public burnFee = 20;\\r\\n    uint256 public totalFee =\\r\\n        liquidityFee.add(treasuryAndTeamFee).add(RFV).add(\\r\\n            burnFee\\r\\n        );\\r\\n    uint256 public feeDenominator = 1000;\\r\\n\\r\\n    address public Wildfire = 0x000000000000000000000000000000000000dEaD;//Wildfire is blacklisted\\r\\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\\r\\n\\r\\n    address public autoLiquidityReceiver;\\r\\n    address public treasuryReceiver;\\r\\n    address public SuuperInsuranceFundReceiver;\\r\\n    address public pairAddress;\\r\\n    address public TeamWallet;\\r\\n    bool public swapEnabled = true;\\r\\n    IPancakeSwapRouter public router;\\r\\n    address public pair;\\r\\n    bool inSwap = false;\\r\\n    modifier swapping() {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    uint256 private constant TOTAL_GONS =\\r\\n        MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\r\\n\\r\\n    uint256 private constant MAX_SUPPLY = 500 * 10**7 * 10**DECIMALS;\\r\\n\\r\\n    bool public _autoRebase;\\r\\n    bool public _autoAddLiquidity;\\r\\n    uint256 public LaunchTimestamp=MAX_UINT256;\\r\\n    uint256 public _lastRebasedTime=MAX_UINT256;\\r\\n    uint256 public _lastAddLiquidityTime;\\r\\n    uint256 public _totalSupply;\\r\\n    uint256 private _gonsPerFragment;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private _gonBalances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowedFragments;\\r\\n\\r\\n    constructor() ERC20Detailed(\\\"Suuper\\\", \\\"SUUPER\\\", uint8(DECIMALS)) Ownable() {\\r\\n\\r\\n        router = IPancakeSwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); \\r\\n        //router = IPancakeSwapRouter(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);        \\r\\n        pair = IPancakeSwapFactory(router.factory()).createPair(\\r\\n            router.WETH(),\\r\\n            address(this)\\r\\n        );\\r\\n        //set all fee receiver to owner at launch\\r\\n        autoLiquidityReceiver = msg.sender;\\r\\n        treasuryReceiver = msg.sender; \\r\\n        TeamWallet=msg.sender;\\r\\n        SuuperInsuranceFundReceiver = msg.sender;\\r\\n\\r\\n        _allowedFragments[address(this)][address(router)] = uint256(-1);\\r\\n        pairAddress = pair;\\r\\n        pairContract = IPancakeSwapPair(pair);\\r\\n\\r\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\r\\n        _gonBalances[treasuryReceiver] = TOTAL_GONS;\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n        _autoRebase = true;\\r\\n        _autoAddLiquidity = true;\\r\\n        _isFeeExempt[treasuryReceiver] = true;\\r\\n        _isFeeExempt[address(this)] = true;\\r\\n\\r\\n        _transferOwnership(treasuryReceiver);\\r\\n        emit Transfer(address(0x0), treasuryReceiver, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function setLaunchTimestamp(uint Timestamp) external onlyOwner{\\r\\n        require(block.timestamp\\u003cLaunchTimestamp,\\\"Already Launched\\\");\\r\\n        require(Timestamp\\u003e=block.timestamp,\\\"Launch can\\u0027t be in the past\\\");\\r\\n        LaunchTimestamp=Timestamp;\\r\\n        _lastRebasedTime=Timestamp;\\r\\n    }\\r\\n    function rebase() internal {\\r\\n        if ( inSwap ) return;\\r\\n        uint256 rebaseRate;\\r\\n        uint256 deltaTimeFromInit = block.timestamp - LaunchTimestamp;\\r\\n        uint256 deltaTime = block.timestamp - _lastRebasedTime;\\r\\n        uint256 times = deltaTime.div(10 minutes);\\r\\n        uint256 epoch = deltaTimeFromInit.div(10 minutes);\\r\\n        //max 100 rebases at once so no out of gas is possible due to inactivity\\r\\n        if (times\\u003e100)times=100;\\r\\n\\r\\n        if (deltaTimeFromInit \\u003c (365 days)) {\\r\\n            rebaseRate = 1600;\\r\\n        } else if (deltaTimeFromInit \\u003e= (7 * 365 days)) {\\r\\n            rebaseRate = 2;\\r\\n        } else if (deltaTimeFromInit \\u003e= ((15 * 365 days) / 10)) {\\r\\n            rebaseRate = 16;\\r\\n        } else {\\r\\n            rebaseRate = 160;\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c times; i++) {\\r\\n            _totalSupply = _totalSupply\\r\\n                .mul((10**RATE_DECIMALS).add(rebaseRate))\\r\\n                .div(10**RATE_DECIMALS);\\r\\n        }\\r\\n\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n        _lastRebasedTime = _lastRebasedTime.add(times.mul(10 minutes));\\r\\n\\r\\n        pairContract.sync();\\r\\n\\r\\n        emit LogRebase(epoch, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 value)\\r\\n        external\\r\\n        override\\r\\n        validRecipient(to)\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transferFrom(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external override validRecipient(to) returns (bool) {\\r\\n        \\r\\n        if (_allowedFragments[from][msg.sender] != uint256(-1)) {\\r\\n            _allowedFragments[from][msg.sender] = _allowedFragments[from][\\r\\n                msg.sender\\r\\n            ].sub(value, \\\"Insufficient Allowance\\\");\\r\\n        }\\r\\n        _transferFrom(from, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _basicTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\\r\\n        _gonBalances[from] = _gonBalances[from].sub(gonAmount);\\r\\n        _gonBalances[to] = _gonBalances[to].add(gonAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n\\r\\n        require(sender!=Wildfire, \\\"Wildfire can\\u0027t transfer\\\");\\r\\n\\r\\n        if (inSwap) {\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n        }\\r\\n        if(shouldTakeFee(sender, recipient)){\\r\\n            require(block.timestamp\\u003e=LaunchTimestamp,\\\"Not yet Launched\\\");\\r\\n            if (shouldRebase()) {\\r\\n                rebase();\\r\\n            }\\r\\n            if (shouldAddLiquidity()) {\\r\\n                addLiquidity();\\r\\n            }\\r\\n            if (shouldSwapBack()) {\\r\\n                swapBack();\\r\\n            }\\r\\n        }\\r\\n\\r\\n\\r\\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\\r\\n        _gonBalances[sender] = _gonBalances[sender].sub(gonAmount);\\r\\n        uint256 gonAmountReceived = shouldTakeFee(sender, recipient)\\r\\n            ? takeFee(sender, recipient, gonAmount)\\r\\n            : gonAmount;\\r\\n        _gonBalances[recipient] = _gonBalances[recipient].add(\\r\\n            gonAmountReceived\\r\\n        );\\r\\n\\r\\n\\r\\n        emit Transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            gonAmountReceived.div(_gonsPerFragment)\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function takeFee(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 gonAmount\\r\\n    ) internal  returns (uint256) {\\r\\n        uint256 _totalFee = totalFee;\\r\\n        uint256 _treasuryFee = treasuryAndTeamFee;\\r\\n\\r\\n        if (recipient == pair) {\\r\\n            _totalFee = totalFee.add(sellFee);\\r\\n            _treasuryFee = treasuryAndTeamFee.add(sellFee);\\r\\n        }\\r\\n\\r\\n        uint256 feeAmount = gonAmount.div(feeDenominator).mul(_totalFee);\\r\\n       \\r\\n        _gonBalances[Wildfire] = _gonBalances[Wildfire].add(\\r\\n            gonAmount.div(feeDenominator).mul(burnFee)\\r\\n        );\\r\\n        _gonBalances[address(this)] = _gonBalances[address(this)].add(\\r\\n            gonAmount.div(feeDenominator).mul(_treasuryFee.add(RFV))\\r\\n        );\\r\\n        _gonBalances[autoLiquidityReceiver] = _gonBalances[autoLiquidityReceiver].add(\\r\\n            gonAmount.div(feeDenominator).mul(liquidityFee)\\r\\n        );\\r\\n        \\r\\n        emit Transfer(sender, address(this), feeAmount.div(_gonsPerFragment));\\r\\n        return gonAmount.sub(feeAmount);\\r\\n    }\\r\\n\\r\\n    function addLiquidity() internal swapping {\\r\\n        uint256 autoLiquidityAmount = _gonBalances[autoLiquidityReceiver].div(\\r\\n            _gonsPerFragment\\r\\n        );\\r\\n        _gonBalances[address(this)] = _gonBalances[address(this)].add(\\r\\n            _gonBalances[autoLiquidityReceiver]\\r\\n        );\\r\\n        _gonBalances[autoLiquidityReceiver] = 0;\\r\\n        uint256 amountToLiquify = autoLiquidityAmount.div(2);\\r\\n        uint256 amountToSwap = autoLiquidityAmount.sub(amountToLiquify);\\r\\n\\r\\n        if( amountToSwap == 0 ) {\\r\\n            return;\\r\\n        }\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        uint256 balanceBefore = address(this).balance;\\r\\n\\r\\n\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amountToSwap,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 amountETHLiquidity = address(this).balance.sub(balanceBefore);\\r\\n\\r\\n        if (amountToLiquify \\u003e 0\\u0026\\u0026amountETHLiquidity \\u003e 0) {\\r\\n            router.addLiquidityETH{value: amountETHLiquidity}(\\r\\n                address(this),\\r\\n                amountToLiquify,\\r\\n                0,\\r\\n                0,\\r\\n                autoLiquidityReceiver,\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n        _lastAddLiquidityTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function swapBack() internal swapping {\\r\\n\\r\\n        uint256 amountToSwap = _gonBalances[address(this)].div(_gonsPerFragment);\\r\\n\\r\\n        if( amountToSwap == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 balanceBefore = address(this).balance;\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        \\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amountToSwap,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 receivedAmount = address(this).balance.sub(\\r\\n            balanceBefore\\r\\n        );\\r\\n\\r\\n        uint TreasuryAndTeamAmount=receivedAmount.mul(treasuryAndTeamFee).div(treasuryAndTeamFee.add(RFV));\\r\\n        uint TreasuryAmount=TreasuryAndTeamAmount*4/5;\\r\\n        uint TeamAmount=TreasuryAndTeamAmount-TreasuryAmount;\\r\\n\\r\\n        (bool success, ) = payable(treasuryReceiver).call{\\r\\n            value: TreasuryAmount,\\r\\n            gas: 70000\\r\\n        }(\\\"\\\");\\r\\n\\r\\n        (success, ) = payable(TeamWallet).call{\\r\\n            value: TeamAmount,\\r\\n            gas: 70000\\r\\n        }(\\\"\\\");\\r\\n\\r\\n        (success, ) = payable(SuuperInsuranceFundReceiver).call{\\r\\n            value: receivedAmount.mul(RFV).div(\\r\\n                treasuryAndTeamFee.add(RFV)\\r\\n            ),\\r\\n            gas: 70000\\r\\n        }(\\\"\\\");\\r\\n    }\\r\\n\\r\\n    function withdrawAllToTreasury() external swapping onlyOwner {\\r\\n\\r\\n        uint256 amountToSwap = _gonBalances[address(this)].div(_gonsPerFragment);\\r\\n        require( amountToSwap \\u003e 0,\\\"There is no Suuper token deposited in token contract\\\");\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amountToSwap,\\r\\n            0,\\r\\n            path,\\r\\n            treasuryReceiver,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function shouldTakeFee(address from, address to)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return \\r\\n            (pair == from || pair == to) \\u0026\\u0026\\r\\n            !(_isFeeExempt[from]||_isFeeExempt[to]);\\r\\n    }\\r\\n\\r\\n    function shouldRebase() internal view returns (bool) {\\r\\n        return\\r\\n            _autoRebase \\u0026\\u0026\\r\\n            block.timestamp\\u003e=LaunchTimestamp\\u0026\\u0026\\r\\n            (_totalSupply \\u003c MAX_SUPPLY) \\u0026\\u0026\\r\\n            msg.sender != pair  \\u0026\\u0026\\r\\n            !inSwap \\u0026\\u0026\\r\\n            block.timestamp \\u003e= (_lastRebasedTime + 10 minutes);\\r\\n    }\\r\\n\\r\\n    function shouldAddLiquidity() internal view returns (bool) {\\r\\n        return\\r\\n            _autoAddLiquidity \\u0026\\u0026 \\r\\n            !inSwap \\u0026\\u0026 \\r\\n            msg.sender != pair \\u0026\\u0026\\r\\n            block.timestamp \\u003e= (_lastAddLiquidityTime + 2 days);\\r\\n    }\\r\\n\\r\\n    function shouldSwapBack() internal view returns (bool) {\\r\\n        return \\r\\n            !inSwap \\u0026\\u0026\\r\\n            msg.sender != pair  ; \\r\\n    }\\r\\n\\r\\n    function setAutoRebase(bool _flag) external onlyOwner {\\r\\n        if (_flag) {\\r\\n            _autoRebase = _flag;\\r\\n            _lastRebasedTime = block.timestamp;\\r\\n        } else {\\r\\n            _autoRebase = _flag;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setAutoAddLiquidity(bool _flag) external onlyOwner {\\r\\n        if(_flag) {\\r\\n            _autoAddLiquidity = _flag;\\r\\n            _lastAddLiquidityTime = block.timestamp;\\r\\n        } else {\\r\\n            _autoAddLiquidity = _flag;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function allowance(address owner_, address spender)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowedFragments[owner_][spender];\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\r\\n        if (subtractedValue \\u003e= oldValue) {\\r\\n            _allowedFragments[msg.sender][spender] = 0;\\r\\n        } else {\\r\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(\\r\\n                subtractedValue\\r\\n            );\\r\\n        }\\r\\n        emit Approval(\\r\\n            msg.sender,\\r\\n            spender,\\r\\n            _allowedFragments[msg.sender][spender]\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][\\r\\n            spender\\r\\n        ].add(addedValue);\\r\\n        emit Approval(\\r\\n            msg.sender,\\r\\n            spender,\\r\\n            _allowedFragments[msg.sender][spender]\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 value)\\r\\n        external\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] = value;\\r\\n        emit Approval(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function checkFeeExempt(address _addr) external view returns (bool) {\\r\\n        return _isFeeExempt[_addr];\\r\\n    }\\r\\n\\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return\\r\\n            (TOTAL_GONS.sub(_gonBalances[Wildfire]).sub(_gonBalances[ZERO])).div(\\r\\n                _gonsPerFragment\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function isNotInSwap() external view returns (bool) {\\r\\n        return !inSwap;\\r\\n    }\\r\\n\\r\\n    function manualSync() external {\\r\\n        IPancakeSwapPair(pair).sync();\\r\\n    }\\r\\n\\r\\n    function setFeeReceivers(\\r\\n        address _autoLiquidityReceiver,\\r\\n        address _treasuryReceiver,\\r\\n        address _SuuperInsuranceFundReceiver,\\r\\n        address _teamWallet\\r\\n    ) external onlyOwner {\\r\\n        autoLiquidityReceiver = _autoLiquidityReceiver;\\r\\n        treasuryReceiver = _treasuryReceiver;\\r\\n        SuuperInsuranceFundReceiver = _SuuperInsuranceFundReceiver;\\r\\n        TeamWallet=_teamWallet;\\r\\n    }\\r\\n\\r\\n    function getLiquidityBacking(uint256 accuracy)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 liquidityBalance = _gonBalances[pair].div(_gonsPerFragment);\\r\\n        return\\r\\n            accuracy.mul(liquidityBalance.mul(2)).div(getCirculatingSupply());\\r\\n    }\\r\\n\\r\\n    function setWhitelist(address _addr) external onlyOwner {\\r\\n        _isFeeExempt[_addr] = true;\\r\\n    }\\r\\n\\r\\n    function AdjustWildfireWallet(address newDeadWallet) external onlyOwner {\\r\\n        require(block.timestamp\\u003cLaunchTimestamp);\\r\\n        Wildfire=newDeadWallet;  \\r\\n    }\\r\\n    \\r\\n    function setPairAddress(address _pairAddress) public onlyOwner {\\r\\n        pairAddress = _pairAddress;\\r\\n        pairContract=IPancakeSwapPair(_pairAddress);\\r\\n    }\\r\\n    \\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n   \\r\\n    function balanceOf(address who) external view override returns (uint256) {\\r\\n        return _gonBalances[who].div(_gonsPerFragment);\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    receive() external payable {\\r\\n        require(msg.sender==address(router));\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeadWallet\",\"type\":\"address\"}],\"name\":\"AdjustWildfireWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LaunchTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RFV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SuuperInsuranceFundReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TeamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wildfire\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAddLiquidityTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastRebasedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNotInSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairContract\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_SuuperInsuranceFundReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"name\":\"setLaunchTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pairAddress\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAndTeamFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Suuper", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4489c929486a281634d64179be4bdcf8d0bd245651a051d51063a8d3e8ecc40f"}