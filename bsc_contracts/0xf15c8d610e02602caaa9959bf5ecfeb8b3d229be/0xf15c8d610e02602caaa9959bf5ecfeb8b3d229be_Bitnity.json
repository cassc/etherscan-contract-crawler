{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/bitnity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT                                                                               \\r\\n                                                    \\r\\npragma solidity 0.8.15;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20 {\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    uint256 private _totalSupply;\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        unchecked {\\r\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[sender] = senderBalance - amount;\\r\\n        }\\r\\n        _balances[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _createInitialSupply(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IDexRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\r\\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\r\\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IDexFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ncontract TokenHandler is Ownable {\\r\\n    function sendTokenToOwner(address token) external onlyOwner {\\r\\n        if(IERC20(token).balanceOf(address(this)) > 0){\\r\\n            IERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Bitnity is ERC20, Ownable {\\r\\n\\r\\n    uint256 public maxBuyAmount;\\r\\n    uint256 public maxSellAmount;\\r\\n\\r\\n    IDexRouter public immutable dexRouter;\\r\\n    address public immutable lpPair;\\r\\n    address public immutable lpPairEth;\\r\\n\\r\\n    bool public lpToEth;\\r\\n\\r\\n    IERC20 public immutable STABLECOIN; \\r\\n\\r\\n    bool private swapping;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n\\r\\n    // must be used with Stablecoin\\r\\n    TokenHandler public tokenHandler;\\r\\n\\r\\n    address public operationsAddress;\\r\\n    address public futureOwnerAddress;\\r\\n\\r\\n    uint256 public tradingActiveBlock = 0; // 0 means trading is not active\\r\\n    mapping (address => bool) public restrictedWallets;\\r\\n    uint256 public blockForPenaltyEnd;\\r\\n\\r\\n    bool public limitsInEffect = true;\\r\\n    bool public tradingActive = false;\\r\\n    bool public swapEnabled = false;\\r\\n    \\r\\n    uint256 public buyTotalFees;\\r\\n    uint256 public buyOperationsFee;\\r\\n\\r\\n    uint256 public sellTotalFees;\\r\\n    uint256 public sellOperationsFee;\\r\\n\\r\\n    uint256 constant FEE_DIVISOR = 10000;\\r\\n\\r\\n    uint256 public tokensForLiquidity;\\r\\n    uint256 public tokensForOperations;\\r\\n    \\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n\\r\\n    // Events\\r\\n\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n    event EnabledTrading();\\r\\n    event RemovedLimits();\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n    event UpdatedMaxBuyAmount(uint256 newAmount);\\r\\n    event UpdatedMaxSellAmount(uint256 newAmount);\\r\\n    event UpdatedMaxWalletAmount(uint256 newAmount);\\r\\n    event UpdatedBuyFee(uint256 newAmount);\\r\\n    event UpdatedSellFee(uint256 newAmount);\\r\\n    event UpdatedProjectAddress(address indexed newWallet);\\r\\n    event UpdatedLiquidityAddress(address indexed newWallet);\\r\\n    event UpdatedDevAddress(address indexed newWallet);\\r\\n    event UpdatedOperationsAddress(address indexed newWallet);\\r\\n    event MaxTransactionExclusion(address _address, bool excluded);\\r\\n    event OwnerForcedSwapBack(uint256 timestamp);\\r\\n    event CaughtEarlyBuyer(address sniper);\\r\\n    event TransferForeignToken(address token, uint256 amount);\\r\\n\\r\\n    constructor(bool _lpIsEth, address newOwner) ERC20(\\\"Bitnity Token\\\", \\\"BTNTY\\\") {\\r\\n\\r\\n        lpToEth = _lpIsEth;\\r\\n\\r\\n        address stablecoinAddress;\\r\\n        address _dexRouter;\\r\\n\\r\\n        // automatically detect router/desired stablecoin\\r\\n        if(block.chainid == 1){\\r\\n            stablecoinAddress = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // USDC\\r\\n            _dexRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ETH: Uniswap V2\\r\\n        } else if(block.chainid == 4){\\r\\n            stablecoinAddress  = 0xE7d541c18D6aDb863F4C570065c57b75a53a64d3; // Rinkeby Testnet USDC\\r\\n            _dexRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ETH: Uniswap V2\\r\\n        } else if(block.chainid == 56){\\r\\n            stablecoinAddress  = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // BUSD\\r\\n            _dexRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // BNB Chain: PCS V2\\r\\n        } else if(block.chainid == 97){\\r\\n            stablecoinAddress  = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // BSC Testnet BUSD\\r\\n            _dexRouter = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1; // BNB Chain: PCS V2\\r\\n        } else {\\r\\n            revert(\\\"Chain not configured\\\");\\r\\n        }\\r\\n\\r\\n        STABLECOIN = IERC20(stablecoinAddress);\\r\\n        require(STABLECOIN.decimals() > 0 , \\\"Incorrect liquidity token\\\");\\r\\n\\r\\n        dexRouter = IDexRouter(_dexRouter);\\r\\n\\r\\n        // create pair\\r\\n        lpPair = IDexFactory(dexRouter.factory()).createPair(address(this), address(STABLECOIN));\\r\\n        setAutomatedMarketMakerPair(address(lpPair), true);\\r\\n\\r\\n        lpPairEth = IDexFactory(dexRouter.factory()).createPair(address(this), dexRouter.WETH());\\r\\n        setAutomatedMarketMakerPair(address(lpPairEth), true);\\r\\n\\r\\n        uint256 totalSupply = 1 * 1e9 * 1e18;\\r\\n        \\r\\n        maxBuyAmount = totalSupply * 25 / 10000;\\r\\n        maxSellAmount = totalSupply * 25 / 10000;\\r\\n        swapTokensAtAmount = totalSupply * 25 / 100000;\\r\\n\\r\\n        tokenHandler = new TokenHandler();\\r\\n\\r\\n        buyOperationsFee = 450;\\r\\n        buyTotalFees = buyOperationsFee;\\r\\n\\r\\n        sellOperationsFee = 450;\\r\\n        sellTotalFees = sellOperationsFee;\\r\\n\\r\\n        \\r\\n        futureOwnerAddress = address(msg.sender);\\r\\n        operationsAddress = address(0xCF32e7019048Ac0C51AeC2678f98a73905D8d64d);\\r\\n\\r\\n        _excludeFromMaxTransaction(newOwner, true);\\r\\n        _excludeFromMaxTransaction(futureOwnerAddress, true);\\r\\n        _excludeFromMaxTransaction(address(this), true);\\r\\n        _excludeFromMaxTransaction(address(0xdead), true);\\r\\n        _excludeFromMaxTransaction(address(operationsAddress), true);\\r\\n        _excludeFromMaxTransaction(address(dexRouter), true);\\r\\n\\r\\n        excludeFromFees(newOwner, true);\\r\\n        excludeFromFees(futureOwnerAddress, true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n        excludeFromFees(address(operationsAddress), true);\\r\\n        excludeFromFees(address(dexRouter), true);\\r\\n\\r\\n        _createInitialSupply(address(newOwner), totalSupply);\\r\\n        transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    // Owner Functions\\r\\n\\r\\n    function updateLpToEth(bool _lpToEth) external onlyOwner {\\r\\n        if(_lpToEth){\\r\\n            require(balanceOf(address(lpPairEth))>0, \\\"Must have tokens in ETH pair to set as default LP pair\\\");\\r\\n        } else {\\r\\n            require(balanceOf(address(lpPair))>0, \\\"Must have tokens in STABLECOIN pair to set as default LP pair\\\");\\r\\n        }\\r\\n        lpToEth = _lpToEth;\\r\\n    }\\r\\n\\r\\n    function enableTrading(uint256 blocksForPenalty) external onlyOwner {\\r\\n        require(!tradingActive, \\\"Trading is already active, cannot relaunch.\\\");\\r\\n        require(blocksForPenalty <= 10, \\\"Cannot make penalty blocks more than 10\\\");\\r\\n        tradingActive = true;\\r\\n        swapEnabled = true;\\r\\n        tradingActiveBlock = block.number;\\r\\n        blockForPenaltyEnd = tradingActiveBlock + blocksForPenalty;\\r\\n        emit EnabledTrading();\\r\\n    }\\r\\n\\r\\n    function pauseTrading() external onlyOwner {\\r\\n        require(tradingActiveBlock > 0, \\\"Cannot pause until token has launched\\\");\\r\\n        require(tradingActive, \\\"Trading is already paused\\\");\\r\\n        tradingActive = false;\\r\\n    }\\r\\n\\r\\n    function unpauseTrading() external onlyOwner {\\r\\n        require(tradingActiveBlock > 0, \\\"Cannot unpause until token has launched\\\");\\r\\n        require(!tradingActive, \\\"Trading is already unpaused\\\");\\r\\n        tradingActive = true;\\r\\n    }\\r\\n\\r\\n    function manageRestrictedWallets(address[] calldata wallets,  bool restricted) external onlyOwner {\\r\\n        for(uint256 i = 0; i < wallets.length; i++){\\r\\n            restrictedWallets[wallets[i]] = restricted;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function removeLimits() external onlyOwner {\\r\\n        limitsInEffect = false;\\r\\n        maxBuyAmount = totalSupply();\\r\\n        maxSellAmount = totalSupply();\\r\\n        emit RemovedLimits();\\r\\n    }\\r\\n\\r\\n    function updateMaxBuyAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 1 / 1000) / (10 ** decimals()), \\\"Cannot set max buy amount lower than 0.1%\\\");\\r\\n        maxBuyAmount = newNum * (10 ** decimals());\\r\\n        emit UpdatedMaxBuyAmount(maxBuyAmount);\\r\\n    }\\r\\n    \\r\\n    function updateMaxSellAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 1 / 1000) / (10 ** decimals()), \\\"Cannot set max sell amount lower than 0.1%\\\");\\r\\n        maxSellAmount = newNum * (10 ** decimals());\\r\\n        emit UpdatedMaxSellAmount(maxSellAmount);\\r\\n    }\\r\\n\\r\\n    // change the minimum amount of tokens to sell from fees\\r\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\\r\\n  \\t    require(newAmount >= totalSupply() * 1 / 1000000, \\\"Swap amount cannot be lower than 0.0001% total supply.\\\");\\r\\n  \\t    require(newAmount <= totalSupply() * 1 / 1000, \\\"Swap amount cannot be higher than 0.1% total supply.\\\");\\r\\n  \\t    swapTokensAtAmount = newAmount;\\r\\n  \\t}\\r\\n    \\r\\n    function transferForeignToken(address _token, address _to) external onlyOwner returns (bool _sent) {\\r\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\r\\n        require(_token != address(this) || !tradingActive, \\\"Can't withdraw native tokens while trading is active\\\");\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\\r\\n        emit TransferForeignToken(_token, _contractBalance);\\r\\n    }\\r\\n\\r\\n    function setOperationsAddress(address _operationsAddress) external onlyOwner {\\r\\n        require(_operationsAddress != address(0), \\\"address cannot be 0\\\");\\r\\n        operationsAddress = payable(_operationsAddress);\\r\\n        emit UpdatedOperationsAddress(_operationsAddress);\\r\\n    }\\r\\n\\r\\n    function forceSwapBack(bool inEth) external onlyOwner {\\r\\n        require(balanceOf(address(this)) >= swapTokensAtAmount, \\\"Can only swap when token amount is at or higher than restriction\\\");\\r\\n        swapping = true;\\r\\n        if(inEth){\\r\\n            swapBackEth();\\r\\n        } else {\\r\\n            swapBack();\\r\\n        }\\r\\n        swapping = false;\\r\\n        emit OwnerForcedSwapBack(block.timestamp);\\r\\n    }\\r\\n    \\r\\n    function airdropToWallets(address[] memory wallets, uint256[] memory amountsInTokens) external onlyOwner {\\r\\n        require(wallets.length == amountsInTokens.length, \\\"arrays must be the same length\\\");\\r\\n        require(wallets.length < 600, \\\"Can only airdrop 600 wallets per txn due to gas limits\\\");\\r\\n        for(uint256 i = 0; i < wallets.length; i++){\\r\\n            address wallet = wallets[i];\\r\\n            uint256 amount = amountsInTokens[i];\\r\\n            super._transfer(msg.sender, wallet, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {\\r\\n        if(!isEx){\\r\\n            require(updAds != lpPair, \\\"Cannot remove uniswap pair from max txn\\\");\\r\\n        }\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != lpPair || value, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n        _excludeFromMaxTransaction(pair, value);\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function updateBuyFees(uint256 _operationsFee) external onlyOwner {\\r\\n        buyOperationsFee = _operationsFee;\\r\\n        buyTotalFees = buyOperationsFee;\\r\\n        require(buyTotalFees <= 1500, \\\"Must keep fees at 15% or less\\\");\\r\\n        emit UpdatedBuyFee(buyTotalFees);\\r\\n    }\\r\\n\\r\\n    function updateSellFees(uint256 _operationsFee) external onlyOwner {\\r\\n        sellOperationsFee = _operationsFee;\\r\\n        sellTotalFees = sellOperationsFee;\\r\\n        require(sellTotalFees <= 1500, \\\"Must keep fees at 15% or less\\\");\\r\\n        emit UpdatedSellFee(sellTotalFees);\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    // private / internal functions\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal override {\\r\\n\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        // transfer of 0 is allowed, but triggers no logic.  In case of staking where a staking pool is paying out 0 rewards.\\r\\n        if(amount == 0){\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        if(!tradingActive){\\r\\n            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\r\\n        }\\r\\n\\r\\n        if(!earlyBuyPenaltyInEffect() && blockForPenaltyEnd > 0){\\r\\n            require(!restrictedWallets[from] || to == owner() || to == address(0xdead), \\\"Bots cannot transfer tokens in or out except to owner or dead address.\\\");\\r\\n        }\\r\\n\\r\\n        if(limitsInEffect){\\r\\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){\\r\\n                \\r\\n                //on buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                    require(amount <= maxBuyAmount, \\\"Buy transfer amount exceeds the max buy.\\\");\\r\\n                } \\r\\n                //on sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                    require(amount <= maxSellAmount, \\\"Sell transfer amount exceeds the max sell.\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n        \\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n\\r\\n        if(canSwap && swapEnabled && !swapping && automatedMarketMakerPairs[to]) {\\r\\n            swapping = true;\\r\\n            if(lpToEth){\\r\\n                swapBackEth();\\r\\n            } else {\\r\\n                swapBack();\\r\\n            }\\r\\n            swapping = false;\\r\\n        }\\r\\n\\r\\n        bool takeFee = true;\\r\\n\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        \\r\\n        uint256 fees = 0;\\r\\n\\r\\n        // only take fees on buys/sells, do not take on wallet transfers\\r\\n        if(takeFee){\\r\\n            // bot/sniper penalty.\\r\\n            if(earlyBuyPenaltyInEffect() && automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to] && buyTotalFees > 0){\\r\\n                \\r\\n                if(!restrictedWallets[to]){\\r\\n                    restrictedWallets[to] = true;\\r\\n                }\\r\\n                \\r\\n                fees = amount * buyTotalFees / FEE_DIVISOR;\\r\\n                tokensForOperations += fees * buyOperationsFee / buyTotalFees;\\r\\n            }\\r\\n\\r\\n            // on sell\\r\\n            else if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\r\\n                fees = amount * sellTotalFees / FEE_DIVISOR;\\r\\n                tokensForOperations += fees * sellOperationsFee / sellTotalFees;\\r\\n            }\\r\\n\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\r\\n        \\t    fees = amount * buyTotalFees / FEE_DIVISOR;\\r\\n                tokensForOperations += fees * buyOperationsFee / buyTotalFees;\\r\\n            }\\r\\n            \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n        \\t\\r\\n        \\tamount -= fees;\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function swapTokensForSTABLECOIN(uint256 tokenAmount) private {\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = address(STABLECOIN);\\r\\n\\r\\n        _approve(address(this), address(dexRouter), tokenAmount);\\r\\n\\r\\n        dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(tokenHandler), block.timestamp);\\r\\n    }\\r\\n\\r\\n    // if LP pair in use is STABLECOIN, this function will be used to handle fee distribution.\\r\\n\\r\\n    function swapBack() private {\\r\\n\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForOperations;\\r\\n        \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n\\r\\n        if(contractBalance > swapTokensAtAmount * 10){\\r\\n            contractBalance = swapTokensAtAmount * 10;\\r\\n        }\\r\\n        \\r\\n        swapTokensForSTABLECOIN(contractBalance);\\r\\n\\r\\n        tokenHandler.sendTokenToOwner(address(STABLECOIN));\\r\\n\\r\\n        tokensForOperations = 0;\\r\\n\\r\\n        if(STABLECOIN.balanceOf(address(this)) > 0){\\r\\n            STABLECOIN.transfer(operationsAddress, STABLECOIN.balanceOf(address(this)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // if LP pair in use is ETH, this function will be used to handle fee distribution.\\r\\n\\r\\n    function swapBackEth() private {\\r\\n        bool success;\\r\\n\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForOperations;\\r\\n        \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n\\r\\n        if(contractBalance > swapTokensAtAmount * 10){\\r\\n            contractBalance = swapTokensAtAmount * 10;\\r\\n        }\\r\\n\\r\\n        swapTokensForEth(contractBalance);\\r\\n        \\r\\n        tokensForOperations = 0;\\r\\n\\r\\n        if(address(this).balance > 0){\\r\\n            (success, ) = operationsAddress.call{value: address(this).balance}(\\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = dexRouter.WETH();\\r\\n\\r\\n        _approve(address(this), address(dexRouter), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);\\r\\n    }\\r\\n\\r\\n    function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isExcluded;\\r\\n        emit MaxTransactionExclusion(updAds, isExcluded);\\r\\n    }\\r\\n\\r\\n    //views\\r\\n\\r\\n    function earlyBuyPenaltyInEffect() private view returns (bool){\\r\\n        return block.number < blockForPenaltyEnd;\\r\\n    }\\r\\n\\r\\n    function getBlockNumber() external view returns (uint256){\\r\\n        return block.number;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lpIsEth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"}],\"name\":\"CaughtEarlyBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EnabledTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"MaxTransactionExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OwnerForcedSwapBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RemovedLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferForeignToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedBuyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedDevAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedLiquidityAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxBuyAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxSellAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxWalletAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedOperationsAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedProjectAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedSellFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"STABLECOIN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsInTokens\",\"type\":\"uint256[]\"}],\"name\":\"airdropToWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockForPenaltyEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyOperationsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocksForPenalty\",\"type\":\"uint256\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"inEth\",\"type\":\"bool\"}],\"name\":\"forceSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureOwnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPairEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"restricted\",\"type\":\"bool\"}],\"name\":\"manageRestrictedWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"restrictedWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellOperationsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operationsAddress\",\"type\":\"address\"}],\"name\":\"setOperationsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenHandler\",\"outputs\":[{\"internalType\":\"contract TokenHandler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActiveBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_operationsFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lpToEth\",\"type\":\"bool\"}],\"name\":\"updateLpToEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxBuyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxSellAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_operationsFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Bitnity", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000100000000000000000000000026b76fe53af235a8680eba66ed05a17cf24dea86", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}