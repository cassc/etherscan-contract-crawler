{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n}\r\n\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract SimpleBridge is Ownable{\r\n    string public  domain;\r\n    string public  bridgeVersion;\r\n    address public  bridgeToken;\r\n    uint256 public fixedFee;\r\n\r\n    ISwapRouter public swapRouter;\r\n    address public fundAddress;\r\n    address public usdt;\r\n\r\n    mapping(uint64 => uint64) public getInboundNonceByChainId;\r\n    mapping(uint64 => uint64) public getOutboundNonceByChainId;\r\n    mapping(uint64 => bool) public supportedChainId;\r\n    mapping(uint64 => uint256) public getOutBoundFeeByChainId;\r\n\r\n    modifier inboundChecker(uint64 _srcChainId, uint64 _nonce) {\r\n        require(_nonce == getInboundNonceByChainId[_srcChainId], \"wrong nonce\");\r\n        getInboundNonceByChainId[_srcChainId]++;\r\n        _;\r\n    }\r\n    event Received(address Sender, uint Value);\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n    \r\n    function initialize(\r\n        string memory _domain,\r\n        string memory _bridgeVersion,\r\n        address _bridgeToken,\r\n        address _usdt,\r\n        address _fundAddress,\r\n        address _routerAddress\r\n    ) public onlyOwner {\r\n        domain = _domain;\r\n        bridgeVersion = _bridgeVersion;\r\n        bridgeToken = _bridgeToken;\r\n        usdt = _usdt;\r\n        fundAddress = _fundAddress;\r\n        swapRouter = ISwapRouter(_routerAddress);\r\n        IERC20(bridgeToken).approve(_routerAddress,~uint256(0));\r\n        IERC20(_usdt).approve(_routerAddress,~uint256(0));\r\n\r\n    }\r\n    event DepositInitiated(\r\n        uint64 dstChainId,\r\n        uint64 indexed nonce,\r\n        address token,\r\n        address indexed from,\r\n        address to,\r\n        uint256 amount\r\n    );\r\n\r\n    event WithdrawalFinalizedETH(\r\n        uint64 srcChainId,\r\n        uint64 indexed nonce,\r\n        address indexed from,\r\n        address indexed target,\r\n        uint256 value\r\n    );\r\n    event WithdrawalFinalizedToken(\r\n        uint64 srcChainId,\r\n        uint64 indexed nonce,\r\n        address  token,\r\n        address indexed from,\r\n        address indexed target,\r\n        uint256 value\r\n    );\r\n    event Failed_swapExactTokensForTokens(\r\n        uint256 value\r\n    );\r\n    event Failed_swapExactETHForTokens(\r\n        uint256 value\r\n    );\r\n    event Failed_swapExactTokensForETH(\r\n        uint256 value\r\n    );\r\n    event Failed_addLiquidityETH(\r\n        uint256 value\r\n    );\r\n    event Failed_addLiquidity(\r\n        uint256 value\r\n    );\r\n\r\n    event SwapSuccess(uint64 indexed nonce, int256 amountIn, int256 amoutOut);\r\n\r\n    event SwapFailed(uint64 indexed nonce, uint256 amountIn, string reason);\r\n\r\n    function enableChain(uint64 _chainId, bool _enabled) public onlyOwner {\r\n        supportedChainId[_chainId] = _enabled;\r\n    }\r\n\r\n    function checkFeeAmount(uint64 _chainId,uint256 swapAmount,bool isETH) public view returns(uint256)  {\r\n        require(swapAmount >0);\r\n        uint256 feeAmount;\r\n        if(isETH){\r\n\r\n            address[] memory ETHtoUpath = new address[](2);\r\n            ETHtoUpath[0] = usdt;\r\n            ETHtoUpath[1] = swapRouter.WETH();\r\n\r\n            uint256 fixedETHAmount = swapRouter.getAmountsOut(fixedFee,ETHtoUpath)[1];\r\n            feeAmount = swapAmount * getOutBoundFeeByChainId[_chainId] / 10000 + fixedETHAmount;\r\n\r\n        }else{\r\n            feeAmount = swapAmount * getOutBoundFeeByChainId[_chainId] / 10000 + fixedFee;\r\n        }\r\n        return feeAmount;\r\n\r\n    }\r\n\r\n\r\n    function swapETHtoDeposit(uint256 feeAmount,uint256 tAmount) private returns(bool) {\r\n\r\n        uint256 lpAmount = feeAmount / 2;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = swapRouter.WETH();\r\n        path[1] = bridgeToken;\r\n        uint256 beforeBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        if(lpAmount >0){\r\n\r\n            try\r\n                swapRouter.swapExactETHForTokens{value: lpAmount}(\r\n                    0,\r\n                    path,\r\n                    address(this),\r\n                    block.timestamp\r\n                )\r\n\r\n            {} catch {\r\n                emit Failed_swapExactETHForTokens(lpAmount);\r\n            }           \r\n        }else{\r\n            return false;\r\n        }\r\n\r\n        \r\n        uint256 afterBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        uint256 bridgeAmount = afterBridgeAmount - beforeBridgeAmount;\r\n\r\n        if(bridgeAmount >0){\r\n            try\r\n                swapRouter.addLiquidityETH{value: lpAmount}(\r\n                    bridgeToken,\r\n                    bridgeAmount,\r\n                    0,\r\n                    0,\r\n                    fundAddress,\r\n                    block.timestamp\r\n                )\r\n            {} catch {\r\n                emit Failed_addLiquidityETH(lpAmount);\r\n            }\r\n        }else{\r\n            return false;\r\n        }\r\n\r\n\r\n        uint256 swapAmount = tAmount - feeAmount;\r\n        uint256 acceptSwapedBridgeAmount = swapRouter.getAmountsOut(swapAmount,path)[1] / 2;\r\n        if(address(this).balance >= swapAmount){\r\n            try\r\n                swapRouter.swapExactETHForTokens{value: swapAmount}(\r\n                    acceptSwapedBridgeAmount,\r\n                    path,\r\n                    address(this),\r\n                    block.timestamp\r\n                )\r\n\r\n            {} catch {\r\n                emit Failed_swapExactETHForTokens(swapAmount);\r\n            }\r\n        }else{\r\n            return false;\r\n        }\r\n        uint256 finalBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        uint256 swapedBridgeAmount = finalBridgeAmount - beforeBridgeAmount;\r\n        if(swapedBridgeAmount>=acceptSwapedBridgeAmount){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function swapTokentoDeposit(address token,uint256 feeAmount,uint256 tAmount) private returns(bool) {\r\n\r\n        uint256 lpTokenAmount = feeAmount / 2;\r\n\r\n        address[] memory path = new address[](3);\r\n        path[0] = token;\r\n        path[1] = swapRouter.WETH();\r\n        path[2] = bridgeToken;\r\n        uint256 beforeBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        if(lpTokenAmount > 0 ){\r\n            try\r\n                swapRouter.swapExactTokensForTokens(\r\n                        lpTokenAmount,\r\n                        0,\r\n                        path,\r\n                        address(this),\r\n                        block.timestamp\r\n                    )\r\n            {} catch {\r\n                emit Failed_swapExactTokensForTokens(lpTokenAmount);\r\n            }\r\n        }else{\r\n            return false;\r\n        }\r\n\r\n        \r\n\r\n        uint256 afterBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        uint256 lpBridgeAmount = afterBridgeAmount - beforeBridgeAmount;\r\n\r\n        if(lpBridgeAmount > 0 ){\r\n            try\r\n                swapRouter.addLiquidity(\r\n                    token,\r\n                    bridgeToken,\r\n                    lpTokenAmount,\r\n                    lpBridgeAmount,\r\n                    0,\r\n                    0,\r\n                    fundAddress,\r\n                    block.timestamp\r\n                )\r\n            {} catch {\r\n                emit Failed_addLiquidity(lpTokenAmount);\r\n            }\r\n        }else{\r\n            return false;\r\n        }\r\n\r\n        uint256 swapAmount = tAmount - feeAmount;\r\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\r\n        uint256 acceptSwapedBridgeAmount = swapRouter.getAmountsOut(swapAmount,path)[2] / 2;\r\n        if(tokenBalance >= swapAmount){\r\n            try\r\n                swapRouter.swapExactTokensForTokens(\r\n                        swapAmount,\r\n                        acceptSwapedBridgeAmount,\r\n                        path,\r\n                        address(this),\r\n                        block.timestamp\r\n                    )\r\n            {} catch {\r\n                emit Failed_swapExactTokensForTokens(swapAmount);\r\n\r\n            }\r\n        }\r\n        uint256 finalBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        uint256 swapedBridgeAmount = finalBridgeAmount - beforeBridgeAmount;\r\n        if(swapedBridgeAmount>=acceptSwapedBridgeAmount){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    function depositETH(uint64 _dstChainId,address _dstToken, address _to, uint256 swapAmount) public payable  {\r\n\r\n        require(supportedChainId[_dstChainId], \"NOT_SUPPORTED\");\r\n        uint256 feeAmount =  checkFeeAmount(_dstChainId,swapAmount,true);\r\n        //\u5224\u65ad\u8f6c\u5165\u6570\u91cf\u5927\u4e8e\u5151\u6362\u5230\u7684 \u6865\u5e01\u6570\u91cf+\u8d39\u7528\r\n        uint256 tAmount = feeAmount + swapAmount;\r\n        require(msg.value >= tAmount, \"too few\");\r\n        //\u5151\u6362\u6865\u5e01\r\n        uint256 beforeBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        bool success = swapETHtoDeposit(feeAmount, tAmount);\r\n        uint256 afterBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        if(success){\r\n            uint256 swapedBridgeAmount = afterBridgeAmount - beforeBridgeAmount;\r\n            //nonce\u6838\u5bf9\r\n            uint64 _nonce = getOutboundNonceByChainId[_dstChainId];\r\n            getOutboundNonceByChainId[_dstChainId]++;\r\n            \r\n            emit DepositInitiated(_dstChainId, _nonce, _dstToken, msg.sender, _to, swapedBridgeAmount);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function depositToken(uint64 _dstChainId,address _dstToken, address _to,address token, uint256 swapAmount) public   {\r\n        \r\n        require(supportedChainId[_dstChainId], \"NOT_SUPPORTED\");\r\n        uint256 feeAmount =  checkFeeAmount(_dstChainId,swapAmount,false);\r\n        //\u5224\u65ad\u8f6c\u5165\u6570\u91cf\u5927\u4e8e\u5151\u6362\u5230\u7684 \u6865\u5e01\u6570\u91cf+\u8d39\u7528\r\n        uint256 tAmount = feeAmount + swapAmount;\r\n        require(IERC20(token).allowance(msg.sender,address(this))>=tAmount && tAmount > 0);\r\n        IERC20(token).transferFrom(msg.sender,address(this),tAmount);\r\n        //\u5151\u6362\u6865\u5e01\r\n        uint256 beforeBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        bool success = swapTokentoDeposit(token,feeAmount, tAmount);\r\n        uint256 afterBridgeAmount = IERC20(bridgeToken).balanceOf(address(this));\r\n        if(success){\r\n            uint256 swapedBridgeAmount = afterBridgeAmount - beforeBridgeAmount;\r\n            //nonce\u6838\u5bf9\r\n            uint64 _nonce = getOutboundNonceByChainId[_dstChainId];\r\n            getOutboundNonceByChainId[_dstChainId]++;\r\n            \r\n            emit DepositInitiated(_dstChainId, _nonce, _dstToken, msg.sender, _to, swapedBridgeAmount);\r\n\r\n        }\r\n    }\r\n\r\n    function claimToken(\r\n        address token,\r\n        uint256 amount,\r\n        address to\r\n    ) external onlyOwner {\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n\r\n    function claimBalance() external onlyOwner{\r\n        payable(fundAddress).transfer(address(this).balance);\r\n    }\r\n    function getFeeByChainId(uint64 _chainId) public view returns (uint256) {\r\n        return getOutBoundFeeByChainId[_chainId];\r\n    }\r\n\r\n\r\n    function setFee(uint64 _chainId, uint256 feeRate) public onlyOwner {\r\n        getOutBoundFeeByChainId[_chainId] = feeRate;\r\n    }\r\n    function setFixedFee(uint256 _fee) public onlyOwner {\r\n        fixedFee = _fee;\r\n    }\r\n    function finalizeWithdrawETH(\r\n        uint64 _srcChainId,\r\n        uint64 _nonce,\r\n        address _from,\r\n        address _target,\r\n        uint256 _value\r\n    ) public onlyOwner inboundChecker(_srcChainId, _nonce) {\r\n        uint256 bridgeBalance = IERC20(bridgeToken).balanceOf(address(this));\r\n        require(bridgeBalance >= _value);\r\n        address[] memory path = new address[](2);\r\n        path[0] = bridgeToken;\r\n        path[1] = swapRouter.WETH();\r\n\r\n        try\r\n            swapRouter.swapExactTokensForETH(\r\n                    _value,\r\n                    0,\r\n                    path,\r\n                    _target,\r\n                    block.timestamp\r\n                )\r\n        {} catch {\r\n            emit SwapFailed( _nonce, _value, \"swapETHFailed\");\r\n        }\r\n        emit WithdrawalFinalizedETH(_srcChainId, _nonce, _from, _target, _value);\r\n    }\r\n    function finalizeWithdrawToken(\r\n        uint64 _srcChainId,\r\n        uint64 _nonce,\r\n        address token,\r\n        address _from,\r\n        address _target,\r\n        uint256 _value\r\n    ) public onlyOwner inboundChecker(_srcChainId, _nonce) {\r\n        uint256 bridgeBalance = IERC20(bridgeToken).balanceOf(address(this));\r\n        require(bridgeBalance >= _value);\r\n        address[] memory path = new address[](3);\r\n        path[0] = bridgeToken;\r\n        path[1] = swapRouter.WETH();\r\n        path[2] = token;\r\n        try\r\n            swapRouter.swapExactTokensForTokens(\r\n                    _value,\r\n                    0,\r\n                    path,\r\n                    _target,\r\n                    block.timestamp\r\n                )\r\n        {} catch {\r\n            emit SwapFailed( _nonce, _value, \"swapTokenFailed\");\r\n        }\r\n        emit WithdrawalFinalizedToken(_srcChainId, _nonce,token, _from, _target, _value);\r\n    }\r\n\r\n    function setFundAddress(address addr) external onlyOwner {\r\n        fundAddress = addr;\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Failed_addLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Failed_addLiquidityETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Failed_swapExactETHForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Failed_swapExactTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Failed_swapExactTokensForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Value\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"SwapFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amountIn\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amoutOut\",\"type\":\"int256\"}],\"name\":\"SwapSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawalFinalizedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawalFinalizedToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridgeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isETH\",\"type\":\"bool\"}],\"name\":\"checkFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"}],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"enableChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"finalizeWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"finalizeWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"}],\"name\":\"getFeeByChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"getInboundNonceByChainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"getOutBoundFeeByChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"getOutboundNonceByChainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_domain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_bridgeVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_bridgeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"feeRate\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFixedFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"supportedChainId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SimpleBridge", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2e552ae0959d37eda7af2633f9ae4eb0c3e925be0877657661a291ef1217485f"}