{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/PeggedTokenBridgeV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/ISigsVerifier.sol\\\";\\nimport \\\"../interfaces/IPeggedToken.sol\\\";\\nimport \\\"../libraries/PbPegged.sol\\\";\\nimport \\\"../safeguard/Pauser.sol\\\";\\nimport \\\"../safeguard/VolumeControl.sol\\\";\\nimport \\\"../interfaces/IBridgeAdminOracle.sol\\\";\\nimport \\\"../safeguard/DelayedTransfer.sol\\\";\\n\\n/**\\n * @title The bridge contract to mint and burn pegged tokens\\n * @dev Work together with OriginalTokenVault deployed at remote chains.\\n */\\ncontract PeggedTokenBridgeV2 is Pauser, VolumeControl, DelayedTransfer {\\n    ISigsVerifier public immutable sigsVerifier;\\n    IBridgeAdminOracle public bridgeAdminOracle;\\n\\n    mapping(bytes32 => bool) public records;\\n    mapping(address => uint256) public supplies;\\n\\n    mapping(address => uint256) public minBurn;\\n    mapping(address => uint256) public maxBurn;\\n\\n    event Mint(\\n        bytes32 mintId,\\n        address token,\\n        address account,\\n        uint256 amount,\\n        // ref_chain_id defines the reference chain ID, taking values of:\\n        // 1. The common case: the chain ID on which the remote corresponding deposit or burn happened;\\n        // 2. Refund for wrong burn: this chain ID on which the burn happened\\n        uint64 refChainId,\\n        // ref_id defines a unique reference ID, taking values of:\\n        // 1. The common case of deposit/burn-mint: the deposit or burn ID on the remote chain;\\n        // 2. Refund for wrong burn: the burn ID on this chain\\n        bytes32 refId,\\n        address depositor\\n    );\\n    event Burn(\\n        bytes32 burnId,\\n        address token,\\n        address account,\\n        uint256 amount,\\n        uint64 toChainId,\\n        address toAccount,\\n        uint64 nonce\\n    );\\n    event MinBurnUpdated(address token, uint256 amount);\\n    event MaxBurnUpdated(address token, uint256 amount);\\n    event SupplyUpdated(address token, uint256 supply);\\n\\n    constructor(ISigsVerifier _sigsVerifier, address _bridgeAdminOracle) {\\n        sigsVerifier = _sigsVerifier;\\n        bridgeAdminOracle = IBridgeAdminOracle(_bridgeAdminOracle);\\n    }\\n\\n    modifier checkFee(uint256 _value)\\n    {\\n        require(_value >= bridgeAdminOracle.getFee(), \\\"fee not met\\\");\\n        _;\\n    }\\n\\n    modifier checkChain(uint64 _chainId)\\n    {\\n        require(bridgeAdminOracle.checkChain(_chainId), \\\"chain not allowed\\\");\\n        _;\\n    }\\n\\n    modifier checkToken(address _token)\\n    {\\n        require(bridgeAdminOracle.checkToken(_token), \\\"token not allowed\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\\n     * @param _request The serialized Mint protobuf.\\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\\n     * @param _signers The sorted list of signers.\\n     * @param _powers The signing powers of the signers.\\n     */\\n    function mint(\\n        bytes calldata _request,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external whenNotPaused returns (bytes32) {\\n\\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \\\"Mint\\\"));\\n\\n        sigsVerifier.verifySigs(abi.encodePacked(domain, _request), _sigs, _signers, _powers);\\n\\n        PbPegged.Mint memory request = PbPegged.decMint(_request);\\n        bytes32 mintId = keccak256(\\n            // len = 20 + 20 + 32 + 20 + 8 + 32 + 20 = 152\\n            abi.encodePacked(\\n                request.account,\\n                request.token,\\n                request.amount,\\n                request.depositor,\\n                request.refChainId,\\n                request.refId,\\n                address(this)\\n            )\\n        );\\n        require(records[mintId] == false, \\\"record exists\\\");\\n        records[mintId] = true;\\n        _updateVolume(request.token, request.amount);\\n        uint256 delayThreshold = delayThresholds[request.token];\\n        if (delayThreshold > 0 && request.amount > delayThreshold) {\\n            _addDelayedTransfer(mintId, request.account, request.token, request.amount);\\n        } else {\\n            IPeggedToken(request.token).mint(request.account, request.amount);\\n        }\\n        supplies[request.token] += request.amount;\\n        emit Mint(\\n            mintId,\\n            request.token,\\n            request.account,\\n            request.amount,\\n            request.refChainId,\\n            request.refId,\\n            request.depositor\\n        );\\n        return mintId;\\n    }\\n\\n    /**\\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\\n     * OriginalTokenVault, or mint at another remote chain\\n     * NOTE: This function DOES NOT SUPPORT fee-on-transfer / rebasing tokens.\\n     * @param _token The pegged token address.\\n     * @param _amount The amount to burn.\\n     * @param _toChainId If zero, withdraw from original vault; otherwise, the remote chain to mint tokens.\\n     * @param _toAccount The account to receive tokens on the remote chain\\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\\n     */\\n    function burn(\\n        address _from,\\n        address _token,\\n        uint256 _amount,\\n        uint64 _toChainId,\\n        address _toAccount,\\n        uint64 _nonce\\n    ) external payable whenNotPaused checkFee(msg.value) checkChain(_toChainId) checkToken(_token) returns (bytes32) {\\n        address payable feeReceiver = payable(bridgeAdminOracle.getFeeReceiver());\\n        feeReceiver.transfer(msg.value);\\n        bytes32 burnId = _burn(_from, _token, _amount, _toChainId, _toAccount, _nonce);\\n        IPeggedToken(_token).burn(_from, _amount);\\n        return burnId;\\n    }\\n\\n    function _burn(\\n        address _from,\\n        address _token,\\n        uint256 _amount,\\n        uint64 _toChainId,\\n        address _toAccount,\\n        uint64 _nonce\\n    ) internal returns (bytes32) {\\n        require(_amount > minBurn[_token], \\\"amount too small\\\");\\n        require(maxBurn[_token] == 0 || _amount <= maxBurn[_token], \\\"amount too large\\\");\\n        supplies[_token] -= _amount;\\n        bytes32 burnId = keccak256(\\n            // len = 20 + 20 + 32 + 8 + 20 + 8 + 8 + 20 = 136\\n            abi.encodePacked(\\n                _from,\\n                _token,\\n                _amount,\\n                _toChainId,\\n                _toAccount,\\n                _nonce,\\n                uint64(block.chainid),\\n                address(this)\\n            )\\n        );\\n        require(records[burnId] == false, \\\"record exists\\\");\\n        records[burnId] = true;\\n        emit Burn(burnId, _token, _from, _amount, _toChainId, _toAccount, _nonce);\\n        return burnId;\\n    }\\n\\n    function executeDelayedTransfer(bytes32 id) external whenNotPaused {\\n        delayedTransfer memory transfer = _executeDelayedTransfer(id);\\n        IPeggedToken(transfer.token).mint(transfer.receiver, transfer.amount);\\n    }\\n\\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\\n        require(_tokens.length == _amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            minBurn[_tokens[i]] = _amounts[i];\\n            emit MinBurnUpdated(_tokens[i], _amounts[i]);\\n        }\\n    }\\n\\n    function setMaxBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\\n        require(_tokens.length == _amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            maxBurn[_tokens[i]] = _amounts[i];\\n            emit MaxBurnUpdated(_tokens[i], _amounts[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBridgeAdminOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.17;\\n\\ninterface IBridgeAdminOracle {\\n    function getFee() external view returns (uint256);\\n    function checkChain(uint64 chainId) external view returns(bool);\\n    function getFeeReceiver() external view returns (address);\\n    function checkToken(address _token) external view returns(bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPeggedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface IPeggedToken {\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISigsVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface ISigsVerifier {\\n    /**\\n     * @notice Verifies that a message is signed by a quorum among the signers.\\n     * @param _msg signed message\\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\\n     * @param _signers sorted list of current signers\\n     * @param _powers powers of current signers\\n     */\\n    function verifySigs(\\n        bytes memory _msg,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Pb.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\n// runtime proto sol library\\nlibrary Pb {\\n    enum WireType {\\n        Varint,\\n        Fixed64,\\n        LengthDelim,\\n        StartGroup,\\n        EndGroup,\\n        Fixed32\\n    }\\n\\n    struct Buffer {\\n        uint256 idx; // the start index of next read. when idx=b.length, we're done\\n        bytes b; // hold serialized proto msg, readonly\\n    }\\n\\n    // create a new in-memory Buffer object from raw msg bytes\\n    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\\n        buf.b = raw;\\n        buf.idx = 0;\\n    }\\n\\n    // whether there are unread bytes\\n    function hasMore(Buffer memory buf) internal pure returns (bool) {\\n        return buf.idx < buf.b.length;\\n    }\\n\\n    // decode current field number and wiretype\\n    function decKey(Buffer memory buf) internal pure returns (uint256 tag, WireType wiretype) {\\n        uint256 v = decVarint(buf);\\n        tag = v / 8;\\n        wiretype = WireType(v & 7);\\n    }\\n\\n    // count tag occurrences, return an array due to no memory map support\\n    // have to create array for (maxtag+1) size. cnts[tag] = occurrences\\n    // should keep buf.idx unchanged because this is only a count function\\n    function cntTags(Buffer memory buf, uint256 maxtag) internal pure returns (uint256[] memory cnts) {\\n        uint256 originalIdx = buf.idx;\\n        cnts = new uint256[](maxtag + 1); // protobuf's tags are from 1 rather than 0\\n        uint256 tag;\\n        WireType wire;\\n        while (hasMore(buf)) {\\n            (tag, wire) = decKey(buf);\\n            cnts[tag] += 1;\\n            skipValue(buf, wire);\\n        }\\n        buf.idx = originalIdx;\\n    }\\n\\n    // read varint from current buf idx, move buf.idx to next read, return the int value\\n    function decVarint(Buffer memory buf) internal pure returns (uint256 v) {\\n        bytes10 tmp; // proto int is at most 10 bytes (7 bits can be used per byte)\\n        bytes memory bb = buf.b; // get buf.b mem addr to use in assembly\\n        v = buf.idx; // use v to save one additional uint variable\\n        assembly {\\n            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\\n        }\\n        uint256 b; // store current byte content\\n        v = 0; // reset to 0 for return value\\n        for (uint256 i = 0; i < 10; i++) {\\n            assembly {\\n                b := byte(i, tmp) // don't use tmp[i] because it does bound check and costs extra\\n            }\\n            v |= (b & 0x7F) << (i * 7);\\n            if (b & 0x80 == 0) {\\n                buf.idx += i + 1;\\n                return v;\\n            }\\n        }\\n        revert(); // i=10, invalid varint stream\\n    }\\n\\n    // read length delimited field and return bytes\\n    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\\n        uint256 len = decVarint(buf);\\n        uint256 end = buf.idx + len;\\n        require(end <= buf.b.length); // avoid overflow\\n        b = new bytes(len);\\n        bytes memory bufB = buf.b; // get buf.b mem addr to use in assembly\\n        uint256 bStart;\\n        uint256 bufBStart = buf.idx;\\n        assembly {\\n            bStart := add(b, 32)\\n            bufBStart := add(add(bufB, 32), bufBStart)\\n        }\\n        for (uint256 i = 0; i < len; i += 32) {\\n            assembly {\\n                mstore(add(bStart, i), mload(add(bufBStart, i)))\\n            }\\n        }\\n        buf.idx = end;\\n    }\\n\\n    // return packed ints\\n    function decPacked(Buffer memory buf) internal pure returns (uint256[] memory t) {\\n        uint256 len = decVarint(buf);\\n        uint256 end = buf.idx + len;\\n        require(end <= buf.b.length); // avoid overflow\\n        // array in memory must be init w/ known length\\n        // so we have to create a tmp array w/ max possible len first\\n        uint256[] memory tmp = new uint256[](len);\\n        uint256 i = 0; // count how many ints are there\\n        while (buf.idx < end) {\\n            tmp[i] = decVarint(buf);\\n            i++;\\n        }\\n        t = new uint256[](i); // init t with correct length\\n        for (uint256 j = 0; j < i; j++) {\\n            t[j] = tmp[j];\\n        }\\n        return t;\\n    }\\n\\n    // move idx pass current value field, to beginning of next tag or msg end\\n    function skipValue(Buffer memory buf, WireType wire) internal pure {\\n        if (wire == WireType.Varint) {\\n            decVarint(buf);\\n        } else if (wire == WireType.LengthDelim) {\\n            uint256 len = decVarint(buf);\\n            buf.idx += len; // skip len bytes value data\\n            require(buf.idx <= buf.b.length); // avoid overflow\\n        } else {\\n            revert();\\n        } // unsupported wiretype\\n    }\\n\\n    // type conversion help utils\\n    function _bool(uint256 x) internal pure returns (bool v) {\\n        return x != 0;\\n    }\\n\\n    function _uint256(bytes memory b) internal pure returns (uint256 v) {\\n        require(b.length <= 32); // b's length must be smaller than or equal to 32\\n        assembly {\\n            v := mload(add(b, 32))\\n        } // load all 32bytes to v\\n        v = v >> (8 * (32 - b.length)); // only first b.length is valid\\n    }\\n\\n    function _address(bytes memory b) internal pure returns (address v) {\\n        v = _addressPayable(b);\\n    }\\n\\n    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\\n        require(b.length == 20);\\n        //load 32bytes then shift right 12 bytes\\n        assembly {\\n            v := div(mload(add(b, 32)), 0x1000000000000000000000000)\\n        }\\n    }\\n\\n    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\\n        require(b.length == 32);\\n        assembly {\\n            v := mload(add(b, 32))\\n        }\\n    }\\n\\n    // uint[] to uint8[]\\n    function uint8s(uint256[] memory arr) internal pure returns (uint8[] memory t) {\\n        t = new uint8[](arr.length);\\n        for (uint256 i = 0; i < t.length; i++) {\\n            t[i] = uint8(arr[i]);\\n        }\\n    }\\n\\n    function uint32s(uint256[] memory arr) internal pure returns (uint32[] memory t) {\\n        t = new uint32[](arr.length);\\n        for (uint256 i = 0; i < t.length; i++) {\\n            t[i] = uint32(arr[i]);\\n        }\\n    }\\n\\n    function uint64s(uint256[] memory arr) internal pure returns (uint64[] memory t) {\\n        t = new uint64[](arr.length);\\n        for (uint256 i = 0; i < t.length; i++) {\\n            t[i] = uint64(arr[i]);\\n        }\\n    }\\n\\n    function bools(uint256[] memory arr) internal pure returns (bool[] memory t) {\\n        t = new bool[](arr.length);\\n        for (uint256 i = 0; i < t.length; i++) {\\n            t[i] = arr[i] != 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PbPegged.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Code generated by protoc-gen-sol. DO NOT EDIT.\\n// source: contracts/libraries/proto/pegged.proto\\npragma solidity 0.8.17;\\nimport \\\"./Pb.sol\\\";\\n\\n\\nlibrary PbPegged {\\n    using Pb for Pb.Buffer; // so we can call Pb funcs on Buffer obj\\n\\n    struct Mint {\\n        address token; // tag: 1\\n        address account; // tag: 2\\n        uint256 amount; // tag: 3\\n        address depositor; // tag: 4\\n        uint64 refChainId; // tag: 5\\n        bytes32 refId; // tag: 6\\n    } // end struct Mint\\n\\n    function decMint(bytes memory raw) internal pure returns (Mint memory m) {\\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\\n        uint256 tag;\\n        Pb.WireType wire;\\n        while (buf.hasMore()) {\\n            (tag, wire) = buf.decKey();\\n            if (tag == 1) {\\n                m.token = Pb._address(buf.decBytes());\\n            } else if (tag == 2) {\\n                m.account = Pb._address(buf.decBytes());\\n            } else if (tag == 3) {\\n                m.amount = Pb._uint256(buf.decBytes());\\n            } else if (tag == 4) {\\n                m.depositor = Pb._address(buf.decBytes());\\n            } else if (tag == 5) {\\n                m.refChainId = uint64(buf.decVarint());\\n            } else if (tag == 6) {\\n                m.refId = Pb._bytes32(buf.decBytes());\\n            } else {\\n                buf.skipValue(wire);\\n            } // skip value of unknown tag\\n        }\\n    } // end decoder Mint\\n\\n    struct Withdraw {\\n        address token; // tag: 1\\n        address receiver; // tag: 2\\n        uint256 amount; // tag: 3\\n        address burnAccount; // tag: 4\\n        uint64 refChainId; // tag: 5\\n        bytes32 refId; // tag: 6\\n    } // end struct Withdraw\\n\\n    function decWithdraw(bytes memory raw) internal pure returns (Withdraw memory m) {\\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\\n\\n        uint256 tag;\\n        Pb.WireType wire;\\n        while (buf.hasMore()) {\\n            (tag, wire) = buf.decKey();\\n            if (tag == 1) {\\n                m.token = Pb._address(buf.decBytes());\\n            } else if (tag == 2) {\\n                m.receiver = Pb._address(buf.decBytes());\\n            } else if (tag == 3) {\\n                m.amount = Pb._uint256(buf.decBytes());\\n            } else if (tag == 4) {\\n                m.burnAccount = Pb._address(buf.decBytes());\\n            } else if (tag == 5) {\\n                m.refChainId = uint64(buf.decVarint());\\n            } else if (tag == 6) {\\n                m.refId = Pb._bytes32(buf.decBytes());\\n            } else {\\n                buf.skipValue(wire);\\n            } // skip value of unknown tag\\n        }\\n    } // end decoder Withdraw\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/DelayedTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./Governor.sol\\\";\\n\\nabstract contract DelayedTransfer is Governor {\\n    struct delayedTransfer {\\n        address receiver;\\n        address token;\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n    mapping(bytes32 => delayedTransfer) public delayedTransfers;\\n    mapping(address => uint256) public delayThresholds;\\n    uint256 public delayPeriod; // in seconds\\n\\n    event DelayedTransferAdded(bytes32 id);\\n    event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount);\\n\\n    event DelayPeriodUpdated(uint256 period);\\n    event DelayThresholdUpdated(address token, uint256 threshold);\\n\\n    function setDelayThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) external onlyGovernor {\\n        require(_tokens.length == _thresholds.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            delayThresholds[_tokens[i]] = _thresholds[i];\\n            emit DelayThresholdUpdated(_tokens[i], _thresholds[i]);\\n        }\\n    }\\n\\n    function setDelayPeriod(uint256 _period) external onlyGovernor {\\n        delayPeriod = _period;\\n        emit DelayPeriodUpdated(_period);\\n    }\\n\\n    function _addDelayedTransfer(\\n        bytes32 id,\\n        address receiver,\\n        address token,\\n        uint256 amount\\n    ) internal {\\n        require(delayedTransfers[id].timestamp == 0, \\\"delayed transfer already exists\\\");\\n        delayedTransfers[id] = delayedTransfer({\\n            receiver: receiver,\\n            token: token,\\n            amount: amount,\\n            timestamp: block.timestamp\\n        });\\n        emit DelayedTransferAdded(id);\\n    }\\n\\n    // caller needs to do the actual token transfer\\n    function _executeDelayedTransfer(bytes32 id) internal returns (delayedTransfer memory) {\\n        delayedTransfer memory transfer = delayedTransfers[id];\\n        require(transfer.timestamp > 0, \\\"delayed transfer not exist\\\");\\n        require(block.timestamp > transfer.timestamp + delayPeriod, \\\"delayed transfer still locked\\\");\\n        delete delayedTransfers[id];\\n        emit DelayedTransferExecuted(id, transfer.receiver, transfer.token, transfer.amount);\\n        return transfer;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/Governor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\nabstract contract Governor is Ownable {\\n    mapping(address => bool) public governors;\\n\\n    event GovernorAdded(address account);\\n    event GovernorRemoved(address account);\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(msg.sender), \\\"Caller is not governor\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        _addGovernor(msg.sender);\\n    }\\n\\n    function isGovernor(address _account) public view returns (bool) {\\n        return governors[_account];\\n    }\\n\\n    function addGovernor(address _account) public onlyOwner {\\n        _addGovernor(_account);\\n    }\\n\\n    function removeGovernor(address _account) public onlyOwner {\\n        _removeGovernor(_account);\\n    }\\n\\n    function renounceGovernor() public {\\n        _removeGovernor(msg.sender);\\n    }\\n\\n    function _addGovernor(address _account) private {\\n        require(!isGovernor(_account), \\\"Account is already governor\\\");\\n        governors[_account] = true;\\n        emit GovernorAdded(_account);\\n    }\\n\\n    function _removeGovernor(address _account) private {\\n        require(isGovernor(_account), \\\"Account is not governor\\\");\\n        governors[_account] = false;\\n        emit GovernorRemoved(_account);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/Pauser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\nabstract contract Pauser is Ownable, Pausable {\\n    mapping(address => bool) public pausers;\\n\\n    event PauserAdded(address account);\\n    event PauserRemoved(address account);\\n\\n    constructor() {\\n        _addPauser(msg.sender);\\n    }\\n\\n    modifier onlyPauser() {\\n        require(isPauser(msg.sender), \\\"Caller is not pauser\\\");\\n        _;\\n    }\\n\\n    function pause() public onlyPauser {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyPauser {\\n        _unpause();\\n    }\\n\\n    function isPauser(address account) public view returns (bool) {\\n        return pausers[account];\\n    }\\n\\n    function addPauser(address account) public onlyOwner {\\n        _addPauser(account);\\n    }\\n\\n    function removePauser(address account) public onlyOwner {\\n        _removePauser(account);\\n    }\\n\\n    function renouncePauser() public {\\n        _removePauser(msg.sender);\\n    }\\n\\n    function _addPauser(address account) private {\\n        require(!isPauser(account), \\\"Account is already pauser\\\");\\n        pausers[account] = true;\\n        emit PauserAdded(account);\\n    }\\n\\n    function _removePauser(address account) private {\\n        require(isPauser(account), \\\"Account is not pauser\\\");\\n        pausers[account] = false;\\n        emit PauserRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/VolumeControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.17;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\nabstract contract VolumeControl is Ownable {\\n    uint256 public epochLength; // seconds\\n    mapping(address => uint256) public epochVolumes; // key is token\\n    mapping(address => uint256) public epochVolumeCaps; // key is token\\n    mapping(address => uint256) public lastOpTimestamps; // key is token\\n\\n    event EpochLengthUpdated(uint256 length);\\n    event EpochVolumeUpdated(address token, uint256 cap);\\n\\n    function setEpochLength(uint256 _length) external onlyOwner {\\n        epochLength = _length;\\n        emit EpochLengthUpdated(_length);\\n    }\\n\\n    function setEpochVolumeCaps(address[] calldata _tokens, uint256[] calldata _caps) external onlyOwner {\\n        require(_tokens.length == _caps.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            epochVolumeCaps[_tokens[i]] = _caps[i];\\n            emit EpochVolumeUpdated(_tokens[i], _caps[i]);\\n        }\\n    }\\n\\n    function _updateVolume(address _token, uint256 _amount) internal {\\n        if (epochLength == 0) {\\n            return;\\n        }\\n        uint256 cap = epochVolumeCaps[_token];\\n        if (cap == 0) {\\n            return;\\n        }\\n        uint256 volume = epochVolumes[_token];\\n        uint256 timestamp = block.timestamp;\\n        uint256 epochStartTime = (timestamp / epochLength) * epochLength;\\n        if (lastOpTimestamps[_token] < epochStartTime) {\\n            volume = _amount;\\n        } else {\\n            volume += _amount;\\n        }\\n        require(volume <= cap, \\\"volume exceeds cap\\\");\\n        epochVolumes[_token] = volume;\\n        lastOpTimestamps[_token] = timestamp;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridgeAdminOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"burnId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mintId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"SupplyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeAdminOracle\",\"outputs\":[{\"internalType\":\"contract IBridgeAdminOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_toChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_toAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contract ISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PeggedTokenBridgeV2", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000fc97acda9f67f72339c25583bd6444b67f4337e900000000000000000000000045b710975895dc34b4452f60f90f4a2496f20bb4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}