{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/REBLStakingV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IERC20Rebl.sol\\\";\\nimport \\\"./interfaces/IREBLNFT.sol\\\";\\nimport \\\"./libs/IterableMapping.sol\\\";\\n\\ninterface IPancakeSwap {\\n    function WETH() external pure returns (address);\\n\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IPancakePair {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\\ninterface IREBLStaking {\\n    struct UserStakingInfo {\\n        uint256 rewardUnblockTimestamp;\\n        uint256 usdtAmountForReward;\\n        uint256 tokenAmount;\\n        uint256 rAmount;\\n        uint256 periodInWeeks;\\n    }\\n\\n    function stake(uint256 amount, uint256 periodInWeeks) external;\\n\\n    function unstakeWithReward() external;\\n\\n    function unstakeWithoutReward() external;\\n\\n    function getPotentialNftReward(uint256 tokenAmount, uint256 periodInWeeks, address account) view external returns (uint256[] memory, uint256, uint256);\\n\\n    function changeMultiplier(uint256 periodInWeeks, uint256 value) external;\\n\\n    function getMinAmountToStake() external view returns (uint256);\\n\\n    function usersStaking(address) external view returns (UserStakingInfo memory);\\n\\n    function getActualNftReward(uint256 calculatedUsdtAmountForReward) view external returns (uint256[] memory);\\n}\\n\\ncontract REBLStakingV2 is IREBLStaking, Ownable {\\n    IREBLNFT public nftContract;\\n    using IterableMapping for IterableMapping.Map;\\n    IterableMapping.Map internal investors;\\n\\n    struct Rank {\\n        address account;\\n        uint256 multipliedValue;\\n    }\\n    IPancakeSwap public router;\\n    IPancakePair bnbTokenPair = IPancakePair(0x54d79E2c9A7fe6d40623Ee0Cc91BF970Ce6fC150);\\n    IPancakePair bnbUsdtPair = IPancakePair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);\\n\\n    address usdtAddress = 0x55d398326f99059fF775485246999027B3197955;\\n    address reblAddress = 0xbB8b7E9A870FbC22ce4b543fc3A43445Fbf9097f;\\n    address wbnbAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    IREBLStaking stakingV2 = IREBLStaking(0xC1b102872B2A85f09CfdC6723CF7506598112e82);\\n\\n    mapping(address => bool) public startedMigrating;\\n    mapping(address => bool) public finalizedMigrating;\\n\\n    mapping(uint256 => uint256) multiplierByWeekAmount;\\n    mapping(address => UserStakingInfo) public userStakingOf;\\n    mapping(address => UserStakingInfo) public tempUserStakingOf;\\n    uint256 constant MULTIPLIER_DENOMINATOR = 100;\\n     uint256 constant SECONDS_IN_WEEK = 1 weeks;\\n\\n    constructor(\\n        address _nftContractAddress\\n    ) {\\n        initDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        nftContract = IREBLNFT(_nftContractAddress);\\n        multiplierByWeekAmount[2] = 100;\\n        multiplierByWeekAmount[4] = 120;\\n        multiplierByWeekAmount[6] = 130;\\n        multiplierByWeekAmount[8] = 140;\\n        multiplierByWeekAmount[10] = 150;\\n        multiplierByWeekAmount[12] = 160;\\n        multiplierByWeekAmount[14] = 170;\\n        multiplierByWeekAmount[16] = 180;\\n        multiplierByWeekAmount[18] = 190;\\n        multiplierByWeekAmount[20] = 200;\\n    }\\n\\n    function getAllInvestors() external view returns(Rank[] memory) {\\n        Rank[] memory rank = new Rank[](investors.size());\\n        address user;\\n        for(uint256 index = 0; index < investors.size(); index++) {\\n            user = investors.keys[index];\\n            rank[index] = Rank(user, investors.values[user]);\\n        }\\n        return rank;\\n    }\\n\\n    function stake(uint256 amount, uint256 periodInWeeks) public override {\\n        require(periodInWeeks >= 2, \\\"Min period for staking is 2 weeks\\\");\\n        require(isEvenNumber(periodInWeeks), \\\"Period in weeks should be even number\\\");\\n\\n        uint256 initialBalance = IERC20Rebl(reblAddress).balanceOf(address(this));\\n        IERC20Rebl(reblAddress).transferFrom(msg.sender, address(this), amount);\\n        amount = IERC20Rebl(reblAddress).balanceOf(address(this)) - initialBalance;\\n\\n        uint256 calculatedUsdtAmountForReward = calculateUsdtAmountForReward(amount, periodInWeeks);\\n        uint256 calculatedUSDT = userStakingOf[msg.sender].usdtAmountForReward + calculatedUsdtAmountForReward;\\n        uint256 tokenAmount = userStakingOf[msg.sender].tokenAmount + amount;\\n        uint256 newRAmount = IERC20Rebl(reblAddress).reflectionFromToken(amount, false);\\n        uint256 rAmount = userStakingOf[msg.sender].rAmount + newRAmount;\\n        uint256 unstakeTimestamp = calculateUnstakeTimestamp(periodInWeeks);\\n        if (unstakeTimestamp < userStakingOf[msg.sender].rewardUnblockTimestamp) {\\n            unstakeTimestamp = userStakingOf[msg.sender].rewardUnblockTimestamp;\\n        }\\n        investors.set(msg.sender, calculatedUSDT);\\n        userStakingOf[msg.sender] = UserStakingInfo(unstakeTimestamp, calculatedUSDT, tokenAmount, rAmount, periodInWeeks);\\n    }\\n\\n    function startMigrating() external {\\n        require(!startedMigrating[msg.sender], \\\"Migrating already started\\\");\\n        UserStakingInfo memory infoV1 = stakingV2.usersStaking(msg.sender);\\n        require(infoV1.rewardUnblockTimestamp > block.timestamp, \\\"You don't have active stake\\\");\\n        tempUserStakingOf[msg.sender] = infoV1;\\n        startedMigrating[msg.sender] = true;\\n    }\\n\\n    function finalizeMigrating() external {\\n        require(!finalizedMigrating[msg.sender], \\\"Migrating already finalized\\\");\\n        IERC20Rebl rebl = IERC20Rebl(reblAddress);\\n        uint256 amount = tempUserStakingOf[msg.sender].tokenAmount;\\n        uint256 initialBalance = rebl.balanceOf(address(this));\\n        rebl.transferFrom(msg.sender, address(this), amount);\\n        require(rebl.balanceOf(address(this)) - initialBalance >= amount, \\\"Wrong transfer amount\\\");\\n        userStakingOf[msg.sender] = tempUserStakingOf[msg.sender];\\n        investors.set(msg.sender, tempUserStakingOf[msg.sender].usdtAmountForReward);\\n        finalizedMigrating[msg.sender] = true;\\n    }\\n\\n    function unstakeWithReward() public override {\\n        require(block.timestamp >= userStakingOf[msg.sender].rewardUnblockTimestamp, \\\"Reward is not available yet\\\");\\n        nftContract.mintToByAmount(msg.sender, userStakingOf[msg.sender].usdtAmountForReward);\\n        uint256 tokenAmount = IERC20Rebl(reblAddress).tokenFromReflection(userStakingOf[msg.sender].rAmount);\\n        IERC20Rebl(reblAddress).transfer(msg.sender, tokenAmount);\\n        _clearUserStaking(msg.sender);\\n    }\\n\\n    function unstakeWithoutReward() public override {\\n        uint256 tokenAmount = IERC20Rebl(reblAddress).tokenFromReflection(userStakingOf[msg.sender].rAmount);\\n        IERC20Rebl(reblAddress).transfer(msg.sender, tokenAmount);\\n        _clearUserStaking(msg.sender);\\n    }\\n\\n    function usersStaking(address account) external override view returns (UserStakingInfo memory) {\\n        return userStakingOf[account];\\n    }\\n\\n    function getPotentialNftReward(uint256 tokenAmount, uint256 periodInWeeks, address account) view public override returns (uint256[] memory, uint256, uint256) {\\n        uint256 calculatedUsdtAmountForReward = calculateUsdtAmountForReward(tokenAmount, periodInWeeks);\\n        uint256 unlockTimestamp = block.timestamp + periodInWeeks * SECONDS_IN_WEEK;\\n        if (userStakingOf[account].usdtAmountForReward > 0) {\\n            calculatedUsdtAmountForReward += userStakingOf[account].usdtAmountForReward;\\n            if (userStakingOf[account].rewardUnblockTimestamp > unlockTimestamp) {\\n                unlockTimestamp = userStakingOf[account].rewardUnblockTimestamp;\\n            }\\n        }\\n        return (getNftReward(calculatedUsdtAmountForReward), calculatedUsdtAmountForReward, unlockTimestamp);\\n    }\\n\\n    function getActualNftReward(uint256 calculatedUsdtAmountForReward) view public override returns (uint256[] memory) {\\n        uint256[] memory nftReward = getNftReward(calculatedUsdtAmountForReward);\\n        return nftReward;\\n    }\\n\\n    function getNftReward(uint256 calculatedUsdtAmountForReward) view internal returns (uint256[] memory) {\\n        uint256[] memory levelsUsdtValues = nftContract.getLevelsUsdtValues();\\n        uint256 lowestNftUsdtValue = nftContract.getLowestLevelUsdtValue();\\n        uint256[] memory levelsCount = new uint256[](levelsUsdtValues.length);\\n        while (calculatedUsdtAmountForReward >= lowestNftUsdtValue) {\\n            for (uint256 i = levelsUsdtValues.length; i > 0; i--) {\\n                if (calculatedUsdtAmountForReward >= levelsUsdtValues[i - 1]) {\\n                    levelsCount[i - 1]++;\\n                    calculatedUsdtAmountForReward -= levelsUsdtValues[i - 1];\\n                    break;\\n                }\\n            }\\n        }\\n        return levelsCount;\\n    }\\n\\n    function changeMultiplier(uint256 periodInWeeks, uint256 value) public override onlyOwner {\\n        multiplierByWeekAmount[periodInWeeks] = value;\\n    }\\n\\n    function updateNFTContract(address _newAddress) public  onlyOwner {\\n        nftContract = IREBLNFT(_newAddress);\\n    }\\n\\n    function _clearUserStaking(address userAddress) internal {\\n        userStakingOf[userAddress].usdtAmountForReward = 0;\\n        userStakingOf[userAddress].tokenAmount = 0;\\n        userStakingOf[userAddress].rAmount = 0;\\n        userStakingOf[userAddress].rewardUnblockTimestamp = 0;\\n        investors.remove(userAddress);\\n    }\\n\\n    function calculateMultiplier(uint256 periodInWeeks) view internal returns (uint256) {\\n        if (periodInWeeks > 18) {\\n            return multiplierByWeekAmount[20];\\n        }\\n        return multiplierByWeekAmount[periodInWeeks];\\n    }\\n\\n    function isEvenNumber(uint256 number) internal pure returns (bool) {\\n        uint256 div = number / 2;\\n        return div * 2 == number;\\n    }\\n\\n    function calculateUnstakeTimestamp(uint256 periodInWeeks) internal view returns (uint256) {\\n        return block.timestamp + periodInWeeks * SECONDS_IN_WEEK;\\n    }\\n\\n    function calculateUsdtAmountForReward(uint256 amount, uint256 periodInWeeks) public view returns (uint256) {\\n        uint256 multiplier = calculateMultiplier(periodInWeeks);\\n        return calculateTokensPriceInUSDT(amount) * multiplier * (periodInWeeks / 2) / MULTIPLIER_DENOMINATOR;\\n    }\\n\\n    function calculateTokensPriceInUSDT(uint256 tokenAmount) public view returns (uint256) {\\n        (uint256 token1Amount, uint256 token2Amount, ) = bnbTokenPair.getReserves();\\n        (uint256 tokenReserveForBnbPair, uint256 bnbReserve) = reblAddress < wbnbAddress ? (token1Amount, token2Amount) : (token2Amount, token1Amount);\\n        (uint256 token3Amount, uint256 token4Amount, ) = bnbUsdtPair.getReserves();\\n        (uint256 usdtReserve, uint256 bnbReserveForUsdtPair) = usdtAddress < wbnbAddress ? (token3Amount, token4Amount) : (token4Amount, token3Amount);\\n        return tokenAmount * bnbReserve / bnbReserveForUsdtPair * usdtReserve / tokenReserveForBnbPair;\\n    }\\n\\n    function calculateTokensAmountForUsdt(uint256 usdtAmount) public view returns (uint256) {\\n        (uint256 token1Amount, uint256 token2Amount, ) = bnbUsdtPair.getReserves();\\n        (uint256 usdtReserve, uint256 bnbReserveForUsdtPair) = usdtAddress < wbnbAddress ? (token1Amount, token2Amount) : (token2Amount, token1Amount);\\n        (uint256 token3Amount, uint256 token4Amount, ) = bnbTokenPair.getReserves();\\n        (uint256 tokenReserveForBnbPair, uint256 bnbReserve) = reblAddress < wbnbAddress ? (token3Amount, token4Amount) : (token4Amount, token3Amount);\\n        return usdtAmount * bnbReserveForUsdtPair / usdtReserve * tokenReserveForBnbPair / bnbReserve;\\n    }\\n\\n    function initDEXRouter(address _router) public onlyOwner {\\n        IPancakeSwap _pancakeV2Router = IPancakeSwap(_router);\\n        router = _pancakeV2Router;\\n    }\\n\\n    function getMinAmountToStake() public view override returns (uint256) {\\n        return calculateTokensAmountForUsdt(nftContract.getLowestLevelUsdtValue());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Rebl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Rebl {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /*\\n     * To get rAmount by tAmount form token contract.\\n    */\\n    function reflectionFromToken(\\n        uint256 tAmount,\\n        bool deductTransferFee\\n    ) external view returns(uint256);\\n    /*\\n     * To get tAmount by rAmount form token contract.\\n    */\\n    function tokenFromReflection(uint256 rAmount) external view returns(uint256);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IREBLNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IREBLNFT {\\n    function mintToByAmount(address to, uint256 usdtAmount) external;\\n    function mintToByOwner(address to, uint256 level) external;\\n    function getLevelsUsdtValues() external view returns (uint256[] memory);\\n    function getLowestLevelUsdtValue() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/libs/IterableMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary IterableMapping {\\n    struct Map {\\n        address[] keys;\\n        mapping(address => uint) values;\\n        mapping(address => uint) indexOf;\\n        mapping(address => bool) inserted;\\n    }\\n\\n    function get(Map storage map, address key) public view returns (uint) {\\n        return map.values[key];\\n    }\\n\\n    function getIndexOfKey(Map storage map, address key) public view returns (int) {\\n        if(!map.inserted[key]) {\\n            return -1;\\n        }\\n        return int(map.indexOf[key]);\\n    }\\n\\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\\n        return map.keys[index];\\n    }\\n\\n\\n\\n    function size(Map storage map) public view returns (uint) {\\n        return map.keys.length;\\n    }\\n\\n    function set(Map storage map, address key, uint val) public {\\n        if (map.inserted[key]) {\\n            map.values[key] = val;\\n        } else {\\n            map.inserted[key] = true;\\n            map.values[key] = val;\\n            map.indexOf[key] = map.keys.length;\\n            map.keys.push(key);\\n        }\\n    }\\n\\n    function remove(Map storage map, address key) public {\\n        if (!map.inserted[key]) {\\n            return;\\n        }\\n\\n        delete map.inserted[key];\\n        delete map.values[key];\\n\\n        uint index = map.indexOf[key];\\n        uint lastIndex = map.keys.length - 1;\\n        address lastKey = map.keys[lastIndex];\\n\\n        map.indexOf[lastKey] = index;\\n        delete map.indexOf[key];\\n\\n        map.keys[index] = lastKey;\\n        map.keys.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libs/IterableMapping.sol\": {\r\n        \"IterableMapping\": \"0x57cfe933c1af5ee19b572b16da2ca2c19545dd39\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"calculateTokensAmountForUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"calculateTokensPriceInUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodInWeeks\",\"type\":\"uint256\"}],\"name\":\"calculateUsdtAmountForReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodInWeeks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changeMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeMigrating\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"finalizedMigrating\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"calculatedUsdtAmountForReward\",\"type\":\"uint256\"}],\"name\":\"getActualNftReward\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllInvestors\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"multipliedValue\",\"type\":\"uint256\"}],\"internalType\":\"struct REBLStakingV2.Rank[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinAmountToStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodInWeeks\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPotentialNftReward\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"initDEXRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"contract IREBLNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodInWeeks\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startMigrating\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"startedMigrating\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tempUserStakingOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardUnblockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtAmountForReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodInWeeks\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeWithReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeWithoutReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateNFTContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStakingOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardUnblockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtAmountForReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodInWeeks\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"usersStaking\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rewardUnblockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtAmountForReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodInWeeks\",\"type\":\"uint256\"}],\"internalType\":\"struct IREBLStaking.UserStakingInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "REBLStakingV2", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ffedd14be5768c2852328d0a51c613db2ba2322d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}