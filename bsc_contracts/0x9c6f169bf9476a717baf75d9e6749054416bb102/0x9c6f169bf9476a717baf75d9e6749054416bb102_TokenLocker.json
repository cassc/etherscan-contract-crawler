{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBEP20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract TokenLocker {\r\n    IBEP20 public token;\r\n    struct Lock {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    enum LockPeriod { Minutes2, Days7, Days14, Days30 }\r\n    uint256 constant DAY_IN_SECONDS = 86400;\r\n    uint256 constant MINUTE_IN_SECONDS = 60;\r\n\r\n    mapping(address => Lock[]) public locks;\r\n    mapping(address => bool) public lockStatus; // Mapping to track lock status\r\n    address[] private lockOwners;\r\n\r\n    // Hardcoded token address\r\n    address private constant TOKEN_ADDRESS = 0xcD7de9252c9F8B7626a923b7f92B19321b626894;\r\n\r\n    constructor() {\r\n        token = IBEP20(TOKEN_ADDRESS);\r\n    }\r\n\r\n    function lockTokens(uint256 _amount, LockPeriod _lockPeriod) external {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        uint256 lockDuration;\r\n\r\n        if (_lockPeriod == LockPeriod.Minutes2) {\r\n            lockDuration = 2 * MINUTE_IN_SECONDS;\r\n        } else if (_lockPeriod == LockPeriod.Days7) {\r\n            lockDuration = 7 * DAY_IN_SECONDS;\r\n        } else if (_lockPeriod == LockPeriod.Days14) {\r\n            lockDuration = 14 * DAY_IN_SECONDS;\r\n        } else if (_lockPeriod == LockPeriod.Days30) {\r\n            lockDuration = 30 * DAY_IN_SECONDS;\r\n        } else {\r\n            revert(\"Invalid lock period\");\r\n        }\r\n\r\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\");\r\n        \r\n        uint256 unlockTime = block.timestamp + lockDuration;\r\n        locks[msg.sender].push(Lock(_amount, unlockTime));\r\n        lockStatus[msg.sender] = true; // Set lock status to true\r\n\r\n        if (!_isAlreadyAdded(msg.sender)) {\r\n            lockOwners.push(msg.sender);\r\n        }\r\n    }\r\n\r\n    function releaseTokens(uint256 _lockIndex) external {\r\n        Lock storage lock = locks[msg.sender][_lockIndex];\r\n        require(block.timestamp >= lock.unlockTime, \"Tokens are still locked\");\r\n\r\n        require(token.transfer(msg.sender, lock.amount), \"Transfer failed\");\r\n        delete locks[msg.sender][_lockIndex];\r\n        lockStatus[msg.sender] = false; // Set lock status to false\r\n    }\r\n\r\n    function getLockInfo(address _user, uint256 _lockIndex) external view returns (uint256 amount, uint256 unlockTime) {\r\n        Lock storage lock = locks[_user][_lockIndex];\r\n        return (lock.amount, lock.unlockTime);\r\n    }\r\n\r\n    function _isAlreadyAdded(address _user) private view returns (bool) {\r\n        for (uint i = 0; i < lockOwners.length; i++) {\r\n            if (lockOwners[i] == _user) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\nfunction getAllLockOwners() external view returns (address[] memory, uint256[] memory) {\r\n    uint256[] memory totalLockedAmounts = new uint256[](lockOwners.length);\r\n\r\n    for (uint i = 0; i < lockOwners.length; i++) {\r\n        uint256 totalLocked = 0;\r\n        Lock[] storage userLocks = locks[lockOwners[i]];\r\n        for (uint j = 0; j < userLocks.length; j++) {\r\n            if (block.timestamp < userLocks[j].unlockTime) {\r\n                totalLocked += userLocks[j].amount;\r\n            }\r\n        }\r\n        totalLockedAmounts[i] = totalLocked;\r\n    }\r\n\r\n    return (lockOwners, totalLockedAmounts);\r\n}\r\n\r\n    function getLockCount(address _user) external view returns (uint256) {\r\n    return locks[_user].length;\r\n}\r\n\r\n\r\n    function approveToken(IBEP20 _token, uint256 _amount) external {\r\n    require(_token.approve(address(this), _amount), \"Token approval failed\");\r\n}\r\n\r\nfunction _removeLockOwner(address _user) private {\r\n    for (uint i = 0; i < lockOwners.length; i++) {\r\n        if (lockOwners[i] == _user) {\r\n            lockOwners[i] = lockOwners[lockOwners.length - 1];\r\n            lockOwners.pop();\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllLockOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"getLockInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum TokenLocker.LockPeriod\",\"name\":\"_lockPeriod\",\"type\":\"uint8\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockIndex\",\"type\":\"uint256\"}],\"name\":\"releaseTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenLocker", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1da2b0ae8ed9e9cfd3f43146b8619e26f3d80c62a205761c170a613486dbba16"}