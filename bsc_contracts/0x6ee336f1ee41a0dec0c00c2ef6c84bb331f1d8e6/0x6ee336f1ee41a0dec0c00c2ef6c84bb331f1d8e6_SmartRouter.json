{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BaseCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./libs/Pausable.sol\\\";\\r\\nimport \\\"./libs/ReentrancyGuard.sol\\\";\\r\\nimport \\\"./libs/TransferHelper.sol\\\";\\r\\nimport \\\"./libs/RevertReasonParser.sol\\\";\\r\\nimport \\\"./libs/SafeMath.sol\\\";\\r\\nimport \\\"./libs/Ownable.sol\\\";\\r\\nimport \\\"./interfaces/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV3Pool.sol\\\";\\r\\n\\r\\ncontract BaseCore is Ownable, Pausable, ReentrancyGuard {\\r\\n    using SafeMath for uint;\\r\\n    struct ExactInputV2SwapParams {\\r\\n        address dstReceiver; //to\\r\\n        address wrappedToken; //gasToken\\r\\n        address router; //router\\r\\n        uint amount; //amountIn\\r\\n        uint minReturnAmount; //minAmountOut\\r\\n        uint deadline; //deadline\\r\\n        address[] path;\\r\\n        address[] pool;\\r\\n    }\\r\\n\\r\\n    struct ExactInputV3SwapParams {\\r\\n        address srcToken; //fromToken\\r\\n        address dstToken; //toToken\\r\\n        address dstReceiver; //to\\r\\n        address wrappedToken; //gasToken\\r\\n        uint amount; //amountIn\\r\\n        uint minReturnAmount; //minAmountOut\\r\\n        uint deadline; //deadline\\r\\n        address[] pools;\\r\\n    }\\r\\n\\r\\n    struct UniswapV3Pool {\\r\\n        bool status;\\r\\n        address factory;\\r\\n        bytes initCodeHash;\\r\\n    }\\r\\n\\r\\n    uint public _aggregate_fee = 30;\\r\\n    uint public factoryListLength;\\r\\n    mapping(address => bool) public _wrapped_allowed;\\r\\n    mapping(uint => UniswapV3Pool) public allowedFactoryInitCodeHashList;\\r\\n    mapping(address => bool) public WList;\\r\\n    mapping(address => bool) public BList;\\r\\n    mapping(address => bool) public WPoolList;\\r\\n\\r\\n    event Receipt(uint time, address from, uint amount);\\r\\n    event Withdraw(address indexed token, address indexed executor, address indexed recipient, uint amount);\\r\\n    event setV3FactoryListEvent(uint[] poolIndex, address[] factories, bytes[] initCodeHash);\\r\\n    event SwapEvent(address srcToken, address dstToken, address dstReceiver, uint amount, uint returnAmount, uint _timestamp, uint _blockNumber);\\r\\n    event _verifyCallbackEvent(address _pool, bytes32 _poolSalt, address _caller, address _calcPool, address _poolFactory, address _matchFactory);\\r\\n\\r\\n    constructor() Ownable(msg.sender) {}\\r\\n\\r\\n    function calculateTradeFee(uint tradeAmount, uint fee, address _fromToken, address _toToken, address _to) internal view returns (uint) {\\r\\n        require(!BList[_fromToken] && !BList[_toToken] && !BList[_to] && !BList[msg.sender], \\\"Unacceptable address\\\");\\r\\n        return (WList[_fromToken] || WList[_toToken] || WList[_to]) ? tradeAmount : tradeAmount.sub(fee);\\r\\n    }\\r\\n\\r\\n    function _emitSwapEvent(address _srcToken, address _dstToken, address _dstReceiver, uint _amount, uint _returnAmount, uint _timestamp, uint _blockNumber) internal {\\r\\n        emit SwapEvent(\\r\\n            _srcToken,\\r\\n            _dstToken,\\r\\n            _dstReceiver,\\r\\n            _amount,\\r\\n            _returnAmount,\\r\\n            _timestamp,\\r\\n            _blockNumber\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setAggregateFee(uint newRate) external onlyExecutor {\\r\\n        require(newRate >= 0 && newRate <= 1000, \\\"fee rate is:0-1000\\\");\\r\\n        _aggregate_fee = newRate;\\r\\n    }\\r\\n\\r\\n    //whitelist\\r\\n    function setWList(address[] memory _addressList, bool _status) external onlyExecutor {\\r\\n        uint _num = _addressList.length;\\r\\n        for (uint i = 0; i < _num; i++) {\\r\\n            WList[_addressList[i]] = _status;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //blacklist\\r\\n    function setBList(address[] memory _addressList, bool _status) external onlyExecutor {\\r\\n        uint _num = _addressList.length;\\r\\n        for (uint i = 0; i < _num; i++) {\\r\\n            BList[_addressList[i]] = _status;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setWPoolList(address[] memory _addressList, bool _status) external onlyExecutor {\\r\\n        uint _num = _addressList.length;\\r\\n        for (uint i = 0; i < _num; i++) {\\r\\n            WPoolList[_addressList[i]] = _status;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setWrappedTokensList(address[] calldata wrappedTokens, bool _status) public onlyExecutor {\\r\\n        uint _num = wrappedTokens.length;\\r\\n        for (uint i = 0; i < _num; i++) {\\r\\n            _wrapped_allowed[wrappedTokens[i]] = _status;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setV3FactoryList(uint[] memory indexList, address[] calldata factories, bytes[] calldata initCodeHash, bool _status) public onlyExecutor {\\r\\n        require(factories.length == initCodeHash.length, \\\"invalid data\\\");\\r\\n        uint len = factories.length;\\r\\n        factoryListLength = len;\\r\\n        for (uint i = 0; i < len; i++) {\\r\\n            uint index = indexList[i];\\r\\n            require(index == i, \\\"invalid Index\\\");\\r\\n            allowedFactoryInitCodeHashList[index] = UniswapV3Pool({\\r\\n                status: _status,\\r\\n                factory: factories[i],\\r\\n                initCodeHash: initCodeHash[i]\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setPause(bool paused) external onlyExecutor {\\r\\n        if (paused) {\\r\\n            _pause();\\r\\n        } else {\\r\\n            _unpause();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        emit Receipt(block.timestamp, msg.sender, msg.value);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.9;\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function balanceOf(address account) external view returns (uint);\\r\\n    function transfer(address recipient, uint amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.9;\\r\\n\\r\\ninterface IUniswapV2 {\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n\\r\\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IUniswapV3Pool {\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function fee() external view returns (uint24);\\r\\n\\r\\n    function swap(\\r\\n        address recipient,\\r\\n        bool zeroForOne,\\r\\n        int256 amountSpecified,\\r\\n        uint160 sqrtPriceLimitX96,\\r\\n        bytes calldata data\\r\\n    ) external returns (int256 amount0, int256 amount1);\\r\\n}\"\r\n    },\r\n    \"contracts/libs/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n// Add executor extension\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable {\\r\\n\\r\\n    address private _executor;\\r\\n    address private _pendingExecutor;\\r\\n    bool internal _initialized;\\r\\n\\r\\n    event ExecutorshipTransferStarted(address indexed previousExecutor, address indexed newExecutor);\\r\\n    event ExecutorshipTransferred(address indexed previousExecutor, address indexed newExecutor);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor(address newExecutor) {\\r\\n        require(!_initialized, \\\"Ownable: initialized\\\");\\r\\n        _transferExecutorship(newExecutor);\\r\\n        _initialized = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the executor.\\r\\n     */\\r\\n    modifier onlyExecutor() {\\r\\n        _checkExecutor();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current executor.\\r\\n     */\\r\\n    function executor() public view virtual returns (address) {\\r\\n        return _executor;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the pending executor.\\r\\n     */\\r\\n    function pendingExecutor() public view virtual returns (address) {\\r\\n        return _pendingExecutor;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the executor.\\r\\n     */\\r\\n    function _checkExecutor() internal view virtual {\\r\\n        require(executor() == msg.sender, \\\"Ownable: caller is not the executor\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers executorship of the contract to a new account (`newExecutor`).\\r\\n     * Can only be called by the current executor.\\r\\n     */\\r\\n    function transferExecutorship(address newExecutor) public virtual onlyExecutor {\\r\\n        _pendingExecutor = newExecutor;\\r\\n        emit ExecutorshipTransferStarted(executor(), newExecutor);\\r\\n    }\\r\\n\\r\\n    function _transferExecutorship(address newExecutor) internal virtual {\\r\\n        delete _pendingExecutor;\\r\\n        address oldExecutor = _executor;\\r\\n        _executor = newExecutor;\\r\\n        emit ExecutorshipTransferred(oldExecutor, newExecutor);\\r\\n    }\\r\\n\\r\\n    function acceptExecutorship() external {\\r\\n        address sender = msg.sender;\\r\\n        require(pendingExecutor() == sender, \\\"Ownable: caller is not the new executor\\\");\\r\\n        _transferExecutorship(sender);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libs/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        _requireNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        _requirePaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is paused.\\r\\n     */\\r\\n    function _requireNotPaused() internal view virtual {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is not paused.\\r\\n     */\\r\\n    function _requirePaused() internal view virtual {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(msg.sender);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libs/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint private constant _NOT_ENTERED = 1;\\r\\n    uint private constant _ENTERED = 2;\\r\\n\\r\\n    uint private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n        assembly {\\r\\n            sstore(_status.slot, _ENTERED)\\r\\n        }\\r\\n        _;\\r\\n        assembly {\\r\\n            sstore(_status.slot, _NOT_ENTERED)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libs/RevertReasonParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\nlibrary RevertReasonParser {\\r\\n    function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {\\r\\n        // https://solidity.readthedocs.io/en/latest/control-structures.html#revert\\r\\n        // We assume that revert reason is abi-encoded as Error(string)\\r\\n\\r\\n        // 68 = 4-byte selector 0x08c379a0 + 32 bytes offset + 32 bytes length\\r\\n        if (data.length >= 68 && data[0] == \\\"\\\\x08\\\" && data[1] == \\\"\\\\xc3\\\" && data[2] == \\\"\\\\x79\\\" && data[3] == \\\"\\\\xa0\\\") {\\r\\n            string memory reason;\\r\\n            // solhint-disable no-inline-assembly\\r\\n            assembly {\\r\\n            // 68 = 32 bytes data length + 4-byte selector + 32 bytes offset\\r\\n                reason := add(data, 68)\\r\\n            }\\r\\n            /*\\r\\n                revert reason is padded up to 32 bytes with ABI encoder: Error(string)\\r\\n                also sometimes there is extra 32 bytes of zeros padded in the end:\\r\\n                https://github.com/ethereum/solidity/issues/10170\\r\\n                because of that we can't check for equality and instead check\\r\\n                that string length + extra 68 bytes is less than overall data length\\r\\n            */\\r\\n            require(data.length >= 68 + bytes(reason).length, \\\"Invalid revert reason\\\");\\r\\n            return string(abi.encodePacked(prefix, \\\"Error(\\\", reason, \\\")\\\"));\\r\\n        }\\r\\n        // 36 = 4-byte selector 0x4e487b71 + 32 bytes integer\\r\\n        else if (data.length == 36 && data[0] == \\\"\\\\x4e\\\" && data[1] == \\\"\\\\x48\\\" && data[2] == \\\"\\\\x7b\\\" && data[3] == \\\"\\\\x71\\\") {\\r\\n            uint code;\\r\\n            // solhint-disable no-inline-assembly\\r\\n            assembly {\\r\\n            // 36 = 32 bytes data length + 4-byte selector\\r\\n                code := mload(add(data, 36))\\r\\n            }\\r\\n            return string(abi.encodePacked(prefix, \\\"Panic(\\\", _toHex(code), \\\")\\\"));\\r\\n        }\\r\\n\\r\\n        return string(abi.encodePacked(prefix, \\\"Unknown(\\\", _toHex(data), \\\")\\\"));\\r\\n    }\\r\\n\\r\\n    function _toHex(uint value) private pure returns (string memory) {\\r\\n        return _toHex(abi.encodePacked(value));\\r\\n    }\\r\\n\\r\\n    function _toHex(bytes memory data) private pure returns (string memory) {\\r\\n        bytes16 alphabet = 0x30313233343536373839616263646566;\\r\\n        bytes memory str = new bytes(2 + data.length * 2);\\r\\n        str[0] = \\\"0\\\";\\r\\n        str[1] = \\\"x\\\";\\r\\n        for (uint i = 0; i < data.length; i++) {\\r\\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\\r\\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\\r\\n        }\\r\\n        return string(str);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\r\\n    }\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\r\\n    }\\r\\n\\r\\n    function div(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y != 0 , 'ds-math-div-zero');\\r\\n        z = x / y;\\r\\n    }\\r\\n\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\r\\n        return int256(value);\\r\\n    }\\r\\n\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\r\\n        return uint256(value);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libs/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nlibrary TransferHelper {\\r\\n\\r\\n    address private constant _ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\r\\n    address private constant _ZERO_ADDRESS = address(0);\\r\\n\\r\\n    function getEthAddress() external view returns (address) {\\r\\n        uint chainId = block.chainid;\\r\\n        if (chainId == 1) {\\r\\n            return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n        } else if (chainId == 5) {\\r\\n            return 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6;\\r\\n        } else if (chainId == 42161) {\\r\\n            return 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\\r\\n        } else if (chainId == 421613) {\\r\\n            return 0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3;\\r\\n        } else if (chainId == 137) {\\r\\n            return 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\\r\\n        } else if (chainId == 80001) {\\r\\n            return 0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889;\\r\\n        } else if (chainId == 56) {\\r\\n            return 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\r\\n        } else if (chainId == 97) {\\r\\n            return 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\r\\n        } else if (chainId == 204) {\\r\\n            return 0x4200000000000000000000000000000000000006;\\r\\n        } else if (chainId == 5611) {\\r\\n            return 0x617d91847b74B70a3D3e3745445cb0d1b3c8560E;\\r\\n        } else if (chainId == 324) {\\r\\n            return 0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91;\\r\\n        } else if (chainId == 8453) {\\r\\n            return 0x4200000000000000000000000000000000000006;\\r\\n        } else if (chainId == 369) {\\r\\n            return 0xA1077a294dDE1B09bB078844df40758a5D0f9a27;\\r\\n        } else {\\r\\n            return 0x4200000000000000000000000000000000000006;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isETH(address token) internal pure returns (bool) {\\r\\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\\r\\n    }\\r\\n\\r\\n    function safeApprove(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_TOKEN_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferWithoutRequire(address token, address to, uint value) internal returns (bool) {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint value) internal {\\r\\n        // solium-disable-next-line\\r\\n        (bool success,) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'TransferHelper: TRANSFER_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeDeposit(address wrapped, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('deposit()')));\\r\\n        (bool success, bytes memory data) = wrapped.call{value: value}(abi.encodeWithSelector(0xd0e30db0));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: DEPOSIT_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeWithdraw(address wrapped, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('withdraw(uint wad)')));\\r\\n        (bool success, bytes memory data) = wrapped.call{value: 0}(abi.encodeWithSelector(0x2e1a7d4d, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: WITHDRAW_FAILED');\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/SmartRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./UniswapV2Router.sol\\\";\\r\\nimport \\\"./UniswapV3Router.sol\\\";\\r\\n\\r\\ncontract SmartRouter is UniswapV2Router, UniswapV3Router {\\r\\n    function withdrawTokens(address[] memory tokens, address recipient) external onlyExecutor {\\r\\n        for (uint index; index < tokens.length; index++) {\\r\\n            uint amount;\\r\\n            if (TransferHelper.isETH(tokens[index])) {\\r\\n                amount = address(this).balance;\\r\\n                TransferHelper.safeTransferETH(recipient, amount);\\r\\n            } else {\\r\\n                amount = IERC20(tokens[index]).balanceOf(address(this));\\r\\n                TransferHelper.safeTransferWithoutRequire(tokens[index], recipient, amount);\\r\\n            }\\r\\n            emit Withdraw(tokens[index], msg.sender, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/UniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./BaseCore.sol\\\";\\r\\n\\r\\ncontract UniswapV2Router is BaseCore {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    struct BeforeSwapItem {\\r\\n        uint fee;\\r\\n        address[] path;\\r\\n        address srcToken;\\r\\n        address dstToken;\\r\\n    }\\r\\n\\r\\n    function _beforeSwap(ExactInputV2SwapParams calldata exactInput) internal returns (bool isFromETH, bool isToETH, uint actualAmountIn, address[] memory paths, uint thisAddressBeforeBalance, uint toBeforeBalance) {\\r\\n        BeforeSwapItem memory kk;\\r\\n        kk.fee = exactInput.amount.mul(_aggregate_fee).div(10000);\\r\\n        require(exactInput.path.length == exactInput.pool.length + 1, \\\"Invalid path\\\");\\r\\n        require(_wrapped_allowed[exactInput.wrappedToken], \\\"Invalid wrapped address\\\");\\r\\n        kk.path = exactInput.path;\\r\\n        kk.srcToken = exactInput.path[0];\\r\\n        kk.dstToken = kk.path[exactInput.path.length - 1];\\r\\n        actualAmountIn = calculateTradeFee(exactInput.amount, kk.fee, kk.srcToken, kk.dstToken, exactInput.dstReceiver);\\r\\n        if (TransferHelper.isETH(kk.srcToken)) {\\r\\n            isFromETH = true;\\r\\n            require(msg.value == exactInput.amount, \\\"Invalid msg.value\\\");\\r\\n            kk.path[0] = exactInput.wrappedToken;\\r\\n            TransferHelper.safeDeposit(exactInput.wrappedToken, actualAmountIn);\\r\\n        } else {\\r\\n            isFromETH = false;\\r\\n            if (kk.fee > 0) {\\r\\n                TransferHelper.safeTransferFrom(kk.srcToken, msg.sender, address(this), kk.fee);\\r\\n            }\\r\\n        }\\r\\n        if (TransferHelper.isETH(kk.dstToken)) {\\r\\n            kk.path[kk.path.length - 1] = exactInput.wrappedToken;\\r\\n            isToETH = true;\\r\\n            thisAddressBeforeBalance = IERC20(exactInput.wrappedToken).balanceOf(address(this));\\r\\n        } else {\\r\\n            isToETH = false;\\r\\n            toBeforeBalance = IERC20(kk.dstToken).balanceOf(exactInput.dstReceiver);\\r\\n        }\\r\\n        paths = kk.path;\\r\\n    }\\r\\n\\r\\n    function exactInputV2SwapAndGasUsed(ExactInputV2SwapParams calldata exactInput) external payable returns (uint returnAmount, uint gasUsed) {\\r\\n        uint gasLeftBefore = gasleft();\\r\\n        returnAmount = _executeV2Swap(exactInput);\\r\\n        gasUsed = gasLeftBefore - gasleft();\\r\\n    }\\r\\n\\r\\n    function exactInputV2Swap(ExactInputV2SwapParams calldata exactInput) external payable returns (uint returnAmount) {\\r\\n        returnAmount = _executeV2Swap(exactInput);\\r\\n    }\\r\\n\\r\\n    function _executeV2Swap(ExactInputV2SwapParams calldata exactInput) internal nonReentrant whenNotPaused returns (uint returnAmount) {\\r\\n        require(exactInput.deadline >= block.timestamp, \\\"Expired\\\");\\r\\n        address _router = exactInput.router;\\r\\n        {\\r\\n            (bool isFromETH, bool isToETH, uint actualAmountIn, address[] memory paths, uint thisAddressBeforeBalance, uint toBeforeBalance) = _beforeSwap(exactInput);\\r\\n            if (isFromETH) {\\r\\n                TransferHelper.safeTransfer(paths[0], exactInput.pool[0], actualAmountIn);\\r\\n            } else {\\r\\n                TransferHelper.safeTransferFrom(paths[0], msg.sender, exactInput.pool[0], actualAmountIn);\\r\\n            }\\r\\n            if (isToETH) {\\r\\n                _swapSupportingFeeOnTransferTokens(_router, paths, exactInput.pool, address(this));\\r\\n                returnAmount = IERC20(exactInput.wrappedToken).balanceOf(address(this)).sub(thisAddressBeforeBalance);\\r\\n            } else {\\r\\n                _swapSupportingFeeOnTransferTokens(_router, paths, exactInput.pool, exactInput.dstReceiver);\\r\\n                returnAmount = IERC20(paths[paths.length - 1]).balanceOf(exactInput.dstReceiver).sub(toBeforeBalance);\\r\\n            }\\r\\n            require(returnAmount >= exactInput.minReturnAmount, \\\"Too little received\\\");\\r\\n            if (isToETH) {\\r\\n                TransferHelper.safeWithdraw(exactInput.wrappedToken, returnAmount);\\r\\n                TransferHelper.safeTransferETH(exactInput.dstReceiver, returnAmount);\\r\\n            }\\r\\n        }\\r\\n        _emitSwapEvent(exactInput.path[0], exactInput.path[exactInput.path.length - 1], exactInput.dstReceiver, exactInput.amount, returnAmount, block.timestamp, block.number);\\r\\n    }\\r\\n\\r\\n    function _swap(uint[] memory amounts, address[] memory path, address[] memory pool, address _to) internal {\\r\\n        for (uint i; i < path.length - 1; i++) {\\r\\n            (address input, address output) = (path[i], path[i + 1]);\\r\\n            (address token0,) = input < output ? (input, output) : (output, input);\\r\\n            uint amountOut = amounts[i + 1];\\r\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\r\\n            address to = i < path.length - 2 ? pool[i + 1] : _to;\\r\\n            IUniswapV2(pool[i]).swap(\\r\\n                amount0Out, amount1Out, to, new bytes(0)\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _swapSupportingFeeOnTransferTokens(address router, address[] memory path, address[] memory pool, address _to) internal virtual {\\r\\n        for (uint i; i < path.length - 1; i++) {\\r\\n            (address input, address output) = (path[i], path[i + 1]);\\r\\n            address[] memory _path = new  address[](2);\\r\\n            _path[0] = input;\\r\\n            _path[1] = output;\\r\\n            (address token0,) = input < output ? (input, output) : (output, input);\\r\\n            IUniswapV2 pair = IUniswapV2(pool[i]);\\r\\n            uint amountInput;\\r\\n            uint amountOutput;\\r\\n            {\\r\\n                (uint reserve0, uint reserve1,) = pair.getReserves();\\r\\n                //(uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n                (uint reserveInput,) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\\r\\n                //amountOutput = IUniswapV2(router).getAmountOut(amountInput, reserveInput, reserveOutput);\\r\\n                amountOutput = (IUniswapV2(router).getAmountsOut(amountInput, _path))[1];\\r\\n            }\\r\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\\r\\n            address to = i < path.length - 2 ? pool[i + 1] : _to;\\r\\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/UniswapV3Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./BaseCore.sol\\\";\\r\\n\\r\\ncontract UniswapV3Router is BaseCore {\\r\\n\\r\\n    using SafeMath for uint;\\r\\n    uint160 private constant MIN_SQRT_RATIO = 4295128739;\\r\\n    uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\r\\n\\r\\n    fallback() external {\\r\\n        (int256 amount0Delta, int256 amount1Delta, bytes memory _data) = abi.decode(msg.data[4 :], (int256, int256, bytes));\\r\\n        _executeCallback(amount0Delta, amount1Delta, _data);\\r\\n    }\\r\\n\\r\\n    function pancakeV3SwapCallback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes calldata _data\\r\\n    ) external {\\r\\n        _executeCallback(amount0Delta, amount1Delta, _data);\\r\\n    }\\r\\n\\r\\n    function uniswapV3SwapCallback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes calldata _data\\r\\n    ) external {\\r\\n        _executeCallback(amount0Delta, amount1Delta, _data);\\r\\n    }\\r\\n\\r\\n    function _executeCallback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes memory _data\\r\\n    ) internal {\\r\\n        require(amount0Delta > 0 || amount1Delta > 0, \\\"M0 or M1\\\"); // swaps entirely within 0-liquidity regions are not supported\\r\\n        (address pool, bytes memory tokenInAndPoolSalt) = abi.decode(_data, (address, bytes));\\r\\n        (address tokenIn, bytes32 poolSalt,address factory) = abi.decode(tokenInAndPoolSalt, (address, bytes32, address));\\r\\n        _verifyCallback(pool, poolSalt, msg.sender, factory);\\r\\n        uint amountToPay = uint(amount1Delta);\\r\\n        if (amount0Delta > 0) {\\r\\n            amountToPay = uint(amount0Delta);\\r\\n        }\\r\\n        TransferHelper.safeTransfer(tokenIn, msg.sender, amountToPay);\\r\\n    }\\r\\n\\r\\n    function exactInputV3SwapAndGasUsed(ExactInputV3SwapParams calldata params) external payable returns (uint returnAmount, uint gasUsed) {\\r\\n        uint gasLeftBefore = gasleft();\\r\\n        returnAmount = _executeV3Swap(params);\\r\\n        gasUsed = gasLeftBefore - gasleft();\\r\\n\\r\\n    }\\r\\n\\r\\n    function exactInputV3Swap(ExactInputV3SwapParams calldata params) external payable returns (uint returnAmount) {\\r\\n        returnAmount = _executeV3Swap(params);\\r\\n    }\\r\\n\\r\\n    function _executeV3Swap(ExactInputV3SwapParams calldata params) internal nonReentrant whenNotPaused returns (uint returnAmount) {\\r\\n        uint fee = params.amount.mul(_aggregate_fee).div(10000);\\r\\n        require(params.pools.length > 0, \\\"Empty pools\\\");\\r\\n        require(params.deadline >= block.timestamp, \\\"Expired\\\");\\r\\n        require(_wrapped_allowed[params.wrappedToken], \\\"Invalid wrapped address\\\");\\r\\n        address tokenIn = params.srcToken;\\r\\n        address tokenOut = params.dstToken;\\r\\n        uint actualAmountIn = calculateTradeFee(params.amount, fee, tokenIn, tokenOut, params.dstReceiver);\\r\\n        uint toBeforeBalance;\\r\\n        bool isToETH;\\r\\n        if (TransferHelper.isETH(params.srcToken)) {\\r\\n            tokenIn = params.wrappedToken;\\r\\n            require(msg.value == params.amount, \\\"Invalid msg.value\\\");\\r\\n            TransferHelper.safeDeposit(params.wrappedToken, actualAmountIn);\\r\\n        } else {\\r\\n            TransferHelper.safeTransferFrom(params.srcToken, msg.sender, address(this), params.amount);\\r\\n        }\\r\\n        if (TransferHelper.isETH(params.dstToken)) {\\r\\n            tokenOut = params.wrappedToken;\\r\\n            toBeforeBalance = IERC20(params.wrappedToken).balanceOf(address(this));\\r\\n            isToETH = true;\\r\\n        } else {\\r\\n            toBeforeBalance = IERC20(params.dstToken).balanceOf(params.dstReceiver);\\r\\n        }\\r\\n        {\\r\\n            uint len = params.pools.length;\\r\\n            address recipient = address(this);\\r\\n            bytes memory tokenInAndPoolSalt;\\r\\n            bool _zeroForOne;\\r\\n            if (len > 1) {\\r\\n                address thisTokenIn = tokenIn;\\r\\n                address thisTokenOut = address(0);\\r\\n                for (uint i; i < len; i++) {\\r\\n                    address thisPool = params.pools[i];\\r\\n                    (thisTokenIn, tokenInAndPoolSalt, _zeroForOne) = _verifyPool(thisTokenIn, thisTokenOut, thisPool);\\r\\n                    if (i == len - 1 && !isToETH) {\\r\\n                        recipient = params.dstReceiver;\\r\\n                        thisTokenOut = tokenOut;\\r\\n                    }\\r\\n                    actualAmountIn = _swap(recipient, thisPool, tokenInAndPoolSalt, actualAmountIn, _zeroForOne);\\r\\n                }\\r\\n                returnAmount = actualAmountIn;\\r\\n            } else {\\r\\n                (, tokenInAndPoolSalt, _zeroForOne) = _verifyPool(tokenIn, tokenOut, params.pools[0]);\\r\\n                if (!isToETH) {\\r\\n                    recipient = params.dstReceiver;\\r\\n                }\\r\\n                returnAmount = _swap(recipient, params.pools[0], tokenInAndPoolSalt, actualAmountIn, _zeroForOne);\\r\\n            }\\r\\n        }\\r\\n        if (isToETH) {\\r\\n            returnAmount = IERC20(params.wrappedToken).balanceOf(address(this)).sub(toBeforeBalance);\\r\\n            require(returnAmount >= params.minReturnAmount, \\\"Too little received\\\");\\r\\n            TransferHelper.safeWithdraw(params.wrappedToken, returnAmount);\\r\\n            TransferHelper.safeTransferETH(params.dstReceiver, returnAmount);\\r\\n        } else {\\r\\n            returnAmount = IERC20(params.dstToken).balanceOf(params.dstReceiver).sub(toBeforeBalance);\\r\\n            require(returnAmount >= params.minReturnAmount, \\\"Too little received\\\");\\r\\n        }\\r\\n        _emitSwapEvent(params.srcToken, params.dstToken, params.dstReceiver, params.amount, returnAmount, block.timestamp, block.number);\\r\\n    }\\r\\n\\r\\n    function _swap(address recipient, address pool, bytes memory tokenInAndPoolSalt, uint amount, bool _zeroForOne) internal returns (uint amountOut) {\\r\\n        bool zeroForOne = _zeroForOne;\\r\\n        address _pool = pool;\\r\\n        if (zeroForOne) {\\r\\n            (, int256 amount1) =\\r\\n            IUniswapV3Pool(_pool).swap(\\r\\n                recipient,\\r\\n                zeroForOne,\\r\\n                amount.toInt256(),\\r\\n                MIN_SQRT_RATIO + 1,\\r\\n                abi.encode(_pool, tokenInAndPoolSalt)\\r\\n            );\\r\\n            amountOut = SafeMath.toUint256(- amount1);\\r\\n        } else {\\r\\n            (int256 amount0,) =\\r\\n            IUniswapV3Pool(_pool).swap(\\r\\n                recipient,\\r\\n                zeroForOne,\\r\\n                amount.toInt256(),\\r\\n                MAX_SQRT_RATIO - 1,\\r\\n                abi.encode(_pool, tokenInAndPoolSalt)\\r\\n            );\\r\\n            amountOut = SafeMath.toUint256(- amount0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _verifyPool(address tokenIn, address tokenOut, address pool) internal view returns (address nextTokenIn, bytes memory tokenInAndPoolSalt, bool zeroForOne) {\\r\\n        IUniswapV3Pool iPool = IUniswapV3Pool(pool);\\r\\n        address token0 = iPool.token0();\\r\\n        address token1 = iPool.token1();\\r\\n        uint24 fee = iPool.fee();\\r\\n        address factory = iPool.factory();\\r\\n        bytes32 poolSalt = keccak256(abi.encode(token0, token1, fee));\\r\\n        if (tokenIn == token0) {\\r\\n            if (tokenOut != address(0)) {\\r\\n                require(tokenOut == token1, \\\"Bad pool\\\");\\r\\n            }\\r\\n            nextTokenIn = token1;\\r\\n            tokenInAndPoolSalt = abi.encode(token0, poolSalt, factory);\\r\\n            zeroForOne = true;\\r\\n        } else {\\r\\n            if (tokenOut != address(0)) {\\r\\n                require(tokenOut == token0, \\\"Bad pool\\\");\\r\\n            }\\r\\n            nextTokenIn = token0;\\r\\n            tokenInAndPoolSalt = abi.encode(token1, poolSalt, factory);\\r\\n            zeroForOne = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function _getPoolSalt(address token0, address token1, uint24 fee) public pure returns (bytes32){\\r\\n        return keccak256(abi.encode(token0, token1, fee));\\r\\n    }\\r\\n\\r\\n    function _getCalcPool(address factory, bytes32 poolSalt, bytes memory initCodeHash) public pure returns (address){\\r\\n        return address(\\r\\n            uint160(\\r\\n                uint(\\r\\n                    keccak256(\\r\\n                        abi.encodePacked(\\r\\n                            hex'ff',\\r\\n                            factory,\\r\\n                            poolSalt,\\r\\n                            initCodeHash\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n    function _verifyCallback(address pool, bytes32 poolSalt, address caller, address factory) internal {\\r\\n        bool _verifyOk;\\r\\n        for (uint i = 0; i < factoryListLength; i++) {\\r\\n            UniswapV3Pool memory v3Pool = allowedFactoryInitCodeHashList[i];\\r\\n            require(v3Pool.status, \\\"Callback bad pool 0\\\");\\r\\n            require(v3Pool.factory != address(0), \\\"Callback bad pool 1\\\");\\r\\n            address calcPool = _getCalcPool(v3Pool.factory, poolSalt, v3Pool.initCodeHash);\\r\\n            emit _verifyCallbackEvent(pool, poolSalt, caller, calcPool, factory, v3Pool.factory);\\r\\n            if (calcPool == caller) {\\r\\n                _verifyOk = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (!WPoolList[caller]) {\\r\\n            require(_verifyOk, \\\"Callback bad pool 2\\\");\\r\\n        }\\r\\n        require(pool == caller, \\\"Callback bad pool 3\\\");\\r\\n    }\\r\\n\\r\\n    function calculateInitCodeHash(bytes memory contractCode) public pure returns (bytes32) {\\r\\n        bytes32 initCodeHash = keccak256(contractCode);\\r\\n        return initCodeHash;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"ExecutorshipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"ExecutorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Receipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"SwapEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_poolSalt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_calcPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_poolFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_matchFactory\",\"type\":\"address\"}],\"name\":\"_verifyCallbackEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"poolIndex\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"factories\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"initCodeHash\",\"type\":\"bytes[]\"}],\"name\":\"setV3FactoryListEvent\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"WList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"WPoolList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_aggregate_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"poolSalt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCodeHash\",\"type\":\"bytes\"}],\"name\":\"_getCalcPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"_getPoolSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_wrapped_allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptExecutorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedFactoryInitCodeHashList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initCodeHash\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"contractCode\",\"type\":\"bytes\"}],\"name\":\"calculateInitCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pool\",\"type\":\"address[]\"}],\"internalType\":\"struct BaseCore.ExactInputV2SwapParams\",\"name\":\"exactInput\",\"type\":\"tuple\"}],\"name\":\"exactInputV2Swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pool\",\"type\":\"address[]\"}],\"internalType\":\"struct BaseCore.ExactInputV2SwapParams\",\"name\":\"exactInput\",\"type\":\"tuple\"}],\"name\":\"exactInputV2SwapAndGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"internalType\":\"struct BaseCore.ExactInputV3SwapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputV3Swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"internalType\":\"struct BaseCore.ExactInputV3SwapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputV3SwapAndGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"pancakeV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setAggregateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexList\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"factories\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"initCodeHash\",\"type\":\"bytes[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setV3FactoryList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWPoolList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wrappedTokens\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWrappedTokensList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"transferExecutorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SmartRouter", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}