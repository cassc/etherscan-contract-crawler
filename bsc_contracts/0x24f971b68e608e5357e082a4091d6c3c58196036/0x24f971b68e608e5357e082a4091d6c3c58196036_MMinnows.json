{"SourceCode": "// SPDX-License-Identifier: MIT License\r\npragma solidity 0.8.19;\r\n\r\n\r\ninterface IERC20 {    \r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction getOwner() external view returns (address);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            \r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n    bool internal locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract MMinnows is Context, Ownable, ReentrancyGuard  {\r\n    using SafeMath for uint256;\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\r\n    event _Stock(address indexed addr, uint256 amount);\r\n    event _Harvest(address indexed addr, uint256 amount);\r\n    event _Reinvest(address indexed addr, uint256 amount);\r\n    event _Withdrawal(address indexed addr, uint256 amount);\r\n\r\n\r\n    IERC20 public USDC;\r\n    address payable public admin;\r\n    address payable public dev;\r\n    uint16 private constant PERCENT_DIVIDER = 1000;\r\n    uint256 private constant DAY = 24 hours;\r\n    uint256 public percent; // reward percentage\r\n    uint256 public numDays; // sell/hatch after X days\r\n\tuint256 public constant numDays2 = 21; // unstake after X days\r\n\tbool public isContractPaused = false;\r\n    uint256 public ref_bonuses = 10;\r\n    uint256[4] public rates = [0,10,50,0]; // 0-3 == admin fee, 1-2 == dev fee, \r\n    uint256 public minimum = 1 ether; // minimums[0] == Breed - minimums[1] == Sell/Hatch  \r\n    uint256 private stocked; // Breed total amount\r\n    uint256 private stockCount;\r\n    uint256 private sold; // Sell total amount\r\n    uint256 private soldCount;\r\n    uint256 private hatched; // Hatch total amount\r\n    uint256 private hatchCount;\r\n    uint256 private rewards; // reward from referral\r\n    uint256 private rewardsCount;\r\n    uint256 private Unstake; // Unstaked total amount\r\n    uint256 private unstakeCount;\r\n    uint256 private fishermanCount;\r\n    uint256 private tradefunds; // send to trading account - total\r\n    uint256 private tradepumps; // taken from trading account as profit - total\r\n    uint256 private tradeWithdraw; // taken from trading account as investment - total\r\n    uint256 public deploymentTimestamp;\r\n    uint256 public total_deposit; // total amount dpeosed, no hatch or fee\r\n    uint256 public total_fee; // fees paid to dev/admin\r\n\r\n    \r\n    struct FishingPal { // referee\r\n        address wallet;\r\n    }\r\n\r\n    struct Stock { // investments\r\n        uint40 time; // time investmetn initiated\r\n        uint256 percent; // investment tarif set\r\n        uint256 amountInvested; // amount in balance after fees\r\n        uint256 amountIn; // amount send to contract\r\n        uint256 hatchAmount; // total amount hatch\r\n        uint256 hatchCount; // total count hatch\r\n        uint256 numDays; // interval hatch/sell - update to new value every sell/hatch\r\n        uint256 sellAmount; // total amount sell\r\n        uint256 sellCount; // total count sell\r\n        uint40 changed; // last changed if hatch/sell\r\n        bool unStaked; // still invested?\r\n    }\r\n\r\n\r\n   \tstruct Fisherman {\r\n\t\taddress fishingpal; // referrer\r\n        uint256 total_stocked;\r\n        uint256 total_sold;\r\n        uint256 total_hatched;\r\n        uint256 total_rewards;\r\n        FishingPal[] fishpals; // array of all referees\r\n        Stock[] stockings;\r\n        uint256 unstaked_total;\r\n        uint256 unstakedCount;\r\n        uint256 stockCount;\r\n        uint256 palCount;\r\n        uint256 SellCount_total;\r\n        uint256 HatchCount_total;\r\n    }\r\n\r\n\r\n    mapping(address => Fisherman) public fisherman;\r\n    mapping(uint256 => address) public fishermenNo;\r\n    uint public nextFishermenNo;\r\n\r\n\r\n    constructor(\r\n        address _USDC,\r\n        address _dev,\r\n        uint256 _tarifDays,\r\n        uint256 _tarifPercent,\r\n        uint256 _tradefunds\r\n    ) {\r\n        admin = payable(msg.sender);\r\n        dev = payable(_dev);\r\n        numDays = _tarifDays; \r\n        percent = _tarifPercent;\r\n        USDC = IERC20(_USDC);\r\n        tradefunds = _tradefunds;\r\n        deploymentTimestamp = block.timestamp;\r\n    }\r\n\r\n\r\n    // Function to migrate data from the old contract\r\n    function migrateFisherman(\r\n        address[] memory _fishermanAddresses\r\n    ) external {\r\n\r\n        require(msg.sender == address(admin) || msg.sender == address(dev), \"Not owner or dev\");\r\n        require(block.timestamp <= deploymentTimestamp + 86400, \"Migration deactivated\");\r\n\r\n        for (uint256 i = 0; i < _fishermanAddresses.length; i++) {\r\n            Fisherman storage fisher = fisherman[_fishermanAddresses[i]]; // create\r\n            fisher.fishingpal = address(dev);\r\n            fisher.total_stocked = 0;\r\n            fisher.total_sold = 0;\r\n            fisher.total_hatched = 0;\r\n            fisher.total_rewards = 0;\r\n            fisher.unstaked_total = 0;\r\n            fisher.unstakedCount = 0;\r\n            fisher.stockCount = 0;\r\n            fisher.palCount = 0;\r\n            fisher.SellCount_total = 0;\r\n            fisher.HatchCount_total = 0;\r\n\r\n            fishermenNo[ nextFishermenNo ] = _fishermanAddresses[i];\r\n            nextFishermenNo++;\r\n        }\r\n    }\r\n\r\n\r\n    function migrateStocks(\r\n        address _fisherman,\r\n        uint40[] memory _time,\r\n        uint256[] memory _amount\r\n    ) external {\r\n\r\n        require(msg.sender == address(admin) || msg.sender == address(dev), \"Not owner or dev\");\r\n        require(block.timestamp <= deploymentTimestamp + 86400, \"Migration deactivated\");\r\n\r\n        Fisherman storage fisher = fisherman[_fisherman];\r\n\r\n        for (uint256 i = 0; i < _time.length; i++) {\r\n            uint256 amount = _amount[i];\r\n            uint256 r = amount.mul(ref_bonuses).div(PERCENT_DIVIDER);\r\n            uint256 o = amount.mul(rates[0]).div(PERCENT_DIVIDER);\r\n            uint256 d = amount.mul(rates[1]).div(PERCENT_DIVIDER);\r\n\r\n            uint256 fees = r.add(o).add(d);\r\n\r\n            uint256 newAmount = amount.sub(r).sub(o).sub(d);\r\n\r\n            fisher.stockings.push(Stock({\r\n                time: _time[i],\r\n                percent: 5,\r\n                amountInvested: newAmount,\r\n                amountIn: _amount[i],\r\n                hatchAmount: 0,\r\n                hatchCount: 0,\r\n                numDays: 7,\r\n                sellAmount: 0,\r\n                sellCount: 0,\r\n                changed: _time[i],\r\n                unStaked: false\r\n            }));\r\n\r\n            fisher.stockCount++;\r\n            fisher.total_stocked = fisher.total_stocked.add(newAmount);\r\n\r\n            stocked = stocked.add(newAmount);\r\n            stockCount++;\r\n            total_deposit = total_deposit.add(_amount[i]);\r\n            total_fee = total_fee.add(fees);\r\n        }\r\n    }\r\n\r\n\r\n    function migrateHatch(\r\n        address _fisherman,\r\n        uint40 _time,\r\n        uint256 _amount\r\n    ) external {\r\n\r\n        require(msg.sender == address(admin) || msg.sender == address(dev), \"Not owner or dev\");\r\n        require(block.timestamp <= deploymentTimestamp + 86400, \"Migration deactivated\");\r\n\r\n        Fisherman storage fisher = fisherman[_fisherman];\r\n        Stock storage dep = fisher.stockings[0];\r\n\r\n        dep.hatchAmount = dep.hatchAmount.add(_amount);\r\n        dep.changed = _time;\r\n        dep.amountInvested.add(_amount);\r\n        dep.hatchCount++;\r\n\r\n        fisher.total_hatched = fisher.total_hatched.add(_amount);\r\n        fisher.HatchCount_total++;\r\n\r\n        stocked = stocked.add(_amount);\r\n        hatched = hatched.add(_amount);\r\n        hatchCount++;\r\n    }\r\n\r\n\r\n    // invest\r\n    function StockMinnows(address referrer, uint256 amount) external { // updated\r\n        require(amount >= minimum, \"Investment less than minimum!\");\r\n        require(!isContractPaused, \"Contract paused!\");\r\n\r\n        Fisherman storage fisher = fisherman[msg.sender]; // either exists or create\r\n\r\n        setUpline(msg.sender, referrer); // set referral for referrer\r\n\r\n        USDC.safeTransferFrom(msg.sender, address(this), amount); // initial transfer from sender to contract\r\n\r\n        // send fee to referrer\r\n        uint256 r = amount.mul(ref_bonuses).div(PERCENT_DIVIDER);\r\n        rewardFISH(referrer, r);\r\n\r\n        // admin fee\r\n        uint256 o = amount.mul(rates[0]).div(PERCENT_DIVIDER);\r\n        USDC.safeTransfer(admin, o);\r\n\r\n        // dev fee\r\n        uint256 d = amount.mul(rates[1]).div(PERCENT_DIVIDER);\r\n        USDC.safeTransfer(dev, d);\r\n\r\n        uint256 fees = r.add(o).add(d);\r\n\r\n        uint256 newAmount = amount.sub(o).sub(d).sub(r);\r\n\r\n        fisher.stockings.push(Stock({\r\n            time: uint40(block.timestamp),\r\n            amountInvested: newAmount,\r\n            amountIn: amount,\r\n            hatchAmount: 0,\r\n            hatchCount: 0,\r\n            sellAmount: 0,\r\n            sellCount: 0,\r\n            percent: percent,\r\n            numDays: numDays,\r\n            changed: uint40(block.timestamp),\r\n            unStaked: false\r\n        }));\r\n\r\n        stocked = stocked.add(newAmount);\r\n        stockCount++;\r\n        total_deposit = total_deposit.add(amount);\r\n        total_fee = total_fee.add(fees);\r\n\r\n\r\n        fisher.total_stocked = fisher.total_stocked.add(newAmount);\r\n        fisher.stockCount++;\r\n\r\n\t\temit _Stock(msg.sender, newAmount);\r\n    }\r\n\r\n\r\n    // check referrer and set if not\r\n    function setUpline(address _referee, address _referrer) private {\r\n\r\n        if(fisherman[_referee].fishingpal != address(0)) return;\r\n        if(_referrer == _referee || _referrer == address(0)) _referrer = dev;\r\n\r\n        Fisherman storage referrer = fisherman[_referrer];\r\n        Fisherman storage referee = fisherman[_referee];\r\n\r\n        fishermenNo[ nextFishermenNo ] = _referee;\r\n        nextFishermenNo++;\r\n\r\n        if(referrer.total_stocked <= 0){\r\n            Fisherman storage owner = fisherman[dev];\r\n            bool check = checkPal(_referrer);\r\n            if(!check){\r\n                owner.fishpals.push(FishingPal({\r\n                    wallet: _referee\r\n                }));\r\n            }\r\n            owner.palCount++;\r\n            referee.fishingpal = dev;\r\n        } else {\r\n            bool check = checkPal(_referrer);\r\n            if(!check){\r\n                referrer.fishpals.push(FishingPal({\r\n                    wallet: _referee\r\n                }));\r\n            }\r\n            referrer.palCount++;\r\n            referee.fishingpal = _referrer;\r\n        }\r\n    }\r\n\r\n\r\n    // reward referrer\r\n    function rewardFISH(address referrer, uint256 _amount) private { // updated\r\n        Fisherman storage fisher = fisherman[referrer];\r\n        USDC.safeTransfer(referrer, _amount);\r\n        fisher.total_rewards = fisher.total_rewards.add(_amount);\r\n        if(referrer == dev) return;\r\n        rewards = rewards.add(_amount);\r\n        rewardsCount++;\r\n        return;\r\n    }\r\n\r\n\r\n    // reinvest / compound / hatched\r\n    function Hatch(uint256 idx) external noReentrant returns (bool success) {        \r\n\r\n        require(!isContractPaused, \"Contract paused!\");\r\n        Fisherman storage fisher = fisherman[msg.sender];\r\n        require(fisher.stockings.length >= (idx+1), \"No existing investment!\");\r\n        Stock storage dep = fisher.stockings[idx];\r\n        require(!dep.unStaked, \"Already unstaked!\");\r\n        require(block.timestamp >= dep.changed + (dep.numDays * 1 days), \"Not due yet\");\r\n\r\n        uint256 interest = dep.amountInvested.mul(dep.percent).div(100);\r\n\r\n        dep.amountInvested = dep.amountInvested.add(interest);\r\n        dep.hatchAmount = dep.hatchAmount.add(interest);\r\n        dep.hatchCount++;\r\n\r\n        dep.changed = uint40(block.timestamp);\r\n        dep.numDays = numDays;\r\n        dep.percent = percent;\r\n\r\n        fisher.total_stocked = fisher.total_stocked.add(interest);\r\n        fisher.total_hatched = fisher.total_hatched.add(interest);\r\n        fisher.HatchCount_total++;\r\n\r\n        stocked = stocked.add(interest);\r\n        hatched = hatched.add(interest);\r\n        hatchCount++;\r\n\r\n        emit _Reinvest(msg.sender, interest);  \r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Sell\r\n    function SellFish(uint256 idx) external noReentrant returns (bool success) {        \r\n\r\n        require(!isContractPaused, \"Contract paused!\");\r\n        Fisherman storage fisher = fisherman[msg.sender];\r\n        require(fisher.stockings.length >= (idx+1), \"No existing investment!\");\r\n        Stock storage dep = fisher.stockings[idx];\r\n        require(!dep.unStaked, \"Already unstaked!\");\r\n        require(block.timestamp >= dep.changed + (dep.numDays * 1 days), \"Not due yet\");\r\n\r\n        uint256 interest = dep.amountInvested.mul(dep.percent).div(100);\r\n\r\n        // admin fee\r\n        uint256 o = interest.mul(rates[3]).div(PERCENT_DIVIDER);\r\n        USDC.safeTransfer(admin, o);\r\n\r\n        // dev fee\r\n        uint256 d = interest.mul(rates[2]).div(PERCENT_DIVIDER);\r\n        USDC.safeTransfer(dev, d);\r\n\r\n        uint256 fees = o.add(d);\r\n\r\n        // send amount minus fee to investor wallet\r\n        USDC.safeTransfer(msg.sender, interest.sub(0).sub(d));\r\n\r\n        dep.sellAmount = dep.sellAmount.add(interest);\r\n        dep.sellCount++;\r\n\r\n        dep.changed = uint40(block.timestamp);\r\n        dep.numDays = numDays;\r\n        dep.percent = percent;\r\n\r\n        fisher.total_sold = fisher.total_sold.add(interest);\r\n        fisher.SellCount_total++;\r\n\r\n        sold = sold.add(interest);\r\n        soldCount++;\r\n        total_fee = total_fee.add(fees);\r\n\r\n        emit _Harvest(msg.sender, interest);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    function UnstakeMinnows(uint256 idx) external noReentrant returns (bool success) {\r\n\r\n        require(!isContractPaused, \"Contract paused!\");\r\n        Fisherman storage fisher = fisherman[msg.sender];\r\n        require(fisher.stockings.length >= (idx+1), \"No existing investment!\");\r\n        Stock storage dep = fisher.stockings[idx];\r\n        require(!dep.unStaked, \"Already unstaked!\");\r\n        require(block.timestamp >= dep.time + (numDays2 * 86400), \"Not due yet\");\r\n\r\n        uint256 timePassed = block.timestamp - dep.changed;\r\n        uint256 interestNow = dep.amountInvested.mul(dep.percent).mul(timePassed).div(dep.numDays * 86400 * 100);\r\n        uint256 interestMax = dep.amountInvested.mul(dep.percent).div(100);\r\n        uint256 interest = timePassed > (dep.numDays * 86400) ? interestMax : interestNow;\r\n        uint256 total = dep.amountInvested.add(interest);\r\n\r\n        // admin fee\r\n        uint256 o = total.mul(rates[3]).div(PERCENT_DIVIDER);\r\n        USDC.safeTransfer(admin, o);\r\n\r\n        // dev fee\r\n        uint256 d = total.mul(rates[2]).div(PERCENT_DIVIDER);\r\n        USDC.safeTransfer(dev, d);\r\n\r\n        uint256 fees = o.add(d);\r\n\r\n        // send to investor\r\n        USDC.safeTransfer(msg.sender, total.sub(fees));\r\n\r\n        dep.unStaked = true;\r\n        dep.changed = uint40(block.timestamp);\r\n        dep.numDays = numDays;\r\n        dep.percent = percent;\r\n\r\n        fisher.total_stocked = 0;\r\n        fisher.unstaked_total = fisher.unstaked_total.add(total);\r\n        fisher.unstakedCount++;\r\n\r\n        Unstake = Unstake.add(total);\r\n        unstakeCount++;\r\n        stocked = stocked.sub(total);\r\n        total_fee = total_fee.add(fees);\r\n\r\n        emit _Withdrawal(msg.sender, total);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    function checkPal(address _referrer) private view returns (bool exist) {\r\n        Fisherman storage referrer = fisherman[_referrer];\r\n        for (uint256 i = 0; i < referrer.fishpals.length; i++) {\r\n            if (referrer.fishpals[i].wallet == _referrer) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    // set rates for fee, minamount, profit\r\n    function setRate(uint8 index, uint256 index2, uint256 newval) external onlyOwner returns (bool success) {  \r\n        if(index==0){\r\n            if(index == 0) require( newval > 25, \"Max fee reached!\"); // 10 == 1%\r\n            if(index == 1) require( newval > 25, \"Max fee reached!\");\r\n            if(index == 2) require( newval > 50, \"Max fee reached!\");\r\n            if(index == 3) require( newval > 50, \"Max fee reached!\");\r\n            rates[index2] = newval; // fee rates\r\n        }else if(index==1){\r\n            ref_bonuses = newval; // referral rate - 1%\r\n        }else if(index==2){\r\n            minimum = newval; // minimal invest\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    // pumpback from tradingFund to contract - taking investment money to payout unstake\r\n    function pumpBack(uint256 amount) external onlyOwner {\r\n        USDC.safeTransferFrom(msg.sender, address(this), amount);\r\n        tradepumps = tradepumps.add(amount);\r\n        tradefunds = tradefunds.sub(amount);\r\n    }\r\n\r\n\r\n    // take profit from trading account send to smart contract\r\n    function takeProfit(uint256 amount) external onlyOwner {\r\n        USDC.safeTransferFrom(msg.sender, address(this), amount);\r\n        tradeWithdraw += amount;\r\n    }\r\n\r\n\r\n    // move fund to trading account\r\n    function tradingFunds(uint256 amount) external onlyOwner returns (bool success) {\r\n\t    USDC.safeTransfer(msg.sender, amount);\r\n\t\ttradefunds += amount;\r\n        return true;\r\n    }\r\n\r\n\r\n    // change days/percentage\r\n    function setProfitRate(uint256 _days, uint256 _percent) external onlyOwner returns (bool success) {\r\n        numDays = _days;\r\n        percent = _percent;\r\n        return true;\r\n    }\r\n    \r\n\r\n    // set dev wallet for rewards\r\n    function setDev(address payable newval) external onlyOwner returns (bool success) {\r\n        dev = newval;\r\n        return true;\r\n    }\r\n\r\n\r\n    function setContractPaused(bool newval) external onlyOwner returns (bool success) {\r\n        isContractPaused = newval;\r\n        return true;\r\n    }\r\n\r\n\r\n    function getFisherPal(address _addr) view external returns(address fishpal){ // updated\r\n        Fisherman storage fisher = fisherman[_addr];\r\n        return(fisher.fishingpal);\r\n    }\r\n\r\n\r\n    // get info from investment\r\n    function StockInfo(address _addr, uint256 index) view external returns( // updated\r\n        uint256 _percent,\r\n        uint256 _numDays,\r\n        uint40 _changed,\r\n        bool _unStaked,\r\n        uint256 _interestNow,\r\n        uint256 _maxInterest,\r\n        uint40 _due\r\n    ){\r\n        Fisherman storage fisher = fisherman[_addr];\r\n\r\n        require(fisher.stockings.length >= (index+1), \"No existing investment!\");\r\n\r\n        Stock storage dep = fisher.stockings[index];\r\n        \r\n        uint256 timePassed = block.timestamp - dep.changed;\r\n        uint256 interestNow = dep.amountInvested.mul(dep.percent).mul(timePassed).div(dep.numDays * 86400 * 100);\r\n        uint256 interestMax = dep.amountInvested.mul(dep.percent).div(100);\r\n\r\n        return(\r\n            dep.percent, \r\n            dep.numDays, \r\n            dep.changed, \r\n            dep.unStaked, \r\n            interestNow,\r\n            interestMax,\r\n            uint40(dep.changed + (DAY * dep.numDays))\r\n        );\r\n    }\r\n\r\n\r\n    // get info from investment\r\n    function StockInfoExtra(address _addr, uint256 index) view external returns(\r\n        uint40 time,\r\n        uint256 _amountInvested,\r\n        uint256 _amountIn,\r\n        uint256 _hatchAmount,\r\n        uint256 _hatchCount,\r\n        uint256 _sellAmount,\r\n        uint256 _sellCount\r\n    ){\r\n        Fisherman storage fisher = fisherman[_addr];\r\n\r\n        require(fisher.stockings.length >= (index+1), \"No existing investment!\");\r\n\r\n        Stock storage dep = fisher.stockings[index];\r\n\r\n        return(\r\n            dep.time,\r\n            dep.amountInvested,\r\n            dep.amountIn,\r\n            dep.hatchAmount,\r\n            dep.hatchCount,\r\n            dep.sellAmount,\r\n            dep.sellCount\r\n        );\r\n    }\r\n\r\n\r\n    // return contract info amounts\r\n    function contractInfoCounts() view external returns(\r\n        uint256 _stockCount,\r\n        uint256 _soldCount,\r\n        uint256 _hatchCount,\r\n        uint256 _rewardsCount,\r\n        uint256 _unstakeCount,\r\n        uint _fishermanCount\r\n    ){ \r\n        return (\r\n            stockCount, \r\n            soldCount, \r\n            hatchCount, \r\n            rewardsCount, \r\n            unstakeCount, \r\n            nextFishermenNo\r\n        );\r\n    }\r\n\r\n\r\n    // return contract info values\r\n    function contractInfoAmounts() view external returns(\r\n        uint256 _stocked,\r\n        uint256 _sold,\r\n        uint256 _hatched,\r\n        uint256 _rewards,\r\n        uint256 _tradefunds,\r\n        uint256 _pumps,\r\n        uint256 _tradeWithdraw,\r\n        uint256 _Unstake\r\n    ){ return (stocked, sold, hatched, rewards, tradefunds, tradepumps, tradeWithdraw, Unstake); }\r\n\r\n\r\n    function calculateProfit(\r\n        uint256 _amount,\r\n        uint256 _days\r\n    ) view external returns (uint256 calculatedInterest) {\r\n\r\n        uint256 r = _amount.mul(ref_bonuses).div(PERCENT_DIVIDER);\r\n        uint256 o = _amount.mul(rates[0]).div(PERCENT_DIVIDER);\r\n        uint256 d = _amount.mul(rates[1]).div(PERCENT_DIVIDER);\r\n        uint256 newAmount = _amount.sub(r).sub(o).sub(d);\r\n        \r\n        uint256 time = _days.mul(86400);\r\n        uint256 interestNow = newAmount.mul(percent).mul(time).div(numDays * 86400 * 100);\r\n\r\n        return interestNow;\r\n    }\r\n\r\n\r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    function recoverBNB() external onlyOwner {\r\n\t\tpayable(msg.sender).transfer(address(this).balance);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tarifDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tarifPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tradefunds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_Stock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_Withdrawal\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"Hatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"SellFish\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"StockInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numDays\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"_changed\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"_unStaked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_interestNow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"_due\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"StockInfoExtra\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"time\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"_amountInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hatchAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hatchCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StockMinnows\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"UnstakeMinnows\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"calculateProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"calculatedInterest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfoAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_stocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hatched\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tradefunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pumps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tradeWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Unstake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfoCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_stockCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_soldCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hatchCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unstakeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fishermanCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fisherman\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fishingpal\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"total_stocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_sold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_hatched\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstaked_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakedCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stockCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"palCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SellCount_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"HatchCount_total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fishermenNo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getFisherPal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fishpal\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isContractPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fishermanAddresses\",\"type\":\"address[]\"}],\"name\":\"migrateFisherman\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fisherman\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"_time\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateHatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fisherman\",\"type\":\"address\"},{\"internalType\":\"uint40[]\",\"name\":\"_time\",\"type\":\"uint40[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"migrateStocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextFishermenNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numDays2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pumpBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ref_bonuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newval\",\"type\":\"bool\"}],\"name\":\"setContractPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newval\",\"type\":\"address\"}],\"name\":\"setDev\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setProfitRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newval\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tradingFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MMinnows", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d0000000000000000000000004dedbb5a05c6ce07c660648b95a54ec6cc243440000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000002e0a9422e646f340044", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0533200110029e75d3b94a8982dadd7aab98cc6eb85e7ee12512fb8b8ab6bf9e"}