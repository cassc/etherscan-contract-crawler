{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\n// ------------------------------------- Address -------------------------------------------\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n// ------------------------------------- SafeERC20 -------------------------------------------\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n// ------------------------------------- Context -------------------------------------------\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n// ------------------------------------- Ownable -------------------------------------------\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n// ------------------------------------- IERC20 -------------------------------------------\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function mint(address _to, uint256 _amount) external;\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// ------------------------------------- ReentrancyGuard -------------------------------------------\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n// -------------------------------------- IUniswapV2Pair -------------------------------------------\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n// -------------------------------------- IUniswapV2Router01 -------------------------------------------\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n// -------------------------------------- IUniswapV2Router02 -------------------------------------------\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// ------------------------------------- IWETH -------------------------------------------\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n}\r\n// ------------------------------------- IPenaltyReceiver -------------------------------------------\r\ninterface IPenaltyReceiver {\r\n    function notifyReward(uint256 reward) external;\r\n}\r\n\r\n// Shade staked within this contact entitles stakers to a portion of the admin fees generated by Shade Payment contracts\r\ncontract TORII_Loyalty is ReentrancyGuard, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    // -------------------------------- VARIABLES -----------------------------------\r\n    \r\n    struct LockedBalance {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n    }\r\n    struct RewardData {\r\n        address token;\r\n        uint256 amount;\r\n    }\r\n\r\n\tIUniswapV2Router02 public immutable router;\r\n    IUniswapV2Pair public immutable pair;\t\r\n\taddress[] public path;\r\n\taddress public immutable token;\t\t\r\n\taddress public immutable WETH;    \t\r\n\t\r\n\tuint256 public periodFinish = 0;\r\n    uint256 public rewardRate = 0;\r\n    uint256 public lastUpdateTime;\r\n    uint256 public rewardPerTokenStored;\r\n\tmapping(address => uint256) public userRewardPerTokenPaid;\r\n    mapping(address => uint256) public rewards;\r\n    \r\n    uint256 public constant rewardsDuration = 2 days; // \r\n\tuint256 public constant lockDurationMultiplier = 15; // \r\n    // Duration of lock period\r\n    uint256 public constant lockDuration = rewardsDuration * lockDurationMultiplier; \r\n        \r\n    // addresses that allowed to stake in lock\r\n    mapping(address => bool) public lockStakers;\r\n\r\n    uint256 public totalSupply;\r\n\r\n\tuint256 public penaltyPercent;\r\n\tuint256 public constant penaltyPercentMAX = 50;\t\r\n    \r\n    mapping(address => uint256) public balances;    \t\r\n\tmapping(address => mapping(uint256 => LockedBalance)) public userLocks;\r\n\tmapping(address => uint256) public startIndex;\r\n\tmapping(address => uint256) public userLocksLength;\r\n\r\n\tbool public emergencyMode;\r\n    uint256 public emergencyModeStartTime;\r\n\tuint256 public immutable recoveryDelay;\r\n        \r\n    // -------------------------------- CONSTRUCTOR -----------------------------------\r\n    constructor() Ownable() {        \r\n\t\ttoken = address(0xD9979e2479AEa29751D31AE512a61297B98Fbbf4); // TORII mainnet\t\r\n\t\trouter = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); // mainnet        \r\n        WETH = router.WETH();    \r\n\t\t\r\n\t\tpair = IUniswapV2Pair(address(0xEE6739F85f6a87fF90c360Ea2210D5F2cB620320)); // TORII LP mainnet\r\n        require(pair.factory() == router.factory(), 'iiVault Swapper: Incompatible liquidity pair factory');\r\n\t\tpath = [WETH, token];\r\n\t\t\t\t            \r\n\t\tpenaltyPercent = 20;\r\n\r\n\t\tlastUpdateTime = block.timestamp;\r\n\t\tperiodFinish = block.timestamp;\r\n\t\trecoveryDelay = 7 days;\r\n    }\r\n\r\n    // -------------------------------- CONFIG -----------------------------------\r\n\r\n\t// Penalty\r\n    function setPenaltyPercent(uint256 newPenaltyPercent) public onlyOwner {\r\n        require(newPenaltyPercent <= penaltyPercentMAX, \"Penalty percent max\");\r\n\t\tpenaltyPercent = newPenaltyPercent;   \r\n\t\temit SetPenalty(newPenaltyPercent);     \r\n    }\r\n\r\n\t// EmergencyMode\r\n    function setEmergencyMode() public onlyOwner {\r\n        emergencyMode = true; \r\n\t\temergencyModeStartTime = block.timestamp;  \r\n\t\temit SetEmergencyMode();     \r\n    }\r\n\r\n    // -------------------------------- VIEWS -----------------------------------\r\n    //\r\n    function rewardPerToken() internal view returns (uint256) {\r\n        if (totalSupply == 0) {\r\n            return rewardPerTokenStored;\r\n        }        \r\n        return rewardPerTokenStored + ( (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / totalSupply );\r\n    }\r\n\r\n    //\r\n    function earned(address account) internal view returns (uint256) {\r\n        return balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18 + rewards[account];\r\n    }\r\n\r\n    //\r\n    function lastTimeRewardApplicable() internal view returns (uint256) {\r\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\r\n    }\r\n\r\n    //\r\n    function claimRewardForDuration() internal view returns (uint256) {\r\n        return rewardRate * rewardsDuration;\r\n    }\r\n\r\n\tfunction lockedBalance(address account) public view returns (uint256 amount) {\r\n\t\tfor (uint i = startIndex[account]; i < userLocksLength[account]; i++) {\r\n            if (userLocks[account][i].unlockTime > block.timestamp) {\r\n                amount += userLocks[account][i].amount;\r\n\t\t\t}  \t\t\t         \r\n        } \t\t\r\n\t}\r\n\r\n    // Contract Data method for decrease number of request to contract from dApp UI\r\n    function contractData() public view returns (\r\n        uint256 _totalDeposited,            // totalSupply\r\n        uint256 _rewardPerToken,   // rewardPerToken        \r\n        uint256 _claimRewardForDuration,   // claimRewardForDuration        \r\n        uint256 _rewardsDuration,            // rewardsDuration   \r\n        uint256 _lockDuration,            // lockDuration   \r\n\t\tuint256 _balanceToken,\r\n        uint256 _penaltyPercent        \r\n\t\t) {\r\n            _totalDeposited = totalSupply;\t\t\t\r\n\t\t\t_rewardPerToken = rewardPerToken();\r\n\t\t\t_claimRewardForDuration = claimRewardForDuration();\r\n            _balanceToken = IERC20(token).balanceOf(address(this));\r\n\t\t\t_rewardsDuration = rewardsDuration;\r\n\t\t\t_lockDuration = lockDuration;\r\n            _penaltyPercent = penaltyPercent;\r\n    }\r\n\r\n    // User Data method for decrease number of request to contract from dApp UI\r\n    function userData(address account) public view returns (\r\n        uint256 _deposited,  // Staked balance\r\n        uint256 _locked,  // Locked balance\r\n        LockedBalance[] memory _userLocks,     // Locks\r\n        uint256 _earned,        // claimableRewards\r\n        uint256 _allowance,                     // allowance of staking token        \r\n        uint256 _balance                    // balance of staking token        \r\n        ) {\r\n\t\t\t_deposited = balances[account];                \r\n\t\t\t_userLocks = new LockedBalance[](userLocksLength[account] - startIndex[account]);\r\n\t\t\tuint256 idx;\r\n\t\t\tfor (uint i = startIndex[account]; i < userLocksLength[account]; i++) {\r\n\t\t\t\tif (userLocks[account][i].unlockTime > block.timestamp) {\r\n                   \t_userLocks[idx] = userLocks[account][i]; \r\n\t\t\t\t\t_locked += userLocks[account][i].amount;                    \r\n                    idx ++;             \r\n                }            \r\n            }\r\n\t\t\t            \r\n            _earned = earned(account);\r\n            _allowance = IERC20(token).allowance(account, address(this));\r\n            _balance = IERC20(token).balanceOf(account);        \r\n    }\r\n\r\n    // -------------------------------- MUTATIVE FUNCTIONS -----------------------------------        \r\n    // Deposit tokens to receive rewards\r\n    function deposit(uint256 amount) public nonReentrant {\r\n        _updateUserLocks(msg.sender);\r\n        _updateReward(msg.sender);        \r\n        _deposit(msg.sender, amount, true);\r\n    }\r\n    \r\n    // Withdraw defined amount of staked tokens\r\n    // If amount higher than unlocked we get extra from locks and pay penalty\r\n    function withdraw(uint256 amount) public nonReentrant {\r\n        _updateUserLocks(msg.sender);\r\n        _updateReward(msg.sender);\r\n\r\n        require(amount != 0, \"Can't withdraw 0\");  \r\n\r\n        uint256 balance = balances[msg.sender];\r\n        require(balance >= amount, \"Not enough tokens to withdraw\"); \r\n\t\tbalances[msg.sender] -= amount;   \r\n       \r\n        uint256 unlocked = balance - lockedBalance(msg.sender);\r\n        uint256 penalty;\r\n        \r\n        if (amount > unlocked) {\r\n\t\t\trequire(penaltyPercent != 0, \"Can't withdraw locked without penalty\");  \r\n\r\n            uint256 remaining = amount - unlocked;\r\n\t\t\trequire(remaining >= 100, \"Can't withdraw locked less than 100 wei\"); \r\n\t\t\t\r\n            penalty = remaining / 100 * penaltyPercent;\r\n            amount = unlocked + remaining - penalty;\r\n                      \r\n            for (uint i = startIndex[msg.sender]; i < userLocksLength[msg.sender]; i++) {\r\n                uint256 lockAmount = userLocks[msg.sender][i].amount;\r\n                if (lockAmount < remaining) {\r\n                    remaining = remaining - lockAmount;\r\n                    delete userLocks[msg.sender][i];\r\n                } else if (lockAmount == remaining) {\r\n                    delete userLocks[msg.sender][i];\r\n                    break;\r\n                } else { \r\n                    userLocks[msg.sender][i].amount = lockAmount - remaining;\r\n                    break;\r\n                }            \r\n            }\r\n        }\r\n        _sendTokensAndPenalty(amount, penalty);\r\n        emit Withdrawn(msg.sender, amount);\t\t\r\n    }\r\n    \r\n    // Withdraw defined amount of unlocked tokens\r\n    function withdrawUnlocked() public nonReentrant {\r\n        _updateUserLocks(msg.sender);\r\n        _updateReward(msg.sender);\r\n        \r\n        uint256 balance = balances[msg.sender];\r\n        require(balance != 0, \"No tokens on balance\"); \r\n\t\tuint256 locked = lockedBalance(msg.sender);  \r\n\r\n        uint256 amount = balance - locked; \r\n\t\trequire(amount != 0, \"No unlocked tokens\");\r\n\r\n        balances[msg.sender] -= amount;    \r\n\t\t\r\n\t\t_sendTokensAndPenalty(amount, 0);                \r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    // Withdraw all user locked tokens\r\n    function withdrawLocked() public nonReentrant {\r\n        _updateUserLocks(msg.sender); \r\n        _updateReward(msg.sender);\r\n                \r\n        uint256 amount = lockedBalance(msg.sender);\r\n        require(amount != 0, \"Can't withdraw 0\");  \r\n\r\n\t\trequire(penaltyPercent != 0, \"Can't withdraw locked without penalty\");  \r\n\t\trequire(amount >= 100, \"Can't withdraw locked less than 100 wei\");    \r\n        \r\n        balances[msg.sender] -= amount;\r\n                \r\n        for (uint i = startIndex[msg.sender]; i < userLocksLength[msg.sender]; i++) {\r\n            delete userLocks[msg.sender][i];\r\n        }\r\n\t\tstartIndex[msg.sender] = 0;\r\n        userLocksLength[msg.sender] = 0;\r\n\r\n\t\tuint256 penalty = amount / 100 * penaltyPercent;\r\n        amount -= penalty; \r\n\r\n        _sendTokensAndPenalty(amount, penalty);\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n\t// Withdraw full unlocked balance and claim pending rewards\r\n    function withdrawAll() public nonReentrant {         \r\n        _updateUserLocks(msg.sender);    \r\n        _updateReward(msg.sender);   \r\n       \r\n\t\tuint256 balance = balances[msg.sender];\r\n        require(balance != 0, \"Can't withdraw 0\"); \r\n\t\t \r\n\t\tuint256 locked = lockedBalance(msg.sender);    \r\n\t\tif (locked != 0) {\r\n\t\t\trequire(penaltyPercent != 0, \"Can't withdraw locked without penalty\");  \r\n\t\t\trequire(locked >= 100, \"Can't withdraw locked less than 100 wei\"); \r\n\t\t}   \r\n        uint256 unlocked = balance - locked;\r\n\t\t\r\n\t\tuint256 penalty = locked / 100 * penaltyPercent;\r\n        uint256 amount = unlocked + locked - penalty; \r\n\r\n        balances[msg.sender] = 0;\r\n\t\tfor (uint i = startIndex[msg.sender]; i < userLocksLength[msg.sender]; i++) {\r\n            delete userLocks[msg.sender][i];\r\n        }\r\n\t\tstartIndex[msg.sender] = 0;\r\n        userLocksLength[msg.sender] = 0;\r\n\r\n        _sendTokensAndPenalty(amount, penalty);\r\n\r\n\t\temit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n\t// Withdraw full unlocked balance and claim pending rewards\r\n    function withdrawEmergency() public nonReentrant { \r\n        require(emergencyMode, \"Emergency mode not enabled\"); \r\n\t\t\r\n\t\tuint256 amount = balances[msg.sender];\r\n        require(amount != 0, \"Can't withdraw 0\"); \r\n\t\t       \r\n\t\tstartIndex[msg.sender] = 0;\r\n        userLocksLength[msg.sender] = 0;\r\n\t\tbalances[msg.sender] = 0;\r\n\r\n        _sendTokensAndPenalty(amount, 0);\r\n\r\n\t\temit EmergencyWithdrawn(msg.sender, amount);\r\n    }\r\n\r\n    // Claim all pending staking rewards\r\n    function claim() public nonReentrant {\t\t\r\n        _updateReward(msg.sender);\r\n        _claimReward(msg.sender, true);        \r\n    }\r\n    // Claim all pending staking rewards\r\n    function claimAndDeposit() public nonReentrant {\t\t\r\n        _updateReward(msg.sender);        \r\n        uint256 reward = _claimReward(msg.sender, false);\r\n        if (reward != 0) { \r\n            _updateUserLocks(msg.sender);\r\n            _deposit(msg.sender, reward, false);          \r\n        }   \r\n    }\r\n    \r\n    //\r\n    function updateUserLocks() public {\r\n        _updateUserLocks(msg.sender);\r\n    }\r\n\t//notifyReward\r\n    function notifyReward(uint256 amount) public {\r\n        uint256 balanceWETH = IERC20(WETH).balanceOf(address(this));\r\n        if (balanceWETH != 0) {\r\n            _updateReward(address(0));\r\n\t\t\t\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\t\t\t\r\n\t\t\tIERC20(WETH).approve(address(router), balanceWETH);\r\n\t\t\trouter.swapExactTokensForTokens(balanceWETH, 0, path, address(this), block.timestamp);\t\t\t\r\n\t\t\tuint256 tokenAmount = IERC20(token).balanceOf(address(this)) - balance;\r\n\t\t\t\r\n\t\t\t_notifyReward(tokenAmount);\r\n\t\t\temit RewardAdded(tokenAmount);\r\n\t\t}\r\n    }\r\n    function notifyRewardAmount(uint256 amount) public {\r\n        if (amount != 0) {\r\n\t\t\t_updateReward(address(0));\r\n\t\t\tIERC20(WETH).safeTransferFrom(msg.sender, address(this), amount);\r\n\t\t\tuint256 balanceWETH = IERC20(WETH).balanceOf(address(this));\t\t\t\t\r\n\t\t\t\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\t\t\t\r\n\t\t\tIERC20(WETH).approve(address(router), balanceWETH);\r\n\t\t\trouter.swapExactTokensForTokens(balanceWETH, 0, path, address(this), block.timestamp);\t\t\t\r\n\t\t\tuint256 tokenAmount = IERC20(token).balanceOf(address(this)) - balance;\r\n\t\t\t\r\n\t\t\t_notifyReward(tokenAmount);\r\n\t\t\temit RewardAdded(tokenAmount);\r\n\t\t}\r\n    }\r\n\t// \r\n    function notifyRewardToken(uint256 amount) public {        \r\n        _updateReward(address(0));\r\n\t\t\r\n\t\tuint256 balance = IERC20(token).balanceOf(address(this));\r\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\t\r\n\t\tuint256 tokensIn = IERC20(token).balanceOf(address(this)) - balance;\r\n\r\n\t\trequire(tokensIn != 0, \"No reward\"); \t\r\n\t\t\r\n\t\t_notifyReward(tokensIn);\r\n        emit TokenReceived(tokensIn);     \r\n    }\r\n\t// \r\n    function notifyRewardETH() public payable {        \r\n        require(msg.value != 0, \"No reward\"); \r\n        _updateReward(address(0));\r\n\t\t\r\n        IWETH(WETH).deposit{ value: msg.value }();\r\n\r\n\t\tnotifyReward(0);\r\n        emit ETHReceived(msg.value);     \r\n    }\r\n\t//\r\n\treceive() external payable {\r\n\t\tnotifyRewardETH();\r\n    }\r\n\r\n    // Added to support recovering \r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\r\n\t\tif (!emergencyMode) {\r\n\t\t\trequire(tokenAddress != token, \"Can't withdraw staking/reward token\");\r\n\t\t} else {\r\n\t\t\tif (tokenAddress == token) {\r\n\t\t\t\trequire(block.timestamp >= emergencyModeStartTime + recoveryDelay, \"Can't withdraw staking/reward token before recovery delay\");\r\n\t\t\t}\r\n\t\t}                \r\n\t\tIERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n\t\r\n    // -------------------------------- RESTRICTED -----------------------------------\r\n    // Locked tokens can't be withdrawn for lockDuration and are eligible to receive staking rewards\r\n    function _deposit(address account, uint256 amount, bool transfer) internal {               \r\n        require(amount != 0, \"Can't stake 0\");\r\n       \r\n        uint256 unlockTime = (block.timestamp / rewardsDuration * rewardsDuration) + lockDuration;\r\n        uint256 locksLength = userLocksLength[account];\r\n\t\t\r\n\t\tif (locksLength == 0 || userLocks[account][locksLength-1].unlockTime < unlockTime) {                \r\n\t\t\tuserLocks[account][locksLength] = LockedBalance({\r\n                amount: amount, \r\n                unlockTime: unlockTime\r\n            }); \r\n\t\t\tuserLocksLength[account] ++;                \r\n        } else {\t\t\t\t\r\n            userLocks[account][locksLength-1].amount += amount;\r\n        }\r\n\r\n        if (transfer) {\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n        } \r\n        \r\n\t\tbalances[account] += amount;\r\n        totalSupply += amount;\r\n\r\n        emit Deposited(account, amount);\r\n    }\r\n    // Update all currently locked tokens where the unlock time has passed\r\n    function _updateUserLocks(address account) internal {\r\n        require(!emergencyMode, \"Not allowed in emergency mode\");\r\n        uint256 locksLength = userLocksLength[account];\r\n        // return if user has no locks\r\n        if (locksLength == 0) return;\r\n\t\t\r\n        // searching for expired locks from stratIndex untill first locked found or end reached        \r\n        while (userLocks[account][startIndex[account]].unlockTime <= block.timestamp && startIndex[account] < locksLength) {\r\n\t\t\tstartIndex[account] ++;\r\n\t\t} \r\n\t\t\r\n\t\t// if end reached it means no lock found and we can reset startedIndex and clear all locks array\r\n\t\tif (startIndex[account] >= locksLength) {\r\n            startIndex[account] = 0;\r\n            userLocksLength[account] = 0;\r\n        }\r\n    }\r\n\r\n    function _updateReward(address account) internal {\r\n        require(!emergencyMode, \"Not allowed in emergency mode\");\r\n        rewardPerTokenStored = rewardPerToken();            \r\n        lastUpdateTime = lastTimeRewardApplicable();        \r\n\t\tif (account != address(0)) {\r\n            rewards[account] = earned(account);\r\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\r\n        }                \r\n    }\r\n\r\n    // Claim all pending staking rewards\r\n    function _claimReward(address account, bool transfer) internal returns (uint256 reward) {\r\n\t\treward = rewards[account];\r\n        if (reward != 0) {\r\n            rewards[account] = 0;\r\n            if (transfer) {\r\n                IERC20(token).safeTransfer(account, reward);\r\n                emit RewardPaid(account, reward);\r\n            } \r\n        }        \r\n    }\r\n\r\n    // Transfer tokens to user and penalty to xShade rewards distributor or wallet\r\n    function _sendTokensAndPenalty(uint256 tokensAmount, uint256 penaltyAmount) internal {         \r\n\t\tIERC20(token).safeTransfer(msg.sender, tokensAmount);\r\n        totalSupply -= (tokensAmount + penaltyAmount);\r\n\r\n\t\tif (penaltyAmount != 0) {\r\n\t\t\t_notifyReward(penaltyAmount);\t\t\t\r\n\t\t\temit PenaltyPaid(msg.sender, penaltyAmount); \r\n        }\r\n    }\r\n\r\n    //  \r\n    function _notifyReward(uint256 reward) internal {   \r\n\t\tif (block.timestamp >= periodFinish) {\r\n            rewardRate = reward / rewardsDuration;\r\n        } else {\r\n            uint256 remaining = periodFinish - block.timestamp;\r\n            uint256 leftover = remaining * rewardRate;\r\n            rewardRate = (reward + leftover) / rewardsDuration;\r\n        }\r\n\r\n        lastUpdateTime = block.timestamp;\r\n        periodFinish = block.timestamp + rewardsDuration;\r\n    }\r\n\r\n    // -------------------------------- EVENTS -----------------------------------\r\n    event RewardAdded(uint256 reward);\r\n    event Deposited(address indexed user, uint256 amount);    \r\n\tevent Withdrawn(address indexed user, uint256 amount);\r\n\r\n\tevent PenaltyPaid(address indexed user, uint256 amount);     \r\n    event RewardPaid(address indexed user, uint256 reward);    \r\n    event Recovered(address token, uint256 amount);\t\r\n    \r\n\tevent SetPenalty(uint256 penalty);\r\n\tevent SetEmergencyMode();\r\n\t\r\n\tevent TokenReceived(uint256 amount);\r\n\tevent ETHReceived(uint256 amount);\r\n\t\r\n\tevent EmergencyWithdrawn(address indexed user, uint256 amount);\t\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PenaltyPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SetEmergencyMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"SetPenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAndDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimRewardForDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balanceToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_penaltyPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyModeStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDurationMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockStakers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyRewardETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"path\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyPercentMAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setEmergencyMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPenaltyPercent\",\"type\":\"uint256\"}],\"name\":\"setPenaltyPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"startIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateUserLocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_locked\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct TORII_Loyalty.LockedBalance[]\",\"name\":\"_userLocks\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userLocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLocksLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawUnlocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TORII_Loyalty", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://90467fb71c4ebd646270a85fa1ace2cb2af7a81b9c4860e4013e6b56b387f8e4"}