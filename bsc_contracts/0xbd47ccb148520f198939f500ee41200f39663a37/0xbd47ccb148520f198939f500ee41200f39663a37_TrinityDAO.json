{"SourceCode": "{\"Core.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\n\\n\\nabstract contract Core {\\n    address public contractOwner;\\n\\n    constructor() {\\n        contractOwner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == contractOwner, \\\"C: 1\\\");\\n        _;\\n    }\\n\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.14;\\n\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"},\"IGTToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\n\\n\\ninterface IGTToken {\\n    event TokenTransfer(address indexed initiator, address indexed receiver, uint amount, uint reason, uint itemNumber);\\n\\n    function getAccountStatusLevel(address accountAddress) external view returns (uint8);\\n    function getStatusLevelViaBalance(uint balance) external view returns (uint8);\\n    function setDistributor(address _distributor) external;\\n    function batchMint(address[] memory to, uint[] memory amount, address initiator, uint reason, uint itemNumber) external;\\n    function balanceOf(address account) external view returns (uint256);\\n    function setTokenLimit(uint _tokenLimit) external;\\n}\\n\"},\"IMatrix.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\n\\n\\ninterface IMatrix {\\n    function initializeLevelTree(\\n        address[] memory rootAddresses\\n    ) external;\\n\\n    function addAccountInLevelTree(\\n        address accountAddress,\\n        address refererAddress\\n    ) external;\\n\\n    function addAccountInLevelTree(\\n        address refererAddress\\n    ) external;\\n\\n    function checkRefund(address accountAddress, uint8 level) external;\\n    function hackAlarm(address accountAddress, uint8 level) external;\\n\\n    function getLevelPrice() external view returns (uint);\\n\\n    function getReinvestCount(\\n        address accountAddress\\n    ) external view returns (uint);\\n\\n    function getAccountMatrix(\\n        address accountAddress\\n    ) external view returns (address[3] memory, string[3] memory);\\n\\n    function getLevelAccount(\\n        address accountAddress\\n    )\\n    external view returns (address[3] memory, uint16, uint);\\n\\n    function getAccountInfo(\\n        address accountAddress\\n    ) external view returns (string memory);\\n\\n    function getHackAlarm(\\n        address accountAddress\\n    )\\n    external\\n    view\\n    returns (bool);\\n\\n    function getParentMatrix(\\n        address refererAddress\\n    ) external view returns (address[4] memory, string[4] memory);\\n\\n    function getParentAddress(\\n        address accountAddress\\n    ) external view returns (address);\\n\\n    function isOnLevel(\\n        address accountAddress\\n    ) external view returns(bool);\\n\\n    function isParentOnNextLevel(\\n        address accountAddress\\n    ) external view returns(bool);\\n\\n    function initTime() external view returns(uint);\\n\\n    function isLevelTreeInitialized() external view returns (bool);\\n    function isRoot(address accountAddress) external view returns (bool);\\n    function getActivationPrice() external view returns (uint);\\n    function getTotalPrice() external view returns (uint);\\n    function refundRequest(address accountAddress) external;\\n    function getTrinaryBonus(address accountAddress, uint amount, address receiverAddress) external;\\n    function getAccountStats(address accountAddress) external view returns (uint16, uint);\\n    function transfer(address addr, uint amount) external;\\n    function levelIsBought(address accountAddress) external view returns (bool);\\n    function getRefererAddressPlacedInMatrix(address addr) external view returns (address, bool);\\n\\n    event Refunds(address indexed account, uint refundAmount, bool refundSuccess);\\n    event MissedPayment(address indexed account, address indexed initiator);\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\"},\"TrinityDAO.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\u0027./Core.sol\\u0027;\\nimport \\u0027./IMatrix.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IGTToken.sol\\u0027;\\n\\nstruct AccountInfo {\\n    address accountAddress;\\n    address refererAddress;\\n}\\n\\nstruct DisplayAccountInfo {\\n    address accountAddress;\\n    address refererAddress;\\n    uint gtTokenAmount;\\n}\\n\\nstruct LevelInfo {\\n    uint[6] gtTokenForPurchase;\\n}\\n\\nstruct PlayerLevelInfo {\\n    address accountAddress;\\n    address[12] trinars;\\n    uint16 reinvestCount;\\n    uint levelBalance;\\n    bool hasMatrix;\\n}\\n\\n\\ncontract TrinityDAO is Core, ReentrancyGuard {\\n\\n  address[] public players;\\n  mapping(address =\\u003e AccountInfo) public accountsByAddress;\\n  IERC20 public IERC20Token;\\n  IGTToken public GTToken;\\n  uint public gtTokenDecimal = 18;\\n  uint public gtTokenSize = 10 ** gtTokenDecimal;\\n  mapping(uint8 =\\u003e IMatrix) public localMatrixes;\\n  uint8 public matrixCount;\\n  mapping(uint8 =\\u003e LevelInfo) internal levelInfos;\\n  address[] public defaultReferers;\\n\\n  event LevelPurchase(address indexed account, uint8 level);\\n  event Payment(uint level, address indexed sender, address indexed receiver, uint position, uint16 reinvestCount, uint amount);\\n  event ActivationBonus(address indexed receiver, address indexed initiator, uint amount, uint8 level, bool received);\\n  event Refunds(address indexed account, uint refundAmount, uint8 level);\\n  event MissedPayment(address indexed account, address indexed initiator, uint8 level);\\n  event LeaderBonus(address indexed receiver, address indexed initiator, uint amount, uint8 level, bool received);\\n\\n  constructor(\\n      address _IERC20Token,\\n      address _IGTToken\\n  ) Core() {\\n      _init();\\n      IERC20Token = IERC20(_IERC20Token);\\n      GTToken = IGTToken(_IGTToken);\\n      defaultReferers.push(msg.sender);\\n  }\\n\\n  function _init() internal {\\n      uint zeroToken = uint(0) * gtTokenSize;\\n      levelInfos[1] = LevelInfo([uint(5) * gtTokenSize, zeroToken, zeroToken, zeroToken, zeroToken, zeroToken]);\\n      levelInfos[2] = LevelInfo([uint(5) * gtTokenSize, uint(5) * gtTokenSize, uint(5) * gtTokenSize, zeroToken, zeroToken, zeroToken]);\\n      levelInfos[3] = LevelInfo([uint(10) * gtTokenSize, uint(5) * gtTokenSize, uint(5) * gtTokenSize, zeroToken, zeroToken, zeroToken]);\\n      levelInfos[4] = LevelInfo([uint(15) * gtTokenSize, uint(5) * gtTokenSize, uint(5) * gtTokenSize, zeroToken, zeroToken, zeroToken]);\\n      levelInfos[5] = LevelInfo([uint(20) * gtTokenSize, uint(10) * gtTokenSize, uint(10) * gtTokenSize, uint(5) * gtTokenSize, uint(5) * gtTokenSize, uint(5) * gtTokenSize]);\\n      levelInfos[6] = LevelInfo([uint(40) * gtTokenSize, uint(20) * gtTokenSize, uint(20) * gtTokenSize, uint(10) * gtTokenSize, uint(10) * gtTokenSize, uint(10) * gtTokenSize]);\\n      levelInfos[7] = LevelInfo([uint(80) * gtTokenSize, uint(40) * gtTokenSize, uint(40) * gtTokenSize, uint(20) * gtTokenSize, uint(20) * gtTokenSize, uint(20) * gtTokenSize]);\\n      levelInfos[8] = LevelInfo([uint(160) * gtTokenSize, uint(80) * gtTokenSize, uint(80) * gtTokenSize, uint(40) * gtTokenSize, uint(40) * gtTokenSize, uint(40) * gtTokenSize]);\\n      levelInfos[9] = LevelInfo([uint(200) * gtTokenSize, uint(100) * gtTokenSize, uint(100) * gtTokenSize, uint(50) * gtTokenSize, uint(50) * gtTokenSize, uint(50) * gtTokenSize]);\\n      levelInfos[10] = LevelInfo([uint(400) * gtTokenSize, uint(200) * gtTokenSize, uint(200) * gtTokenSize, uint(100) * gtTokenSize, uint(100) * gtTokenSize, uint(100) * gtTokenSize]);\\n      levelInfos[11] = LevelInfo([uint(800) * gtTokenSize, uint(400) * gtTokenSize, uint(400) * gtTokenSize, uint(200) * gtTokenSize, uint(200) * gtTokenSize, uint(200) * gtTokenSize]);\\n      levelInfos[12] = LevelInfo([uint(1600) * gtTokenSize, uint(800) * gtTokenSize, uint(800) * gtTokenSize, uint(400) * gtTokenSize, uint(400) * gtTokenSize, uint(400) * gtTokenSize]);\\n      levelInfos[13] = LevelInfo([uint(2000) * gtTokenSize, uint(1000) * gtTokenSize, uint(1000) * gtTokenSize, uint(500) * gtTokenSize, uint(500) * gtTokenSize, uint(500) * gtTokenSize]);\\n      levelInfos[14] = LevelInfo([uint(4000) * gtTokenSize, uint(2000) * gtTokenSize, uint(2000) * gtTokenSize, uint(1000) * gtTokenSize, uint(1000) * gtTokenSize, uint(1000) * gtTokenSize]);\\n      levelInfos[15] = LevelInfo([uint(8000) * gtTokenSize, uint(4000) * gtTokenSize, uint(4000) * gtTokenSize, uint(2000) * gtTokenSize, uint(2000) * gtTokenSize, uint(2000) * gtTokenSize]);\\n      levelInfos[16] = LevelInfo([uint(16000) * gtTokenSize, uint(8000) * gtTokenSize, uint(8000) * gtTokenSize, uint(4000) * gtTokenSize, uint(4000) * gtTokenSize, uint(4000) * gtTokenSize]);\\n  }\\n\\n  modifier isRoot(uint8 level, address addr) {\\n     require(\\n         localMatrixes[level].isRoot(addr),\\n         \\\"DE: 12\\\"\\n     );\\n     _;\\n  }\\n\\n  modifier isLevelTreeInitialized(uint8 level) {\\n    require(\\n        localMatrixes[level].isLevelTreeInitialized(),\\n        \\\"DE: 2\\\"\\n    );\\n      _;\\n  }\\n\\n\\n  function isSubMatrix() internal view returns (bool){\\n      bool condition = false;\\n      for (uint i = 1; i \\u003c= matrixCount; i++) {\\n          if (address(localMatrixes[uint8(i)]) == msg.sender) { condition = true; }\\n      }\\n      return condition;\\n  }\\n\\n  modifier subMatrixOnly() {\\n      require(\\n          isSubMatrix(),\\n          \\\"DE: 3.\\\"\\n      );\\n      _;\\n  }\\n\\n  function isNotZeroAddress(address accountAddress) internal pure {\\n      require(\\n          accountAddress != address(0),\\n          \\\"DE: 4\\\"\\n      );\\n  }\\n\\n  function isSendByAccount(address accountAddress) internal view {\\n      require(\\n          msg.sender == accountsByAddress[accountAddress].accountAddress,\\n          \\\"DE: 5\\\"\\n      );\\n  }\\n\\n  function getRandomReferer() internal view returns (address) {\\n      bytes32 randomBytes = keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender));\\n      uint256 randomNumber = uint256(randomBytes);\\n      return defaultReferers[randomNumber % defaultReferers.length];\\n  }\\n\\n  function setPrograms(\\n      address[] memory _localMatrixes\\n  ) external onlyOwner {\\n      for (uint8 i = 1; i \\u003c _localMatrixes.length + 1; i++) {\\n          localMatrixes[i] = IMatrix(_localMatrixes[i-1]);\\n      }\\n      matrixCount = uint8(_localMatrixes.length);\\n  }\\n\\n  function setDefaultUsers(\\n      address[] memory _defaultReferers\\n  ) external onlyOwner {\\n      defaultReferers = _defaultReferers;\\n  }\\n\\n  function registerNewAccount(\\n      address referer,\\n      address accountAddress,\\n      bool isRoot\\n  ) internal {\\n      if (accountsByAddress[accountAddress].accountAddress != address(0)) { return; }\\n      if (referer == address(0) \\u0026\\u0026 !isRoot) {\\n          referer = getRandomReferer();\\n      }\\n      accountsByAddress[accountAddress] = AccountInfo(\\n          accountAddress,\\n          referer\\n      );\\n      players.push(accountAddress);\\n  }\\n\\n  function validatedRegisterNewAccount(address accountAddress, address referer) internal {\\n      if (accountsByAddress[accountAddress].accountAddress == address(0)) {\\n          isNotZeroAddress(accountAddress);\\n          registerNewAccount(referer, accountAddress, false);\\n      }\\n      else { isSendByAccount(accountAddress); }\\n  }\\n\\n  function getPrice(uint8 level) public view returns (uint) {\\n      return localMatrixes[level].getTotalPrice();\\n  }\\n\\n  function getLevelPrice(uint8 level) public view returns (uint) {\\n      return localMatrixes[level].getLevelPrice();\\n  }\\n\\n  function buyProgram(\\n      address accountAddress,\\n      address referer,\\n      uint8 level\\n  ) external isLevelTreeInitialized(level) nonReentrant {\\n      if (level != 1) {\\n          require(\\n              localMatrixes[level-1].levelIsBought(accountAddress),\\n              \\u0027DE: 6\\u0027\\n          );\\n      }\\n      validatedRegisterNewAccount(accountAddress, referer);\\n      uint levelPrice = localMatrixes[level].getLevelPrice();\\n      uint activationPrice = localMatrixes[level].getActivationPrice();\\n      bool transferSuccess = IERC20Token.transferFrom(\\n          accountAddress,\\n          address(this),\\n          levelPrice + activationPrice\\n      );\\n      require(\\n          transferSuccess,\\n          \\u0027DE: 11\\u0027\\n      );\\n      _sendInLocalMatrix(level, levelPrice);\\n      _sendActivationBonus(accountAddress, activationPrice, 5, level);\\n      _sendGTTokenForPurchase(accountAddress, level);\\n      localMatrixes[level].addAccountInLevelTree(\\n          accountAddress,\\n          accountsByAddress[accountAddress].refererAddress\\n      );\\n      emit LevelPurchase(accountAddress, level);\\n  }\\n\\n  function _sendInLocalMatrix(uint8 level, uint amount) internal {\\n      IERC20Token.transfer(address(localMatrixes[level]), amount);\\n  }\\n\\n  function pay(address accountAddress, uint amount) external subMatrixOnly {\\n      IERC20Token.transfer(accountsByAddress[accountAddress].accountAddress, amount);\\n  }\\n\\n  function programTransfer(uint8 from, uint8 to, uint amount) external onlyOwner {\\n      localMatrixes[from].transfer(address(localMatrixes[to]), amount);\\n  }\\n\\n  function sendActivationBonus(\\n      address accountAddress,\\n      uint activationPrice,\\n      uint8 bonusCount,\\n      uint8 level\\n  ) external subMatrixOnly {\\n      _sendActivationBonus(accountAddress, activationPrice, bonusCount, level);\\n  }\\n\\n  function _sendActivationBonus(\\n      address accountAddress,\\n      uint activationPrice,\\n      uint8 bonusCount,\\n      uint8 level\\n  ) internal {\\n      uint8 bonusReceived;\\n      uint activationBonus = activationPrice / bonusCount;\\n      address refererAddress = accountAddress;\\n      while (bonusReceived \\u003c bonusCount) {\\n          refererAddress = accountsByAddress[refererAddress].refererAddress;\\n          if (refererAddress == address(0)) { break; }\\n          if (!localMatrixes[level].isOnLevel(refererAddress) || localMatrixes[level].getHackAlarm(refererAddress)) {\\n              emit ActivationBonus(refererAddress, accountAddress, activationBonus, level, false);\\n              continue;\\n          }\\n          IERC20Token.transfer(refererAddress, activationBonus);\\n          emit ActivationBonus(refererAddress, accountAddress, activationBonus, level, true);\\n          bonusReceived += 1;\\n      }\\n      if (bonusReceived \\u003c bonusCount) {\\n          IERC20Token.transfer(contractOwner, activationBonus * (bonusCount - bonusReceived));\\n          emit ActivationBonus(contractOwner, accountAddress, activationBonus * (bonusCount - bonusReceived), level, true);\\n      }\\n  }\\n\\n  function sendBonuses(address accountAddress, uint amount, uint8 level) external subMatrixOnly {\\n      uint leaderBonusesSpent = sendLeaderBonuses(accountAddress, amount, level);\\n  }\\n\\n  function sendLeaderBonuses(address accountAddress, uint amount, uint8 level) internal returns (uint) {\\n    uint8 bonusReceived;\\n    uint bonusCount = 5;\\n    uint bonusAmount = amount / bonusCount;\\n    address refererAddress = accountAddress;\\n    while (bonusReceived \\u003c bonusCount) {\\n        refererAddress = accountsByAddress[refererAddress].refererAddress;\\n        if (refererAddress == address(0)) { break; }\\n        if (!localMatrixes[level].isOnLevel(refererAddress) || localMatrixes[level].getHackAlarm(refererAddress)) {\\n            emit LeaderBonus(refererAddress, accountAddress, bonusAmount, level, false);\\n            continue;\\n        }\\n        IERC20Token.transfer(refererAddress, bonusAmount);\\n        emit LeaderBonus(refererAddress, accountAddress, bonusAmount, level, true);\\n        bonusReceived += 1;\\n    }\\n    if (bonusReceived \\u003c bonusCount) {\\n        IERC20Token.transfer(contractOwner, bonusAmount * (bonusCount - bonusReceived));\\n        emit LeaderBonus(contractOwner, accountAddress, bonusAmount * (bonusCount - bonusReceived), level, true);\\n    }\\n    return bonusAmount * (bonusCount - bonusReceived);\\n  }\\n\\n  function sendGTTokenForPurchase(address accountAddress, uint8 level) public subMatrixOnly {\\n      _sendGTTokenForPurchase(accountAddress, level);\\n  }\\n\\n  function _sendGTTokenForPurchase(address accountAddress, uint8 level) internal {\\n      address initiator = accountAddress;\\n      LevelInfo memory levelInfo = levelInfos[level];\\n      address[] memory receivers = new address[](levelInfo.gtTokenForPurchase.length);\\n      uint[] memory amount = new uint[](levelInfo.gtTokenForPurchase.length);\\n      for (uint8 i = 0; i \\u003c levelInfo.gtTokenForPurchase.length; i++) {\\n          receivers[i] = accountAddress;\\n          amount[i] = levelInfo.gtTokenForPurchase[i];\\n          if (accountsByAddress[accountAddress].refererAddress != address(0)) {\\n              accountAddress = accountsByAddress[accountAddress].refererAddress;\\n          }\\n      }\\n      GTToken.batchMint(receivers, amount, initiator, 1, level);\\n  }\\n\\n  function getReferer(address accountAddress) public view returns (address) {\\n      AccountInfo storage account = accountsByAddress[accountAddress];\\n      if (account.accountAddress != address(0) \\u0026\\u0026 account.refererAddress == address(0)) {\\n          return players[1];\\n      }\\n      return accountsByAddress[accountAddress].refererAddress;\\n  }\\n\\n  function isOnLevel(\\n      address accountAddress,\\n      uint8 level\\n  ) public view returns (bool) {\\n      return localMatrixes[level].isOnLevel(accountAddress);\\n  }\\n\\n  function emitPayment(\\n      uint level,\\n      address senderAddress,\\n      address receiverAddress,\\n      uint position,\\n      uint16 reinvestCount,\\n      uint amount\\n  ) external subMatrixOnly {\\n      emit Payment(level, senderAddress, receiverAddress, position, reinvestCount, amount);\\n  }\\n\\n  function initializeProgram(\\n      address[] memory rootAddresses,\\n      uint8 level\\n  ) external onlyOwner {\\n      address root = rootAddresses[0];\\n      if (accountsByAddress[root].accountAddress == address(0)) {\\n          isNotZeroAddress(root);\\n          registerNewAccount(address(0), root, true);\\n      }\\n      rootAddresses[0] = root;\\n      for (uint i = 1; i \\u003c rootAddresses.length; i++) {\\n          address rand = rootAddresses[i];\\n          if (accountsByAddress[rand].accountAddress == address(0)) {\\n              isNotZeroAddress(rand);\\n              registerNewAccount(root, rand, true);\\n          }\\n      }\\n      localMatrixes[level].initializeLevelTree(rootAddresses);\\n  }\\n\\n  function getAccountInfo(address accountAddress) public view returns (address, address) {\\n      return (\\n          accountsByAddress[accountAddress].accountAddress,\\n          accountsByAddress[accountAddress].refererAddress\\n      );\\n  }\\n\\n  function isLocalMatrixInitialized(uint8 level) external view returns (bool) {\\n      if (level \\u003e 16) { return false; }\\n      return localMatrixes[level].isLevelTreeInitialized();\\n  }\\n\\n  function refundRequest(uint8 level) external nonReentrant {\\n      localMatrixes[level].refundRequest(msg.sender);\\n  }\\n\\n  function getTrinaryBonus(address receiverAddress, uint amount, uint8 level) external isRoot(level, msg.sender) {\\n      localMatrixes[level].getTrinaryBonus(msg.sender, amount, receiverAddress);\\n  }\\n\\n  function clearOffsetLimitPlayers(uint offset, uint limit) internal view returns (uint, uint) {\\n      if (offset \\u003e players.length) {\\n          offset = players.length;\\n      }\\n      if (offset + limit \\u003e players.length) {\\n          limit = players.length - offset;\\n      }\\n      return (offset, limit);\\n  }\\n\\n  function getPlayersAccountInfo(uint offset, uint limit) external view returns (DisplayAccountInfo[] memory) {\\n      (offset, limit) = clearOffsetLimitPlayers(offset, limit);\\n      DisplayAccountInfo[] memory PlayersDisplayAccountInfo = new DisplayAccountInfo[](limit);\\n      uint pos;\\n      for (uint i = offset; i \\u003c offset + limit; i++) {\\n          pos = i - offset;\\n          PlayersDisplayAccountInfo[pos].accountAddress = accountsByAddress[players[i]].accountAddress;\\n          PlayersDisplayAccountInfo[pos].refererAddress = accountsByAddress[players[i]].refererAddress;\\n          PlayersDisplayAccountInfo[pos].gtTokenAmount = GTToken.balanceOf(players[i]);\\n      }\\n      return PlayersDisplayAccountInfo;\\n  }\\n\\n  function getMatrixTree(uint8 level, address accountAddress, uint depth) public view returns (address[] memory) {\\n      uint length;\\n      uint posOffset;\\n      for (uint i = 0; i \\u003c= depth; i++) {\\n          length += 3 ** i;\\n      }\\n      address[] memory tree = new address[](length);\\n      tree[0] = accountAddress;\\n      uint startPos;\\n      for (uint i = 0; i \\u003c depth; i++) {\\n          if (i != 0) {\\n              startPos += 3 ** (i - 1);\\n          }\\n          for (uint j = 0; j \\u003c 3 ** i; j++) {\\n              try localMatrixes[level].getLevelAccount(tree[startPos + j]) returns (address[3] memory _childs, uint16 _reinvestCount, uint _levelBalance) {\\n                  posOffset = startPos + 3 ** i + 3 * j;\\n                  tree[posOffset] = _childs[0];\\n                  tree[posOffset + 1] = _childs[1];\\n                  tree[posOffset + 2] = _childs[2];\\n              } catch Error(string memory _err) {\\n                  continue;\\n              }\\n          }\\n      }\\n      return tree;\\n  }\\n\\n  function getPlayerLevelInfo(uint8 level, address accountAddress) public view returns (PlayerLevelInfo memory) {\\n      address[12] memory childs;\\n      address[3] memory firstChilds;\\n      address[3] memory secondChilds;\\n      uint16[2] memory reinvestCount;\\n      uint[2] memory levelBalance;\\n      uint childOffset;\\n      bool hasMatrix;\\n      try localMatrixes[level].getLevelAccount(accountAddress) returns (address[3] memory _firstChilds, uint16 _reinvestCount, uint _levelBalance) {\\n          (firstChilds, reinvestCount[0], levelBalance[0]) = (_firstChilds, _reinvestCount, _levelBalance);\\n          hasMatrix = true;\\n          for (uint i = 0; i \\u003c 3; i++) {\\n              if (firstChilds[i] != address(0) \\u0026\\u0026 localMatrixes[level].isOnLevel(firstChilds[i])) {\\n                  (secondChilds, reinvestCount[1], levelBalance[1]) = localMatrixes[level].getLevelAccount(firstChilds[i]);\\n              } else {\\n                  secondChilds = [address(0), address(0), address(0)];\\n              }\\n              childOffset = i * 4;\\n              childs[childOffset] = firstChilds[i];\\n              childs[childOffset + 1] = secondChilds[0];\\n              childs[childOffset + 2] = secondChilds[1];\\n              childs[childOffset + 3] = secondChilds[2];\\n          }\\n      } catch Error(string memory _err) {\\n          childs = [address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0)];\\n          hasMatrix = false;\\n          (reinvestCount[0], levelBalance[0]) = localMatrixes[level].getAccountStats(accountAddress);\\n      }\\n      PlayerLevelInfo memory info = PlayerLevelInfo(\\n          accountAddress,\\n          childs,\\n          reinvestCount[0],\\n          levelBalance[0],\\n          hasMatrix\\n      );\\n      return info;\\n  }\\n\\n  function getPlayerLevelsInfo(address accountAddress) public view returns (PlayerLevelInfo[] memory) {\\n      PlayerLevelInfo[] memory PlayerLevelsInfo = new PlayerLevelInfo[](16);\\n      for (uint8 i = 1; i \\u003c 17; i++) {\\n          PlayerLevelsInfo[i - 1] = getPlayerLevelInfo(i, accountAddress);\\n      }\\n      return PlayerLevelsInfo;\\n  }\\n\\n  function getPlayersLevelInfo(uint8 level, uint offset, uint limit) external view returns (PlayerLevelInfo[] memory) {\\n      (offset, limit) = clearOffsetLimitPlayers(offset, limit);\\n      PlayerLevelInfo[] memory PlayersLevelInfo = new PlayerLevelInfo[](limit);\\n      for (uint i = offset; i \\u003c offset + limit; i++) {\\n          PlayersLevelInfo[i - offset] = getPlayerLevelInfo(level, players[i]);\\n      }\\n      return PlayersLevelInfo;\\n  }\\n\\n  function getMatrixParents(uint8 level, address accountAddress, uint depth) public view returns (address[] memory) {\\n      address[] memory parents = new address[](depth);\\n      for (uint i = 0; i \\u003c depth; i++) {\\n          try localMatrixes[level].getParentAddress(accountAddress) returns (address _parentAddress) {\\n              parents[i] = _parentAddress;\\n          } catch Error(string memory _err) {\\n              parents[i] = address(0);\\n          }\\n          accountAddress = parents[i];\\n      }\\n      return parents;\\n  }\\n\\n  function emitRefundsEvent(address accountAddress, uint refundAmount, uint8 level) public subMatrixOnly {\\n      emit Refunds(accountAddress, refundAmount, level);\\n  }\\n\\n  function emitMissedPaymentEvent(address accountAddress, address initiatorAddress, uint8 level) public subMatrixOnly {\\n      emit MissedPayment(accountAddress, initiatorAddress, level);\\n  }\\n\\n  function getLevelInfos() public view returns (LevelInfo[16] memory) {\\n      LevelInfo[16] memory levelInfosArr;\\n      uint8 pos;\\n      for (uint i = 0; i \\u003c 16; i++) {\\n          pos = uint8(i)+1;\\n          levelInfosArr[i] = levelInfos[pos];\\n      }\\n      return levelInfosArr;\\n  }\\n\\n  function getLevelsInitialized() external view returns (bool[16] memory) {\\n      bool[16] memory statuses;\\n      for (uint i = 0; i \\u003c 16; i++) {\\n          statuses[i] = localMatrixes[uint8(i)+1].isLevelTreeInitialized();\\n      }\\n      return statuses;\\n  }\\n\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_IERC20Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_IGTToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"received\",\"type\":\"bool\"}],\"name\":\"ActivationBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"received\",\"type\":\"bool\"}],\"name\":\"LeaderBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"LevelPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"MissedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"reinvestCount\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Refunds\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GTToken\",\"outputs\":[{\"internalType\":\"contract IGTToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IERC20Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsByAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refererAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"buyProgram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defaultReferers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initiatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"emitMissedPaymentEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"reinvestCount\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"emitRefundsEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLevelInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[6]\",\"name\":\"gtTokenForPurchase\",\"type\":\"uint256[6]\"}],\"internalType\":\"struct LevelInfo[16]\",\"name\":\"\",\"type\":\"tuple[16]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"getLevelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLevelsInitialized\",\"outputs\":[{\"internalType\":\"bool[16]\",\"name\":\"\",\"type\":\"bool[16]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depth\",\"type\":\"uint256\"}],\"name\":\"getMatrixParents\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depth\",\"type\":\"uint256\"}],\"name\":\"getMatrixTree\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getPlayerLevelInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address[12]\",\"name\":\"trinars\",\"type\":\"address[12]\"},{\"internalType\":\"uint16\",\"name\":\"reinvestCount\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"levelBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasMatrix\",\"type\":\"bool\"}],\"internalType\":\"struct PlayerLevelInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getPlayerLevelsInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address[12]\",\"name\":\"trinars\",\"type\":\"address[12]\"},{\"internalType\":\"uint16\",\"name\":\"reinvestCount\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"levelBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasMatrix\",\"type\":\"bool\"}],\"internalType\":\"struct PlayerLevelInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getPlayersAccountInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refererAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gtTokenAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DisplayAccountInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getPlayersLevelInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address[12]\",\"name\":\"trinars\",\"type\":\"address[12]\"},{\"internalType\":\"uint16\",\"name\":\"reinvestCount\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"levelBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasMatrix\",\"type\":\"bool\"}],\"internalType\":\"struct PlayerLevelInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getReferer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"getTrinaryBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gtTokenDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gtTokenSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"rootAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"initializeProgram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"isLocalMatrixInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"isOnLevel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"localMatrixes\",\"outputs\":[{\"internalType\":\"contract IMatrix\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matrixCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"from\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"to\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"programTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"refundRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"activationPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"bonusCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"sendActivationBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"sendBonuses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"sendGTTokenForPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_defaultReferers\",\"type\":\"address[]\"}],\"name\":\"setDefaultUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_localMatrixes\",\"type\":\"address[]\"}],\"name\":\"setPrograms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TrinityDAO", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "5", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000639fa623d730856988e077a4de972f527756fc2d", "EVMVersion": "london", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3e5cfd8d363118ae2d6aa09a9cf264cfea6b18569b642814152ce4e224d97ead"}