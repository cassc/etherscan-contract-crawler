{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PrivateSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ncontract PrivateSale {\\n    address public owner;\\n    address public projectToken;\\n    uint256 public icoStartTime;\\n    uint256 public icoEndTime;\\n    bool public icoActive;\\n    uint256 public maxContribution;\\n    uint256 public totalParticipations = 0;\\n    uint256 public totalContributions = 0;\\n    uint256 public currentRate;\\n    mapping(address => uint256) public contributions;\\n    mapping(address => bool) public claimedTokens;\\n    mapping(address => bool) public whitelist; // New mapping for whitelist\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not the contract owner\\\");\\n        _;\\n    }\\n\\n    modifier duringICO() {\\n        require(icoActive, \\\"ICO not active\\\");\\n        // require(block.timestamp >= icoStartTime && block.timestamp <= icoEndTime, \\\"ICO is not ongoing\\\");\\n        _;\\n    }\\n\\n    modifier afterICO() {\\n        require(!icoActive, \\\"ICO is still active\\\");\\n        // require(block.timestamp > icoEndTime, \\\"ICO has not ended yet\\\");\\n        _;\\n    }\\n\\n    modifier canContribute() {\\n        require(whitelist[msg.sender], \\\"Address not whitelisted\\\");\\n        require(contributions[msg.sender] == 0, \\\"Already contributed\\\");\\n        require(msg.value <= maxContribution, \\\"Exceeds maximum contribution\\\");\\n        _;\\n    }\\n\\n    modifier hasNotClaimedTokens() {\\n        require(whitelist[msg.sender], \\\"Address not whitelisted\\\");\\n        require(!claimedTokens[msg.sender], \\\"Tokens already claimed\\\");\\n        _;\\n    }\\n\\n    event Contribution(address indexed contributor, uint256 amount, uint256 currentRate);\\n    event TokensClaimed(address indexed contributor, uint256 amount);\\n    event ICOStarted(uint256 startTime, uint256 endTime);\\n    event ICOStopped();\\n    event WhitelistUpdated(address[] addresses, bool[] statuses); // New event for whitelist updates\\n\\n    constructor(address _projectToken, uint256 _maxContribution) {\\n        owner = msg.sender;\\n        projectToken = _projectToken;\\n        maxContribution = _maxContribution;\\n    }\\n\\n    function startICO(uint256 _duration) external onlyOwner {\\n        require(!icoActive, \\\"ICO already active\\\");\\n        icoStartTime = block.timestamp;\\n        icoEndTime = icoStartTime + _duration;\\n        icoActive = true;\\n        emit ICOStarted(icoStartTime, icoEndTime);\\n    }\\n\\n    function stopICO() external onlyOwner {\\n        require(icoActive, \\\"ICO not active\\\");\\n        icoActive = false;\\n        emit ICOStopped();\\n    }\\n\\n    function contribute() external payable canContribute duringICO {\\n        require(msg.value > 0, \\\"Contribution amount must be greater than 0\\\");\\n        contributions[msg.sender] = msg.value;\\n        totalContributions += msg.value;\\n        totalParticipations += 1;\\n        currentRate = IERC20(projectToken).balanceOf(address(this)) / totalContributions;\\n        emit Contribution(msg.sender, msg.value, currentRate);\\n    }\\n\\n    function claimTokens() external hasNotClaimedTokens afterICO {\\n        require(contributions[msg.sender] > 0, \\\"No contribution found\\\");\\n\\n        uint256 tokenAmount = contributions[msg.sender] * currentRate;\\n\\n        claimedTokens[msg.sender] = true;\\n\\n        // Transfer tokens to contributor\\n        require(IERC20(projectToken).transfer(msg.sender, tokenAmount), \\\"Token transfer failed\\\");\\n\\n        emit TokensClaimed(msg.sender, tokenAmount);\\n    }\\n\\n    function withdraw() external onlyOwner afterICO {\\n        // Transfer all ETH to the owner\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    // Add function to add or remove addresses from the whitelist\\n    function updateWhitelist(address[] memory _addresses, bool[] memory _statuses) external onlyOwner {\\n        require(_addresses.length == _statuses.length, \\\"Arrays length mismatch\\\");\\n        for (uint256 i = 0; i < _addresses.length; i++) {\\n            whitelist[_addresses[i]] = _statuses[i];\\n        }\\n        emit WhitelistUpdated(_addresses, _statuses);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_projectToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxContribution\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentRate\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"ICOStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICOStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"statuses\",\"type\":\"bool[]\"}],\"name\":\"WhitelistUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"startICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalParticipations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_statuses\",\"type\":\"bool[]\"}],\"name\":\"updateWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PrivateSale", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000da4346fd3345b485ff6d2ebee236af565eb110650000000000000000000000000000000000000000000000001bc16d674ec80000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}