{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.7.0;\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\npragma solidity 0.7.0;\r\n\r\n\r\nlibrary LibERC20 {\r\n\r\n   function approveQuery(address _token,address _spender) internal view returns(uint256 _amount){\r\n       _amount=IERC20(_token).allowance(msg.sender,_spender);\r\n   }\r\n\r\n   function queryDecimals(address _token) internal view returns(uint256 decimals){\r\n       decimals=IERC20(_token).decimals();\r\n   }\r\n\r\n    function transferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_token)\r\n        }\r\n        require(size > 0, \"LibERC20: Address has no code\");\r\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _value));\r\n        handleReturn(success, result);\r\n    }\r\n\r\n    function transfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_token)\r\n        }\r\n        require(size > 0, \"LibERC20: Address has no code\");\r\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.transfer.selector, _to, _value));\r\n        handleReturn(success, result);\r\n    }\r\n\r\n    function handleReturn(bool _success, bytes memory _result) internal pure {\r\n        if (_success) {\r\n            if (_result.length > 0) {\r\n                require(abi.decode(_result, (bool)), \"LibERC20: contract call returned false\");\r\n            }\r\n        } else {\r\n            if (_result.length > 0) {\r\n                // bubble up any reason for revert\r\n                revert(string(_result));\r\n            } else {\r\n                revert(\"LibERC20: contract call reverted\");\r\n            }\r\n        }\r\n    }\r\n}\r\npragma solidity =0.7.0;\r\n\r\ninterface IBiswapPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function swapFee() external view returns (uint32);\r\n    function devFee() external view returns (uint32);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n    function setSwapFee(uint32) external;\r\n    function setDevFee(uint32) external;\r\n}\r\npragma solidity 0.7.0;\r\n\r\nlibrary LibBiswapPair {\r\n\r\n   function approveQuery(address _token,address _spender) internal view returns(uint256 _amount){\r\n       _amount=IBiswapPair(_token).allowance(msg.sender,_spender);\r\n   }\r\n\r\n   function queryDecimals(address _token) internal pure returns(uint256 decimals){\r\n       decimals=IBiswapPair(_token).decimals();\r\n   }\r\n\r\n    function transferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_token)\r\n        }\r\n        require(size > 0, \"LibERC20: Address has no code\");\r\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IBiswapPair.transferFrom.selector, _from, _to, _value));\r\n        handleReturn(success, result);\r\n    }\r\n\r\n    function transfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_token)\r\n        }\r\n        require(size > 0, \"LibERC20: Address has no code\");\r\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IBiswapPair.transfer.selector, _to, _value));\r\n        handleReturn(success, result);\r\n    }\r\n\r\n    function handleReturn(bool _success, bytes memory _result) internal pure {\r\n        if (_success) {\r\n            if (_result.length > 0) {\r\n                require(abi.decode(_result, (bool)), \"LibERC20: contract call returned false\");\r\n            }\r\n        } else {\r\n            if (_result.length > 0) {\r\n                // bubble up any reason for revert\r\n                revert(string(_result));\r\n            } else {\r\n                revert(\"LibERC20: contract call reverted\");\r\n            }\r\n        }\r\n    }\r\n    //\u8fd4\u56de\u6c60\u5b50\u5e01\u6570\u91cf\r\n    function getReserves(address _token) internal view returns(uint112 reserve0, uint112 reserve1){\r\n        (reserve0, reserve1,) = IBiswapPair(_token).getReserves();\r\n    }\r\n    //\u603b\u6d41\u901a\u91cf\r\n     function getTotalSupply(address _token) internal view returns(uint balance){\r\n       balance = IBiswapPair(_token).totalSupply();\r\n    }\r\n}\r\npragma solidity >=0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        require(y>0,'ds-math-div-overflow');\r\n        z = x / y;\r\n        //require((z = x / y) * y == x, 'ds-math-div-overflow');\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity 0.7.0;\r\n\r\nstruct BalanceMap{\r\n    mapping(address => mapping(address => BalanceInfo)) userBalanceMap;\r\n}\r\nstruct BalanceInfo{\r\n    uint balance;\r\n}\r\nstruct Transferin{\r\n    uint amount; //\u4f59\u989d\r\n    uint timein; //\u8f6c\u5165\u65f6\u95f4\r\n}\r\n\r\nstruct TransferOut{\r\n    uint amount; //\u4f59\u989d\r\n    uint timeout; //\u8f6c\u51fa\u65f6\u95f4\r\n}\r\nstruct IncomeInfo{\r\n    uint amount; //\u6536\u76ca\r\n    uint timecome; //\u5206\u914d\u65f6\u95f4\r\n}\r\nstruct IncomeAllInfo{\r\n    address addr;\r\n    uint amount; //\u6536\u76ca\r\n    uint timecome; //\u5206\u914d\u65f6\u95f4\r\n}\r\ncontract kugoushibbdefi{\r\n    using SafeMath for uint; \r\n    address owner;\r\n    uint addressNum = 0;//\u5730\u5740\u8ba1\u6570\u5668\uff08\u53ea\u8bb0\u5f55\u8d28\u62bc\u7c7b\u578b\u5730\u5740\uff09\r\n    mapping(uint => address) addressMap;//\u5730\u5740\u8ba1\u6570\u5668\uff08\u53ea\u8bb0\u5f55\u8d28\u62bc\u7c7b\u578b\u5730\u5740\uff09\r\n    mapping(address => uint) addressNumMap;//\u8f6c\u5e01\u6b21\u6570\r\n    mapping(address=>mapping(address=>BalanceInfo)) userBalanceMap;\r\n    event _transferIn(address userAddr,address token,uint amount); \r\n    event _transferOut(address userAddr,address token,uint amount);\r\n    event _transferInkgt(address userAddr,uint amount);\r\n    event _transferOutkgt(address userAddr,uint amount);\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    //kgt\u5408\u7ea6\u5730\u5740\r\n    address kgttokenaddress = 0xB858EC225986122eBd1AC6a1A3b9C27008f42801;\r\n    //shibb\u5408\u7ea6\u5730\u5740\r\n    address shibbtokenaddress = 0x0E0d97DdD63eb75fBACE026B8A3E56cBE225c298;\r\n    //lp-shibb-kgt\u5408\u7ea6\u5730\u5740\r\n    address shibbKgtAddress = 0x762F95280a168fcdcCefEb9E0B837158C41A4AE0;\r\n    //\u8bbe\u7f6e\u603b\u6c60\u5b50\r\n    uint allKgtBalance = 0;\r\n    //\u5df2\u5206\u7ea2\u603b\u6570\u91cf\r\n    uint aleryKgtBalance = 0;\r\n    //\u603b\u8f6c\u5165lp\u6570\u91cf\r\n    uint allShibbLpNum = 0;\r\n    constructor(address tokenOwnerAddress){\r\n      owner = tokenOwnerAddress;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0),\"newOwner is null.\");\r\n        owner = newOwner;\r\n        emit OwnerSet(owner, newOwner);\r\n    }\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n    //\u662f\u5426\u662f\u5408\u7ea6\u5730\u5740\r\n     function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n    function transferInkgt(uint _amount) external payable onlyOwner returns(bool){\r\n        address _token = kgttokenaddress;\r\n        require(isContract(msg.sender) == false,'address cannot be the contract address');\r\n        require(_token!=address(0),'token invalid');\r\n        require(_amount>0,'amount must be greater than 0');\r\n        require(LibERC20.approveQuery(_token,address(this)) >= _amount, \"Insufficient authorization limit remaining\");\r\n        //\u5f00\u59cb\u8f6c\u8d26\r\n        LibERC20.transferFrom(_token, msg.sender, address(this), _amount);\r\n        allKgtBalance = allKgtBalance.add(_amount);\r\n        emit _transferInkgt(msg.sender,_amount);\r\n        return true;\r\n    }\r\n    function transferOutkgt(uint _amount) external payable onlyOwner returns(bool){\r\n        address _token = kgttokenaddress;\r\n        require(isContract(msg.sender) == false,'address cannot be the contract address');\r\n        require(_token!=address(0),'token invalid');\r\n        require(_amount>0,'amount must be greater than 0');\r\n        require(allKgtBalance>=_amount,'The total pool balance of kgt is insufficient');\r\n        //\u5f00\u59cb\u8f6c\u8d26\r\n        LibERC20.transfer(_token, msg.sender, _amount);\r\n        allKgtBalance = allKgtBalance.sub(_amount);\r\n        emit _transferOutkgt(msg.sender,_amount);\r\n        return true;\r\n    }\r\n    function transferIn(address _token,uint _amount) external payable returns(bool){\r\n        require(isContract(msg.sender) == false,'address cannot be the contract address');\r\n        require(_token!=address(0),'token invalid');\r\n        require(_amount>0,'amount must be greater than 0');\r\n        require(LibERC20.approveQuery(_token,address(this)) >= _amount, \"Insufficient authorization limit remaining\");\r\n        //\u5f00\u59cb\u8f6c\u8d26\r\n        LibERC20.transferFrom(_token, msg.sender, address(this), _amount);\r\n        BalanceInfo storage _balanceInfo = userBalanceMap[msg.sender][_token];\r\n        _balanceInfo.balance = _balanceInfo.balance.add(_amount);\r\n        if(_token == shibbKgtAddress){\r\n            allShibbLpNum = allShibbLpNum.add(_amount);\r\n            if(addressNumMap[msg.sender] <= 0){\r\n                addressMap[addressNum] = msg.sender;\r\n                addressNum = addressNum.add(1);\r\n            } \r\n           addressNumMap[msg.sender] = addressNumMap[msg.sender]+1;\r\n        }\r\n        emit _transferIn (msg.sender,_token,_amount);\r\n        return true;\r\n    }\r\n    function transferOut(address _token,uint _amount) external payable returns(bool){\r\n        require(isContract(msg.sender) == false,'address cannot be the contract address');\r\n        require(_token!=address(0),'token invalid');\r\n        require(_amount>0,'amount must be greater than 0');\r\n        BalanceInfo storage _balanceInfo = userBalanceMap[msg.sender][_token];\r\n        require(_balanceInfo.balance >=_amount,'Insufficient recoverable assets');\r\n        //\u5f00\u59cb\u8f6c\u8d26\r\n       LibERC20.transfer(_token, msg.sender, _amount);\r\n        _balanceInfo.balance = _balanceInfo.balance.sub(_amount);\r\n        if(_token == shibbKgtAddress){\r\n            allShibbLpNum = allShibbLpNum.sub(_amount);\r\n        }\r\n        emit _transferOut(msg.sender,_token,_amount);\r\n        return true;\r\n    }\r\n    function queryBalance(address _token) public view returns(uint){\r\n        BalanceInfo storage _balanceInfo = userBalanceMap[msg.sender][_token];\r\n        return (_balanceInfo.balance);\r\n    }\r\n    function approveQuery(address _token,address _sender) public view returns(uint256 balance){\r\n        balance = LibERC20.approveQuery(_token,_sender);\r\n    }\r\n    function queryDecimals(address _token) internal view returns(uint256 decimals){\r\n       decimals=LibERC20.queryDecimals(_token);\r\n   }\r\n   function querykgtBalance() public view returns(uint balance){\r\n      return allKgtBalance;\r\n   }\r\n   function queryallLpNum() public view returns(uint balance){\r\n      return allShibbLpNum;\r\n   }\r\n   function distributionIncome() public onlyOwner returns(bool){\r\n       require(addressNum>0,'The number of addresses must be greater than 0');\r\n       require(allKgtBalance>0,'The balance of the kgt income pool is insufficient!');\r\n        uint alllpBalance = LibBiswapPair.getTotalSupply(shibbKgtAddress);\r\n         (,uint reserve1) = LibBiswapPair.getReserves(shibbKgtAddress);\r\n       for(uint i=0;i<addressNum;i++){\r\n            uint lpbalance  = userBalanceMap[addressMap[i]][shibbKgtAddress].balance;\r\n            if(lpbalance > 0){\r\n                uint kgtBalance =   lpbalance.mul(reserve1).mul(2).div(alllpBalance);\r\n                kgtBalance = kgtBalance.div(5).div(365);\r\n                if(kgtBalance >0 && allKgtBalance>=kgtBalance){\r\n                     BalanceInfo storage _balanceInfo = userBalanceMap[addressMap[i]][kgttokenaddress];\r\n                     _balanceInfo.balance = _balanceInfo.balance.add(kgtBalance);\r\n                     allKgtBalance = allKgtBalance.sub(kgtBalance);\r\n                     aleryKgtBalance = aleryKgtBalance.add(kgtBalance);\r\n                }\r\n            }\r\n       }\r\n       return true;\r\n   }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwnerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferInkgt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferOutkgt\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"approveQuery\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionIncome\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"queryBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryallLpNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"querykgtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferIn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferInkgt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferOutkgt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "kugoushibbdefi", "CompilerVersion": "v0.7.0+commit.9e61f92b", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000efb8fead359ed21b001f45c6eac79c3ecf88188b", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fcc0b3659d6c9daf9b766957cca639ffa62fba2065e52ac2c6f802c35b909b42"}