{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n\r\n    \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\r\n    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\r\n    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557   \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\r\n    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u255d    \u255a\u2588\u2588\u2554\u255d      \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\r\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551        \u2588\u2588\u2551       \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\r\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d        \u255a\u2550\u255d        \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\r\n                                                                   \r\n\r\n    WELCOME TO LUFFY G5 Inu COMMUNITY! Now you are a member of the next x500 gem!\r\n\r\n    The gaming landscape is evolving rapidly, and LUFFY G5 \r\n    is poised to lead the charge. It marries the thrilling dynamics \r\n    of a combat-oriented PvP and PvE system with the decentralized\r\n    nature of blockchain technology. This whitepaper outlines the \r\n    core features, mechanics, and vision behind LUFFY G5, poised \r\n    to redefine how players interact with blockchain gaming\r\n\r\n    \ud83d\udca5 Get ready for our EXPLOSIVE LAUNCH on PancakeSwap - October 2th at 13:00 UTC!\r\n\r\n    | \ud83d\udfe1 All BSC Trending confirmed \r\n    | \ud83d\udd35 CMC&CG Fast-Track confirmed\r\n\r\n    \ud83e\udd1d Recommend by the BIGGEST CALLERS!\r\n    \ud83e\udd1d Tier 1 Partnerships incoming\r\n    \ud83c\udf89 Dev BASED\r\n    \ud83d\udc8e Experienced Team\r\n    \ud83d\udc8e 140x and 300x Previous\r\n    \ud83d\udc8e Contest and Competitions incoming\r\n\r\n\r\n    @devBlockchain https://bullsprotocol.com/en\r\n    @devBlockchain https://t.me/italo_blockchain\r\n\r\n    ______       _ _             ______          _                  _ \r\n    | ___ \\     | | |            | ___ \\        | |                | |\r\n    | |_/ /_   _| | |___         | |_/ / __ ___ | |_ ___   ___ ___ | |\r\n    | ___ \\ | | | | / __|        |  __/ '__/ _ \\| __/ _ \\ / __/ _ \\| |\r\n    | |_/ / |_| | | \\__ \\        | |  | | | (_) | || (_) | (_| (_) | |\r\n    \\____/ \\__,_|_|_|___/        \\_|  |_|  \\___/ \\__\\___/ \\___\\___/|_|\r\n\r\n    \r\n */\r\n\r\npragma solidity 0.8.18;\r\n\r\n\r\n//Declaration of experimental ABIEncoderV2 encoder to return dynamic types\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n*/\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0) && newOwner != address(0xdead\r\n            ), \"Is impossible to renounce the ownership of the contract\");\r\n\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\nabstract contract Pausable is Context {\r\n\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (uint256);    \r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\ncontract ERC20 is Context {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    uint256 internal _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function _create(address account, uint256 amount) internal virtual {\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Router {\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut, \r\n        address[] calldata path) \r\n    external view returns (uint[] memory amounts);\r\n        \r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return recover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return recover(hash, r, vs);\r\n        } else {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n            v := add(shr(255, vs), 27)\r\n        }\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(\r\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n            \"ECDSA: invalid signature 's' value\"\r\n        );\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n    }\r\n}\r\n\r\n\r\ncontract LyffyG5 is ERC20, Pausable, Ownable, ReentrancyGuard {\r\n\r\n    string public webSite;\r\n    string public telegram;\r\n    string public twitter;\r\n\r\n    uint256 public timeDeployContract;\r\n    uint256 public timeOpenNFTcontract;\r\n\r\n    uint256 public fees = 1000000000000000;\r\n\r\n    uint256 public totalSoldInBUSD;\r\n    uint256 public totalSoldInUSDT;\r\n    uint256 public totalSoldInUSDC;\r\n    uint256 public totalSoldInBNB;\r\n    uint256 public totalSoldInLFG;\r\n    uint256 public totalSoldUSD;\r\n    \r\n    uint256 public amountLFGclaimed;\r\n    uint256 public amountUSDclaimed;\r\n    \r\n    address public addressLFG     = 0x84958F423651205207E8Ce01EDb6fA863Dfc604C;\r\n    address public addressBUSD    = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address public addressPCVS2   = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address public addressWBNB    = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public addressUSDT    = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public addressUSDC    = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\r\n    address public addressUSD;\r\n\r\n    address public fundNFTs;\r\n    address public projectWallet;\r\n\r\n    address public authAddress = address(0xEf83Fc0C22B0df25f946802D8150D3a458589068);\r\n\r\n    mapping(address => bool) private mappingAuth;\r\n\r\n    mapping(address => uint256) public nonces;\r\n    mapping(bytes => bool) private signatureUsed;\r\n    mapping(bytes => infosBuy) private getInfosBySignatureMapping;\r\n\r\n    struct infosBuy {\r\n        address buyer;\r\n        uint256 amount;\r\n        uint256 wichToken;\r\n        address smartContract;\r\n        uint256 nonce;\r\n        bytes signature;\r\n        bytes32 hash;\r\n    }\r\n\r\n    receive(\r\n\r\n    ) external payable {\r\n\r\n    }\r\n\r\n    constructor() ERC20(\"Luffy NFT Game\", \"LUFFY NFTs\") {\r\n        timeDeployContract = block.timestamp;\r\n\r\n        if (authAddress != address(0)) {\r\n            mappingAuth[authAddress] = true;\r\n        }\r\n        \r\n        addressUSD = addressUSDT;\r\n        fundNFTs = address(this);\r\n\r\n        webSite     = \"https://luffyg5.com\";\r\n        telegram    = \"https://t.me/+MeiEr1Ps9tcyN2Ux\";\r\n        twitter     = \"https://x.com/LuffyG5Token\";\r\n\r\n        _create(address(0), 1 * (10 ** decimals()));\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(_msgSender() == owner() || mappingAuth[_msgSender()] == true, \"No hack here!\");\r\n        _;\r\n    }\r\n\r\n    function getDaysPassed() public view returns (uint256){\r\n        return (block.timestamp - timeDeployContract) / (1 days); \r\n    }\r\n\r\n    function getInfosBySignature(bytes memory signature) external view returns (infosBuy memory){\r\n        require(_msgSender() == owner() || mappingAuth[_msgSender()], \"No consultation allowed\");\r\n        return getInfosBySignatureMapping[signature]; \r\n    }\r\n\r\n    //Retorna quantos tokens de entrada que equivalem o valor em BNB de amount de sa\u00edda\r\n    //Entra tokens, sai o valor de amount em BNB\r\n    function getAmountsLFGinput(uint256 amount) public view returns (uint256) {\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = addressLFG;\r\n        path[1] = addressWBNB;\r\n\r\n        uint256[] memory amountInMins = \r\n        IUniswapV2Router(addressPCVS2).getAmountsIn(amount, path);\r\n\r\n        return amountInMins[0];\r\n    }\r\n\r\n    //Retorna quantos tokens de entrada que equivalem o valor em BNB de amount de sa\u00edda\r\n    function getAmountsBUSDinput(uint256 amount) public view returns (uint256) {\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = addressBUSD;\r\n        path[1] = addressWBNB;\r\n\r\n        uint256[] memory amountInMins = \r\n        IUniswapV2Router(addressPCVS2).getAmountsIn(amount, path);\r\n\r\n        return amountInMins[0];\r\n    }\r\n\r\n    //Retorna quantos tokens de entrada que equivalem o valor em BNB de amount de sa\u00edda\r\n    function getAmountsUSDTinput(uint256 amount) public view returns (uint256) {\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = addressUSDT;\r\n        path[1] = addressWBNB;\r\n\r\n        uint256[] memory amountInMins = \r\n        IUniswapV2Router(addressPCVS2).getAmountsIn(amount, path);\r\n\r\n        return amountInMins[0];\r\n        \r\n    }\r\n\r\n    //Used to update the price of NFTs in BUSD\r\n    //returns the conversion to BUSD of the LFG tokens\r\n    function getConvertLFGtoUSD(uint256 amount) public view returns (uint256) {\r\n        uint256 getReturn;\r\n        if (amount != 0) {\r\n\r\n            address[] memory path = new address[](3);\r\n            path[0] = addressLFG;\r\n            path[1] = addressWBNB;\r\n            path[2] = addressBUSD;\r\n\r\n            uint256[] memory amountOutMins = IUniswapV2Router(addressPCVS2)\r\n            .getAmountsOut(amount, path);\r\n            getReturn = amountOutMins[path.length - 1];\r\n        }\r\n        return getReturn;\r\n    } \r\n\r\n    function getConvertBNBtoUSD(uint256 amount) public view returns (uint256) {\r\n        uint256 getReturn;\r\n        if (amount != 0) {\r\n\r\n            address[] memory path = new address[](2);\r\n            path[0] = addressWBNB;\r\n            path[1] = addressBUSD;\r\n\r\n            uint256[] memory amountOutMins = IUniswapV2Router(addressPCVS2)\r\n            .getAmountsOut(amount, path);\r\n            getReturn = amountOutMins[path.length - 1];\r\n            \r\n        }\r\n        return getReturn;\r\n    }\r\n\r\n    function bytesLength(bytes memory signature) public pure returns (uint256) {\r\n        return signature.length;\r\n    }\r\n\r\n    function hashReturn(bytes memory hash) public pure returns (bytes32,bytes32) {\r\n        return (keccak256(abi.encodePacked(hash)),keccak256(hash));\r\n    }\r\n\r\n    function ckeckSignatureCrypto(\r\n        address buyer,\r\n        uint256 amount,\r\n        address smartContract,\r\n        uint256 nonce, \r\n        bytes memory signature) private {\r\n        require(getInfosBySignatureMapping[signature].buyer == address(0x0), \"Signature has already been used\");\r\n\r\n        require(address(this) == smartContract, \"Invalid contract\");\r\n        require(signature.length == 65, \"Signature length not approved\");\r\n        require(keccak256(abi.encodePacked(signature)) != \r\n                keccak256(abi.encodePacked(\"0x19457468657265756d205369676e6564204d6573736167653a0a3332\")), \r\n                \"Exploit attempt\");\r\n\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(prefix, \r\n                keccak256(abi.encodePacked(smartContract,buyer,nonce,amount)))\r\n                );\r\n\r\n        address recoveredAddress = ECDSA.recover(hash, signature);\r\n        \r\n        require(_msgSender() == buyer, \"No hacking here, no mempool bot here, motherfuck!\");\r\n        require(\r\n            recoveredAddress == authAddress && recoveredAddress != address(0), \r\n            \"Signature was not authorized\"\r\n            );\r\n        require(nonces[recoveredAddress]++ == nonce, \"Nonce already used\");\r\n    }\r\n\r\n    function decodeSignature(\r\n        address buyer,\r\n        uint256 amount,\r\n        address smartContract,\r\n        uint256 nonce, \r\n        bytes memory signature) public pure returns \r\n        (address,uint256,uint256,bytes memory,bytes32,address) {\r\n\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(abi.encodePacked(prefix, keccak256(abi.encodePacked(smartContract,buyer,nonce,amount))));\r\n        address recoveredAddress = ECDSA.recover(hash, signature);\r\n\r\n        return (buyer,amount,nonce,signature,hash,recoveredAddress);\r\n    }\r\n\r\n    function buyNFT(\r\n        address buyer,\r\n        uint256 amount, \r\n        uint256 numbersNFTs, \r\n        uint256 wichToken,\r\n        address smartContract, \r\n        uint256 nonce, \r\n        bytes memory signature) \r\n        external payable\r\n        nonReentrant() whenNotPaused() {\r\n\r\n        //Redundant declaration to avoid warning message in solidity compiler\r\n        numbersNFTs = numbersNFTs;\r\n\r\n        ckeckSignatureCrypto(\r\n            buyer,\r\n            amount,\r\n            smartContract, \r\n            nonce, \r\n            signature);\r\n\r\n        getInfosBySignatureMapping[signature].buyer = msg.sender; \r\n        getInfosBySignatureMapping[signature].amount = amount; \r\n        getInfosBySignatureMapping[signature].wichToken = wichToken; \r\n        getInfosBySignatureMapping[signature].smartContract = smartContract; \r\n        getInfosBySignatureMapping[signature].nonce = nonce; \r\n        getInfosBySignatureMapping[signature].signature = signature; \r\n\r\n        //BUSD\r\n        if (wichToken == 1) {\r\n            IERC20(addressBUSD).transferFrom(msg.sender, fundNFTs, amount);\r\n\r\n            totalSoldInBUSD += amount;\r\n            totalSoldUSD += amount;\r\n\r\n        //USDT\r\n        } else if (wichToken == 2) {\r\n            IERC20(addressUSDT).transferFrom(msg.sender, fundNFTs, amount);\r\n\r\n            totalSoldInUSDT += amount;\r\n            totalSoldUSD += amount;\r\n\r\n        //USDC\r\n        } else if (wichToken == 3) {\r\n            IERC20(addressUSDC).transferFrom(msg.sender, fundNFTs, amount);\r\n\r\n            totalSoldInUSDC += amount;\r\n            totalSoldUSD += amount;\r\n\r\n        //BNB\r\n        } else if (wichToken == 4) {\r\n            payable(fundNFTs).transfer(amount);\r\n\r\n            totalSoldInBNB += amount;\r\n            totalSoldUSD += getConvertBNBtoUSD(amount);\r\n\r\n        //LFG\r\n        } else if (wichToken == 5) {\r\n            IERC20(addressLFG).transferFrom(msg.sender, fundNFTs, amount);\r\n\r\n            totalSoldInLFG += amount;\r\n            totalSoldUSD += getConvertLFGtoUSD(amount);\r\n        }\r\n\r\n    }\r\n\r\n    //Only the claim account authorized in the backend that can call this function\r\n    //here is the claim of rewards for investment quotas\r\n    function claimRewardsLFG(\r\n        address buyer,\r\n        uint256 amount) external onlyAuthorized() nonReentrant() whenNotPaused() {\r\n\r\n        if (amount > 0) IERC20(addressLFG).transfer(buyer, amount);\r\n\r\n        unchecked {\r\n            amountLFGclaimed += amount;\r\n        }\r\n\r\n    }\r\n\r\n    function claimRewardsUSDT(\r\n        address buyer,\r\n        uint256 amountUSD) external onlyAuthorized() nonReentrant() whenNotPaused() {\r\n\r\n        if (amountUSD > 0) IERC20(addressUSD).transfer(buyer, amountUSD);\r\n\r\n        unchecked {\r\n            amountUSDclaimed += amountUSD;\r\n        }\r\n\r\n    }\r\n\r\n    function claimRewards(\r\n        address buyer,\r\n        uint256 amountUSD,\r\n        uint256 amountLFG) external onlyAuthorized() nonReentrant() whenNotPaused() {\r\n\r\n        if (amountUSD > 0) IERC20(addressUSD).transfer(buyer, amountUSD);\r\n        if (amountLFG > 0) IERC20(addressLFG).transfer(buyer, amountLFG);\r\n\r\n        unchecked {\r\n            amountUSDclaimed += amountUSD;\r\n            amountLFGclaimed += amountLFG;\r\n        }\r\n    }\r\n\r\n    //claimer requests the claim, which will be processed later\r\n    function requestClaim(\r\n        address buyer) external payable nonReentrant() whenNotPaused() {\r\n\r\n        buyer = buyer;\r\n\r\n        require(msg.value == fees, \"Invalid amount transferred\");\r\n        (bool success,) = authAddress.call{value: fees}(\"\");\r\n        require(success, \"Failed to send BNB\");\r\n    }\r\n\r\n    function uncheckedI (uint256 i) public pure returns (uint256) {\r\n        unchecked { return i + 1; }\r\n    }\r\n\r\n    function claimManyRewards (\r\n        address[] memory buyer, \r\n        uint256[] memory amountLFG, \r\n        uint256[] memory amoutUSD\r\n        ) \r\n        external \r\n        onlyAuthorized() nonReentrant() whenNotPaused() {\r\n\r\n        uint256 buyerLength = buyer.length;\r\n        for (uint256 i = 0; i < buyerLength; i = uncheckedI(i)) {  \r\n\r\n            if (amountLFG[i] != 0) {\r\n                IERC20(addressLFG).transfer(buyer[i], amountLFG[i]);\r\n            }\r\n            if (amoutUSD[i] != 0) {\r\n                IERC20(addressUSD).transfer(buyer[i], amoutUSD[i]);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function withdraw(address account, uint256 amount) public onlyOwner() {\r\n        IERC20(addressLFG).transfer(account, amount);\r\n    }\r\n\r\n    function balanceBNB () external onlyOwner() {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function balanceERC20 (address token) external onlyOwner() {\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function setStrings(\r\n        string memory _webSite,\r\n        string memory _telegram,\r\n        string memory _twitter\r\n    ) public onlyOwner() {\r\n\r\n        webSite = _webSite;\r\n        telegram = _telegram;\r\n        twitter = _twitter;\r\n    }\r\n\r\n    function setFees (uint256 _fees) external onlyOwner() {\r\n        fees = _fees;\r\n    }\r\n\r\n    function setLFGaddressContract (address _addressLFG) external onlyOwner() {\r\n        addressLFG = _addressLFG;\r\n    }\r\n\r\n    function setAddressUSD (address _addressUSD) external onlyOwner() {\r\n        addressUSD = _addressUSD;\r\n    }\r\n\r\n    //set the authorized project wallet\r\n    function setMappingAuth(address account, bool boolean) external onlyOwner() {\r\n        mappingAuth[account] = boolean;\r\n        authAddress = payable(account);\r\n    }\r\n\r\n    function setFundNFTs(address _fundNFTs) external onlyOwner() {\r\n        fundNFTs = _fundNFTs;\r\n    }\r\n\r\n    function setProjectWallet (address _projectWallet) external onlyOwner() {\r\n        projectWallet = _projectWallet;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressBUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressLFG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressPCVS2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressUSDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressUSDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressWBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountLFGclaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountUSDclaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balanceERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numbersNFTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wichToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"smartContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"buyNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"bytesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"buyer\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountLFG\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amoutUSD\",\"type\":\"uint256[]\"}],\"name\":\"claimManyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLFG\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimRewardsLFG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountUSD\",\"type\":\"uint256\"}],\"name\":\"claimRewardsUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"smartContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"decodeSignature\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundNFTs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAmountsBUSDinput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAmountsLFGinput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAmountsUSDTinput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getConvertBNBtoUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getConvertLFGtoUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDaysPassed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getInfosBySignature\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wichToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"smartContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct LyffyG5.infosBuy\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"hashReturn\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"requestClaim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressUSD\",\"type\":\"address\"}],\"name\":\"setAddressUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fees\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundNFTs\",\"type\":\"address\"}],\"name\":\"setFundNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressLFG\",\"type\":\"address\"}],\"name\":\"setLFGaddressContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"boolean\",\"type\":\"bool\"}],\"name\":\"setMappingAuth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_projectWallet\",\"type\":\"address\"}],\"name\":\"setProjectWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_webSite\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_telegram\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_twitter\",\"type\":\"string\"}],\"name\":\"setStrings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"telegram\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeDeployContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeOpenNFTcontract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSoldInBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSoldInBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSoldInLFG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSoldInUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSoldInUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSoldUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twitter\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"uncheckedI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"webSite\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LyffyG5", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca0bec4999aca710840511c9349bf14cbe7db490419831ddd261e10e39dfdb8c"}