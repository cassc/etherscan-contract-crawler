{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"XChance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\ncontract XChance {\\n    struct GameCollection {\\n        uint256[] divisions;\\n        mapping(uint256 =\\u003e GameDivision) map;\\n    }\\n\\n    struct GameDivision {\\n        address[] tokens;\\n        mapping(address =\\u003e GameChain) map;\\n    }\\n\\n    struct GameChain {\\n        uint256[] ids;\\n        mapping(uint256 =\\u003e Game) map;\\n    }\\n\\n    struct Game {\\n        uint256 potSeed;\\n        Pot[] pots;\\n        mapping(address =\\u003e uint256) claims;\\n    }\\n\\n    struct Pot {\\n        uint256 totalFund;\\n        mapping(address =\\u003e uint256) funds;\\n    }\\n\\n    string public constant VERSION = \\\"1.0\\\";\\n    uint256 public constant FEE_DENO = 1000;\\n    address public owner;\\n    address public manager;\\n    uint256 public blocksPerGame;\\n    uint256 public feeRatio;\\n    uint256 public endgameID;\\n    uint256 public seedReleasedBlock;\\n    GameCollection collection;\\n    mapping(address =\\u003e uint256) public seedThresholds;\\n\\n    constructor(uint256 _blocksPerGame, uint256 _feeRatio) {\\n        owner = msg.sender;\\n        blocksPerGame = _blocksPerGame;\\n        feeRatio = _feeRatio;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(msg.sender == manager || msg.sender == owner);\\n        _;\\n    }\\n\\n    function updateManager(address _manager) public onlyOwner {\\n        manager = _manager;\\n    }\\n\\n    function endgame(uint256 _id) public onlyOwner {\\n        require(seedReleasedBlock == 0, \\\"No seed after endgame\\\");\\n        require(_id \\u003e= getGameID() || _id == 0, \\\"Invalid endgame\\\");\\n        endgameID = _id;\\n    }\\n\\n    function getGameID() internal view returns (uint256) {\\n        return block.number / blocksPerGame;\\n    }\\n\\n    function updateFeeRatio(uint256 _feeRatio) public onlyManager {\\n        require(_feeRatio \\u003c FEE_DENO, \\\"Ratio is too big\\\");\\n        feeRatio = _feeRatio;\\n    }\\n\\n    function updateSeedThreshold(uint256 _seedThreshold) public onlyManager {\\n        updateTokenSeedThreshold(address(0), _seedThreshold);\\n    }\\n\\n    function updateTokenSeedThreshold(address _token, uint256 _seedThreshold)\\n        public\\n        onlyManager\\n    {\\n        require(_seedThreshold \\u003e 0, \\\"Threshold is too small\\\");\\n        seedThresholds[_token] = _seedThreshold;\\n    }\\n\\n    function registerGame(uint256 _division) public payable onlyManager {\\n        registerGameInternal(_division, address(0), msg.value);\\n    }\\n\\n    function registerTokenGame(\\n        uint256 _division,\\n        address _token,\\n        uint256 _seed\\n    ) public onlyManager {\\n        IERC20(_token).transferFrom(msg.sender, address(this), _seed);\\n        registerGameInternal(_division, _token, _seed);\\n    }\\n\\n    function registerGameInternal(\\n        uint256 _division,\\n        address _token,\\n        uint256 _seed\\n    ) internal {\\n        require(\\n            _division \\u003e 1 \\u0026\\u0026\\n                collection.map[_division].map[_token].ids.length == 0,\\n            \\\"Game was already registered\\\"\\n        );\\n        require(_seed \\u003e 0, \\\"Seed is required\\\");\\n        GameDivision storage division = collection.map[_division];\\n        if (division.tokens.length == 0) {\\n            collection.divisions.push(_division);\\n        }\\n        division.tokens.push(_token);\\n        GameChain storage chain = division.map[_token];\\n        createNewGame(chain, _division, _seed);\\n    }\\n\\n    function releaseSeed() public onlyOwner {\\n        require(\\n            endgameID \\u003e 0 \\u0026\\u0026 endgameID \\u003c getGameID(),\\n            \\\"Available after endgame only\\\"\\n        );\\n        seedReleasedBlock = block.number;\\n        for (uint256 i = 0; i \\u003c collection.divisions.length; i++) {\\n            GameDivision storage division = collection.map[\\n                collection.divisions[i]\\n            ];\\n            for (uint256 j = 0; j \\u003c division.tokens.length; j++) {\\n                address tokenAddress = division.tokens[j];\\n                GameChain storage chain = division.map[tokenAddress];\\n                Game storage lastGame = chain.map[\\n                    chain.ids[chain.ids.length - 1]\\n                ];\\n                (uint256 totalFund, uint256 winnerFund, ) = findGameStats(\\n                    lastGame.pots\\n                );\\n                uint256 seed = (totalFund * lastGame.potSeed) / winnerFund;\\n                if (tokenAddress == address(0)) {\\n                    payable(owner).transfer(seed);\\n                } else {\\n                    IERC20(tokenAddress).transfer(address(owner), seed);\\n                }\\n            }\\n        }\\n    }\\n\\n    function createNewGame(\\n        GameChain storage chain,\\n        uint256 _division,\\n        uint256 _seed\\n    ) internal {\\n        uint256 id = getGameID();\\n        require(endgameID == 0 || id \\u003c= endgameID, \\\"This is already endgame\\\");\\n        Game storage game = chain.map[id];\\n        game.potSeed = _seed / _division;\\n        for (uint256 i = 0; i \\u003c _division; i++) {\\n            Pot storage pot = game.pots.push();\\n            pot.totalFund = game.potSeed;\\n        }\\n        chain.ids.push(id);\\n    }\\n\\n    function getBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function getDivisions() public view returns (uint256[] memory) {\\n        return collection.divisions;\\n    }\\n\\n    function getTokens(uint256 _division)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return collection.map[_division].tokens;\\n    }\\n\\n    function fund(uint256 _division, uint256 _potID) public payable {\\n        uint256 fee = fundInternal(_division, address(0), _potID, msg.value);\\n        if (fee \\u003e 0) {\\n            payable(owner).transfer(fee);\\n        }\\n    }\\n\\n    function fundToken(\\n        uint256 _division,\\n        address _token,\\n        uint256 _potID,\\n        uint256 _value\\n    ) public {\\n        IERC20 tokenContract = IERC20(_token);\\n        tokenContract.transferFrom(msg.sender, address(this), _value);\\n        uint256 fee = fundInternal(_division, _token, _potID, _value);\\n        if (fee \\u003e 0) {\\n            tokenContract.transfer(address(owner), fee);\\n        }\\n    }\\n\\n    function fundInternal(\\n        uint256 _division,\\n        address _token,\\n        uint256 _potID,\\n        uint256 _value\\n    ) internal returns (uint256) {\\n        GameChain storage chain = collection.map[_division].map[_token];\\n        require(chain.ids.length \\u003e 0, \\\"No game to fund\\\");\\n        require(_potID \\u003c _division, \\\"No pot to fund\\\");\\n        require(_value \\u003e 0, \\\"No value to fund\\\");\\n        uint256 gameID = getGameID();\\n        if (chain.map[gameID].pots.length == 0) {\\n            finalizeLastGame(chain, _token);\\n        }\\n        Pot storage pot = chain.map[gameID].pots[_potID];\\n        uint256 fee = (_value * feeRatio) / FEE_DENO;\\n        uint256 fundValue = _value - fee;\\n        pot.totalFund += fundValue;\\n        pot.funds[msg.sender] += fundValue;\\n        return fee;\\n    }\\n\\n    function finalizeLastGame(GameChain storage _chain, address _token)\\n        internal\\n    {\\n        uint256 lastGameID = _chain.ids[_chain.ids.length - 1];\\n        Game storage lastGame = _chain.map[lastGameID];\\n        (uint256 totalFund, uint256 winnerFund, ) = findGameStats(\\n            lastGame.pots\\n        );\\n        uint256 seed = (totalFund * lastGame.potSeed) / winnerFund;\\n        uint256 seedThreshold = seedThresholds[_token];\\n        if (seedThreshold \\u003e 0 \\u0026\\u0026 seed \\u003e= seedThreshold) {\\n            uint256 cut = seed / 2;\\n            seed = seed - cut;\\n            if (_token == address(0)) {\\n                payable(owner).transfer(cut);\\n            } else {\\n                IERC20(_token).transfer(address(owner), cut);\\n            }\\n        }\\n        createNewGame(_chain, lastGame.pots.length, seed);\\n    }\\n\\n    function findGameStats(Pot[] storage _pots)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 winnerFund = _pots[0].totalFund;\\n        uint256 winnerCount = 1;\\n        uint256 totalFund = winnerFund;\\n        for (uint256 i = 1; i \\u003c _pots.length; i++) {\\n            totalFund += _pots[i].totalFund;\\n            if (_pots[i].totalFund \\u003c winnerFund) {\\n                winnerFund = _pots[i].totalFund;\\n                winnerCount = 1;\\n            } else if (_pots[i].totalFund == winnerFund) {\\n                winnerCount += 1;\\n            }\\n        }\\n        return (totalFund, winnerFund, winnerCount);\\n    }\\n\\n    function getPots(\\n        uint256 _division,\\n        address _token,\\n        uint256 _gameID\\n    ) public view returns (uint256[] memory) {\\n        uint256[] memory pots = new uint256[](_division);\\n        Game storage game = collection.map[_division].map[_token].map[_gameID];\\n        if (game.pots.length == _division) {\\n            for (uint256 i = 0; i \\u003c _division; i++) {\\n                pots[i] = game.pots[i].totalFund;\\n            }\\n        }\\n        return pots;\\n    }\\n\\n    function getFunds(\\n        uint256 _division,\\n        address _token,\\n        uint256 _gameID,\\n        address _address\\n    ) public view returns (uint256[] memory) {\\n        uint256[] memory funds = new uint256[](_division + 1);\\n        Game storage game = collection.map[_division].map[_token].map[_gameID];\\n        if (game.pots.length == _division) {\\n            (\\n                uint256 totalFund,\\n                uint256 winnerFund,\\n                uint256 winnerCount\\n            ) = findGameStats(game.pots);\\n            uint256 totalPrize = 0;\\n            for (uint256 i = 0; i \\u003c _division; i++) {\\n                Pot storage pot = game.pots[i];\\n                funds[i] = pot.funds[_address];\\n                if (pot.totalFund == winnerFund \\u0026\\u0026 funds[i] \\u003e 0) {\\n                    totalPrize +=\\n                        (funds[i] * totalFund) /\\n                        (pot.totalFund * winnerCount);\\n                }\\n            }\\n            funds[_division] = totalPrize;\\n        }\\n        return funds;\\n    }\\n\\n    function claimPrize(uint256 _division, uint256 _gameID) public {\\n        uint256 totalPrize = claimPrizeInternal(_division, address(0), _gameID);\\n        payable(msg.sender).transfer(totalPrize);\\n    }\\n\\n    function claimTokenPrize(\\n        uint256 _division,\\n        address _token,\\n        uint256 _gameID\\n    ) public {\\n        uint256 totalPrize = claimPrizeInternal(_division, _token, _gameID);\\n        IERC20(_token).transfer(msg.sender, totalPrize);\\n    }\\n\\n    function claimPrizeInternal(\\n        uint256 _division,\\n        address _token,\\n        uint256 _gameID\\n    ) internal returns (uint256) {\\n        require(\\n            _gameID \\u003c block.number / blocksPerGame,\\n            \\\"Game is still ongoing\\\"\\n        );\\n        Game storage game = collection.map[_division].map[_token].map[_gameID];\\n        require(game.pots.length \\u003e 0, \\\"No game to claim\\\");\\n        require(game.claims[msg.sender] == 0, \\\"Prize has been claimed\\\");\\n        uint256 totalPrize = getFunds(_division, _token, _gameID, msg.sender)[\\n            _division\\n        ];\\n        require(totalPrize \\u003e 0, \\\"No prize to claim\\\");\\n        game.claims[msg.sender] = block.number;\\n        return totalPrize;\\n    }\\n\\n    function getClaim(\\n        uint256 _division,\\n        address _token,\\n        uint256 _gameID,\\n        address _address\\n    ) public view returns (uint256) {\\n        Game storage game = collection.map[_division].map[_token].map[_gameID];\\n        if (game.pots.length == _division) {\\n            return game.claims[_address];\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocksPerGame\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FEE_DENO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksPerGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"claimPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"claimTokenPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"endgame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endgameID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_potID\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_potID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"fundToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gameID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDivisions\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gameID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getFunds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"getPots\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"}],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"}],\"name\":\"registerGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_division\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"registerTokenGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseSeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedReleasedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"seedThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRatio\",\"type\":\"uint256\"}],\"name\":\"updateFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"updateManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seedThreshold\",\"type\":\"uint256\"}],\"name\":\"updateSeedThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seedThreshold\",\"type\":\"uint256\"}],\"name\":\"updateTokenSeedThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "XChance", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d8a68c67f1b8e1d19d75205c7213d2bd2daf5733e162d6a12a63378d899ff05e"}