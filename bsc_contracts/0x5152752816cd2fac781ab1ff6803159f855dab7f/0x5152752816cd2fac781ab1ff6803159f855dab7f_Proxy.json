{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-12-14\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-06-22\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-06-08\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-04-18\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-04-05\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-03-09\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-03-03\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-02-09\r\n*/\r\n\r\npragma solidity ^0.6.0;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint a, uint m) internal pure returns (uint r) {\r\n    return (a + m - 1) / m * m;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n\r\ninterface IToken {\r\n     function decimals() external view returns (uint256);\r\n    function transfer(address to, uint256 tokens) external returns (bool success);\r\n    function burnTokens(uint256 _amount) external;\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface MetaStake {\r\n    function deposit(uint, uint) external;\r\n    function depositFor(uint,uint,address) external;\r\n    function withdraw(uint, uint) external;\r\n    function userInfo(uint, address) external view returns (uint, uint);\r\n}\r\n\r\ncontract MetaswapLaunchpad is Owned {\r\n    using SafeMath for uint256;\r\n    \r\n    bool public isPresaleOpen;\r\n    \r\n    address public tokenAddress; // buy\r\n    uint256 public tokenDecimals = 5;\r\n    \r\n    address public _crypto = 0x55d398326f99059fF775485246999027B3197955; // USDT // sell\r\n    // address public _crypto = 0x8d9f46183A23d81dcCc172C92bDb4553c1b67FFf; // testnet USDT // sell\r\n   \r\n    \r\n    uint256 public tokenRatePerEth = 0;\r\n    uint256 public tokenRatePercrypto = 0;\r\n    uint256 public rateDecimals = 0;\r\n    uint256 public minEthLimit = 1e17; // 0.1 BNB\r\n    uint256 public maxEthLimit = 10e18; // 10 BNB\r\n\r\n     uint256 public BUSDminEthLimit = 1e17; // 0.1 BNB\r\n    uint256 public  BUSDmaxEthLimit = 10e18;\r\n    \r\n    uint256 public soldTokens=0;\r\n    \r\n    uint256 public intervalDays;\r\n    \r\n    uint256 public endTime = 2 days;\r\n    \r\n    bool public isClaimable = false;\r\n    \r\n    bool public isWhitelisted = false;\r\n\r\n    bool public iscrypto = false;\r\n\r\n    uint256 public hardCap = 10 ether;\r\n    uint256 public BUSDhardCap = 10 ether;\r\n    \r\n    uint256 public earnedCap =0;\r\n\r\n     uint256 public BUSDearnedCap =0;\r\n    \r\n    uint256 public whitelistLength = 0;\r\n\r\n    address public Staker;\r\n\r\n    uint256 public currentPoolId = 0;\r\n    \r\n    mapping(address => uint256) public usersInvestments;\r\n\r\n    mapping(address => uint256) public usersBUSDInvestments;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    \r\n    mapping(address => mapping(address => uint256)) public whitelistedAddresses;\r\n    \r\n \r\n    \r\n    function startPresale(uint256 numberOfdays) external onlyOwner{\r\n        require(!isPresaleOpen, \"Presale is open\");\r\n        intervalDays = numberOfdays.mul(1 days);\r\n        endTime = block.timestamp.add(intervalDays);\r\n        isPresaleOpen = true;\r\n        isClaimable = false;\r\n    }\r\n    \r\n    function closePresale() external onlyOwner{\r\n        require(isPresaleOpen, \"Presale is not open yet or ended.\");\r\n        \r\n        isPresaleOpen = false;\r\n    }\r\n    \r\n    function setTokenAddress(address token) external onlyOwner {\r\n        tokenAddress = token;\r\n    }\r\n\r\n    function setCurrentPoolId(uint256 _pid) external onlyOwner {\r\n        currentPoolId = _pid;\r\n    }\r\n    \r\n    function setTokenDecimals(uint256 decimals) external onlyOwner {\r\n       tokenDecimals = decimals;\r\n    }\r\n    \r\n     function setCryptoAddress(address token) external onlyOwner {\r\n        _crypto = token;\r\n    }\r\n    \r\n    function setMinEthLimit(uint256 amount) external onlyOwner {\r\n        minEthLimit = amount;    \r\n    }\r\n    \r\n    function setBUSDMinEthLimit(uint256 amount) external onlyOwner {\r\n        BUSDminEthLimit = amount;    \r\n    }\r\n    function setMaxEthLimit(uint256 amount) external onlyOwner {\r\n        maxEthLimit = amount;    \r\n    }\r\n     function setBUSDMaxEthLimit(uint256 amount) external onlyOwner {\r\n        BUSDmaxEthLimit = amount;    \r\n    }\r\n    \r\n    function setTokenRatePerEth(uint256 rate) external onlyOwner {\r\n        tokenRatePerEth = rate;\r\n    }\r\n\r\n    function setTokenRatePercrypto(uint256 rateBUSD) external onlyOwner {\r\n        tokenRatePercrypto = rateBUSD;\r\n    }\r\n    \r\n    function setRateDecimals(uint256 decimals) external onlyOwner {\r\n        rateDecimals = decimals;\r\n    }\r\n    \r\n    function getUserInvestments(address user) public view returns (uint256){\r\n        return usersInvestments[user];\r\n    }\r\n\r\n     function getUserBUSDInvestments(address user) public view returns (uint256){\r\n        return usersBUSDInvestments[user];\r\n    }\r\n    \r\n    function getUserClaimbale(address user) public view returns (uint256){\r\n        return balanceOf[user];\r\n    }\r\n    \r\n    function addWhitelistedAddress(address _address, uint256 _allocation) external onlyOwner {\r\n        whitelistedAddresses[tokenAddress][_address] = _allocation;\r\n    }\r\n    \r\n    function addMultipleWhitelistedAddresses(address[] calldata _addresses, uint256[] calldata _allocation) external onlyOwner {\r\n         for (uint i=0; i<_addresses.length; i++) {\r\n             whitelistLength = whitelistLength.add(1);\r\n             whitelistedAddresses[tokenAddress][_addresses[i]] = _allocation[i];\r\n         }\r\n    }\r\n\r\n    function removeWhitelistedAddress(address _address) external onlyOwner {\r\n        whitelistedAddresses[tokenAddress][_address] = 0;\r\n        whitelistLength = whitelistLength.sub(1);\r\n    }\r\n    \r\n    receive() external payable{\r\n    \r\n       uint256 amount = msg.value;\r\n         if(block.timestamp > endTime || earnedCap.add(amount) > hardCap)\r\n            isPresaleOpen = false;\r\n        \r\n        require(isPresaleOpen, \"Presale is not open.\");\r\n       \r\n        if(isWhitelisted){\r\n            require(whitelistedAddresses[tokenAddress][msg.sender] > 0, \"you are not whitelisted\");\r\n            require(whitelistedAddresses[tokenAddress][msg.sender] >= amount, \"amount too high\");\r\n            require(usersInvestments[msg.sender].add(amount) <= whitelistedAddresses[tokenAddress][msg.sender], \"Maximum purchase cap hit\");\r\n        }else{\r\n             require(\r\n                usersInvestments[msg.sender].add(amount) <= maxEthLimit\r\n                && usersInvestments[msg.sender].add(amount) >= minEthLimit,\r\n                \"Installment Invalid.\"\r\n            );\r\n        }\r\n        \r\n        require(earnedCap.add(amount) <= hardCap,\"Hard Cap Exceeds\");\r\n        require( (IToken(tokenAddress).balanceOf(address(this))).sub(soldTokens) > 0 ,\"No Presale Funds left\");\r\n        uint256 tokenAmount = getTokensPerEth(amount);\r\n        require( (IToken(tokenAddress).balanceOf(address(this))).sub(soldTokens) >= tokenAmount ,\"No Presale Funds left\");\r\n        // require(msg.value),\"Insufficient balance from User\");\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(tokenAmount);\r\n        soldTokens = soldTokens.add(tokenAmount);\r\n        usersInvestments[msg.sender] = usersInvestments[msg.sender].add(amount);\r\n        earnedCap = earnedCap.add(amount);\r\n        payable(owner).transfer(amount);\r\n        IToken(tokenAddress).approve(Staker,soldTokens);\r\n    }\r\n    function buyToken(uint256 amount) public{\r\n         if(block.timestamp > endTime || BUSDearnedCap.add(amount) > BUSDhardCap)\r\n            isPresaleOpen = false;\r\n        \r\n        require(isPresaleOpen, \"Presale is not open.\");\r\n       \r\n        if(isWhitelisted){\r\n            require(whitelistedAddresses[tokenAddress][msg.sender] > 0, \"you are not whitelisted\");\r\n            require(whitelistedAddresses[tokenAddress][msg.sender] >= amount, \"amount too high\");\r\n            require(usersBUSDInvestments[msg.sender].add(amount) <= whitelistedAddresses[tokenAddress][msg.sender], \"Maximum purchase cap hit\");\r\n        }else{\r\n             require(\r\n                usersBUSDInvestments[msg.sender].add(amount) <= BUSDmaxEthLimit\r\n                && usersBUSDInvestments[msg.sender].add(amount) >= BUSDminEthLimit,\r\n                \"Installment Invalid.\"\r\n            );\r\n        }\r\n        require(BUSDearnedCap.add(amount) <= BUSDhardCap,\"Hard Cap Exceeds\");\r\n        require( (IToken(tokenAddress).balanceOf(address(this))).sub(soldTokens) > 0 ,\"No Presale Funds left\");\r\n        uint256 tokenAmount = getTokenPerCrypto(amount);\r\n        require( (IToken(tokenAddress).balanceOf(address(this))).sub(soldTokens) >= tokenAmount ,\"No Presale Funds left\");\r\n        require(IToken(_crypto).transferFrom(msg.sender,owner, amount),\"Insufficient balance from User\");\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(tokenAmount);\r\n        soldTokens = soldTokens.add(tokenAmount);\r\n        usersBUSDInvestments[msg.sender] = usersBUSDInvestments[msg.sender].add(amount);\r\n        BUSDearnedCap = BUSDearnedCap.add(amount);\r\n         IToken(tokenAddress).approve(Staker,soldTokens);\r\n    }  \r\n  function claimTokens() public{\r\n     //   require(!isPresaleOpen, \"You cannot claim tokens until the presale is closed.\");\r\n     //   require(isClaimable, \"You cannot claim tokens until the finalizeSale.\");\r\n        require(balanceOf[msg.sender] > 0 , \"No Tokens left !\");\r\n      //  require(IToken(tokenAddress).transferFrom(msg.sender,Staker, balanceOf[msg.sender]), \"Insufficient balance of presale contract!\");\r\n        MetaStake(Staker).depositFor(currentPoolId,balanceOf[msg.sender],msg.sender);\r\n        balanceOf[msg.sender]=0;\r\n    }\r\n    \r\n    function finalizeSale(address _staker) public onlyOwner{\r\n        isClaimable = !(isClaimable);\r\n        Staker = _staker;\r\n        IToken(tokenAddress).approve(Staker,soldTokens);\r\n        soldTokens = 0;\r\n    }\r\n    function approveContarct(address _staker,uint256 _amount) public onlyOwner {\r\n         Staker = _staker;\r\n         IToken(tokenAddress).approve(_staker,_amount);\r\n    }\r\n\r\n    function deposit(uint256 _pid,uint256 _amount) public onlyOwner{\r\n        MetaStake(Staker).depositFor(_pid,_amount,msg.sender);\r\n    }\r\n    \r\n    function whitelistedSale() public onlyOwner{\r\n        isWhitelisted = !(isWhitelisted);\r\n    }\r\n\r\n    function setHardCap(uint256 _hardCap) public onlyOwner{\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n     function setBUSDHardCap(uint256 _BUSDhardCap) public onlyOwner{\r\n        BUSDhardCap = _BUSDhardCap;\r\n    }\r\n    \r\n    function getTokensPerEth(uint256 amount) public view returns(uint256) {\r\n        return amount.mul(tokenRatePerEth).div(\r\n            10**(uint256(18).sub(tokenDecimals).add(rateDecimals))\r\n            );\r\n    }\r\n\r\n    \r\nfunction getTokenPerCrypto(uint256 _amount) public view returns (uint256){\r\n         return _amount.mul(tokenRatePercrypto).div(10**(uint256(IToken(_crypto).decimals()).sub(uint256(IToken(tokenAddress).decimals()).add(rateDecimals))));\r\n    }\r\n    \r\n    function withdrawBNB() public onlyOwner{\r\n        require(address(this).balance > 0 , \"No Funds Left\");\r\n         owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    function getUnsoldTokensBalance() public view returns(uint256) {\r\n        return IToken(tokenAddress).balanceOf(address(this));\r\n    }\r\n    \r\n    function burnUnsoldTokens() external onlyOwner {\r\n        require(!isPresaleOpen, \"You cannot burn tokens untitl the presale is closed.\");\r\n        IToken(tokenAddress).burnTokens(IToken(tokenAddress).balanceOf(address(this)));   \r\n    }\r\n    \r\n    function getUnsoldTokens() external onlyOwner {\r\n        require(!isPresaleOpen, \"You cannot get tokens until the presale is closed.\");\r\n        soldTokens = 0;\r\n        IToken(tokenAddress).transfer(owner, (IToken(tokenAddress).balanceOf(address(this))).sub(soldTokens) );\r\n    }\r\n      constructor(\r\n        \r\n        address _tokenAddress,\r\n        uint256 _tokenRatePerEth,\r\n        uint256 _tokenRatePercrypto,\r\n        uint256 _maxEthLimit,\r\n        uint256 _minEthLimit,\r\n        uint256 _BUSDmaxEthLimit,\r\n        uint256 _BUSDminEthLimit,\r\n        uint256 _hardCap,\r\n        uint256 _BUSDhardCap,\r\n        uint256 _poolId,\r\n        address _staker,\r\n        address _owner\r\n        \r\n    ) public {\r\n        tokenAddress = _tokenAddress;\r\n        tokenRatePerEth = _tokenRatePerEth;\r\n        tokenRatePercrypto = _tokenRatePercrypto;\r\n        maxEthLimit = _maxEthLimit;\r\n        minEthLimit = _minEthLimit;\r\n        BUSDmaxEthLimit = _BUSDmaxEthLimit;\r\n        BUSDminEthLimit = _BUSDminEthLimit;\r\n        hardCap = _hardCap;\r\n        BUSDhardCap = _BUSDhardCap;\r\n        currentPoolId = _poolId;\r\n        Staker = _staker;\r\n        owner = payable(_owner);\r\n    }\r\n    \r\n}\r\n\r\ncontract Proxy is Owned {\r\n\r\n    mapping(address => address) public _presale;\r\n\r\n    function createPresale( address _tokenAddress,\r\n        uint256 _tokenRatePerEth,\r\n        uint256 _tokenRatePercrypto,\r\n        uint256 _maxEthLimit,\r\n        uint256 _minEthLimit,\r\n        uint256 _BUSDmaxEthLimit,\r\n        uint256 _BUSDminEthLimit,\r\n        uint256 _hardCap,\r\n        uint256 _BUSDhardCap,\r\n        uint256 _poolId,\r\n        address _staker\r\n        ) public onlyOwner {\r\n         _presale[_tokenAddress] = address(new MetaswapLaunchpad(_tokenAddress,_tokenRatePerEth,_tokenRatePercrypto,_maxEthLimit,_minEthLimit,_BUSDmaxEthLimit,_BUSDminEthLimit,_hardCap,_BUSDhardCap,_poolId,_staker,msg.sender));\r\n        }\r\n    \r\n    function getPresale(address _token) public view returns (address){\r\n        return _presale[_token];\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_presale\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenRatePerEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenRatePercrypto\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxEthLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minEthLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_BUSDmaxEthLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_BUSDminEthLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_BUSDhardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"createPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPresale\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://12855f608bd7d28d7fdfa9f083a05e5b57994678fc98559361f10bdb792c0ccf"}