{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/DboneIssuer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n//\\n\\n// interface IPancakeFactory {\\n//     event PairCreated(\\n//         address indexed token0,\\n//         address indexed token1,\\n//         address pair,\\n//         uint256\\n//     );\\n\\n//     function feeTo() external view returns (address);\\n\\n//     function feeToSetter() external view returns (address);\\n\\n//     function getPair(address tokenA, address tokenB)\\n//         external\\n//         view\\n//         returns (address pair);\\n\\n//     function allPairs(uint256) external view returns (address pair);\\n\\n//     function allPairsLength() external view returns (uint256);\\n\\n//     function createPair(address tokenA, address tokenB)\\n//         external\\n//         returns (address pair);\\n\\n//     function setFeeTo(address) external;\\n\\n//     function setFeeToSetter(address) external;\\n// }\\n\\n// //\\n// interface IPancakeRouter {\\n//     function factory() external pure returns (address);\\n\\n//     function WETH() external pure returns (address);\\n\\n//     function addLiquidity(\\n//         address tokenA,\\n//         address tokenB,\\n//         uint256 amountADesired,\\n//         uint256 amountBDesired,\\n//         uint256 amountAMin,\\n//         uint256 amountBMin,\\n//         address to,\\n//         uint256 deadline\\n//     )\\n//         external\\n//         returns (\\n//             uint256 amountA,\\n//             uint256 amountB,\\n//             uint256 liquidity\\n//         );\\n\\n//     function addLiquidityETH(\\n//         address token,\\n//         uint256 amountTokenDesired,\\n//         uint256 amountTokenMin,\\n//         uint256 amountETHMin,\\n//         address to,\\n//         uint256 deadline\\n//     )\\n//         external\\n//         payable\\n//         returns (\\n//             uint256 amountToken,\\n//             uint256 amountETH,\\n//             uint256 liquidity\\n//         );\\n\\n//     function removeLiquidity(\\n//         address tokenA,\\n//         address tokenB,\\n//         uint256 liquidity,\\n//         uint256 amountAMin,\\n//         uint256 amountBMin,\\n//         address to,\\n//         uint256 deadline\\n//     ) external returns (uint256 amountA, uint256 amountB);\\n// }\\n\\n// /**\\n//  * @title SafeMath\\n//  * @dev Math operations with safety checks that throw on error\\n//  */\\n\\n// library SafeMath {\\n//     /**\\n//      * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n//      */\\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n//         require(b <= a);\\n//         uint256 c = a - b;\\n\\n//         return c;\\n//     }\\n\\n//     /**\\n//      * @dev Adds two numbers, reverts on overflow.\\n//      */\\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n//         uint256 c = a + b;\\n//         require(c >= a);\\n\\n//         return c;\\n//     }\\n// }\\n\\n// token\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function isTransferable() external view returns (bool);\\n\\n    function totalSupplyLimit() external view returns (uint256);\\n\\n    function getManager() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function mint(address to, uint256 amount) external returns (bool);\\n\\n    function burn(address to, uint256 amount) external returns (bool);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    // whitelist\\n    function isWhitelisted(address account) external view returns (bool);\\n\\n    function getWhiteListedAddressesCount() external view returns (uint256);\\n\\n    function whitelistAddresses(uint256 index) external view returns (address);\\n\\n    function updateWhiteList(\\n        address account,\\n        bool add\\n    ) external returns (address[] memory);\\n\\n    //\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ncontract DboneIssuer is Ownable {\\n    struct Proposal {\\n        string name; // short name (up to 32 bytes)\\n        uint256 voteCountInYes; // number of accumulated votes\\n        uint256 voteCountInNo; // number of accumulated votes\\n        address submittedBy; // number of accumulated votes\\n        bool isPoleclosed; // number of accumulated votes\\n    }\\n    struct Voter {\\n        bool voted; // if true, that person already voted\\n        bool voteIn; // person delegated to\\n        uint256 proposalIndex; // index of the voted proposal\\n    }\\n\\n    using SafeMath for uint;\\n\\n    uint256 public dbonPerUSDT = 125;\\n    uint256 public maxSwapTokenLimit = 25000 * 10 ** 18;\\n\\n    uint256 public claimedDevelopmentTeamReward;\\n    uint256 public claimRewardTime;\\n    uint256 public rewardMinted;\\n    bool public isRewardAvailable = true;\\n    uint256 public rewardAmount = 50 * 10 ** 18;\\n    uint256 public swapedLemltoEmlm;\\n    // uint256 public swapedUsdtToEmlm;\\n    uint256 public usdtWithEmlmLiquidity;\\n    uint256 public collectedUsdtInSwap = 0;\\n    uint256 public swappedDbnWithUsdt = 0;\\n    bool public acceptPublicProposal;\\n\\n    // address[] public whitelistAddresses;\\n    address[] public developmentTeamAddresses;\\n\\n    // A dynamically-sized array of `Proposal` structs.\\n    Proposal[] public proposals;\\n    mapping(uint256 => mapping(address => Voter)) public voters;\\n    IERC20 public usdtContract;\\n    IERC20 public dbonContract;\\n    IERC20 public ldbnContract;\\n    // IPancakeRouter public pancakeRouter =\\n    //     IPancakeRouter(0xD99D1c33F9fC3444f8101754aBC46c52416550D1);\\n\\n    // mapping(address => uint256) private _whitelistedIndexes;\\n    // mapping(address => bool) public isWhitelisted;\\n\\n    mapping(address => uint256) public rewards;\\n    mapping(address => uint256) public dues;\\n\\n    event UsdtToDBON(address indexed account, uint256 value);\\n    event CreatePool(uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    constructor(\\n        IERC20 usdtAddress,\\n        IERC20 dbonAddress,\\n        IERC20 ldbnAddress,\\n        address[] memory _developmentTeamAddresses\\n    ) {\\n        usdtContract = usdtAddress;\\n        dbonContract = dbonAddress;\\n        ldbnContract = ldbnAddress;\\n        developmentTeamAddresses = _developmentTeamAddresses;\\n        dbonContract.updateWhiteList(msg.sender, true);\\n    }\\n\\n    receive() external payable {}\\n\\n    // function getUsdtWithDBONPoolAddress() public view returns (address) {\\n    //     IPancakeFactory factory = IPancakeFactory(\\n    //         address(pancakeRouter.factory())\\n    //     );\\n    //     return factory.getPair(address(dbonContract), address(usdtContract));\\n    // }\\n\\n    // public methods\\n    // ...give free reward\\n    function getreward() public {\\n        require(isRewardAvailable, \\\"Reward is not available\\\");\\n        require(rewards[msg.sender] == 0, \\\"You have already registered\\\");\\n        require(rewardMinted <= 1000000 * 10 ** 18, \\\"Reward Limit Exceeded\\\");\\n        rewards[msg.sender] = rewardAmount;\\n        rewardMinted += rewardAmount;\\n        dbonContract.mint(msg.sender, rewardAmount);\\n    }\\n\\n    function setRewardSettings(\\n        bool _isRewardAvailable,\\n        uint256 _rewardAmount\\n    ) public {\\n        isRewardAvailable = _isRewardAvailable;\\n        rewardAmount = _rewardAmount;\\n    }\\n\\n    function clearDues(address account) public {\\n        if (\\n            dues[account] > 0 &&\\n            dbonContract.balanceOf(account) >= dues[account]\\n        ) {\\n            dbonContract.burn(msg.sender, dues[account]);\\n            dues[account] = 0;\\n        }\\n    }\\n\\n    function getVoteProposal()\\n        public\\n        view\\n        returns (Proposal[] memory _proposals, uint256 limit)\\n    {\\n        return (proposals, proposals.length);\\n    }\\n\\n    // function getVoteProposal(uint256 page, uint256 pageSize)\\n    //     external\\n    //     view\\n    //     returns (Proposal[] memory _proposals, uint256 limit)\\n    // {\\n    //     require(pageSize > 0, \\\"page size must be positive\\\");\\n    //     require(\\n    //         page == 0 || page * pageSize <= proposals.length,\\n    //         \\\"out of bounds\\\"\\n    //     );\\n    //     uint256 actualSize = pageSize;\\n    //     if ((page + 1) * pageSize > proposals.length) {\\n    //         actualSize = proposals.length - page * pageSize;\\n    //     }\\n    //     _proposals = new Proposal[](actualSize);\\n    //     for (uint256 i = 0; i < actualSize; i++) {\\n    //         _proposals[i] = proposals[page * pageSize + i];\\n    //     }\\n    //     return (_proposals, proposals.length);\\n    // }\\n\\n    // function createPool()\\n    //     public\\n    //     returns (\\n    //         uint256 amountA,\\n    //         uint256 amountB,\\n    //         uint256 liquidity\\n    //     )\\n    // {\\n    //     require(\\n    //         usdtContract.balanceOf(address(this)) >= 100 * 10**18,\\n    //         \\\"haven't enough usdt\\\"\\n    //     );\\n    //     require(\\n    //         dbonContract.isTransferable(),\\n    //         \\\"haven't enough usdt\\\"\\n    //     );\\n    //     dbonContract.mint(address(this), 100 * 10**18);\\n    //     dbonContract.approve(address(pancakeRouter), 100 * 10**18);\\n    //     usdtContract.approve(address(pancakeRouter), 100 * 10**18);\\n    //     (amountA, amountB, liquidity) = pancakeRouter.addLiquidity(\\n    //         address(dbonContract),\\n    //         address(usdtContract),\\n    //         100 * 10**18,\\n    //         100 * 10**18,\\n    //         1 * 10**18,\\n    //         1 * 10**18,\\n    //         address(this),\\n    //         block.timestamp + 1 days\\n    //     );\\n    //     usdtWithEmlmLiquidity = liquidity;\\n    //     emit CreatePool(amountA, amountB, liquidity);\\n    // }\\n\\n    // function removeLiquidity() public {\\n    //     // dbonContract.mint(address(this), 100 * 10**18);\\n    //     // dbonContract.approve(address(pancakeRouter), 100 * 10**18);\\n    //     pancakeRouter.removeLiquidity(\\n    //         address(dbonContract),\\n    //         address(usdtContract),\\n    //         usdtWithEmlmLiquidity,\\n    //         1 * 10**18,\\n    //         1 * 10**18,\\n    //         address(this),\\n    //         block.timestamp + 1 days\\n    //     );\\n    // }\\n\\n    // ...submit vote proposol\\n    function subimtVoteProposal(string memory _name) public {\\n        if (owner() != msg.sender) {\\n            require(acceptPublicProposal, \\\"Proposal submission is closed.\\\");\\n        }\\n        if (proposals.length > 0) {\\n            require(\\n                proposals[proposals.length - 1].isPoleclosed,\\n                \\\"Previus pool is not closed yet\\\"\\n            );\\n        }\\n        require(\\n            dbonContract.balanceOf(msg.sender) >= 20000 * 10 ** 18,\\n            \\\"Own 20k DBN to submit proposal.\\\"\\n        );\\n        clearDues(msg.sender);\\n        proposals.push(\\n            Proposal({\\n                name: _name,\\n                voteCountInYes: 0, // number of accumulated votes in yes\\n                voteCountInNo: 0, // number of accumulated votes in no\\n                submittedBy: msg.sender, // number of accumulated votes\\n                isPoleclosed: false // number of accumulated votes\\n            })\\n        );\\n    }\\n\\n    function claimDevelopmentTeamRewards() public {\\n        require(\\n            claimRewardTime != 0 && block.timestamp >= claimRewardTime,\\n            \\\"Can't claim before time.\\\"\\n        );\\n        uint256 _rewardToMint = (100000000 * 10 ** 18 * 27777777) / 1000000000;\\n        claimedDevelopmentTeamReward += _rewardToMint;\\n        claimRewardTime = claimRewardTime + 30 days;\\n        for (uint256 i = 0; i < developmentTeamAddresses.length; i++) {\\n            dbonContract.mint(\\n                developmentTeamAddresses[i],\\n                _rewardToMint / developmentTeamAddresses.length\\n            );\\n        }\\n    }\\n\\n    // ...submit vote proposol\\n    function vote(uint256 _index, bool _vote) public {\\n        clearDues(msg.sender);\\n        Voter storage voter = voters[_index][msg.sender];\\n        require(!voter.voted, \\\"Already voted.\\\");\\n        require(\\n            dbonContract.isWhitelisted(msg.sender),\\n            \\\"Only whitelisted allowed.\\\"\\n        );\\n        require(!proposals[_index].isPoleclosed, \\\"Pole is closed.\\\");\\n        require(\\n            dbonContract.balanceOf(msg.sender) >= 50 * 10 ** 18,\\n            \\\"Haven't enough DBN to pay fee.\\\"\\n        );\\n        dbonContract.burn(msg.sender, 50 * 10 ** 18);\\n        voter.voted = true;\\n        voter.proposalIndex = _index;\\n        voter.voteIn = _vote;\\n        // If `proposal` is out of the range of the array,\\n        // this will throw automatically and revert all\\n        // changes.\\n        if (_vote) proposals[_index].voteCountInYes++;\\n        else proposals[_index].voteCountInNo++;\\n    }\\n\\n    // ...submit vote proposol\\n    function closeProposalPoll(uint256 _index) public {\\n        clearDues(msg.sender);\\n        require(!proposals[_index].isPoleclosed, \\\"Proposal is already closed\\\");\\n        require(\\n            proposals[_index].submittedBy == msg.sender,\\n            \\\"Proposal is not submitted by you\\\"\\n        );\\n        Proposal memory _proposal = proposals[_index];\\n        if (_proposal.voteCountInYes > _proposal.voteCountInNo) {\\n            if (dbonContract.balanceOf(_proposal.submittedBy) > 0)\\n                dbonContract.burn(\\n                    _proposal.submittedBy,\\n                    dbonContract.balanceOf(_proposal.submittedBy) / 100\\n                );\\n            for (\\n                uint256 i = 0;\\n                i < dbonContract.getWhiteListedAddressesCount();\\n                i++\\n            ) {\\n                // Voter memory voter = voters[_index][whitelistAddresses[i]];\\n\\n                if (\\n                    !voters[_index][dbonContract.whitelistAddresses(i)].voteIn\\n                ) {\\n                    if (\\n                        dbonContract.balanceOf(\\n                            dbonContract.whitelistAddresses(i)\\n                        ) >= 10 * 10 ** 18\\n                    )\\n                        dbonContract.burn(\\n                            dbonContract.whitelistAddresses(i),\\n                            10 * 10 ** 18\\n                        );\\n                    else\\n                        dues[dbonContract.whitelistAddresses(i)] +=\\n                            10 *\\n                            10 ** 18;\\n                }\\n            }\\n        } else {\\n            dbonContract.burn(\\n                _proposal.submittedBy,\\n                dbonContract.balanceOf(_proposal.submittedBy) / 10\\n            );\\n        }\\n        _proposal.isPoleclosed = true;\\n        proposals[_index] = _proposal;\\n    }\\n\\n    function dbnToUsdt(uint256 dbn) public {\\n        clearDues(msg.sender);\\n        require(dbonContract.balanceOf(msg.sender) >= dbn, \\\"Not enough DBN.\\\");\\n        (uint256 _usdt, uint256 newEmlmPerUSDT) = dbnToUsdtPrice(dbn);\\n        require(\\n            usdtContract.balanceOf(address(this)) >= _usdt,\\n            \\\"Not enough USDT.\\\"\\n        );\\n        dbonPerUSDT = newEmlmPerUSDT;\\n        collectedUsdtInSwap -= _usdt;\\n        swappedDbnWithUsdt -= dbn;\\n        usdtContract.transfer(msg.sender, _usdt);\\n        dbonContract.burn(msg.sender, dbn);\\n        // swapedUsdtToEmlm += _usdt;\\n        // emit UsdtToDBON(msg.sender, _usdt);\\n    }\\n\\n    function usdtToDBON(uint256 amount) public {\\n        require(\\n            usdtContract.allowance(msg.sender, address(this)) >= amount,\\n            \\\"Not enough usdt allowance.\\\"\\n        );\\n        (uint256 _tokens, uint256 newEmlmPerUSDT) = usdtToDBNPrice(amount);\\n        require(\\n            dbonContract.balanceOf(msg.sender) + _tokens < maxSwapTokenLimit,\\n            \\\"You can not swap more than limit\\\"\\n        );\\n        dbonPerUSDT = newEmlmPerUSDT;\\n        usdtContract.transferFrom(msg.sender, address(this), amount);\\n        dbonContract.mint(msg.sender, _tokens);\\n        dbonContract.updateWhiteList(msg.sender, true);\\n        clearDues(msg.sender);\\n        // swapedUsdtToEmlm += _tokens;\\n        collectedUsdtInSwap += amount;\\n        swappedDbnWithUsdt += _tokens;\\n        emit UsdtToDBON(msg.sender, _tokens);\\n    }\\n\\n    function usdtToDBNPrice(\\n        uint256 usdt\\n    ) public view returns (uint256 tokens, uint256 newEmlmPerUSDT) {\\n        uint256 _dbonPerUSDT = dbonPerUSDT;\\n        uint256 tokenLimitUnderPrice = usdt + collectedUsdtInSwap;\\n\\n        if (_dbonPerUSDT == 125) {\\n            if (tokenLimitUnderPrice > (800000 * 10 ** 18)) {\\n                tokens =\\n                    ((400000 * 10 ** 18) - collectedUsdtInSwap) *\\n                    _dbonPerUSDT;\\n                _dbonPerUSDT = 112;\\n                tokens += (400000 * 10 ** 18) * _dbonPerUSDT;\\n                _dbonPerUSDT = 100;\\n                tokens +=\\n                    (usdt -\\n                        (400000 * 10 ** 18) -\\n                        ((400000 * 10 ** 18) - collectedUsdtInSwap)) *\\n                    _dbonPerUSDT;\\n            } else if (tokenLimitUnderPrice > (400000 * 10 ** 18)) {\\n                tokens =\\n                    ((400000 * 10 ** 18) - collectedUsdtInSwap) *\\n                    _dbonPerUSDT;\\n                _dbonPerUSDT = 112;\\n                tokens +=\\n                    (usdt - ((400000 * 10 ** 18) - collectedUsdtInSwap)) *\\n                    _dbonPerUSDT;\\n            } else {\\n                tokens = usdt * _dbonPerUSDT;\\n            }\\n        } else if (_dbonPerUSDT == 112) {\\n            if (tokenLimitUnderPrice > (800000 * 10 ** 18)) {\\n                tokens =\\n                    ((800000 * 10 ** 18) - collectedUsdtInSwap) *\\n                    _dbonPerUSDT;\\n                _dbonPerUSDT = 100;\\n                tokens +=\\n                    (usdt - ((800000 * 10 ** 18) - collectedUsdtInSwap)) *\\n                    _dbonPerUSDT;\\n            } else {\\n                tokens = usdt * _dbonPerUSDT;\\n            }\\n        } else {\\n            tokens = usdt * dbonPerUSDT;\\n        }\\n        // swapedUsdtToEmlm += tokens;\\n        return (tokens, _dbonPerUSDT);\\n    }\\n\\n    function dbnToUsdtPrice(\\n        uint256 dbn\\n    ) public view returns (uint256 usdt, uint256 newEmlmPerUSDT) {\\n        uint256 _dbonPerUSDT = dbonPerUSDT;\\n        uint256 resultDbn = 0;\\n        if (swappedDbnWithUsdt > dbn) {\\n            resultDbn = swappedDbnWithUsdt.sub(dbn);\\n        }\\n\\n        if (_dbonPerUSDT == 112) {\\n            // change price in 2nd phase\\n            if (resultDbn < (400000 * 10 ** 18)) {\\n                // above 112 rate\\n                usdt = swappedDbnWithUsdt.sub(400000 * 10 ** 18) / _dbonPerUSDT;\\n                _dbonPerUSDT = 125;\\n                usdt +=\\n                    (dbn.sub(swappedDbnWithUsdt.sub(400000 * 10 ** 18))) /\\n                    _dbonPerUSDT;\\n            } else {\\n                usdt = dbn * _dbonPerUSDT;\\n            }\\n        } else if (_dbonPerUSDT == 100) {\\n            // change price in 3nd phase\\n            if (resultDbn < (400000 * 10 ** 18)) {\\n                // above 800000 per 100 usdt\\n                usdt =\\n                    (swappedDbnWithUsdt.sub(800000 * 10 ** 18)) /\\n                    _dbonPerUSDT;\\n                _dbonPerUSDT = 112;\\n                usdt += (400000 * 10 ** 18) / _dbonPerUSDT;\\n                _dbonPerUSDT = 125;\\n                usdt +=\\n                    (dbn.sub(swappedDbnWithUsdt.sub(800000 * 10 ** 18)) +\\n                        (400000 * 10 ** 18)) /\\n                    _dbonPerUSDT;\\n            } else if (resultDbn < (800000 * 10 ** 18)) {\\n                usdt =\\n                    (swappedDbnWithUsdt.sub(800000 * 10 ** 18)) /\\n                    _dbonPerUSDT;\\n                _dbonPerUSDT = 112;\\n                usdt +=\\n                    (dbn.sub(swappedDbnWithUsdt.sub(800000 * 10 ** 18))) /\\n                    _dbonPerUSDT;\\n            } else {\\n                usdt = dbn * _dbonPerUSDT;\\n            }\\n        } else {\\n            // dont change price in 1nd phase\\n            usdt = dbn.div(dbonPerUSDT);\\n        }\\n        return (usdt, _dbonPerUSDT);\\n    }\\n\\n    // ...swap LDBN with DBON\\n    function ldbnToEmlm(uint256 amount) public {\\n        require(\\n            swapedLemltoEmlm <= 300000000 * 10 ** 18,\\n            \\\"DBN Limit is Exceeded.\\\"\\n        );\\n        require(\\n            ldbnContract.allowance(msg.sender, address(this)) >= amount,\\n            \\\"Not enough ldbn allowance.\\\"\\n        );\\n        swapedLemltoEmlm += amount;\\n        ldbnContract.transferFrom(msg.sender, address(this), amount);\\n        dbonContract.mint(msg.sender, amount);\\n        clearDues(msg.sender);\\n    }\\n\\n    function updateMEMLPerUSDT(uint256 amount) public onlyOwner {\\n        dbonPerUSDT = amount;\\n    }\\n\\n    function startDevTeamRewardClaim() public onlyOwner {\\n        claimRewardTime = block.timestamp;\\n    }\\n\\n    function updateDBONAddress(IERC20 _dbonContract) public onlyOwner {\\n        dbonContract = _dbonContract;\\n    }\\n\\n    function updateAcceptPublicProposal(\\n        bool _acceptPublicProposal\\n    ) public onlyOwner {\\n        require(\\n            _acceptPublicProposal != acceptPublicProposal,\\n            \\\"Nothing to update\\\"\\n        );\\n        acceptPublicProposal = _acceptPublicProposal;\\n    }\\n\\n    function updateMaxSwapTokenLimit(\\n        uint256 _maxSwapTokenLimit\\n    ) public onlyOwner {\\n        maxSwapTokenLimit = _maxSwapTokenLimit;\\n    }\\n\\n    function transferUSDT(address account, uint256 amount) public onlyOwner {\\n        require(\\n            usdtContract.balanceOf(address(this)) >= amount,\\n            \\\"Not Enogh In USDT\\\"\\n        );\\n        usdtContract.transfer(account, amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"usdtAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dbonAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"ldbnAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_developmentTeamAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"CreatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"UsdtToDBON\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptPublicProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDevelopmentTeamRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedDevelopmentTeamReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"clearDues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"closeProposalPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedUsdtInSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbn\",\"type\":\"uint256\"}],\"name\":\"dbnToUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbn\",\"type\":\"uint256\"}],\"name\":\"dbnToUsdtPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newEmlmPerUSDT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dbonContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dbonPerUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"developmentTeamAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVoteProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"voteCountInYes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteCountInNo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"submittedBy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPoleclosed\",\"type\":\"bool\"}],\"internalType\":\"struct DboneIssuer.Proposal[]\",\"name\":\"_proposals\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getreward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRewardAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ldbnContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ldbnToEmlm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSwapTokenLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"voteCountInYes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteCountInNo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"submittedBy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPoleclosed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isRewardAvailable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_rewardAmount\",\"type\":\"uint256\"}],\"name\":\"setRewardSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDevTeamRewardClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"subimtVoteProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapedLemltoEmlm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swappedDbnWithUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_acceptPublicProposal\",\"type\":\"bool\"}],\"name\":\"updateAcceptPublicProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_dbonContract\",\"type\":\"address\"}],\"name\":\"updateDBONAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateMEMLPerUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSwapTokenLimit\",\"type\":\"uint256\"}],\"name\":\"updateMaxSwapTokenLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"}],\"name\":\"usdtToDBNPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newEmlmPerUSDT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"usdtToDBON\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtWithEmlmLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"voted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"voteIn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DboneIssuer", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000002a597cde5f37d4cf2bbd9f902444f7085a977379000000000000000000000000b878932ebe45cc7948360e8eed8cf58da7f12ca70000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000006b59327e05d6b288d149e9d16042c4405f00881000000000000000000000000edcf463ad9820c8f308e68632b929cce31592343000000000000000000000000f2d730a475a62dd59924e44b0a44e89cb352de92000000000000000000000000d9d7aa768af964f0f27aa0e163e87f188a4743e5000000000000000000000000488e67d0f8995a4f850c417c40627305bf9f8274000000000000000000000000485a0254f1ba80251d12530d397c3e9f420056f50000000000000000000000004374a0b9d6a9b79f50b3dcb16a1d5e7250a226f0000000000000000000000000502aa841deb1077b75ab1ed12f1a20596eb799970000000000000000000000006ecc45e5ba8a3ba4cd610257ff9dd88ed3b5ee230000000000000000000000004f0cb8111c39dd95eff1df565c992e99e1b0e00b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}