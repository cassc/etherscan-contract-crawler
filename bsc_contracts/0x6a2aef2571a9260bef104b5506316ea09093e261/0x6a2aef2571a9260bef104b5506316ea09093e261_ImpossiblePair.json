{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"},\"IImpossibleCallee.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IImpossibleCallee {\\n    function ImpossibleCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"},\"IImpossibleERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IImpossibleERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\"},\"IImpossibleFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\ninterface IImpossibleFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n    event UpdatedGovernance(address governance);\\n\\n    function feeTo() external view returns (address);\\n\\n    function governance() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setGovernance(address) external;\\n}\\n\"},\"IImpossibleMigrator.Sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IImpossibleMigrator {\\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\\n}\\n\"},\"IImpossiblePair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport \\u0027./IImpossibleERC20.sol\\u0027;\\n\\ninterface IImpossiblePair is IImpossibleERC20 {\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint256 reserve0, uint256 reserve1);\\n    event changeInvariant(bool _isXybk, uint256 _ratioStart, uint256 _ratioEnd);\\n    event updatedTradeFees(uint256 _prevFee, uint256 _newFee);\\n    event updatedDelay(uint256 _oldDelay, uint256 _newDelay);\\n    event updatedHardstops(uint8 _ratioStart, uint8 _ratioEnd);\\n    event updatedBoost(\\n        uint32 _prevBoost0,\\n        uint32 _prevBoost1,\\n        uint32 _newBoost0,\\n        uint32 _newBoost1,\\n        uint256 _start,\\n        uint256 _end\\n    );\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address); // address of token0\\n\\n    function token1() external view returns (address); // address of token1\\n\\n    function router() external view returns (address); // address of token1\\n\\n    function getReserves() external view returns (uint256, uint256); // reserves of token0/token1\\n\\n    function calcBoost() external view returns (uint256, uint256);\\n\\n    function mint(address) external returns (uint256);\\n\\n    function burn(address) external returns (uint256, uint256);\\n\\n    function swap(\\n        uint256,\\n        uint256,\\n        address,\\n        bytes calldata\\n    ) external;\\n\\n    function cheapSwap(\\n        uint256,\\n        uint256,\\n        address,\\n        bytes calldata\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function getFeeAndXybk() external view returns (uint256, bool); // Uses single storage slot, save gas\\n\\n    function delay() external view returns (uint256); // Amount of time delay required before any change to boost etc, denoted in seconds\\n\\n    function initialize(\\n        address,\\n        address,\\n        address\\n    ) external;\\n}\\n\"},\"IImpossibleRouter01.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity \\u003e=0.6.2;\\n\\ninterface IImpossibleRouter01 {\\n    function factory() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view returns (uint256);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view returns (uint256);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n}\\n\"},\"IImpossibleRouter02.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity \\u003e=0.6.2;\\n\\nimport \\u0027./IImpossibleRouter01.sol\\u0027;\\n\\ninterface IImpossibleRouter02 is IImpossibleRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"},\"ImpossibleERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport \\u0027./IImpossibleERC20.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract ImpossibleERC20 is IImpossibleERC20 {\\n    using SafeMath for uint256;\\n\\n    string public constant override name = \\u0027Impossible Swap LPs\\u0027;\\n    string public constant override symbol = \\u0027IF-LP\\u0027;\\n    uint8 public constant override decimals = 18;\\n    uint256 public override totalSupply;\\n    mapping(address =\\u003e uint256) public override balanceOf;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public override allowance;\\n\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address =\\u003e uint256) public override nonces;\\n\\n    constructor() {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\u0027EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\u0027),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\u00271\\u0027)),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(deadline \\u003e= block.timestamp, \\u0027IF: EXPIRED\\u0027);\\n        bytes32 digest =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\u0027\\\\x19\\\\x01\\u0027,\\n                    DOMAIN_SEPARATOR,\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\u0027IF: INVALID_SIGNATURE\\u0027);\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"},\"ImpossibleFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport \\u0027./IImpossibleFactory.sol\\u0027;\\nimport \\u0027./ImpossiblePair.sol\\u0027;\\n\\ncontract ImpossibleFactory is IImpossibleFactory {\\n    bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(ImpossiblePair).creationCode));\\n\\n    address public override feeTo;\\n    address public override governance;\\n    address public router;\\n    bool whitelist;\\n    mapping(address =\\u003e bool) approvedTokens;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e address)) public override getPair;\\n    address[] public override allPairs;\\n\\n    constructor(address _governance) {\\n        governance = _governance;\\n    }\\n\\n    function allPairsLength() external view override returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    function setRouter(address _router) external {\\n        require(msg.sender == address(governance), \\\"IF: FORBIDDEN\\\");\\n        require(router == address(0x0), \\u0027IF: ROUTER_SET\\u0027);\\n        router = _router;\\n    }\\n\\n    function changeTokenAccess(address token, bool allowed) external {\\n        require(msg.sender == address(governance), \\u0027IF: FORBIDDEN\\u0027);\\n        approvedTokens[token] = allowed;\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\\n        // tokens must not be identical (i.e. have same address)\\n        if (whitelist) {\\n            require(approvedTokens[tokenA] \\u0026\\u0026 approvedTokens[tokenB], \\u0027IF: Unapproved tokens\\u0027);\\n        }\\n        require(tokenA != tokenB, \\u0027IF: IDENTICAL_ADDRESSES\\u0027);\\n        // order token addresses from low to high\\n        (address token0, address token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        // token0 and token1 should always be ordered from low to high, so only check token0\\n        require(token0 != address(0), \\u0027IF: ZERO_ADDRESS\\u0027);\\n        // both directions of mappings should always exist, so we only need to check one direction\\n        // (see code below for logic that adds mappings)\\n        require(getPair[token0][token1] == address(0), \\u0027IF: PAIR_EXISTS\\u0027);\\n\\n        // deploy pair contract using create2 opcode\\n        // for more info: https://hackernoon.com/using-ethereums-create2-nw2137q7\\n        bytes memory bytecode = type(ImpossiblePair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n\\n        // deploy pair\\n        IImpossiblePair(pair).initialize(token0, token1, router);\\n        // populate mappings in both forward and reverse directions\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair;\\n        // add new pair to array of all pair addresses\\n        allPairs.push(pair);\\n        // emit event\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function setFeeTo(address _feeTo) external override {\\n        // setter of feeTo must be `feeToSetter`\\n        require(msg.sender == governance, \\u0027IF: FORBIDDEN\\u0027);\\n        // set feeTo\\n        feeTo = _feeTo;\\n    }\\n\\n    function setGovernance(address _governance) external override {\\n        // setter of feeToSetter must be current `feeToSetter`\\n        require(msg.sender == governance, \\u0027IF: FORBIDDEN\\u0027);\\n        // set feeToSetter\\n        governance = _governance;\\n    }\\n}\\n\"},\"ImpossibleLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity \\u003e=0.5.0;\\n\\nimport \\u0027./IImpossiblePair.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./Math.sol\\u0027;\\n\\nlibrary ImpossibleLibrary {\\n    using SafeMath for uint256;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\u0027ImpossibleLibrary: IDENTICAL_ADDRESSES\\u0027);\\n        (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\u0027ImpossibleLibrary: ZERO_ADDRESS\\u0027);\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    // Bytecode:\\n    // test: 7001e83fa95fc00db3ef41a018f2da0a7dbea398f06fe2cf2e1aa3f1c148978c\\n    // prod:\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\u0027ff\\u0027,\\n                        factory,\\n                        keccak256(abi.encodePacked(token0, token1)),\\n                        hex\\u00274386fe27b9c4bd094a30feca11207fdde676bdece6b55d36760cf329266d1fa7\\u0027 // init code hash\\n                        // de353d433fa966b87b4bc7c1e4c8035e23fd1ae8b9908cc103a0403d4abfbe13 in prod\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 reserveA,\\n            uint256 reserveB,\\n            address pair\\n        )\\n    {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        pair = pairFor(factory, tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1) = IImpossiblePair(pair).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA \\u003e 0, \\u0027ImpossibleLibrary: INSUFFICIENT_AMOUNT\\u0027);\\n        require(reserveA \\u003e 0 \\u0026\\u0026 reserveB \\u003e 0, \\u0027ImpossibleLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // Calculates term for artificial liquidity. Term = (b-1)*sqrtK\\n    function calcArtiLiquidityTerm(uint256 _boost, uint256 _sqrtK) internal pure returns (uint256) {\\n        return (_boost - 1).mul(_sqrtK);\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut,\\n        address factory\\n    ) internal view returns (uint256 amountOut) {\\n        require(amountIn \\u003e 0, \\u0027ImpossibleLibrary: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n        uint256 amountInPostFee;\\n        address pair;\\n        bool isMatch;\\n        {\\n            // Avoid stack too deep\\n            (address token0, ) = sortTokens(tokenIn, tokenOut);\\n            isMatch = tokenIn == token0;\\n            (reserveIn, reserveOut, pair) = getReserves(factory, tokenIn, tokenOut);\\n            require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027ImpossibleLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        }\\n        uint256 artiLiqTerm;\\n        bool isXybk;\\n        {\\n            // Avoid stack too deep\\n            uint256 fee;\\n            (fee, isXybk) = IImpossiblePair(pair).getFeeAndXybk();\\n            amountInPostFee = amountIn.mul(10000 - fee);\\n        }\\n\\n        // If xybk invariant, set reserveIn/reserveOut to artificial liquidity instead of actual liquidity\\n        if (isXybk) {\\n            (uint256 boost0, uint256 boost1) = IImpossiblePair(pair).calcBoost();\\n            uint256 sqrtK = xybkComputeSqrtK(isMatch, reserveIn, reserveOut, boost0, boost1);\\n            // since balance0=balance1 only at sqrtK, if final balanceIn \\u003e= sqrtK means balanceIn \\u003e= balanceOut\\n            // Use post-fee balances to maintain consistency with pair contract K invariant check\\n            if (amountInPostFee.add(reserveIn.mul(10000)) \\u003e= sqrtK.mul(10000)) {\\n                // If tokenIn = token0, balanceIn \\u003e sqrtK =\\u003e balance0\\u003esqrtK, use boost0\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost0 : boost1, sqrtK);\\n                // If balance started from \\u003csqrtK and ended at \\u003esqrtK and boosts are different, there\\u0027ll be different amountIn/Out\\n                // Don\\u0027t need to check in other case for reserveIn \\u003c reserveIn.add(x) \\u003c= sqrtK since that case doesnt cross midpt\\n                if (reserveIn \\u003c sqrtK \\u0026\\u0026 boost0 != boost1) {\\n                    // Break into 2 trades =\\u003e start point -\\u003e midpoint (sqrtK, sqrtK), then midpoint -\\u003e final point\\n                    amountOut = reserveOut.sub(sqrtK);\\n                    amountInPostFee = amountInPostFee.sub((sqrtK.sub(reserveIn)).mul(10000));\\n                    reserveIn = sqrtK;\\n                    reserveOut = sqrtK;\\n                }\\n            } else {\\n                // If tokenIn = token0, balanceIn \\u003c sqrtK =\\u003e balance0\\u003csqrtK, use boost1\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost1 : boost0, sqrtK);\\n            }\\n        }\\n        uint256 numerator = amountInPostFee.mul(reserveOut.add(artiLiqTerm));\\n        uint256 denominator = (reserveIn.add(artiLiqTerm)).mul(10000).add(amountInPostFee);\\n        uint256 lastSwapAmountOut = numerator / denominator;\\n        amountOut = (lastSwapAmountOut \\u003e reserveOut) ? reserveOut.add(amountOut) : lastSwapAmountOut.add(amountOut);\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        address tokenIn,\\n        address tokenOut,\\n        address factory\\n    ) internal view returns (uint256 amountIn) {\\n        require(amountOut \\u003e 0, \\u0027ImpossibleLibrary: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n        uint256 artiLiqTerm;\\n        uint256 fee;\\n        bool isMatch;\\n        {\\n            // Avoid stack too deep\\n            bool isXybk;\\n            uint256 boost0;\\n            uint256 boost1;\\n            {\\n                // Avoid stack too deep\\n                (address token0, ) = sortTokens(tokenIn, tokenOut);\\n                isMatch = token0 == tokenOut;\\n            }\\n            {\\n                // Avoid stack too deep\\n                address pair;\\n                (reserveIn, reserveOut, pair) = getReserves(factory, tokenIn, tokenOut);\\n                require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027ImpossibleLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n                (fee, isXybk) = IImpossiblePair(pair).getFeeAndXybk();\\n                (boost0, boost1) = IImpossiblePair(pair).calcBoost();\\n            }\\n            if (isXybk) {\\n                uint256 sqrtK = xybkComputeSqrtK(isMatch, reserveOut, reserveIn, boost0, boost1);\\n                // since balance0=balance1 only at sqrtK, if final balanceOut \\u003e= sqrtK means balanceOut \\u003e= balanceIn\\n                if (reserveOut.sub(amountOut) \\u003e= sqrtK) {\\n                    // If tokenOut = token0, balanceOut \\u003e sqrtK =\\u003e balance0\\u003esqrtK, use boost0\\n                    artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost0 : boost1, sqrtK);\\n                } else {\\n                    // If tokenOut = token0, balanceOut \\u003c sqrtK =\\u003e balance0\\u003csqrtK, use boost1\\n                    artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost1 : boost0, sqrtK);\\n                    // If balance started from \\u003csqrtK and ended at \\u003esqrtK and boosts are different, there\\u0027ll be different amountIn/Out\\n                    // Don\\u0027t need to check in other case for reserveOut \\u003e reserveOut.sub(x) \\u003e= sqrtK since that case doesnt cross midpt\\n                    if (reserveOut \\u003e sqrtK \\u0026\\u0026 boost0 != boost1) {\\n                        // Break into 2 trades =\\u003e start point -\\u003e midpoint (sqrtK, sqrtK), then midpoint -\\u003e final point\\n                        amountIn = sqrtK.sub(reserveIn).mul(10000).div(10000 - fee);\\n                        amountOut = amountOut.sub(reserveOut.sub(sqrtK));\\n                        reserveOut = sqrtK;\\n                        reserveIn = sqrtK;\\n                    }\\n                }\\n            }\\n        }\\n        uint256 numerator = (reserveIn.add(artiLiqTerm)).mul(amountOut).mul(10000);\\n        uint256 denominator = (reserveOut.add(artiLiqTerm)).sub(amountOut).mul(10000 - fee);\\n        amountIn = amountIn.add((numerator / denominator).add(1));\\n    }\\n\\n    function getAmountOutFeeOnTransfer(\\n        address tokenIn,\\n        address tokenOut,\\n        address factory\\n    ) internal view returns (uint256, uint256) {\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n        address pair;\\n        bool isMatch;\\n        {\\n            // Avoid stack too deep\\n            (address token0, ) = sortTokens(tokenIn, tokenOut);\\n            isMatch = tokenIn == token0;\\n            (reserveIn, reserveOut, pair) = getReserves(factory, tokenIn, tokenOut); // Should be reserve0/1 but reuse variables to save stack\\n            require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027ImpossibleLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        }\\n        uint256 amountOut;\\n        uint256 artiLiqTerm;\\n        uint256 amountInPostFee;\\n        bool isXybk;\\n        {\\n            // Avoid stack too deep\\n            uint256 fee;\\n            uint256 balanceIn = IERC20(tokenIn).balanceOf(address(pair));\\n            require(balanceIn \\u003e reserveIn, \\u0027ImpossibleLibrary: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n            (fee, isXybk) = IImpossiblePair(pair).getFeeAndXybk();\\n            amountInPostFee = (balanceIn.sub(reserveIn)).mul(10000 - fee);\\n        }\\n        // If xybk invariant, set reserveIn/reserveOut to artificial liquidity instead of actual liquidity\\n        if (isXybk) {\\n            (uint256 boost0, uint256 boost1) = IImpossiblePair(pair).calcBoost();\\n            uint256 sqrtK = xybkComputeSqrtK(isMatch, reserveIn, reserveOut, boost0, boost1);\\n            // since balance0=balance1 only at sqrtK, if final balanceIn \\u003e= sqrtK means balanceIn \\u003e= balanceOut\\n            // Use post-fee balances to maintain consistency with pair contract K invariant check\\n            if (amountInPostFee.add(reserveIn.mul(10000)) \\u003e= sqrtK.mul(10000)) {\\n                // If tokenIn = token0, balanceIn \\u003e sqrtK =\\u003e balance0\\u003esqrtK, use boost0\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost0 : boost1, sqrtK);\\n                // If balance started from \\u003csqrtK and ended at \\u003esqrtK and boosts are different, there\\u0027ll be different amountIn/Out\\n                // Don\\u0027t need to check in other case for reserveIn \\u003c reserveIn.add(x) \\u003c= sqrtK since that case doesnt cross midpt\\n                if (reserveIn \\u003c sqrtK \\u0026\\u0026 boost0 != boost1) {\\n                    // Break into 2 trades =\\u003e start point -\\u003e midpoint (sqrtK, sqrtK), then midpoint -\\u003e final point\\n                    amountOut = reserveOut.sub(sqrtK);\\n                    amountInPostFee = amountInPostFee.sub(sqrtK.sub(reserveIn));\\n                    reserveOut = sqrtK;\\n                    reserveIn = sqrtK;\\n                }\\n            } else {\\n                // If tokenIn = token0, balanceIn \\u003c sqrtK =\\u003e balance0\\u003csqrtK, use boost0\\n                artiLiqTerm = calcArtiLiquidityTerm(isMatch ? boost1 : boost0, sqrtK);\\n            }\\n        }\\n        uint256 numerator = amountInPostFee.mul(reserveOut.add(artiLiqTerm));\\n        uint256 denominator = (reserveIn.add(artiLiqTerm)).mul(10000).add(amountInPostFee);\\n        uint256 lastSwapAmountOut = numerator / denominator;\\n        amountOut = (lastSwapAmountOut \\u003e reserveOut) ? reserveOut.add(amountOut) : lastSwapAmountOut.add(amountOut);\\n        return isMatch ? (uint256(0), amountOut) : (amountOut, uint256(0));\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027ImpossibleLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i \\u003c path.length - 1; i++) {\\n            amounts[i + 1] = getAmountOut(amounts[i], path[i], path[i + 1], factory);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027ImpossibleLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i \\u003e 0; i--) {\\n            amounts[i - 1] = getAmountIn(amounts[i], path[i - 1], path[i], factory);\\n        }\\n    }\\n\\n    // Computing K from reserve, boosts. Same as in pair function\\n    function xybkComputeSqrtK(\\n        bool isMatch,\\n        uint256 x, // if isMatch, x == token0\\n        uint256 y,\\n        uint256 boost0,\\n        uint256 boost1\\n    ) internal pure returns (uint256) {\\n        uint256 boost = isMatch ? ((x \\u003e y) ? boost0.sub(1) : boost1.sub(1)) : ((y \\u003e x) ? boost0.sub(1) : boost1.sub(1));\\n        uint256 denom = boost.mul(2).add(1); // 1+2*boost\\n        uint256 term = boost.mul(x.add(y)).div(denom.mul(2)); // boost*(x+y)/(2+4*boost)\\n        return Math.sqrt(term**2 + x.mul(y).div(denom)) + term;\\n    }\\n}\\n\"},\"ImpossiblePair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport \\u0027./ImpossibleERC20.sol\\u0027;\\n\\nimport \\u0027./Math.sol\\u0027;\\nimport \\u0027./ReentrancyGuard.sol\\u0027;\\n\\nimport \\u0027./IImpossiblePair.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IImpossibleFactory.sol\\u0027;\\nimport \\u0027./IImpossibleCallee.sol\\u0027;\\n\\ncontract ImpossiblePair is IImpossiblePair, ImpossibleERC20, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n    uint256 private constant FEE = 201; // 1/201=0.4795% fee collected from LP if (feeOn)\\n    uint256 private constant THIRTY_MINS = 600; // 30 mins in 3 second blocks\\n    uint256 private constant ONE_DAY = 28800; // 50 for testing, will be 24*60*60/3 = 28800 in production.\\n    uint256 private constant TWO_WEEKS = 403200; //2 * 7 * 24 * 60 * 60 / 3;\\n\\n    address public override factory;\\n    address public override token0;\\n    address public override token1;\\n    address public override router;\\n\\n    uint128 private reserve0; // Single storage slot\\n    uint128 private reserve1; // Single storage slot\\n\\n    uint256 public kLast;\\n\\n    // Variables for xybk invariant.\\n    uint32 private boost0; // Boost0 applies when pool balance0 \\u003e= balance1 (when token1 is the more expensive token)\\n    uint32 private boost1; // Boost1 applies when pool balance1 \\u003e balance0 (when token0 is the more expensive token)\\n    uint32 private newBoost0;\\n    uint32 private newBoost1;\\n    uint16 private tradeFee; // Tradefee=amt of fees collected per swap denoted in basis points\\n    bool private isXybk;\\n\\n    uint256 public startBlockChange; // Boost linearly interpolates between start/end block when changing\\n    uint256 public endBlockChange; // BSC mines 10m blocks a year. uint32 lasts 400 years before overflowing\\n\\n    uint8 public ratioStart;\\n    uint8 public ratioEnd;\\n\\n    // Delay sets the duration for boost changes over time\\n    uint256 public override delay;\\n\\n    modifier onlyIFRouter() {\\n        require(msg.sender == router, \\u0027IF: FORBIDDEN\\u0027);\\n        _;\\n    }\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == IImpossibleFactory(factory).governance(), \\u0027IF: FORBIDDEN\\u0027); // NOTE: Comment out when running tests to allow calls to makeXybk\\n        _;\\n    }\\n\\n    function getFeeAndXybk() external view override returns (uint256 _tradeFee, bool _isXybk) {\\n        _tradeFee = tradeFee;\\n        _isXybk = isXybk;\\n    }\\n\\n    // Get reserves. No timestamp unlike uni\\n    function getReserves() public view override returns (uint256 _reserve0, uint256 _reserve1) {\\n        _reserve0 = uint256(reserve0);\\n        _reserve1 = uint256(reserve1);\\n    }\\n\\n    // Helper function to get boost values\\n    function getBoost()\\n        internal\\n        view\\n        returns (\\n            uint32 _newBoost0,\\n            uint32 _newBoost1,\\n            uint32 _boost0,\\n            uint32 _boost1\\n        )\\n    {\\n        _newBoost0 = newBoost0;\\n        _newBoost1 = newBoost1;\\n        _boost0 = boost0;\\n        _boost1 = boost1;\\n    }\\n\\n    // Helper function to calculate interpolated boost values. Allows for staircasing change of boost over time. Decimal places rounds down\\n    function linInterpolate(\\n        uint32 oldBst,\\n        uint32 newBst,\\n        uint256 end\\n    ) internal view returns (uint256) {\\n        uint256 start = startBlockChange;\\n        if (newBst \\u003e oldBst) {\\n            // old + diff * (curr-start) / (end-start)\\n            return\\n                uint256(oldBst).add(\\n                    (uint256(newBst).sub(uint256(oldBst))).mul(block.number.sub(start)).div(end.sub(start))\\n                );\\n        } else {\\n            // old - diff * (curr-start) / (end-start)\\n            return\\n                uint256(oldBst).sub(\\n                    (uint256(oldBst).sub(uint256(newBst))).mul(block.number.sub(start)).div(end.sub(start))\\n                );\\n        }\\n    }\\n\\n    // Calculates boost if in the middle of a linear interpolation, else return _newBoosts\\n    function calcBoost() public view override returns (uint256 _boost0, uint256 _boost1) {\\n        uint256 _endBlockChange = endBlockChange;\\n        if (block.number \\u003e= _endBlockChange) {\\n            (uint32 _newBoost0, uint32 _newBoost1, , ) = getBoost();\\n            _boost0 = uint256(_newBoost0);\\n            _boost1 = uint256(_newBoost1);\\n        } else {\\n            (uint32 _newBoost0, uint32 _newBoost1, uint32 _oldBoost0, uint32 _oldBoost1) = getBoost();\\n            _boost0 = linInterpolate(_oldBoost0, _newBoost0, _endBlockChange);\\n            _boost1 = linInterpolate(_oldBoost1, _newBoost1, _endBlockChange);\\n        }\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027IF: TRANSFER_FAILED\\u0027);\\n    }\\n\\n    // Causes pool to use xybk invariant to uni invariant\\n    function makeXybk(\\n        uint8 _ratioStart,\\n        uint8 _ratioEnd,\\n        uint32 _boost0,\\n        uint32 _boost1\\n    ) external onlyGovernance nonReentrant {\\n        require(!isXybk, \\u0027IF: IS_ALREADY_XYBK\\u0027);\\n        require(0 \\u003c= _ratioStart \\u0026\\u0026 _ratioStart \\u003c _ratioEnd \\u0026\\u0026 _ratioEnd \\u003c= 100, \\u0027IF: IF: INVALID_RATIO\\u0027);\\n        require(_boost0 \\u003e= 1 \\u0026\\u0026 _boost1 \\u003e= 1 \\u0026\\u0026 _boost0 \\u003c= 1000000 \\u0026\\u0026 _boost1 \\u003c= 1000000, \\u0027IF: INVALID_BOOST\\u0027);\\n        require(block.number \\u003e= endBlockChange, \\u0027IF: BOOST_ALREADY_CHANGING\\u0027);\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves();\\n        _mintFee(_reserve0, _reserve1);\\n        boost0 = newBoost0;\\n        boost1 = newBoost1;\\n        newBoost0 = _boost0;\\n        newBoost1 = _boost1;\\n        startBlockChange = block.number;\\n        endBlockChange = block.number + delay;\\n        ratioStart = _ratioStart;\\n        ratioEnd = _ratioEnd;\\n        isXybk = true;\\n        emit changeInvariant(isXybk, _ratioStart, _ratioEnd);\\n        emit updatedBoost(boost0, boost1, newBoost0, newBoost1, startBlockChange, endBlockChange);\\n    }\\n\\n    // makeUni requires pool to already be at boost=1. Setting isXybk=false makes efficient uni swaps.\\n    // Removing isXybk state might save gas on xybk swaps. Then, isXybk is a function that returns calcBoost() == (1, 1)\\n    function makeUni() external onlyGovernance nonReentrant {\\n        require(isXybk, \\u0027IF: IS_ALREADY_UNI\\u0027);\\n        require(block.number \\u003e= endBlockChange, \\u0027IF: BOOST_ALREADY_CHANGING\\u0027);\\n        require(newBoost0 == 1 \\u0026\\u0026 newBoost1 == 1, \\u0027IF: INVALID_BOOST\\u0027);\\n        isXybk = false;\\n        boost0 = 1;\\n        boost1 = 1;\\n        ratioStart = 0;\\n        ratioEnd = 100;\\n        emit changeInvariant(isXybk, ratioStart, ratioEnd);\\n    }\\n\\n    function updateTradeFees(uint16 _fee) external onlyGovernance {\\n        require(_fee \\u003c= 1000, \\u0027IF: INVALID_FEE\\u0027); // capped at 10%\\n        emit updatedTradeFees(tradeFee, _fee);\\n        // fee is uint so can\\u0027t be negative\\n        tradeFee = _fee;\\n    }\\n\\n    // Allows delay change. Default is a 1 day delay\\n    // Timelock of 30 minutes is a minimum\\n    function updateDelay(uint256 _delay) external onlyGovernance {\\n        require(_delay \\u003e= THIRTY_MINS \\u0026\\u0026 delay \\u003c= TWO_WEEKS, \\u0027IF: INVALID_DELAY\\u0027);\\n        emit updatedDelay(delay, _delay);\\n        delay = _delay;\\n    }\\n\\n    // Updates lower/upper hardstops for a pool\\n    function updateHardstops(uint8 _ratioStart, uint8 _ratioEnd) external onlyGovernance nonReentrant {\\n        require(isXybk, \\u0027IF: IS_CURRENTLY_UNI\\u0027);\\n        require(0 \\u003c= _ratioStart \\u0026\\u0026 _ratioStart \\u003c _ratioEnd \\u0026\\u0026 _ratioEnd \\u003c= 100, \\u0027IF: INVALID_RATIO\\u0027);\\n        ratioStart = _ratioStart;\\n        ratioEnd = _ratioEnd;\\n        emit updatedHardstops(_ratioStart, _ratioEnd);\\n    }\\n\\n    // Updates boost values. Boost changes over delay number of blocks.\\n    function updateBoost(uint32 _boost0, uint32 _boost1) external onlyGovernance nonReentrant {\\n        require(isXybk, \\u0027IF: IS_CURRENTLY_UNI\\u0027);\\n        require(_boost0 \\u003e= 1 \\u0026\\u0026 _boost1 \\u003e= 1 \\u0026\\u0026 _boost0 \\u003c= 1000000 \\u0026\\u0026 _boost1 \\u003c= 1000000, \\u0027IF: INVALID_BOOST\\u0027);\\n        require(block.number \\u003e= endBlockChange, \\u0027IF: BOOST_ALREADY_CHANGING\\u0027);\\n        boost0 = newBoost0;\\n        boost1 = newBoost1;\\n        newBoost0 = _boost0;\\n        newBoost1 = _boost1;\\n        startBlockChange = block.number;\\n        endBlockChange = block.number + delay;\\n        emit updatedBoost(boost0, boost1, newBoost0, newBoost1, startBlockChange, endBlockChange);\\n    }\\n\\n    constructor() {\\n        factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _router\\n    ) external override {\\n        require(msg.sender == factory, \\u0027IF: FORBIDDEN\\u0027); // sufficient check\\n        router = _router;\\n        token0 = _token0;\\n        token1 = _token1;\\n        boost0 = 1;\\n        boost1 = 1;\\n        newBoost0 = 1;\\n        newBoost1 = 1;\\n        tradeFee = 30; // 30 basis points\\n        delay = ONE_DAY;\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    // PriceCumulativeLast calculations will cost too much gas for Impossibleswap invariant - scrap feature\\n    function _update(uint256 balance0, uint256 balance1) private {\\n        reserve0 = uint128(balance0);\\n        reserve1 = uint128(balance1);\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // if fee is on, mint liquidity equivalent to 4/5th of the growth in sqrt(k)\\n    function _mintFee(uint256 _reserve0, uint256 _reserve1) private returns (bool feeOn) {\\n        address feeTo = IImpossibleFactory(factory).feeTo();\\n        feeOn = feeTo != address(0);\\n        uint256 _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint256 rootK =\\n                    isXybk ? Math.sqrt(_xybkComputeK(_reserve0, _reserve1)) : Math.sqrt(_reserve0.mul(_reserve1));\\n                uint256 rootKLast = Math.sqrt(_kLast);\\n                if (rootK \\u003e rootKLast) {\\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast)).mul(4);\\n                    uint256 denominator = rootK.add(rootKLast.mul(4));\\n                    uint256 liquidity = numerator / denominator;\\n                    if (liquidity \\u003e 0) _mint(feeTo, liquidity);\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    // Unchanged - LP tokens represent proportion of tokens in pool\\n    function mint(address to) external override nonReentrant returns (uint256 liquidity) {\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n        uint256 amount0 = balance0.sub(_reserve0);\\n        uint256 amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\\n        }\\n        require(liquidity \\u003e 0, \\u0027IF: INSUFFICIENT_LIQUIDITY_MINTED\\u0027);\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1);\\n        if (feeOn) kLast = isXybk ? _xybkComputeK(balance0, balance1) : balance0.mul(balance1);\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) external override nonReentrant returns (uint256 amount0, uint256 amount1) {\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        {\\n            // Scope for _totalSupply is only within this block\\n            uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n            amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n            amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n\\n            require(amount0 \\u003e 0 \\u0026\\u0026 amount1 \\u003e 0, \\u0027IF: INSUFFICIENT_LIQUIDITY_BURNED\\u0027);\\n\\n            if (feeOn) {\\n                uint256 _FEE = FEE;\\n                amount0 -= amount0.div(_FEE);\\n                amount1 -= amount1.div(_FEE);\\n                // Sends the 0.4975% Fee of LP tokens to the IImpossibleFactory feeTo Address\\n                _safeTransfer(address(this), IImpossibleFactory(factory).feeTo(), liquidity.div(_FEE));\\n                _burn(address(this), liquidity.sub(liquidity.div(_FEE)));\\n            } else {\\n                _burn(address(this), liquidity);\\n            }\\n\\n            // Outside of this if feeOn statement, returns the appropriate funds to the user\\n            _safeTransfer(_token0, to, amount0);\\n            _safeTransfer(_token1, to, amount1);\\n        }\\n\\n        // Grabs the new balances of the tokens in the LP pool after the withdrawal takes place\\n        {\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n            _update(balance0, balance1);\\n            if (feeOn) kLast = isXybk ? _xybkComputeK(balance0, balance1) : balance0.mul(balance1);\\n        }\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // This swap function can only be called from the Impossible router which has implemented checks\\n    function cheapSwap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external override onlyIFRouter nonReentrant {\\n        if (amount0Out \\u003e 0) _safeTransfer(token0, to, amount0Out); // optimistically transfer tokens\\n        if (amount1Out \\u003e 0) _safeTransfer(token1, to, amount1Out); // optimistically transfer tokens\\n        if (data.length \\u003e 0) IImpossibleCallee(to).ImpossibleCall(msg.sender, amount0Out, amount1Out, data);\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n        if (isXybk) {\\n            bool side = balance0 \\u003e= balance1;\\n            uint256 ratio = side ? ratioStart : ratioEnd;\\n            if (side \\u0026\\u0026 ratio \\u003e 0) {\\n                require(balance1.mul(ratio) \\u003c balance0.mul(100 - ratio), \\u0027IF: EXCEED_UPPER_STOP\\u0027);\\n            } else if (!side \\u0026\\u0026 ratio \\u003c 100) {\\n                require(balance0.mul(ratio) \\u003e balance1.mul(100 - ratio), \\u0027IF: EXCEED_LOWER_STOP\\u0027);\\n            }\\n        }\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        uint256 amount0In = balance0 \\u003e _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint256 amount1In = balance1 \\u003e _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        _update(balance0, balance1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    // Without safety checks, calling swap directly will throw failure at bounds\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external override nonReentrant {\\n        require(amount0Out \\u003e 0 || amount1Out \\u003e 0, \\u0027IF: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        require(amount0Out \\u003c _reserve0 \\u0026\\u0026 amount1Out \\u003c _reserve1, \\u0027IF: INSUFFICIENT_LIQUIDITY\\u0027);\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        uint256 amount0In;\\n        uint256 amount1In;\\n        {\\n            require(to != token0 \\u0026\\u0026 to != token1, \\u0027IF: INVALID_TO\\u0027);\\n            if (amount0Out \\u003e 0) _safeTransfer(token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out \\u003e 0) _safeTransfer(token1, to, amount1Out); // optimistically transfer tokens\\n            if (data.length \\u003e 0) IImpossibleCallee(to).ImpossibleCall(msg.sender, amount0Out, amount1Out, data);\\n            balance0 = IERC20(token0).balanceOf(address(this));\\n            balance1 = IERC20(token1).balanceOf(address(this));\\n            // Check bounds\\n            amount0In = balance0 \\u003e _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n            amount1In = balance1 \\u003e _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        }\\n\\n        require(amount0In \\u003e 0 || amount1In \\u003e 0, \\u0027IF: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n\\n        {\\n            // Avoid stack too deep errors\\n            bool _isXybk = isXybk;\\n            if (_isXybk) {\\n                bool side = balance0 \\u003e= balance1;\\n                uint256 ratio = side ? ratioStart : ratioEnd;\\n                if (side \\u0026\\u0026 ratio \\u003e 0) {\\n                    require(balance1.mul(ratio) \\u003c balance0.mul(100 - ratio), \\u0027IF: EXCEED_UPPER_STOP\\u0027);\\n                } else if (!side \\u0026\\u0026 ratio \\u003c 100) {\\n                    require(balance0.mul(ratio) \\u003e balance1.mul(100 - ratio), \\u0027IF: EXCEED_LOWER_STOP\\u0027);\\n                }\\n            }\\n            uint256 _tradeFee = uint256(tradeFee); // Gas savings?\\n            uint256 balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(_tradeFee)); // tradeFee amt of basis pts\\n            uint256 balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(_tradeFee)); // tradeFee amt of basis pts\\n            _isXybk\\n                ? require(\\n                    _xybkCheckK(balance0Adjusted, balance1Adjusted, _xybkComputeK(_reserve0, _reserve1).mul(10000**2)),\\n                    \\u0027IF: INSUFFICIENT_XYBK_K\\u0027\\n                )\\n                : require(\\n                    balance0Adjusted.mul(balance1Adjusted) \\u003e= _reserve0.mul(_reserve1).mul(10000**2),\\n                    \\u0027IF: INSUFFICIENT_UNI_K\\u0027\\n                );\\n        }\\n\\n        _update(balance0, balance1);\\n\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // Calculating new stableswap invariant K value given balance0, balance1\\n    // Exact calculation of K given token balances. Called after mint/burn/swaps\\n    // let i=(boost-1)*(x+y)/(4*boost-2); sqrtK = sqrt(i**2 + b0*b1/(2*boost-1)) + i\\n    function _xybkComputeK(uint256 _balance0, uint256 _balance1) private view returns (uint256 k) {\\n        (uint256 _boost0, uint256 _boost1) = calcBoost();\\n        uint256 boost = (_balance0 \\u003e _balance1) ? _boost0.sub(1) : _boost1.sub(1);\\n        uint256 denom = boost.mul(2).add(1); // 1+2*boost\\n        uint256 term = boost.mul(_balance0.add(_balance1)).div(denom.mul(2)); // boost*(x+y)/(2+4*boost)\\n        k = (Math.sqrt(term**2 + _balance0.mul(_balance1).div(denom)) + term)**2;\\n    }\\n\\n    // Calculating new stableswap invariant K given balance0, balance1, old K\\n    // Called to check K invariance post-swap\\n    // let i=(boost-1)*sqrt(K_old); K_new = (b0+i)*(b1+i)/(boost**2)\\n    // If K_new \\u003e K_old, this check still maintains correctness\\n    function _xybkCheckK(\\n        uint256 _balance0,\\n        uint256 _balance1,\\n        uint256 _oldK\\n    ) private view returns (bool) {\\n        uint256 sqrtOldK = Math.sqrt(_oldK);\\n        (uint256 _boost0, uint256 _boost1) = calcBoost();\\n        uint256 boost = (_balance0 \\u003e _balance1) ? _boost0.sub(1) : _boost1.sub(1);\\n        uint256 innerTerm = boost.mul(sqrtOldK);\\n        return (_balance0.add(innerTerm)).mul(_balance1.add(innerTerm)).div((boost.add(1))**2) \\u003e= _oldK;\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external override nonReentrant {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves();\\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(_reserve0));\\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(_reserve1));\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external override nonReentrant {\\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\\n        _update(_balance0, _balance1);\\n    }\\n}\\n\"},\"ImpossibleRouter01.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\nimport \\u0027./IImpossiblePair.sol\\u0027;\\nimport \\u0027./IImpossibleFactory.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\n\\nimport \\u0027./ImpossibleLibrary.sol\\u0027;\\nimport \\u0027./IImpossibleRouter01.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IWETH.sol\\u0027;\\n\\ncontract ImpossibleRouter01 is IImpossibleRouter01 {\\n    address public immutable override factory;\\n    address public immutable override WETH;\\n    uint8 private locked;\\n\\n    modifier lock() {\\n        require(locked == 0, \\u0027IF: LOCKED\\u0027);\\n        locked = 1;\\n        _;\\n        locked = 0;\\n    }\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline \\u003e= block.timestamp, \\u0027ImpossibleRouter: EXPIRED\\u0027);\\n        _;\\n    }\\n\\n    constructor(address _factory, address _WETH) {\\n        factory = _factory;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    // Unchanged from uni\\n    // **** ADD LIQUIDITY ****\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) private returns (uint256 amountA, uint256 amountB) {\\n        // create the pair if it doesn\\u0027t exist yet\\n        if (IImpossibleFactory(factory).getPair(tokenA, tokenB) == address(0)) {\\n            IImpossibleFactory(factory).createPair(tokenA, tokenB);\\n        }\\n        (uint256 reserveA, uint256 reserveB, ) = ImpossibleLibrary.getReserves(factory, tokenA, tokenB);\\n        if (reserveA == 0 \\u0026\\u0026 reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint256 amountBOptimal = ImpossibleLibrary.quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal \\u003c= amountBDesired) {\\n                require(amountBOptimal \\u003e= amountBMin, \\u0027ImpossibleRouter: INSUFFICIENT_B_AMOUNT\\u0027);\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = ImpossibleLibrary.quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal \\u003c= amountADesired);\\n                require(amountAOptimal \\u003e= amountAMin, \\u0027ImpossibleRouter: INSUFFICIENT_A_AMOUNT\\u0027);\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    // Unchanged from uni\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        override\\n        ensure(deadline)\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n        liquidity = IImpossiblePair(pair).mint(to);\\n    }\\n\\n    // Unchanged from uni\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        override\\n        ensure(deadline)\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountToken, amountETH) = _addLiquidity(\\n            token,\\n            WETH,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(pair, amountETH));\\n        liquidity = IImpossiblePair(pair).mint(to);\\n        if (msg.value \\u003e amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any\\n    }\\n\\n    // Unchanged from uni\\n    // **** REMOVE LIQUIDITY ****\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) public override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        IImpossiblePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint256 amount0, uint256 amount1) = IImpossiblePair(pair).burn(to);\\n        (address token0, ) = ImpossibleLibrary.sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA \\u003e= amountAMin, \\u0027ImpossibleRouter: INSUFFICIENT_A_AMOUNT\\u0027);\\n        require(amountB \\u003e= amountBMin, \\u0027ImpossibleRouter: INSUFFICIENT_B_AMOUNT\\u0027);\\n    }\\n\\n    // Unchanged from uni\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) public override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\\n        (amountToken, amountETH) = removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, amountToken);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    // Unchanged from uni\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override returns (uint256 amountA, uint256 amountB) {\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\\n    }\\n\\n    // Unchanged from uni\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override returns (uint256 amountToken, uint256 amountETH) {\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\\n    }\\n\\n    // Unchanged from uni\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(\\n        uint256[] memory amounts,\\n        address[] memory path,\\n        address _to\\n    ) private {\\n        for (uint256 i; i \\u003c path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0, ) = ImpossibleLibrary.sortTokens(input, output);\\n            uint256 amountOut = amounts[i + 1];\\n            (uint256 amount0Out, uint256 amount1Out) =\\n                input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\\n            address to = i \\u003c path.length - 2 ? ImpossibleLibrary.pairFor(factory, output, path[i + 2]) : _to;\\n            IImpossiblePair(ImpossibleLibrary.pairFor(factory, input, output)).cheapSwap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    // Unchanged from uni (but getAmountsOut calculates uni/xybk invariant)\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external override ensure(deadline) lock returns (uint256[] memory amounts) {\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n\\n    // Unchanged from uni (but getAmountsIn calculates uni/xybk invariant)\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external override ensure(deadline) lock returns (uint256[] memory amounts) {\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= amountInMax, \\u0027ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n\\n    // Unchanged from uni (but getAmountsOut calculates uni/xybk invariant)\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable override ensure(deadline) lock returns (uint256[] memory amounts) {\\n        require(path[0] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, msg.value, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to);\\n    }\\n\\n    // Unchanged from uni (but getAmountsIn calculates uni/xybk invariant)\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external override ensure(deadline) lock returns (uint256[] memory amounts) {\\n        require(path[path.length - 1] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= amountInMax, \\u0027ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    // Unchanged from uni (but getAmountsOut calculates uni/xybk invariant)\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external override ensure(deadline) lock returns (uint256[] memory amounts) {\\n        require(path[path.length - 1] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    // Unchanged from uni (but getAmountsIn calculates uni/xybk invariant)\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable override ensure(deadline) lock returns (uint256[] memory amounts) {\\n        require(path[0] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= msg.value, \\u0027ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to);\\n        if (msg.value \\u003e amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any\\n    }\\n\\n    // Unchanged from uni\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure override returns (uint256 amountB) {\\n        return ImpossibleLibrary.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view override returns (uint256) {\\n        return ImpossibleLibrary.getAmountOut(amountIn, tokenIn, tokenOut, factory);\\n    }\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view override returns (uint256) {\\n        return ImpossibleLibrary.getAmountIn(amountOut, tokenIn, tokenOut, factory);\\n    }\\n\\n    // Unchanged from uni\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n    }\\n\\n    // Unchanged from uni\\n    function getAmountsIn(uint256 amountOut, address[] memory path)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n    }\\n}\\n\"},\"ImpossibleRouter02.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\u0027./IImpossibleFactory.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\nimport \\u0027./ReentrancyGuard.sol\\u0027;\\n\\nimport \\u0027./IImpossibleRouter02.sol\\u0027;\\nimport \\u0027./ImpossibleLibrary.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IWETH.sol\\u0027;\\n\\ncontract ImpossibleRouter02 is IImpossibleRouter02, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    address public immutable override factory;\\n    address public immutable override WETH;\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline \\u003e= block.timestamp, \\u0027ImpossibleRouter: EXPIRED\\u0027);\\n        _;\\n    }\\n\\n    constructor(address _factory, address _WETH) {\\n        factory = _factory;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    // Unchanged from uni\\n    // **** ADD LIQUIDITY ****\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\\n        // create the pair if it doesn\\u0027t exist yet\\n        if (IImpossibleFactory(factory).getPair(tokenA, tokenB) == address(0)) {\\n            IImpossibleFactory(factory).createPair(tokenA, tokenB);\\n        }\\n        (uint256 reserveA, uint256 reserveB, ) = ImpossibleLibrary.getReserves(factory, tokenA, tokenB);\\n        if (reserveA == 0 \\u0026\\u0026 reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint256 amountBOptimal = ImpossibleLibrary.quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal \\u003c= amountBDesired) {\\n                require(amountBOptimal \\u003e= amountBMin, \\u0027ImpossibleRouter: INSUFFICIENT_B_AMOUNT\\u0027);\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = ImpossibleLibrary.quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal \\u003c= amountADesired);\\n                require(amountAOptimal \\u003e= amountAMin, \\u0027ImpossibleRouter: INSUFFICIENT_A_AMOUNT\\u0027);\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    // Unchanged from uni\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        nonReentrant\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n        liquidity = IImpossiblePair(pair).mint(to);\\n    }\\n\\n    // Unchanged from uni\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        nonReentrant\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountToken, amountETH) = _addLiquidity(\\n            token,\\n            WETH,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(pair, amountETH));\\n        liquidity = IImpossiblePair(pair).mint(to);\\n        if (msg.value \\u003e amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any\\n    }\\n\\n    // Unchanged from uni\\n    // **** REMOVE LIQUIDITY ****\\n    function _removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) private ensure(deadline) returns (uint256 amountA, uint256 amountB) {\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        IImpossiblePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint256 amount0, uint256 amount1) = IImpossiblePair(pair).burn(to);\\n        (address token0, ) = ImpossibleLibrary.sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA \\u003e= amountAMin, \\u0027ImpossibleRouter: INSUFFICIENT_A_AMOUNT\\u0027);\\n        require(amountB \\u003e= amountBMin, \\u0027ImpossibleRouter: INSUFFICIENT_B_AMOUNT\\u0027);\\n    }\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) public virtual override ensure(deadline) nonReentrant returns (uint256 amountA, uint256 amountB) {\\n        return _removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\\n    }\\n\\n    // Unchanged from uni\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) public virtual override ensure(deadline) nonReentrant returns (uint256 amountToken, uint256 amountETH) {\\n        (amountToken, amountETH) = _removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, amountToken);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    // Unchanged from uni\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override nonReentrant returns (uint256 amountA, uint256 amountB) {\\n        address pair = ImpossibleLibrary.pairFor(factory, tokenA, tokenB);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountA, amountB) = _removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\\n    }\\n\\n    // Unchanged from uni\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\\n    }\\n\\n    // Unchanged from uni\\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) public virtual override ensure(deadline) nonReentrant returns (uint256 amountETH) {\\n        (, amountETH) = _removeLiquidity(token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);\\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    // Unchanged from uni\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override returns (uint256 amountETH) {\\n        address pair = ImpossibleLibrary.pairFor(factory, token, WETH);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IImpossiblePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n            token,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            to,\\n            deadline\\n        );\\n    }\\n\\n    // Unchanged from uni\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(\\n        uint256[] memory amounts,\\n        address[] memory path,\\n        address _to\\n    ) internal virtual {\\n        for (uint256 i; i \\u003c path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0, ) = ImpossibleLibrary.sortTokens(input, output);\\n            uint256 amountOut = amounts[i + 1];\\n            (uint256 amount0Out, uint256 amount1Out) =\\n                input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\\n            address to = i \\u003c path.length - 2 ? ImpossibleLibrary.pairFor(factory, output, path[i + 2]) : _to;\\n            IImpossiblePair(ImpossibleLibrary.pairFor(factory, input, output)).cheapSwap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    // Unchanged from uni (but getAmountsOut calculates uni/xybk invariant)\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n\\n    // Unchanged from uni (but getAmountsIn calculates uni/xybk invariant)\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= amountInMax, \\u0027ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n\\n    // Unchanged from uni (but getAmountsOut calculates uni/xybk invariant)\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[0] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, msg.value, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to);\\n    }\\n\\n    // Unchanged from uni (but getAmountsIn calculates uni/xybk invariant)\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[path.length - 1] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= amountInMax, \\u0027ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    // Unchanged from uni (but getAmountsOut calculates uni/xybk invariant)\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[path.length - 1] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    // Unchanged from uni (but getAmountsIn calculates uni/xybk invariant)\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable virtual override ensure(deadline) nonReentrant returns (uint256[] memory amounts) {\\n        require(path[0] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        amounts = ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= msg.value, \\u0027ImpossibleRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to);\\n        // refund dust eth, if any\\n        if (msg.value \\u003e amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    // Changed from uni router02. Most of the logic sits in library.getAmountOutFeeOnTransfer()\\n    // **** SWAP (supporting fee-on-transfer tokens) ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\\n        for (uint256 i; i \\u003c path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (uint256 amount0Out, uint256 amount1Out) =\\n                ImpossibleLibrary.getAmountOutFeeOnTransfer(input, output, factory);\\n            address to = i \\u003c path.length - 2 ? ImpossibleLibrary.pairFor(factory, output, path[i + 2]) : _to;\\n            IImpossiblePair(ImpossibleLibrary.pairFor(factory, input, output)).cheapSwap(\\n                amount0Out,\\n                amount1Out,\\n                to,\\n                new bytes(0)\\n            );\\n        }\\n    }\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant {\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amountIn\\n        );\\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n        _swapSupportingFeeOnTransferTokens(path, to);\\n        require(\\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) \\u003e= amountOutMin,\\n            \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027\\n        );\\n    }\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable virtual override ensure(deadline) nonReentrant {\\n        require(path[0] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        uint256 amountIn = msg.value;\\n        IWETH(WETH).deposit{value: amountIn}();\\n        assert(IWETH(WETH).transfer(ImpossibleLibrary.pairFor(factory, path[0], path[1]), amountIn));\\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n        _swapSupportingFeeOnTransferTokens(path, to);\\n        require(\\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) \\u003e= amountOutMin,\\n            \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027\\n        );\\n    }\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) nonReentrant {\\n        require(path[path.length - 1] == WETH, \\u0027ImpossibleRouter: INVALID_PATH\\u0027);\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            ImpossibleLibrary.pairFor(factory, path[0], path[1]),\\n            amountIn\\n        );\\n        _swapSupportingFeeOnTransferTokens(path, address(this));\\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\\n        require(amountOut \\u003e= amountOutMin, \\u0027ImpossibleRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(to, amountOut);\\n    }\\n\\n    // **** LIBRARY FUNCTIONS ****\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure virtual override returns (uint256 amountB) {\\n        return ImpossibleLibrary.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view override returns (uint256) {\\n        return ImpossibleLibrary.getAmountOut(amountIn, tokenIn, tokenOut, factory);\\n    }\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        address tokenIn,\\n        address tokenOut\\n    ) external view override returns (uint256) {\\n        return ImpossibleLibrary.getAmountIn(amountOut, tokenIn, tokenOut, factory);\\n    }\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return ImpossibleLibrary.getAmountsOut(factory, amountIn, path);\\n    }\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return ImpossibleLibrary.getAmountsIn(factory, amountOut, path);\\n    }\\n}\\n\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x \\u003c y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\u0027ReentrancyGuard: reentrant call\\u0027);\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3\\npragma solidity =0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) \\u003e= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) \\u003c= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n}\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isXybk\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ratioStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ratioEnd\",\"type\":\"uint256\"}],\"name\":\"changeInvariant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_prevBoost0\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_prevBoost1\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_newBoost0\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_newBoost1\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"updatedBoost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newDelay\",\"type\":\"uint256\"}],\"name\":\"updatedDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_ratioStart\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_ratioEnd\",\"type\":\"uint8\"}],\"name\":\"updatedHardstops\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prevFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"updatedTradeFees\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_boost0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_boost1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"cheapSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBlockChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeAndXybk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tradeFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isXybk\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserve1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeUni\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ratioStart\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_ratioEnd\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_boost0\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_boost1\",\"type\":\"uint32\"}],\"name\":\"makeXybk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ratioEnd\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ratioStart\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlockChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_boost0\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_boost1\",\"type\":\"uint32\"}],\"name\":\"updateBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"updateDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ratioStart\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_ratioEnd\",\"type\":\"uint8\"}],\"name\":\"updateHardstops\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"updateTradeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ImpossiblePair", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cd2f83748d805f46c0fa4141e5ae7345e975521eaa3a514af5c5c546f36ec3cc"}