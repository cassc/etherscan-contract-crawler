{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/implementations/RMRKCatalogImpl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"../RMRK/access/OwnableLock.sol\\\";\\nimport \\\"../RMRK/catalog/RMRKCatalog.sol\\\";\\n\\n/**\\n * @title RMRKCatalogImpl\\n * @author RMRK team\\n * @notice Implementation of RMRK catalog.\\n * @dev Contract for storing 'catalog' elements of NFTs to be accessed by instances of RMRKAsset implementing contracts.\\n *  This default implementation includes an OwnableLock dependency, which allows the deployer to freeze the state of the\\n *  catalog contract.\\n */\\ncontract RMRKCatalogImpl is OwnableLock, RMRKCatalog {\\n    /**\\n     * @notice Used to initialize the smart contract.\\n     * @param metadataURI Base metadata URI of the contract\\n     * @param type_ The type of the catalog\\n     */\\n    constructor(\\n        string memory metadataURI,\\n        string memory type_\\n    ) RMRKCatalog(metadataURI, type_) {}\\n\\n    /**\\n     * @notice Used to add a single `Part` to storage.\\n     * @dev The full `IntakeStruct` looks like this:\\n     *  [\\n     *          partID,\\n     *      [\\n     *          itemType,\\n     *          z,\\n     *          [\\n     *               permittedCollectionAddress0,\\n     *               permittedCollectionAddress1,\\n     *               permittedCollectionAddress2\\n     *           ],\\n     *           metadataURI\\n     *       ]\\n     *   ]\\n     * @param intakeStruct `IntakeStruct` struct consisting of `partId` and a nested `Part` struct\\n     */\\n    function addPart(\\n        IntakeStruct calldata intakeStruct\\n    ) public virtual onlyOwnerOrContributor notLocked {\\n        _addPart(intakeStruct);\\n    }\\n\\n    /**\\n     * @notice Used to add multiple `Part`s to storage.\\n     * @dev The full `IntakeStruct` looks like this:\\n     *  [\\n     *          partID,\\n     *      [\\n     *          itemType,\\n     *          z,\\n     *          [\\n     *               permittedCollectionAddress0,\\n     *               permittedCollectionAddress1,\\n     *               permittedCollectionAddress2\\n     *           ],\\n     *           metadataURI\\n     *       ]\\n     *   ]\\n     * @param intakeStructs[] An array of `IntakeStruct` structs consisting of `partId` and a nested `Part` struct\\n     */\\n    function addPartList(\\n        IntakeStruct[] calldata intakeStructs\\n    ) public virtual onlyOwnerOrContributor notLocked {\\n        _addPartList(intakeStructs);\\n    }\\n\\n    /**\\n     * @notice Used to add multiple `equippableAddresses` to a single catalog entry.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @param partId ID of the `Part` that we are adding the equippable addresses to\\n     * @param equippableAddresses An array of addresses that can be equipped into the `Part` associated with the `partId`\\n     */\\n    function addEquippableAddresses(\\n        uint64 partId,\\n        address[] calldata equippableAddresses\\n    ) public virtual onlyOwnerOrContributor {\\n        _addEquippableAddresses(partId, equippableAddresses);\\n    }\\n\\n    /**\\n     * @notice Function used to set the new list of `equippableAddresses`.\\n     * @dev Overwrites existing `equippableAddresses`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @param partId ID of the `Part`s that we are overwiting the `equippableAddresses` for\\n     * @param equippableAddresses A full array of addresses that can be equipped into this `Part`\\n     */\\n    function setEquippableAddresses(\\n        uint64 partId,\\n        address[] calldata equippableAddresses\\n    ) public virtual onlyOwnerOrContributor {\\n        _setEquippableAddresses(partId, equippableAddresses);\\n    }\\n\\n    /**\\n     * @notice Sets the isEquippableToAll flag to true, meaning that any collection may be equipped into the `Part` with\\n     *  this `partId`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @param partId ID of the `Part` that we are setting as equippable by any address\\n     */\\n    function setEquippableToAll(\\n        uint64 partId\\n    ) public virtual onlyOwnerOrContributor {\\n        _setEquippableToAll(partId);\\n    }\\n\\n    /**\\n     * @notice Used to remove all of the `equippableAddresses` for a `Part` associated with the `partId`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @param partId ID of the part that we are clearing the `equippableAddresses` from\\n     */\\n    function resetEquippableAddresses(\\n        uint64 partId\\n    ) public virtual onlyOwnerOrContributor {\\n        _resetEquippableAddresses(partId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"../library/RMRKErrors.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @author RMRK team\\n * @notice A minimal ownable smart contractf or owner and contributors.\\n * @dev This smart contract is based on \\\"openzeppelin's access/Ownable.sol\\\".\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n    mapping(address => uint256) private _contributors;\\n\\n    /**\\n     * @notice Used to anounce the transfer of ownership.\\n     * @param previousOwner Address of the account that transferred their ownership role\\n     * @param newOwner Address of the account receiving the ownership role\\n     */\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @notice Event that signifies that an address was granted contributor role or that the permission has been\\n     *  revoked.\\n     * @dev This can only be triggered by a current owner, so there is no need to include that information in the event.\\n     * @param contributor Address of the account that had contributor role status updated\\n     * @param isContributor A boolean value signifying whether the role has been granted (`true`) or revoked (`false`)\\n     */\\n    event ContributorUpdate(address indexed contributor, bool isContributor);\\n\\n    /**\\n     * @dev Reverts if called by any account other than the owner or an approved contributor.\\n     */\\n    modifier onlyOwnerOrContributor() {\\n        _onlyOwnerOrContributor();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract by setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     * @return Address of the current owner\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without owner. Functions using the `onlyOwner` modifier will be disabled.\\n     * @dev Can only be called by the current owner.\\n     * @dev Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is\\n     *  only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new owner.\\n     * @dev Can only be called by the current owner.\\n     * @param newOwner Address of the new owner's account\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert RMRKNewOwnerIsZeroAddress();\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new owner.\\n     * @dev Internal function without access restriction.\\n     * @dev Emits ***OwnershipTransferred*** event.\\n     * @param newOwner Address of the new owner's account\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @notice Adds or removes a contributor to the smart contract.\\n     * @dev Can only be called by the owner.\\n     * @dev Emits ***ContributorUpdate*** event.\\n     * @param contributor Address of the contributor's account\\n     * @param grantRole A boolean value signifying whether the contributor role is being granted (`true`) or revoked\\n     *  (`false`)\\n     */\\n    function manageContributor(\\n        address contributor,\\n        bool grantRole\\n    ) external onlyOwner {\\n        if (contributor == address(0)) revert RMRKNewContributorIsZeroAddress();\\n        grantRole\\n            ? _contributors[contributor] = 1\\n            : _contributors[contributor] = 0;\\n        emit ContributorUpdate(contributor, grantRole);\\n    }\\n\\n    /**\\n     * @notice Used to check if the address is one of the contributors.\\n     * @param contributor Address of the contributor whose status we are checking\\n     * @return Boolean value indicating whether the address is a contributor or not\\n     */\\n    function isContributor(address contributor) public view returns (bool) {\\n        return _contributors[contributor] == 1;\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is either the owner or a contributor.\\n     * @dev If the caller is not the owner or a contributor, the execution will be reverted.\\n     */\\n    function _onlyOwnerOrContributor() private view {\\n        if (owner() != _msgSender() && !isContributor(_msgSender()))\\n            revert RMRKNotOwnerOrContributor();\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is the owner.\\n     * @dev If the caller is not the owner, the execution will be reverted.\\n     */\\n    function _onlyOwner() private view {\\n        if (owner() != _msgSender()) revert RMRKNotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/access/OwnableLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"../library/RMRKErrors.sol\\\";\\n\\n/**\\n * @title OwnableLock\\n * @author RMRK team\\n * @notice A minimal ownable lock smart contract.\\n */\\ncontract OwnableLock is Ownable {\\n    uint256 private _lock;\\n\\n    /**\\n     * @notice Emitted when the smart contract is locked.\\n     */\\n    event LockSet();\\n\\n    /**\\n     * @notice Reverts if the lock flag is set to true.\\n     */\\n    modifier notLocked() {\\n        _onlyNotLocked();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Locks the operation.\\n     * @dev Once locked, functions using `notLocked` modifier cannot be executed.\\n     * @dev Emits ***LockSet*** event.\\n     */\\n    function setLock() public virtual onlyOwner {\\n        _lock = 1;\\n        emit LockSet();\\n    }\\n\\n    /**\\n     * @notice Used to retrieve the status of a lockable smart contract.\\n     * @return A boolean value signifying whether the smart contract has been locked\\n     */\\n    function getLock() public view returns (bool) {\\n        return _lock == 1;\\n    }\\n\\n    /**\\n     * @notice Used to verify that the operation of the smart contract is not locked.\\n     * @dev If the operation of the smart contract is locked, the execution will be reverted.\\n     */\\n    function _onlyNotLocked() private view {\\n        if (_lock == 1) revert RMRKLocked();\\n    }\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/catalog/IRMRKCatalog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IRMRKCatalog\\n * @author RMRK team\\n * @notice An interface Catalog for RMRK equippable module.\\n */\\ninterface IRMRKCatalog is IERC165 {\\n    /**\\n     * @notice Event to announce addition of a new part.\\n     * @dev It is emitted when a new part is added.\\n     * @param partId ID of the part that was added\\n     * @param itemType Enum value specifying whether the part is `None`, `Slot` and `Fixed`\\n     * @param zIndex An uint specifying the z value of the part. It is used to specify the depth which the part should\\n     *  be rendered at\\n     * @param equippableAddresses An array of addresses that can equip this part\\n     * @param metadataURI The metadata URI of the part\\n     */\\n    event AddedPart(\\n        uint64 indexed partId,\\n        ItemType indexed itemType,\\n        uint8 zIndex,\\n        address[] equippableAddresses,\\n        string metadataURI\\n    );\\n\\n    /**\\n     * @notice Event to announce new equippables to the part.\\n     * @dev It is emitted when new addresses are marked as equippable for `partId`.\\n     * @param partId ID of the part that had new equippable addresses added\\n     * @param equippableAddresses An array of the new addresses that can equip this part\\n     */\\n    event AddedEquippables(\\n        uint64 indexed partId,\\n        address[] equippableAddresses\\n    );\\n\\n    /**\\n     * @notice Event to announce the overriding of equippable addresses of the part.\\n     * @dev It is emitted when the existing list of addresses marked as equippable for `partId` is overwritten by a new one.\\n     * @param partId ID of the part whose list of equippable addresses was overwritten\\n     * @param equippableAddresses The new, full, list of addresses that can equip this part\\n     */\\n    event SetEquippables(uint64 indexed partId, address[] equippableAddresses);\\n\\n    /**\\n     * @notice Event to announce that a given part can be equipped by any address.\\n     * @dev It is emitted when a given part is marked as equippable by any.\\n     * @param partId ID of the part marked as equippable by any address\\n     */\\n    event SetEquippableToAll(uint64 indexed partId);\\n\\n    /**\\n     * @notice Used to define a type of the item. Possible values are `None`, `Slot` or `Fixed`.\\n     * @dev Used for fixed and slot parts.\\n     */\\n    enum ItemType {\\n        None,\\n        Slot,\\n        Fixed\\n    }\\n\\n    /**\\n     * @notice The integral structure of a standard RMRK catalog item defining it.\\n     * @dev Requires a minimum of 3 storage slots per catalog item, equivalent to roughly 60,000 gas as of Berlin hard\\n     *  fork (April 14, 2021), though 5-7 storage slots is more realistic, given the standard length of an IPFS URI.\\n     *  This will result in between 25,000,000 and 35,000,000 gas per 250 assets--the maximum block size of Ethereum\\n     *  mainnet is 30M at peak usage.\\n     * @return itemType The item type of the part\\n     * @return z The z value of the part defining how it should be rendered when presenting the full NFT\\n     * @return equippable The array of addresses allowed to be equipped in this part\\n     * @return metadataURI The metadata URI of the part\\n     */\\n    struct Part {\\n        ItemType itemType; //1 byte\\n        uint8 z; //1 byte\\n        address[] equippable; //n Collections that can be equipped into this slot\\n        string metadataURI; //n bytes 32+\\n    }\\n\\n    /**\\n     * @notice The structure used to add a new `Part`.\\n     * @dev The part is added with specified ID, so you have to make sure that you are using an unused `partId`,\\n     *  otherwise the addition of the part vill be reverted.\\n     * @dev The full `IntakeStruct` looks like this:\\n     *  [\\n     *          partID,\\n     *      [\\n     *          itemType,\\n     *          z,\\n     *          [\\n     *               permittedCollectionAddress0,\\n     *               permittedCollectionAddress1,\\n     *               permittedCollectionAddress2\\n     *           ],\\n     *           metadataURI\\n     *       ]\\n     *   ]\\n     * @return partId ID to be assigned to the `Part`\\n     * @return part A `Part` to be added\\n     */\\n    struct IntakeStruct {\\n        uint64 partId;\\n        Part part;\\n    }\\n\\n    /**\\n     * @notice Used to return the metadata URI of the associated Catalog.\\n     * @return Catalog metadata URI\\n     */\\n    function getMetadataURI() external view returns (string memory);\\n\\n    /**\\n     * @notice Used to return the `itemType` of the associated Catalog\\n     * @return `itemType` of the associated Catalog\\n     */\\n    function getType() external view returns (string memory);\\n\\n    /**\\n     * @notice Used to check whether the given address is allowed to equip the desired `Part`.\\n     * @dev Returns true if a collection may equip asset with `partId`.\\n     * @param partId The ID of the part that we are checking\\n     * @param targetAddress The address that we are checking for whether the part can be equipped into it or not\\n     * @return The status indicating whether the `targetAddress` can be equipped into `Part` with `partId` or not\\n     */\\n    function checkIsEquippable(\\n        uint64 partId,\\n        address targetAddress\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Used to check if the part is equippable by all addresses.\\n     * @dev Returns true if part is equippable to all.\\n     * @param partId ID of the part that we are checking\\n     * @return The status indicating whether the part with `partId` can be equipped by any address or not\\n     */\\n    function checkIsEquippableToAll(uint64 partId) external view returns (bool);\\n\\n    /**\\n     * @notice Used to retrieve a `Part` with id `partId`\\n     * @param partId ID of the part that we are retrieving\\n     * @return The `Part` struct associated with given `partId`\\n     */\\n    function getPart(uint64 partId) external view returns (Part memory);\\n\\n    /**\\n     * @notice Used to retrieve multiple parts at the same time.\\n     * @param partIds An array of part IDs that we want to retrieve\\n     * @return An array of `Part` structs associated with given `partIds`\\n     */\\n    function getParts(\\n        uint64[] memory partIds\\n    ) external view returns (Part[] memory);\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/catalog/RMRKCatalog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"./IRMRKCatalog.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../library/RMRKErrors.sol\\\";\\n\\n/**\\n * @title RMRKCatalog\\n * @author RMRK team\\n * @notice Catalog contract for RMRK equippable module.\\n */\\ncontract RMRKCatalog is IRMRKCatalog {\\n    using Address for address;\\n\\n    /**\\n     * @notice Mapping of uint64 `partId` to IRMRKCatalog `Part` struct\\n     */\\n    mapping(uint64 => Part) private _parts;\\n\\n    /**\\n     * @notice Mapping of uint64 `partId` to boolean flag, indicating that a given `Part` can be equippable by any\\n     *  address\\n     */\\n    mapping(uint64 => bool) private _isEquippableToAll;\\n\\n    uint64[] private _partIds;\\n\\n    string private _metadataURI;\\n    string private _type;\\n\\n    /**\\n     * @notice Used to initialize the Catalog.\\n     * @param metadataURI Base metadata URI of the Catalog\\n     * @param type_ Type of Catalog\\n     */\\n    constructor(string memory metadataURI, string memory type_) {\\n        _setMetadataURI(metadataURI);\\n        _setType(type_);\\n    }\\n\\n    /**\\n     * @notice Used to limit execution of functions intended for the `Slot` parts to only execute when used with such\\n     *  parts.\\n     * @dev Reverts execution of a function if the part with associated `partId` is uninitailized or is `Fixed`.\\n     * @param partId ID of the part that we want the function to interact with\\n     */\\n    modifier onlySlot(uint64 partId) {\\n        _onlySlot(partId);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Used to verify that an operation is only executed on slot Parts.\\n     * @dev If the Part is not Slot type, the execution will be reverted.\\n     * @param partId ID of the part to check\\n     */\\n    function _onlySlot(uint64 partId) private view {\\n        ItemType itemType = _parts[partId].itemType;\\n        if (itemType == ItemType.None) revert RMRKPartDoesNotExist();\\n        if (itemType == ItemType.Fixed) revert RMRKPartIsNotSlot();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual returns (bool) {\\n        return\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IRMRKCatalog).interfaceId;\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getMetadataURI() external view returns (string memory) {\\n        return _metadataURI;\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getType() external view returns (string memory) {\\n        return _type;\\n    }\\n\\n    /**\\n     * @notice Internal helper function that sets the base metadata URI of the contract.\\n     * @param metadataURI Base metadata URI of the contract\\n     */\\n    function _setMetadataURI(string memory metadataURI) internal {\\n        _metadataURI = metadataURI;\\n    }\\n\\n    /**\\n     * @notice Internal helper function that sets the type of the contract.\\n     * @param type_ Type of the contract\\n     */\\n    function _setType(string memory type_) internal {\\n        _type = type_;\\n    }\\n\\n    /**\\n     * @notice Internal helper function that adds `Part` entries to storage.\\n     * @dev Delegates to { _addPart } below.\\n     * @param partIntake An array of `IntakeStruct` structs, consisting of `partId` and a nested `Part` struct\\n     */\\n    function _addPartList(IntakeStruct[] calldata partIntake) internal {\\n        uint256 len = partIntake.length;\\n        for (uint256 i; i < len; ) {\\n            _addPart(partIntake[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function that adds a single `Part` to storage.\\n     * @param partIntake `IntakeStruct` struct consisting of `partId` and a nested `Part` struct\\n     *\\n     */\\n    function _addPart(IntakeStruct calldata partIntake) internal {\\n        uint64 partId = partIntake.partId;\\n        Part memory part = partIntake.part;\\n\\n        if (partId == uint64(0)) revert RMRKIdZeroForbidden();\\n        if (_parts[partId].itemType != ItemType.None)\\n            revert RMRKPartAlreadyExists();\\n        if (part.itemType == ItemType.None) revert RMRKBadConfig();\\n        if (part.itemType == ItemType.Fixed && part.equippable.length != 0)\\n            revert RMRKBadConfig();\\n\\n        _parts[partId] = part;\\n        _partIds.push(partId);\\n\\n        emit AddedPart(\\n            partId,\\n            part.itemType,\\n            part.z,\\n            part.equippable,\\n            part.metadataURI\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal function used to add multiple `equippableAddresses` to a single catalog entry.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***AddedEquippables*** event.\\n     * @param partId ID of the `Part` that we are adding the equippable addresses to\\n     * @param equippableAddresses An array of addresses that can be equipped into the `Part` associated with the `partId`\\n     */\\n    function _addEquippableAddresses(\\n        uint64 partId,\\n        address[] calldata equippableAddresses\\n    ) internal onlySlot(partId) {\\n        if (equippableAddresses.length <= 0) revert RMRKZeroLengthIdsPassed();\\n\\n        uint256 len = equippableAddresses.length;\\n        for (uint256 i; i < len; ) {\\n            _parts[partId].equippable.push(equippableAddresses[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        delete _isEquippableToAll[partId];\\n\\n        emit AddedEquippables(partId, equippableAddresses);\\n    }\\n\\n    /**\\n     * @notice Internal function used to set the new list of `equippableAddresses`.\\n     * @dev Overwrites existing `equippableAddresses`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***SetEquippable*** event.\\n     * @param partId ID of the `Part`s that we are overwiting the `equippableAddresses` for\\n     * @param equippableAddresses A full array of addresses that can be equipped into this `Part`\\n     */\\n    function _setEquippableAddresses(\\n        uint64 partId,\\n        address[] calldata equippableAddresses\\n    ) internal onlySlot(partId) {\\n        if (equippableAddresses.length <= 0) revert RMRKZeroLengthIdsPassed();\\n        _parts[partId].equippable = equippableAddresses;\\n        delete _isEquippableToAll[partId];\\n\\n        emit SetEquippables(partId, equippableAddresses);\\n    }\\n\\n    /**\\n     * @notice Internal function used to remove all of the `equippableAddresses` for a `Part` associated with the `partId`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***SetEquippable*** event.\\n     * @param partId ID of the part that we are clearing the `equippableAddresses` from\\n     */\\n    function _resetEquippableAddresses(\\n        uint64 partId\\n    ) internal onlySlot(partId) {\\n        delete _parts[partId].equippable;\\n        delete _isEquippableToAll[partId];\\n\\n        emit SetEquippables(partId, new address[](0));\\n    }\\n\\n    /**\\n     * @notice Sets the isEquippableToAll flag to true, meaning that any collection may be equipped into the `Part` with this\\n     *  `partId`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***SetEquippableToAll*** event.\\n     * @param partId ID of the `Part` that we are setting as equippable by any address\\n     */\\n    function _setEquippableToAll(uint64 partId) internal onlySlot(partId) {\\n        _isEquippableToAll[partId] = true;\\n        emit SetEquippableToAll(partId);\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function checkIsEquippableToAll(uint64 partId) public view returns (bool) {\\n        return _isEquippableToAll[partId];\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function checkIsEquippable(\\n        uint64 partId,\\n        address targetAddress\\n    ) public view returns (bool) {\\n        // If this is equippable to all, we're good\\n        bool isEquippable = _isEquippableToAll[partId];\\n\\n        // Otherwise, must check against each of the equippable for the part\\n        if (!isEquippable && _parts[partId].itemType == ItemType.Slot) {\\n            address[] memory equippable = _parts[partId].equippable;\\n            uint256 len = equippable.length;\\n            for (uint256 i; i < len; ) {\\n                if (targetAddress == equippable[i]) {\\n                    isEquippable = true;\\n                    break;\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n        return isEquippable;\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getPart(uint64 partId) public view returns (Part memory) {\\n        return (_parts[partId]);\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getParts(\\n        uint64[] memory partIds\\n    ) public view returns (Part[] memory) {\\n        uint256 numParts = partIds.length;\\n        Part[] memory parts = new Part[](numParts);\\n\\n        for (uint256 i; i < numParts; ) {\\n            uint64 partId = partIds[i];\\n            parts[i] = _parts[partId];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return parts;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/equippable/IERC6220.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"../multiasset/IERC5773.sol\\\";\\n\\n/**\\n * @title IERC6220\\n * @author RMRK team\\n * @notice Interface smart contract of the RMRK equippable module.\\n */\\ninterface IERC6220 is IERC5773 {\\n    /**\\n     * @notice Used to store the core structure of the `Equippable` RMRK lego.\\n     * @return assetId The ID of the asset equipping a child\\n     * @return childAssetId The ID of the asset used as equipment\\n     * @return childId The ID of token that is equipped\\n     * @return childEquippableAddress Address of the collection to which the child asset belongs to\\n     */\\n    struct Equipment {\\n        uint64 assetId;\\n        uint64 childAssetId;\\n        uint256 childId;\\n        address childEquippableAddress;\\n    }\\n\\n    /**\\n     * @notice Used to provide a struct for inputing equip data.\\n     * @dev Only used for input and not storage of data.\\n     * @return tokenId ID of the token we are managing\\n     * @return childIndex Index of a child in the list of token's active children\\n     * @return assetId ID of the asset that we are equipping into\\n     * @return slotPartId ID of the slot part that we are using to equip\\n     * @return childAssetId ID of the asset that we are equipping\\n     */\\n    struct IntakeEquip {\\n        uint256 tokenId;\\n        uint256 childIndex;\\n        uint64 assetId;\\n        uint64 slotPartId;\\n        uint64 childAssetId;\\n    }\\n\\n    /**\\n     * @notice Used to notify listeners that a child's asset has been equipped into one of its parent assets.\\n     * @param tokenId ID of the token that had an asset equipped\\n     * @param assetId ID of the asset associated with the token we are equipping into\\n     * @param slotPartId ID of the slot we are using to equip\\n     * @param childId ID of the child token we are equipping into the slot\\n     * @param childAddress Address of the child token's collection\\n     * @param childAssetId ID of the asset associated with the token we are equipping\\n     */\\n    event ChildAssetEquipped(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed slotPartId,\\n        uint256 childId,\\n        address childAddress,\\n        uint64 childAssetId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that a child's asset has been unequipped from one of its parent assets.\\n     * @param tokenId ID of the token that had an asset unequipped\\n     * @param assetId ID of the asset associated with the token we are unequipping out of\\n     * @param slotPartId ID of the slot we are unequipping from\\n     * @param childId ID of the token being unequipped\\n     * @param childAddress Address of the collection that a token that is being unequipped belongs to\\n     * @param childAssetId ID of the asset associated with the token we are unequipping\\n     */\\n    event ChildAssetUnequipped(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed slotPartId,\\n        uint256 childId,\\n        address childAddress,\\n        uint64 childAssetId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that the assets belonging to a `equippableGroupId` have been marked as\\n     *  equippable into a given slot and parent\\n     * @param equippableGroupId ID of the equippable group being marked as equippable into the slot associated with\\n     *  `slotPartId` of the `parentAddress` collection\\n     * @param slotPartId ID of the slot part of the catalog into which the parts belonging to the equippable group\\n     *  associated with `equippableGroupId` can be equipped\\n     * @param parentAddress Address of the collection into which the parts belonging to `equippableGroupId` can be\\n     *  equipped\\n     */\\n    event ValidParentEquippableGroupIdSet(\\n        uint64 indexed equippableGroupId,\\n        uint64 indexed slotPartId,\\n        address parentAddress\\n    );\\n\\n    /**\\n     * @notice Used to equip a child into a token.\\n     * @dev The `IntakeEquip` stuct contains the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @param data An `IntakeEquip` struct specifying the equip data\\n     */\\n    function equip(IntakeEquip memory data) external;\\n\\n    /**\\n     * @notice Used to unequip child from parent token.\\n     * @dev This can only be called by the owner of the token or by an account that has been granted permission to\\n     *  manage the given token by the current owner.\\n     * @param tokenId ID of the parent from which the child is being unequipped\\n     * @param assetId ID of the parent's asset that contains the `Slot` into which the child is equipped\\n     * @param slotPartId ID of the `Slot` from which to unequip the child\\n     */\\n    function unequip(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) external;\\n\\n    /**\\n     * @notice Used to check whether the token has a given child equipped.\\n     * @dev This is used to prevent from transferring a child that is equipped.\\n     * @param tokenId ID of the parent token for which we are querying for\\n     * @param childAddress Address of the child token's smart contract\\n     * @param childId ID of the child token\\n     * @return A boolean value indicating whether the child token is equipped into the given token or not\\n     */\\n    function isChildEquipped(\\n        uint256 tokenId,\\n        address childAddress,\\n        uint256 childId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Used to verify whether a token can be equipped into a given parent's slot.\\n     * @param parent Address of the parent token's smart contract\\n     * @param tokenId ID of the token we want to equip\\n     * @param assetId ID of the asset associated with the token we want to equip\\n     * @param slotId ID of the slot that we want to equip the token into\\n     * @return A boolean indicating whether the token with the given asset can be equipped into the desired slot\\n     */\\n    function canTokenBeEquippedWithAssetIntoSlot(\\n        address parent,\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Used to get the Equipment object equipped into the specified slot of the desired token.\\n     * @dev The `Equipment` struct consists of the following data:\\n     *  [\\n     *      assetId,\\n     *      childAssetId,\\n     *      childId,\\n     *      childEquippableAddress\\n     *  ]\\n     * @param tokenId ID of the token for which we are retrieving the equipped object\\n     * @param targetCatalogAddress Address of the `Catalog` associated with the `Slot` part of the token\\n     * @param slotPartId ID of the `Slot` part that we are checking for equipped objects\\n     * @return The `Equipment` struct containing data about the equipped object\\n     */\\n    function getEquipment(\\n        uint256 tokenId,\\n        address targetCatalogAddress,\\n        uint64 slotPartId\\n    ) external view returns (Equipment memory);\\n\\n    /**\\n     * @notice Used to get the asset and equippable data associated with given `assetId`.\\n     * @param tokenId ID of the token for which to retrieve the asset\\n     * @param assetId ID of the asset of which we are retrieving\\n     * @return metadataURI The metadata URI of the asset\\n     * @return equippableGroupId ID of the equippable group this asset belongs to\\n     * @return catalogAddress The address of the catalog the part belongs to\\n     * @return partIds An array of IDs of parts included in the asset\\n     */\\n    function getAssetAndEquippableData(\\n        uint256 tokenId,\\n        uint64 assetId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory metadataURI,\\n            uint64 equippableGroupId,\\n            address catalogAddress,\\n            uint64[] memory partIds\\n        );\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/library/RMRKErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\n/// @title RMRKErrors\\n/// @author RMRK team\\n/// @notice A collection of errors used in the RMRK suite\\n/// @dev Errors are kept in a centralised file in order to provide a central point of reference and to avoid error\\n///  naming collisions due to inheritance\\n\\n/// Attempting to grant the token to 0x0 address\\nerror ERC721AddressZeroIsNotaValidOwner();\\n/// Attempting to grant approval to the current owner of the token\\nerror ERC721ApprovalToCurrentOwner();\\n/// Attempting to grant approval when not being owner or approved for all should not be permitted\\nerror ERC721ApproveCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to get approvals for a token owned by 0x0 (considered non-existent)\\nerror ERC721ApprovedQueryForNonexistentToken();\\n/// Attempting to grant approval to self\\nerror ERC721ApproveToCaller();\\n/// Attempting to use an invalid token ID\\nerror ERC721InvalidTokenId();\\n/// Attempting to mint to 0x0 address\\nerror ERC721MintToTheZeroAddress();\\n/// Attempting to manage a token without being its owner or approved by the owner\\nerror ERC721NotApprovedOrOwner();\\n/// Attempting to mint an already minted token\\nerror ERC721TokenAlreadyMinted();\\n/// Attempting to transfer the token from an address that is not the owner\\nerror ERC721TransferFromIncorrectOwner();\\n/// Attempting to safe transfer to an address that is unable to receive the token\\nerror ERC721TransferToNonReceiverImplementer();\\n/// Attempting to transfer the token to a 0x0 address\\nerror ERC721TransferToTheZeroAddress();\\n/// Attempting to grant approval of assets to their current owner\\nerror RMRKApprovalForAssetsToCurrentOwner();\\n/// Attempting to grant approval of assets without being the caller or approved for all\\nerror RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to incorrectly configue a Catalog item\\nerror RMRKBadConfig();\\n/// Attempting to set the priorities with an array of length that doesn't match the length of active assets array\\nerror RMRKBadPriorityListLength();\\n/// Attempting to add an asset entry with `Part`s, without setting the `Catalog` address\\nerror RMRKCatalogRequiredForParts();\\n/// Attempting to transfer a soulbound (non-transferrable) token\\nerror RMRKCannotTransferSoulbound();\\n/// Attempting to accept a child that has already been accepted\\nerror RMRKChildAlreadyExists();\\n/// Attempting to interact with a child, using index that is higher than the number of children\\nerror RMRKChildIndexOutOfRange();\\n/// Attempting to find the index of a child token on a parent which does not own it.\\nerror RMRKChildNotFoundInParent();\\n/// Attempting to pass collaborator address array and collaborator permission array of different lengths\\nerror RMRKCollaboratorArraysNotEqualLength();\\n/// Attempting to register a collection that is already registered\\nerror RMRKCollectionAlreadyRegistered();\\n/// Attempting to manage or interact with colleciton that is not registered\\nerror RMRKCollectionNotRegistered();\\n/// Attempting to equip a `Part` with a child not approved by the Catalog\\nerror RMRKEquippableEquipNotAllowedByCatalog();\\n/// Attempting to pass an epired ECDSA deadline\\nerror RMRKExpiredDeadline();\\n/// Attempting to use ID 0, which is not supported\\n/// @dev The ID 0 in RMRK suite is reserved for empty values. Guarding against its use ensures the expected operation\\nerror RMRKIdZeroForbidden();\\n/// Attempting to interact with an asset, using index greater than number of assets\\nerror RMRKIndexOutOfRange();\\n/// Attempting to reclaim a child that can't be reclaimed\\nerror RMRKInvalidChildReclaim();\\n/// Attempting to use and invalid ECDSA signature\\nerror RMRKInvalidSignature();\\n/// Attempting to interact with an end-user account when the contract account is expected\\nerror RMRKIsNotContract();\\n/// Attempting to interact with a contract that had its operation locked\\nerror RMRKLocked();\\n/// Attempting to add a pending child after the number of pending children has reached the limit (default limit is 128)\\nerror RMRKMaxPendingChildrenReached();\\n/// Attempting to add a pending asset after the number of pending assets has reached the limit (default limit is\\n///  128)\\nerror RMRKMaxPendingAssetsReached();\\n/// Attempting to burn a total number of recursive children higher than maximum set\\n/// @param childContract Address of the collection smart contract in which the maximum number of recursive burns was reached\\n/// @param childId ID of the child token at which the maximum number of recursive burns was reached\\nerror RMRKMaxRecursiveBurnsReached(address childContract, uint256 childId);\\n/// Attempting to mint a number of tokens that would cause the total supply to be greater than maximum supply\\nerror RMRKMintOverMax();\\n/// Attempting to mint a nested token to a smart contract that doesn't support nesting\\nerror RMRKMintToNonRMRKNestableImplementer();\\n/// Attempting to mint zero tokens\\nerror RMRKMintZero();\\n/// Attempting to pass complementary arrays of different lengths\\nerror RMRKMismachedArrayLength();\\n/// Attempting to transfer a child before it is unequipped\\nerror RMRKMustUnequipFirst();\\n/// Attempting to nest a child over the nestable limit (current limit is 100 levels of nesting)\\nerror RMRKNestableTooDeep();\\n/// Attempting to nest the token to own descendant, which would create a loop and leave the looped tokens in limbo\\nerror RMRKNestableTransferToDescendant();\\n/// Attempting to nest the token to a smart contract that doesn't support nesting\\nerror RMRKNestableTransferToNonRMRKNestableImplementer();\\n/// Attempting to nest the token into itself\\nerror RMRKNestableTransferToSelf();\\n/// Attempting to interact with an asset that can not be found\\nerror RMRKNoAssetMatchingId();\\n/// Attempting to manage an asset without owning it or having been granted permission by the owner to do so\\nerror RMRKNotApprovedForAssetsOrOwner();\\n/// Attempting to interact with a token without being its owner or having been granted permission by the\\n///  owner to do so\\n/// @dev When a token is nested, only the direct owner (NFT parent) can mange it. In that case, approved addresses are\\n///  not allowed to manage it, in order to ensure the expected behaviour\\nerror RMRKNotApprovedOrDirectOwner();\\n/// Attempting to manage a collection without being the collection's collaborator\\nerror RMRKNotCollectionCollaborator();\\n/// Attemting to manage a collection without being the collection's issuer\\nerror RMRKNotCollectionIssuer();\\n/// Attempting to manage a collection without being the collection's issuer or collaborator\\nerror RMRKNotCollectionIssuerOrCollaborator();\\n/// Attempting to compose an asset wihtout having an associated Catalog\\nerror RMRKNotComposableAsset();\\n/// Attempting to unequip an item that isn't equipped\\nerror RMRKNotEquipped();\\n/// Attempting to interact with a management function without being the smart contract's owner\\nerror RMRKNotOwner();\\n/// Attempting to interact with a function without being the owner or contributor of the collection\\nerror RMRKNotOwnerOrContributor();\\n/// Attempting to manage a collection without being the specific address\\nerror RMRKNotSpecificAddress();\\n/// Attempting to manage a token without being its owner\\nerror RMRKNotTokenOwner();\\n/// Attempting to transfer the ownership to the 0x0 address\\nerror RMRKNewOwnerIsZeroAddress();\\n/// Attempting to assign a 0x0 address as a contributor\\nerror RMRKNewContributorIsZeroAddress();\\n/// Attemtping to use `Ownable` interface without implementing it\\nerror RMRKOwnableNotImplemented();\\n/// Attempting an operation requiring the token being nested, while it is not\\nerror RMRKParentIsNotNFT();\\n/// Attempting to add a `Part` with an ID that is already used\\nerror RMRKPartAlreadyExists();\\n/// Attempting to use a `Part` that doesn't exist\\nerror RMRKPartDoesNotExist();\\n/// Attempting to use a `Part` that is `Fixed` when `Slot` kind of `Part` should be used\\nerror RMRKPartIsNotSlot();\\n/// Attempting to interact with a pending child using an index greater than the size of pending array\\nerror RMRKPendingChildIndexOutOfRange();\\n/// Attempting to add an asset using an ID that has already been used\\nerror RMRKAssetAlreadyExists();\\n/// Attempting to equip an item into a slot that already has an item equipped\\nerror RMRKSlotAlreadyUsed();\\n/// Attempting to equip an item into a `Slot` that the target asset does not implement\\nerror RMRKTargetAssetCannotReceiveSlot();\\n/// Attempting to equip a child into a `Slot` and parent that the child's collection doesn't support\\nerror RMRKTokenCannotBeEquippedWithAssetIntoSlot();\\n/// Attempting to compose a NFT of a token without active assets\\nerror RMRKTokenDoesNotHaveAsset();\\n/// Attempting to determine the asset with the top priority on a token without assets\\nerror RMRKTokenHasNoAssets();\\n/// Attempting to accept or transfer a child which does not match the one at the specified index\\nerror RMRKUnexpectedChildId();\\n/// Attempting to reject all pending assets but more assets than expected are pending\\nerror RMRKUnexpectedNumberOfAssets();\\n/// Attempting to reject all pending children but children assets than expected are pending\\nerror RMRKUnexpectedNumberOfChildren();\\n/// Attempting to accept or reject an asset which does not match the one at the specified index\\nerror RMRKUnexpectedAssetId();\\n/// Attempting an operation expecting a parent to the token which is not the actual one\\nerror RMRKUnexpectedParent();\\n/// Attempting not to pass an empty array of equippable addresses when adding or setting the equippable addresses\\nerror RMRKZeroLengthIdsPassed();\\n/// Attempting to set the royalties to a value higher than 100% (10000 in basis points)\\nerror RMRKRoyaltiesTooHigh();\\n/// Attempting to do a bulk operation on a token that is not owned by the caller\\nerror RMRKCanOnlyDoBulkOperationsOnOwnedTokens();\\n/// Attempting to do a bulk operation with multiple tokens at a time\\nerror RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime();\\n/// Attempting to pay with native token with a value different than expected\\nerror RMRKWrongValueSent();\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/multiasset/IERC5773.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IERC5773\\n * @author RMRK team\\n * @notice Interface smart contract of the RMRK multi asset module.\\n */\\ninterface IERC5773 is IERC165 {\\n    /**\\n     * @notice Used to notify listeners that an asset object is initialized at `assetId`.\\n     * @param assetId ID of the asset that was initialized\\n     */\\n    event AssetSet(uint64 indexed assetId);\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is added to token's pending asset\\n     *  array.\\n     * @param tokenIds An array of token IDs that received a new pending asset\\n     * @param assetId ID of the asset that has been added to the token's pending assets array\\n     * @param replacesId ID of the asset that would be replaced\\n     */\\n    event AssetAddedToTokens(\\n        uint256[] tokenIds,\\n        uint64 indexed assetId,\\n        uint64 indexed replacesId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is accepted by the token and migrated\\n     *  from token's pending assets array to active assets array of the token.\\n     * @param tokenId ID of the token that had a new asset accepted\\n     * @param assetId ID of the asset that was accepted\\n     * @param replacesId ID of the asset that was replaced\\n     */\\n    event AssetAccepted(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed replacesId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is rejected from token and is dropped\\n     *  from the pending assets array of the token.\\n     * @param tokenId ID of the token that had an asset rejected\\n     * @param assetId ID of the asset that was rejected\\n     */\\n    event AssetRejected(uint256 indexed tokenId, uint64 indexed assetId);\\n\\n    /**\\n     * @notice Used to notify listeners that token's prioritiy array is reordered.\\n     * @param tokenId ID of the token that had the asset priority array updated\\n     */\\n    event AssetPrioritySet(uint256 indexed tokenId);\\n\\n    /**\\n     * @notice Used to notify listeners that owner has granted an approval to the user to manage the assets of a\\n     *  given token.\\n     * @dev Approvals must be cleared on transfer\\n     * @param owner Address of the account that has granted the approval for all token's assets\\n     * @param approved Address of the account that has been granted approval to manage the token's assets\\n     * @param tokenId ID of the token on which the approval was granted\\n     */\\n    event ApprovalForAssets(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that owner has granted approval to the user to manage assets of all of their\\n     *  tokens.\\n     * @param owner Address of the account that has granted the approval for all assets on all of their tokens\\n     * @param operator Address of the account that has been granted the approval to manage the token's assets on all of\\n     *  the tokens\\n     * @param approved Boolean value signifying whether the permission has been granted (`true`) or revoked (`false`)\\n     */\\n    event ApprovalForAllForAssets(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @notice Accepts an asset at from the pending array of given token.\\n     * @dev Migrates the asset from the token's pending asset array to the token's active asset array.\\n     * @dev Active assets cannot be removed by anyone, but can be replaced by a new asset.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits an {AssetAccepted} event.\\n     * @param tokenId ID of the token for which to accept the pending asset\\n     * @param index Index of the asset in the pending array to accept\\n     * @param assetId ID of the asset expected to be in the index\\n     */\\n    function acceptAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) external;\\n\\n    /**\\n     * @notice Rejects an asset from the pending array of given token.\\n     * @dev Removes the asset from the token's pending asset array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits a {AssetRejected} event.\\n     * @param tokenId ID of the token that the asset is being rejected from\\n     * @param index Index of the asset in the pending array to be rejected\\n     * @param assetId ID of the asset expected to be in the index\\n     */\\n    function rejectAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) external;\\n\\n    /**\\n     * @notice Rejects all assets from the pending array of a given token.\\n     * @dev Effecitvely deletes the pending array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     * @dev Emits a {AssetRejected} event with assetId = 0.\\n     * @param tokenId ID of the token of which to clear the pending array.\\n     * @param maxRejections Maximum number of expected assets to reject, used to prevent from rejecting assets which\\n     *  arrive just before this operation.\\n     */\\n    function rejectAllAssets(uint256 tokenId, uint256 maxRejections) external;\\n\\n    /**\\n     * @notice Sets a new priority array for a given token.\\n     * @dev The priority array is a non-sequential list of `uint64`s, where the lowest value is considered highest\\n     *  priority.\\n     * @dev Value `0` of a priority is a special case equivalent to unitialized.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - The length of `priorities` must be equal the length of the active assets array.\\n     * @dev Emits a {AssetPrioritySet} event.\\n     * @param tokenId ID of the token to set the priorities for\\n     * @param priorities An array of priorities of active assets. The succesion of items in the priorities array\\n     *  matches that of the succesion of items in the active array\\n     */\\n    function setPriority(\\n        uint256 tokenId,\\n        uint64[] calldata priorities\\n    ) external;\\n\\n    /**\\n     * @notice Used to retrieve IDs of the active assets of given token.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @dev You can safely get 10k\\n     * @param tokenId ID of the token to retrieve the IDs of the active assets\\n     * @return An array of active asset IDs of the given token\\n     */\\n    function getActiveAssets(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Used to retrieve IDs of the pending assets of given token.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @param tokenId ID of the token to retrieve the IDs of the pending assets\\n     * @return An array of pending asset IDs of the given token\\n     */\\n    function getPendingAssets(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Used to retrieve the priorities of the active resoources of a given token.\\n     * @dev Asset priorities are a non-sequential array of uint64 values with an array size equal to active asset\\n     *  priorites.\\n     * @param tokenId ID of the token for which to retrieve the priorities of the active assets\\n     * @return An array of priorities of the active assets of the given token\\n     */\\n    function getActiveAssetPriorities(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Used to retrieve the asset that will be replaced if a given asset from the token's pending array\\n     *  is accepted.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @param tokenId ID of the token to check\\n     * @param newAssetId ID of the pending asset which will be accepted\\n     * @return ID of the asset which will be replaced\\n     */\\n    function getAssetReplacements(\\n        uint256 tokenId,\\n        uint64 newAssetId\\n    ) external view returns (uint64);\\n\\n    /**\\n     * @notice Used to fetch the asset metadata of the specified token's active asset with the given index.\\n     * @dev Assets are stored by reference mapping `_assets[assetId]`.\\n     * @dev Can be overriden to implement enumerate, fallback or other custom logic.\\n     * @param tokenId ID of the token from which to retrieve the asset metadata\\n     * @param assetId Asset Id, must be in the active assets array\\n     * @return The metadata of the asset belonging to the specified index in the token's active assets\\n     *  array\\n     */\\n    function getAssetMetadata(\\n        uint256 tokenId,\\n        uint64 assetId\\n    ) external view returns (string memory);\\n\\n    // Approvals\\n\\n    /**\\n     * @notice Used to grant permission to the user to manage token's assets.\\n     * @dev This differs from transfer approvals, as approvals are not cleared when the approved party accepts or\\n     *  rejects an asset, or sets asset priorities. This approval is cleared on token transfer.\\n     * @dev Only a single account can be approved at a time, so approving the `0x0` address clears previous approvals.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be an approved operator.\\n     *  - `tokenId` must exist.\\n     * @dev Emits an {ApprovalForAssets} event.\\n     * @param to Address of the account to grant the approval to\\n     * @param tokenId ID of the token for which the approval to manage the assets is granted\\n     */\\n    function approveForAssets(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @notice Used to retrieve the address of the account approved to manage assets of a given token.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @param tokenId ID of the token for which to retrieve the approved address\\n     * @return Address of the account that is approved to manage the specified token's assets\\n     */\\n    function getApprovedForAssets(\\n        uint256 tokenId\\n    ) external view returns (address);\\n\\n    /**\\n     * @notice Used to add or remove an operator of assets for the caller.\\n     * @dev Operators can call {acceptAsset}, {rejectAsset}, {rejectAllAssets} or {setPriority} for any token\\n     *  owned by the caller.\\n     * @dev Requirements:\\n     *\\n     *  - The `operator` cannot be the caller.\\n     * @dev Emits an {ApprovalForAllForAssets} event.\\n     * @param operator Address of the account to which the operator role is granted or revoked from\\n     * @param approved The boolean value indicating whether the operator role is being granted (`true`) or revoked\\n     *  (`false`)\\n     */\\n    function setApprovalForAllForAssets(\\n        address operator,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @notice Used to check whether the address has been granted the operator role by a given address or not.\\n     * @dev See {setApprovalForAllForAssets}.\\n     * @param owner Address of the account that we are checking for whether it has granted the operator role\\n     * @param operator Address of the account that we are checking whether it has the operator role or not\\n     * @return A boolean value indicating wehter the account we are checking has been granted the operator role\\n     */\\n    function isApprovedForAllForAssets(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/IMintableWithAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC6220} from \\\"@rmrk-team/evm-contracts/contracts/RMRK/equippable/IERC6220.sol\\\";\\nimport \\\"@rmrk-team/evm-contracts/contracts/implementations/RMRKCatalogImpl.sol\\\"; // So typechain catches it\\n\\ninterface IMintableWithAsset is IERC6220 {\\n    function mint(address to, uint64 assetId) external returns (uint256);\\n\\n    function nestMint(\\n        address to,\\n        uint256 destinationId,\\n        uint64 assetId\\n    ) external returns (uint256);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {Ownable} from \\\"@rmrk-team/evm-contracts/contracts/RMRK/access/Ownable.sol\\\";\\nimport {IERC6220} from \\\"@rmrk-team/evm-contracts/contracts/RMRK/equippable/IERC6220.sol\\\";\\nimport {IMintableWithAsset} from \\\"./IMintableWithAsset.sol\\\";\\n\\nerror FailedToSend();\\nerror IncorrectOdds();\\nerror IncorrectValueSent();\\n\\ncontract Minter is Ownable, IERC721Receiver {\\n    event PackMinted(\\n        address indexed to,\\n        uint256 indexed packId,\\n        uint64 parentAssetId,\\n        uint64 backgroundAssetId,\\n        uint64 glassesAssetId,\\n        uint64 handsAssetId,\\n        uint64 hatAssetId,\\n        uint64 shirtAssetId\\n    );\\n\\n    IMintableWithAsset private _parent;\\n    IMintableWithAsset private _backgrounds;\\n    IMintableWithAsset private _glasses;\\n    IMintableWithAsset private _hands;\\n    IMintableWithAsset private _hats;\\n    IMintableWithAsset private _shirts;\\n\\n    uint256[] private _parentAssetOdds;\\n    uint256[] private _backgroundsAssetOdds;\\n    uint256[] private _glassesAssetOdds;\\n    uint256[] private _handsAssetOdds;\\n    uint256[] private _hatsAssetOdds;\\n    uint256[] private _shirtsAssetOdds;\\n\\n    uint64 private constant BACKGROUNDS_SLOT_ID = 1001;\\n    uint64 private constant GLASSES_SLOT_ID = 1002;\\n    uint64 private constant HANDS_SLOT_ID = 1003;\\n    uint64 private constant HATS_SLOT_ID = 1004;\\n    uint64 private constant SHIRTS_SLOT_ID = 1005;\\n\\n    uint256 private _packsMinted;\\n    uint256 private _mintPrice;\\n    address private _beneficiary;\\n\\n    constructor(\\n        address beneficiary,\\n        address parent,\\n        address backgrounds,\\n        address glasses,\\n        address hands,\\n        address hats,\\n        address shirts,\\n        uint256 mintPrice\\n    ) {\\n        _beneficiary = beneficiary;\\n        _parent = IMintableWithAsset(parent);\\n        _backgrounds = IMintableWithAsset(backgrounds);\\n        _glasses = IMintableWithAsset(glasses);\\n        _hands = IMintableWithAsset(hands);\\n        _hats = IMintableWithAsset(hats);\\n        _shirts = IMintableWithAsset(shirts);\\n        _mintPrice = mintPrice;\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function getBeneficiary() external view returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    function getAddresses()\\n        external\\n        view\\n        returns (\\n            address parent,\\n            address backgrounds,\\n            address glasses,\\n            address hands,\\n            address hats,\\n            address shirts\\n        )\\n    {\\n        parent = address(_parent);\\n        backgrounds = address(_backgrounds);\\n        glasses = address(_glasses);\\n        hands = address(_hands);\\n        hats = address(_hats);\\n        shirts = address(_shirts);\\n    }\\n\\n    function getTotalAssets()\\n        external\\n        view\\n        returns (\\n            uint256 parent,\\n            uint256 backgrounds,\\n            uint256 glasses,\\n            uint256 hands,\\n            uint256 hats,\\n            uint256 shirts\\n        )\\n    {\\n        parent = _parentAssetOdds.length;\\n        backgrounds = _backgroundsAssetOdds.length;\\n        glasses = _glassesAssetOdds.length;\\n        hands = _handsAssetOdds.length;\\n        hats = _hatsAssetOdds.length;\\n        shirts = _shirtsAssetOdds.length;\\n    }\\n\\n    function getAssetods()\\n        external\\n        view\\n        returns (\\n            uint256[] memory parent,\\n            uint256[] memory backgrounds,\\n            uint256[] memory glasses,\\n            uint256[] memory hands,\\n            uint256[] memory hats,\\n            uint256[] memory shirts\\n        )\\n    {\\n        parent = _parentAssetOdds;\\n        backgrounds = _backgroundsAssetOdds;\\n        glasses = _glassesAssetOdds;\\n        hands = _handsAssetOdds;\\n        hats = _hatsAssetOdds;\\n        shirts = _shirtsAssetOdds;\\n    }\\n\\n    function getPacksMinted() public view returns (uint256) {\\n        return _packsMinted;\\n    }\\n\\n    function getMintPrice() public view returns (uint256) {\\n        return _mintPrice;\\n    }\\n\\n    function setBeneficiary(address beneficiary) external onlyOwner {\\n        _beneficiary = beneficiary;\\n    }\\n\\n    function setAssetOdds(\\n        uint256[] memory parentOdds,\\n        uint256[] memory backgroundsOdds,\\n        uint256[] memory glassesOdds,\\n        uint256[] memory handsOdds,\\n        uint256[] memory hatsOdds,\\n        uint256[] memory shirtsOdds\\n    ) external onlyOwnerOrContributor {\\n        delete _parentAssetOdds;\\n        delete _backgroundsAssetOdds;\\n        delete _glassesAssetOdds;\\n        delete _handsAssetOdds;\\n        delete _hatsAssetOdds;\\n        delete _shirtsAssetOdds;\\n\\n        _setOdds(_parentAssetOdds, parentOdds);\\n        _setOdds(_backgroundsAssetOdds, backgroundsOdds);\\n        _setOdds(_glassesAssetOdds, glassesOdds);\\n        _setOdds(_handsAssetOdds, handsOdds);\\n        _setOdds(_hatsAssetOdds, hatsOdds);\\n        _setOdds(_shirtsAssetOdds, shirtsOdds);\\n    }\\n\\n    function _setOdds(\\n        uint256[] storage currentOdds,\\n        uint256[] memory newOdds\\n    ) private {\\n        uint256 totalOdds;\\n        for (uint256 i = 0; i < newOdds.length; i++) {\\n            totalOdds += newOdds[i];\\n            currentOdds.push(newOdds[i]);\\n        }\\n        if (totalOdds != 100) revert IncorrectOdds();\\n    }\\n\\n    function mintPacks(address to, uint256 numPacks) external payable {\\n        _chargeFee(numPacks);\\n        for (uint256 i = 0; i < numPacks; i++) {\\n            _mintParentAndChildren(to);\\n        }\\n    }\\n\\n    function _mintParentAndChildren(address to) private {\\n        unchecked {\\n            ++_packsMinted;\\n        }\\n\\n        (\\n            uint64 parentAssetId,\\n            uint64 backgroundAssetId,\\n            uint64 glassesAssetId,\\n            uint64 handsAssetId,\\n            uint64 hatAssetId,\\n            uint64 shirtAssetId\\n        ) = _getAssetIds();\\n\\n        uint256 parentId = _parent.mint(address(this), parentAssetId);\\n        _backgrounds.nestMint(address(_parent), parentId, backgroundAssetId);\\n        _glasses.nestMint(address(_parent), parentId, glassesAssetId);\\n        _hands.nestMint(address(_parent), parentId, handsAssetId);\\n        _hats.nestMint(address(_parent), parentId, hatAssetId);\\n        _shirts.nestMint(address(_parent), parentId, shirtAssetId);\\n\\n        IERC6220.IntakeEquip memory equipInfo = IERC6220.IntakeEquip({\\n            tokenId: parentId,\\n            childIndex: 0,\\n            assetId: parentAssetId,\\n            slotPartId: BACKGROUNDS_SLOT_ID,\\n            childAssetId: backgroundAssetId\\n        });\\n        _parent.equip(equipInfo);\\n\\n        equipInfo.childIndex = 1;\\n        equipInfo.slotPartId = GLASSES_SLOT_ID;\\n        equipInfo.childAssetId = glassesAssetId;\\n        _parent.equip(equipInfo);\\n\\n        equipInfo.childIndex = 2;\\n        equipInfo.slotPartId = HANDS_SLOT_ID;\\n        equipInfo.childAssetId = handsAssetId;\\n        _parent.equip(equipInfo);\\n\\n        equipInfo.childIndex = 3;\\n        equipInfo.slotPartId = HATS_SLOT_ID;\\n        equipInfo.childAssetId = hatAssetId;\\n        _parent.equip(equipInfo);\\n\\n        equipInfo.childIndex = 4;\\n        equipInfo.slotPartId = SHIRTS_SLOT_ID;\\n        equipInfo.childAssetId = shirtAssetId;\\n        _parent.equip(equipInfo);\\n\\n        _parent.transferFrom(address(this), to, parentId);\\n\\n        emit PackMinted(\\n            to,\\n            _packsMinted,\\n            parentAssetId,\\n            backgroundAssetId,\\n            glassesAssetId,\\n            handsAssetId,\\n            hatAssetId,\\n            shirtAssetId\\n        );\\n    }\\n\\n    function _getAssetIds()\\n        private\\n        view\\n        returns (\\n            uint64 parentAssetId,\\n            uint64 backgroundAssetId,\\n            uint64 glassesAssetId,\\n            uint64 handsAssetId,\\n            uint64 hatAssetId,\\n            uint64 shirtAssetId\\n        )\\n    {\\n        uint256 baseSeed = uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    block.timestamp,\\n                    block.difficulty,\\n                    msg.sender,\\n                    _packsMinted\\n                )\\n            )\\n        );\\n        parentAssetId = _getAssetFromSeed(_parentAssetOdds, baseSeed);\\n        baseSeed >>= 8;\\n        backgroundAssetId = _getAssetFromSeed(_backgroundsAssetOdds, baseSeed);\\n        baseSeed >>= 8;\\n        glassesAssetId = _getAssetFromSeed(_glassesAssetOdds, baseSeed);\\n        baseSeed >>= 8;\\n        handsAssetId = _getAssetFromSeed(_handsAssetOdds, baseSeed);\\n        baseSeed >>= 8;\\n        hatAssetId = _getAssetFromSeed(_hatsAssetOdds, baseSeed);\\n        baseSeed >>= 8;\\n        shirtAssetId = _getAssetFromSeed(_shirtsAssetOdds, baseSeed);\\n    }\\n\\n    function _getAssetFromSeed(\\n        uint256[] memory odds,\\n        uint256 seed\\n    ) private view returns (uint64) {\\n        uint256 totalOdds;\\n        uint256 modSeed = seed % 100;\\n        for (uint256 i; i < odds.length; ) {\\n            totalOdds += odds[i];\\n            unchecked {\\n                ++i;\\n            }\\n            if (modSeed < totalOdds) {\\n                return uint64(i);\\n            }\\n        }\\n        return uint64(odds.length);\\n    }\\n\\n    function _chargeFee(uint256 numPacks) private {\\n        if (msg.value != _mintPrice * numPacks) {\\n            revert IncorrectValueSent();\\n        }\\n        (bool success, ) = _beneficiary.call{value: msg.value}(\\\"\\\");\\n        if (!success) revert FailedToSend();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"backgrounds\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"glasses\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hands\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hats\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"shirts\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FailedToSend\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectOdds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectValueSent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNewContributorIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotOwnerOrContributor\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isContributor\",\"type\":\"bool\"}],\"name\":\"ContributorUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"packId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"parentAssetId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"backgroundAssetId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"glassesAssetId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"handsAssetId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"hatAssetId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"shirtAssetId\",\"type\":\"uint64\"}],\"name\":\"PackMinted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"backgrounds\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"glasses\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hands\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hats\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"shirts\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssetods\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"parent\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"backgrounds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"glasses\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"hands\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"hats\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shirts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPacksMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"backgrounds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"glasses\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hands\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hats\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shirts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"isContributor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"grantRole\",\"type\":\"bool\"}],\"name\":\"manageContributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numPacks\",\"type\":\"uint256\"}],\"name\":\"mintPacks\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"parentOdds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"backgroundsOdds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"glassesOdds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"handsOdds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"hatsOdds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shirtsOdds\",\"type\":\"uint256[]\"}],\"name\":\"setAssetOdds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Minter", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000025864456507954be6020ea12d0bde3617901935b0000000000000000000000000cf0bc4dd026f3b7fec0339812d99d11829c0df4000000000000000000000000252ef85e1e66d34a8f3df2bc8d52518174a49585000000000000000000000000dc1c1263ba7bac5f8371734a0a3cd6697843152900000000000000000000000020c80a3069d5b51d7d4e40764ecd905000962e57000000000000000000000000c6f7cbbb32791e0bdc737d1f360de9c8a4a80b5f000000000000000000000000b75b0654f312d6905a075e6cdde5501560781518000000000000000000000000000000000000000000000000016345785d8a0000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}