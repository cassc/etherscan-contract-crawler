{"SourceCode": "# @version 0.3.7\r\n\r\nstruct Deposit:\r\n    path: DynArray[address, MAX_SIZE]\r\n    amount1: uint256\r\n    depositor: address\r\n\r\nenum WithdrawType:\r\n    CANCEL\r\n    PROFIT_TAKING\r\n    STOP_LOSS\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n\r\ninterface UniswapV2Router:\r\n    def WETH() -> address: pure\r\n    def swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn: uint256, amountOutMin: uint256, path: DynArray[address, MAX_SIZE], to: address, deadline: uint256): nonpayable\r\n    def swapExactTokensForETHSupportingFeeOnTransferTokens(amountIn: uint256, amountOutMin: uint256, path: DynArray[address, MAX_SIZE], to: address, deadline: uint256): nonpayable\r\n    def getAmountsOut(amountIn: uint256, path: DynArray[address, MAX_SIZE]) -> DynArray[uint256, MAX_SIZE]: view\r\n\r\nevent Deposited:\r\n    deposit_id: uint256\r\n    token0: address\r\n    token1: address\r\n    amount0: uint256\r\n    amount1: uint256\r\n    depositor: address\r\n    profit_taking: uint256\r\n    stop_loss: uint256\r\n\r\nevent Withdrawn:\r\n    deposit_id: uint256\r\n    withdrawer: address\r\n    withdraw_type: WithdrawType\r\n    withdraw_amount: uint256\r\n\r\nevent UpdateCompass:\r\n    old_compass: address\r\n    new_compass: address\r\n\r\nevent UpdateRefundWallet:\r\n    old_refund_wallet: address\r\n    new_refund_wallet: address\r\n\r\nevent UpdateFee:\r\n    old_fee: uint256\r\n    new_fee: uint256\r\n\r\nevent SetPaloma:\r\n    paloma: bytes32\r\n\r\nWETH: immutable(address)\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE # Virtual ETH\r\nMAX_SIZE: constant(uint256) = 8\r\nROUTER: immutable(address)\r\ncompass: public(address)\r\ndeposit_size: public(uint256)\r\ndeposits: public(HashMap[uint256, Deposit])\r\nrefund_wallet: public(address)\r\nfee: public(uint256)\r\npaloma: public(bytes32)\r\n\r\n@external\r\ndef __init__(_compass: address, router: address, _refund_wallet: address, _fee: uint256):\r\n    self.compass = _compass\r\n    ROUTER = router\r\n    WETH = UniswapV2Router(ROUTER).WETH()\r\n    self.refund_wallet = _refund_wallet\r\n    self.fee = _fee\r\n    log UpdateCompass(empty(address), _compass)\r\n    log UpdateRefundWallet(empty(address), _refund_wallet)\r\n    log UpdateFee(0, _fee)\r\n\r\n@internal\r\ndef _safe_approve(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"approve(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed approve\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_from, _to, _value, method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed transferFrom\r\n\r\n@external\r\n@payable\r\n@nonreentrant(\"lock\")\r\ndef deposit(path: DynArray[address, MAX_SIZE], amount0: uint256, min_amount1: uint256, profit_taking: uint256, stop_loss: uint256):\r\n    _value: uint256 = msg.value\r\n    _fee: uint256 = self.fee\r\n    assert _value >= _fee, \"Insufficient fee\"\r\n    assert self.paloma != empty(bytes32), \"Paloma not set\"\r\n    send(self.refund_wallet, _fee)\r\n    _value = unsafe_sub(_value, _fee)\r\n    assert len(path) >= 2, \"Wrong path\"\r\n    _path: DynArray[address, MAX_SIZE] = path\r\n    token0: address = path[0]\r\n    last_index: uint256 = unsafe_sub(len(path), 1)\r\n    token1: address = path[last_index]\r\n    _amount0: uint256 = amount0\r\n    if token0 == VETH:\r\n        assert _value >= amount0, \"Insufficient deposit\"\r\n        if _value > amount0:\r\n            send(msg.sender, unsafe_sub(_value, amount0))\r\n        WrappedEth(WETH).deposit(value=amount0)\r\n        _path[0] = WETH\r\n    else:\r\n        send(msg.sender, _value)\r\n        _amount0 = ERC20(token0).balanceOf(self)\r\n        self._safe_transfer_from(token0, msg.sender, self, amount0)\r\n        _amount0 = ERC20(token0).balanceOf(self) - _amount0\r\n    if token1 == VETH:\r\n        _path[last_index] = WETH\r\n    self._safe_approve(_path[0], ROUTER, _amount0)\r\n    _amount1: uint256 = ERC20(_path[last_index]).balanceOf(self)\r\n    UniswapV2Router(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(_amount0, min_amount1, _path, self, block.timestamp)\r\n    _amount1 = ERC20(_path[last_index]).balanceOf(self) - _amount1\r\n    assert _amount1 > 0, \"Insufficient deposit\"\r\n    deposit_id: uint256 = self.deposit_size\r\n    self.deposits[deposit_id] = Deposit({\r\n        path: path,\r\n        amount1: _amount1,\r\n        depositor: msg.sender\r\n    })\r\n    self.deposit_size = unsafe_add(deposit_id, 1)\r\n    log Deposited(deposit_id, token0, token1, amount0, _amount1, msg.sender, profit_taking, stop_loss)\r\n\r\n@internal\r\ndef _withdraw(deposit_id: uint256, min_amount0: uint256, withdraw_type: WithdrawType) -> uint256:\r\n    deposit: Deposit = self.deposits[deposit_id]\r\n    if withdraw_type == WithdrawType.CANCEL:\r\n        assert msg.sender == deposit.depositor, \"Unauthorized\"\r\n    self.deposits[deposit_id] = Deposit({\r\n        path: empty(DynArray[address, MAX_SIZE]),\r\n        amount1: empty(uint256),\r\n        depositor: empty(address)\r\n    })\r\n    assert deposit.amount1 > 0, \"Empty deposit\"\r\n    last_index: uint256 = unsafe_sub(len(deposit.path), 1)\r\n    path: DynArray[address, MAX_SIZE] = []\r\n    for i in range(MAX_SIZE):\r\n        path.append(deposit.path[unsafe_sub(last_index, i)])\r\n        if i >= last_index:\r\n            break\r\n    if path[0] == VETH:\r\n        path[0] = WETH\r\n    if path[last_index] == VETH:\r\n        path[last_index] = WETH\r\n    self._safe_approve(path[0], ROUTER, deposit.amount1)\r\n    _amount0: uint256 = 0\r\n    if deposit.path[0] == VETH:\r\n        _amount0 = deposit.depositor.balance\r\n        UniswapV2Router(ROUTER).swapExactTokensForETHSupportingFeeOnTransferTokens(deposit.amount1, min_amount0, path, deposit.depositor, block.timestamp)\r\n        _amount0 = deposit.depositor.balance - _amount0\r\n    else:\r\n        _amount0 = ERC20(path[last_index]).balanceOf(self)\r\n        UniswapV2Router(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(deposit.amount1, min_amount0, path, deposit.depositor, block.timestamp)\r\n        _amount0 = ERC20(path[last_index]).balanceOf(self) - _amount0\r\n    log Withdrawn(deposit_id, msg.sender, withdraw_type, _amount0)\r\n    return _amount0\r\n\r\n@external\r\ndef cancel(deposit_id: uint256, min_amount0: uint256) -> uint256:\r\n    return self._withdraw(deposit_id, min_amount0, WithdrawType.CANCEL)\r\n\r\n@external\r\ndef multiple_withdraw(deposit_ids: DynArray[uint256, MAX_SIZE], min_amounts0: DynArray[uint256, MAX_SIZE], withdraw_types: DynArray[WithdrawType, MAX_SIZE]):\r\n    assert msg.sender == self.compass, \"Unauthorized\"\r\n    _len: uint256 = len(deposit_ids)\r\n    assert _len == len(min_amounts0) and _len == len(withdraw_types), \"Validation error\"\r\n    _len = unsafe_add(unsafe_mul(unsafe_add(_len, 2), 96), 4)\r\n    assert len(msg.data) == _len, \"invalid payload\"\r\n    assert self.paloma == convert(slice(msg.data, unsafe_sub(_len, 32), 32), bytes32), \"invalid paloma\"\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_ids):\r\n            break\r\n        self._withdraw(deposit_ids[i], min_amounts0[i], withdraw_types[i])\r\n\r\n@external\r\ndef update_compass(new_compass: address):\r\n    assert msg.sender == self.compass and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    self.compass = new_compass\r\n    log UpdateCompass(msg.sender, new_compass)\r\n\r\n@external\r\ndef update_refund_wallet(new_refund_wallet: address):\r\n    assert msg.sender == self.compass and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_refund_wallet: address = self.refund_wallet\r\n    self.refund_wallet = new_refund_wallet\r\n    log UpdateRefundWallet(old_refund_wallet, new_refund_wallet)\r\n\r\n@external\r\ndef update_fee(new_fee: uint256):\r\n    assert msg.sender == self.compass and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_fee: uint256 = self.fee\r\n    self.fee = new_fee\r\n    log UpdateFee(old_fee, new_fee)\r\n\r\n@external\r\ndef set_paloma():\r\n    assert msg.sender == self.compass and self.paloma == empty(bytes32) and len(msg.data) == 36, \"Invalid\"\r\n    _paloma: bytes32 = convert(slice(msg.data, 4, 32), bytes32)\r\n    self.paloma = _paloma\r\n    log SetPaloma(_paloma)", "ABI": "[{\"name\":\"Deposited\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token0\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token1\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount0\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount1\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"depositor\",\"type\":\"address\",\"indexed\":false},{\"name\":\"profit_taking\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"stop_loss\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdrawn\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdrawer\",\"type\":\"address\",\"indexed\":false},{\"name\":\"withdraw_type\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdraw_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateCompass\",\"inputs\":[{\"name\":\"old_compass\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_compass\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateRefundWallet\",\"inputs\":[{\"name\":\"old_refund_wallet\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_refund_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFee\",\"inputs\":[{\"name\":\"old_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPaloma\",\"inputs\":[{\"name\":\"paloma\",\"type\":\"bytes32\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_compass\",\"type\":\"address\"},{\"name\":\"router\",\"type\":\"address\"},{\"name\":\"_refund_wallet\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"path\",\"type\":\"address[]\"},{\"name\":\"amount0\",\"type\":\"uint256\"},{\"name\":\"min_amount1\",\"type\":\"uint256\"},{\"name\":\"profit_taking\",\"type\":\"uint256\"},{\"name\":\"stop_loss\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\"},{\"name\":\"min_amount0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_withdraw\",\"inputs\":[{\"name\":\"deposit_ids\",\"type\":\"uint256[]\"},{\"name\":\"min_amounts0\",\"type\":\"uint256[]\"},{\"name\":\"withdraw_types\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_compass\",\"inputs\":[{\"name\":\"new_compass\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_refund_wallet\",\"inputs\":[{\"name\":\"new_refund_wallet\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_fee\",\"inputs\":[{\"name\":\"new_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_paloma\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"compass\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposit_size\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposits\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"path\",\"type\":\"address[]\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"depositor\",\"type\":\"address\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"refund_wallet\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paloma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000083faa28424d2819c4c4c2f701998c47d572fb2f4000000000000000000000000cf0febd3f17cef5b47b0cd257acf6025c5bff3b70000000000000000000000006dc0a87638cd75cc700ccdb226c7ab6c054bc70b00000000000000000000000000000000000000000000000000b1a2bc2ec50000", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}