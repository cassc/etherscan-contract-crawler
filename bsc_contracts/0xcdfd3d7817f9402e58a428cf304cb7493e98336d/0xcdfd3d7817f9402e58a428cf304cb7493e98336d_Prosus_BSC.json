{"SourceCode": "pragma solidity ^0.8.0;\r\n\r\n\r\ninterface interfaz_BEP20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nabstract contract contexto {\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Prosus_BSC is contexto, interfaz_BEP20 {\r\n    \r\n    address payable private deployer;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    uint256 internal _totalSupply;\r\n\r\n    constructor() {\r\n        _name = \"Prosus-BSC\";\r\n        _symbol = \"bPROSUS\";\r\n        _decimals = 12;\r\n        _totalSupply = 0;\r\n        _balances[msg.sender] = _totalSupply;\r\n\r\n        deployer = payable(msg.sender);\r\n \r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    /*=================================\r\n    =          MODIFICADORES          =\r\n    =================================*/\r\n    // s\u00f3lo quienes tienen tokens\r\n    modifier conTokens() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // s\u00f3lo quienes tienen ganancias\r\n    modifier conGanancias() {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == deployer, \"No eres el creador del contrato\");\r\n        _;\r\n    }\r\n    \r\n    /*==============================\r\n    =           EVENTOS            =\r\n    ==============================*/\r\n    event onTokenPurchase(address indexed customerAddress, uint256 incomingBNB, uint256 tokensMinted, address indexed referredBy);\r\n    event onTokenSell(address indexed customerAddress, uint256 tokensBurned, uint256 bnbEarned);\r\n    event onReinvestment(address indexed customerAddress, uint256 bnbReinvested, uint256 tokensMinted);\r\n    event onWithdraw(address indexed customerAddress, uint256 bnbWithdrawn);\r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    uint8 constant internal dividendFee_ = 10;  // 10%   ( dividendFee_ / 100  =  porcentaje )\r\n    uint256 constant internal tokenPriceInitial_     = 0.00000100       * (10**18); // precio en BNB\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001       * (10**18); \r\n    uint256 constant internal magnitude = 2**64;\r\n    \r\n   /*================================\r\n    =            DATASETS         \t=\r\n    ===============================*/\r\n    // cantidad de cripto-activos para cada direcci\u00f3n (n\u00famero escalado)\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    \r\n    // otras m\u00e9tricas\r\n    mapping(address => bool) internal activatedPlayer_;\r\n    \r\n    mapping(address => uint256) internal referralsOf_;\r\n    mapping(address => uint256) internal referralEarningsOf_;\r\n    \r\n    uint256 internal players;\r\n    uint256 internal AMMsupply_ = 0;\r\n    uint256 internal profitPerShare_;\r\n    \r\n    /*=======================================\r\n    =            FUNCIONES P\u00dcBLICAS         =\r\n    =======================================*/\r\n    // Convierte todos los BNB entrantes en Prosus_AMM, para cada usuario. Y agrega un complemento para referidos (si corresponde).\r\n    function buy(address _referredBy) external payable {\r\n        \r\n        // Depositar BNB en el contrato; crear los tokens.\r\n        purchaseTokens(msg.value, _referredBy);\r\n        \r\n\t\t// Si en los dep\u00f3sitos 'msgSender = 0' , significa que es el primer dep\u00f3sito.\r\n        // Por esto, se agrega 1 al recuento total de participantes y al contador de sus referidos.\r\n        if (activatedPlayer_[msg.sender] == false) {\r\n            activatedPlayer_[msg.sender] = true;\r\n            players += 1;\r\n            referralsOf_[_referredBy] += 1;\r\n        }\r\n    }\r\n    \r\n    // Funci\u00f3n de respaldo para manejar BNB enviados directamente al contrato: \"deployer\" es el referido.\r\n    receive() payable external {\r\n        purchaseTokens(msg.value, deployer);\r\n    }\r\n    \r\n    // Convertir los dividendos en Prosus_AMM.\r\n    function reinvest() conGanancias() public {\r\n        // obtener dividendos\r\n        uint256 _dividends = myDividends(false); // recuperar bono de referidos (ver el c\u00f3digo a continuaci\u00f3n)\r\n        \r\n        // pagar (virtualmente) dividendos\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\r\n\r\n        // recuperar bono de referidos\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n        \r\n        // ejecutar una orden de compra \"virtual\", usando el retiro de dividendos.\r\n        uint256 _tokens = purchaseTokens(_dividends, deployer);\r\n        \r\n        // emitir evento\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n    \r\n    // Alias para vender y girar.\r\n    function exit() public {\r\n        // Obtener el recuento de tokens para la persona que lo solicita y venderlos todos.\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens > 0) sell(_tokens);\r\n        \r\n\t\t// ejecutar\r\n        withdraw();\r\n    }\r\n\r\n    // Los participantes retiran sus ganancias.\r\n    function withdraw() conGanancias() public {\r\n        // datos de configuraci\u00f3n\r\n        address payable _customerAddress = payable(msg.sender);\r\n        uint256 _dividends = myDividends(false); // tomar bono de referidos (m\u00e1s adelante en el c\u00f3digo)\r\n        \r\n        // actualizar el trazador de dividendos\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\r\n        \r\n        // agregar bono de referidos\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n        \r\n        // ejecutar\r\n        _customerAddress.transfer(_dividends);\r\n        \r\n        // emitir evento\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    \r\n    // liquidar Prosus_AMM (convertirlos a BNB)\r\n    function sell(uint256 _amountOfTokens) conTokens() public {\r\n        // datos de configuraci\u00f3n\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]); // comprobar saldo\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _bnb = tokensToBNB_(_tokens);\r\n        uint256 _dividends = _bnb / dividendFee_;\r\n        uint256 _taxedBNB = _bnb - _dividends;\r\n        \r\n        // quemar los tokens vendidos\r\n        AMMsupply_ = AMMsupply_ - _tokens;\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress] - _tokens;\r\n        \r\n        // actualizar el trazador de dividendos\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedBNB * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;       \r\n        \r\n        if (AMMsupply_ > 0) {         // para evitar dividir por cero\r\n            // actualizar la cantidad de dividendos por cada token\r\n            profitPerShare_ = profitPerShare_ + (_dividends * magnitude) / AMMsupply_ ;\r\n        }\r\n        \r\n        // emitir evento\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedBNB);\r\n    }\r\n\r\n    /*----------  AUXILIARES (\"helpers\") Y C\u00c1LCULOS  ----------*/\r\n    \r\n    // Buscar si el enlace de referido ya est\u00e1 siendo usado.\r\n    function playerStatus(address _player) public view returns (bool) {\r\n        return activatedPlayer_[_player];\r\n    }\r\n    \r\n    function myTotalReferrals() public view returns (uint) {\r\n        return referralsOf_[msg.sender];\r\n    }\r\n    \r\n    function myTotalReferralEarnings() public view returns (uint) {\r\n        return referralEarningsOf_[msg.sender];\r\n    }\r\n    \r\n    // ----------\r\n    \r\n    function totalReferralsOf(address _user) public view returns (uint) {\r\n        return referralsOf_[_user];\r\n    }\r\n    \r\n    function totalReferralEarningsOf(address _user) public view returns (uint) {\r\n        return referralEarningsOf_[_user];\r\n    }\r\n    \r\n    // ----------\r\n    \r\n    // M\u00e9todo para ver los BNB vigentes, almacenados en el contrato.\r\n    function totalBNBBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    // Obtener cantidad total (\"suministro\") de Prosus_AMM.\r\n    function AMM_totalSupply() public view returns(uint256) {\r\n        return AMMsupply_;\r\n    }\r\n    \r\n    // Obtener cantidad de Prosus_AMM que posee el usuario.\r\n    function myTokens() public view returns(uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return AMM_balanceOf(_customerAddress);\r\n    }\r\n\r\n    // Recuperar los dividendos pertenecientes a la persona que lo solicita.    \r\n    /* Si `_includeReferralBonus` es 1 (verdadero), el bono de referidos se incluir\u00e1 en los c\u00e1lculos.\r\n     * La raz\u00f3n de esto es que, en la interfaz, deben aparecer los dividendos totales (global + referidos)\r\n     * pero en los c\u00e1lculos internos los queremos por separado. */ \r\n    function myDividends(bool _includeReferralBonus) public view returns(uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return dividendsOf(_customerAddress,_includeReferralBonus);\r\n    }\r\n    \r\n    // Recuperar el balance de Prosus_AMM, de una determinada direcci\u00f3n.\r\n    function AMM_balanceOf(address _customerAddress) view public returns(uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    \r\n    // Recuperar el balance de los dividendos, de una sola direcci\u00f3n.\r\n    function dividendsOf(address _customerAddress,bool _includeReferralBonus) view public returns(uint256) {\r\n        uint256 regularDividends = (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n        if (_includeReferralBonus){\r\n            return regularDividends + referralBalance_[_customerAddress];\r\n        } else {\r\n            return regularDividends;\r\n        }\r\n    }\r\n    \r\n    // Obtener el precio de compra de un solo token.\r\n    function sellPrice() public view returns(uint256) {\r\n        if(AMMsupply_ == 0){  // se necesita un valor para calcular el suministro.\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _bnb = tokensToBNB_(1e12);\r\n            uint256 _dividends = _bnb / dividendFee_;\r\n            uint256 _taxedBNB = _bnb - _dividends;\r\n            return _taxedBNB;\r\n        }\r\n    }\r\n    \r\n    // Obtener el precio de venta de un solo token.\r\n    function buyPrice() public view returns(uint256) {\r\n        if(AMMsupply_ == 0){  // se necesita un valor para calcular el suministro de tokens.\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _bnb = tokensToBNB_(1e12);\r\n            uint256 _dividends = _bnb / dividendFee_;\r\n            uint256 _taxedBNB = _bnb + _dividends;\r\n            return _taxedBNB;\r\n        }\r\n    }\r\n    \r\n    // Funci\u00f3n para que la interfaz recupere din\u00e1micamente la escala de precios de las \u00f3rdenes de compra.\r\n    function calculateTokensReceived(uint256 _bnbToSpend) public view returns(uint256) {\r\n        uint256 _dividends = _bnbToSpend / dividendFee_;\r\n        uint256 _taxedBNB = _bnbToSpend - _dividends;\r\n        uint256 _amountOfTokens = bnbToTokens_(_taxedBNB);\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n    \r\n    // Funci\u00f3n de la interfaz para recuperar din\u00e1micamente la escala de precios de las \u00f3rdenes de venta.\r\n    function calculateBNBReceived(uint256 _tokensToSell) public view returns(uint256) {\r\n        require(_tokensToSell <= AMMsupply_);\r\n        uint256 _bnb = tokensToBNB_(_tokensToSell);\r\n            uint256 _dividends = _bnb / dividendFee_;\r\n            uint256 _taxedBNB = _bnb - _dividends;\r\n        return _taxedBNB;\r\n    }\r\n    \r\n    \r\n    /*==========================================\r\n    =            FUNCIONES INTERNAS            =\r\n    ==========================================*/\r\n    function purchaseTokens(uint256 _incomingBNB, address _referredBy) internal returns(uint256) {\r\n        // datos de configuraci\u00f3n\r\n        address _customerAddress = msg.sender;\r\n        uint256 _undividedDividends = _incomingBNB / dividendFee_;\r\n        uint256 _taxedBNB = _incomingBNB - _undividedDividends;\r\n        uint256 _amountOfTokens = bnbToTokens_(_taxedBNB);\r\n\r\n        uint256 _referralBonus = _undividedDividends / 2 ;\r\n        uint256 _dividends = _undividedDividends - _referralBonus;\r\n        uint256 _fee = _dividends * magnitude;\r\n \r\n        require(_amountOfTokens > 0 && (_amountOfTokens + AMMsupply_) > AMMsupply_) ; // prevenir saturaci\u00f3n\r\n        \r\n        if ( _referredBy != 0x0000000000000000000000000000000000000000 ) { // usan enlace de referidos\r\n            // distribuci\u00f3n de los bonos por referido\r\n            referralBalance_[_referredBy] = referralBalance_[_referredBy] + _referralBonus ;\r\n        } else { // no usan enlace de referidos\r\n            // se devuelve bono de referidos al reparto global de dividendos.\r\n            _dividends = _dividends + _referralBonus;\r\n            _fee = _dividends * magnitude;\r\n        }\r\n        \r\n        if(AMMsupply_ > 0){  // Para no entregar BNB infinito a los usuarios.\r\n            // agregar tokens al suministo\r\n            AMMsupply_ = AMMsupply_ + _amountOfTokens;\r\n \r\n            // tomar la cantidad de dividendos obtenidos a trav\u00e9s de esta transacci\u00f3n y distribuirlos a los participantes\r\n            profitPerShare_ += (_dividends * magnitude / AMMsupply_ );\r\n            \r\n            // calcular la cantidad de tokens que recibe el usuario cuando compra\r\n            _fee = _fee - (_fee - (_amountOfTokens * ( _dividends * magnitude / (AMMsupply_) )));\r\n        \r\n         } else {\r\n            // agregar tokens al suministro\r\n            AMMsupply_ = _amountOfTokens;\r\n         }\r\n        \r\n        // actualizar el suministro circulante usando los balances de usuario\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress] + _amountOfTokens;\r\n        \r\n\t\t// actualizar trazador de dividendos antes de entregar dividendos\r\n        int256 _updatedPayouts = int256( (int256(profitPerShare_) * int256(_amountOfTokens)) - int256(_fee) ); // s\u00f3lo cantidades enteras\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n\r\n        referralEarningsOf_[_referredBy] += (_referralBonus);\r\n        \r\n        // emitir evento\r\n        emit onTokenPurchase(_customerAddress, _incomingBNB, _amountOfTokens, _referredBy);\r\n\r\n        return _amountOfTokens;        \r\n    }\r\n\r\n    // Calcular el precio de Prosus_AMM en funci\u00f3n de la cantidad de BNB entrantes.\r\n\t// Se realizan algunas conversiones para evitar errores decimales o desbordamientos en el c\u00f3digo Solidity.\r\n    function bnbToTokens_(uint256 _bnb) internal view returns(uint256) {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e12;\r\n        uint256 _tokensReceived = \r\n         (\r\n            (\r\n                (\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e12)*(_bnb * 1e12))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(AMMsupply_**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*AMMsupply_)\r\n                        )\r\n                    ) - _tokenPriceInitial\r\n                )\r\n            ) / (tokenPriceIncremental_)\r\n        ) - (AMMsupply_) ;\r\n  \r\n        return _tokensReceived;\r\n    }\r\n        function sqrt(uint x) internal pure returns (uint y) {\r\n            uint z = (x + 1) / 2;\r\n            y = x;\r\n            while (z < y) {\r\n                y = z;\r\n                z = (x / z + z) / 2;\r\n            }\r\n        }\r\n    \r\n    // Calcular el precio de venta de Prosus_AMM.\r\n\t// Se realizan algunas conversiones para evitar errores decimales o desbordamientos en el c\u00f3digo Solidity.\r\n     function tokensToBNB_(uint256 amount) internal view returns(uint256) {\r\n        uint256 _tokens = (amount + 1e12);\r\n        uint256 _AMMsupply = (AMMsupply_ + 1e12)/1e12;\r\n        uint256 _BNBrecibido =  \r\n        (\r\n            (\r\n                (\r\n                    (\r\n                        (\r\n                        tokenPriceInitial_ + (tokenPriceIncremental_ * _AMMsupply)\r\n                        ) - tokenPriceIncremental_\r\n                    ) * (_tokens - 1e12)\r\n                ) - (tokenPriceIncremental_ * ((_tokens**2 - _tokens)/1e12))/2\r\n            ) / 1e12 \r\n        );\r\n\r\n        return _BNBrecibido;\r\n    }\r\n\r\n    /*==========================================\r\n    =        INTERACCION AMM / BEP20           =\r\n    ==========================================*/\r\n    function AMM_BEP (uint256 _amountOfTokens) public returns(bool){  // traspasar saldo de cuenta Prosus_AMM a cuenta Prosus_BEP\r\n        // asegurar que tengamos los tokens_AMM solicitados\r\n        require(_amountOfTokens <= tokenBalanceLedger_[msg.sender]);\r\n\r\n        // quemar tokens_AMM\r\n        AMMsupply_ = AMMsupply_ - _amountOfTokens;\r\n        tokenBalanceLedger_[msg.sender] = tokenBalanceLedger_[msg.sender] - _amountOfTokens;\r\n            \r\n        // actualizar (disminuir) el trazador de dividendos\r\n        payoutsTo_[msg.sender] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n\r\n        // minar tokens_BEP\r\n        _mint(msg.sender, _amountOfTokens);    \r\n\r\n        return true ;\r\n    }\r\n\r\n    function BEP_AMM (uint256 _amountOfTokens) public returns(bool){  // traspasar saldo de cuenta Prosus_BEP a cuenta Prosus_AMM\r\n        // asegurar que tengamos los tokens_BEP solicitados\r\n        require(_amountOfTokens <= _balances[msg.sender]);\r\n\r\n        // quemar tokens_BEP\r\n        _totalSupply = _totalSupply - _amountOfTokens;\r\n        _balances[msg.sender] = _balances[msg.sender] - _amountOfTokens;\r\n            \r\n        // actualizar (aumentar) el trazador de dividendos\r\n        payoutsTo_[msg.sender] += (int256) (profitPerShare_ * _amountOfTokens);\r\n\r\n        // minar tokens_AMM\r\n        _mintAMM(msg.sender, _amountOfTokens);    \r\n\r\n        return true ;\r\n    }\r\n\r\n    function SupplyPeg(uint256 amount) external onlyOwner returns (bool) {\r\n       _mint(msg.sender, amount);\r\n       return true;\r\n    }\r\n\r\n    function _mintAMM(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: mint to the zero address?\");\r\n        AMMsupply_ = AMMsupply_ + amount ;\r\n        tokenBalanceLedger_[account] = tokenBalanceLedger_[account] + amount ;\r\n        emit Transfer(address(0), account, amount);\r\n    }  \r\n\r\n\r\n    /*==========================================\r\n    =            FUNCIONES BEP20            =\r\n    ==========================================*/\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n        require(currentAllowance >= subtractedValue, \"BEP20: decreased allowance below zero\");\r\n        unchecked { _approve(owner, spender, currentAllowance - subtractedValue); }\r\n        return true;\r\n    }\r\n\r\n    function burn(uint _amount) public {\r\n        _burn(msg.sender, _amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"BEP20: transfer from the zero address\");\r\n        require(to != address(0), \"BEP20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"BEP20: transfer amount exceeds balance\");\r\n        unchecked { _balances[from] = fromBalance - amount; }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"BEP20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"BEP20: burn amount exceeds balance\");\r\n        unchecked { _balances[account] = accountBalance - amount; }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"BEP20: insufficient allowance\");\r\n            unchecked { _approve(owner, spender, currentAllowance - amount); }\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\r\n    }\r\n\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n /*================================\r\n =            CR\u00c9DITOS            =\r\n ================================*/\r\n // autor: Prosus Corp (research and technological development)\r\n // mantenimiento: YerkoBits\r\n // SPDX-License-Identifier: MIT\r\n // open-source: Prosus-BSC est\u00e1 basado en varios contratos de c\u00f3digo abierto, principalmente Hourglass, OpenZeppelin, StrongHands.\r\n //", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"AMM_BEP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"AMM_balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AMM_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"BEP_AMM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SupplyPeg\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateBNBReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnbToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTotalReferralEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTotalReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"playerStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBNBBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"totalReferralEarningsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"totalReferralsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Prosus_BSC", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2e96b938ca928c2cf60eeaf12548830b49067104c6da87c92658b706f1c77609"}