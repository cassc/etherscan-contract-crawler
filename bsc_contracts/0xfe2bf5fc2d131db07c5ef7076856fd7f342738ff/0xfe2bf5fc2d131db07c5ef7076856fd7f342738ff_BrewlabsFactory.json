{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BrewlabsERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\nimport {IBrewlabsERC20} from \\\"./interfaces/IBrewlabsERC20.sol\\\";\\n\\ncontract BrewlabsERC20 is IBrewlabsERC20 {\\n    string public constant name = \\\"Brewswap LP\\\";\\n    string public constant symbol = \\\"BREWSWAP-LP\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public nonces;\\n\\n    constructor() {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply + value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from] - value;\\n        totalSupply = totalSupply - value;\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) private {\\n        require(owner != address(0) && spender != address(0), \\\"Invalid owner or spender address\\\");\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal virtual {\\n        require(from != address(0) && to != address(0), \\\"Invalid from or to address\\\");\\n        balanceOf[from] = balanceOf[from] - value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender] - value;\\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external\\n    {\\n        require(deadline >= block.timestamp, \\\"Brewlabs: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"Brewlabs: INVALID_SIGNATURE\\\");\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BrewlabsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\nimport {IBrewlabsFactory} from \\\"./interfaces/IBrewlabsFactory.sol\\\";\\nimport {IBrewlabsSwapFeeManager} from \\\"./interfaces/IBrewlabsSwapFeeManager.sol\\\";\\n\\nimport {BrewlabsPair} from \\\"./BrewlabsPair.sol\\\";\\n\\ncontract BrewlabsFactory is IBrewlabsFactory {\\n    bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(BrewlabsPair).creationCode));\\n\\n    address public owner;\\n    address public feePercentOwner;\\n    address public setStableOwner;\\n    address public feeTo;\\n    address public feeManager;\\n    address public discountMgr;\\n\\n    mapping(address => bool) private isBlackListed;\\n    mapping(address => bool) private whitelist;\\n    bool private disableUpdateFeeMgr;\\n\\n    uint256 public constant MAX_OWNER_FEE = 300_000; // 30%\\n    uint256 public ownerFee = 166_666; // default value = 1/6\\n\\n    mapping(address => mapping(address => address)) public getPair;\\n    address[] public allPairs;\\n\\n    event FeeToTransferred(address indexed prevFeeTo, address indexed newFeeTo);\\n    event DiscountManagerChanged(address indexed prevMgr, address indexed newMgr);\\n    event FeeManagerChanged(address indexed prevMgr, address indexed newMgr);\\n    event FeePercentOwnershipTransferred(address indexed prevOwner, address indexed newOwner);\\n    event OwnerFeeUpdated(uint256 prevOwnerFee, uint256 ownerFee);\\n    event OwnershipTransferred(address indexed prevOwner, address indexed newOwner);\\n    event SetStableOwnershipTransferred(address indexed prevOwner, address indexed newOwner);\\n    event Whitelisted(address indexed addr, bool status);\\n    event Blacklisted(address indexed addr);\\n\\n    constructor(address feeTo_) {\\n        owner = msg.sender;\\n        feePercentOwner = msg.sender;\\n        setStableOwner = msg.sender;\\n        feeTo = feeTo_;\\n\\n        emit OwnershipTransferred(address(0), msg.sender);\\n        emit FeePercentOwnershipTransferred(address(0), msg.sender);\\n        emit SetStableOwnershipTransferred(address(0), msg.sender);\\n        emit FeeToTransferred(address(0), feeTo_);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Brewlabs: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if address is allowed to execute swap transaction\\n     *\\n     * Return true if address is not added to the blacklist.\\n     */\\n\\n    function isAllowedToSwap(address addr) external view returns (bool) {\\n        return !isBlackListed[addr];\\n    }\\n\\n    /**\\n     * @dev Check if address is whitelisted to swap with no fee\\n     */\\n    function isWhitelisted(address addr) external view returns (bool) {\\n        return whitelist[addr];\\n    }\\n\\n    function allPairsLength() external view returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\\n        require(tokenA != tokenB, \\\"Brewlabs: IDENTICAL_ADDRESSES\\\");\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"Brewlabs: ZERO_ADDRESS\\\");\\n        require(getPair[token0][token1] == address(0), \\\"Brewlabs: PAIR_EXISTS\\\"); // single check is sufficient\\n        bytes memory bytecode = type(BrewlabsPair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        require(pair != address(0), \\\"Brewlabs: FAILED\\\");\\n        BrewlabsPair(pair).initialize(token0, token1);\\n        if (feeManager != address(0)) {\\n            IBrewlabsSwapFeeManager(feeManager).createPool(token0, token1);\\n        }\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"Brewlabs: zero address\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function setFeePercentOwner(address _feePercentOwner) external onlyOwner {\\n        require(_feePercentOwner != address(0), \\\"Brewlabs: zero address\\\");\\n        emit FeePercentOwnershipTransferred(feePercentOwner, _feePercentOwner);\\n        feePercentOwner = _feePercentOwner;\\n    }\\n\\n    function setSetStableOwner(address _setStableOwner) external onlyOwner {\\n        require(_setStableOwner != address(0), \\\"Brewlabs: zero address\\\");\\n        emit SetStableOwnershipTransferred(setStableOwner, _setStableOwner);\\n        setStableOwner = _setStableOwner;\\n    }\\n\\n    function setFeeTo(address feeAddr) external onlyOwner {\\n        emit FeeToTransferred(feeTo, feeAddr);\\n        feeTo = feeAddr;\\n    }\\n\\n    function setFeeManager(address newFeeMgr) external onlyOwner {\\n        require(!disableUpdateFeeMgr, \\\"Cannot set fee manager\\\");\\n        emit FeeManagerChanged(feeManager, newFeeMgr);\\n        if (feeManager != address(0x0) && newFeeMgr == address(0x0)) {\\n            disableUpdateFeeMgr = true;\\n        }\\n        feeManager = newFeeMgr;\\n    }\\n\\n    function setDiscountManager(address newDiscountMgr) external onlyOwner {\\n        emit DiscountManagerChanged(discountMgr, newDiscountMgr);\\n        discountMgr = newDiscountMgr;\\n    }\\n\\n    /**\\n     * @dev Updates the share of fees attributed to the owner\\n     *\\n     * Must only be called by owner\\n     */\\n    function setOwnerFee(uint256 newOwnerFee) external onlyOwner {\\n        require(newOwnerFee > 0, \\\"Brewlabs: ownerFee must exceed minimum\\\");\\n        require(newOwnerFee <= MAX_OWNER_FEE, \\\"Brewlabs: ownerFee cannot exceed maximum\\\");\\n        emit OwnerFeeUpdated(ownerFee, newOwnerFee);\\n        ownerFee = newOwnerFee;\\n    }\\n\\n    function feeInfo() external view returns (uint256, address) {\\n        if (feeManager != address(0)) return (1_000_000, feeTo);\\n        return (ownerFee, feeTo);\\n    }\\n\\n    /**\\n     * @dev Disable specific contract address to swap token using brewlabs by adding it to blacklist\\n     *\\n     * Must only be called by owner\\n     */\\n\\n    function addToBlackList(address addr) external onlyOwner {\\n        require(addr != address(0), \\\"Brewlabs: invalid address\\\");\\n        isBlackListed[addr] = true;\\n        emit Blacklisted(addr);\\n    }\\n\\n    function setWhitelist(address addr, bool status) external onlyOwner {\\n        require(addr != address(0), \\\"Brewlabs: invalid address\\\");\\n        whitelist[addr] = status;\\n        emit Whitelisted(addr, status);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BrewlabsPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IBrewlabsFactory} from \\\"./interfaces/IBrewlabsFactory.sol\\\";\\nimport {IBrewlabsCallee} from \\\"./interfaces/IBrewlabsCallee.sol\\\";\\nimport {IBrewlabsNFTDiscountManager} from \\\"./interfaces/IBrewlabsNFTDiscountManager.sol\\\";\\nimport {IBrewlabsSwapFeeManager} from \\\"./interfaces/IBrewlabsSwapFeeManager.sol\\\";\\n\\nimport {UQ112x112} from \\\"./libraries/UQ112x112.sol\\\";\\nimport {BrewlabsERC20} from \\\"./BrewlabsERC20.sol\\\";\\n\\ncontract BrewlabsPair is BrewlabsERC20 {\\n    using UQ112x112 for uint224;\\n\\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n    address public stakingPool;\\n\\n    bool public initialized;\\n\\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\\n    uint256 public constant DISCOUNT_MAX = 10_000;\\n    uint256 public constant MAX_FEE_PERCENT = 320_000; // = 32%\\n\\n    uint32 public feePercent = 3_000; // default = 0.3%  // uses single storage slot, accessible via getReserves\\n\\n    uint256 public precisionMultiplier0;\\n    uint256 public precisionMultiplier1;\\n\\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n    bool public stableSwap; // if set to true, defines pair type as stable\\n    bool public pairTypeImmutable; // if set to true, stableSwap states cannot be updated anymore\\n\\n    uint256 private unlocked = 1;\\n\\n    struct SwapFeeConstraint {\\n        uint256 realFee;\\n        uint256 operationFee;\\n        uint256 remainingFee;\\n    }\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    event Skim();\\n\\n    event SetFeePercent(uint32 feePercent);\\n    event SetPairTypeImmutable();\\n    event SetStableSwap(bool prevStableSwap, bool stableSwap);\\n    event RecoverWrongToken(address indexed token, address to);\\n\\n    modifier lock() {\\n        require(unlocked == 1, \\\"Brewlabs: LOCKED\\\");\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    constructor() {\\n        factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory && !initialized, \\\"Brewlabs: FORBIDDEN\\\");\\n        // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n\\n        precisionMultiplier0 = 10 ** uint256(IERC20(_token0).decimals());\\n        precisionMultiplier1 = 10 ** uint256(IERC20(_token1).decimals());\\n\\n        initialized = true;\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (uint112 _reserve0, uint112 _reserve1, uint32 _feePercent, uint32 _blockTimestampLast)\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _feePercent = feePercent;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(address token, address to, uint256 value) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Brewlabs: TRANSFER_FAILED\\\");\\n    }\\n\\n    // update reserves\\n    function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private {\\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \\\"Brewlabs: OVERFLOW\\\");\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            unchecked {\\n                // * never overflows, and + overflow is desired\\n                price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n                price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n            }\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(uint112(balance0), uint112(balance1));\\n    }\\n\\n    // if fee is on, mint liquidity equivalent to \\\"factory.ownerFee()\\\" of the growth in sqrt(k)\\n    // only for uni configuration\\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\\n        if (stableSwap) return false;\\n\\n        (uint256 ownerFee, address feeTo) = IBrewlabsFactory(factory).feeInfo();\\n        feeOn = feeTo != address(0);\\n        uint256 _kLast = kLast;\\n        // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint256 rootK = Math.sqrt(_k(uint256(_reserve0), uint256(_reserve1)));\\n                uint256 rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint256 d = (FEE_DENOMINATOR * 100 / ownerFee) - 100;\\n                    uint256 numerator = totalSupply * (rootK - rootKLast) * 100;\\n                    uint256 denominator = rootK * d + (rootKLast * 100);\\n                    uint256 liquidity = numerator / denominator;\\n                    if (liquidity > 0) _mint(feeTo, liquidity);\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal override {\\n        super._transfer(from, to, value);\\n\\n        address feeMgr = IBrewlabsFactory(factory).feeManager();\\n        if (feeMgr != address(0x0)) {\\n            IBrewlabsSwapFeeManager(feeMgr).lpTransferred(from, to, value, address(this), token0, token1);\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external lock returns (uint256 liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1,,) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n        uint256 amount0 = balance0 - _reserve0;\\n        uint256 amount1 = balance1 - _reserve1;\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\\n            _mint(address(0), MINIMUM_LIQUIDITY);\\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = Math.min(amount0 * _totalSupply / _reserve0, amount1 * _totalSupply / _reserve1);\\n        }\\n        require(liquidity > 0, \\\"Brewlabs: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = _k(uint256(reserve0), uint256(reserve1));\\n        // reserve0 and reserve1 are up-to-date\\n        emit Mint(msg.sender, amount0, amount1);\\n\\n        address feeMgr = IBrewlabsFactory(factory).feeManager();\\n        if (feeMgr != address(0x0)) {\\n            IBrewlabsSwapFeeManager(feeMgr).lpMinted(to, liquidity, address(this), token0, token1);\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\\n        (uint112 _reserve0, uint112 _reserve1,,) = getReserves(); // gas savings\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        amount0 = liquidity * balance0 / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity * balance1 / _totalSupply; // using balances ensures pro-rata distribution\\n        require(amount0 > 0 && amount1 > 0, \\\"Brewlabs: INSUFFICIENT_LIQUIDITY_BURNED\\\");\\n\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = _k(uint256(reserve0), uint256(reserve1)); // reserve0 and reserve1 are up-to-date\\n        emit Burn(msg.sender, amount0, amount1, to);\\n\\n        address feeMgr = IBrewlabsFactory(factory).feeManager();\\n        if (feeMgr != address(0x0)) {\\n            IBrewlabsSwapFeeManager(feeMgr).lpBurned(to, liquidity, address(this), token0, token1);\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {\\n        require(IBrewlabsFactory(factory).isAllowedToSwap(msg.sender), \\\"BrewlabsRouter: NOT_ALLOWED_TO_SWAP\\\");\\n        require(amount0Out > 0 || amount1Out > 0, \\\"Brewlabs: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n        require(to != token0 && to != token1, \\\"Brewlabs: INVALID_TO\\\");\\n\\n        (uint112 _reserve0, uint112 _reserve1, uint32 _feePercent,) = getReserves();\\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \\\"Brewlabs: INSUFFICIENT_LIQUIDITY\\\");\\n\\n        // optimistically transfer tokens\\n        if (amount0Out > 0) _safeTransfer(token0, to, amount0Out);\\n        if (amount1Out > 0) _safeTransfer(token1, to, amount1Out);\\n        if (data.length > 0) {\\n            IBrewlabsCallee(to).brewlabsCall(msg.sender, amount0Out, amount1Out, data);\\n        }\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n\\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In > 0 || amount1In > 0, \\\"Brewlabs: INSUFFICIENT_INPUT_AMOUNT\\\");\\n\\n        SwapFeeConstraint memory constraint;\\n        {\\n            uint256 discount = getDiscount(to);\\n\\n            // scope for fee management\\n            if (!IBrewlabsFactory(factory).isWhitelisted(to)) {\\n                constraint.realFee = uint256(_feePercent) * (DISCOUNT_MAX - discount) / DISCOUNT_MAX;\\n                (constraint.remainingFee, constraint.operationFee) =\\n                    _distributeFees(amount0In, amount1In, constraint.realFee);\\n            } else {\\n                constraint.operationFee = 1;\\n            }\\n        }\\n        // readjust tokens balance\\n        if (amount0In > 0) balance0 = IERC20(token0).balanceOf(address(this));\\n        if (amount1In > 0) balance1 = IERC20(token1).balanceOf(address(this));\\n        {\\n            uint256 remainingFee0 =\\n                amount0In * constraint.realFee * constraint.remainingFee / (FEE_DENOMINATOR * constraint.operationFee);\\n            uint256 remainingFee1 =\\n                amount1In * constraint.realFee * constraint.remainingFee / (FEE_DENOMINATOR * constraint.operationFee);\\n            uint256 balance0Adjusted = balance0 - remainingFee0;\\n            uint256 balance1Adjusted = balance1 - remainingFee1;\\n            require(_k(balance0Adjusted, balance1Adjusted) >= _k(uint256(_reserve0), uint256(_reserve1)), \\\"Brewlabs: K\\\");\\n        }\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        {\\n            // scope for _amountOut{0,1}, avoids stack too deep errors\\n            uint256 _amount0Out = amount0Out;\\n            uint256 _amount1Out = amount1Out;\\n            emit Swap(msg.sender, amount0In, amount1In, _amount0Out, _amount1Out, to);\\n        }\\n    }\\n\\n    function _distributeFees(uint256 amount0In, uint256 amount1In, uint256 realFee)\\n        internal\\n        returns (uint256, uint256)\\n    {\\n        address feeMgr = IBrewlabsFactory(factory).feeManager();\\n        if (feeMgr == address(0)) return (1, 1);\\n\\n        (uint256 operationFee,, uint256 brewlabsFee,, uint256 stakingFee,) =\\n            IBrewlabsSwapFeeManager(feeMgr).getFeeDistribution(address(this));\\n        uint256 remainingFee = brewlabsFee + stakingFee;\\n        uint256 fee = 0;\\n        {\\n            uint256 _amount0In = amount0In;\\n            if (_amount0In > 0) {\\n                uint256 _realFee = _amount0In * realFee / FEE_DENOMINATOR;\\n                fee = _realFee * (operationFee - remainingFee) / operationFee;\\n                IERC20(token0).approve(feeMgr, fee);\\n                IBrewlabsSwapFeeManager(feeMgr).notifyRewardAmount(address(this), token0, token1, fee, 0);\\n                // staking fee distribution\\n                if (stakingFee > 0 && stakingPool != address(0)) {\\n                    fee = _realFee * stakingFee / operationFee;\\n                    _safeTransfer(token0, stakingPool, fee);\\n                    remainingFee = remainingFee - stakingFee;\\n                }\\n            }\\n        }\\n        {\\n            uint256 _amount1In = amount1In;\\n            if (_amount1In > 0) {\\n                uint256 _realFee = _amount1In * realFee / FEE_DENOMINATOR;\\n                fee = _realFee * (operationFee - remainingFee) / operationFee;\\n                IERC20(token1).approve(feeMgr, fee);\\n                IBrewlabsSwapFeeManager(feeMgr).notifyRewardAmount(address(this), token0, token1, 0, fee);\\n                // staking fee distribution\\n                if (stakingFee > 0 && stakingPool != address(0)) {\\n                    fee = _realFee * stakingFee / operationFee;\\n                    _safeTransfer(token1, stakingPool, fee);\\n                    remainingFee = remainingFee - stakingFee;\\n                }\\n            }\\n        }\\n        return (remainingFee, operationFee);\\n    }\\n\\n    function _k(uint256 balance0, uint256 balance1) internal view returns (uint256) {\\n        if (stableSwap) {\\n            uint256 _x = balance0 * 1e18 / precisionMultiplier0;\\n            uint256 _y = balance1 * 1e18 / precisionMultiplier1;\\n            uint256 _a = _x * _y / 1e18;\\n            uint256 _b = _x * _x / 1e18 + _y * _y / 1e18;\\n            return _a * _b / 1e18; // x3y+y3x >= k\\n        }\\n        return balance0 * balance1;\\n    }\\n\\n    function _get_x(uint256 x, uint256 xy, uint256 y0) internal pure returns (uint256) {\\n        for (uint256 i = 0; i < 255; i++) {\\n            uint256 x_prev = x;\\n            uint256 k = _f(x, y0);\\n            if (k < xy) {\\n                uint256 dx = ((xy - k) * 1e18) / _d(y0, x);\\n                x = x + dx;\\n            } else {\\n                uint256 dx = ((k - xy) * 1e18) / _d(y0, x);\\n                x = x - dx;\\n            }\\n            if (x > x_prev) {\\n                if (x - x_prev <= 1) {\\n                    return x;\\n                }\\n            } else {\\n                if (x_prev - x <= 1) {\\n                    return x;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n\\n    function _get_y(uint256 x0, uint256 xy, uint256 y) internal pure returns (uint256) {\\n        for (uint256 i = 0; i < 255; i++) {\\n            uint256 y_prev = y;\\n            uint256 k = _f(x0, y);\\n            if (k < xy) {\\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\\n                y = y + dy;\\n            } else {\\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\\n                y = y - dy;\\n            }\\n            if (y > y_prev) {\\n                if (y - y_prev <= 1) {\\n                    return y;\\n                }\\n            } else {\\n                if (y_prev - y <= 1) {\\n                    return y;\\n                }\\n            }\\n        }\\n        return y;\\n    }\\n\\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\\n        return (x0 * ((((y * y) / 1e18) * y) / 1e18)) / 1e18 + (((((x0 * x0) / 1e18) * x0) / 1e18) * y) / 1e18;\\n    }\\n\\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\\n        return (3 * x0 * ((y * y) / 1e18)) / 1e18 + ((((x0 * x0) / 1e18) * x0) / 1e18);\\n    }\\n\\n    function getDiscount(address addr) internal view returns (uint256 discount) {\\n        address discountMgr = IBrewlabsFactory(factory).discountMgr();\\n        if (discountMgr != address(0)) {\\n            discount = IBrewlabsNFTDiscountManager(discountMgr).discountOf(addr);\\n        } else {\\n            discount = 0;\\n        }\\n    }\\n\\n    function getAmountOut(uint256 amountIn, address tokenIn, uint256 discount) external view returns (uint256) {\\n        require(amountIn > 0, \\\"Brewlabs: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(reserve0 > 0 && reserve1 > 0, \\\"Brewlabs: INSUFFICIENT_LIQUIDITY\\\");\\n        return _getAmountOut(\\n            amountIn,\\n            tokenIn,\\n            uint256(reserve0),\\n            uint256(reserve1),\\n            uint256(feePercent) * (DISCOUNT_MAX - discount) / DISCOUNT_MAX\\n        );\\n    }\\n\\n    function getAmountIn(uint256 amountOut, address tokenIn, uint256 discount) external view returns (uint256) {\\n        require(amountOut > 0, \\\"Brewlabs: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(reserve0 > 0 && reserve1 > 0, \\\"Brewlabs: INSUFFICIENT_LIQUIDITY\\\");\\n        return _getAmountIn(\\n            amountOut,\\n            tokenIn,\\n            uint256(reserve0),\\n            uint256(reserve1),\\n            uint256(feePercent) * (DISCOUNT_MAX - discount) / DISCOUNT_MAX\\n        );\\n    }\\n\\n    function _getAmountOut(uint256 amountIn, address tokenIn, uint256 _reserve0, uint256 _reserve1, uint256 _feePercent)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        if (stableSwap) {\\n            amountIn = amountIn - (amountIn * _feePercent / FEE_DENOMINATOR); // remove fee from amount received\\n            uint256 xy = _k(_reserve0, _reserve1);\\n            _reserve0 = _reserve0 * 1e18 / precisionMultiplier0;\\n            _reserve1 = _reserve1 * 1e18 / precisionMultiplier1;\\n\\n            (uint256 reserveIn, uint256 reserveOut) =\\n                tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\\n            amountIn =\\n                tokenIn == token0 ? amountIn * 1e18 / precisionMultiplier0 : amountIn * 1e18 / precisionMultiplier1;\\n            uint256 y = reserveOut - _get_y(amountIn + reserveIn, xy, reserveOut);\\n            return y * (tokenIn == token0 ? precisionMultiplier1 : precisionMultiplier0) / 1e18;\\n        } else {\\n            (uint256 reserveIn, uint256 reserveOut) =\\n                tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\\n            amountIn = amountIn * (FEE_DENOMINATOR - _feePercent);\\n            return (amountIn * reserveOut) / (reserveIn * FEE_DENOMINATOR + amountIn);\\n        }\\n    }\\n\\n    function _getAmountIn(uint256 amountOut, address tokenIn, uint256 _reserve0, uint256 _reserve1, uint256 _feePercent)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        if (stableSwap) {\\n            uint256 xy = _k(_reserve0, _reserve1);\\n            _reserve0 = (_reserve0 * 1e18) / precisionMultiplier0;\\n            _reserve1 = (_reserve1 * 1e18) / precisionMultiplier1;\\n\\n            (uint256 reserveIn, uint256 reserveOut) =\\n                tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\\n            amountOut = tokenIn == token0\\n                ? (amountOut * 1e18) / precisionMultiplier0\\n                : (amountOut * 1e18) / precisionMultiplier1;\\n            uint256 x = _get_x(reserveIn, xy, reserveOut - amountOut) - reserveIn;\\n            return ((x * (tokenIn == token0 ? precisionMultiplier0 : precisionMultiplier1)) / 1e18) * FEE_DENOMINATOR\\n                / (FEE_DENOMINATOR - _feePercent);\\n        } else {\\n            (uint256 reserveIn, uint256 reserveOut) =\\n                tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\\n            uint256 numerator = reserveIn * amountOut * FEE_DENOMINATOR;\\n            uint256 denominator = (reserveOut - (amountOut)) * (FEE_DENOMINATOR - _feePercent);\\n            return (numerator / denominator) + 1;\\n        }\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external lock {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - (reserve0));\\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - (reserve1));\\n        emit Skim();\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\\n    }\\n\\n    /**\\n     * @dev Updates the swap fees percent\\n     * Can only be called by the factory's feeManager or feePercentOwner\\n     */\\n    function setFeePercent(uint32 newfeePercent) external lock {\\n        address feeMgr = IBrewlabsFactory(factory).feeManager();\\n\\n        if (feeMgr == address(0)) {\\n            require(\\n                msg.sender == IBrewlabsFactory(factory).feePercentOwner(), \\\"Brewlabs: only factory's feePercentOwner\\\"\\n            );\\n        } else {\\n            require(msg.sender == feeMgr, \\\"Brewlabs: only factory's feeManager\\\");\\n        }\\n\\n        require(newfeePercent <= MAX_FEE_PERCENT, \\\"Brewlabs: feePercent mustn't exceed the maximum\\\");\\n        require(newfeePercent > 0, \\\"Brewlabs: feePercent mustn't exceed the minimum\\\");\\n        feePercent = newfeePercent;\\n        emit SetFeePercent(newfeePercent);\\n    }\\n\\n    function setStableSwap(bool stable, uint112 expectedReserve0, uint112 expectedReserve1) external lock {\\n        address feeMgr = IBrewlabsFactory(factory).feeManager();\\n        if (feeMgr == address(0)) {\\n            require(msg.sender == IBrewlabsFactory(factory).setStableOwner(), \\\"Brewlabs: only factory's setStableOwner\\\");\\n        } else {\\n            require(msg.sender == feeMgr, \\\"Brewlabs: only factory's feeManager\\\");\\n        }\\n        require(!pairTypeImmutable, \\\"Brewlabs: immutable\\\");\\n\\n        require(stable != stableSwap, \\\"Brewlabs: no update\\\");\\n        require(expectedReserve0 == reserve0 && expectedReserve1 == reserve1, \\\"Brewlabs: failed\\\");\\n\\n        emit SetStableSwap(stableSwap, stable);\\n        stableSwap = stable;\\n        kLast = _k(uint256(reserve0), uint256(reserve1));\\n    }\\n\\n    function setStakingPool(address _stakingPool) external lock {\\n        address feeMgr = IBrewlabsFactory(factory).feeManager();\\n        if (feeMgr == address(0)) {\\n            require(msg.sender == IBrewlabsFactory(factory).owner(), \\\"Brewlabs: only factory's owner\\\");\\n        } else {\\n            require(msg.sender == feeMgr, \\\"Brewlabs: only factory's feeManager\\\");\\n        }\\n        require(_stakingPool != address(0), \\\"Brewlabs: invalid staking pool address\\\");\\n        stakingPool = _stakingPool;\\n    }\\n\\n    function setPairTypeImmutable() external lock {\\n        require(msg.sender == IBrewlabsFactory(factory).owner(), \\\"Brewlabs: only factory's owner\\\");\\n        require(!pairTypeImmutable, \\\"Brewlabs: already immutable\\\");\\n\\n        pairTypeImmutable = true;\\n        emit SetPairTypeImmutable();\\n    }\\n\\n    /**\\n     * @dev Allow to recover token sent here by mistake\\n     * Can only be called by factory's owner\\n     */\\n    function rescueWrongToken(address token, address to) external lock {\\n        require(msg.sender == IBrewlabsFactory(factory).owner(), \\\"Brewlabs: only factory's owner\\\");\\n        require(token != token0 && token != token1, \\\"Brewlabs: invalid token\\\");\\n\\n        if (token == address(0)) {\\n            (bool sent,) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n            require(sent, \\\"Failed to recover native token\\\");\\n        } else {\\n            _safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\\n        }\\n        emit RecoverWrongToken(token, to);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBrewlabsCallee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\ninterface IBrewlabsCallee {\\n    function brewlabsCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBrewlabsERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\ninterface IBrewlabsERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address owner) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBrewlabsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\ninterface IBrewlabsFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function owner() external view returns (address);\\n    function feePercentOwner() external view returns (address);\\n    function setStableOwner() external view returns (address);\\n    function feeTo() external view returns (address);\\n\\n    function discountMgr() external view returns (address);\\n    function feeManager() external view returns (address);\\n\\n    function ownerFee() external view returns (uint256);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function feeInfo() external view returns (uint256 _ownerFee, address _feeTo);\\n\\n    function isAllowedToSwap(address) external view returns (bool);\\n    function isWhitelisted(address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBrewlabsNFTDiscountManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\ninterface IBrewlabsNFTDiscountManager {\\n    function discountOf(address _to) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBrewlabsSwapFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\ninterface IBrewlabsSwapFeeManager {\\n    event Claimed(address indexed to, address indexed pair, uint256 amount0, uint256 amount1);\\n\\n    function getFeeDistribution(address pair)\\n        external\\n        view\\n        returns (uint256, uint256, uint256, uint256, uint256, uint256);\\n    function pendingLPRewards(address pair, address staker) external view returns (uint256, uint256);\\n    function createPool(address token0, address token1) external;\\n    function claim(address pair) external;\\n    function claimAll(address[] calldata pairs) external;\\n    function lpMinted(address to, uint256 amount, address pair, address token0, address token1) external;\\n    function lpBurned(address from, uint256 amount, address pair, address token0, address token1) external;\\n    function lpTransferred(address from, address to, uint256 amount, address pair, address token0, address token1)\\n        external;\\n    function notifyRewardAmount(address pair, address token0, address token1, uint256 amount0, uint256 amount1)\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address owner) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UQ112x112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.14;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2 ** 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeTo_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevMgr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMgr\",\"type\":\"address\"}],\"name\":\"DiscountManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevMgr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMgr\",\"type\":\"address\"}],\"name\":\"FeeManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"FeePercentOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFeeTo\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"FeeToTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevOwnerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerFee\",\"type\":\"uint256\"}],\"name\":\"OwnerFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetStableOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INIT_CODE_PAIR_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OWNER_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addToBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountMgr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAllowedToSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDiscountMgr\",\"type\":\"address\"}],\"name\":\"setDiscountManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeMgr\",\"type\":\"address\"}],\"name\":\"setFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feePercentOwner\",\"type\":\"address\"}],\"name\":\"setFeePercentOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeAddr\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newOwnerFee\",\"type\":\"uint256\"}],\"name\":\"setOwnerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_setStableOwner\",\"type\":\"address\"}],\"name\":\"setSetStableOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStableOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BrewlabsFactory", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e1f1dd010bbc2860f81c8f90ea4e38db949bb16f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}