{"SourceCode": "//SPDX-License-Identifier: MIT\r\n//import \"hardhat/console.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n  // Empty internal constructor, to prevent people from mistakenly deploying\r\n  // an instance of this contract, which should be used via inheritance.\r\n  constructor ()  { }\r\n\r\n  function _msgSender() internal view returns (address payable) {\r\n    return payable(msg.sender);\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         token interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface ERC20In{\r\n\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns(bool);\r\n\r\n }\r\n\r\ncontract owned {\r\n    address  public owner;\r\n    address public transfedOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        _setContractOwner(newOwner);\r\n    }\r\n\r\n    function _setContractOwner(address newOwner) internal {\r\n        transfedOwner = newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public virtual {\r\n        require(transfedOwner==msg.sender,\"You Dont Have Previlege To Accept\");\r\n        owner=transfedOwner;\r\n    }\r\n\r\nmodifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n   \r\n}\r\n\r\ncontract Believe_Network_Space_EcoSystem is Context , owned {\r\n\r\n\r\n  uint plannetPlanID;  // for plan entry \r\n  uint32 userID;       // for user unique ID\r\n  bool public systemLive;\r\n\r\n  uint public cycleOverTeam=126;\r\n\r\n\r\n\r\n  //============Prices==================\r\n\r\n\r\n    uint constant directSponserRate=50;\r\n    uint constant levelRate=30;\r\n    uint constant upgradeRate=50;\r\n\r\n    address tokenAddress;\r\n\r\n    uint32 index;\r\n\r\n\r\n    uint32 nextPoolParent;\r\n\r\n\r\n    struct autoPool\r\n    { \r\n        uint32 userID;\r\n        uint32 autoPoolParent;\r\n\r\n    }\r\n\r\n\r\n    struct poolCycleInfo{\r\n\r\n        uint poolCycleTeam;\r\n        bool isFullCycleCompleted;\r\n        bool isLevelActive;\r\n\r\n    }\r\n\r\n\r\n   struct userInfo {\r\n\r\n        uint32      id;             // user id.\r\n        uint32      partnersCount;   // partner Count\r\n        address     referrer;       // user sponser address. \r\n        uint32      recentPackage;  // \r\n        bool        incomeBlocked;  \r\n   \r\n        mapping(uint=>uint) plannetPurchase; // this will contain plannet id with number of time they purchase \r\n\r\n        mapping(uint=>poolCycleInfo) poolCycleInfos;\r\n       \r\n    }\r\n\r\n\r\n    // -----------------------MAPPING DATA STORAGE-------------------\r\n\r\n\r\n\r\n    struct poolInfo {\r\n\r\n        uint32 nextPoolParent;\r\n        uint fillLeg;\r\n    }\r\n\r\n\r\n    mapping(uint=>uint) public plannetPlans;\r\n\r\n    mapping(address=>userInfo) public userInfos;\r\n\r\n    mapping(uint=>address) public userAddressByID;\r\n\r\n    mapping(uint=>uint) public distLevelPrice;\r\n\r\n\r\n    mapping(uint=>autoPool[]) public autoPoolDataList;  // package=>level=>data\r\n\r\n    // uint[6] nextPoolParent;\r\n\r\n    mapping(uint=>poolInfo) public poolInfos;\r\n    \r\n\r\n\r\n//--------------------------------EVENT SECTION --------------------------------------\r\n\r\n\r\n      // FINANCIAL EVENT\r\n    event regUserEv(address user, address referral,uint id);\r\n    event sponsorDirectEv(address from_user,address to_user,uint amount);\r\n\r\n    event plannetBuy(address user, uint plannetId);\r\n\r\n    event levelEv(address _from , address _to,uint level,uint amount);\r\n\r\n    event incomeLost(address _user,uint amount);\r\n\r\n    event upgradeEv(address _from , address _to,uint level,uint amount);\r\n\r\n    event autopoolPosition(uint level, uint index,uint32 parent,address immediateParentAddress);\r\n\r\n    event autoPoolPayEv (uint timestamp, uint level,address receiver, address paidFrom, uint amount);\r\n\r\n  \r\n\r\n    event newPlanEv(uint planID,uint planAmount);\r\n\r\n    event Oldadd_UserEv(address _newuseradd, address _olduseradd);\r\n\r\n\r\n    constructor(address _defaultUser, address token){\r\n        owner = _defaultUser;\r\n        tokenAddress = token;\r\n\r\n        systemLive=true;\r\n\r\n        //------default plannet plans with price ---------------\r\n\r\n        userID++;\r\n\r\n        userInfos[_defaultUser].id = userID; \r\n    \r\n        userAddressByID[userID] = _defaultUser;\r\n\r\n     \r\n\r\n        for (uint i=1;i<=10;i++){\r\n\r\n             autoPoolPosition(_defaultUser,i,true);\r\n\r\n             userInfos[_defaultUser].poolCycleInfos[i].isLevelActive=true;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n        distLevelPrice[1]= 0.10 ether;\r\n        distLevelPrice[2]= 0.09 ether;\r\n        distLevelPrice[3]= 0.08 ether;\r\n        distLevelPrice[4]= 0.07 ether;\r\n        distLevelPrice[5]= 0.06 ether;\r\n        distLevelPrice[6]= 0.05 ether;\r\n        distLevelPrice[7]= 0.05 ether;\r\n        distLevelPrice[8]= 0.05 ether;\r\n        distLevelPrice[9]= 0.05 ether;\r\n        distLevelPrice[10]= 0.05 ether;\r\n        distLevelPrice[11]= 0.15 ether;\r\n        distLevelPrice[12]= 0.15 ether;\r\n        distLevelPrice[13]= 0.15 ether;\r\n        distLevelPrice[14]= 0.20 ether;\r\n        distLevelPrice[15]= 0.20 ether;\r\n\r\n\r\n\r\n\r\n        for (uint i=1;i<=10;i++){\r\n\r\n\r\n            uint lastPlanAmount = plannetPlans[plannetPlanID];\r\n\r\n            plannetPlanID++;\r\n\r\n\r\n            if (i%3==0){ \r\n\r\n                plannetPlans[plannetPlanID]=(lastPlanAmount*2)+(lastPlanAmount/2);\r\n\r\n            }else {\r\n\r\n                plannetPlans[plannetPlanID]=lastPlanAmount<1?5e18:(lastPlanAmount*2);\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    // function UpdateByOwn(address _oldwallet,address _newwallet) public onlyOwner returns(bool){\r\n    //     require(_oldwallet!=address(0),\"Invalid Wallet Address\");\r\n    //     require(_newwallet!=address(0),\"Invalid Wallet Address\");\r\n    //     require(_oldwallet!=_newwallet,\"Unable To Set New Wallet Same As Old Wallet\");\r\n        \r\n    //     userInfos[_oldwallet].id=0;\r\n    //     userInfos[_newwallet].id=userInfos[_oldwallet].id;\r\n    //     userAddressByID[userInfos[_oldwallet].id]=_newwallet;\r\n    //     return true;\r\n    // }\r\n\r\n    function UpdateByOwn(address _oldwallet,address _newwallet) public onlyOwner returns(bool){\r\n        require(_oldwallet!=address(0),\"Invalid Wallet Address\");\r\n        require(_newwallet!=address(0),\"Invalid Wallet Address\");\r\n        require(_oldwallet!=_newwallet,\"Unable To Set New Wallet Same As Old Wallet\");\r\n        require(userInfos[_oldwallet].id!=0,\"Already Removed The Wallet\");\r\n    \r\n\r\n\r\n        userInfos[_newwallet].id=userInfos[_oldwallet].id;\r\n        userInfos[_newwallet].partnersCount=userInfos[_oldwallet].partnersCount;\r\n        userInfos[_newwallet].referrer=userInfos[_oldwallet].referrer;\r\n        userInfos[_newwallet].recentPackage=userInfos[_oldwallet].recentPackage;\r\n        userInfos[_newwallet].incomeBlocked=userInfos[_oldwallet].incomeBlocked;\r\n\r\n       \r\n\r\n        for(uint i=1;i<=10;i++){\r\n            userInfos[_newwallet].plannetPurchase[i]=userInfos[_oldwallet].plannetPurchase[i];\r\n            userInfos[_newwallet].poolCycleInfos[i]=userInfos[_oldwallet].poolCycleInfos[i];\r\n        }\r\n\r\n        userAddressByID[userInfos[_newwallet].id] =_newwallet;\r\n        \r\n        delete userInfos[_oldwallet];\r\n\r\n        emit Oldadd_UserEv(_newwallet, _oldwallet);\r\n        return true;\r\n    }\r\n\r\n\r\n    //----------------------------For receving matic--------------------------------------\r\n\r\n    fallback () external {\r\n\r\n\r\n    }\r\n\r\n\r\n    receive () external payable {\r\n        \r\n    }\r\n\r\n\r\n\r\n    //===============REGISTRAION======================>\r\n\r\n\r\n    function registrations( address referrerAddress) public payable {  \r\n\r\n        address userAddress = _msgSender();  \r\n        uint registrationFee = 0.002 ether;\r\n        \r\n        if(_msgSender() != owner)\r\n        {\r\n             require(systemLive,\"Operation aborted\");\r\n        }\r\n\r\n        require(!isUserExists(userAddress) && isUserExists(referrerAddress), \"user already exisit/invalid referral\");\r\n        require(tokenAddress!=address(0),\"Please set token address first\");\r\n        require(registrationFee==msg.value,\"insufficient fee\");\r\n        \r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        require(size == 0, \"Invalid User wallet\");\r\n\r\n\r\n        userID++;\r\n        \r\n        userInfos[userAddress].id = userID; \r\n        userInfos[userAddress].referrer = referrerAddress;\r\n        userAddressByID[userID] = userAddress;\r\n                \r\n        userInfos[referrerAddress].partnersCount++;\r\n\r\n        // receiveFund(userAddress,registrationFee);\r\n\r\n        payable(userAddressByID[1]).transfer(registrationFee);\r\n\r\n        //transferIncome(userAddressByID[1],registrationFee); // send to \r\n\r\n        emit regUserEv(userAddress, referrerAddress,userID);\r\n      \r\n    }\r\n\r\n    function reregistrations( address referrerAddress) internal {  \r\n\r\n        address userAddress = _msgSender();  \r\n        \r\n\r\n        \r\n        require(tokenAddress!=address(0),\"Please set token address first\");\r\n        \r\n        \r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        require(size == 0, \"Invalid User wallet\");\r\n\r\n        userAddressByID[userInfos[userAddress].id]=userAddressByID[1];\r\n        userID++;\r\n       \r\n        userInfos[userAddress].id = userID; \r\n        userInfos[userAddress].referrer = referrerAddress;\r\n        userAddressByID[userID] = userAddress;\r\n                \r\n        userInfos[referrerAddress].partnersCount++;\r\n\r\n       \r\n\r\n        emit regUserEv(userAddress, referrerAddress,userID);\r\n      \r\n    }\r\n\r\n    function registrations_User( address referrerAddress, address MemberAddress) public payable {  \r\n\r\n        address userAddress = MemberAddress;  \r\n        uint registrationFee = 0.002 ether;\r\n\r\n        if(_msgSender() != owner)\r\n        {\r\n             require(systemLive,\"Operation aborted\");\r\n        }\r\n\r\n        require(!isUserExists(userAddress) && isUserExists(referrerAddress), \"user already exisit/invalid referral\");\r\n        require(tokenAddress!=address(0),\"Please set token address first\");\r\n        require(registrationFee==msg.value,\"insufficient fee\");\r\n        \r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        require(size == 0, \"Invalid User wallet\");\r\n\r\n\r\n        userID++;\r\n        \r\n        userInfos[userAddress].id = userID; \r\n        userInfos[userAddress].referrer = referrerAddress;\r\n        userAddressByID[userID] = userAddress;\r\n                \r\n        userInfos[referrerAddress].partnersCount++;\r\n\r\n        // receiveFund(userAddress,registrationFee);\r\n\r\n        payable(userAddressByID[1]).transfer(registrationFee);\r\n\r\n        //transferIncome(userAddressByID[1],registrationFee); // send to \r\n\r\n        emit regUserEv(userAddress, referrerAddress,userID);\r\n      \r\n    }\r\n\r\n\r\n\r\n    function buyPlannet(uint32 plannetID) public  returns(bool){\r\n\r\n        //require(systemLive,\"Operation aborted\");\r\n         if(_msgSender() != owner)\r\n        {\r\n             require(systemLive,\"Operation aborted\");\r\n        }\r\n        \r\n        require(isUserExists(_msgSender()),\"You are not Joined\");\r\n        \r\n\r\n        uint lastLevel = userInfos[_msgSender()].recentPackage;\r\n\r\n        require(userInfos[_msgSender()].poolCycleInfos[plannetID].isFullCycleCompleted || userInfos[_msgSender()].plannetPurchase[plannetID]==0,\"You can't buy new package untill cycle over\");\r\n\r\n\r\n        if (userInfos[_msgSender()].poolCycleInfos[plannetID].isFullCycleCompleted){\r\n\r\n            userInfos[_msgSender()].poolCycleInfos[plannetID].isFullCycleCompleted=false;\r\n            userInfos[_msgSender()].poolCycleInfos[plannetID].poolCycleTeam=0; // reset poolcycle\r\n\r\n            userInfos[_msgSender()].incomeBlocked=false;\r\n\r\n            reregistrations(userInfos[_msgSender()].referrer);\r\n        }\r\n     \r\n        require( plannetID>0 && plannetID <= plannetPlanID && plannetID<=lastLevel+1 , \"Invalid level\");\r\n       \r\n       require(tokenAddress!=address(0),\"Please set token address first\");\r\n\r\n         uint amount = plannetPlans[plannetID];\r\n\r\n          receiveFund(_msgSender(),amount);\r\n\r\n\r\n        _buyPlannet(plannetID,false,_msgSender());\r\n\r\n        \r\n         \r\n        if (plannetID==1){\r\n\r\n             plannetLevelIncome(_msgSender());\r\n\r\n             plannetSponserIncome(amount, _msgSender());  \r\n\r\n        }else{\r\n\r\n\r\n             plannetUpgradeIncome(_msgSender(),plannetID);\r\n\r\n        }\r\n\r\n        userInfos[_msgSender()].poolCycleInfos[plannetID].isLevelActive=true;\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    function buyPlannet_user(uint32 plannetID, address MemberAddress) public  returns(bool){\r\n\r\n        if(_msgSender() != owner)\r\n        {\r\n             require(systemLive,\"Operation aborted\");\r\n        }\r\n        \r\n        require(isUserExists(MemberAddress),\"You are not Joined\");\r\n        \r\n\r\n        uint lastLevel = userInfos[MemberAddress].recentPackage;\r\n\r\n        require(userInfos[MemberAddress].poolCycleInfos[plannetID].isFullCycleCompleted || userInfos[MemberAddress].plannetPurchase[plannetID]==0,\"You can't buy new package untill cycle over\");\r\n\r\n\r\n        if (userInfos[MemberAddress].poolCycleInfos[plannetID].isFullCycleCompleted){\r\n\r\n            userInfos[MemberAddress].poolCycleInfos[plannetID].isFullCycleCompleted=false;\r\n            userInfos[MemberAddress].poolCycleInfos[plannetID].poolCycleTeam=0; // reset poolcycle\r\n            userInfos[MemberAddress].incomeBlocked=false; // re-active growth\r\n        }\r\n     \r\n        require( plannetID>0 && plannetID <= plannetPlanID && plannetID<=lastLevel+1 , \"Invalid level\");\r\n       \r\n       require(tokenAddress!=address(0),\"Please set token address first\");\r\n\r\n         uint amount = plannetPlans[plannetID];\r\n\r\n          receiveFund(_msgSender(),amount);\r\n\r\n\r\n        _buyPlannet(plannetID,false,MemberAddress);\r\n\r\n        \r\n         \r\n        if (plannetID==1){\r\n\r\n             plannetLevelIncome(MemberAddress);\r\n\r\n             plannetSponserIncome(amount, MemberAddress);  \r\n\r\n        }else{\r\n\r\n\r\n             plannetUpgradeIncome(MemberAddress,plannetID);\r\n\r\n        }\r\n\r\n        userInfos[MemberAddress].poolCycleInfos[plannetID].isLevelActive=true;\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    function _buyPlannet(uint32 pid, bool defaultReg, address _user) internal {\r\n\r\n        userInfos[_user].plannetPurchase[pid]+=1;\r\n\r\n        autoPoolPosition(_user,pid,defaultReg);\r\n\r\n        if (pid>userInfos[_user].recentPackage){\r\n\r\n              userInfos[_user].recentPackage=pid;\r\n        }\r\n\r\n\r\n        emit plannetBuy(_user,pid);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    function plannetUpgradeIncome(address user, uint pid) internal {\r\n\r\n\r\n        address receiver = userInfos[user].referrer;\r\n\r\n        uint amount = plannetPlans[pid]*upgradeRate/100;\r\n\r\n       for (uint i = 1;i<pid;i++){\r\n\r\n        \r\n           if (receiver==address(0) || userInfos[user].poolCycleInfos[pid].isFullCycleCompleted  ){\r\n\r\n               receiver= userAddressByID[1];\r\n\r\n                break;\r\n           }\r\n\r\n            receiver= userInfos[receiver].referrer;\r\n\r\n       }\r\n\r\n       \r\n\r\n        if (userInfos[receiver].plannetPurchase[pid]<1){\r\n\r\n            // receiver is not eligible\r\n\r\n            for(uint level=1;level<=10;level++){\r\n\r\n\r\n                        \r\n                if (receiver==address(0) || userInfos[user].poolCycleInfos[pid].isFullCycleCompleted  ){\r\n\r\n                    receiver= userAddressByID[1];\r\n\r\n                    break;\r\n                }else{\r\n\r\n\r\n                    if (userInfos[receiver].plannetPurchase[pid]>0){\r\n\r\n                        break;\r\n                    }\r\n                }\r\n\r\n\r\n\r\n                receiver= userInfos[receiver].referrer;\r\n\r\n            }\r\n\r\n\r\n            if (userInfos[receiver].plannetPurchase[pid]<1){\r\n\r\n                receiver= userAddressByID[1];\r\n\r\n            }\r\n\r\n\r\n        }\r\n\r\n\r\n       transferIncome(receiver,amount);\r\n       //emit\r\n\r\n       emit upgradeEv(user , receiver,pid,amount);\r\n\r\n\r\n    }\r\n\r\n\r\n    function getPackagesStatus(address _user) public view returns( bool[] memory ){\r\n\r\n            bool[] memory a = new bool[](plannetPlanID);\r\n\r\n            for(uint i=0;i<plannetPlanID;i++){\r\n\r\n                \r\n                a[i]=userInfos[_user].poolCycleInfos[i+1].isLevelActive;\r\n                    \r\n            }\r\n\r\n\r\n        return a;\r\n          \r\n\r\n    }\r\n\r\n\r\n    function getLegFillInLevel(uint level) pure public returns(uint){\r\n\r\n        if (level==1){\r\n\r\n            return 2;\r\n        }else if (level==2){\r\n\r\n            return 4;\r\n        }else if (level==3){\r\n\r\n            return 8;\r\n        }else if (level==4){\r\n\r\n            return 16;\r\n        }else if (level==5){\r\n\r\n            return 32;\r\n        }else{\r\n\r\n            return 64;\r\n        }\r\n\r\n    }\r\n\r\n    \r\n\r\n    function getAutopoolDistPrice(uint level) pure public returns(uint){\r\n        if (level>0 && level<=2){\r\n            return 10;\r\n        }else if (level>=3 && level<=6){\r\n            return 20;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n    function getPackageRecycleCount(address user ,uint packageId)  public view returns (uint) {\r\n\r\n\r\n        return userInfos[user].plannetPurchase[packageId];\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    function autoPoolPosition(address user,uint pid, bool defaultReg) internal {\r\n\r\n\r\n        autoPool memory pool; // create a local copy of autopool\r\n        pool.userID = userInfos[user].id;\r\n\r\n\r\n        (uint32 indx) = getLastMember(pid,defaultReg);\r\n\r\n        uint32 parentIndex = indx;\r\n        pool.autoPoolParent = parentIndex;  \r\n        autoPoolDataList[pid].push(pool);\r\n\r\n        if (!defaultReg){\r\n\r\n             // autoPoolPay section Here ..\r\n\r\n            uint autopoolDistRate = pid==1?20:50;\r\n\r\n            uint amount = plannetPlans[pid]*autopoolDistRate/100;\r\n\r\n            address  usr = userAddressByID[autoPoolDataList[pid][indx].userID];\r\n\r\n           \r\n            if(usr == address(0)) usr = userAddressByID[1];\r\n\r\n            if (usr != userAddressByID[1] || userInfos[usr].poolCycleInfos[pid].isFullCycleCompleted==false ){\r\n\r\n                userInfos[usr].poolCycleInfos[pid].poolCycleTeam++;\r\n            }\r\n\r\n            for(uint i=0;i<6;i++)\r\n            {\r\n                uint payAmount = amount*getAutopoolDistPrice(i+1)/100;\r\n         \r\n                emit autoPoolPayEv(block.timestamp, i+1, usr, user,payAmount);\r\n\r\n                // transfer amount as well\r\n\r\n                transferIncome(usr,payAmount); // send to \r\n\r\n                indx = autoPoolDataList[pid][indx].autoPoolParent; \r\n                usr = userAddressByID[autoPoolDataList[pid][indx].userID];\r\n\r\n                if (usr!=address(0) && usr != userAddressByID[1] && userInfos[usr].poolCycleInfos[pid].isFullCycleCompleted==false ){\r\n\r\n                    userInfos[usr].poolCycleInfos[pid].poolCycleTeam++;\r\n                }\r\n\r\n                if ( userInfos[usr].poolCycleInfos[pid].poolCycleTeam>=cycleOverTeam){\r\n\r\n                    userInfos[usr].poolCycleInfos[pid].isFullCycleCompleted=true;\r\n                    userInfos[usr].poolCycleInfos[pid].isLevelActive=false;\r\n                    userInfos[usr].incomeBlocked=true; // stop growth\r\n\r\n                }\r\n            }\r\n\r\n           \r\n        }\r\n\r\n        address imidiateParent = userAddressByID[autoPoolDataList[pid][indx].userID];\r\n\r\n        emit  autopoolPosition(pid, autoPoolDataList[pid].length ,parentIndex,imidiateParent);\r\n \r\n        \r\n    }\r\n\r\n\r\n\r\n    function autoPoolLength(uint16 pid) public view returns (uint) {\r\n\r\n            return autoPoolDataList[pid].length;  \r\n\r\n    }\r\n\r\n    function getLastMember(uint pid, bool defaultReg) internal  returns(uint32 parent){\r\n\r\n  \r\n             uint legs = poolInfos[pid].fillLeg;\r\n\r\n            uint32 oldParent = poolInfos[pid].nextPoolParent;\r\n\r\n            if (defaultReg){\r\n\r\n                return oldParent; // skip indexing for default user\r\n            }\r\n\r\n            if (legs==0){\r\n\r\n                poolInfos[pid].fillLeg=1;\r\n\r\n            }\r\n\r\n            else{\r\n\r\n                poolInfos[pid].nextPoolParent++;\r\n\r\n                poolInfos[pid].fillLeg=0;\r\n\r\n            }\r\n\r\n            return oldParent;\r\n            \r\n\r\n    }\r\n\r\n\r\n    function getPoolCycleInfos(address user , uint packageID) public view returns(bool,uint){\r\n\r\n\r\n        return (userInfos[user].poolCycleInfos[packageID].isFullCycleCompleted,userInfos[user].poolCycleInfos[packageID].poolCycleTeam);\r\n    }\r\n\r\n\r\n    function plannetSponserIncome(uint amount, address _user) internal {\r\n\r\n\r\n       address receiver =  userInfos[_user].referrer;\r\n\r\n        uint _tranferableAmnt = amount*directSponserRate/100;\r\n\r\n        if (userInfos[receiver].plannetPurchase[1]==0 || userInfos[receiver].incomeBlocked==true){\r\n\r\n\r\n             emit incomeLost(receiver,_tranferableAmnt);\r\n             transferIncome(userAddressByID[1],_tranferableAmnt);\r\n              emit sponsorDirectEv(_user,userAddressByID[1],_tranferableAmnt);\r\n\r\n        }else{\r\n\r\n                 transferIncome(receiver,_tranferableAmnt);\r\n                emit sponsorDirectEv(_user,receiver,_tranferableAmnt);\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    function plannetLevelIncome(address user) internal {\r\n\r\n        address receiver = userInfos[user].referrer;\r\n\r\n        uint amount;\r\n\r\n       for(uint i=1;i<=15;i++){\r\n\r\n           if ( (receiver==address(0) || userInfos[receiver].plannetPurchase[1]==0) || (userInfos[receiver].incomeBlocked==true) ){\r\n\r\n               \r\n                amount+=distLevelPrice[i];\r\n\r\n                emit levelEv(user, userAddressByID[1],i,distLevelPrice[i]);\r\n                emit incomeLost(receiver,distLevelPrice[i]);\r\n\r\n           }else{\r\n\r\n               transferIncome(receiver,distLevelPrice[i]);\r\n              emit levelEv(user, receiver,i,distLevelPrice[i]);\r\n\r\n           }\r\n\r\n\r\n            receiver=userInfos[receiver].referrer;\r\n           \r\n       }\r\n\r\n       if (amount>0){\r\n\r\n           transferIncome(userAddressByID[1],amount); // send fund to default id\r\n       }\r\n\r\n    }\r\n\r\n\r\n\r\n     function isUserExists(address user) public view returns (bool) {\r\n        return (userInfos[user].id != 0);\r\n    }\r\n\r\n\r\n\r\n    function transferIncome(address to , uint amount) internal{\r\n\r\n        ERC20In(tokenAddress).transfer(to,amount);\r\n\r\n    }\r\n\r\n\r\n    function receiveFund(address from, uint amount) internal{\r\n\r\n        ERC20In(tokenAddress).transferFrom(from,address(this),amount);\r\n\r\n    }\r\n\r\n\r\n   function addTokenAddress(address _token) onlyOwner public  {\r\n\r\n       require(_msgSender()==userAddressByID[1],\"invalid authentication\");\r\n\r\n       tokenAddress = _token;\r\n\r\n   }\r\n\r\n\r\n    function updatePoolCycleOverTeam(uint _team) onlyOwner public  {\r\n\r\n       cycleOverTeam = _team;\r\n\r\n   }\r\n\r\n\r\n    function systemActiveInactive() onlyOwner public  {\r\n\r\n        systemLive = !systemLive;\r\n\r\n   }\r\n\r\n\r\n    function addNewPlan(uint planAmount) public  {\r\n\r\n       require(_msgSender()==userAddressByID[1],\"invalid authentication\");\r\n\r\n       plannetPlanID++;\r\n\r\n        plannetPlans[plannetPlanID]=planAmount;\r\n\r\n        autoPoolPosition(userAddressByID[1],plannetPlanID,true);\r\n\r\n        emit newPlanEv(plannetPlanID,planAmount);\r\n\r\n   }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultUser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newuseradd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_olduseradd\",\"type\":\"address\"}],\"name\":\"Oldadd_UserEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"autoPoolPayEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"parent\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"immediateParentAddress\",\"type\":\"address\"}],\"name\":\"autopoolPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"incomeLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"levelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planAmount\",\"type\":\"uint256\"}],\"name\":\"newPlanEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plannetId\",\"type\":\"uint256\"}],\"name\":\"plannetBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"regUserEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sponsorDirectEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"upgradeEv\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldwallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newwallet\",\"type\":\"address\"}],\"name\":\"UpdateByOwn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planAmount\",\"type\":\"uint256\"}],\"name\":\"addNewPlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPoolDataList\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"userID\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"autoPoolParent\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"pid\",\"type\":\"uint16\"}],\"name\":\"autoPoolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"plannetID\",\"type\":\"uint32\"}],\"name\":\"buyPlannet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"plannetID\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"MemberAddress\",\"type\":\"address\"}],\"name\":\"buyPlannet_user\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleOverTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distLevelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getAutopoolDistPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getLegFillInLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"getPackageRecycleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getPackagesStatus\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"}],\"name\":\"getPoolCycleInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plannetPlans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfos\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"nextPoolParent\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fillLeg\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registrations\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"MemberAddress\",\"type\":\"address\"}],\"name\":\"registrations_User\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemActiveInactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transfedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"updatePoolCycleOverTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"partnersCount\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"recentPackage\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"incomeBlocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Believe_Network_Space_EcoSystem", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ebf738543ade1024f3373c415fbb0669e5de327f00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://98a8dc199df227864d08b39f4eb0611b42210093869c7a553785bef340384920"}