{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.0;\r\n\r\n interface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract ForeignToken {\r\n    function balanceOf(address _owner) virtual public returns (uint256);\r\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\r\n}\r\n\r\nabstract contract BEP20Basic {\r\n    function balanceOf(address who) public virtual returns (uint256);\r\n    function transfer(address to, uint256 value) virtual public returns (bool);\r\n}\r\n\r\nabstract contract BEP20 is BEP20Basic {\r\n    function allowance(address owner, address spender) public virtual returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) virtual public returns (bool);\r\n    function approve(address spender, uint256 value) virtual public returns (bool);\r\n}\r\n\r\ncontract TofoFinance is BEP20 {\r\n    \r\n    using SafeMath for uint256;\r\n    address owner = msg.sender;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => bool) public Claimed; \r\n\r\n    \r\n    string public constant name = \"Tofu Finance\";\r\n    string public constant symbol = \"TOFU\";\r\n    uint public constant decimals = 9;\r\n    uint256 public deadline = 1619222400 ; // 24 /Apr\r\n    uint256 private period = 172800; //2 Days\r\n    uint256 private StartSale = 1617840000; // 8 /Apr /2021 : 00:00 GMT\r\n    uint256 private round1 = StartSale + period;\r\n    uint256 private round2 = round1 + period;\r\n    uint256 private round3 = round2 + period;\r\n    uint256 private round4 = round3 + period;\r\n    uint256 private round5 = round4 + period;\r\n    uint256 private round6 = round5 + period;\r\n    uint256 private round7 = round6 + period;\r\n    uint256 private round8 = round7 + period;\r\n    uint256 public totalSupply = 10000000000e9;\r\n    uint256 public totalDistributed;\r\n    uint256 public constant requestMinimum = 0.001 ether;\r\n    uint256 public tokensPerEth = 10000000e9;\r\n    uint256 private _tFeeTotal;\r\n    uint256 public _taxFee = 2;\r\n    uint256 private _previousTaxFee = _taxFee;\r\n    uint256 public _liquidityFee = 3;\r\n    uint256 private _previousLiquidityFee = _liquidityFee;\r\n    uint public target0drop = 20000;\r\n    uint public progress0drop = 0;\r\n    uint256 public totallBurn = 0;\r\n    uint256 public totallDistribution = 0;\r\n\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Distr(address indexed to, uint256 amount);\r\n    event DistrFinished();\r\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\r\n    event TokensPerEthUpdated(uint _tokensPerEth);\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n\r\n    bool public distributionFinished = false;\r\n    \r\n    modifier canDistr() {\r\n        require(!distributionFinished);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    constructor() {\r\n        owner = 0xC8047F164033EF81aE915C745AA39bA5eb2bbFb6;\r\n        balances[owner] = balances[owner].add(totalSupply);\r\n        emit Transfer (address(this),owner,totalSupply);\r\n    }\r\n    \r\n    function setTaxFeePercent(uint256 taxFee) external onlyOwner() {\r\n        _taxFee = taxFee;\r\n    }\r\n    \r\n    function calculateTaxFee(uint256 _amount) private view returns (uint256) {\r\n        return _amount.mul(_taxFee).div(\r\n            10**2\r\n        );\r\n    }\r\n\r\n    function removeAllFee() private {\r\n        if(_taxFee == 0 && _liquidityFee == 0) return;\r\n        \r\n        _previousTaxFee = _taxFee;\r\n        _previousLiquidityFee = _liquidityFee;\r\n        \r\n        _taxFee = 0;\r\n        _liquidityFee = 0;\r\n    }    \r\n\r\n    function restoreAllFee() private {\r\n        _taxFee = _previousTaxFee;\r\n        _liquidityFee = _previousLiquidityFee;\r\n    }\r\n    \r\n    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\r\n        _liquidityFee = liquidityFee;\r\n    }    \r\n\r\n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\r\n        return _amount.mul(_liquidityFee).div(\r\n            10**2\r\n        );\r\n    }\r\n    \r\n    function transferOwnership(address payable newOwner) onlyOwner public {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function finishDistribution() onlyOwner canDistr public returns (bool) {\r\n        distributionFinished = true;\r\n        emit DistrFinished();\r\n        return true;\r\n    }\r\n    \r\n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\r\n        totalDistributed = totalDistributed.add(_amount); \r\n        balances[owner] = balances[owner].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Distr(_to, _amount);\r\n        emit Transfer(owner ,_to, _amount);\r\n\r\n        return true;\r\n    }\r\n    \r\n     function totalFees() public view returns (uint256) {\r\n        return _tFeeTotal;\r\n    }\r\n    \r\n    function Distribute(address _participant, uint _amount) onlyOwner internal {\r\n\r\n        require( _amount > 0 );      \r\n        require( totalDistributed < totalSupply );\r\n        balances[owner] = balances[owner].sub(_amount);\r\n        balances[_participant] = balances[_participant].add(_amount);\r\n        totalDistributed = totalDistributed.add(_amount);\r\n\r\n        if (totalDistributed >= totalSupply) {\r\n            distributionFinished = true;\r\n        }\r\n\r\n        // log\r\n        emit Airdrop(_participant, _amount, balances[_participant]);\r\n        emit Transfer(address(0), _participant, _amount);\r\n    }\r\n    \r\n    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \r\n        tokensPerEth = _tokensPerEth;\r\n        emit TokensPerEthUpdated(_tokensPerEth);\r\n    }\r\n           \r\n    fallback () external payable {\r\n        getTokens();\r\n     }\r\n     receive () external payable {\r\n         getTokens();\r\n     }\r\n\r\n    function getTokens() payable canDistr  public {\r\n        uint256 tokens = 0;\r\n        uint256 bonus = 0;\r\n        uint256 countbonus = 0;\r\n        uint256 MaxTX = 10 ether;\r\n        tokens = tokensPerEth.mul(msg.value) / 1 ether;  \r\n        address vault = 0x7617EB8436aC63f940ed59C3b521c57B4D4557C1;\r\n        \r\n        address investor = msg.sender;\r\n\r\n        if (msg.value >= requestMinimum && block.timestamp < deadline && block.timestamp > StartSale ){\r\n            require(msg.value <= MaxTX , \"Max Puchase Amount is 10 BNB\");\r\n            if(block.timestamp < round1 ) {\r\n                countbonus = tokens;\r\n            }else if(block.timestamp < round2 && block.timestamp > round1){\r\n                countbonus = tokens.mul(90)/100;\r\n            }else if(block.timestamp < round3 && block.timestamp > round2){\r\n                countbonus = tokens.mul(80)/100;\r\n            }else if(block.timestamp < round4 && block.timestamp > round3){\r\n                countbonus = tokens.mul(70)/100;\r\n            }else if(block.timestamp < round5 && block.timestamp > round4){\r\n                countbonus = tokens.mul(60)/100;\r\n            }else if(block.timestamp < round6 && block.timestamp > round5){\r\n                tokensPerEth = 5000000e9;\r\n                tokens =tokensPerEth.mul(msg.value) /1 ether;\r\n                countbonus = tokens.mul(50)/100;\r\n            }else if(block.timestamp < round7 && block.timestamp > round6){\r\n                tokensPerEth = 5000000e9;\r\n                tokens =tokensPerEth.mul(msg.value) /1 ether;\r\n                countbonus = tokens.mul(30)/100;\r\n            }else if(block.timestamp < round8 && block.timestamp > round7){\r\n                tokensPerEth = 5000000e9;\r\n                tokens =tokensPerEth.mul(msg.value) /1 ether;\r\n                countbonus = tokens.mul(10)/100;\r\n            }\r\n            bonus = tokens + countbonus;\r\n            \r\n            distr(investor, bonus);\r\n            payable(vault).transfer(msg.value);\r\n        }else{\r\n            countbonus = 0;\r\n            payable(vault).transfer(msg.value);\r\n\r\n          \r\n        }\r\n    \r\n        \r\n        \r\n        if (tokens == 0) {\r\n            uint256 valdrop = 5000e9;\r\n            if (Claimed[investor] == false && progress0drop <= target0drop ) {\r\n                \r\n                distr(investor, valdrop);\r\n                Claimed[investor] = true;\r\n                progress0drop++;\r\n            }else{\r\n                require( msg.value >= requestMinimum );\r\n               \r\n            }\r\n        }else{\r\n            require( msg.value >= requestMinimum );\r\n            \r\n        }\r\n\r\n        if (totalDistributed >= totalSupply) {\r\n            distributionFinished = true;\r\n        }\r\n    }\r\n    \r\n    function balanceOf(address _owner) view public override returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public override returns (bool success) {\r\n        \r\n        _transfer(msg.sender, _to , _amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public override returns (bool success) {\r\n        \r\n        _transfer(_from, _to, _amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint256 amount) private{\r\n        require(_to != address(0));\r\n        require(amount <= balances[_from]);\r\n        if (totalSupply > 5000000000e9){\r\n      \r\n        \r\n        uint256 burnFee = amount.mul(2)/100;\r\n  \r\n        uint256 newAmount = amount.sub(burnFee);\r\n        \r\n        balances[_from] = balances[_from].sub(newAmount);\r\n        balances[_to] = balances[_to].add(newAmount);\r\n        \r\n        balances[_from] = balances[_from].sub(burnFee);\r\n        balances[address(0x0)] = balances[address(0x0)].add(burnFee);\r\n        totalSupply = totalSupply.sub(burnFee);\r\n    \r\n        \r\n        \r\n        emit Burn(address(0x0) , burnFee);\r\n        emit Transfer(_from , address(0x0), burnFee);\r\n        emit Transfer(_from , _to, newAmount);\r\n            \r\n        }else{\r\n            balances[_from] = balances[_from].sub(amount);\r\n            balances[_to] = balances[_to].add(amount);\r\n            emit Transfer(_from , _to, amount);\r\n        }\r\n        \r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) view public override returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function getTokenBalance(address tokenAddress, address who) public returns (uint){\r\n        ForeignToken t = ForeignToken(tokenAddress);\r\n        uint bal = t.balanceOf(who);\r\n        return bal;\r\n    }\r\n    \r\n    function withdrawAll() onlyOwner public {\r\n      \r\n        address myAddress = address(this);\r\n        uint256 etherBalance = myAddress.balance;\r\n        payable(owner).transfer(etherBalance);\r\n    }\r\n\r\n    function withdraw(uint256 _wdamount) onlyOwner public {\r\n        uint256 wantAmount = _wdamount;\r\n        payable(owner).transfer(wantAmount);\r\n    }\r\n\r\n    function burn(uint256 _value) onlyOwner public {\r\n        _value = _value.mul(10**9);\r\n        require(_value <= balances[owner]);\r\n        balances[owner] = balances[owner].sub(_value);    \r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Transfer(owner , address(0.0), _value);\r\n        emit Burn(owner, _value);\r\n    }\r\n    \r\n    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\r\n        ForeignToken token = ForeignToken(_tokenContract);\r\n        uint256 amount = token.balanceOf(address(this));\r\n        return token.transfer(owner, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Distr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DistrFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokensPerEth\",\"type\":\"uint256\"}],\"name\":\"TokensPerEthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishDistribution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"progress0drop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taxFee\",\"type\":\"uint256\"}],\"name\":\"setTaxFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target0drop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totallBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totallDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensPerEth\",\"type\":\"uint256\"}],\"name\":\"updateTokensPerEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wdamount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TofoFinance", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e8f9377d0a96136a89edc6e1bd7b8ebce5c85b91f7ccb98053912bd98292500b"}