{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SWORDProtocol.sol\": {\r\n      \"content\": \"\\r\\n//SPDX-License-Identifier: MIT\\r\\n//9ecc02a53f8032a599c51cbc7f7c474835c40cb0e92543f7995708cce9e06df9\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    \\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function getLockedEther() external returns (uint256);\\r\\n\\r\\n    function replenishProtocol() external;\\r\\n\\r\\n    \\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    \\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ncontract SWORDProtocol {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct Position {\\r\\n        uint256 amount;\\r\\n        uint256 daily;\\r\\n        uint256 lockupDays;\\r\\n        uint256 lockupTime;\\r\\n        uint256 checkpoint;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    struct Partner {\\r\\n        uint256 referrals;\\r\\n        uint256 claimableRewards;\\r\\n        uint256 withdrawnRewards;\\r\\n        address referrer;\\r\\n    }\\r\\n\\r\\n    struct User {\\r\\n        Position[] positions;\\r\\n        Partner partners;\\r\\n        uint256 checkpoint;\\r\\n        uint256 withdrawnRewards;\\r\\n    }\\r\\n\\r\\n    modifier replenishStaking() {\\r\\n        _;\\r\\n        token.replenishProtocol();\\r\\n    }\\r\\n\\r\\n\\r\\n    uint256 constant public PERCENTS_DIVIDER = 100_000;\\r\\n    uint256 constant public TIME_STEP = 24 hours;\\r\\n\\r\\n    uint256 constant public MARKETING_FEE = 4_000; //4%\\r\\n    uint256 constant public DEV_FEE = 1_000; // 1%\\r\\n\\r\\n    uint256 constant public MIN_DAYS_LOCKUP = 7;\\r\\n    uint256 constant public MAX_DAYS_LOCKUP = 50;\\r\\n    \\r\\n    uint256 constant public TVL_BONUS_STEP = 10 ether;\\r\\n\\r\\n    uint256 public totalStaked;\\r\\n    uint256 public totalPositions;\\r\\n\\r\\n    IERC20 public token;\\r\\n\\r\\n    address private marketingFund;\\r\\n    address private dev; \\r\\n\\r\\n    mapping(address => User) public users;\\r\\n\\r\\n    event onStake(address indexed addr, uint256 amount);\\r\\n    event onClaim(address indexed addr, uint256 amount);\\r\\n    event onClaimRef(address indexed addr, uint256 amount);\\r\\n    event onUnstake(address indexed addr, uint256 amount);\\r\\n\\r\\n\\r\\n\\r\\n    constructor(address marketingAddr, address devAddr) {\\r\\n        require(!isContract(marketingAddr));\\r\\n        require(!isContract(devAddr));\\r\\n\\r\\n        marketingFund = marketingAddr;\\r\\n        dev = devAddr;\\r\\n    }\\r\\n\\r\\n    function stake(address referrer, uint256 amount, uint256 _days) public replenishStaking {\\r\\n        require(msg.sender == tx.origin, \\\"not allowed\\\");\\r\\n        require(amount > 0, \\\"wrong amount\\\");\\r\\n        require(_days >= 7 && _days <= 50, \\\"wrong lockup period\\\");\\r\\n        require(address(token) != address(0), \\\"protocol hast`t launched yet\\\");\\r\\n\\r\\n        User storage user = users[msg.sender];\\r\\n\\r\\n        token.transferFrom(msg.sender, address(this),amount);\\r\\n\\r\\n        payFee(amount);\\r\\n        recordReferral(referrer, msg.sender);\\r\\n        payRefFee(msg.sender,amount);\\r\\n\\r\\n        if(user.positions.length == 0) {\\r\\n            user.checkpoint = block.timestamp;\\r\\n        }\\r\\n\\r\\n        (uint256 _dailyPercent, uint256 _lockupTime) = getPositionData(_days);\\r\\n\\r\\n        user.positions.push(Position(amount,_dailyPercent,_days,_lockupTime,block.timestamp, true));\\r\\n\\r\\n        totalStaked = totalStaked.add(amount);\\r\\n        totalPositions = totalPositions.add(1);\\r\\n        \\r\\n\\r\\n        emit onStake(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function claim() public replenishStaking{\\r\\n        uint256 rewards = getPendingRewards(msg.sender);\\r\\n\\r\\n        require(rewards > 0, \\\"nothing to claim\\\");\\r\\n\\r\\n        users[msg.sender].checkpoint = block.timestamp;\\r\\n        users[msg.sender].withdrawnRewards = users[msg.sender].withdrawnRewards.add(rewards);\\r\\n\\r\\n        token.transfer(msg.sender,rewards);\\r\\n\\r\\n        emit onClaim(msg.sender, rewards);\\r\\n    }\\r\\n\\r\\n    function claimRef() public replenishStaking {\\r\\n        uint256 rewards = users[msg.sender].partners.claimableRewards;\\r\\n\\r\\n        require(rewards > 0, \\\"nothing to claim\\\");\\r\\n\\r\\n        users[msg.sender].partners.claimableRewards = 0;\\r\\n        users[msg.sender].partners.withdrawnRewards = users[msg.sender].partners.withdrawnRewards.add(rewards);\\r\\n\\r\\n        token.transfer(msg.sender, rewards);\\r\\n\\r\\n        emit onClaimRef(msg.sender,rewards);\\r\\n    }\\r\\n\\r\\n    function unstake(uint256 index) public replenishStaking {\\r\\n        uint256 positionsNum = users[msg.sender].positions.length;\\r\\n\\r\\n        require(index < positionsNum, \\\"wrong index\\\");\\r\\n        require(users[msg.sender].positions[index].isActive, \\\"position is not active\\\");\\r\\n        require(getUnlockTimer(msg.sender,index) == 0, \\\"position is locked\\\");\\r\\n\\r\\n        uint256 amount = users[msg.sender].positions[index].amount;\\r\\n\\r\\n        users[msg.sender].positions[index].isActive = false;\\r\\n\\r\\n        token.transfer(msg.sender,amount);\\r\\n\\r\\n        emit onUnstake(msg.sender,amount);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function launchProtocol(IERC20 _token) public {\\r\\n        require(msg.sender == dev, \\\"not allowed\\\");\\r\\n        require(address(token) == address(0), \\\"can be updated only once\\\");\\r\\n\\r\\n        token = _token;\\r\\n    }\\r\\n\\r\\n     function payFee(uint256 amount) internal {\\r\\n\\r\\n        uint256 marketingFee = amount.mul(MARKETING_FEE).div(PERCENTS_DIVIDER);\\r\\n        uint256 devFee = amount.mul(DEV_FEE).div(PERCENTS_DIVIDER);\\r\\n\\r\\n        token.transfer(marketingFund,marketingFee);\\r\\n        token.transfer(dev,devFee);\\r\\n\\r\\n    }\\r\\n\\r\\n    function recordReferral(address referrer, address sender) internal {\\r\\n\\r\\n        if(users[sender].partners.referrer == address(0)) {\\r\\n            \\r\\n            if(referrer != address(0) && sender != referrer && users[referrer].positions.length != 0) {\\r\\n                users[sender].partners.referrer = referrer;\\r\\n            } \\r\\n\\r\\n            address upline = users[sender].partners.referrer;\\r\\n\\r\\n\\r\\n            for(uint8 i = 0; i < 4; i++) {\\r\\n                    if(upline != address(0)) {\\r\\n                        users[upline].partners.referrals = users[upline].partners.referrals.add(1);\\r\\n                        upline = users[upline].partners.referrer;\\r\\n                    } else break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function payRefFee(address sender, uint256 value) internal {\\r\\n\\r\\n        if (users[sender].partners.referrer != address(0)) {\\r\\n\\r\\n\\t\\t\\taddress upline = users[sender].partners.referrer;\\r\\n\\r\\n\\t\\t\\tfor (uint8 i = 0; i < 4; i++) {  \\r\\n\\t\\t\\t\\tif (upline != address(0)) {\\r\\n\\t\\t\\t\\t\\r\\n    \\t\\t\\t\\tuint256 amount = value.mul(getRefRewards(i)).div(PERCENTS_DIVIDER);\\r\\n    \\t\\t\\t\\t\\t\\r\\n    \\t\\t\\t\\tusers[upline].partners.claimableRewards = users[upline].partners.claimableRewards.add(amount); \\r\\n\\t\\t\\t\\t    \\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tupline = users[upline].partners.referrer;\\r\\n\\t\\t\\t\\t} else break;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n    }\\r\\n\\r\\n    function getPositionData(uint256 _days) public returns(uint256 _dailyPercent, uint256 _lockupTime) {\\r\\n        uint256 baseDailyPercent = getDailyPercent(_days);\\r\\n        uint256 tvlBonusPercent = getTvlBonus();\\r\\n        _dailyPercent = baseDailyPercent.add(tvlBonusPercent);\\r\\n        _lockupTime = block.timestamp.add(_days.mul(24 hours));\\r\\n    }\\r\\n\\r\\n    function getUnlockTimer(address addr, uint256 index) public view returns(uint256) {\\r\\n        return block.timestamp >= users[addr].positions[index].lockupTime ? 0 : users[addr].positions[index].lockupTime.sub(block.timestamp);\\r\\n    }\\r\\n\\r\\n   \\r\\n    function getPendingRewards(address addr) public view returns(uint256) {\\r\\n\\r\\n        User storage user = users[addr];\\r\\n\\r\\n        uint256 pendingRewards = 0;\\r\\n\\r\\n        uint256 holdBonus = getHoldBonus(addr);\\r\\n\\r\\n        for(uint256 i = 0; i < user.positions.length; i++) {\\r\\n\\r\\n            \\r\\n\\r\\n            if(user.positions[i].isActive) {\\r\\n                \\r\\n                uint256 share = user.positions[i].amount.mul(user.positions[i].daily.add(holdBonus)).div(PERCENTS_DIVIDER);\\r\\n\\r\\n                uint256 from = user.positions[i].checkpoint > user.checkpoint ? user.positions[i].checkpoint: user.checkpoint;\\r\\n                uint256 to = block.timestamp;\\r\\n\\r\\n                uint256 rewards = share.mul(to.sub(from)).div(TIME_STEP);\\r\\n\\r\\n                pendingRewards = pendingRewards.add(rewards);\\r\\n\\r\\n\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n        return pendingRewards;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    function getTvlBonus() public returns(uint256 bonus) {\\r\\n        uint256 lockedEther = token.getLockedEther();\\r\\n\\r\\n        bonus = lockedEther.div(TVL_BONUS_STEP).mul(10); // +0.01% each 10 ether \\r\\n\\r\\n    }\\r\\n\\r\\n    function getHoldBonus(address addr) public view returns(uint256 holdBonus) {\\r\\n        uint256 userCheckpoint = users[addr].checkpoint;\\r\\n\\r\\n        holdBonus = block.timestamp.sub(userCheckpoint).div(TIME_STEP).mul(50); //+0.05% each day\\r\\n    }\\r\\n\\r\\n    function getDailyPercent(uint256 _days) internal pure returns(uint256 _percent) {\\r\\n        _percent = [500,525,551,579,608,638,670,704,739,776,814,855,898,943,990,1039,1091,1146,1203,1263,1327,1393,1463,1536,1613,1693,1778,1867,1960,2058,2161,2269,2382,2502,2627,2758,2896,3041,3193,3352,3520,3696,3881,4075][_days.sub(7)];\\r\\n    }\\r\\n\\r\\n    function getRefRewards(uint256 level) internal pure returns(uint256 _percent) {\\r\\n        return [4000, 3000, 2000, 1000][level];\\r\\n    }\\r\\n\\r\\n    function getContractStats() external view returns(uint256 staked, uint256 positions) {\\r\\n        staked = totalStaked;\\r\\n        positions = totalPositions;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getUserData(address addr) external view returns(Position[] memory _positions, Partner memory _partners, uint256 _withdrawn) {\\r\\n        _positions = users[addr].positions;\\r\\n        _partners = users[addr].partners;\\r\\n        _withdrawn = users[addr].withdrawnRewards;\\r\\n    }\\r\\n\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    \\r\\n     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketingAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onClaimRef\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onUnstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEV_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETING_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DAYS_LOCKUP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DAYS_LOCKUP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TVL_BONUS_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positions\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getHoldBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"holdBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"getPositionData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_dailyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockupTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTvlBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUnlockTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daily\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct SWORDProtocol.Position[]\",\"name\":\"_positions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"internalType\":\"struct SWORDProtocol.Partner\",\"name\":\"_partners\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"launchProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"internalType\":\"struct SWORDProtocol.Partner\",\"name\":\"partners\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SWORDProtocol", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000027799a2d63a9c3c085f05c25df1571fe10b80d7e00000000000000000000000014f3afddda5133a13e5068fd51ce57a066d94a01", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}