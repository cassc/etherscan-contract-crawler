{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/sales/PrivateSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"../libs/fota/Auth.sol\\\";\\nimport \\\"../libs/zeppelin/token/BEP20/IBEP20.sol\\\";\\nimport \\\"../interfaces/IFOTAToken.sol\\\";\\n\\ncontract PrivateSale is Auth {\\n\\n  struct Buyer {\\n    uint allocated;\\n    uint price; // decimal 3\\n    uint boughtAtBlock;\\n    uint lastClaimed;\\n    uint totalClaimed;\\n  }\\n  enum USDCurrency {\\n    busd,\\n    usdt\\n  }\\n\\n  address public fundAdmin;\\n  IFOTAToken public fotaToken;\\n  IBEP20 public busdToken;\\n  IBEP20 public usdtToken;\\n  uint public constant privateSaleAllocation = 21e24;\\n  uint public startVestingBlock;\\n  uint public constant blockInOneMonth = 864000; // 30 * 24 * 60 * 20\\n//  uint public constant blockInOneMonth = 200; // 30 * 24 * 60 * 20\\n  uint constant decimal3 = 1000;\\n  uint public tgeRatio;\\n  uint public vestingTime;\\n  bool public adminCanUpdateAllocation;\\n  uint totalAllocated;\\n  mapping(address => Buyer) buyers;\\n\\n  event UserAllocated(address indexed buyer, uint amount, uint price, uint timestamp);\\n  event Bought(address indexed buyer, uint amount, uint price, uint timestamp);\\n  event Claimed(address indexed buyer, uint amount, uint timestamp);\\n  event VestingStated(uint timestamp);\\n\\n  function initialize(address _mainAdmin, address _fundAdmin, address _fotaToken) public initializer {\\n    Auth.initialize(_mainAdmin);\\n    fundAdmin = _fundAdmin;\\n    fotaToken = IFOTAToken(_fotaToken);\\n    vestingTime = 12;\\n    tgeRatio = 20;\\n    adminCanUpdateAllocation = true;\\n    busdToken = IBEP20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\\n    usdtToken = IBEP20(0x55d398326f99059fF775485246999027B3197955);\\n  }\\n\\n  function startVesting() onlyMainAdmin external {\\n    require(startVestingBlock == 0, \\\"PrivateSale: vesting had started\\\");\\n    startVestingBlock = block.number;\\n    emit VestingStated(startVestingBlock);\\n  }\\n\\n  function updateVestingTime(uint _month) onlyMainAdmin external {\\n    require(adminCanUpdateAllocation, \\\"PrivateSale: user had bought\\\");\\n    vestingTime = _month;\\n  }\\n\\n  function updateTGERatio(uint _ratio) onlyMainAdmin external {\\n    require(adminCanUpdateAllocation, \\\"PrivateSale: user had bought\\\");\\n    require(_ratio < 100, \\\"PrivateSale: invalid ratio\\\");\\n    tgeRatio = _ratio;\\n  }\\n\\n  function updateFundAdmin(address _address) onlyMainAdmin external {\\n    require(_address != address(0), \\\"PrivateSale: invalid address\\\");\\n    fundAdmin = _address;\\n  }\\n\\n  function setUserAllocations(address[] calldata _buyers, uint[] calldata _amounts, uint[] calldata _prices) external onlyMainAdmin {\\n    require(_buyers.length == _amounts.length && _amounts.length == _prices.length, \\\"PrivateSale: invalid data input\\\");\\n    address buyer;\\n    uint amount;\\n    uint price;\\n    for(uint i = 0; i < _buyers.length; i++) {\\n      buyer = _buyers[i];\\n      amount = _amounts[i];\\n      price = _prices[i];\\n      if (_buyers[i] != address(0) && buyers[_buyers[i]].boughtAtBlock == 0) {\\n        if (buyers[buyer].allocated == 0) {\\n          totalAllocated += amount;\\n        } else {\\n          totalAllocated = totalAllocated - buyers[buyer].allocated + amount;\\n        }\\n        buyers[buyer] = Buyer(amount, price, 0, 0, 0);\\n        emit UserAllocated(buyer, amount, price, block.timestamp);\\n      }\\n    }\\n    require(totalAllocated <= privateSaleAllocation, \\\"PrivateSale: amount invalid\\\");\\n  }\\n\\n  function removeBuyerAllocation(address _buyer) external onlyMainAdmin {\\n    require(buyers[_buyer].allocated > 0, \\\"PrivateSale: User have no allocation\\\");\\n    require(buyers[_buyer].boughtAtBlock == 0, \\\"PrivateSale: User have bought already\\\");\\n    delete buyers[_buyer];\\n  }\\n\\n  function buy(USDCurrency _usdCurrency) external {\\n    Buyer storage buyer = buyers[msg.sender];\\n    require(buyer.allocated > 0, \\\"PrivateSale: You have no allocation\\\");\\n    require(buyer.boughtAtBlock == 0, \\\"PrivateSale: You had bought\\\");\\n    if (adminCanUpdateAllocation) {\\n      adminCanUpdateAllocation = false;\\n    }\\n    _takeFund(_usdCurrency, buyer.allocated * buyer.price / decimal3);\\n    buyer.boughtAtBlock = block.number;\\n    emit Bought(msg.sender, buyer.allocated, buyer.price, block.timestamp);\\n  }\\n\\n  function claim() external {\\n    require(startVestingBlock > 0, \\\"PrivateSale: please wait more time\\\");\\n    Buyer storage buyer = buyers[msg.sender];\\n    require(buyer.boughtAtBlock > 0, \\\"PrivateSale: You have no allocation\\\");\\n    uint maxBlockNumber = startVestingBlock + blockInOneMonth * vestingTime;\\n    require(maxBlockNumber > buyer.lastClaimed, \\\"PrivateSale: your allocation had released\\\");\\n    uint blockPass;\\n    uint releaseAmount;\\n    if (buyer.lastClaimed == 0) {\\n      buyer.lastClaimed = startVestingBlock;\\n      releaseAmount = buyer.allocated * tgeRatio / 100;\\n    } else {\\n      if (block.number < maxBlockNumber) {\\n        blockPass = block.number - buyer.lastClaimed;\\n        buyer.lastClaimed = block.number;\\n      } else {\\n        blockPass = maxBlockNumber - buyer.lastClaimed;\\n        buyer.lastClaimed = maxBlockNumber;\\n      }\\n      releaseAmount = buyer.allocated * (100 - tgeRatio) / 100 * blockPass / (blockInOneMonth * vestingTime);\\n    }\\n    buyer.totalClaimed = buyer.totalClaimed + releaseAmount;\\n    require(fotaToken.releasePrivateSaleAllocation(msg.sender, releaseAmount), \\\"PrivateSale: transfer token failed\\\");\\n    emit Claimed(msg.sender, releaseAmount, block.timestamp);\\n  }\\n\\n  function getBuyer(address _address) external view returns (uint, uint, uint, uint, uint) {\\n    Buyer storage buyer = buyers[_address];\\n    return(\\n    buyer.allocated,\\n    buyer.price,\\n    buyer.boughtAtBlock,\\n    buyer.lastClaimed,\\n    buyer.totalClaimed\\n    );\\n  }\\n\\n  function _takeFund(USDCurrency _usdCurrency, uint _amount) private {\\n    IBEP20 usdToken = _usdCurrency == USDCurrency.busd ? busdToken : usdtToken;\\n    require(usdToken.allowance(msg.sender, address(this)) >= _amount, \\\"PrivateSale: please approve usd token first\\\");\\n    require(usdToken.balanceOf(msg.sender) >= _amount, \\\"PrivateSale: please fund your account\\\");\\n    require(usdToken.transferFrom(msg.sender, address(this), _amount), \\\"PrivateSale: transfer usd token failed\\\");\\n    require(usdToken.transfer(fundAdmin, _amount), \\\"PrivateSale: transfer usd token failed\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/zeppelin/token/BEP20/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IBEP20 {\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/fota/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nabstract contract Auth is Initializable {\\n\\n  address internal mainAdmin;\\n\\n  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\\n  function initialize(address _mainAdmin) virtual public initializer {\\n    mainAdmin = _mainAdmin;\\n  }\\n\\n  modifier onlyMainAdmin() {\\n    require(_isMainAdmin(), \\\"onlyMainAdmin\\\");\\n    _;\\n  }\\n\\n  function transferOwnership(address _newOwner) onlyMainAdmin external {\\n    require(_newOwner != address(0x0));\\n    mainAdmin = _newOwner;\\n    emit OwnershipTransferred(msg.sender, _newOwner);\\n  }\\n\\n  function _isMainAdmin() public view returns (bool) {\\n    return msg.sender == mainAdmin;\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IFOTAToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"../libs/zeppelin/token/BEP20/IBEP20.sol\\\";\\n\\ninterface IFOTAToken is IBEP20 {\\n  function releaseGameAllocation(address _gamerAddress, uint _amount) external returns (bool);\\n  function releasePrivateSaleAllocation(address _buyerAddress, uint _amount) external returns (bool);\\n  function releaseSeedSaleAllocation(address _buyerAddress, uint _amount) external returns (bool);\\n  function releaseStrategicSaleAllocation(address _buyerAddress, uint _amount) external returns (bool);\\n  function burn(uint _amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UserAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"VestingStated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_isMainAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminCanUpdateAllocation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockInOneMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PrivateSale.USDCurrency\",\"name\":\"_usdCurrency\",\"type\":\"uint8\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fotaToken\",\"outputs\":[{\"internalType\":\"contract IFOTAToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBuyer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mainAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fundAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fotaToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mainAdmin\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"privateSaleAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"removeBuyerAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_buyers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"}],\"name\":\"setUserAllocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startVestingBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tgeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateFundAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"updateTGERatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_month\",\"type\":\"uint256\"}],\"name\":\"updateVestingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PrivateSale", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}