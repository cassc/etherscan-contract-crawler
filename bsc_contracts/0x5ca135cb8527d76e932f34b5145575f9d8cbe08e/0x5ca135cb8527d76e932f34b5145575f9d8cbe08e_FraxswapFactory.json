{"SourceCode": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\n// Sources flattened with hardhat v2.9.6 https://hardhat.org\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2FactoryV5.sol\r\n\r\n\r\ninterface IUniswapV2FactoryV5 {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2PairPartialV5.sol\r\n\r\n\r\ninterface IUniswapV2PairPartialV5 {\r\n    //    event Approval(address indexed owner, address indexed spender, uint value);\r\n    //    event Transfer(address indexed from, address indexed to, uint value);\r\n    //\r\n    //    function name() external pure returns (string memory);\r\n    //    function symbol() external pure returns (string memory);\r\n    //    function decimals() external pure returns (uint8);\r\n    //    function totalSupply() external view returns (uint);\r\n    //    function balanceOf(address owner) external view returns (uint);\r\n    //    function allowance(address owner, address spender) external view returns (uint);\r\n    //\r\n    //    function approve(address spender, uint value) external returns (bool);\r\n    //    function transfer(address to, uint value) external returns (bool);\r\n    //    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    //\r\n    //    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    //    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    //    function nonces(address owner) external view returns (uint);\r\n    //\r\n    //    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n\r\n    // TWAMM\r\n\r\n    function longTermSwapFrom0To1(uint256 amount0In, uint256 numberOfTimeIntervals) external returns (uint256 orderId);\r\n    function longTermSwapFrom1To0(uint256 amount1In, uint256 numberOfTimeIntervals) external returns (uint256 orderId);\r\n    function cancelLongTermSwap(uint256 orderId) external;\r\n    function withdrawProceedsFromLongTermSwap(uint256 orderId) external returns (bool is_expired, address rewardTkn, uint256 totalReward);\r\n    function executeVirtualOrders(uint256 blockTimestamp) external;\r\n\r\n    function orderTimeInterval() external returns (uint256);\r\n    function getTWAPHistoryLength() external view returns (uint);\r\n    function getTwammReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast, uint112 _twammReserve0, uint112 _twammReserve1);\r\n    function getReserveAfterTwamm(uint256 blockTimestamp) external view returns (uint112 _reserve0, uint112 _reserve1, uint256 lastVirtualOrderTimestamp, uint112 _twammReserve0, uint112 _twammReserve1);\r\n    function getNextOrderID() external view returns (uint256);\r\n    function getOrderIDsForUser(address user) external view returns (uint256[] memory);\r\n    function getOrderIDsForUserLength(address user) external view returns (uint256);\r\n    //    function getDetailedOrdersForUser(address user, uint256 offset, uint256 limit) external view returns (LongTermOrdersLib.Order[] memory detailed_orders);\r\n    function twammUpToDate() external view returns (bool);\r\n    function getTwammState() external view returns (uint256 token0Rate, uint256 token1Rate, uint256 lastVirtualOrderTimestamp, uint256 orderTimeInterval_rtn, uint256 rewardFactorPool0, uint256 rewardFactorPool1);\r\n    function getTwammSalesRateEnding(uint256 _blockTimestamp) external view returns (uint256 orderPool0SalesRateEnding, uint256 orderPool1SalesRateEnding);\r\n    function getTwammRewardFactor(uint256 _blockTimestamp) external view returns (uint256 rewardFactorPool0AtTimestamp, uint256 rewardFactorPool1AtTimestamp);\r\n    function getTwammOrder(uint256 orderId) external view returns (uint256 id, uint256 expirationTimestamp, uint256 saleRate, address owner, address sellTokenAddr, address buyTokenAddr);\r\n    function getTwammOrderProceedsView(uint256 orderId, uint256 blockTimestamp) external view returns (bool orderExpired, uint256 totalReward);\r\n    function getTwammOrderProceeds(uint256 orderId) external returns (bool orderExpired, uint256 totalReward);\r\n\r\n\r\n    function togglePauseNewSwaps() external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2ERC20V5.sol\r\n\r\n\r\ninterface IUniswapV2ERC20V5 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/FraxswapERC20.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ========================== FraxswapERC20 ===========================\r\n// ====================================================================\r\n// Fraxswap ERC-20\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\ncontract FraxswapERC20 is IUniswapV2ERC20V5 {\r\n\r\n    string public constant override name = 'Fraxswap V1';\r\n    string public constant override symbol = 'FS-V1';\r\n    uint8 public constant override decimals = 18;\r\n    uint  public override totalSupply;\r\n    mapping(address => uint) public override balanceOf;\r\n    mapping(address => mapping(address => uint)) public override allowance;\r\n\r\n    bytes32 public override DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public override nonces;\r\n\r\n    constructor() public {\r\n        uint chainId = block.chainid;\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply + value;\r\n        balanceOf[to] = balanceOf[to] + value;\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from] - value;\r\n        totalSupply = totalSupply - value;\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from] - value;\r\n        balanceOf[to] = balanceOf[to] + value;\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint).max) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender] - value;\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\r\n        require(deadline >= block.timestamp); // EXPIRED\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner); // INVALID_SIGNATURE\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/libraries/Math.sol\r\n\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/libraries/UQ112x112.sol\r\n\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IERC20V5.sol\r\n\r\n\r\ninterface IERC20V5 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2CalleeV5.sol\r\n\r\n\r\ninterface IUniswapV2CalleeV5 {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/libraries/TransferHelper.sol\r\n\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeApprove: approve failed'\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeTransfer: transfer failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/twamm/ExecVirtualOrders.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ======================= ExecVirtualOrdersLib =======================\r\n// ====================================================================\r\n// TWAMM logic for executing the virtual orders\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\n\r\n///@notice This library handles the execution of long term orders.\r\nlibrary ExecVirtualOrdersLib {\r\n\r\n    ///@notice computes the result of virtual trades by the token pools\r\n    function computeVirtualBalances(\r\n        uint256 token0Start,\r\n        uint256 token1Start,\r\n        uint256 token0In,\r\n        uint256 token1In)\r\n    internal pure returns (uint256 token0Out, uint256 token1Out)\r\n    {\r\n        token0Out = 0;\r\n        token1Out = 0;\r\n        //if no tokens are sold to the pool, we don't need to execute any orders\r\n        if (token0In <= 1 && token1In <= 1) {\r\n            // do nothing\r\n        }\r\n        //in the case where only one pool is selling, we just perform a normal swap\r\n        else if (token0In <= 1) {\r\n            //constant product formula\r\n            uint token1InWithFee = token1In * 997;\r\n            token0Out = token0Start * token1InWithFee / ((token1Start * 1000) + token1InWithFee);\r\n        }\r\n        else if (token1In <= 1) {\r\n            //contant product formula\r\n            uint token0InWithFee = token0In * 997;\r\n            token1Out = token1Start * token0InWithFee / ((token0Start * 1000) + token0InWithFee);\r\n        }\r\n        //when both pools sell, we use the TWAMM formula\r\n        else {\r\n            uint256 newToken0 = token0Start + (token0In * 997 / 1000);\r\n            uint256 newToken1 = token1Start + (token1In * 997 / 1000);\r\n            token0Out = newToken0 - (token1Start * (newToken0) / (newToken1));\r\n            token1Out = newToken1 - (token0Start * (newToken1) / (newToken0));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/twamm/LongTermOrders.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ========================= LongTermOrdersLib ========================\r\n// ====================================================================\r\n// TWAMM long term order execution logic\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\n\r\n///@notice This library handles the state and execution of long term orders. \r\nlibrary LongTermOrdersLib {\r\n\r\n    using LongTermOrdersLib for OrderPool;\r\n\r\n    /// ---------------------------\r\n    /// ----- LongTerm Orders -----\r\n    /// ---------------------------\r\n\r\n    uint112 internal constant SELL_RATE_ADDITIONAL_PRECISION = 1000000;\r\n\r\n    ///@notice information associated with a long term order\r\n    ///fields should NOT be changed after Order struct is created\r\n    struct Order {\r\n        uint256 id;\r\n        uint256 expirationTimestamp;\r\n        uint256 saleRate;\r\n        address owner;\r\n        address sellTokenAddr;\r\n        address buyTokenAddr;\r\n        bool isComplete;\r\n    }\r\n\r\n    ///@notice structure contains full state related to long term orders\r\n    struct LongTermOrders {\r\n\r\n        ///@notice minimum time interval between order expiries\r\n        uint256 orderTimeInterval;\r\n\r\n        ///@notice last virtual orders were executed immediately before this block.timestamp\r\n        uint256 lastVirtualOrderTimestamp;\r\n\r\n        ///@notice token pair being traded in embedded amm\r\n        address token0;\r\n        address token1;\r\n\r\n        ///@notice mapping from token address to pool that is selling that token\r\n        ///we maintain two order pools, one for each token that is tradable in the AMM\r\n        OrderPool OrderPool0;\r\n        OrderPool OrderPool1;\r\n\r\n        ///@notice incrementing counter for order ids, this is the next order id\r\n        uint256 orderId;\r\n\r\n        ///@notice mapping from order ids to Orders\r\n        mapping(uint256 => Order) orderMap;\r\n    }\r\n\r\n    struct ExecuteVirtualOrdersResult {\r\n        uint112 newReserve0;\r\n        uint112 newReserve1;\r\n        uint256 newTwammReserve0;\r\n        uint256 newTwammReserve1;\r\n        uint256 token0Bought;\r\n        uint256 token1Bought;\r\n        uint256 token0Sold;\r\n        uint256 token1Sold;\r\n        uint256 expiries;\r\n    }\r\n\r\n    ///@notice initialize state\r\n    function initialize(LongTermOrders storage longTermOrders,\r\n        address token0,\r\n        address token1,\r\n        uint256 lastVirtualOrderTimestamp,\r\n        uint256 orderTimeInterval) internal {\r\n        longTermOrders.token0 = token0;\r\n        longTermOrders.token1 = token1;\r\n        longTermOrders.lastVirtualOrderTimestamp = lastVirtualOrderTimestamp;\r\n        longTermOrders.orderTimeInterval = orderTimeInterval;\r\n    }\r\n\r\n    ///@notice get the OrderPool for this token\r\n    function getOrderPool(LongTermOrders storage longTermOrders, address token) internal view returns (OrderPool storage orderPool) {\r\n        orderPool = token == longTermOrders.token0 ? longTermOrders.OrderPool0 : longTermOrders.OrderPool1;\r\n    }\r\n\r\n    ///@notice swap token 0 for token 1. Amount represents total amount being sold, numberOfTimeIntervals determines when order expires\r\n    function longTermSwapFrom0To1(LongTermOrders storage longTermOrders, uint256 amount0, uint256 numberOfTimeIntervals) internal returns (uint256) {\r\n        return performLongTermSwap(longTermOrders, longTermOrders.token0, longTermOrders.token1, amount0, numberOfTimeIntervals);\r\n    }\r\n\r\n    ///@notice swap token 1 for token 0. Amount represents total amount being sold, numberOfTimeIntervals determines when order expires\r\n    function longTermSwapFrom1To0(LongTermOrders storage longTermOrders, uint256 amount1, uint256 numberOfTimeIntervals) internal returns (uint256) {\r\n        return performLongTermSwap(longTermOrders, longTermOrders.token1, longTermOrders.token0, amount1, numberOfTimeIntervals);\r\n    }\r\n\r\n    ///@notice adds long term swap to order pool\r\n    function performLongTermSwap(LongTermOrders storage longTermOrders, address from, address to, uint256 amount, uint256 numberOfTimeIntervals) private returns (uint256) {\r\n        // make sure to update virtual order state (before calling this function)\r\n\r\n        //determine the selling rate based on number of blocks to expiry and total amount\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 lastExpiryTimestamp = currentTime - (currentTime % longTermOrders.orderTimeInterval);\r\n        uint256 orderExpiry = longTermOrders.orderTimeInterval * (numberOfTimeIntervals + 1) + lastExpiryTimestamp;\r\n        uint256 sellingRate = SELL_RATE_ADDITIONAL_PRECISION * amount / (orderExpiry - currentTime);\r\n\r\n        require(sellingRate > 0); // tokenRate cannot be zero\r\n\r\n        //add order to correct pool\r\n        OrderPool storage orderPool = getOrderPool(longTermOrders, from);\r\n        orderPoolDepositOrder(orderPool, longTermOrders.orderId, sellingRate, orderExpiry);\r\n\r\n        //add to order map\r\n        longTermOrders.orderMap[longTermOrders.orderId] = Order(longTermOrders.orderId, orderExpiry, sellingRate, msg.sender, from, to, false);\r\n        return longTermOrders.orderId++;\r\n    }\r\n\r\n    ///@notice cancel long term swap, pay out unsold tokens and well as purchased tokens\r\n    function cancelLongTermSwap(LongTermOrders storage longTermOrders, uint256 orderId) internal returns (address sellToken, uint256 unsoldAmount, address buyToken, uint256 purchasedAmount) {\r\n        // make sure to update virtual order state (before calling this function)\r\n\r\n        Order storage order = longTermOrders.orderMap[orderId];\r\n        buyToken = order.buyTokenAddr;\r\n        sellToken = order.sellTokenAddr;\r\n\r\n        OrderPool storage orderPool = getOrderPool(longTermOrders, sellToken);\r\n        (unsoldAmount, purchasedAmount) = orderPoolCancelOrder(orderPool, orderId, longTermOrders.lastVirtualOrderTimestamp);\r\n\r\n        require(order.owner == msg.sender && (unsoldAmount > 0 || purchasedAmount > 0)); // owner and amounts check\r\n\r\n    }\r\n\r\n    ///@notice withdraw proceeds from a long term swap (can be expired or ongoing)\r\n    function withdrawProceedsFromLongTermSwap(LongTermOrders storage longTermOrders, uint256 orderId) internal returns (address proceedToken, uint256 proceeds, bool orderExpired) {\r\n        // make sure to update virtual order state (before calling this function)\r\n\r\n        Order storage order = longTermOrders.orderMap[orderId];\r\n        proceedToken = order.buyTokenAddr;\r\n\r\n        OrderPool storage orderPool = getOrderPool(longTermOrders, order.sellTokenAddr);\r\n        (proceeds, orderExpired) = orderPoolWithdrawProceeds(orderPool, orderId, longTermOrders.lastVirtualOrderTimestamp);\r\n\r\n        require(order.owner == msg.sender && proceeds > 0); // owner and amounts check\r\n    }\r\n\r\n    ///@notice executes all virtual orders between current lastVirtualOrderTimestamp and blockTimestamp\r\n    //also handles orders that expire at end of final blockTimestamp. This assumes that no orders expire inside the given interval\r\n    function executeVirtualTradesAndOrderExpiries(\r\n        ExecuteVirtualOrdersResult memory reserveResult,\r\n        uint256 token0SellAmount,\r\n        uint256 token1SellAmount\r\n    ) private view returns (uint256 token0Out, uint256 token1Out) {\r\n\r\n        //initial amm balance\r\n        uint256 bal0 = reserveResult.newReserve0 + reserveResult.newTwammReserve0;\r\n        uint256 bal1 = reserveResult.newReserve1 + reserveResult.newTwammReserve1;\r\n\r\n        //updated balances from sales\r\n        (token0Out, token1Out) = ExecVirtualOrdersLib.computeVirtualBalances(\r\n            reserveResult.newReserve0,\r\n            reserveResult.newReserve1,\r\n            token0SellAmount,\r\n            token1SellAmount\r\n        );\r\n\r\n        //update balances reserves\r\n        reserveResult.newTwammReserve0 = reserveResult.newTwammReserve0 + token0Out - token0SellAmount;\r\n        reserveResult.newTwammReserve1 = reserveResult.newTwammReserve1 + token1Out - token1SellAmount;\r\n        reserveResult.newReserve0 = uint112(bal0 - reserveResult.newTwammReserve0); // calculate reserve0 incl LP fees\r\n        reserveResult.newReserve1 = uint112(bal1 - reserveResult.newTwammReserve1); // calculate reserve1 incl LP fees\r\n        reserveResult.token0Bought += token0Out;\r\n        reserveResult.token1Bought += token1Out;\r\n        reserveResult.token0Sold += token0SellAmount;\r\n        reserveResult.token1Sold += token1SellAmount;\r\n        reserveResult.expiries += 1;\r\n    }\r\n\r\n    ///@notice executes all virtual orders until blockTimestamp is reached.\r\n    function executeVirtualOrdersUntilTimestamp(LongTermOrders storage longTermOrders, uint256 blockTimestamp, ExecuteVirtualOrdersResult memory reserveResult) internal {\r\n\r\n        uint256 lastVirtualOrderTimestampLocal = longTermOrders.lastVirtualOrderTimestamp; // save gas\r\n        uint256 orderTimeInterval = longTermOrders.orderTimeInterval; // save gas\r\n        uint256 nextExpiryBlockTimestamp = lastVirtualOrderTimestampLocal - (lastVirtualOrderTimestampLocal % orderTimeInterval) + orderTimeInterval;\r\n        //iterate through time intervals eligible for order expiries, moving state forward\r\n\r\n        OrderPool storage orderPool0 = longTermOrders.OrderPool0;\r\n        OrderPool storage orderPool1 = longTermOrders.OrderPool1;\r\n\r\n        while (nextExpiryBlockTimestamp < blockTimestamp) {\r\n            // Optimization for skipping blocks with no expiry\r\n            if (orderPool0.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0\r\n                || orderPool1.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0) {\r\n\r\n                //amount sold from virtual trades\r\n                uint256 blockTimestampElapsed = nextExpiryBlockTimestamp - lastVirtualOrderTimestampLocal;\r\n                uint256 token0SellAmount = orderPool0.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n                uint256 token1SellAmount = orderPool1.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n                (uint256 token0Out, uint256 token1Out) = executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n                //distribute proceeds to pools. make sure to call this before orderPoolUpdateStateFromTimestampExpiry.\r\n                orderPoolDistributePayment(orderPool0, token1Out);\r\n                orderPoolDistributePayment(orderPool1, token0Out);\r\n\r\n                //handle orders expiring at end of interval. call orderPoolDistributePayment before calling this.\r\n                orderPoolUpdateStateFromTimestampExpiry(orderPool0, nextExpiryBlockTimestamp);\r\n                orderPoolUpdateStateFromTimestampExpiry(orderPool1, nextExpiryBlockTimestamp);\r\n\r\n                lastVirtualOrderTimestampLocal = nextExpiryBlockTimestamp;\r\n            }\r\n            nextExpiryBlockTimestamp += orderTimeInterval;\r\n        }\r\n        //finally, move state to current blockTimestamp if necessary\r\n        if (lastVirtualOrderTimestampLocal != blockTimestamp) {\r\n\r\n            //amount sold from virtual trades\r\n            uint256 blockTimestampElapsed = blockTimestamp - lastVirtualOrderTimestampLocal;\r\n            uint256 token0SellAmount = orderPool0.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n            uint256 token1SellAmount = orderPool1.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n            (uint256 token0Out, uint256 token1Out) = executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n            //distribute proceeds to pools\r\n            orderPoolDistributePayment(orderPool0, token1Out);\r\n            orderPoolDistributePayment(orderPool1, token0Out);\r\n\r\n            // skip call to orderPoolUpdateStateFromTimestampExpiry, this will not be an expiry timestamp. save gas\r\n        }\r\n\r\n        longTermOrders.lastVirtualOrderTimestamp = blockTimestamp;\r\n    }\r\n\r\n    ///@notice executes all virtual orders until blockTimestamp is reached (AS A VIEW)\r\n    function executeVirtualOrdersUntilTimestampView(LongTermOrders storage longTermOrders, uint256 blockTimestamp, ExecuteVirtualOrdersResult memory reserveResult) internal view {\r\n\r\n        uint256 lastVirtualOrderTimestampLocal = longTermOrders.lastVirtualOrderTimestamp; // save gas\r\n        uint256 orderTimeInterval = longTermOrders.orderTimeInterval; // save gas\r\n        uint256 nextExpiryBlockTimestamp = lastVirtualOrderTimestampLocal - (lastVirtualOrderTimestampLocal % orderTimeInterval) + orderTimeInterval;\r\n        //iterate through time intervals eligible for order expiries, moving state forward\r\n\r\n        OrderPool storage orderPool0 = longTermOrders.OrderPool0;\r\n        OrderPool storage orderPool1 = longTermOrders.OrderPool1;\r\n\r\n        // currentSales for each pool is mutated in the non-view (mutate locally)\r\n        uint256 currentSalesRate0 = orderPool0.currentSalesRate;\r\n        uint256 currentSalesRate1 = orderPool1.currentSalesRate;\r\n\r\n        while (nextExpiryBlockTimestamp < blockTimestamp) {\r\n            // Optimization for skipping blocks with no expiry\r\n            if (orderPool0.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0\r\n                || orderPool1.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0) {\r\n\r\n                //amount sold from virtual trades\r\n                uint256 blockTimestampElapsed = nextExpiryBlockTimestamp - lastVirtualOrderTimestampLocal;\r\n                uint256 token0SellAmount = currentSalesRate0 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n                uint256 token1SellAmount = currentSalesRate1 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n                executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n                currentSalesRate0 -= orderPool0.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp];\r\n                currentSalesRate1 -= orderPool1.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp];\r\n\r\n                lastVirtualOrderTimestampLocal = nextExpiryBlockTimestamp;\r\n            }\r\n            nextExpiryBlockTimestamp += orderTimeInterval;\r\n        }\r\n        //finally, move state to current blockTimestamp if necessary\r\n        if (lastVirtualOrderTimestampLocal != blockTimestamp) {\r\n\r\n            //amount sold from virtual trades\r\n            uint256 blockTimestampElapsed = blockTimestamp - lastVirtualOrderTimestampLocal;\r\n            uint256 token0SellAmount = currentSalesRate0 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n            uint256 token1SellAmount = currentSalesRate1 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n            executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n        }\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// -------- OrderPool --------\r\n    /// ---------------------------\r\n\r\n    ///@notice An Order Pool is an abstraction for a pool of long term orders that sells a token at a constant rate to the embedded AMM.\r\n    ///the order pool handles the logic for distributing the proceeds from these sales to the owners of the long term orders through a modified\r\n    ///version of the staking algorithm from  https://uploads-ssl.webflow.com/5ad71ffeb79acc67c8bcdaba/5ad8d1193a40977462982470_scalable-reward-distribution-paper.pdf\r\n\r\n    uint256 constant Q112 = 2**112;\r\n\r\n    ///@notice you can think of this as a staking pool where all long term orders are staked.\r\n    /// The pool is paid when virtual long term orders are executed, and each order is paid proportionally\r\n    /// by the order's sale rate per time intervals\r\n    struct OrderPool {\r\n        ///@notice current rate that tokens are being sold (per time interval)\r\n        uint256 currentSalesRate;\r\n\r\n        ///@notice sum of (salesProceeds_k / salesRate_k) over every period k. Stored as a fixed precision floating point number\r\n        uint256 rewardFactor;\r\n\r\n        ///@notice this maps time interval numbers to the cumulative sales rate of orders that expire on that block (time interval)\r\n        mapping(uint256 => uint256) salesRateEndingPerTimeInterval;\r\n\r\n        ///@notice map order ids to the block timestamp in which they expire\r\n        mapping(uint256 => uint256) orderExpiry;\r\n\r\n        ///@notice map order ids to their sales rate\r\n        mapping(uint256 => uint256) salesRate;\r\n\r\n        ///@notice reward factor per order at time of submission\r\n        mapping(uint256 => uint256) rewardFactorAtSubmission;\r\n\r\n        ///@notice reward factor at a specific time interval\r\n        mapping(uint256 => uint256) rewardFactorAtTimestamp;\r\n    }\r\n\r\n    ///@notice distribute payment amount to pool (in the case of TWAMM, proceeds from trades against amm)\r\n    function orderPoolDistributePayment(OrderPool storage orderPool, uint256 amount) internal {\r\n        if (orderPool.currentSalesRate != 0) {\r\n            unchecked { // Addition is with overflow\r\n                orderPool.rewardFactor += amount * Q112 * SELL_RATE_ADDITIONAL_PRECISION / orderPool.currentSalesRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    ///@notice deposit an order into the order pool.\r\n    function orderPoolDepositOrder(OrderPool storage orderPool, uint256 orderId, uint256 amountPerInterval, uint256 orderExpiry) internal {\r\n        orderPool.currentSalesRate += amountPerInterval;\r\n        orderPool.rewardFactorAtSubmission[orderId] = orderPool.rewardFactor;\r\n        orderPool.orderExpiry[orderId] = orderExpiry;\r\n        orderPool.salesRate[orderId] = amountPerInterval;\r\n        orderPool.salesRateEndingPerTimeInterval[orderExpiry] += amountPerInterval;\r\n    }\r\n\r\n    ///@notice when orders expire after a given timestamp, we need to update the state of the pool\r\n    function orderPoolUpdateStateFromTimestampExpiry(OrderPool storage orderPool, uint256 blockTimestamp) internal {\r\n        orderPool.currentSalesRate -= orderPool.salesRateEndingPerTimeInterval[blockTimestamp];\r\n        orderPool.rewardFactorAtTimestamp[blockTimestamp] = orderPool.rewardFactor;\r\n    }\r\n\r\n    ///@notice cancel order and remove from the order pool\r\n    function orderPoolCancelOrder(OrderPool storage orderPool, uint256 orderId, uint256 blockTimestamp) internal returns (uint256 unsoldAmount, uint256 purchasedAmount) {\r\n        uint256 expiry = orderPool.orderExpiry[orderId];\r\n        require(expiry > blockTimestamp);\r\n\r\n        //calculate amount that wasn't sold, and needs to be returned\r\n        uint256 salesRate = orderPool.salesRate[orderId];\r\n        unsoldAmount = (expiry - blockTimestamp) * salesRate / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n        //calculate amount of other token that was purchased\r\n        unchecked { // subtraction is with underflow\r\n            purchasedAmount = ((orderPool.rewardFactor - orderPool.rewardFactorAtSubmission[orderId]) * salesRate / SELL_RATE_ADDITIONAL_PRECISION) / Q112;\r\n        }\r\n\r\n        //update state\r\n        orderPool.currentSalesRate -= salesRate;\r\n        orderPool.salesRate[orderId] = 0;\r\n        orderPool.orderExpiry[orderId] = 0;\r\n        orderPool.salesRateEndingPerTimeInterval[expiry] -= salesRate;\r\n    }\r\n\r\n    ///@notice withdraw proceeds from pool for a given order. This can be done before or after the order has expired.\r\n    //If the order has expired, we calculate the reward factor at time of expiry. If order has not yet expired, we\r\n    //use current reward factor, and update the reward factor at time of staking (effectively creating a new order)\r\n    function orderPoolWithdrawProceeds(OrderPool storage orderPool, uint256 orderId, uint256 blockTimestamp) internal returns (uint256 totalReward, bool orderExpired) {\r\n        (orderExpired, totalReward) = orderPoolGetProceeds(orderPool, orderId, blockTimestamp);\r\n\r\n        if (orderExpired) {\r\n            //remove stake\r\n            orderPool.salesRate[orderId] = 0;\r\n        }\r\n        //if order has not yet expired, we just adjust the start\r\n        else {\r\n            orderPool.rewardFactorAtSubmission[orderId] = orderPool.rewardFactor;\r\n        }\r\n    }\r\n\r\n    ///@notice view function for getting the current proceeds for the given order\r\n    function orderPoolGetProceeds(OrderPool storage orderPool, uint256 orderId, uint256 blockTimestamp) internal view returns (bool orderExpired, uint256 totalReward) {\r\n        uint256 stakedAmount = orderPool.salesRate[orderId];\r\n        require(stakedAmount > 0);\r\n        uint256 orderExpiry = orderPool.orderExpiry[orderId];\r\n        uint256 rewardFactorAtSubmission = orderPool.rewardFactorAtSubmission[orderId];\r\n\r\n        //if order has expired, we need to calculate the reward factor at expiry\r\n        if (blockTimestamp > orderExpiry) {\r\n            uint256 rewardFactorAtExpiry = orderPool.rewardFactorAtTimestamp[orderExpiry];\r\n            unchecked { // subtraction is with underflow\r\n                totalReward = ((rewardFactorAtExpiry - rewardFactorAtSubmission) * stakedAmount / SELL_RATE_ADDITIONAL_PRECISION) / Q112;\r\n            }\r\n            orderExpired = true;\r\n        }\r\n        else {\r\n            unchecked { // subtraction is with underflow\r\n                totalReward = ((orderPool.rewardFactor - rewardFactorAtSubmission) * stakedAmount / SELL_RATE_ADDITIONAL_PRECISION) / Q112;\r\n            }\r\n            orderExpired = false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/FraxswapPair.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// =========================== FraxswapPair ===========================\r\n// ====================================================================\r\n// TWAMM LP Pair Token\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FraxswapPair is IUniswapV2PairPartialV5, FraxswapERC20 {\r\n    using UQ112x112 for uint224;\r\n    using LongTermOrdersLib for LongTermOrdersLib.LongTermOrders;\r\n    using LongTermOrdersLib for LongTermOrdersLib.ExecuteVirtualOrdersResult;\r\n\r\n    /// ---------------------------\r\n    /// -----TWAMM Parameters -----\r\n    /// ---------------------------\r\n\r\n    // address public owner_address;\r\n\r\n    ///@notice time interval that are eligible for order expiry (to align expiries)\r\n    uint256 public orderTimeInterval = 3600;\r\n\r\n    ///@notice data structure to handle long term orders\r\n    LongTermOrdersLib.LongTermOrders internal longTermOrders;\r\n\r\n    uint112 public twammReserve0;\r\n    uint112 public twammReserve1;\r\n\r\n    bool public newSwapsPaused;\r\n\r\n    modifier execVirtualOrders() {\r\n        executeVirtualOrdersInternal(block.timestamp);\r\n        _;\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// -------- Modifiers --------\r\n    /// ---------------------------\r\n\r\n    ///@notice Throws if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(IUniswapV2FactoryV5(factory).feeToSetter() == msg.sender); // NOT OWNER\r\n        _;\r\n    }\r\n\r\n    ///@notice Checks if new swaps are paused. If they are, only allow closing of existing ones.\r\n    modifier isNotPaused() {\r\n        require(newSwapsPaused == false); // NEW LT ORDERS PAUSED\r\n        _;\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// --------- Events ----------\r\n    /// ---------------------------\r\n\r\n    ///@notice An event emitted when a long term swap from token0 to token1 is performed\r\n    event LongTermSwap0To1(address indexed addr, uint256 orderId, uint256 amount0In, uint256 numberOfTimeIntervals);\r\n\r\n    ///@notice An event emitted when a long term swap from token1 to token0 is performed\r\n    event LongTermSwap1To0(address indexed addr, uint256 orderId, uint256 amount1In, uint256 numberOfTimeIntervals);\r\n\r\n    ///@notice An event emitted when a long term swap is cancelled\r\n    event CancelLongTermOrder(address indexed addr, uint256 orderId, address sellToken, uint256 unsoldAmount, address buyToken, uint256 purchasedAmount);\r\n\r\n    ///@notice An event emitted when a long term swap is withdrawn\r\n    event WithdrawProceedsFromLongTermOrder(address indexed addr, uint256 orderId, address indexed proceedToken, uint256 proceeds, bool orderExpired);\r\n\r\n    ///@notice An event emitted when virtual orders are executed\r\n    event VirtualOrderExecution(uint256 blocktimestamp, uint256 newReserve0, uint256 newReserve1, uint256 newTwammReserve0, uint256 newTwammReserve1, uint256 token0Bought, uint256 token1Bought, uint256 token0Sold, uint256 token1Sold, uint256 expiries);\r\n\r\n    /// -------------------------------\r\n    /// -----UNISWAPV2 Parameters -----\r\n    /// -------------------------------\r\n\r\n    uint public constant override MINIMUM_LIQUIDITY = 10 ** 3;\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    address public override factory;\r\n    address public override token0;\r\n    address public override token1;\r\n\r\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\r\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\r\n\r\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    uint public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    // Track order IDs\r\n    mapping(address => uint256[]) public orderIDsForUser;\r\n\r\n    TWAPObservation[] public TWAPObservationHistory;\r\n\r\n    struct TWAPObservation {\r\n        uint timestamp;\r\n        uint price0CumulativeLast;\r\n        uint price1CumulativeLast;\r\n    }\r\n    function price0CumulativeLast() public view override returns (uint){\r\n        return TWAPObservationHistory.length > 0 ? TWAPObservationHistory[TWAPObservationHistory.length - 1].price0CumulativeLast : 0;\r\n    }\r\n    function price1CumulativeLast() public view override returns (uint){\r\n        return TWAPObservationHistory.length > 0 ? TWAPObservationHistory[TWAPObservationHistory.length - 1].price1CumulativeLast : 0;\r\n    }\r\n    function getTWAPHistoryLength() public view override returns (uint){\r\n        return TWAPObservationHistory.length;\r\n    }\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1); // LOCKED\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    function getOrderIDsForUser(address user) external view returns (uint256[] memory) {\r\n        return orderIDsForUser[user];\r\n    }\r\n\r\n    function getOrderIDsForUserLength(address user) external view returns (uint256) {\r\n        return orderIDsForUser[user].length;\r\n    }\r\n\r\n    function getDetailedOrdersForUser(address user, uint256 offset, uint256 limit) external view returns (LongTermOrdersLib.Order[] memory detailed_orders) {\r\n        uint256[] memory order_ids = orderIDsForUser[user];\r\n        uint256 length_remaining = order_ids.length - offset;\r\n        uint256 limit_to_use = Math.min(limit, length_remaining);\r\n        detailed_orders = new LongTermOrdersLib.Order[](limit_to_use);\r\n\r\n        for (uint256 i = 0; i < limit_to_use; i++){ \r\n            detailed_orders[i] = longTermOrders.orderMap[order_ids[offset + i]];\r\n        }\r\n    }\r\n\r\n    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\r\n        return (reserve0, reserve1, blockTimestampLast);\r\n    }\r\n\r\n    function getTwammReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast, uint112 _twammReserve0, uint112 _twammReserve1) {\r\n        return (reserve0, reserve1, blockTimestampLast, twammReserve0, twammReserve1);\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"EC01\"); // TRANSFER_FAILED\r\n    }\r\n\r\n    constructor() public {\r\n        factory = msg.sender;\r\n        // owner_address = IUniswapV2FactoryV5(factory).feeToSetter();\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external override {\r\n        require(msg.sender == factory); // FORBIDDEN\r\n        // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n\r\n        // TWAMM\r\n        longTermOrders.initialize(_token0, _token1, block.timestamp, orderTimeInterval);\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\r\n        require(balance0 + twammReserve0 <= type(uint112).max && balance1 + twammReserve1 <= type(uint112).max, \"EC02\"); // OVERFLOW\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n\r\n        uint32 timeElapsed;\r\n        unchecked{\r\n            timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n            if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n                // * never overflows, and + overflow is desired\r\n                TWAPObservationHistory.push(\r\n                    TWAPObservation(\r\n                        blockTimestamp,\r\n                        price0CumulativeLast() + uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed,\r\n                        price1CumulativeLast() + uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed\r\n                    )\r\n                );\r\n            }\r\n        }\r\n\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\r\n        address feeTo = IUniswapV2FactoryV5(factory).feeTo();\r\n        feeOn = feeTo != address(0);\r\n        uint _kLast = kLast; // gas savings\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint rootK = Math.sqrt(uint(_reserve0) * _reserve1);\r\n                uint rootKLast = Math.sqrt(_kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint numerator = totalSupply * (rootK - rootKLast);\r\n                    uint denominator = (rootK * 5) + rootKLast;\r\n                    uint liquidity = numerator / denominator;\r\n                    if (liquidity > 0) _mint(feeTo, liquidity);\r\n                }\r\n            }\r\n        } else if (_kLast != 0) {\r\n            kLast = 0;\r\n        }\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external override lock execVirtualOrders returns (uint liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        uint balance0 = IERC20V5(token0).balanceOf(address(this)) - twammReserve0;\r\n        uint balance1 = IERC20V5(token1).balanceOf(address(this)) - twammReserve1;\r\n        uint amount0 = balance0 - _reserve0;\r\n        uint amount1 = balance1 - _reserve1;\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\r\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(amount0 * _totalSupply / _reserve0, amount1 * _totalSupply / _reserve1);\r\n        }\r\n        require(liquidity > 0); // INSUFFICIENT_LIQUIDITY_MINTED\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external override lock execVirtualOrders returns (uint amount0, uint amount1) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        uint balance0 = IERC20V5(_token0).balanceOf(address(this)) - twammReserve0;\r\n        uint balance1 = IERC20V5(_token1).balanceOf(address(this)) - twammReserve1;\r\n        uint liquidity = balanceOf[address(this)];\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amount0 = liquidity * balance0 / _totalSupply; // using balances ensures pro-rata distribution\r\n        amount1 = liquidity * balance1 / _totalSupply; // using balances ensures pro-rata distribution\r\n        require(amount0 > 0 && amount1 > 0); // INSUFFICIENT_LIQUIDITY_BURNED\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n        balance0 = IERC20V5(_token0).balanceOf(address(this)) - twammReserve0;\r\n        balance1 = IERC20V5(_token1).balanceOf(address(this)) - twammReserve1;\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock execVirtualOrders {\r\n        require(amount0Out > 0 || amount1Out > 0, \"EC03\"); // INSUFFICIENT_OUTPUT_AMOUNT\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"EC04\"); // INSUFFICIENT_LIQUIDITY\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        {// scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            require(to != _token0 && to != _token1, \"EC05\"); // INVALID_TO\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\r\n            if (data.length > 0) IUniswapV2CalleeV5(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n            balance0 = IERC20V5(_token0).balanceOf(address(this)) - twammReserve0;\r\n            balance1 = IERC20V5(_token1).balanceOf(address(this)) - twammReserve1;\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        require(amount0In > 0 || amount1In > 0, \"EC06\"); // INSUFFICIENT_INPUT_AMOUNT\r\n        {// scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n            uint balance0Adjusted = (balance0 * 1000) - (amount0In * 3);\r\n            uint balance1Adjusted = (balance1 * 1000) - (amount1In * 3);\r\n            require(balance0Adjusted * balance1Adjusted >= uint(_reserve0) * _reserve1 * (1000 ** 2), 'K');\r\n        }\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external override lock execVirtualOrders {\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        _safeTransfer(_token0, to, IERC20V5(_token0).balanceOf(address(this)) - (reserve0 + twammReserve0));\r\n        _safeTransfer(_token1, to, IERC20V5(_token1).balanceOf(address(this)) - (reserve1 + twammReserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external override lock execVirtualOrders {\r\n        _update(\r\n            IERC20V5(token0).balanceOf(address(this)) - twammReserve0,\r\n            IERC20V5(token1).balanceOf(address(this)) - twammReserve1,\r\n            reserve0, reserve1\r\n        );\r\n    }\r\n\r\n    // TWAMM\r\n\r\n    ///@notice calculate the amount in for token0 using the balance diff to handle feeOnTransfer tokens\r\n    function transferAmount0In(uint amount0In) internal returns(uint256){\r\n        // prev balance\r\n        uint bal0 = IERC20V5(token0).balanceOf(address(this));\r\n        // transfer amount to contract\r\n        TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0In);\r\n        // balance change\r\n        return IERC20V5(token0).balanceOf(address(this)) - bal0;\r\n    }\r\n\r\n    ///@notice calculate the amount in for token1 using the balance diff to handle feeOnTransfer tokens\r\n    function transferAmount1In(uint amount1In) internal returns(uint256){\r\n        // prev balance\r\n        uint bal1 = IERC20V5(token1).balanceOf(address(this));\r\n        // transfer amount to contract\r\n        TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1In);\r\n        // balance change\r\n        return IERC20V5(token1).balanceOf(address(this)) - bal1;\r\n    }\r\n\r\n    ///@notice create a long term order to swap from token0\r\n    ///@param amount0In total amount of token0 to swap\r\n    ///@param numberOfTimeIntervals number of time intervals over which to execute long term order\r\n    function longTermSwapFrom0To1(uint256 amount0In, uint256 numberOfTimeIntervals) external lock isNotPaused execVirtualOrders returns (uint256 orderId) {\r\n        uint amount0 = transferAmount0In(amount0In);\r\n        twammReserve0 += uint112(amount0);\r\n        require(uint256(reserve0) + twammReserve0 <= type(uint112).max); // OVERFLOW\r\n        orderId = longTermOrders.longTermSwapFrom0To1(amount0, numberOfTimeIntervals);\r\n        orderIDsForUser[msg.sender].push(orderId);\r\n        emit LongTermSwap0To1(msg.sender, orderId, amount0, numberOfTimeIntervals);\r\n    }\r\n\r\n    ///@notice create a long term order to swap from token1\r\n    ///@param amount1In total amount of token1 to swap\r\n    ///@param numberOfTimeIntervals number of time intervals over which to execute long term order\r\n    function longTermSwapFrom1To0(uint256 amount1In, uint256 numberOfTimeIntervals) external lock isNotPaused execVirtualOrders returns (uint256 orderId) {\r\n        uint amount1 = transferAmount1In(amount1In);\r\n        twammReserve1 += uint112(amount1);\r\n        require(uint256(reserve1) + twammReserve1 <= type(uint112).max); // OVERFLOW\r\n        orderId = longTermOrders.longTermSwapFrom1To0(amount1, numberOfTimeIntervals);\r\n        orderIDsForUser[msg.sender].push(orderId);\r\n        emit LongTermSwap1To0(msg.sender, orderId, amount1, numberOfTimeIntervals);\r\n    }\r\n\r\n    ///@notice stop the execution of a long term order\r\n    function cancelLongTermSwap(uint256 orderId) external lock execVirtualOrders {\r\n        (address sellToken, uint256 unsoldAmount, address buyToken, uint256 purchasedAmount) = longTermOrders.cancelLongTermSwap(orderId);\r\n\r\n        bool buyToken0 = buyToken == token0;\r\n        twammReserve0 -= uint112(buyToken0 ? purchasedAmount : unsoldAmount);\r\n        twammReserve1 -= uint112(buyToken0 ? unsoldAmount : purchasedAmount);\r\n\r\n        // update order. Used for tracking / informational\r\n        longTermOrders.orderMap[orderId].isComplete = true;\r\n\r\n        // transfer to owner of order\r\n        _safeTransfer(buyToken, msg.sender, purchasedAmount);\r\n        _safeTransfer(sellToken, msg.sender, unsoldAmount);\r\n\r\n        emit CancelLongTermOrder(msg.sender, orderId, sellToken, unsoldAmount, buyToken, purchasedAmount);\r\n    }\r\n\r\n    ///@notice withdraw proceeds from a long term swap\r\n    function withdrawProceedsFromLongTermSwap(uint256 orderId) external lock execVirtualOrders returns (bool is_expired, address rewardTkn, uint256 totalReward) {\r\n        (address proceedToken, uint256 proceeds, bool orderExpired) = longTermOrders.withdrawProceedsFromLongTermSwap(orderId);\r\n        if (proceedToken == token0) {\r\n            twammReserve0 -= uint112(proceeds);\r\n        } else {\r\n            twammReserve1 -= uint112(proceeds);\r\n        }\r\n\r\n        // update order. Used for tracking / informational\r\n        if (orderExpired) longTermOrders.orderMap[orderId].isComplete = true;\r\n\r\n        // transfer to owner of order\r\n        _safeTransfer(proceedToken, msg.sender, proceeds);\r\n\r\n        emit WithdrawProceedsFromLongTermOrder(msg.sender, orderId, proceedToken, proceeds, orderExpired);\r\n\r\n        return (orderExpired, proceedToken, proceeds);\r\n    }\r\n\r\n    ///@notice execute virtual orders in the twamm, bring it up to the blockNumber passed in\r\n    ///updates the TWAP if it is the first amm tx of the block\r\n    function executeVirtualOrdersInternal(uint256 blockTimestamp) internal {\r\n\r\n        if(newSwapsPaused) return; // skip twamm executions\r\n        if(twammUpToDate()) return; // save gas\r\n\r\n        LongTermOrdersLib.ExecuteVirtualOrdersResult memory result;\r\n        result.newReserve0 = reserve0;\r\n        result.newReserve1 = reserve1;\r\n        result.newTwammReserve0 = twammReserve0;\r\n        result.newTwammReserve1 = twammReserve1;\r\n\r\n        longTermOrders.executeVirtualOrdersUntilTimestamp(blockTimestamp, result);\r\n\r\n        twammReserve0 = uint112(result.newTwammReserve0);\r\n        twammReserve1 = uint112(result.newTwammReserve1);\r\n        \r\n        uint112 newReserve0 = uint112(result.newReserve0);\r\n        uint112 newReserve1 = uint112(result.newReserve1);\r\n\r\n        uint32 _blockTimestamp = uint32(blockTimestamp % 2 ** 32);\r\n        uint32 timeElapsed;\r\n        unchecked{\r\n            timeElapsed = _blockTimestamp - blockTimestampLast; // overflow is desired\r\n        }\r\n        // update reserve0 and reserve1\r\n        if ( timeElapsed > 0 && (newReserve0 != reserve0 || newReserve1 != reserve1)) {\r\n            emit VirtualOrderExecution(\r\n                _blockTimestamp,\r\n                result.newReserve0,\r\n                result.newReserve1,\r\n                result.newTwammReserve0,\r\n                result.newTwammReserve1,\r\n                result.token0Bought,\r\n                result.token1Bought,\r\n                result.token0Sold,\r\n                result.token1Sold,\r\n                result.expiries\r\n            );\r\n            _update(newReserve0, newReserve1, reserve0, reserve1);\r\n        } else {\r\n            reserve0 = newReserve0;\r\n            reserve1 = newReserve1;\r\n        }\r\n    }\r\n\r\n    ///@notice convenience function to execute virtual orders. Note that this already happens\r\n    ///before most interactions with the AMM\r\n    function executeVirtualOrders(uint256 blockTimestamp) public override lock {\r\n        // blockTimestamp is valid\r\n        require(longTermOrders.lastVirtualOrderTimestamp <= blockTimestamp && blockTimestamp <= block.timestamp); // INVALID TIMESTAMP\r\n        executeVirtualOrdersInternal(blockTimestamp);\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// ------- TWAMM Views -------\r\n    /// ---------------------------\r\n\r\n    ///@notice util function for getting the next orderId\r\n    function getNextOrderID() public override view returns (uint256){\r\n        return longTermOrders.orderId;\r\n    }\r\n\r\n    ///@notice util function for checking if the twamm is up to date\r\n    function twammUpToDate() public override view returns (bool) {\r\n        return block.timestamp == longTermOrders.lastVirtualOrderTimestamp;\r\n    }\r\n\r\n    function getReserveAfterTwamm(uint256 blockTimestamp) public view returns (\r\n        uint112 _reserve0, uint112 _reserve1,\r\n        uint256 lastVirtualOrderTimestamp,\r\n        uint112 _twammReserve0, uint112 _twammReserve1\r\n    ) {\r\n\r\n        lastVirtualOrderTimestamp = longTermOrders.lastVirtualOrderTimestamp;\r\n\r\n        uint112 bal0 = reserve0 + twammReserve0; // save the balance of token0\r\n        uint112 bal1 = reserve1 + twammReserve1; // save the balance of token1\r\n\r\n        LongTermOrdersLib.ExecuteVirtualOrdersResult memory result;\r\n        result.newReserve0 = reserve0;\r\n        result.newReserve1 = reserve1;\r\n        result.newTwammReserve0 = twammReserve0;\r\n        result.newTwammReserve1 = twammReserve1;\r\n\r\n        longTermOrders.executeVirtualOrdersUntilTimestampView(blockTimestamp, result);\r\n\r\n        _reserve0 = uint112(bal0 - result.newTwammReserve0);\r\n        _reserve1 = uint112(bal1 - result.newTwammReserve1);\r\n        _twammReserve0 = uint112(result.newTwammReserve0);\r\n        _twammReserve1 = uint112(result.newTwammReserve1);\r\n    }\r\n\r\n    ///@notice returns the current state of the twamm\r\n    function getTwammState() public override view returns (\r\n        uint256 token0Rate,\r\n        uint256 token1Rate,\r\n        uint256 lastVirtualOrderTimestamp,\r\n        uint256 orderTimeInterval_rtn,\r\n        uint256 rewardFactorPool0,\r\n        uint256 rewardFactorPool1\r\n    ){\r\n        token0Rate = longTermOrders.OrderPool0.currentSalesRate;\r\n        token1Rate = longTermOrders.OrderPool1.currentSalesRate;\r\n        lastVirtualOrderTimestamp = longTermOrders.lastVirtualOrderTimestamp;\r\n        orderTimeInterval_rtn = longTermOrders.orderTimeInterval;\r\n        rewardFactorPool0 = longTermOrders.OrderPool0.rewardFactor;\r\n        rewardFactorPool1 = longTermOrders.OrderPool1.rewardFactor;\r\n    }\r\n\r\n    ///@notice returns salesRates ending on this blockTimestamp\r\n    function getTwammSalesRateEnding(uint256 _blockTimestamp) public override view returns (\r\n        uint256 orderPool0SalesRateEnding,\r\n        uint256 orderPool1SalesRateEnding\r\n    ){\r\n        uint256 lastExpiryTimestamp = _blockTimestamp - (_blockTimestamp % longTermOrders.orderTimeInterval);\r\n        orderPool0SalesRateEnding = longTermOrders.OrderPool0.salesRateEndingPerTimeInterval[lastExpiryTimestamp];\r\n        orderPool1SalesRateEnding = longTermOrders.OrderPool1.salesRateEndingPerTimeInterval[lastExpiryTimestamp];\r\n    }\r\n\r\n    ///@notice returns reward factors at this blockTimestamp\r\n    function getTwammRewardFactor(uint256 _blockTimestamp) public override view returns (\r\n        uint256 rewardFactorPool0AtTimestamp,\r\n        uint256 rewardFactorPool1AtTimestamp\r\n    ){\r\n        uint256 lastExpiryTimestamp = _blockTimestamp - (_blockTimestamp % longTermOrders.orderTimeInterval);\r\n        rewardFactorPool0AtTimestamp = longTermOrders.OrderPool0.rewardFactorAtTimestamp[lastExpiryTimestamp];\r\n        rewardFactorPool1AtTimestamp = longTermOrders.OrderPool1.rewardFactorAtTimestamp[lastExpiryTimestamp];\r\n    }\r\n\r\n    ///@notice returns the twamm Order struct\r\n    function getTwammOrder(uint256 orderId) public override view returns (\r\n        uint256 id,\r\n        uint256 expirationTimestamp,\r\n        uint256 saleRate,\r\n        address owner,\r\n        address sellTokenAddr,\r\n        address buyTokenAddr\r\n    ){\r\n        require(orderId < longTermOrders.orderId); // INVALID ORDERID\r\n        LongTermOrdersLib.Order storage order = longTermOrders.orderMap[orderId];\r\n        return (order.id, order.expirationTimestamp, order.saleRate, order.owner, order.sellTokenAddr, order.buyTokenAddr);\r\n    }\r\n\r\n    ///@notice returns the twamm Order withdrawable proceeds\r\n    // IMPORTANT: Can be stale. Should call executeVirtualOrders first or use getTwammOrderProceeds below.\r\n    // You can also .call() withdrawProceedsFromLongTermSwap\r\n    // blockTimestamp should be <= current\r\n    function getTwammOrderProceedsView(uint256 orderId, uint256 blockTimestamp) public override view returns (\r\n        bool orderExpired,\r\n        uint256 totalReward\r\n    ){\r\n        require(orderId < longTermOrders.orderId); // INVALID ORDERID\r\n        LongTermOrdersLib.OrderPool storage orderPool = LongTermOrdersLib.getOrderPool(longTermOrders, longTermOrders.orderMap[orderId].sellTokenAddr);\r\n        (orderExpired, totalReward) = LongTermOrdersLib.orderPoolGetProceeds(orderPool, orderId, blockTimestamp);\r\n    }\r\n\r\n    ///@notice returns the twamm Order withdrawable proceeds\r\n    // Need to update the virtual orders first\r\n    function getTwammOrderProceeds(uint256 orderId) public override returns (\r\n        bool orderExpired,\r\n        uint256 totalReward\r\n    ){\r\n        executeVirtualOrders(block.timestamp);\r\n        return getTwammOrderProceedsView(orderId, block.timestamp);\r\n    }\r\n\r\n\r\n    /* ========== RESTRICTED FUNCTIONS - Owner only ========== */\r\n\r\n    // Only callable once\r\n    function togglePauseNewSwaps() external override onlyOwner {\r\n        // Pause new swaps\r\n        require(!newSwapsPaused);\r\n        newSwapsPaused = true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/FraxswapFactory.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ========================== FraxswapFactory =========================\r\n// ====================================================================\r\n// TWAMM LP Pair Factory\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\ncontract FraxswapFactory is IUniswapV2FactoryV5 {\r\n    address public override feeTo;\r\n    address public override feeToSetter;\r\n\r\n    mapping(address => mapping(address => address)) public override getPair;\r\n    address[] public override allPairs;\r\n\r\n    constructor(address _feeToSetter) {\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n\r\n    ///@notice Throws if called by any account other than the feeToSetter.\r\n    modifier onlyFTS() {\r\n        require(msg.sender == feeToSetter); // FORBIDDEN\r\n        _;\r\n    }\r\n\r\n    function allPairsLength() external override view returns (uint) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\r\n        require(tokenA != tokenB, \"IDENTICAL_ADDRESSES\"); // IDENTICAL_ADDRESSES\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"ZERO_ADDRESS\"); // ZERO_ADDRESS\r\n        require(getPair[token0][token1] == address(0), \"PAIR_EXISTS\"); // PAIR_EXISTS // single check is sufficient\r\n        bytes memory bytecode = type(FraxswapPair).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        FraxswapPair(pair).initialize(token0, token1);\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n\r\n    function setFeeTo(address _feeTo) external override onlyFTS {\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    function setFeeToSetter(address _feeToSetter) external override onlyFTS {\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FraxswapFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "00000000000000000000000049f9cbf5333d8e50c9be76c775777db2acb1d456", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ba7a5d3053c5ce04cf80b09fd569e35cbef3c6f605d7779642f67e474085afc1"}