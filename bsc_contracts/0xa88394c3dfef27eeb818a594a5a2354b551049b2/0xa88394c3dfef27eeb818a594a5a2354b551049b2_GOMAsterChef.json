{"SourceCode": "/** \r\n\r\n      /$$$$$$   /$$$$$$  /$$      /$$  /$$$$$$              /$$                          /$$$$$$  /$$                  /$$$$$$ \r\n     /$$__  $$ /$$__  $$| $$$    /$$$ /$$__  $$            | $$                         /$$__  $$| $$                 /$$__  $$\r\n    | $$  \\__/| $$  \\ $$| $$$$  /$$$$| $$  \\ $$  /$$$$$$$ /$$$$$$    /$$$$$$   /$$$$$$ | $$  \\__/| $$$$$$$   /$$$$$$ | $$  \\__/\r\n    | $$ /$$$$| $$  | $$| $$ $$/$$ $$| $$$$$$$$ /$$_____/|_  $$_/   /$$__  $$ /$$__  $$| $$      | $$__  $$ /$$__  $$| $$$$    \r\n    | $$|_  $$| $$  | $$| $$  $$$| $$| $$__  $$|  $$$$$$   | $$    | $$$$$$$$| $$  \\__/| $$      | $$  \\ $$| $$$$$$$$| $$_/    \r\n    | $$  \\ $$| $$  | $$| $$\\  $ | $$| $$  | $$ \\____  $$  | $$ /$$| $$_____/| $$      | $$    $$| $$  | $$| $$_____/| $$      \r\n    |  $$$$$$/|  $$$$$$/| $$ \\/  | $$| $$  | $$ /$$$$$$$/  |  $$$$/|  $$$$$$$| $$      |  $$$$$$/| $$  | $$|  $$$$$$$| $$      \r\n     \\______/  \\______/ |__/     |__/|__/  |__/|_______/    \\___/   \\_______/|__/       \\______/ |__/  |__/ \\_______/|__/     \r\n     \r\n     \r\n                                             ___________________ __________.___.___ \r\n                                            \\__    ___/\\_____  \\\\______   \\   |   |\r\n                                              |    |    /   |   \\|       _/   |   |\r\n                                              |    |   /    |    \\    |   \\   |   |\r\n                                              |____|   \\_______  /____|_  /___|___|\r\n                                                               \\/       \\/    \r\n                                                               \r\n                                                               \r\n                                                  *****************************\r\n                                                        \r\n                                                        \r\n                                                    GOMAsterChef for TORII v3\r\n                                                     \r\n     \r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\n\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() {\r\n\t\t_setOwner(_msgSender());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\t_setOwner(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\t_setOwner(newOwner);\r\n\t}\r\n\r\n\tfunction _setOwner(address newOwner) private {\r\n\t\taddress oldOwner = _owner;\r\n\t\t_owner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\nabstract contract Operable is Ownable {\r\n\tmapping(address => bool) public operators;\r\n\taddress[] public operatorsList;\r\n\r\n\tconstructor() {\r\n\t\tsetOperator(_msgSender(), true);\r\n\t}\r\n\r\n\tfunction setOperator(address operator, bool state) public onlyOwner {\r\n\t\toperators[operator] = state;\r\n\t\tif (state) {\r\n\t\t\toperatorsList.push(operator);\r\n\t\t}\r\n\t\temit OperatorSet(operator, state);\r\n\t}\r\n\r\n\tfunction operatorsCount() public view returns (uint256) {\r\n\t\treturn operatorsList.length;\r\n\t}\r\n\r\n\tmodifier onlyOperator() {\r\n\t\trequire(operators[_msgSender()] || _msgSender() == owner(), \"Sender is not the operator or owner\");\r\n\t\t_;\r\n\t}\r\n\tevent OperatorSet(address operator, bool state);\r\n}\r\n\r\ninterface IBEP20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction decimals() external view returns (uint8);\r\n\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\tfunction name() external view returns (string memory);\r\n\r\n\tfunction getOwner() external view returns (address);\r\n\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\tuint256 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(account)\r\n\t\t}\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\t\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction _verifyCallResult(\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) private pure returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nlibrary SafeBEP20 {\r\n\tusing Address for address;\r\n\r\n\tfunction safeTransfer(\r\n\t\tIBEP20 token,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n\t}\r\n\r\n\tfunction safeTransferFrom(\r\n\t\tIBEP20 token,\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Deprecated. This function has issues similar to the ones found in\r\n\t * {IBEP20-approve}, and its usage is discouraged.\r\n\t *\r\n\t * Whenever possible, use {safeIncreaseAllowance} and\r\n\t * {safeDecreaseAllowance} instead.\r\n\t */\r\n\tfunction safeApprove(\r\n\t\tIBEP20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t// safeApprove should only be called when setting an initial allowance,\r\n\t\t// or when resetting it to zero. To increase and decrease it, use\r\n\t\t// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n\t\trequire((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeBEP20: approve from non-zero to non-zero allowance\");\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n\t}\r\n\r\n\tfunction safeIncreaseAllowance(\r\n\t\tIBEP20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\tuint256 newAllowance = token.allowance(address(this), spender) + value;\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n\t}\r\n\r\n\tfunction safeDecreaseAllowance(\r\n\t\tIBEP20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\tunchecked {\r\n\t\t\tuint256 oldAllowance = token.allowance(address(this), spender);\r\n\t\t\trequire(oldAllowance >= value, \"SafeBEP20: decreased allowance below zero\");\r\n\t\t\tuint256 newAllowance = oldAllowance - value;\r\n\t\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n\t * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n\t * @param token The token targeted by the call.\r\n\t * @param data The call data (encoded using abi.encode or one of its variants).\r\n\t */\r\n\tfunction _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n\t\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n\t\tbytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\r\n\t\tif (returndata.length > 0) {\r\n\t\t\t// Return data is optional\r\n\t\t\trequire(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract GOMAsterChef is Operable {\r\n\tusing SafeBEP20 for IBEP20;\r\n\r\n\tstruct UserInfo {\r\n\t\tuint256 amount;\r\n\t\tuint256 rewardDebt;\r\n\t}\r\n\r\n\tuint256 public lastRewardTimestamp;\r\n\tuint256 public accRewardTokensPerShare;\r\n\tuint256 public claimedRewardTokens;\r\n\r\n\tIBEP20 public rewardToken;\r\n\tIBEP20 public immutable stakedToken;\r\n\tuint256 public stakedTokenDeposied;\r\n\t\r\n\tuint256 public tokensPerSecond;\r\n\tuint256 public minDepositAmount;\r\n\r\n\tmapping(address => UserInfo) public userInfo;\r\n\taddress[] public users;\r\n\r\n\tuint256 public startTimestamp;\r\n\tuint256 public pausedTimestamp;\r\n\tbool public productionMode = false;\r\n\r\n\tevent Deposit(address indexed user, uint256 amount);\r\n\tevent Withdraw(address indexed user, uint256 amount);\r\n\tevent Claim(address indexed user, uint256 amount);\r\n\tevent EmergencyWithdraw(address indexed user, uint256 amount);\r\n\tevent Supply(address indexed user, uint256 amount);\r\n\r\n\tmodifier onlyStarted() {\r\n\t\trequire(startTimestamp != 0, \"GOMAsterChef: not started\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor() {\r\n\t\tstakedToken = IBEP20(0x25c54f9b99eE53eE7ab769D5897B886FE661bd2C); // GOMA\r\n\t\trewardToken = IBEP20(0xD9979e2479AEa29751D31AE512a61297B98Fbbf4); // TORII\r\n\t\t\t\t\r\n\t\ttokensPerSecond = 30000000000000;\r\n\t\tminDepositAmount = 1_000_000_000 * 1e9; \r\n\t}\r\n\r\n\tfunction getData()\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 _stakedTokenDeposied, \r\n\t\t\tuint256 _tokensPerSecond,\r\n\t\t\tuint256 _minDepositAmount,\r\n\t\t\tuint256 _startTimestamp,\r\n\t\t\tuint256 _pausedTimestamp\r\n\t\t)\r\n\t{\r\n    _stakedTokenDeposied = stakedTokenDeposied;\r\n    _tokensPerSecond = tokensPerSecond;\r\n    _minDepositAmount = minDepositAmount;\r\n    _startTimestamp = startTimestamp;\r\n    _pausedTimestamp = pausedTimestamp;    \r\n\t}\r\n\r\n\tfunction getUserData(address account)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 _pendingRewards, \r\n\t\t\tuint256 _depositedAmount,\r\n\t\t\tuint256 _balanceStakeTokens,\r\n\t\t\tuint256 _allowanceStakeTokens,\r\n\t\t\tuint256 _balanceRewardTokens\r\n\t\t)\r\n\t{\r\n    _pendingRewards = pendingRewardsOfUser(account);\r\n    _depositedAmount = userInfo[account].amount;\r\n    _balanceStakeTokens = stakedToken.balanceOf(account);\r\n    _allowanceStakeTokens = stakedToken.allowance(account, address(this));\r\n    _balanceRewardTokens = rewardToken.balanceOf(account);\r\n\t}\r\n\r\n\tfunction setRewardTokensPerSecond(uint256 _tokensPerSecond) external onlyOwner onlyStarted {\r\n\t\trequire(pausedTimestamp == 0, \"GOMAsterChef setTokensPerSecond: you can't set while paused!\");\t\t\r\n\t\t_updatePool();\r\n\t\ttokensPerSecond = _tokensPerSecond;\r\n\t}\r\n\r\n\tfunction setMinDepositAmount(uint256 _minDepositAmount) external onlyOwner {\r\n\t\trequire(_minDepositAmount != 0, \"GOMAsterChef setMinDepositAmount: 0!\");\r\n\t\tminDepositAmount = _minDepositAmount;\r\n\t}\r\n\r\n\tfunction pauseOn() external onlyOwner onlyStarted {\r\n\t\trequire(pausedTimestamp == 0, \"GOMAsterChef pause: already paused!\");\r\n\t\tpausedTimestamp = blockTimestamp();\r\n\t}\r\n\r\n\tfunction pauseOff() external onlyOwner onlyStarted {\r\n\t\trequire(pausedTimestamp != 0, \"GOMAsterChef resume: not paused!\");\r\n\t\t_updatePool();\r\n\t\tpausedTimestamp = 0;\r\n\t}\r\n\r\n\tfunction getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\r\n\t\t_from = _from > startTimestamp ? _from : startTimestamp;\r\n\t\tif (_to < startTimestamp) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif (pausedTimestamp != 0) {\r\n\t\t\treturn _to - (_from + blockTimestamp() - pausedTimestamp);\r\n\t\t} else {\r\n\t\t\treturn _to - _from;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getMultiplierNow() public view returns (uint256) {\r\n\t\treturn getMultiplier(lastRewardTimestamp, blockTimestamp());\r\n\t}\r\n\r\n\tfunction pendingRewardsOfSender() public view returns (uint256) {\r\n\t\treturn pendingRewardsOfUser(msg.sender);\r\n\t}\r\n\r\n\tfunction pendingRewardsOfUser(address _user) public view returns (uint256 amount) {\r\n\t\tUserInfo storage user = userInfo[_user];\r\n\t\tuint256 _accRewardTokensPerShare = accRewardTokensPerShare;\r\n\r\n\t\tif (stakedTokenDeposied != 0 && user.amount != 0 && blockTimestamp() > lastRewardTimestamp) {\r\n\t\t\t_accRewardTokensPerShare = accRewardTokensPerShare + (((getMultiplierNow() * tokensPerSecond) * 1e12) / stakedTokenDeposied);\r\n\t\t}\r\n\r\n\t\tuint256 pending = (user.amount * _accRewardTokensPerShare) / 1e12;\r\n\t\tif (pending > user.rewardDebt) {\r\n\t\t\tamount = pending - user.rewardDebt;\r\n\t\t} else {\r\n\t\t\tamount = 0;\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfunction getPending(UserInfo storage user) internal view returns (uint256) {\r\n\t\tuint256 pending = ((user.amount * accRewardTokensPerShare) / 1e12);\r\n\t\tif (pending > user.rewardDebt) {\r\n\t\t\treturn pending - user.rewardDebt;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updatePool() public onlyStarted {\r\n\t\trequire(pausedTimestamp == 0, \"GOMAsterChef updatePool: you can't update while paused!\");\r\n\t\t_updatePool();\r\n\t}\r\n\r\n\tfunction _updatePool() internal {\r\n\t\tif (blockTimestamp() <= lastRewardTimestamp) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (stakedTokenDeposied == 0) {\r\n\t\t\tlastRewardTimestamp = blockTimestamp();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\taccRewardTokensPerShare = accRewardTokensPerShare + (((getMultiplierNow() * tokensPerSecond) * 1e12) / stakedTokenDeposied);\r\n\t\tlastRewardTimestamp = blockTimestamp();\r\n\t}\r\n\r\n\tfunction deposit(uint256 _amount) public onlyStarted {\r\n\t\trequire(pausedTimestamp == 0, \"GOMAsterChef deposit: you can't deposit while paused!\");\r\n\t\trequire(_amount >= minDepositAmount, \"GOMAsterChef deposit: you can't deposit less than minDepositAmount of wei!\");\r\n\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\r\n\t\t_updatePool();\r\n\r\n\t\tif (stakedTokenDeposied != 0) {\r\n\t\t\tuint256 pending = getPending(user);\r\n\t\t\tif (pending != 0) {\r\n\t\t\t\tclaimedRewardTokens += pending;\r\n\t\t\t\tsafeRewardTransfer(msg.sender, pending);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tstakedTokenDeposied += _amount;\r\n\r\n\t\tif (user.amount == 0 && user.rewardDebt == 0) {\r\n\t\t\tusers.push(msg.sender);\r\n\t\t}\r\n\r\n\t\tuser.amount += _amount;\r\n\t\tuser.rewardDebt = (user.amount * accRewardTokensPerShare) / 1e12;\r\n\r\n\t\tstakedToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n\t\temit Deposit(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction start() external onlyOwner {\r\n\t\trequire(startTimestamp == 0, \"GOMAsterChef start: already started\");\r\n\t\tstartTimestamp = blockTimestamp();\r\n\t\tlastRewardTimestamp = blockTimestamp();\r\n\t}\r\n\r\n  function usersCount() public view returns (uint256) {\r\n\t\treturn users.length;\r\n\t}\r\n\r\n  struct UserExport {\r\n\t  \taddress account;\r\n\t\tuint256 amount;\r\n\t\tuint256 rewards;\r\n\t}\r\n\r\n  function getUsersExport(uint256 _startIndex, uint256 _endIndex) public view returns (UserExport[] memory userExport) {\r\n        userExport = new UserExport[](_endIndex - _startIndex);\r\n\t\tuint256 idx;\r\n        for (uint256 i = _startIndex; i < _endIndex; i++) {\r\n            address user = users[i];\r\n            userExport[idx] = UserExport(user, userInfo[user].amount, pendingRewardsOfUser(user));\r\n\t\t\tidx++;\r\n\t\t}    \r\n\t}\r\n\r\n\tfunction migrateUsers(address[] memory _users, uint256[] memory _amounts) external onlyOwner {\r\n        require(startTimestamp == 0, \"GOMAsterChef start: started\");\r\n\t\trequire(_users.length == _amounts.length, \"GOMAsterChef migrateUsers: number or recipients must be equal to number of amounts\");\r\n\t\tfor (uint256 i = 0; i < _users.length; i++) {\r\n\t\t\tuserInfo[_users[i]].amount = _amounts[i];\r\n\t\t\tstakedTokenDeposied = stakedTokenDeposied + _amounts[i];\r\n\t\t\tif (userInfo[_users[i]].amount != 0) {\r\n\t\t\t\tusers.push(_users[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Withdraw staked tokens\r\n\tfunction withdraw(uint256 _amount) public onlyStarted {\r\n\t\trequire(pausedTimestamp == 0, \"GOMAsterChef withdraw: you can't withdraw while paused!\");\r\n\t\trequire(_amount != 0, \"GOMAsterChef withdraw: you can't withdraw 0!\");\r\n\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.amount >= _amount, \"GOMAsterChef withdraw: not enough funds\");\r\n\r\n\t\t_updatePool();\r\n\r\n\t\tuint256 pending = getPending(user);\r\n\t\tif (pending != 0) {\r\n\t\t\tclaimedRewardTokens += pending;\r\n\t\t\tsafeRewardTransfer(msg.sender, pending);\r\n\t\t}\r\n\r\n\t\tuint256 finalAmount = _amount;\r\n\r\n\t\tif ((user.amount - _amount) < minDepositAmount) {\r\n\t\t\tfinalAmount = user.amount;\r\n\t\t\tuser.amount = 0;\r\n\t\t} else {\r\n\t\t\tuser.amount -= _amount;\t\t\t\r\n\t\t}\r\n        user.rewardDebt = (user.amount * accRewardTokensPerShare) / 1e12;\r\n\r\n\t\tstakedTokenDeposied -= finalAmount;\r\n\r\n\t\tstakedToken.safeTransfer(msg.sender, finalAmount);\r\n\t\temit Withdraw(msg.sender, finalAmount);\r\n\t}\r\n\r\n\t// Withdraw reward tokens\r\n\tfunction claim() public onlyStarted {\r\n\t\trequire(pausedTimestamp == 0, \"GOMAsterChef claim: you can't claim while paused!\");\r\n\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.amount != 0, \"GOMAsterChef claim: user deposited 0\");\r\n\r\n\t\t_updatePool();\r\n\r\n\t\tuint256 pending = getPending(user);\r\n\t\trequire(pending != 0, \"GOMAsterChef claim: nothing to claim\");\r\n\r\n\t\tuser.rewardDebt = (user.amount * accRewardTokensPerShare) / 1e12;\r\n\r\n\t\tclaimedRewardTokens += pending;\r\n\t\tsafeRewardTransfer(msg.sender, pending);\r\n\t\temit Claim(msg.sender, pending);\r\n\t}\r\n\r\n\t// Withdraw without caring about rewards. EMERGENCY ONLY.\r\n\tfunction withdrawEmergency() public onlyStarted {\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\r\n\t\tuint256 userAmount = user.amount;\r\n\t\trequire(userAmount != 0, \"GOMAsterChef emergencyWithdraw: nothing to withdraw\");\r\n\r\n\t\tuser.amount = 0;\r\n\t\tuser.rewardDebt = 0;\r\n\r\n\t\tstakedToken.safeTransfer(msg.sender, userAmount);\r\n\r\n\t\tstakedTokenDeposied -= userAmount;\r\n\r\n\t\temit EmergencyWithdraw(msg.sender, userAmount);\r\n\t}\r\n\r\n\t// Safe rewardToken transfer function.\r\n\tfunction safeRewardTransfer(address _to, uint256 _amount) internal {\r\n\t\tif (_amount > balanceOfRewardToken()) {\r\n\t\t\trevert(\"Not enough reward tokens to claim\");\r\n\t\t} else {\r\n\t\t\trewardToken.transfer(_to, _amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction supplyRewardTokens(uint256 _amount) public {\r\n\t\trewardToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n\t\temit Supply(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction supplyStakedTokens(uint256 _amount) public {\r\n\t\tstakedToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n\t\temit Supply(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction startProductionMode() external onlyOwner onlyStarted {\r\n\t\trequire(productionMode == false, \"startProductionMode: already stared\");\r\n\t\tproductionMode = true;\r\n\t\t_updatePool();\r\n\t\tpausedTimestamp = 0;\r\n\t}\r\n\r\n\tfunction setRewardToken(address newRewardToken) external onlyOwner {\r\n\t\trequire(pausedTimestamp != 0, \"GOMAsterChef setRewardToken: you can't change reward token when not paused\");\r\n\t\trewardToken = IBEP20(newRewardToken);\r\n\t}\r\n\r\n\tfunction withdrawStakedTokens(uint256 _amount) external onlyOwner {\r\n\t\trequire(productionMode == false, \"GOMAsterChef withdrawAllStakedTokens: not allowed in production mode\");\r\n\t\trequire(balanceOfStakedToken() >= _amount, \"GOMAsterChef withdrawAllStakedTokens: no enough funds\");\r\n\t\tstakedToken.safeTransfer(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction withdrawStakedRewards(uint256 _amount) external onlyOwner {\r\n\t\trequire(balanceOfStakedToken() > stakedTokenDeposied, \"GOMAsterChef withdrawStakedRewards: nothing to withdraw\");\r\n\t\tuint256 amount = balanceOfStakedToken() - stakedTokenDeposied;\r\n\t\trequire(_amount <= amount, \"GOMAsterChef withdrawStakedRewards: no enough funds\");\r\n\t\tstakedToken.safeTransfer(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction recoverTokens(address token, uint256 amount) external onlyOwner {\r\n\t\trequire(token != address(stakedToken), \"GOMAsterChef recoverTokens: can't recover staked token\");\r\n\t\trequire(token != address(rewardToken), \"GOMAsterChef recoverTokens: can't recover reward token\");\r\n\t\tIBEP20(token).safeTransfer(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction withdrawRewardTokens(uint256 _amount) external onlyOwner {\r\n\t\trequire(balanceOfRewardToken() >= _amount, \"GOMAsterChef withdrawRewardTokens: nothing to withdraw\");\r\n\t\tsafeRewardTransfer(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction balanceOfRewardToken() public view returns (uint256) {\r\n\t\treturn rewardToken.balanceOf(address(this));\r\n\t}\r\n\r\n\tfunction balanceOfStakedToken() public view returns (uint256) {\r\n\t\treturn stakedToken.balanceOf(address(this));\r\n\t}\r\n\r\n\tfunction blockTimestamp() public view returns (uint256) {\r\n\t\treturn block.timestamp;\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"OperatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accRewardTokensPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedRewardTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedTokenDeposied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pausedTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultiplierNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balanceStakeTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allowanceStakeTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balanceRewardTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndex\",\"type\":\"uint256\"}],\"name\":\"getUsersExport\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"internalType\":\"struct GOMAsterChef.UserExport[]\",\"name\":\"userExport\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"migrateUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorsList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRewardsOfSender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingRewardsOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"productionMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minDepositAmount\",\"type\":\"uint256\"}],\"name\":\"setMinDepositAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardToken\",\"type\":\"address\"}],\"name\":\"setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensPerSecond\",\"type\":\"uint256\"}],\"name\":\"setRewardTokensPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTokenDeposied\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startProductionMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"supplyRewardTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"supplyStakedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawRewardTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStakedRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStakedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GOMAsterChef", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1ac31bf2a43329df974fa98ac8dbd54d49ab50b4a4466110b65704819863c8b8"}