{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"AdoToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n// Web: https://www.ado.network\\n// Twitter: https://twitter.com/NetworkAdo\\n// Discord: https://discord.gg/n9FyS5Tr\\n// Telegram: https://t.me/ADOnetwork\\n// Reddit: https://www.reddit.com/r/ADO_Network/\\n\\nimport \\\"./DividendTracker.sol\\\";\\nimport \\\"./AdoVault.sol\\\";\\nimport \\\"./abstracts/Ownable.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IPancakeSwapV2Pair.sol\\\";\\nimport \\\"./interfaces/IPancakeSwapV2Factory.sol\\\";\\nimport \\\"./interfaces/IPancakeSwapV2Router02.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ncontract AdoToken is IERC20, Ownable {\\n\\tusing SafeMath for uint256;\\n\\n\\taddress private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\n\\tIPancakeSwapV2Router02 public pancakeSwapV2Router;\\n\\tIPancakeSwapV2Pair public pancakeSwapV2Pair;\\n\\tDividendTracker public dividendContract;\\n\\tAdoVault public vault;\\n\\taddress public busd;\\n\\n\\tstring private _name = \\\"ADO.Network\\\";\\n\\tstring private _symbol = \\\"ADO\\\";\\n\\tuint8 private _decimals = 18;\\n\\taddress public immutable deployer;\\n\\taddress public referrerLotteryWallet;\\n\\tbool private _swapEnabled = false;\\n\\tbool private _swapping = false;\\n\\tbool private _dividendContractSet = false;\\n\\tbool private _vaultContractSet = false;\\n\\tbool private _busdContractSet = false;\\n\\tuint256 private _totalSupply = 1000000000 * (10 ** _decimals);\\n\\tuint256 private _numTokensToLiqudate = _totalSupply.div(1000);\\n\\tuint256 private _minDividendBalanceToProcess;\\n\\tuint256 private _gasForProcessing = 200000;\\n\\tuint256 public cursor;\\n\\tuint256 public partners;\\n\\tuint256 private _lpWeight;\\n\\tuint256 private _excludedAccounts;\\n\\tuint256 private _bbperthousand = 0;\\n\\taddress private _bbrecipient = BURN_ADDRESS;\\n\\tuint256 public holdersLotteryFund;\\n\\tuint256 public referrersLotteryFund;\\n\\tuint256 public buyBackBalance;\\n\\tuint256 private _dividendFee = 2;\\n\\tuint256 private _buyBackFee = 6;\\n\\tuint256 private _lotteryFee = 2;\\n\\tuint256 private _totalFee = _dividendFee.add(_buyBackFee).add(_lotteryFee);\\n\\tmapping(address => uint256) private _balances;\\n\\tmapping(address => mapping(address => uint256)) private _allowances;\\n\\tmapping (address => bool) private _isExcludedFromFees;\\n\\tmapping (address => bool) private _partners;\\n\\n\\tevent ExcludeAddress(address indexed account, bool fromLottery, bool fromDividends);\\n\\tevent NewPartner(address indexed account);\\n\\tevent GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\tevent ReferrerLotteryWalletUpdate(address indexed account);\\n\\tevent LPWeightUpdate(uint256 lpWeight);\\n\\tevent FeeDistributionUpdate(uint256 buyBack, uint256 dividend, uint256 lottery);\\n\\tevent AutoBuyBackUpdate(uint256 bbperthousand, address recipient);\\n\\tevent MinimumDividendBalanceToProcess(uint256 indexed newValue, uint256 indexed oldValue);\\n\\tevent TokenBalanceToLiqudateUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\tevent ProcessedDividendTracker(uint256 iterations, uint256 claims, uint256 indexed lastProcessedIndex, bool indexed automatic, uint256 gas, address indexed processor);\\n\\n\\tmodifier onlyDeployer() {\\n\\t\\trequire(_msgSender() == deployer, \\\"Token: Only the token deployer can call this function\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tconstructor() {\\n\\t\\tdeployer = owner();\\n\\t\\treferrerLotteryWallet = owner();\\n\\t\\t_isExcludedFromFees[owner()] = true;\\n\\t\\t_isExcludedFromFees[address(this)] = true;\\n\\t\\t_isExcludedFromFees[BURN_ADDRESS] = true;\\n\\t\\t_excludedAccounts = 3;\\n\\t\\t_balances[msg.sender] = _totalSupply;\\n\\t\\temit Transfer(address(0), owner(), _totalSupply);\\n\\t}\\n\\n\\treceive() external payable {}\\n\\n\\tfunction name() external view override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\tfunction symbol() external view override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\tfunction decimals() external view override returns (uint8) {\\n\\t\\treturn _decimals;\\n\\t}\\n\\n\\tfunction totalFee() external view returns (uint256) {\\n\\t\\treturn _totalFee;\\n\\t}\\n\\n\\tfunction fees() external view returns (uint256 dividendFee, uint256 buyBackFee, uint256 lotteryFee, bool isActive) {\\n\\t\\tdividendFee = _dividendFee;\\n\\t\\tbuyBackFee = _buyBackFee;\\n\\t\\tlotteryFee = _lotteryFee;\\n\\t\\tisActive = _totalFee > 0;\\n\\t}\\n\\n\\tfunction totalSupply() external view override returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\tfunction balanceOf(address account) external view override returns (uint256) {\\n\\t\\treturn _balances[account];\\n\\t}\\n\\n\\tfunction transfer(address recipient, uint256 amount) external override returns (bool) {\\n\\t\\t_transfer(_msgSender(), recipient, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction allowance(address owner, address spender) external view override returns (uint256) {\\n\\t\\treturn _allowances[owner][spender];\\n\\t}\\n\\n\\tfunction approve(address spender, uint256 amount) external override returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n\\t\\t_transfer(sender, recipient, amount);\\n\\t\\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"Token: transfer amount exceeds allowance\\\"));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"Token: decreased allowance below zero\\\"));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction gasForProcessing() external view returns (uint256) {\\n\\t\\treturn _gasForProcessing;\\n\\t}\\n\\n\\tfunction claimWait() external view returns(uint256) {\\n\\t\\treturn dividendContract.claimWait();\\n\\t}\\n\\n\\tfunction lastMilestoneReached() external view returns (uint256) {\\n\\t\\treturn dividendContract.lastMilestoneReached();\\n\\t}\\n\\n\\tfunction nextMilestone() external view returns (uint256) {\\n\\t\\treturn dividendContract.nextMilestone();\\n\\t}\\n\\n\\tfunction maxMilestone() external view returns (uint256) {\\n\\t\\treturn dividendContract.maxMilestone();\\n\\t}\\n\\n\\tfunction totalDividendsDistributed() external view returns (uint256) {\\n\\t\\treturn dividendContract.totalDividendsDistributed();\\n\\t}\\n\\n\\tfunction isExcludedFromFees(address account) external view returns(bool) {\\n\\t\\treturn _isExcludedFromFees[account];\\n\\t}\\n\\n\\tfunction isExcludedFromLottery(address account) external view returns (bool) {\\n\\t\\treturn dividendContract.isExcludedFromLottery(account);\\n\\t}\\n\\n\\tfunction isExcludedFromDividends(address account) external view returns (bool) {\\n\\t\\treturn dividendContract.isExcludedFromDividends(account);\\n\\t}\\n\\n\\tfunction minimumTokenBalanceForLottery() external view returns (uint256) {\\n\\t\\treturn dividendContract.minimumTokenBalanceForLottery();\\n\\t}\\n\\n\\tfunction withdrawableDividendOf(address account) external view returns(uint256) {\\n\\t\\treturn dividendContract.withdrawableDividendOf(account);\\n\\t}\\n\\n\\tfunction dividendTokenBalanceOf(address account) external view returns (uint256) {\\n\\t\\treturn dividendContract.balanceOf(account);\\n\\t}\\n\\n\\tfunction accountDividendsInfo(address _account) external view returns (address account, int256 index, int256 iterationsUntilProcessed, uint256 withdrawableDividends, uint256 totalDividends, uint256 lastClaimTime, uint256 nextClaimTime, uint256 secondsUntilAutoClaimAvailable) {\\n\\t\\treturn dividendContract.getAccount(_account);\\n\\t}\\n\\n\\tfunction accumulativeDividendOf(address account) external view returns(uint256) {\\n\\t\\treturn dividendContract.accumulativeDividendOf(account);\\n\\t}\\n\\n\\tfunction accountDividendsInfoAtIndex(uint256 index) external view returns (address, int256, int256, uint256, uint256, uint256, uint256, uint256) {\\n\\t\\treturn dividendContract.getAccountAtIndex(index);\\n\\t}\\n\\n\\tfunction referrerInfo(address account) external view returns (uint256 transactions, uint256 bonus, uint256 totalValue, uint256 commissions, bool excludedFromLottery) {\\n\\t\\treturn dividendContract.getReferrer(account);\\n\\t}\\n\\n\\tfunction lastProcessedIndex() external view returns(uint256) {\\n\\t\\treturn dividendContract.getLastProcessedIndex();\\n\\t}\\n\\n\\tfunction dividendTokenHolders() external view returns(uint256) {\\n\\t\\treturn dividendContract.getNumberOfDividendsTokenHolders();\\n\\t}\\n\\n\\tfunction numTokensToLiqudate() external view returns(uint256) {\\n\\t\\treturn _numTokensToLiqudate;\\n\\t}\\n\\n\\tfunction minimumTokenBalanceForDividends() external view returns(uint256) {\\n\\t\\treturn dividendContract.minimumTokenBalanceForDividends();\\n\\t}\\n\\n\\tfunction taxSetup() external view returns(uint256, uint256, uint256) {\\n\\t\\tuint256 weight = 10;\\n\\t\\treturn (_lpWeight, weight.sub(_lpWeight), cursor);\\n\\t}\\n\\n\\tfunction buyBackSetup() external view returns(uint256, address) {\\n\\t\\treturn (_bbperthousand, _bbrecipient);\\n\\t}\\n\\n\\tfunction setLPWeight(uint256 lpWeight) external onlyDeployer {\\n\\t\\trequire(lpWeight <= 10, \\\"Token: LPWeight must be between 0 and 10\\\");\\n\\t\\t_lpWeight = lpWeight;\\n\\t\\temit LPWeightUpdate(_lpWeight);\\n\\t}\\n\\n\\tfunction setAutoBuyBack(uint256 newValue, address recipient) external onlyDeployer {\\n\\t\\trequire(newValue >= 0 && newValue <= 10, \\\"Token: AutoBuyBack must be between 0 and 10\\\");\\n\\t\\tif (recipient == address(dividendContract)) {\\n\\t\\t\\t_bbrecipient = address(dividendContract);\\n\\t\\t} else {\\n\\t\\t\\t_bbrecipient = BURN_ADDRESS;\\n\\t\\t}\\n\\t\\t_bbperthousand = newValue;\\n\\t\\temit AutoBuyBackUpdate(_bbperthousand, _bbrecipient);\\n\\t}\\n\\n\\tfunction excludeMeFromLottery() external {\\n\\t\\tdividendContract.excludeFromLottery(_msgSender());\\n\\t}\\n\\n\\tfunction claim() external {\\n\\t\\tdividendContract.claim(_msgSender());\\n\\t}\\n\\n\\tfunction setTokenFees(uint256 newBuyBackFee) external onlyDeployer {\\n\\t\\trequire(newBuyBackFee != _buyBackFee, \\\"Token: The BuyBack fee is already set to the requested value\\\");\\n\\t\\trequire(newBuyBackFee == 2 || newBuyBackFee == 4 || newBuyBackFee == 6, \\\"Token: The BuyBack fee can only be 2 4 or 6\\\");\\n\\t\\t_buyBackFee = newBuyBackFee;\\n\\t\\t_dividendFee = _totalFee.sub(_buyBackFee).sub(_lotteryFee);\\n\\t\\temit FeeDistributionUpdate(_buyBackFee, _dividendFee, _lotteryFee);\\n\\t}\\n\\n\\tfunction referrersLotteryDraw() external onlyDeployer {\\n\\t\\tdividendContract.referrersLotteryDraw();\\n\\t}\\n\\n\\tfunction holdersLotteryDraw() external onlyDeployer {\\n\\t\\tdividendContract.holdersLotteryDraw();\\n\\t}\\n\\n\\tfunction setMinimumDividendBalanceToProcess(uint256 newValue) external onlyDeployer {\\n\\t\\trequire(newValue <= 10 ** 18, \\\"Token: MinimumDividendBalanceToProcess must be between 0 and 1 BNB\\\");\\n\\t\\temit MinimumDividendBalanceToProcess(newValue, _minDividendBalanceToProcess);\\n\\t\\t_minDividendBalanceToProcess = newValue;\\n\\t}\\n\\n\\tfunction updateGasForProcessing(uint256 newValue) external onlyDeployer {\\n\\t\\trequire(newValue >= 100000 && newValue <= 500000, \\\"Token: gasForProcessing must be between 100,000 and 500,000\\\");\\n\\t\\temit GasForProcessingUpdated(newValue, _gasForProcessing);\\n\\t\\t_gasForProcessing = newValue;\\n\\t}\\n\\n\\tfunction updateClaimWait(uint256 newValue) external onlyDeployer {\\n\\t\\tdividendContract.updateClaimWait(newValue);\\n\\t}\\n\\n\\tfunction setMinimumTokenBalanceForDividends(uint256 newValue) external onlyDeployer {\\n\\t\\tdividendContract.updateMinimumTokenBalanceForDividends(newValue);\\n\\t}\\n\\n\\tfunction setNumTokensToLiqudate(uint256 newValue) external onlyDeployer {\\n\\t\\trequire(newValue >= 100000000000000000000 && newValue <= 1000000000000000000000000, \\\"Token: numTokensToLiqudate must be between 100 and 1.000.000\\\");\\n\\t\\temit TokenBalanceToLiqudateUpdated(newValue, _numTokensToLiqudate);\\n\\t\\t_numTokensToLiqudate = newValue;\\n\\t}\\n\\n\\tfunction buyBack(uint256 amount, address recipient) external onlyDeployer {\\n\\t\\trequire(amount <= buyBackBalance, \\\"Token: Insufficient funds.\\\");\\n\\t\\trequire(recipient == BURN_ADDRESS || recipient == address(dividendContract), \\\"Token: Invalid recipient.\\\");\\n\\t\\tswapETHForTokens(recipient, 0, amount);\\n\\t\\tbuyBackBalance = address(this).balance.sub(holdersLotteryFund).sub(referrersLotteryFund);\\n\\t}\\n\\n\\tfunction setMilestone(uint256 milestone) external onlyDeployer {\\n\\t\\trequire(milestone > dividendContract.maxMilestone(), \\\"Token: The new milestone cannot be smaller than the existing ones\\\");\\n\\t\\tdividendContract.setMilestone(milestone);\\n\\t}\\n\\n\\tfunction setReferrerWallet(address wallet) external onlyDeployer {\\n\\t\\trequire(wallet != address(0), \\\"Token: ReferrerLotteryWallet cannot be the zero address\\\");\\n\\t\\treferrerLotteryWallet = wallet;\\n\\t\\temit ReferrerLotteryWalletUpdate(wallet);\\n\\t}\\n\\n\\tfunction processDividendTracker() external onlyDeployer {\\n\\t\\tuint256 contractTokenBalance = _balances[address(this)];\\n\\t\\tbool canSwap = contractTokenBalance > _numTokensToLiqudate;\\n\\t\\tif (canSwap) {\\n\\t\\t\\t_swapping = true;\\n\\t\\t\\tswapAndSendDividends(_numTokensToLiqudate);\\n\\t\\t\\t_swapping = false;\\n\\t\\t}\\n\\t\\tif (address(dividendContract).balance > _minDividendBalanceToProcess) {\\n\\t\\t\\tuint256 gas = _gasForProcessing;\\n\\t\\t\\ttry dividendContract.process(gas) returns (uint256 iterations, uint256 claims, uint256 lpIndex) {\\n\\t\\t\\t\\temit ProcessedDividendTracker(iterations, claims, lpIndex, true, gas, tx.origin);\\n\\t\\t\\t}\\n\\t\\t\\tcatch {}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction updateMinTokensForLottery() external onlyDeployer {\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = address(busd);\\n\\t\\tpath[1] = pancakeSwapV2Router.WETH();\\n\\t\\tuint256 ethPrice = pancakeSwapV2Router.getAmountsOut(10**20, path)[1];\\n\\t\\tpath[0] = pancakeSwapV2Router.WETH();\\n\\t\\tpath[1] = address(this);\\n\\t\\tuint256 amount = pancakeSwapV2Router.getAmountsOut(ethPrice, path)[1];\\n\\t\\tdividendContract.updateMinTokensForLottery(amount);\\n\\t}\\n\\n\\tfunction unlockVaultSlice(address to) external onlyDeployer {\\n\\t\\tvault.unlockSlice(to);\\n\\t}\\n\\n\\tfunction addPartner(address account) external onlyDeployer {\\n\\t\\trequire(_partners[account] == false, \\\"Token: Account is a partner\\\");\\n\\t\\t_partners[account] = true;\\n\\t\\tpartners++;\\n\\t\\tdividendContract.excludeFromLottery(account);\\n\\t\\temit NewPartner(account);\\n\\t}\\n\\n\\tfunction excludeAddress(address account, bool fromLottery, bool fromDividends) external onlyDeployer {\\n\\t\\trequire(_isExcludedFromFees[account] == false, \\\"Token: Account is already excluded\\\");\\n\\t\\trequire(_excludedAccounts <= 15, \\\"Token: The maximum limit of excluded accounts has been reached\\\");\\n\\t\\t_isExcludedFromFees[account] = true;\\n\\t\\t_excludedAccounts++;\\n\\t\\tif (fromLottery) {\\n\\t\\t\\tdividendContract.excludeFromLottery(account);\\n\\t\\t}\\n\\t\\tif (fromDividends) {\\n\\t\\t\\tdividendContract.excludeFromDividends(account);\\n\\t\\t}\\n\\t\\temit ExcludeAddress(account, fromLottery, fromDividends);\\n\\t}\\n\\n\\tfunction removeTax() external onlyDeployer {\\n\\t\\trequire(dividendContract.maxMilestone() == 0, \\\"Token: milestone in progress\\\");\\n\\t\\t_totalFee = 0;\\n\\t\\tuint256 toBurn = _balances[address(this)];\\n\\t\\t_transfer(address(this), BURN_ADDRESS, toBurn);\\n\\t\\tbuyBackBalance = address(this).balance;\\n\\t\\tholdersLotteryFund = 0;\\n\\t\\treferrersLotteryFund = 0;\\n\\t\\tdividendContract.burnTheHouseDown();\\n\\t}\\n\\n\\tfunction _approve(address owner, address spender, uint256 amount) private {\\n\\t\\trequire(owner != address(0), \\\"Token: approve from the zero address\\\");\\n\\t\\trequire(spender != address(0), \\\"Token: approve to the zero address\\\");\\n\\t\\t_allowances[owner][spender] = amount;\\n\\t\\temit Approval(owner, spender, amount);\\n\\t}\\n\\n\\tfunction swapETHForTokens(address recipient, uint256 minTokenAmount, uint256 amount) private {\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = pancakeSwapV2Router.WETH();\\n\\t\\tpath[1] = address(this);\\n\\t\\tpancakeSwapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\\n\\t\\t\\tminTokenAmount,\\n\\t\\t\\tpath,\\n\\t\\t\\trecipient,\\n\\t\\t\\tblock.timestamp\\n\\t\\t);\\n\\t}\\n\\n\\tfunction swapTokensForEth(uint256 tokenAmount) private {\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = address(this);\\n\\t\\tpath[1] = pancakeSwapV2Router.WETH();\\n\\t\\t_approve(address(this), address(pancakeSwapV2Router), tokenAmount);\\n\\t\\tpancakeSwapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\t\\ttokenAmount,\\n\\t\\t\\t0,\\n\\t\\t\\tpath,\\n\\t\\t\\taddress(this),\\n\\t\\t\\tblock.timestamp\\n\\t\\t);\\n\\t}\\n\\n\\tfunction addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(pancakeSwapV2Router), tokenAmount);\\n        pancakeSwapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0,\\n            0,\\n            address(0),\\n            block.timestamp\\n        );\\n    }\\n\\n\\tfunction swapAndSendDividends(uint256 amount) private {\\n\\t\\tuint256 initialBalance = address(this).balance;\\n\\t\\tcursor++;\\n\\t\\tbool addLP = cursor.mod(10) < _lpWeight;\\n\\t\\tuint256 swapTokensAmount = amount;\\n\\t\\tif (addLP) {\\n\\t\\t\\tuint256 lpf = _buyBackFee.div(2);\\n\\t\\t\\tlpf = lpf.add(_lotteryFee).add(_dividendFee);\\n\\t\\t\\tswapTokensAmount = amount.div(_totalFee).mul(lpf);\\n\\t\\t}\\n\\t\\tswapTokensForEth(swapTokensAmount);\\n\\t\\tuint256 eth = address(this).balance.sub(initialBalance);\\n\\t\\tuint256 lotteriesEth = eth.div(_totalFee).mul(_lotteryFee);\\n\\t\\tholdersLotteryFund = holdersLotteryFund.add(lotteriesEth.div(2));\\n\\t\\treferrersLotteryFund = referrersLotteryFund.add(lotteriesEth.div(2));\\n\\t\\tuint256 dividendEth = eth.div(_totalFee).mul(_dividendFee);\\n\\t\\t(bool dividendContractTransfer,) = payable(address(dividendContract)).call{value: dividendEth, gas: 3000}('');\\n\\t\\trequire(dividendContractTransfer, \\\"Token: Transfer to Dividend Contract faild\\\");\\n\\t\\tdividendContract.updateDividendsDistributed(dividendEth);\\n\\t\\tif (addLP) {\\n\\t\\t\\tuint256  lpeth = eth.sub(lotteriesEth).sub(dividendEth);\\n\\t\\t\\taddLiquidity(amount.sub(swapTokensAmount), lpeth);\\n\\t\\t}\\n\\t\\tbuyBackBalance = address(this).balance.sub(holdersLotteryFund).sub(referrersLotteryFund);\\n\\t}\\n\\n\\tfunction _transfer(address from, address to, uint256 amount) private {\\n\\t\\trequire(from != address(0), \\\"Token: Transfer from the zero address\\\");\\n\\t\\trequire(to != address(0), \\\"Token: Transfer to the zero address\\\");\\n\\t\\trequire(amount > 0, \\\"Token: Transfer amount must be greater than zero\\\");\\n\\t\\trequire(_swapEnabled || from == deployer, \\\"Token: Public transfer has not yet been activated\\\");\\n\\t\\trequire(_dividendContractSet, \\\"Token: Dividend Contract Token is not set\\\");\\n\\n\\t\\tbool takeFee = true;\\n        if (\\n\\t\\t\\t_isExcludedFromFees[from] ||\\n\\t\\t\\t_isExcludedFromFees[to] ||\\n\\t\\t\\t_totalFee == 0 ||\\n\\t\\t\\t(_partners[from] && to != address(pancakeSwapV2Pair)) ||\\n\\t\\t\\t(_partners[to] && from != address(pancakeSwapV2Pair))\\n\\t\\t) {\\n            takeFee = false;\\n        }\\n\\n\\t\\tif (\\n\\t\\t\\t!_swapping &&\\n\\t\\t\\ttakeFee\\n\\t\\t) {\\n\\t\\t\\tuint256 contractTokenBalance = _balances[address(this)];\\n\\t\\t\\tbool canSwap = contractTokenBalance > _numTokensToLiqudate;\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!canSwap &&\\n\\t\\t\\t\\tto == address(pancakeSwapV2Pair) &&\\n\\t\\t\\t\\tbuyBackBalance > 10**10 &&\\n\\t\\t\\t\\t_bbperthousand > 0\\n\\t\\t\\t) {\\n\\t\\t\\t\\t_swapping = true;\\n\\t\\t\\t\\tswapETHForTokens(_bbrecipient, 0, buyBackBalance.div(1000).mul(_bbperthousand));\\n\\t\\t\\t\\t_swapping = false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\tcanSwap &&\\n\\t\\t\\t\\t\\tfrom != address(pancakeSwapV2Pair)\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t_swapping = true;\\n\\t\\t\\t\\t\\tswapAndSendDividends(_numTokensToLiqudate);\\n\\t\\t\\t\\t\\t_swapping = false;\\n            \\t}\\n\\t\\t\\t}\\n        }\\n\\n        if (takeFee) {\\n        \\tuint256 txFee = amount.div(100).mul(_totalFee);\\n\\t\\t\\tamount = amount.sub(txFee);\\n\\t\\t\\t_balances[from] = _balances[from].sub(txFee, \\\"Token: Transfer amount exceeds balance\\\");\\n\\t\\t\\t_balances[address(this)] = _balances[address(this)].add(txFee);\\n\\t\\t\\temit Transfer(from, address(this), txFee);\\n        }\\n\\n\\t\\t_balances[from] = _balances[from].sub(amount, \\\"Token: Transfer amount exceeds balance\\\");\\n\\t\\t_balances[to] = _balances[to].add(amount);\\n\\t\\temit Transfer(from, to, amount);\\n\\n\\t\\tif (_totalFee > 0) {\\n\\t\\t\\tdividendContract.setBalance(payable(from), _balances[from]);\\n\\t\\t\\tdividendContract.setBalance(payable(to), _balances[to]);\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!_swapping &&\\n\\t\\t\\t\\t(from != address(dividendContract)) &&\\n\\t\\t\\t\\taddress(dividendContract).balance > _minDividendBalanceToProcess\\n\\t\\t\\t) {\\n\\t\\t\\t\\tuint256 gas = _gasForProcessing;\\n\\t\\t\\t\\ttry dividendContract.process(gas) returns (uint256 iterations, uint256 claims, uint256 lpIndex) {\\n\\t\\t\\t\\t\\temit ProcessedDividendTracker(iterations, claims, lpIndex, true, gas, tx.origin);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch {}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction setDividendTrackerContract(address _dividendTracker) external onlyOwner {\\n\\t\\tdividendContract = DividendTracker(payable(_dividendTracker));\\n\\t\\t_dividendContractSet = true;\\n\\t\\t_isExcludedFromFees[address(dividendContract)] = true;\\n\\t\\t_excludedAccounts++;\\n\\t\\t_transfer(_msgSender(), _dividendTracker, _totalSupply.div(100).mul(20));\\n\\t}\\n\\n\\tfunction setVaultContract(address _vault) external onlyOwner {\\n\\t\\trequire(_dividendContractSet, \\\"Token: DividendContract contract is not set\\\");\\n\\t\\tvault = AdoVault(_vault);\\n\\t\\t_vaultContractSet = true;\\n\\t\\t_isExcludedFromFees[_vault] = true;\\n\\t\\t_excludedAccounts++;\\n\\t\\tdividendContract.excludeFromDividends(_vault);\\n\\t\\t_transfer(_msgSender(), _vault, _totalSupply.div(100).mul(20));\\n\\t}\\n\\n\\tfunction setBUSDContract(address _busd) external onlyOwner {\\n\\t\\trequire(!_busdContractSet, \\\"Token: BUSD Token is already set\\\");\\n\\t\\tbusd = _busd;\\n\\t\\t_busdContractSet = true;\\n\\t}\\n\\n\\tfunction createPancakeSwapPair(address PancakeSwapRouter) external onlyOwner {\\n\\t\\trequire(_dividendContractSet, \\\"Token: Dividend Contract contract is not set\\\");\\n\\t\\trequire(_vaultContractSet, \\\"Token: Vault contract is not set\\\");\\n\\t\\trequire(_busdContractSet, \\\"Token: BUSD Token Contract contract is not set\\\");\\n\\t\\tpancakeSwapV2Router = IPancakeSwapV2Router02(PancakeSwapRouter);\\n\\t\\tpancakeSwapV2Pair = IPancakeSwapV2Pair(IPancakeSwapV2Factory(pancakeSwapV2Router\\n\\t\\t\\t.factory())\\n\\t\\t\\t.createPair(address(this), pancakeSwapV2Router.WETH()));\\n\\t\\tdividendContract.excludeFromDividends(address(pancakeSwapV2Pair));\\n\\t\\tdividendContract.excludeFromDividends(address(pancakeSwapV2Router));\\n\\t}\\n\\n\\tfunction enableSwap() external onlyOwner {\\n\\t\\trequire(!_swapEnabled, \\\"Token: PublicSwap is already enabeled\\\");\\n\\t\\t_swapEnabled = true;\\n\\t}\\n\\n\\tfunction swapETHForExactTokens(uint256 amountOut, address referrer) external payable {\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = pancakeSwapV2Router.WETH();\\n\\t\\tpath[1] = address(this);\\n\\t\\tpancakeSwapV2Router.swapETHForExactTokens {value: msg.value}(amountOut, path, _msgSender(), block.timestamp);\\n\\t\\tuint256 ethBack = address(this).balance\\n\\t\\t\\t.sub(holdersLotteryFund)\\n\\t\\t\\t.sub(referrersLotteryFund)\\n\\t\\t\\t.sub(buyBackBalance);\\n\\t\\t(bool refund,) = _msgSender().call{value: ethBack, gas: 3000}('');\\n\\t\\trequire(refund, \\\"Token: Refund Failed\\\");\\n\\t\\tif (referrer != address(0) && _totalFee > 0) {\\n\\t\\t\\tuint256 txFee = amountOut.div(100).mul(_totalFee);\\n\\t\\t\\tuint256 amount = amountOut.sub(txFee);\\n\\t\\t\\tdividendContract.payCommission(referrer, amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction swapExactETHForTokens(uint256 amountOutMin, address referrer) external payable {\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = pancakeSwapV2Router.WETH();\\n\\t\\tpath[1] = address(this);\\n\\t\\tuint256 initialBalance = _balances[_msgSender()];\\n\\t\\tpancakeSwapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(amountOutMin, path, _msgSender(), block.timestamp);\\n\\t\\tuint256 amountOut = _balances[_msgSender()].sub(initialBalance);\\n\\t\\tif (referrer != address(0) && _totalFee > 0) {\\n\\t\\t\\tdividendContract.payCommission(referrer, amountOut);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction payTheWinner(address winner) external returns (bool) {\\n\\t\\trequire(_msgSender() == address(dividendContract), \\\"Token: Only the Dividend contract can call this function\\\");\\n\\t\\t(bool success,) = payable(winner).call{value: holdersLotteryFund, gas: 3000}('');\\n\\t\\trequire(success, \\\"Token: Transfer to lottery winner faild\\\");\\n\\t\\tholdersLotteryFund = 0;\\n\\t\\treturn success;\\n\\t}\\n\\n\\tfunction referrersLotteryFundWithdrawal() external returns (bool) {\\n\\t\\trequire(_msgSender() == address(dividendContract), \\\"Token: Only the Dividend contract can call this function\\\");\\n\\t\\t(bool success,) = payable(referrerLotteryWallet).call{value: referrersLotteryFund, gas: 3000}('');\\n\\t\\trequire(success, \\\"Token: Transfer to Referrer Lottery Wallet faild\\\");\\n\\t\\treferrersLotteryFund = 0;\\n\\t\\treturn success;\\n\\t}\\n}\"\r\n    },\r\n    \"libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * CAUTION\\n * This version of SafeMath should only be used with Solidity 0.8 or later,\\n * because it relies on the compiler's built in overflow checks.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 c = a + b;\\n\\t\\t\\tif (c < a) return (false, 0);\\n\\t\\t\\treturn (true, c);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\tif (b > a) return (false, 0);\\n\\t\\t\\treturn (true, a - b);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n\\t\\t\\t// benefit is lost if 'b' is also tested.\\n\\t\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\t\\tif (a == 0) return (true, 0);\\n\\t\\t\\tuint256 c = a * b;\\n\\t\\t\\tif (c / a != b) return (false, 0);\\n\\t\\t\\treturn (true, c);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\tif (b == 0) return (false, 0);\\n\\t\\t\\treturn (true, a / b);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\tif (b == 0) return (false, 0);\\n\\t\\t\\treturn (true, a % b);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a + b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a * b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers, reverting on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * reverting when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a % b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {trySub}.\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(b <= a, errorMessage);\\n\\t\\t\\treturn a - b;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(b > 0, errorMessage);\\n\\t\\t\\treturn a / b;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * reverting with custom message when dividing by zero.\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {tryMod}.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(b > 0, errorMessage);\\n\\t\\t\\treturn a % b;\\n\\t\\t}\\n\\t}\\n}\"\r\n    },\r\n    \"interfaces/IPancakeSwapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\nimport \\\"./IPancakeSwapV2Router01.sol\\\";\\ninterface IPancakeSwapV2Router02 is IPancakeSwapV2Router01 {\\n\\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\\n\\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\\n\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\n\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\\n\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\n}\"\r\n    },\r\n    \"interfaces/IPancakeSwapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\ninterface IPancakeSwapV2Factory {\\n\\tfunction feeTo() external view returns (address);\\n\\tfunction feeToSetter() external view returns (address);\\n\\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\tfunction allPairs(uint) external view returns (address pair);\\n\\tfunction allPairsLength() external view returns (uint);\\n\\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\\n\\tfunction setFeeTo(address) external;\\n\\tfunction setFeeToSetter(address) external;\\n\\n\\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n}\"\r\n    },\r\n    \"interfaces/IPancakeSwapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\ninterface IPancakeSwapV2Pair {\\n\\tfunction name() external pure returns (string memory);\\n\\tfunction symbol() external pure returns (string memory);\\n\\tfunction decimals() external pure returns (uint8);\\n\\tfunction totalSupply() external view returns (uint);\\n\\tfunction balanceOf(address owner) external view returns (uint);\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\n\\tfunction approve(address spender, uint value) external returns (bool);\\n\\tfunction transfer(address to, uint value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\tfunction nonces(address owner) external view returns (uint);\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\tfunction factory() external view returns (address);\\n\\tfunction token0() external view returns (address);\\n\\tfunction token1() external view returns (address);\\n\\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\tfunction price0CumulativeLast() external view returns (uint);\\n\\tfunction price1CumulativeLast() external view returns (uint);\\n\\tfunction kLast() external view returns (uint);\\n\\tfunction mint(address to) external returns (uint liquidity);\\n\\tfunction burn(address to) external returns (uint amount0, uint amount1);\\n\\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n\\tfunction skim(address to) external;\\n\\tfunction sync() external;\\n\\tfunction initialize(address, address) external;\\n\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\n\\tevent Mint(address indexed sender, uint amount0, uint amount1);\\n\\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n\\tevent Swap(address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to);\\n\\tevent Sync(uint112 reserve0, uint112 reserve1);\\n}\"\r\n    },\r\n    \"interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\ninterface IERC20 {\\n\\tfunction name() external view returns (string memory);\\n\\tfunction symbol() external view returns (string memory);\\n\\tfunction decimals() external view returns (uint8);\\n\\tfunction totalSupply() external view returns (uint256);\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"abstracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT License\\npragma solidity 0.8.4;\\nimport \\\"./Context.sol\\\";\\nabstract contract Ownable is Context {\\n\\taddress private _owner;\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\t/**\\n\\t * @dev Initializes the contract setting the deployer as the initial owner.\\n\\t */\\n\\tconstructor () {\\n\\t\\taddress msgSender = _msgSender();\\n\\t\\t_owner = msgSender;\\n\\t\\temit OwnershipTransferred(address(0), msgSender);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the address of the current owner.\\n\\t */\\n\\tfunction owner() public view returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Throws if called by any account other than the owner.\\n\\t */\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Leaves the contract without owner. It will not be possible to call\\n\\t * `onlyOwner` functions anymore. Can only be called by the current owner.\\n\\t *\\n\\t * NOTE: Renouncing ownership will leave the contract without an owner,\\n\\t * thereby removing any functionality that is only available to the owner.\\n\\t */\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\n\\t\\temit OwnershipTransferred(_owner, address(0));\\n\\t\\t_owner = address(0);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t * Can only be called by the current owner.\\n\\t */\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n\\t\\temit OwnershipTransferred(_owner, newOwner);\\n\\t\\t_owner = newOwner;\\n\\t}\\n}\"\r\n    },\r\n    \"AdoVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\nimport \\\"./abstracts/Context.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./AdoToken.sol\\\";\\nimport \\\"./DividendTracker.sol\\\";\\n\\ncontract AdoVault is Context {\\n\\tusing SafeMath for uint256;\\n\\tAdoToken public tokenContract;\\n\\tDividendTracker public dividendContract;\\n\\tuint256 public immutable slice;\\n\\tuint256 public pendingMilestone;\\n\\n\\tevent VaultWithdraw(address indexed to, uint256 indexed slice, uint256 indexed milestone);\\n\\n\\tmodifier onlyTokenContract() {\\n\\t\\trequire(_msgSender() == address(tokenContract), \\\"Vault: Only the token contract can call this function\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tconstructor(AdoToken _tokenContract, DividendTracker _dividendContract) {\\n\\t\\ttokenContract = _tokenContract;\\n\\t\\tdividendContract = _dividendContract;\\n\\t\\tslice = tokenContract.totalSupply().div(20);\\n\\t\\tpendingMilestone = dividendContract.MILESTONE4();\\n\\t}\\n\\n\\tfunction unlockSlice(address to) external onlyTokenContract {\\n\\t\\trequire(to != address(0), \\\"Vault: transfer to the zero address\\\");\\n\\t\\trequire(tokenContract.balanceOf(address(this)) >= slice, \\\"Vault: insufficient funds\\\");\\n\\t\\trequire(dividendContract.lastMilestoneReached() >= pendingMilestone, \\\"Vault: no eligible milestone has been reached\\\");\\n\\n\\t\\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE4() && pendingMilestone == dividendContract.MILESTONE4()) {\\n\\t\\t\\ttokenContract.transfer(to, slice);\\n\\t\\t\\tpendingMilestone = dividendContract.MILESTONE5();\\n\\t\\t\\temit VaultWithdraw(to, slice, dividendContract.MILESTONE4());\\n\\t\\t}\\n\\n\\t\\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE5() && pendingMilestone == dividendContract.MILESTONE5()) {\\n\\t\\t\\ttokenContract.transfer(to, slice);\\n\\t\\t\\tpendingMilestone = dividendContract.MILESTONE6();\\n\\t\\t\\temit VaultWithdraw(to, slice, dividendContract.MILESTONE5());\\n\\t\\t}\\n\\n\\t\\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE6() && pendingMilestone == dividendContract.MILESTONE6()) {\\n\\t\\t\\ttokenContract.transfer(to, slice);\\n\\t\\t\\tpendingMilestone = dividendContract.MILESTONE7();\\n\\t\\t\\temit VaultWithdraw(to, slice, dividendContract.MILESTONE6());\\n\\t\\t}\\n\\n\\t\\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE7() && pendingMilestone == dividendContract.MILESTONE7()) {\\n\\t\\t\\ttokenContract.transfer(to, tokenContract.balanceOf(address(this)));\\n\\t\\t\\tpendingMilestone = 0;\\n\\t\\t\\temit VaultWithdraw(to, slice, dividendContract.MILESTONE7());\\n\\t\\t}\\n\\t}\\n}\"\r\n    },\r\n    \"DividendTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\nimport \\\"./abstracts/Context.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/SafeMathUint.sol\\\";\\nimport \\\"./libraries/SafeMathInt.sol\\\";\\nimport \\\"./AdoToken.sol\\\";\\n\\ncontract DividendTracker is Context {\\n\\tusing SafeMath for uint256;\\n\\tusing SafeMathUint for uint256;\\n\\tusing SafeMathInt for int256;\\n\\n\\taddress private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\n\\tuint256 private constant MAGNITUDE = 2**128;\\n\\tuint256 public constant MILESTONE1 = 5000;\\n\\tuint256 public constant MILESTONE2 = 10000;\\n\\tuint256 public constant MILESTONE3 = 25000;\\n\\tuint256 public constant MILESTONE4 = 50000;\\n\\tuint256 public constant MILESTONE5 = 75000;\\n\\tuint256 public constant MILESTONE6 = 100000;\\n\\tuint256 public constant MILESTONE7 = 150000;\\n\\tstruct MilestoneDetails { bool active; uint8 burn; }\\n\\tstruct ReferrerDetails { uint256 transactions; uint256 bonus; uint256 totalValue; uint256 commissions; }\\n\\tstruct DividendsHolders {\\n\\t\\taddress[] keys;\\n\\t\\tmapping(address => uint) values;\\n\\t\\tmapping(address => uint) indexOf;\\n\\t\\tmapping(address => bool) active;\\n\\t}\\n\\tDividendsHolders private _tokenHoldersMap;\\n\\taddress[] private _referredSwaps;\\n\\tuint256 private _totalSupply;\\n\\tuint256 private _totalDividendsDistributed;\\n\\tuint256 private _magnifiedDividendPerShare;\\n\\tuint256 private _minimumTokenBalanceForDividends;\\n\\tuint256 private _minimumTokenBalanceForLottery;\\n\\tuint256 private _lastProcessedIndex;\\n\\tuint256 private _claimWait = 600;\\n\\tuint256 private _lastMilestoneReached;\\n\\tuint256 private _unqualified;\\n\\taddress private _hlWinner;\\n\\taddress private _rlWinner;\\n\\tmapping(address => int256) private _magnifiedDividendCorrections;\\n\\tmapping(address => uint256) private _withdrawnDividends;\\n\\tmapping(address => uint256) private _balances;\\n\\tmapping(address => bool) private _excludedFromDividends;\\n\\tmapping(address => bool) private _excludedFromLottery;\\n\\tmapping(address => uint256) private _lastClaimTimes;\\n\\tmapping(address => ReferrerDetails) private _referrers;\\n\\tmapping(uint256 => MilestoneDetails) private _milestones;\\n\\tuint256[] private _milestonesList;\\n\\tmapping(uint256 => uint256) private _bonusStructure;\\n\\tAdoToken public tokenContract;\\n\\n\\tevent NewMilestone(uint256 indexed milestone);\\n\\tevent ExcludeFromDividends(address indexed account);\\n\\tevent ExcludeFromLottery(address indexed account);\\n\\tevent ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\tevent Claim(address indexed account, uint256 amount, bool indexed automatic);\\n\\tevent MinimumTokenBalanceForDividendsUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\tevent MinimumTokenBalanceForLotteryUpdated(uint256 indexed newValue);\\n\\tevent HoldersLotteryWinner(address indexed account, uint256 indexed milestone, uint256 amount, uint256 burn);\\n\\tevent ReferrersLotteryWinner(address indexed account);\\n\\tevent DividendsDistributed(address indexed from, uint256 weiAmount);\\n\\tevent NoMoreDividends(uint256 totalDividendsDistributed);\\n\\n\\tmodifier onlyTokenContract() {\\n\\t\\trequire(_msgSender() == address(tokenContract), \\\"DividendTracker: Only the token contract can call this function\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tconstructor(AdoToken _tokenContract) {\\n\\t\\ttokenContract = _tokenContract;\\n\\t\\t_minimumTokenBalanceForDividends = tokenContract.totalSupply().div(10000);\\n\\t\\t_excludedFromDividends[address(this)] = true;\\n\\t\\t_excludedFromDividends[address(tokenContract)] = true;\\n\\t\\t_excludedFromDividends[BURN_ADDRESS] = true;\\n\\t\\t_excludedFromDividends[_msgSender()] = true;\\n\\t\\t_milestones[MILESTONE1] = MilestoneDetails({ active : true, burn: 5 });\\n\\t\\t_milestones[MILESTONE2] = MilestoneDetails({ active : true, burn: 10 });\\n\\t\\t_milestones[MILESTONE3] = MilestoneDetails({ active : true, burn: 15 });\\n\\t\\t_milestones[MILESTONE4] = MilestoneDetails({ active : true, burn: 20 });\\n\\t\\t_milestones[MILESTONE5] = MilestoneDetails({ active : true, burn: 25 });\\n\\t\\t_milestones[MILESTONE6] = MilestoneDetails({ active : true, burn: 30 });\\n\\t\\t_milestones[MILESTONE7] = MilestoneDetails({ active : true, burn: 35 });\\n\\t\\t_milestonesList = [MILESTONE1, MILESTONE2, MILESTONE3, MILESTONE4, MILESTONE5, MILESTONE6, MILESTONE7];\\n\\t\\t_bonusStructure[5] = 1;\\n\\t\\t_bonusStructure[20] = 2;\\n\\t\\t_bonusStructure[50] = 4;\\n\\t\\t_bonusStructure[100] = 6;\\n\\t\\t_bonusStructure[250] = 9;\\n\\t}\\n\\n\\treceive() external payable {}\\n\\n\\tfunction totalSupply() external view returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\tfunction balanceOf(address account) external view returns (uint256) {\\n\\t\\treturn _balances[account];\\n\\t}\\n\\n\\tfunction lastMilestoneReached() external view returns (uint256) {\\n\\t\\treturn _lastMilestoneReached;\\n\\t}\\n\\n\\tfunction holdersLotteryWinner() external view returns (address) {\\n\\t\\treturn _hlWinner;\\n\\t}\\n\\n\\tfunction referrersLotteryWinner() external view returns (address) {\\n\\t\\treturn _rlWinner;\\n\\t}\\n\\n\\tfunction nextMilestone() external view returns (uint256) {\\n\\t\\treturn _milestonesList.length > 0 ? _milestonesList[0] : 0;\\n\\t}\\n\\n\\tfunction maxMilestone() external view returns (uint256) {\\n\\t\\treturn _milestonesList.length > 0 ? _milestonesList[_milestonesList.length-1] : 0;\\n\\t}\\n\\n\\tfunction referredSwaps() external view returns (uint256 total, uint256 lotterySwaps) {\\n\\t\\ttotal = _unqualified.add(_referredSwaps.length);\\n\\t\\tlotterySwaps = _referredSwaps.length;\\n\\t}\\n\\n\\tfunction isExcludedFromLottery(address account) external view returns (bool) {\\n\\t\\treturn _excludedFromLottery[account];\\n\\t}\\n\\n\\tfunction isExcludedFromDividends(address account) external view returns (bool) {\\n\\t\\treturn _excludedFromDividends[account];\\n\\t}\\n\\n\\tfunction totalDividendsDistributed() external view returns (uint256) {\\n\\t\\treturn _totalDividendsDistributed;\\n\\t}\\n\\n\\tfunction withdrawableDividendOf(address account) public view returns(uint256) {\\n\\t\\treturn accumulativeDividendOf(account).sub(_withdrawnDividends[account]);\\n\\t}\\n\\n\\tfunction minimumTokenBalanceForDividends() external view returns(uint256) {\\n\\t\\treturn _minimumTokenBalanceForDividends;\\n\\t}\\n\\n\\tfunction minimumTokenBalanceForLottery() external view returns(uint256) {\\n\\t\\treturn _minimumTokenBalanceForLottery;\\n\\t}\\n\\n\\tfunction claimWait() external view returns(uint256) {\\n\\t\\treturn _claimWait;\\n\\t}\\n\\n\\tfunction getLastProcessedIndex() external view returns(uint256) {\\n\\t\\treturn _lastProcessedIndex;\\n\\t}\\n\\n\\tfunction getNumberOfDividendsTokenHolders() external view returns(uint256) {\\n\\t\\treturn _tokenHoldersMap.keys.length;\\n\\t}\\n\\n\\tfunction accumulativeDividendOf(address _owner) public view returns(uint256) {\\n\\t\\treturn _magnifiedDividendPerShare.mul(_balances[_owner])\\n\\t\\t\\t.toInt256Safe()\\n\\t\\t\\t.add(_magnifiedDividendCorrections[_owner])\\n\\t\\t\\t.toUint256Safe() / MAGNITUDE;\\n\\t}\\n\\n\\tfunction getReferrer(address account) external view returns (uint256 transactions, uint256 bonus, uint256 totalValue, uint256 commissions, bool excludedFromLottery) {\\n\\t\\ttransactions = _referrers[account].transactions;\\n\\t\\tbonus = _referrers[account].bonus;\\n\\t\\ttotalValue = _referrers[account].totalValue;\\n\\t\\tcommissions = _referrers[account].commissions;\\n\\t\\texcludedFromLottery = _excludedFromLottery[account];\\n\\t}\\n\\n\\tfunction getAccount(address _account) public view returns (address account, int256 index, int256 iterationsUntilProcessed, uint256 withdrawableDividends, uint256 totalDividends, uint256 lastClaimTime, uint256 nextClaimTime, uint256 secondsUntilAutoClaimAvailable) {\\n\\t\\taccount = _account;\\n\\t\\tindex = _getIndexOfKey(account);\\n\\t\\titerationsUntilProcessed = -1;\\n\\n\\t\\tif (index >= 0) {\\n\\t\\t\\tif (uint256(index) > _lastProcessedIndex) {\\n\\t\\t\\t\\titerationsUntilProcessed = index.sub(int256(_lastProcessedIndex));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tuint256 processesUntilEndOfArray = _tokenHoldersMap.keys.length > _lastProcessedIndex ? _tokenHoldersMap.keys.length.sub(_lastProcessedIndex) : 0;\\n\\t\\t\\t\\titerationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twithdrawableDividends = withdrawableDividendOf(account);\\n\\t\\ttotalDividends = accumulativeDividendOf(account);\\n\\t\\tlastClaimTime = _lastClaimTimes[account];\\n\\t\\tnextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(_claimWait) : 0;\\n\\t\\tsecondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ? nextClaimTime.sub(block.timestamp) : 0;\\n\\t}\\n\\n\\tfunction getAccountAtIndex(uint256 index) external view returns (address, int256, int256, uint256, uint256, uint256, uint256, uint256) {\\n\\t\\tif (index >= _tokenHoldersMap.keys.length) {\\n\\t\\t\\treturn (address(0), -1, -1, 0, 0, 0, 0, 0);\\n\\t\\t}\\n\\t\\taddress account = _getKeyAtIndex(index);\\n\\t\\treturn getAccount(account);\\n\\t}\\n\\n\\tfunction _removeMilestoneFromList() private {\\n        if (_milestonesList.length > 1) {\\n\\t\\t\\tfor (uint i = 0; i < _milestonesList.length-1; i++) {\\n            \\t_milestonesList[i] = _milestonesList[i+1];\\n        \\t}\\n\\t\\t}\\n\\t\\t_milestonesList.pop();\\n    }\\n\\n\\tfunction _withdrawDividendOfUser(address payable user) private returns (uint256) {\\n\\t\\tuint256 _withdrawableDividend = withdrawableDividendOf(user);\\n\\t\\tif (_withdrawableDividend > 0) {\\n\\t\\t\\t_withdrawnDividends[user] = _withdrawnDividends[user].add(_withdrawableDividend);\\n\\t\\t\\t(bool success,) = user.call{value: _withdrawableDividend, gas: 3000}('');\\n\\t\\t\\tif (!success) {\\n\\t\\t\\t\\t_withdrawnDividends[user] = _withdrawnDividends[user].sub(_withdrawableDividend);\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn _withdrawableDividend;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfunction _setBalance(address account, uint256 newBalance) private {\\n\\t\\tuint256 currentBalance = _balances[account];\\n\\t\\tif (newBalance > currentBalance) {\\n\\t\\t\\tuint256 mintAmount = newBalance.sub(currentBalance);\\n\\t\\t\\t_mint(account, mintAmount);\\n\\t\\t} else if (newBalance < currentBalance) {\\n\\t\\t\\tuint256 burnAmount = currentBalance.sub(newBalance);\\n\\t\\t\\t_burn(account, burnAmount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _mint(address account, uint256 value) private {\\n\\t\\trequire(account != address(0), \\\"DividendTracker: mint to the zero address\\\");\\n\\t\\t_totalSupply = _totalSupply.add(value);\\n\\t\\t_balances[account] = _balances[account].add(value);\\n\\t\\t_magnifiedDividendCorrections[account] = _magnifiedDividendCorrections[account]\\n\\t\\t\\t.sub((_magnifiedDividendPerShare.mul(value))\\n\\t\\t\\t.toInt256Safe());\\n\\t}\\n\\n\\tfunction _burn(address account, uint256 value) private {\\n\\t\\trequire(account != address(0), \\\"DividendTracker: burn from the zero address\\\");\\n\\t\\t_balances[account] = _balances[account].sub(value, \\\"DividendTracker: burn amount exceeds balance\\\");\\n\\t\\t_totalSupply = _totalSupply.sub(value);\\n\\t\\t_magnifiedDividendCorrections[account] = _magnifiedDividendCorrections[account]\\n\\t\\t\\t.add((_magnifiedDividendPerShare.mul(value))\\n\\t\\t\\t.toInt256Safe());\\n\\t}\\n\\n\\tfunction _canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\n\\t\\tif (lastClaimTime > block.timestamp) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn block.timestamp.sub(lastClaimTime) >= _claimWait;\\n\\t}\\n\\n\\tfunction _setHolder(address key, uint val) private {\\n\\t\\tif (_tokenHoldersMap.active[key]) {\\n\\t\\t\\t_tokenHoldersMap.values[key] = val;\\n\\t\\t} else {\\n\\t\\t\\t_tokenHoldersMap.active[key] = true;\\n\\t\\t\\t_tokenHoldersMap.values[key] = val;\\n\\t\\t\\t_tokenHoldersMap.indexOf[key] = _tokenHoldersMap.keys.length;\\n\\t\\t\\t_tokenHoldersMap.keys.push(key);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _removeHolder(address key) private {\\n\\t\\tif (!_tokenHoldersMap.active[key]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdelete _tokenHoldersMap.active[key];\\n\\t\\tdelete _tokenHoldersMap.values[key];\\n\\t\\tuint index = _tokenHoldersMap.indexOf[key];\\n\\t\\tuint lastIndex = _tokenHoldersMap.keys.length - 1;\\n\\t\\taddress lastKey = _tokenHoldersMap.keys[lastIndex];\\n\\t\\t_tokenHoldersMap.indexOf[lastKey] = index;\\n\\t\\tdelete _tokenHoldersMap.indexOf[key];\\n\\t\\t_tokenHoldersMap.keys[index] = lastKey;\\n\\t\\t_tokenHoldersMap.keys.pop();\\n\\t}\\n\\n\\tfunction _processAccount(address payable account, bool automatic) private returns (bool) {\\n\\t\\tuint256 amount = _withdrawDividendOfUser(account);\\n\\t\\tif (amount > 0) {\\n\\t\\t\\t_lastClaimTimes[account] = block.timestamp;\\n\\t\\t\\temit Claim(account, amount, automatic);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction _getIndexOfKey(address key) private view returns (int) {\\n\\t\\tif(!_tokenHoldersMap.active[key]) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn int(_tokenHoldersMap.indexOf[key]);\\n\\t}\\n\\n\\tfunction _getKeyAtIndex(uint index) private view returns (address) {\\n\\t\\treturn _tokenHoldersMap.keys[index];\\n\\t}\\n\\n\\tfunction claim(address _holder) external onlyTokenContract {\\n\\t\\t_processAccount(payable(_holder), false);\\n\\t}\\n\\n\\tfunction updateDividendsDistributed(uint256 amount) external onlyTokenContract {\\n\\t\\tif (_totalSupply > 0 && amount > 0) {\\n\\t\\t\\t_magnifiedDividendPerShare = _magnifiedDividendPerShare\\n\\t\\t\\t\\t.add((amount)\\n\\t\\t\\t\\t.mul(MAGNITUDE) / _totalSupply);\\n\\t\\t\\temit DividendsDistributed(_msgSender(), amount);\\n\\t\\t\\t_totalDividendsDistributed = _totalDividendsDistributed.add(amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction excludeFromDividends(address account) external onlyTokenContract {\\n\\t\\trequire(!_excludedFromDividends[account]);\\n\\t\\t_excludedFromDividends[account] = true;\\n\\t\\t_setBalance(account, 0);\\n\\t\\t_removeHolder(account);\\n\\t\\temit ExcludeFromDividends(account);\\n\\t}\\n\\n\\tfunction excludeFromLottery(address account) external onlyTokenContract {\\n\\t\\trequire(!_excludedFromLottery[account]);\\n\\t\\t_excludedFromLottery[account] = true;\\n\\t\\temit ExcludeFromLottery(account);\\n\\t}\\n\\n\\tfunction payCommission(address referrer, uint256 amount) external onlyTokenContract {\\n\\t\\tif (amount >= _minimumTokenBalanceForDividends) {\\n\\t\\t\\t_referrers[referrer].transactions = _referrers[referrer].transactions.add(1);\\n\\t\\t\\tuint256 commission = 1;\\n\\t\\t\\tif (_bonusStructure[_referrers[referrer].transactions] > _referrers[referrer].bonus) {\\n\\t\\t\\t\\t_referrers[referrer].bonus = _bonusStructure[_referrers[referrer].transactions];\\n\\t\\t\\t}\\n\\t\\t\\t_referrers[referrer].totalValue = _referrers[referrer].totalValue.add(amount);\\n\\t\\t\\tcommission = commission.add(_referrers[referrer].bonus);\\n\\t\\t\\tuint256 commissionValue = amount.div(100).mul(commission);\\n\\t\\t\\t_referrers[referrer].commissions = _referrers[referrer].commissions.add(commissionValue);\\n\\t\\t\\ttokenContract.transfer(referrer, commissionValue);\\n\\t\\t\\tif (!_excludedFromLottery[referrer] && _referrers[referrer].transactions >= 5) {\\n\\t\\t\\t\\t_referredSwaps.push(referrer);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_unqualified++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction updateMinimumTokenBalanceForDividends(uint256 newValue) external onlyTokenContract {\\n\\t\\trequire(newValue < _minimumTokenBalanceForDividends, \\\"DividendTracker: The new value cannot be higher than the previous value\\\");\\n\\t\\temit MinimumTokenBalanceForDividendsUpdated(_minimumTokenBalanceForDividends, newValue);\\n\\t\\t_minimumTokenBalanceForDividends = newValue;\\n\\t}\\n\\n\\tfunction updateClaimWait(uint256 newClaimWait) external onlyTokenContract {\\n\\t\\trequire(newClaimWait >= 600 && newClaimWait <= 86400, \\\"DividendTracker: claimWait must be between 1 and 24 hours\\\");\\n\\t\\temit ClaimWaitUpdated(newClaimWait, _claimWait);\\n\\t\\t_claimWait = newClaimWait;\\n\\t}\\n\\n\\tfunction setBalance(address payable account, uint256 newBalance) external onlyTokenContract {\\n\\t\\tif (_excludedFromDividends[account]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (newBalance >= _minimumTokenBalanceForDividends) {\\n\\t\\t\\t_setBalance(account, newBalance);\\n\\t\\t\\t_setHolder(account, newBalance);\\n\\t\\t} else {\\n\\t\\t\\t_setBalance(account, 0);\\n\\t\\t\\t_removeHolder(account);\\n\\t\\t}\\n\\t\\t_processAccount(account, true);\\n\\t}\\n\\n\\tfunction process(uint256 gas) external onlyTokenContract returns (uint256, uint256, uint256) {\\n\\t\\tuint256 numberOfTokenHolders = _tokenHoldersMap.keys.length;\\n\\t\\tif (numberOfTokenHolders == 0) {\\n\\t\\t\\treturn (0, 0, _lastProcessedIndex);\\n\\t\\t}\\n\\t\\tuint256 lastProcessedIndex = _lastProcessedIndex;\\n\\t\\tuint256 gasUsed = 0;\\n\\t\\tuint256 gasLeft = gasleft();\\n\\t\\tuint256 iterations = 0;\\n\\t\\tuint256 claims = 0;\\n\\t\\twhile (gasUsed < gas && iterations < numberOfTokenHolders) {\\n\\t\\t\\tlastProcessedIndex++;\\n\\t\\t\\tif (lastProcessedIndex >= _tokenHoldersMap.keys.length) {\\n\\t\\t\\t\\tlastProcessedIndex = 0;\\n\\t\\t\\t}\\n\\t\\t\\taddress account = _tokenHoldersMap.keys[lastProcessedIndex];\\n\\t\\t\\tif (_canAutoClaim(_lastClaimTimes[account])) {\\n\\t\\t\\t\\tif (_processAccount(payable(account), true)) {\\n\\t\\t\\t\\t\\tclaims++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\titerations++;\\n\\t\\t\\tuint256 newGasLeft = gasleft();\\n\\t\\t\\tif (gasLeft > newGasLeft) {\\n\\t\\t\\t\\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\n\\t\\t\\t}\\n\\t\\t\\tgasLeft = newGasLeft;\\n\\t\\t}\\n\\t\\t_lastProcessedIndex = lastProcessedIndex;\\n\\t\\treturn (iterations, claims, _lastProcessedIndex);\\n\\t}\\n\\n\\tfunction setMilestone(uint256 milestone) external onlyTokenContract {\\n\\t\\t_milestonesList.push(milestone);\\n\\t\\t_milestones[milestone] = MilestoneDetails({ active : true, burn: 0 });\\n\\t\\temit NewMilestone(milestone);\\n\\t}\\n\\n\\tfunction holdersLotteryDraw() external onlyTokenContract {\\n\\t\\trequire(_milestonesList.length > 0, \\\"DividendTracker: There are no active milestones\\\");\\n\\t\\tuint256 milestone = _milestonesList[0];\\n\\t\\trequire(_milestones[milestone].active, \\\"DividendTracker: This milestone is not active\\\");\\n\\t\\tuint256 holders = _tokenHoldersMap.keys.length;\\n\\t\\trequire(holders >= milestone, \\\"DividendTracker: Insufficient holders to activate this milestone\\\");\\n\\t\\tuint256 randomIndex = (uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _totalSupply, _magnifiedDividendPerShare, milestone, _msgSender()))) % holders);\\n\\t\\trequire(!_excludedFromLottery[_tokenHoldersMap.keys[randomIndex]], \\\"DividendTracker: Excluded from lottery\\\");\\n\\t\\trequire(tokenContract.balanceOf(_tokenHoldersMap.keys[randomIndex]) >=  _minimumTokenBalanceForLottery, \\\"DividendTracker: Insufficient tokens\\\");\\n\\t\\tuint256 prize = tokenContract.holdersLotteryFund();\\n\\t\\tbool success = tokenContract.payTheWinner(_tokenHoldersMap.keys[randomIndex]);\\n\\t\\tif (success) {\\n\\t\\t\\t_hlWinner = _tokenHoldersMap.keys[randomIndex];\\n\\t\\t\\t_lastMilestoneReached = milestone;\\n\\t\\t\\t_removeMilestoneFromList();\\n\\t\\t\\t_milestones[milestone].active = false;\\n\\t\\t\\tuint256 toBurn = 0;\\n\\t\\t\\tif (_milestones[milestone].burn > 0) {\\n\\t\\t\\t\\ttoBurn = tokenContract.balanceOf(address(this))\\n\\t\\t\\t\\t\\t.div(100)\\n\\t\\t\\t\\t\\t.mul(_milestones[milestone].burn);\\n\\t\\t\\t\\ttokenContract.transfer(BURN_ADDRESS, toBurn);\\n\\t\\t\\t}\\n\\t\\t\\temit HoldersLotteryWinner(_hlWinner, milestone, prize, toBurn);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction referrersLotteryDraw() external onlyTokenContract {\\n\\t\\tuint256 referrers = _referredSwaps.length;\\n\\t\\tuint256 randomIndex = (uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _totalSupply, _magnifiedDividendPerShare, _tokenHoldersMap.keys.length, address(this).balance,  _msgSender()))) % referrers);\\n\\t\\trequire(!_excludedFromLottery[_referredSwaps[randomIndex]], \\\"DividendTracker: Excluded from lottery\\\");\\n\\t\\tbool success = tokenContract.referrersLotteryFundWithdrawal();\\n\\t\\tif (success) {\\n\\t\\t\\t_rlWinner = _referredSwaps[randomIndex];\\n\\t\\t\\temit ReferrersLotteryWinner(_rlWinner);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction updateMinTokensForLottery(uint256 value) external onlyTokenContract {\\n\\t\\t_minimumTokenBalanceForLottery = value;\\n\\t\\temit MinimumTokenBalanceForLotteryUpdated(value);\\n\\t}\\n\\n\\tfunction burnTheHouseDown() external onlyTokenContract {\\n\\t\\tuint256 toBurn = tokenContract.balanceOf(address(this));\\n\\t\\ttokenContract.transfer(BURN_ADDRESS, toBurn);\\n\\t\\temit NoMoreDividends(_totalDividendsDistributed);\\n\\t}\\n}\"\r\n    },\r\n    \"interfaces/IPancakeSwapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\ninterface IPancakeSwapV2Router01 {\\n\\tfunction factory() external view returns (address);\\n\\tfunction WETH() external view returns (address);\\n\\tfunction addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\\n\\tfunction addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\tfunction removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\\n\\tfunction removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountToken, uint amountETH);\\n\\tfunction removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\\n\\tfunction removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\\n\\tfunction swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n\\tfunction swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n\\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n\\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n\\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n\\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n\\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n\\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n\\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n\\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    },\r\n    \"abstracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\n\\t\\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n\\t\\treturn msg.data;\\n\\t}\\n}\"\r\n    },\r\n    \"libraries/SafeMathInt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n/**\\n * @title SafeMathInt\\n * @dev Math operations for int256 with overflow safety checks.\\n */\\nlibrary SafeMathInt {\\n\\tint256 private constant MIN_INT256 = int256(1) << 255;\\n\\tint256 private constant MAX_INT256 = ~(int256(1) << 255);\\n\\n\\t/**\\n\\t * @dev Multiplies two int256 variables and fails on overflow.\\n\\t */\\n\\tfunction mul(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\tint256 c = a * b;\\n\\t\\t// Detect overflow when multiplying MIN_INT256 with -1\\n\\t\\trequire(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\n\\t\\trequire((b == 0) || (c / b == a));\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Division of two int256 variables and fails on overflow.\\n\\t */\\n\\tfunction div(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\t// Prevent overflow when dividing MIN_INT256 by -1\\n\\t\\trequire(b != -1 || a != MIN_INT256);\\n\\t\\t// Solidity already throws when dividing by 0.\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Subtracts two int256 variables and fails on overflow.\\n\\t */\\n\\tfunction sub(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\tint256 c = a - b;\\n\\t\\trequire((b >= 0 && c <= a) || (b < 0 && c > a));\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Adds two int256 variables and fails on overflow.\\n\\t */\\n\\tfunction add(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\tint256 c = a + b;\\n\\t\\trequire((b >= 0 && c >= a) || (b < 0 && c < a));\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Converts to absolute value, and fails on overflow.\\n\\t */\\n\\tfunction abs(int256 a) internal pure returns (int256) {\\n\\t\\trequire(a != MIN_INT256);\\n\\t\\treturn a < 0 ? -a : a;\\n\\t}\\n\\n\\tfunction toUint256Safe(int256 a) internal pure returns (uint256) {\\n\\t\\trequire(a >= 0);\\n\\t\\treturn uint256(a);\\n\\t}\\n}\"\r\n    },\r\n    \"libraries/SafeMathUint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n/**\\n * @title SafeMathUint\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMathUint {\\n\\tfunction toInt256Safe(uint256 a) internal pure returns (int256) {\\n\\t\\tint256 b = int256(a);\\n\\t\\trequire(b >= 0);\\n\\t\\treturn b;\\n\\t}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bbperthousand\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"AutoBuyBackUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"fromLottery\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"fromDividends\",\"type\":\"bool\"}],\"name\":\"ExcludeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyBack\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dividend\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lottery\",\"type\":\"uint256\"}],\"name\":\"FeeDistributionUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpWeight\",\"type\":\"uint256\"}],\"name\":\"LPWeightUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"MinimumDividendBalanceToProcess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NewPartner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ReferrerLotteryWalletUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"TokenBalanceToLiqudateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"accountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"index\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"iterationsUntilProcessed\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsUntilAutoClaimAvailable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"accountDividendsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accumulativeDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"buyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackSetup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"PancakeSwapRouter\",\"type\":\"address\"}],\"name\":\"createPancakeSwapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendContract\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromLottery\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"fromDividends\",\"type\":\"bool\"}],\"name\":\"excludeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeMeFromLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dividendFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBackFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lotteryFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdersLotteryDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdersLotteryFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromLottery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastMilestoneReached\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMilestone\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokenBalanceForDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokenBalanceForLottery\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextMilestone\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensToLiqudate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeSwapV2Pair\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeSwapV2Router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"payTheWinner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"referrerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transactions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissions\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"excludedFromLottery\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrerLotteryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrersLotteryDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrersLotteryFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrersLotteryFundWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setAutoBuyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_busd\",\"type\":\"address\"}],\"name\":\"setBUSDContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dividendTracker\",\"type\":\"address\"}],\"name\":\"setDividendTrackerContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpWeight\",\"type\":\"uint256\"}],\"name\":\"setLPWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"milestone\",\"type\":\"uint256\"}],\"name\":\"setMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMinimumDividendBalanceToProcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMinimumTokenBalanceForDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setNumTokensToLiqudate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setReferrerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyBackFee\",\"type\":\"uint256\"}],\"name\":\"setTokenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVaultContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxSetup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"unlockVaultSlice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMinTokensForLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract AdoVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AdoToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9267e48a8ea6d167b1d39eca58b3d1d26fff779b8bba53f8ad00ed499ff1f7ff"}