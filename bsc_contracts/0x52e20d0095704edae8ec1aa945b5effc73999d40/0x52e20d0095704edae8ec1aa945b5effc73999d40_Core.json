{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Core.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport './interfaces/IERC20.sol';\\nimport './lib/SafeMath.sol';\\nimport \\\"./open/utils/Initializable.sol\\\";\\nimport \\\"./open/utils/Ownable.sol\\\";\\nimport \\\"./open/lib/EnumerableSet.sol\\\";\\n\\n\\ninterface IPancakeRouter02{\\n    function getAmountsOut(uint amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint[] memory amounts);\\n     function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ncontract Core is Initializable,Ownable{\\n    using SafeMath for uint256;\\n    \\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    address constant public rootAddress = address(0x000000000000000000000000000000000000dEaD);\\n    mapping (address => address) public _recommerMapping;\\n    mapping( address => address[]) firstChilds;\\n\\n\\n    struct Market{\\n        address token;      \\n        uint worth;         \\n        uint amount;        \\n        uint outMultiple;       \\n    }\\n\\n    Market[] public markets;\\n    address public awardToken;\\n    address public usdtToken;\\n    address public oldToken;\\n    address public newToken;\\n    uint public swapRate = 30;\\n    mapping(address => bool) public hasSwap;\\n    uint public swapWorthLimit = 1000e18;\\n    uint public PKSpriceRate = 2491;\\n    uint256 public _sellLqFee = 70;\\n\\n    struct Order{\\n        uint initTime;\\n        uint updateTimePrincipal;\\n        uint updateTimeProfit;\\n        uint endTime;\\n        uint amount;\\n        uint initAmount;\\n        uint outMultiple;\\n    }\\n\\n    struct Achievement{\\n        uint level;         \\n        uint teamAch;      \\n        uint selfAch;       \\n        uint regionAch;    \\n        address regionAddress;  \\n        uint lastTierAmount;\\n        uint indexPrincipal;\\n        uint indexProfit;\\n        Order[] orders;\\n    }\\n\\n    mapping(address => Achievement) internal achievements;\\n    mapping( address => EnumerableSet.AddressSet) internal validUsers;\\n\\n     struct UserInfo {\\n        uint256 hashRate;         \\n        uint256 tokenAward;  \\n        uint256 tokenDebt;\\n        uint256 firstAward; //\u4e00\u7ea7\u603b\u5956\u52b1\\n        uint256 secondAward; //\u4e8c\u7ea7\u603b\u5956\u52b1\\n        uint256 firstAwardHistory; //\u4e00\u7ea7\u603b\u5956\u52b1\u5386\u53f2\\n        uint256 secondAwardHistory; //\u4e8c\u7ea7\u603b\u5956\u52b1\u5386\u53f2\\n    }\\n\\n    struct PoolInfo {\\n        uint256 lastRewardBlock;    \\n        uint256 accCakePerShare; \\n        uint256 totalHashRate;          \\n    }   \\n\\n    PoolInfo[] public poolInfos;\\n    mapping (uint => mapping(address => UserInfo)) public userInfos;\\n\\n    uint constant public STATIC_INDEX = 0;\\n    uint constant public DYNAMIC_INDEX = 1;\\n\\n    function initialize(\\n        address _oldToken,\\n        address _newToken,\\n        address _awardToken,\\n        address _usdtToken\\n    ) public initializer {\\n        swapRate = 30;\\n        swapWorthLimit = 1000e18;\\n        _recommerMapping[rootAddress] = address(0xdeaddead);\\n        _owner = msg.sender;\\n        oldToken = _oldToken;\\n        newToken = _newToken;        \\n        awardToken = _awardToken;\\n        usdtToken = _usdtToken;\\n      \\n        poolInfos.push(PoolInfo(block.number,0,0) );\\n        poolInfos.push(PoolInfo(block.number,0,0) );\\n        markets.push(Market(_awardToken,100e18,0,15));\\n        markets.push(Market(_awardToken,500e18,0,16));\\n        markets.push(Market(_awardToken,1000e18,0,17));\\n        markets.push(Market(_awardToken,2000e18,0,18));\\n        markets.push(Market(_awardToken,3000e18,0,19));\\n    }\\n\\n    function setSwapRate(uint _swapRate)external onlyOwner{\\n        swapRate = _swapRate;\\n    }\\n\\n    struct SwapInfo{\\n        uint rate;\\n        uint swapableOldToken;\\n    }\\n    function getSwapInfo(address owner)external view returns(SwapInfo memory info){\\n        info.rate = swapRate;\\n        if( !hasSwap[owner]){\\n            info.swapableOldToken = _getUsdt2Token(swapWorthLimit) * 5;\\n        }\\n    }\\n\\n    function oldTokenSwapPKS(uint amount)external returns(uint v){\\n        if( amount > 0 ){\\n            IERC20(oldToken).transferFrom(msg.sender,address(this),amount);\\n            v = amount / swapRate;\\n            IERC20(newToken).transfer(msg.sender, v);\\n        }\\n    } \\n\\n\\n    function getMarketInfos()external view returns(Market[] memory mks){\\n        uint len = markets.length;\\n\\n        mks = new Market[](len);\\n        for( uint i = 0; i < len; i++ ){\\n            mks[i] = markets[i];\\n            mks[i].amount = _getUsdt2Token(mks[i].worth);\\n        }\\n    }\\n\\n    struct NetworkInfo{\\n        uint staticAch;\\n        uint dynamicAch;\\n    }\\n    function getNetworkInfo()external view returns(NetworkInfo memory info){\\n        info.staticAch = poolInfos[STATIC_INDEX].totalHashRate;\\n        info.dynamicAch = poolInfos[DYNAMIC_INDEX].totalHashRate;\\n    }\\n\\n    struct PersonInfo{\\n        uint staticAch;\\n        uint dynamicAch;\\n        uint level;\\n        uint childNum;\\n        uint teamAch;\\n        uint littleAch;\\n    }\\n\\n    function getUserInfos(address owner)external view returns(PersonInfo memory info){\\n        info.staticAch = userInfos[STATIC_INDEX][owner].hashRate;\\n        info.dynamicAch = userInfos[DYNAMIC_INDEX][owner].hashRate;\\n        Achievement storage a = achievements[owner];\\n        info.level = a.level;\\n        info.childNum = validUsers[owner].length();\\n        info.teamAch = a.teamAch;\\n        info.littleAch = a.teamAch.sub(a.regionAch);\\n    }\\n\\n    function pledge(uint index) external {\\n        Market storage m = markets[index];\\n\\n        uint tokenAmount = _getUsdt2Token(m.worth);\\n        IERC20(newToken).transferFrom(msg.sender, address(this), tokenAmount);\\n        _doPledge(msg.sender, m.worth, m.outMultiple);\\n\\n        pledgeAward(tokenAmount,msg.sender);\\n    }\\n\\n    function pledgeAwardToken(uint index) external {\\n        Market storage m = markets[index];\\n\\n        uint tokenAmount = _getUsdt2Token(m.worth); \\n        IERC20(awardToken).transferFrom(msg.sender, address(this), tokenAmount);\\n        _doPledge(msg.sender, m.worth, m.outMultiple);\\n\\n        pledgeAward(tokenAmount,msg.sender);\\n    \\n    }\\n\\n\\n    function pledgeUSDT(uint index)external{\\n        Market storage m = markets[index];\\n        uint USDTtokenAmount = m.worth;\\n        IERC20(usdtToken).transferFrom(msg.sender, address(0x042c92A07A5Ef0e71F705D12C66754c09D80dE11), USDTtokenAmount);\\n\\n        _doPledge(msg.sender,m.worth,m.outMultiple);\\n        uint shareAwardAmount = _getUsdt2Token(USDTtokenAmount);\\n        pledgeAward(shareAwardAmount,msg.sender);\\n    }\\n\\n    function pledgeAward( uint shareAwardAmount,address Award) public {\\n        address parent = _recommerMapping[Award];\\n        if (parent != address(0)) {\\n            uint shareAward = _getShareAward(shareAwardAmount, achievements[parent].selfAch);\\n            if (shareAward > 0) {\\n                UserInfo storage parentUser = userInfos[1][parent];\\n                //tokenAward\u53ea\u505a\u6316\u77ff\u5956\u52b1\\n                //parentUser.tokenAward += shareAward;\\n                //\u4e00\u7ea7\u603b\u5956\u52b1\u7d2f\u52a0\\n                parentUser.firstAward += shareAward;\\n                parentUser.firstAwardHistory += shareAward;\\n            }\\n\\n            address secondParent = _recommerMapping[parent];\\n            if (secondParent != address(0) ) {\\n                uint secondShareAward = _getSecondShareAward(shareAwardAmount, achievements[secondParent].selfAch);\\n                if (secondShareAward > 0) {\\n                    UserInfo storage secondParentUser = userInfos[1][secondParent];\\n                    //tokenAward\u53ea\u505a\u6316\u77ff\u5956\u52b1\\n                    //secondParentUser.tokenAward += secondShareAward;\\n                    //\u4e8c\u7ea7\u603b\u5956\u52b1\u7d2f\u52a0\\n                    secondParentUser.secondAward += secondShareAward;\\n                    secondParentUser.secondAwardHistory += secondShareAward;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getShareAward(uint value,uint selfAch)private pure returns(uint v){\\n        if( selfAch >= 100e18) return value * 15 / 100;\\n        return 0;\\n    }\\n\\n    function _getSecondShareAward(uint value,uint selfAch)private pure returns(uint v){\\n        if( selfAch >= 100e18) return value * 10 / 100;\\n        return 0;\\n    }\\n\\n    //\u8d28\u62bc \u9759\u6001\\n    function _doPledge(address owner,uint worth,uint outMultiple)private{\\n        \\n        require(worth > 0,\\\"invalid\\\");\\n\\n        deposit(STATIC_INDEX,owner, worth);\\n\\n        Achievement storage ach = achievements[owner];\\n\\n        uint time = getCurrentTime();\\n        ach.orders.push(\\n            Order(\\n                time,\\n                time,\\n                time,\\n                time + 100 days,\\n                worth * outMultiple / 10,\\n                worth,\\n                outMultiple\\n            )\\n        );\\n        //\u4e1a\u7ee9\u5237\u65b0\\n        ach.selfAch += worth;\\n        _addAch(owner,ach,worth);\\n        \\n        //\u66f4\u65b0\u81ea\u8eab\u7b49\u7ea7\\n        _updateLevel(ach);\\n    }\\n    //\u8ba1\u7b97\u4e1a\u7ee9  \u52a8\u6001\\n    function _addAch(address owner,Achievement storage user,uint value)internal{\\n\\n        address[] memory farthers = getForefathers(owner,10);\\n\\n        uint lg = user.teamAch + user.selfAch - user.lastTierAmount;\\n        address regionAddress = owner;\\n\\n        for( uint i = 0; i < 10; i++ ){\\n\\n            address farther = farthers[i];\\n\\n            if( farther == address(0)) break;\\n\\n            Achievement storage fa = achievements[farther];\\n\\n            fa.teamAch += value;\\n            if( i ==  9){\\n                fa.lastTierAmount += value;\\n            }\\n\\n            if( lg > fa.regionAch ){\\n                fa.regionAch = lg;\\n                fa.regionAddress = regionAddress;\\n            }\\n            \\n            _updateLevel(fa);\\n\\n            uint dhr = _getDynamicHashRate(fa.level,value);\\n            if( i < 3){\\n                EnumerableSet.AddressSet storage set = validUsers[farther];\\n                dhr += _getShareValue(value,set.length(),fa.selfAch,i);\\n\\n                if( i == 0 && !set.contains(owner)){\\n                    set.add(owner);\\n                }\\n            }\\n            if( dhr > 0){\\n                deposit(DYNAMIC_INDEX,farther, dhr);\\n            }\\n\\n            lg = fa.teamAch + fa.selfAch - fa.lastTierAmount;\\n            regionAddress = farther;\\n        }\\n    }\\n\\n    function _getDynamicHashRate(uint level,uint value)private pure returns(uint){\\n        if( level >= 5 ) return value * 50 / 100;\\n        if( level >= 4 ) return value * 40 / 100;\\n        if( level >= 3 ) return value * 30 / 100;\\n        if( level >= 2 ) return value * 20 / 100;\\n        if( level >= 1 ) return value * 10 / 100;\\n        return 0;\\n    }\\n\\n\\n    function _getShareValue(uint value,uint childNum,uint selfAch,uint i)private pure returns(uint){\\n        if( i == 2 && childNum >= 6 && selfAch >= 500e18) return value * 30 / 100;    //6 1000e18\\n        if( i == 1 && childNum >= 3 && selfAch >= 300e18) return value * 50 / 100;     //3 500e18\\n        if( i == 0 && childNum >= 1 && selfAch >= 100e18) return value * 100 / 100;\\n        return 0;\\n    }\\n\\n    function _updateLevel(Achievement storage ach)private{\\n        uint oldLevel = ach.level;\\n        uint newLevel = _getLevel(ach);\\n        if( newLevel != oldLevel){\\n            ach.level = newLevel;\\n        }\\n    }\\n\\n    function _getLevel(Achievement storage ach)internal view returns(uint){\\n        if( ach.selfAch == 0 ) return 0;\\n\\n        uint littleRegion = ach.teamAch - ach.regionAch;\\n        uint selfAch = ach.selfAch;\\n\\n        if( selfAch >= 10000e18 && littleRegion >= 1000000e18){   //\\n            return 5;\\n        }\\n        if( selfAch >= 5000e18  && littleRegion >= 300000e18){   //\\n            return 4;\\n        }\\n        if( selfAch >= 1000e18  && littleRegion >= 100000e18){     //\\n            return 3;\\n        }\\n        if( selfAch >= 500e18  && littleRegion >= 30000e18){     //\\n            return 2;\\n        }\\n        if( selfAch >= 100e18  && littleRegion >= 10000e18){     //\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    function drawPrincipal()external returns(uint v1,uint v2){\\n\\n        Achievement storage user = achievements[msg.sender];\\n\\n        Order[] storage orders = user.orders;\\n        uint index = user.indexPrincipal;\\n\\n        uint time = getCurrentTime();\\n        uint remHashRate = 0;\\n        for( uint i = index; i < orders.length; i++ ){\\n            Order storage order = orders[i];\\n\\n            uint updateTimePrincipal = order.updateTimePrincipal;\\n            uint t = time > order.endTime ? order.endTime : time;\\n            if( t > updateTimePrincipal ){\\n\\n                uint l = t - updateTimePrincipal;\\n\\n                if( l > 0 ){\\n                    v1 += l *( order.amount / (100 * 86400) ) * 10 / order.outMultiple;\\n                }\\n                updateTimePrincipal = t;\\n\\n                if( updateTimePrincipal >= order.endTime){\\n                    remHashRate += order.initAmount;\\n                    index = i + 1;\\n                }\\n                order.updateTimePrincipal = updateTimePrincipal;\\n            }\\n        }\\n\\n        if( index > user.indexPrincipal ){\\n            user.indexPrincipal = index;\\n        }\\n\\n        if( v1 > 0 ){\\n            uint fee = v1 * 2 / 100;\\n            v1 = v1.sub(fee);\\n            v2 = _getUsdt2Token(v1);\\n        }\\n\\n        if( v2 > 0 ){\\n            IERC20(awardToken).transfer(msg.sender, v2);\\n        }\\n\\n        if( remHashRate > 0){\\n            //\u6263\u9664\u7b97\u529b\\n            _clearZeroAch(msg.sender,remHashRate);\\n        }\\n    }\\n\\n    function drawProfit()external returns(uint v1,uint v2){\\n\\n        Achievement storage user = achievements[msg.sender];\\n\\n        Order[] storage orders = user.orders;\\n        uint index = user.indexProfit;\\n\\n        uint time = getCurrentTime();\\n        for( uint i = index; i < orders.length; i++ ){\\n            Order storage order = orders[i];\\n\\n            uint updateTimeProfit = order.updateTimeProfit;\\n            uint t = time > order.endTime ? order.endTime : time;\\n            if( t > updateTimeProfit ){\\n\\n                uint l = t - updateTimeProfit;\\n\\n                if( l > 0 ){\\n                    v1 += l *( order.amount / (100 * 86400) ) * (order.outMultiple.sub(10) ) / order.outMultiple;\\n                }\\n                updateTimeProfit = t;\\n\\n                if( updateTimeProfit >= order.endTime){\\n                    index = i + 1;\\n                }\\n                order.updateTimeProfit = updateTimeProfit;\\n            }\\n        }\\n\\n        if( index > user.indexProfit ){\\n            user.indexProfit = index;\\n        }\\n\\n        if( v1 > 0 ){\\n            v2 = _getUsdt2Token(v1);\\n        }\\n\\n        if( v2 > 0 ){\\n            IERC20(awardToken).transfer(msg.sender, v2);\\n        }\\n\\n    }\\n\\n    function draw()external returns(uint v1,uint v2){\\n        v1 = drawHashRateAward(0,msg.sender);\\n        v2 = drawHashRateAward(1,msg.sender);        \\n        uint v = v1 + v2;\\n        if( v > 0 ){\\n            IERC20(awardToken).transfer(msg.sender,v);\\n        }\\n    }\\n\\n    function getCurrentTime()private view returns(uint){\\n        return block.timestamp + userInfos[0][address(0)].hashRate;\\n    }\\n\\n    function getOffset()external view returns(uint){\\n        return userInfos[0][address(0)].hashRate;\\n    }\\n\\n    function changeOffset(bool isAdd,uint offset)external{\\n        if( isAdd){\\n            userInfos[0][address(0)].hashRate += offset;\\n        }else{\\n            uint o = userInfos[0][address(0)].hashRate;\\n            require(o >= offset);\\n            userInfos[0][address(0)].hashRate -= offset;\\n        }\\n    }\\n\\n    function _clearZeroAch(address owner,uint amount)private{\\n\\n        Achievement storage ach = achievements[owner];\\n        ach.selfAch = ach.selfAch.sub(amount);\\n\\n        withdraw(STATIC_INDEX,owner, amount);\\n\\n        if( ach.selfAch == 0){\\n            address parent = _recommerMapping[owner];\\n\\n            EnumerableSet.AddressSet storage set = validUsers[parent];\\n            if( set.contains(owner)){\\n                set.remove(owner);\\n            }\\n\\n            uint hashRate = userInfos[DYNAMIC_INDEX][owner].hashRate;\\n            withdraw(DYNAMIC_INDEX, owner, hashRate);\\n        }\\n\\n        _subAch(owner,amount);  //\u4e1a\u7ee9\u9012\u51cf\u66f4\u65b0\\n        _updateLevel(ach);    //\u66f4\u65b0\u81ea\u8eab\u661f\u7ea7\\n    }\\n\\n    function setSwapTokensaddress(address _swapTokens) public onlyOwner {\\n        newToken = _swapTokens;\\n    }\\n    function setPKSprice(uint _swapTokens) public onlyOwner {\\n        PKSpriceRate = _swapTokens;\\n    }\\n\\n    //1U \u6362 \u65b0PKS \\n    function _getUsdt2Token(uint amount)internal view returns(uint){\\n        uint usdtSwapToken = amount * PKSpriceRate;\\n        return usdtSwapToken;\\n    }\\n\\n    function _getToken2Usdt(uint tokenAmount)internal view returns(uint){\\n        uint PKSprice = tokenAmount / PKSpriceRate;\\n        return PKSprice;\\n    }\\n\\n    //\u83b7\u53d6\u65b0PKS \u7684\u4ef7\u683c\\n    function Token2Usdt(uint tokenAmount) internal view returns(uint){\\n        uint PKSprice = tokenAmount / PKSpriceRate;\\n        return PKSprice;\\n    }\\n\\n    function token2Usdt(uint tokenAmount)external view returns(uint){\\n        return _getToken2Usdt(tokenAmount);\\n    }\\n\\n    function usdt2Token(uint usdtAmount)external view returns(uint){\\n        return _getUsdt2Token(usdtAmount);\\n    }\\n   \\n    function _subAch(address owner,uint value)internal{\\n        address[] memory farthers = getForefathers(owner,10);\\n        address regionAddress = owner;\\n        for( uint i = 0; i < 10; i++ ){\\n\\n            address farther = farthers[i];\\n\\n            if( farther == address(0)) break;\\n\\n            Achievement storage fa = achievements[farther];\\n\\n            fa.teamAch = fa.teamAch.sub(value);\\n            \\n            if( i == 9){\\n                fa.lastTierAmount = fa.lastTierAmount.sub(value);\\n            }\\n\\n            if( fa.regionAddress == regionAddress ){\\n                fa.regionAch = fa.regionAch.sub(value);\\n\\n                if( fa.teamAch == 0){\\n                    fa.regionAddress = address(0);\\n                }else if( fa.regionAch * 100 / fa.teamAch < 50 ){\\n                    _updateAch(farther,fa);\\n                    _updateLevel(fa);\\n                }\\n            }\\n            regionAddress = farther;\\n        }\\n    }\\n\\n    function _updateAch(address owner,Achievement storage fa)private{\\n        EnumerableSet.AddressSet storage set = validUsers[owner];\\n\\n        uint len = set.length();\\n        address oldRegionAddress = fa.regionAddress;\\n        uint oldLg = fa.regionAch;\\n\\n        for(uint i = 0; i < len; i++){\\n            address child = set.at(i);\\n            Achievement storage a = achievements[child];\\n            uint lg = a.teamAch + a.selfAch - a.lastTierAmount;\\n\\n            if( lg > oldLg){\\n                oldLg = lg;\\n                oldRegionAddress = child;\\n            }\\n        }\\n\\n        if( oldLg > fa.regionAch){\\n            fa.regionAch = oldLg;\\n            fa.regionAddress = oldRegionAddress;\\n        }\\n    }\\n\\n    function addRelationEx(address recommer) external returns (bool) {\\n        require(recommer != msg.sender,\\\"your_self\\\");\\n        require(_recommerMapping[msg.sender] == address(0x0),\\\"binded\\\");\\n        require(recommer == rootAddress || _recommerMapping[recommer] != address(0x0),\\\"p_not_bind\\\");\\n        _recommerMapping[msg.sender] = recommer;\\n        firstChilds[recommer].push(msg.sender);\\n        return true;\\n    }\\n\\n    function getForefathers(address owner,uint num) private view returns(address[] memory fathers){\\n        fathers = new address[](num);\\n        address parent  = owner;\\n        for( uint i = 0; i < num; i++){\\n            parent = _recommerMapping[parent];\\n            if( parent == rootAddress || parent == address(0) ) break;\\n            fathers[i] = parent;\\n        }\\n    }\\n\\n    function _isContract(address a) internal view returns(bool){\\n        uint256 size;\\n        assembly {size := extcodesize(a)}\\n        return size > 0;\\n    }\\n\\n    function updatePool(uint id) internal {\\n        PoolInfo storage poolInfo = poolInfos[id];\\n        uint number = block.number;\\n        uint lastRewardBlock  = poolInfo.lastRewardBlock;\\n        if (number  <= lastRewardBlock) {\\n            return;\\n        }\\n        uint256 lpSupply = poolInfo.totalHashRate;\\n        if (lpSupply == 0) {\\n            poolInfo.lastRewardBlock = number;\\n            return;\\n        }\\n        uint256 multiplier = number.sub(lastRewardBlock);\\n\\n        poolInfo.accCakePerShare = poolInfo.accCakePerShare.add(multiplier.mul(1e40).div(lpSupply));\\n        poolInfo.lastRewardBlock = number;\\n    }\\n\\n    function deposit(uint id,address owner,uint256 _amount) private {\\n        PoolInfo storage poolInfo = poolInfos[id];\\n        UserInfo storage user = userInfos[id][owner];\\n\\n        updatePool(id);\\n\\n        uint hashRate = user.hashRate;\\n        uint accCakePerShare = poolInfo.accCakePerShare;\\n        if (hashRate > 0) {\\n            uint cake =hashRate *( hashRate / (100 * 86400) ); \\n            uint256 pending = cake.mul(accCakePerShare).div(1e40).sub(user.tokenDebt);\\n            if(pending > 0) {\\n                user.tokenAward += pending;\\n            }\\n        }\\n        if (_amount > 0) {\\n            user.hashRate = hashRate.add(_amount);\\n            poolInfo.totalHashRate += _amount;\\n            hashRate += _amount;\\n            uint cake =hashRate *( hashRate / (100 * 86400) ); \\n            user.tokenDebt = cake.mul(accCakePerShare).div(1e40);\\n        }\\n    }\\n\\n    function withdraw(uint id,address owner,uint amount) private {\\n        PoolInfo storage poolInfo = poolInfos[id];\\n\\n        UserInfo storage user = userInfos[id][owner];\\n        uint hashRate = user.hashRate;\\n\\n        if( hashRate == 0 || amount == 0) return;\\n\\n        amount = hashRate >= amount ? amount : hashRate;\\n       \\n        updatePool(id);\\n        uint cake =hashRate *( hashRate / (100 * 86400) ); \\n        uint256 pending = cake.mul(poolInfo.accCakePerShare).div(1e40).sub(user.tokenDebt);\\n        if(pending > 0) {\\n            user.tokenAward += pending;\\n        }\\n\\n        hashRate -= amount;\\n\\n        user.hashRate = hashRate;\\n        poolInfo.totalHashRate = poolInfo.totalHashRate.sub((amount));\\n        \\n        cake =hashRate *( hashRate / (100 * 86400) ); \\n        user.tokenDebt = cake.mul(poolInfo.accCakePerShare).div(1e40);\\n    }\\n\\n    function drawHashRateAward(uint id,address owner)private returns(uint tokenAmount){\\n        PoolInfo storage poolInfo = poolInfos[id];\\n        UserInfo storage user = userInfos[id][owner];\\n\\n        updatePool(id);\\n\\n        uint hashRate = user.hashRate;\\n        if(hashRate > 0) {\\n\\n            uint cake =hashRate *( hashRate / (100 * 86400) / 2); \\n            uint256 pending = cake.mul(poolInfo.accCakePerShare).div(1e40).sub(user.tokenDebt);\\n            if( pending > 0){\\n                user.tokenAward += pending;\\n            }\\n            user.tokenDebt = cake.mul(poolInfo.accCakePerShare).div(1e40);\\n        }\\n\\n        tokenAmount = user.tokenAward;\\n        if( tokenAmount > 0 ){\\n            user.tokenAward = 0;\\n        }\\n    }\\n\\n    //\u51fa\u91d1\\n    function AwardTokenSwapUSDT(uint amount) public {\\n        IERC20(awardToken).transferFrom(msg.sender,address(this),amount);\\n        uint Sell = amount * _sellLqFee / 1000;\\n        uint usdtSwapToken = (amount - Sell) / PKSpriceRate;\\n        IERC20(usdtToken).transfer(msg.sender,usdtSwapToken);\\n    }\\n    //\u5165\u91d1\\n    function USDT2newtokenSwap(uint amount) public {\\n        IERC20(usdtToken).transferFrom(msg.sender,address(0x042c92A07A5Ef0e71F705D12C66754c09D80dE11),amount);\\n        uint usdtSwapToken = amount * PKSpriceRate;\\n        IERC20(newToken).transfer(msg.sender,usdtSwapToken);\\n    }\\n\\n    //\u9080\u8bf7\u63d0\u73b0\\n    function InviteWithdraw() public{\\n        uint256 AwardToken;\\n        uint len = markets.length;\\n        for( uint i = 0; i < len; i++ ){\\n            UserInfo storage user = userInfos[i][msg.sender];\\n            AwardToken += user.firstAward;\\n            AwardToken += user.secondAward;\\n            user.firstAward = 0;\\n            user.secondAward = 0;\\n        }\\n        IERC20(awardToken).transfer(msg.sender,AwardToken);\\n    }\\n    \\n    function getChilds(address myAddress) public view returns(address[] memory childs){\\n        childs = firstChilds[myAddress];\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\nlibrary SafeMath {\\n    \\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n   \\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n   \\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n   \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n   \\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n   \\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/open/lib/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.5.0;\\n\\n\\nlibrary EnumerableSet {\\n   \\n    struct Set {\\n        bytes32[] _values;\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        \\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            \\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n    \\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            set._values.pop();\\n\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    \\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(Set storage set, bytes32 value) private view returns(uint){\\n        return set._indexes[value];\\n    }\\n\\n    \\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   \\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    \\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    \\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n   \\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   \\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    \\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n   \\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n   \\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   \\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    \\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    \\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    \\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n     function indexOf(UintSet storage set, uint256 value) internal view returns (uint) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n    \\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   \\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\"\r\n    },\r\n    \"contracts/open/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() public {}\\n\\n    function _msgSender() internal view returns (address ) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/open/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ncontract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n\\n     //|| _isConstructor()\\n    modifier initializer() {\\n        require(_initializing  || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        address self = address(this);\\n        uint256 cs;\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/open/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\ncontract Ownable is Context {\\n    \\n    address internal _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n   \\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    \\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n        _;\\n    }\\n\\n   \\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n   \\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AwardTokenSwapUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DYNAMIC_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InviteWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PKSpriceRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STATIC_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"USDT2newtokenSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_recommerMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellLqFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"}],\"name\":\"addRelationEx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"awardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"changeOffset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"draw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drawPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drawProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"myAddress\",\"type\":\"address\"}],\"name\":\"getChilds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"childs\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"worth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outMultiple\",\"type\":\"uint256\"}],\"internalType\":\"struct Core.Market[]\",\"name\":\"mks\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetworkInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"staticAch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dynamicAch\",\"type\":\"uint256\"}],\"internalType\":\"struct Core.NetworkInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getSwapInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapableOldToken\",\"type\":\"uint256\"}],\"internalType\":\"struct Core.SwapInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getUserInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"staticAch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dynamicAch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamAch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"littleAch\",\"type\":\"uint256\"}],\"internalType\":\"struct Core.PersonInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_awardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"worth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outMultiple\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"oldTokenSwapPKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pledge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shareAwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Award\",\"type\":\"address\"}],\"name\":\"pledgeAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pledgeAwardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pledgeUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accCakePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalHashRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapTokens\",\"type\":\"uint256\"}],\"name\":\"setPKSprice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapRate\",\"type\":\"uint256\"}],\"name\":\"setSwapRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapTokens\",\"type\":\"address\"}],\"name\":\"setSwapTokensaddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapWorthLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"token2Usdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"usdt2Token\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hashRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstAwardHistory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondAwardHistory\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Core", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}