{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2023-11-16\r\n*/\r\n\r\npragma solidity 0.6.0; \r\n\r\n//*******************************************************************************//\r\n//------------------ Contract to  BLAST50-15-22-20 100% Decentralized  -------------------//\r\n//*******************************************************************************//\r\ncontract owned\r\n{\r\n    address internal owner;\r\n    address internal newOwner;\r\n    address public signer;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        signer = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlySigner {\r\n        require(msg.sender == signer, 'caller must be signer');\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         token interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    //function isUserExists(address userAddress) external returns (bool);\r\n    function balanceOf(address _user) external view returns(uint);\r\n    function currentRate() external view returns(uint);\r\n }\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------        MAIN contract         -------------------//\r\n//*******************************************************************//\r\n\r\ncontract Blast_15_20_22 is owned {\r\n\r\n    // Replace below address with main token token\r\n    address public tokenAddress;\r\n    address public rewadAddress;\r\n    address public liquidityTokenAddress;\r\n\r\n    uint public maxDownLimit = 2;\r\n    uint[9] public lastIDCount;\r\n    uint public joiningFee = 10 * (10 ** 18);\r\n    uint public reJoinFee = 3 * (10 ** 18);\r\n    uint public reJoinFee1 = 5 * (10 ** 18);\r\n    uint public reJoinFee2 = 4 * (10 ** 18);\r\n  \r\n    uint nextJoinWait = 1 days;\r\n    uint nextReJoinWait = 1 hours;\r\n\r\n\r\n    mapping(address => uint) public ActiveDirect;\r\n    mapping(address => uint) public ActiveUnit;\r\n    mapping(address => uint) public nextJoinPending;  \r\n    mapping(address => uint) public nextJoinPending1; \r\n    mapping(address => uint) public nextJoinPending2;  \r\n    mapping(address => uint) public lastJoinTime;\r\n    mapping(address => uint) public lastReJoinTime;\r\n    mapping(address => uint) public lastReJoinTime1;\r\n    mapping(address => uint) public lastReJoinTime2;\r\n\r\n    \r\n    mapping(address => uint) public boostPending;\r\n    mapping(address => uint) public boosedCounter;\r\n\r\n    mapping(address => uint) public boostPending1;\r\n    mapping(address => uint) public boosedCounter1;\r\n\r\n    mapping(address => uint) public boostPending2;\r\n    mapping(address => uint) public boosedCounter2;\r\n\r\n    uint[9] public nextMemberFillIndex;  \r\n    uint[9] public nextMemberFillBox;   \r\n\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint parent;\r\n        uint referrerID;\r\n        uint directCount;\r\n    }\r\n\r\n    mapping(address => address[]) public directAddress;\r\n\r\n    \r\n\r\n    struct TotalInfo {\r\n        uint32 user;        \r\n        uint32 activeUnits;\r\n        uint32 pendingUnits;        \r\n        uint32 boostUnits;\r\n        uint32 boostUnits1;\r\n        uint32 boostUnits2;\r\n    }\r\n\r\n    struct UserIncomeInfo {         \r\n        uint32 UnitIncome;\r\n        uint32 DirectIncome;\r\n        uint32 LevelIncome;\r\n    }\r\n\r\n    mapping(address => UserIncomeInfo) public UserIncomeInfos;\r\n    bool public doUS; // enable or disable update stat\r\n\r\n    TotalInfo public total;\r\n\r\n    mapping(address => userInfo[9]) public userInfos;\r\n    mapping(uint => address) public refAddressbyUID;\r\n    mapping(address=> uint) public uidByRefAddress;\r\n\r\n\r\n    //userID => _level => address\r\n    mapping(uint => mapping(uint => address)) public userAddressByID;\r\n  \r\n    function init() public onlyOwner returns(bool){\r\n        require(lastIDCount[0]==0, \"can be called only once\");\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n\r\n        temp.joined = true;\r\n        temp.id = 1;\r\n        temp.parent = 1;\r\n        temp.referrerID = 1;\r\n        //temp.directCount = 2 ** 100;\r\n        temp.directCount = 100;\r\n\r\n\r\n        userInfos[owner][0] = temp;\r\n        userAddressByID[1][0] = owner;\r\n\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), 500 * (10 ** 18));\r\n\r\n        for(uint i=1;i<9;i++)\r\n        {\r\n            lastIDCount[i]++;\r\n            userInfos[owner][i] = temp;\r\n            userAddressByID[1][i] = owner;\r\n        }\r\n\r\n    }\r\n\r\n    function setTokenNAddress(address _tokenAddress, address _rewadAddress, address _liquidityTokenAddress) public onlyOwner returns(bool)\r\n    {\r\n        tokenAddress = _tokenAddress;\r\n        rewadAddress = _rewadAddress;\r\n        liquidityTokenAddress = _liquidityTokenAddress;\r\n        return true;\r\n    }\r\n\r\n    function token_current_rate() public view returns(uint crate)\r\n    {\r\n        uint current_rate = tokenInterface(liquidityTokenAddress).currentRate();\r\n        return current_rate;\r\n    }\r\n\r\n     function changeLimit_token(uint newlimit, uint64 _distribut) onlyOwner public returns(string memory){\r\n        maxlimit = newlimit;\r\n        distribut = _distribut;\r\n        return(\"token limit updated successfully\");\r\n    }\r\n\r\n    uint public maxlimit = 100 * (10**18);\r\n    uint64 public distribut = 65;\r\n    mapping (address => uint ) public userBytoken;\r\n    function Token_buy(uint amt) public returns(bool)\r\n    {\r\n        //require(userInfos[msg.sender].joined, \"address not joined\");\r\n        require(userInfos[msg.sender][0].joined, \"already joined\");\r\n        require(amt<=maxlimit, \"Limit is over\");\r\n        require((userBytoken[msg.sender] + amt) <= maxlimit, \"User Limit is over\");\r\n        if(amt<=maxlimit &&  (userBytoken[msg.sender] + amt) <= maxlimit)\r\n        {\r\n            tokenInterface(tokenAddress).transferFrom(msg.sender, rewadAddress, amt);\r\n           // tokenInterface(tokenAddress).transfer(levelAddress, amt);\r\n            uint current_rate = tokenInterface(liquidityTokenAddress).currentRate();\r\n            uint tokenamt = (amt * ( 10 ** 18 )) /current_rate;\r\n            tokenInterface(liquidityTokenAddress).transfer(msg.sender, (tokenamt * distribut)/100);\r\n            userBytoken[msg.sender] = userBytoken[msg.sender] + amt;\r\n        }\r\n\r\n         return true;\r\n    }\r\n\r\n\r\n    function settimer(uint _nextJoinWait, uint _nextULPWait) public onlyOwner returns(bool)\r\n    {\r\n        // put timeing is second minute hour day \r\n        nextJoinWait = _nextJoinWait;\r\n        nextReJoinWait = _nextULPWait;\r\n        \r\n        return true;\r\n    }\r\n    function toggleDoUS() public onlyOwner returns(bool)\r\n    {\r\n        doUS = !doUS;\r\n        return true;\r\n    }\r\n\r\n    event regUserEv(address _user,uint userid, address _referrer, uint refID,address parent, uint parentid,  uint timeNow, uint uid);\r\n    function regUser(uint uinRefID) public returns(bool) \r\n    {\r\n        address _ref = refAddressbyUID[uinRefID];\r\n\r\n        uint _referrerID = userInfos[_ref][0].id;\r\n        if(_referrerID == 0) _referrerID = 1;\r\n        //require(tokenInterface(tigerAddress).isUserExists(msg.sender), \"user not exists\");\r\n        require(msg.sender == tx.origin, \"contract can't call\");\r\n        require(!userInfos[msg.sender][0].joined, \"already joined\");\r\n        require(_referrerID <= lastIDCount[0], \"Invalid ref id\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), joiningFee);\r\n\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n\r\n        userInfos[_ref][0].directCount = userInfos[_ref][0].directCount + 1;\r\n\r\n        lastJoinTime[msg.sender] = now;\r\n      \r\n        ActiveUnit[msg.sender]++;\r\n        ActiveDirect[_ref]++;\r\n\r\n        ///////////////////////////////\r\n        uint current_rate = tokenInterface(liquidityTokenAddress).currentRate();\r\n        uint tokenamt = ((2 * ( 10 ** 18 )) * ( 10 ** 18 )) / current_rate;\r\n        tokenInterface(liquidityTokenAddress).transfer(msg.sender, (tokenamt * distribut)/100);\r\n        tokenInterface(tokenAddress).transfer(rewadAddress, 2 * ( 10 ** 18 ));\r\n\r\n        ///////////////////////////////\r\n        \r\n        directAddress[_ref].push(msg.sender);\r\n\r\n        uint uid = (uint(now) % 10000000) + uint(now);\r\n\r\n        uidByRefAddress[msg.sender] = uid;\r\n        refAddressbyUID[uid] = msg.sender;\r\n\r\n        total.user++;        \r\n        total.activeUnits++;\r\n       \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n\r\n        lastIDCount[3]++;\r\n        temp.id = lastIDCount[3];\r\n\r\n        (temp.parent,pay) = findFreeReferrer(3);\r\n        //temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][3] = temp;\r\n        userAddressByID[temp.id][3] = msg.sender;\r\n\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 3);\r\n           // nextJoinPending[userAddressByID[temp.parent][0]]++;\r\n           // total.pendingUnits = total.pendingUnits + 1;\r\n\r\n            buyLevel(userAddressByID[temp.parent][0], 4);\r\n\r\n        }\r\n\r\n        //Direct+Level -- registration\r\n       // payForLevel(_referrerID, 7);\r\n        \r\n        emit regUserEv(msg.sender,temp.id, _ref, _referrerID,userAddressByID[temp.parent][0], temp.parent, now, uid);\r\n        return true;\r\n    }\r\n\r\n    function regUser_top_byother(uint uinRefID, address _useraddress) public returns(bool) \r\n    {\r\n        address _ref = refAddressbyUID[uinRefID];\r\n\r\n        uint _referrerID = userInfos[_ref][0].id;\r\n        if(_referrerID == 0) _referrerID = 1;\r\n        //require(tokenInterface(tigerAddress).isUserExists(msg.sender), \"user not exists\");\r\n        require(msg.sender == tx.origin, \"contract can't call\");\r\n        //require(_useraddress == tx.origin, \"contract can't call\");\r\n        require(!userInfos[_useraddress][0].joined, \"already joined\");\r\n        require(_referrerID <= lastIDCount[0], \"Invalid ref id\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), joiningFee);\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[_useraddress][0] = temp;\r\n        userAddressByID[temp.id][0] = _useraddress;\r\n\r\n        ///////////////////////////////\r\n        uint current_rate = tokenInterface(liquidityTokenAddress).currentRate();\r\n        uint tokenamt =  ((2 * ( 10 ** 18 )) * ( 10 ** 18 )) / current_rate;\r\n        tokenInterface(liquidityTokenAddress).transfer(_useraddress, (tokenamt * distribut)/100);\r\n        tokenInterface(tokenAddress).transfer(rewadAddress, 2 * ( 10 ** 18 ));\r\n\r\n        ///////////////////////////////\r\n\r\n\r\n        userInfos[_ref][0].directCount = userInfos[_ref][0].directCount + 1;\r\n\r\n        lastJoinTime[_useraddress] = now;\r\n       // nextJoinPending[_useraddress] = 2;\r\n        ActiveUnit[_useraddress]++;\r\n        ActiveDirect[_ref]++;\r\n        \r\n        directAddress[_ref].push(_useraddress);\r\n\r\n       uint uid = (uint(now) % 10000000) + uint(now);\r\n\r\n        uidByRefAddress[_useraddress] = uid;\r\n        refAddressbyUID[uid] = _useraddress;\r\n\r\n        total.user++;        \r\n        total.activeUnits++;\r\n        //total.pendingUnits=total.pendingUnits+2;        \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n\r\n       \r\n        lastIDCount[3]++;\r\n        temp.id = lastIDCount[3];\r\n\r\n        (temp.parent,pay) = findFreeReferrer(3);\r\n        //temp.referrerID = _referrerID;\r\n\r\n        userInfos[_useraddress][3] = temp;\r\n        userAddressByID[temp.id][3] = _useraddress;\r\n\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 3);\r\n            buyLevel(userAddressByID[temp.parent][0], 4);\r\n\r\n        }\r\n\r\n        //Direct+Level -- registration\r\n        //payForLevel(_referrerID, 7);\r\n        \r\n        emit regUserEv(_useraddress,temp.id, _ref, _referrerID,userAddressByID[temp.parent][0], temp.parent, now, uid);\r\n        return true;\r\n    }\r\n\r\n    event enterMoreEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function BuyULP() public returns(bool){\r\n        require(lastReJoinTime[msg.sender] + nextReJoinWait <= now, \"please wait time little more\");\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), reJoinFee);\r\n\r\n       \r\n        //nextJoinPending[msg.sender]++;\r\n        ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n       \r\n        lastReJoinTime[msg.sender] = now;\r\n\r\n       \r\n        total.activeUnits++;\r\n       // total.pendingUnits=total.pendingUnits+1;\r\n            \r\n\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    function BuyULP5() public returns(bool){\r\n        require(lastReJoinTime1[msg.sender] + nextReJoinWait <= now, \"please wait time little more\");\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), reJoinFee1);\r\n\r\n       \r\n        //nextJoinPending[msg.sender]++;\r\n        //ActiveUnit[msg.sender]++;\r\n\r\n        userInfo memory temp;\r\n        lastIDCount[3]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[3];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n\r\n       \r\n\r\n        (temp.parent,pay) = findFreeReferrer(3);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][3] = temp;\r\n        userAddressByID[temp.id][3] = msg.sender;\r\n\r\n       \r\n        lastReJoinTime1[msg.sender] = now;\r\n\r\n       \r\n        //total.activeUnits++;\r\n       // total.pendingUnits=total.pendingUnits+1;\r\n            \r\n\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 3);\r\n            buyLevel(userAddressByID[temp.parent][0], 4);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n    function BuyULP4() public returns(bool){\r\n        require(lastReJoinTime2[msg.sender] + nextReJoinWait <= now, \"please wait time little more\");\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), reJoinFee2);\r\n\r\n       \r\n        //nextJoinPending[msg.sender]++;\r\n        //ActiveUnit[msg.sender]++;\r\n\r\n        userInfo memory temp;\r\n        lastIDCount[6]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[6];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n\r\n       \r\n\r\n        (temp.parent,pay) = findFreeReferrer(6);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][6] = temp;\r\n        userAddressByID[temp.id][6] = msg.sender;\r\n\r\n       \r\n        lastReJoinTime2[msg.sender] = now;\r\n\r\n       \r\n        //total.activeUnits++;\r\n       // total.pendingUnits=total.pendingUnits+1;\r\n            \r\n\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 6);\r\n            buyLevel(userAddressByID[temp.parent][0], 7);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    event joinNextEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);    \r\n    function joinNext() public returns(bool){\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n       // require(userInfos[msg.sender][0].joined, \"address used already\");\r\n        require(nextJoinPending[msg.sender] > 0, \"no pending next join\");\r\n        require(lastJoinTime[msg.sender] + nextJoinWait <= now, \"please wait time little more\");\r\n        nextJoinPending[msg.sender]--;\r\n        ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n\r\n        lastJoinTime[msg.sender] = now;\r\n        \r\n         \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits-1;       \r\n                \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0],1);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    function joinNext5() public returns(bool){\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        require(userInfos[msg.sender][0].joined, \"address used already\");\r\n        require(nextJoinPending1[msg.sender] > 0, \"no pending next join\");\r\n        //require(lastJoinTime[msg.sender] + nextJoinWait <= now, \"please wait time little more\");\r\n        nextJoinPending1[msg.sender]--;\r\n        //ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[3]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[3];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(3);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][3] = temp;\r\n        userAddressByID[temp.id][3] = msg.sender;\r\n\r\n\r\n       // lastJoinTime[msg.sender] = now;\r\n        \r\n         \r\n       // total.activeUnits++;\r\n       // total.pendingUnits=total.pendingUnits-1;       \r\n                \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 3);\r\n            buyLevel(userAddressByID[temp.parent][0],4);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n    function joinNext4() public returns(bool){\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n       // require(userInfos[msg.sender][0].joined, \"address used already\");\r\n        require(nextJoinPending2[msg.sender] > 0, \"no pending next join\");\r\n        //require(lastJoinTime[msg.sender] + nextJoinWait <= now, \"please wait time little more\");\r\n        nextJoinPending2[msg.sender]--;\r\n        //ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[6]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[6];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(6);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][6] = temp;\r\n        userAddressByID[temp.id][6] = msg.sender;\r\n\r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 6);\r\n            buyLevel(userAddressByID[temp.parent][0], 7);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    event buyLevelEv(uint level, address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function buyLevel(address _user, uint _level) internal returns(bool)\r\n    {\r\n        userInfo memory temp = userInfos[_user][0];\r\n\r\n        lastIDCount[_level]++;\r\n        temp.id = lastIDCount[_level];\r\n        if(_level == 0) temp.directCount = userInfos[_user][0].directCount;\r\n\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(_level);\r\n \r\n\r\n        userInfos[_user][_level] = temp;\r\n        userAddressByID[temp.id][_level] = _user;\r\n\r\n        address parentAddress = userAddressByID[temp.parent][_level];\r\n\r\n\r\n        if(pay)\r\n        {\r\n            if(_level < 2 ) payForLevel(temp.parent, _level); // for 0,1, only\r\n            if(_level <= 1 ) buyLevel(parentAddress, _level + 1); //upgrade for 0,1, only\r\n\r\n            if(_level == 2 ) \r\n            {\r\n                boostPending[parentAddress]++;              \r\n            }\r\n\r\n            if(_level >= 3  && _level < 5 ) payForLevel(temp.parent, _level); // for 0,1, only\r\n            if(_level >= 3  && _level <= 4 ) buyLevel(parentAddress, _level + 1); //upgrade for 0,1, only\r\n            if(_level == 5 ) \r\n            {\r\n                boostPending1[parentAddress]++;              \r\n            }\r\n\r\n            if(_level >= 6  && _level < 8 ) payForLevel(temp.parent, _level); // for 0,1, only\r\n            if(_level >= 6  && _level <= 7 ) buyLevel(parentAddress, _level + 1); //upgrade for 0,1, only\r\n            if(_level == 8 ) \r\n            {\r\n                boostPending2[parentAddress]++;              \r\n            }\r\n          \r\n            // if(_level == 4)\r\n            // {\r\n            //     buyLevel(parentAddress, _level + 1);\r\n            //     nextJoinPending[parentAddress] = nextJoinPending[parentAddress] + 2;\r\n            //     total.pendingUnits = total.pendingUnits + 2;\r\n            // } \r\n            \r\n            // if(_level == 5)\r\n            // {              \r\n            //     nextJoinPending[parentAddress] = nextJoinPending[parentAddress] + 10;\r\n            //     total.pendingUnits = total.pendingUnits + 10;\r\n            //     tokenInterface(tokenAddress).transfer(rewadAddress, 10 * (10 ** 18));  \r\n            // } \r\n                   \r\n          \r\n        }\r\n        emit buyLevelEv(_level, msg.sender, temp.id, userAddressByID[temp.parent][0], temp.parent, now);\r\n        return true;\r\n    }\r\n\r\n    event boostEv(address user, uint boostCount, uint remainingBoost, uint timeNow);\r\n    function blast15() public returns(bool)\r\n    {\r\n        require(boostPending[msg.sender] > 0, \"not eligible\" );\r\n        boosedCounter[msg.sender]++;\r\n        payForLevel(userInfos[msg.sender][2].id, 2);\r\n\r\n        nextJoinPending[msg.sender] = (nextJoinPending[msg.sender] + 2);\r\n\r\n        //nextJoinPending1[msg.sender] = (nextJoinPending1[msg.sender] + 1);\r\n        \r\n        \r\n        boostPending[msg.sender]--;\r\n\r\n        \r\n        //total.activeUnits++;       \r\n        total.boostUnits++;\r\n        total.pendingUnits = (total.pendingUnits + 2);\r\n        emit boostEv(msg.sender,boosedCounter[msg.sender],boostPending[msg.sender] , now);  \r\n\r\n        // userInfo memory temp = userInfos[msg.sender][0];\r\n\r\n        // lastIDCount[3]++;\r\n        // temp.id = lastIDCount[3];\r\n        // bool pay;\r\n        // (temp.parent,pay) = findFreeReferrer(0);\r\n        \r\n\r\n        // userInfos[msg.sender][3] = temp;\r\n        // userAddressByID[temp.id][3] = msg.sender;\r\n\r\n        // if(pay) \r\n        // {\r\n           \r\n        //     buyLevel(userAddressByID[temp.parent][0], 4);\r\n        // }\r\n\r\n\r\n\r\n        return true;\r\n    }\r\n    function blast22() public returns(bool)\r\n    {\r\n        require(boostPending1[msg.sender] > 0, \"not eligible\" );\r\n        boosedCounter1[msg.sender]++;\r\n        payForLevel(userInfos[msg.sender][5].id, 5);\r\n\r\n        nextJoinPending[msg.sender] = (nextJoinPending[msg.sender] + 3);\r\n\r\n        nextJoinPending1[msg.sender] = (nextJoinPending1[msg.sender] + 1);\r\n\r\n        nextJoinPending2[msg.sender] = (nextJoinPending2[msg.sender] + 1);\r\n        \r\n        \r\n        boostPending1[msg.sender]--;\r\n        \r\n        //total.activeUnits++;       \r\n        total.boostUnits++;\r\n        total.pendingUnits = (total.pendingUnits + 3);\r\n        emit boostEv(msg.sender,boosedCounter1[msg.sender],boostPending1[msg.sender] , now);  \r\n\r\n        \r\n\r\n\r\n        return true;\r\n    }\r\n\r\n    function blast20() public returns(bool)\r\n    {\r\n        require(boostPending2[msg.sender] > 0, \"not eligible\" );\r\n        boosedCounter2[msg.sender]++;\r\n        payForLevel(userInfos[msg.sender][8].id, 8);\r\n\r\n        //nextJoinPending[msg.sender] = (nextJoinPending[msg.sender] + 3);\r\n\r\n        nextJoinPending1[msg.sender] = (nextJoinPending1[msg.sender] + 1);\r\n\r\n        nextJoinPending2[msg.sender] = (nextJoinPending2[msg.sender] + 1);\r\n        \r\n        \r\n        boostPending2[msg.sender]--;\r\n        \r\n        //total.activeUnits++;       \r\n        total.boostUnits++;\r\n       // total.pendingUnits = (total.pendingUnits + 3);\r\n        emit boostEv(msg.sender,boosedCounter2[msg.sender],boostPending2[msg.sender] , now);  \r\n\r\n        \r\n\r\n\r\n        return true;\r\n    }\r\n\r\n    event payForLevelEv(uint level, uint parentID,address paidTo, uint amount, bool direct, uint timeNow);\r\n    function payForLevel(uint _pID, uint _level) internal returns (bool){\r\n        address _user = userAddressByID[_pID][_level];\r\n        if(_level == 0) \r\n        {\r\n           // tokenInterface(tokenAddress).transfer(_user,1 * (10 ** 18));\r\n           //US(_user, 0, 1);\r\n            //emit payForLevelEv(_level,_pID,_user, 1 * (10 ** 18), false, now);            \r\n        }\r\n        else if(_level == 1)\r\n        {\r\n              \r\n        }\r\n        else if(_level == 2)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 15 * (10 ** 18));\r\n            US(_user, 0, 10);\r\n            emit payForLevelEv(_level,_pID,_user, 15 * (10 ** 18), false, now);\r\n          \r\n            tokenInterface(tokenAddress).transfer(rewadAddress, 1 * (10 ** 18));\r\n            \r\n            _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            tokenInterface(tokenAddress).transfer(_user, 3 * (10 ** 18)); \r\n            US(_user, 1, 3);\r\n            emit payForLevelEv(_level,_pID,_user, 3 * (10 ** 18), true, now); \r\n        }\r\n\r\n        if(_level == 3) \r\n        {\r\n            //tokenInterface(tokenAddress).transfer(_user,2 * (10 ** 18));\r\n           // US(_user, 0, 2);\r\n           // emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), false, now);            \r\n        }\r\n        else if(_level == 4)\r\n        {\r\n              \r\n        }\r\n        else if(_level == 5)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 22 * (10 ** 18));\r\n            US(_user, 0, 22);\r\n            emit payForLevelEv(_level,_pID,_user, 22 * (10 ** 18), false, now);\r\n            \r\n            tokenInterface(tokenAddress).transfer(rewadAddress,2 * (10 ** 18));\r\n        }\r\n\r\n        if(_level == 6) \r\n        {\r\n                       \r\n        }\r\n        else if(_level == 7)\r\n        {\r\n           // tokenInterface(tokenAddress).transfer(_user,2 * (10 ** 18));\r\n           // US(_user, 0, 2);\r\n           // emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), false, now);\r\n        }\r\n        else if(_level == 8)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 20 * (10 ** 18));\r\n            US(_user, 0, 20);\r\n            emit payForLevelEv(_level,_pID,_user, 20 * (10 ** 18), false, now);\r\n            \r\n            tokenInterface(tokenAddress).transfer(rewadAddress, 1 * (10 ** 18));\r\n\r\n            _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            tokenInterface(tokenAddress).transfer(_user, 3 * (10 ** 18)); \r\n            US(_user, 1, 3);\r\n            emit payForLevelEv(_level,_pID,_user, 3 * (10 ** 18), true, now); \r\n\r\n        }\r\n\r\n           \r\n    }  \r\n\r\n    function US(address _user,uint8 _type, uint32 _amount) internal \r\n    {\r\n        if (doUS)\r\n        {\r\n            if(_type == 0 ) UserIncomeInfos[_user].UnitIncome = UserIncomeInfos[_user].UnitIncome + _amount ;\r\n            else if (_type == 1 ) UserIncomeInfos[_user].DirectIncome =  UserIncomeInfos[_user].DirectIncome + _amount;\r\n            else if (_type == 2 ) UserIncomeInfos[_user].LevelIncome =  UserIncomeInfos[_user].LevelIncome + _amount;\r\n        }\r\n    }\r\n\r\n  \r\n\r\n    //function findFreeReferrer(uint _level) internal returns(uint,bool) {\r\n    function findFreeReferrer(uint _level) public returns(uint,bool) {\r\n\r\n        bool pay;\r\n\r\n        uint currentID = nextMemberFillIndex[_level];\r\n\r\n        if(nextMemberFillBox[_level] == 0)\r\n        {\r\n            nextMemberFillBox[_level] = 1;\r\n        }   \r\n        else\r\n        {\r\n            nextMemberFillIndex[_level]++;\r\n            nextMemberFillBox[_level] = 0;\r\n            pay = true;\r\n        }\r\n        return (currentID+1,pay);\r\n    }\r\n\r\n\r\n    //a = join, b = ulp join\r\n    function timeRemains(address _user) public view returns(uint, uint, uint, uint)\r\n    {\r\n        uint a; // UNIT TIME\r\n        uint b; // ULP TIME\r\n        uint c;\r\n        uint d;\r\n        if( nextJoinPending[_user] == 0 || lastJoinTime[_user] + nextJoinWait < now) \r\n        {\r\n            a = 0;\r\n        }\r\n        else\r\n        {\r\n            a = (lastJoinTime[_user] + nextJoinWait) - now;\r\n        }\r\n               \r\n        if(lastReJoinTime[_user] + nextReJoinWait < now) \r\n        {\r\n            b = 0;\r\n        }\r\n        else\r\n        {\r\n            b = (lastReJoinTime[_user] + nextReJoinWait) - now ;\r\n        }\r\n        \r\n        if(lastReJoinTime1[_user] + nextReJoinWait < now) \r\n        {\r\n            c = 0;\r\n        }\r\n        else\r\n        {\r\n            c = (lastReJoinTime1[_user] + nextReJoinWait) - now ;\r\n        }\r\n        \r\n        if(lastReJoinTime2[_user] + nextReJoinWait < now) \r\n        {\r\n            d = 0;\r\n        }\r\n        else\r\n        {\r\n            d = (lastReJoinTime2[_user] + nextReJoinWait) - now ;\r\n        }\r\n        return (a,b,c,d);\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBoost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"boostEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"buyLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"enterMoreEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"joinNextEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"payForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"regUserEv\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ActiveDirect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ActiveUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyULP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyULP4\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyULP5\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Token_buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserIncomeInfos\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"UnitIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"DirectIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"LevelIncome\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blast15\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blast20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blast22\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boosedCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boosedCounter1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boosedCounter2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boostPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boostPending1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boostPending2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newlimit\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_distribut\",\"type\":\"uint64\"}],\"name\":\"changeLimit_token\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribut\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinNext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinNext4\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinNext5\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joiningFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastJoinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReJoinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReJoinTime1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReJoinTime2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxlimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextJoinPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextJoinPending1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextJoinPending2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reJoinFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reJoinFee1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reJoinFee2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refAddressbyUID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uinRefID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uinRefID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"regUser_top_byother\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewadAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityTokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenNAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextJoinWait\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextULPWait\",\"type\":\"uint256\"}],\"name\":\"settimer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"timeRemains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDoUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_current_rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"crate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"user\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"activeUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pendingUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits2\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uidByRefAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBytoken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Blast_15_20_22", "CompilerVersion": "v0.6.0+commit.26b70077", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0011d9ebe09567420b0803ca96178d5965633e79b49e2085ff3d5f094c8e4a0e"}