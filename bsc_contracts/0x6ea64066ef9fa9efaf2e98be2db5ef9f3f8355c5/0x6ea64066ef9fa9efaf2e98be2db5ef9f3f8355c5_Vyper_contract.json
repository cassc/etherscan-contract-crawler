{"SourceCode": "# @version 0.3.7\r\n\r\nstruct Deposit:\r\n    path: DynArray[address, MAX_SIZE]\r\n    amount1: uint256\r\n    depositor: address\r\n\r\nenum WithdrawType:\r\n    CANCEL\r\n    PROFIT_TAKING\r\n    STOP_LOSS\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n\r\ninterface UniswapV2Router:\r\n    def WETH() -> address: pure\r\n    def swapExactTokensForTokens(amountIn: uint256, amountOutMin: uint256, path: DynArray[address, MAX_SIZE], to: address, deadline: uint256) -> DynArray[uint256, MAX_SIZE]: nonpayable\r\n    def swapExactTokensForETH(amountIn: uint256, amountOutMin: uint256, path: DynArray[address, MAX_SIZE], to: address, deadline: uint256) -> DynArray[uint256, MAX_SIZE]: nonpayable\r\n    def getAmountsOut(amountIn: uint256, path: DynArray[address, MAX_SIZE]) -> DynArray[uint256, MAX_SIZE]: view\r\n\r\nevent Deposited:\r\n    deposit_id: uint256\r\n    token0: address\r\n    token1: address\r\n    amount0: uint256\r\n    amount1: uint256\r\n    depositor: address\r\n    profit_taking: uint256\r\n    stop_loss: uint256\r\n\r\nevent Withdrawn:\r\n    deposit_id: uint256\r\n    withdrawer: address\r\n    withdraw_type: WithdrawType\r\n    withdraw_amount: uint256\r\n\r\nevent UpdateCompass:\r\n    old_compass: address\r\n    new_compass: address\r\n\r\nWETH: immutable(address)\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE # Virtual ETH\r\nMAX_SIZE: constant(uint256) = 8\r\nROUTER: immutable(address)\r\ncompass: public(address)\r\ndeposit_size: public(uint256)\r\ndeposits: public(HashMap[uint256, Deposit])\r\n\r\n@external\r\ndef __init__(_compass: address, router: address):\r\n    self.compass = _compass\r\n    ROUTER = router\r\n    WETH = UniswapV2Router(ROUTER).WETH()\r\n    log UpdateCompass(empty(address), _compass)\r\n\r\n@internal\r\ndef _safe_approve(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"approve(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed approve\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_from, _to, _value, method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed transferFrom\r\n\r\n@external\r\n@payable\r\ndef deposit(path: DynArray[address, MAX_SIZE], amount0: uint256, min_amount1: uint256, profit_taking: uint256, stop_loss: uint256):\r\n    assert len(path) >= 2, \"Wrong path\"\r\n    _path: DynArray[address, MAX_SIZE] = path\r\n    token0: address = path[0]\r\n    last_index: uint256 = unsafe_sub(len(path), 1)\r\n    token1: address = path[last_index]\r\n    if token0 == VETH:\r\n        assert msg.value >= amount0\r\n        if msg.value > amount0:\r\n            send(msg.sender, msg.value - amount0)\r\n        WrappedEth(WETH).deposit(value=amount0)\r\n        _path[0] = WETH\r\n    else:\r\n        orig_balance: uint256 = ERC20(token0).balanceOf(self)\r\n        self._safe_transfer_from(token0, msg.sender, self, amount0)\r\n        assert ERC20(token0).balanceOf(self) == orig_balance + amount0\r\n    if token1 == VETH:\r\n        _path[last_index] = WETH\r\n    self._safe_approve(_path[0], ROUTER, amount0)\r\n    amounts: DynArray[uint256, MAX_SIZE] = UniswapV2Router(ROUTER).swapExactTokensForTokens(amount0, min_amount1, _path, self, block.timestamp)\r\n    assert amounts[last_index] > 0\r\n    deposit_id: uint256 = self.deposit_size\r\n    self.deposits[deposit_id] = Deposit({\r\n        path: path,\r\n        amount1: amounts[last_index],\r\n        depositor: msg.sender\r\n    })\r\n    self.deposit_size = deposit_id + 1\r\n    log Deposited(deposit_id, token0, token1, amount0, amounts[last_index], msg.sender, profit_taking, stop_loss)\r\n\r\n@internal\r\ndef _withdraw(deposit_id: uint256, min_amount0: uint256, withdraw_type: WithdrawType):\r\n    deposit: Deposit = self.deposits[deposit_id]\r\n    if withdraw_type == WithdrawType.CANCEL:\r\n        assert msg.sender == deposit.depositor\r\n    self.deposits[deposit_id] = Deposit({\r\n        path: empty(DynArray[address, MAX_SIZE]),\r\n        amount1: empty(uint256),\r\n        depositor: empty(address)\r\n    })\r\n    assert deposit.amount1 > 0\r\n    last_index: uint256 = unsafe_sub(len(deposit.path), 1)\r\n    path: DynArray[address, MAX_SIZE] = []\r\n    for i in range(MAX_SIZE):\r\n        path.append(deposit.path[unsafe_sub(last_index, i)])\r\n        if i >= last_index:\r\n            break\r\n    if path[0] == VETH:\r\n        path[0] = WETH\r\n    if path[last_index] == VETH:\r\n        path[last_index] = WETH\r\n    self._safe_approve(path[0], ROUTER, deposit.amount1)\r\n    amounts: DynArray[uint256, MAX_SIZE] = []\r\n    if deposit.path[0] == VETH:\r\n        amounts = UniswapV2Router(ROUTER).swapExactTokensForETH(deposit.amount1, min_amount0, path, deposit.depositor, block.timestamp)\r\n    else:\r\n        amounts = UniswapV2Router(ROUTER).swapExactTokensForTokens(deposit.amount1, min_amount0, path, deposit.depositor, block.timestamp)\r\n    log Withdrawn(deposit_id, msg.sender, withdraw_type, amounts[last_index])\r\n\r\n@external\r\ndef cancel(deposit_id: uint256, min_amount0: uint256):\r\n    self._withdraw(deposit_id, min_amount0, WithdrawType.CANCEL)\r\n\r\n@external\r\ndef withdraw(deposit_id: uint256, min_amount0: uint256, withdraw_type: WithdrawType):\r\n    assert msg.sender == self.compass\r\n    self._withdraw(deposit_id, min_amount0, withdraw_type)\r\n\r\n@external\r\n@view\r\ndef withdraw_amount(deposit_id: uint256) -> uint256:\r\n    deposit: Deposit = self.deposits[deposit_id]\r\n    path: DynArray[address, MAX_SIZE] = []\r\n    last_index: uint256 = unsafe_sub(len(deposit.path), 1)\r\n    for i in range(MAX_SIZE):\r\n        path.append(deposit.path[unsafe_sub(last_index, i)])\r\n        if i >= last_index:\r\n            break\r\n    if path[0] == VETH:\r\n        path[0] = WETH\r\n    if path[last_index] == VETH:\r\n        path[last_index] = WETH\r\n    amounts: DynArray[uint256, MAX_SIZE] = []\r\n    amounts = UniswapV2Router(ROUTER).getAmountsOut(deposit.amount1, path)\r\n    return amounts[last_index]\r\n\r\n@external\r\ndef multiple_withdraw(deposit_ids: DynArray[uint256, MAX_SIZE], min_amounts0: DynArray[uint256, MAX_SIZE], withdraw_types: DynArray[WithdrawType, MAX_SIZE]):\r\n    assert msg.sender == self.compass\r\n    assert len(deposit_ids) == len(min_amounts0) and len(deposit_ids) == len(withdraw_types)\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_ids):\r\n            break\r\n        self._withdraw(deposit_ids[i], min_amounts0[i], withdraw_types[i])\r\n\r\n@external\r\ndef update_compass(new_compass: address):\r\n    assert msg.sender == self.compass\r\n    self.compass = new_compass\r\n    log UpdateCompass(msg.sender, new_compass)", "ABI": "[{\"name\":\"Deposited\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token0\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token1\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount0\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount1\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"depositor\",\"type\":\"address\",\"indexed\":false},{\"name\":\"profit_taking\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"stop_loss\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdrawn\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdrawer\",\"type\":\"address\",\"indexed\":false},{\"name\":\"withdraw_type\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdraw_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateCompass\",\"inputs\":[{\"name\":\"old_compass\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_compass\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_compass\",\"type\":\"address\"},{\"name\":\"router\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"path\",\"type\":\"address[]\"},{\"name\":\"amount0\",\"type\":\"uint256\"},{\"name\":\"min_amount1\",\"type\":\"uint256\"},{\"name\":\"profit_taking\",\"type\":\"uint256\"},{\"name\":\"stop_loss\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\"},{\"name\":\"min_amount0\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\"},{\"name\":\"min_amount0\",\"type\":\"uint256\"},{\"name\":\"withdraw_type\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"withdraw_amount\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_withdraw\",\"inputs\":[{\"name\":\"deposit_ids\",\"type\":\"uint256[]\"},{\"name\":\"min_amounts0\",\"type\":\"uint256[]\"},{\"name\":\"withdraw_types\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_compass\",\"inputs\":[{\"name\":\"new_compass\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"compass\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposit_size\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposits\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"path\",\"type\":\"address[]\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"depositor\",\"type\":\"address\"}]}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000d5b0595208b77e2b2f2d9a5ec6b0e3287addb54500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}