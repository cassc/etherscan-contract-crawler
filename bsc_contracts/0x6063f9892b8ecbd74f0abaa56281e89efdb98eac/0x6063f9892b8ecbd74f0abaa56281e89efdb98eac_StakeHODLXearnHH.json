{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity 0.8.19;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, 'SafeMath: subtraction overflow');\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, 'SafeMath: division by zero');\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, 'SafeMath: modulo by zero');\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IHODLHAND {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function walletOfOwner(address _owner) external view returns(uint256[] memory);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n    function getPrice() external view returns (uint256);\r\n\r\n    function purchase(uint256 num) external payable;\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n}\r\n\r\ninterface IPancakeRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapETHForExactTokens(\r\n\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n  function onERC721Received(\r\n    address,\r\n    address,\r\n    uint256,\r\n    bytes calldata\r\n  )\r\n    public\r\n    pure\r\n    returns(bytes4)\r\n  {\r\n    return this.onERC721Received.selector;\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}('');\r\n        require(success, 'Address: unable to send value, recipient may have reverted');\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, 'Address: low-level call failed');\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), 'Address: call to non-contract');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IBEP20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            'SafeBEP20: approve from non-zero to non-zero allowance'\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            'SafeBEP20: decreased allowance below zero'\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, 'SafeBEP20: low-level call failed');\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), 'SafeBEP20: BEP20 operation did not succeed');\r\n        }\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract StakeHODLXearnHH is Ownable, ERC721Holder {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        uint256 earnedReward;\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IBEP20 lpToken;           // Address of LP token contract.\r\n        uint256 lastRewardBlock;  // Last block number that Hands distribution occurs.\r\n        uint256 accHandPerShare; // Accumulated Hands per share, times 1e12. See below.\r\n    }\r\n\r\n    // The Hand TOKEN!\r\n    IBEP20 public token;\r\n    IHODLHAND public hand;\r\n\r\n    // Hand tokens created per block.\r\n    uint256 public handPerBlock; // times le18, this is only calculation\r\n\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping (address => UserInfo) public userInfo;\r\n    // The block number when Hand mining starts.\r\n    uint256 public startBlock;\r\n    // The block number when Hand mining ends.\r\n    uint256 public bonusEndBlock;\r\n\r\n    uint256 public depositFee;\r\n    uint256 public withdrawFee;\r\n\r\n    uint256 public handPrice;\r\n\r\n    IPancakeRouter private pancakeRouter = IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address private BUSDaddress = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n\r\n    error WrongDepositFee(uint256 required, uint256 passed);\r\n    error WrongWithdrawFee(uint256 required, uint256 passed);\r\n\r\n    constructor(\r\n        IBEP20 _token,\r\n        IHODLHAND _hand,\r\n        uint256 _handPerBlock,\r\n        uint256 _startBlock,\r\n        uint256 _bonusEndBlock,\r\n        uint256 _depositFee,\r\n        uint256 _withdrawFee,\r\n        uint256 _handPrice\r\n    ) {\r\n        token = _token;\r\n        hand = _hand;\r\n        handPerBlock = _handPerBlock;\r\n        startBlock = _startBlock;\r\n        bonusEndBlock = _bonusEndBlock;\r\n        depositFee = _depositFee*1e16;\r\n        withdrawFee = _withdrawFee*1e16;\r\n        handPrice = _handPrice;\r\n\r\n        // staking pool\r\n        poolInfo.push(PoolInfo({\r\n            lpToken: _token,\r\n            lastRewardBlock: startBlock,\r\n            accHandPerShare: 0\r\n        }));\r\n\r\n    }\r\n\r\n    function getUserInfo(address _user) public view returns(\r\n        uint256 amount,\r\n        uint256 rewardDebt,\r\n        uint256 earnedReward\r\n    ) {\r\n        UserInfo memory user = userInfo[_user];\r\n        return (\r\n            user.amount,\r\n            user.rewardDebt,\r\n            user.earnedReward\r\n        );\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\r\n        if (_to <= bonusEndBlock) {\r\n            return _to.sub(_from);\r\n        } else if (_from >= bonusEndBlock) {\r\n            return 0;\r\n        } else {\r\n            return bonusEndBlock.sub(_from);\r\n        }\r\n    }\r\n\r\n    // View function to see pending Reward on frontend.\r\n    function pendingReward(address _user) external view returns (uint256) {\r\n        UserInfo memory user = userInfo[_user];\r\n        PoolInfo memory pool = poolInfo[0];\r\n        uint256 accHandPerShare = pool.accHandPerShare;\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n            uint256 handReward = multiplier.mul(handPerBlock);\r\n            accHandPerShare = accHandPerShare.add(handReward.mul(1e12).div(lpSupply));\r\n        }\r\n        return user.amount.mul(accHandPerShare).div(1e12).add(user.earnedReward).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool() private {\r\n        PoolInfo storage pool = poolInfo[0];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n        uint256 handReward = multiplier.mul(handPerBlock);\r\n        pool.accHandPerShare = pool.accHandPerShare.add(handReward.mul(1e12).div(lpSupply));\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    // Stake HODL tokens to SmartChef\r\n    function deposit(uint256 _amount) public payable {\r\n        require(_amount > 0, \"Nothing to deposit\");\r\n\r\n        if (depositFee > 0) {\r\n            if (msg.value < getFee()) {\r\n                revert WrongDepositFee({\r\n                    required: getFee(),\r\n                    passed: msg.value\r\n                });\r\n            }\r\n        }\r\n\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        PoolInfo storage pool = poolInfo[0];\r\n        updatePool();\r\n\r\n        if (user.amount > 0) {\r\n            user.earnedReward = user.amount.mul(pool.accHandPerShare).div(1e12).add(user.earnedReward).sub(user.rewardDebt);\r\n        } else {\r\n            user.earnedReward = 0;\r\n        }\r\n\r\n        pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n        user.amount = user.amount.add(_amount);\r\n       \r\n        user.rewardDebt = user.amount.mul(pool.accHandPerShare).div(1e12);        \r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw HODL tokens from STAKING.\r\n    function withdraw(uint256 _amount) public payable {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        PoolInfo storage pool = poolInfo[0];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n\r\n        if (withdrawFee > 0) {\r\n            if (msg.value < getWithdrawFee()) {\r\n                revert WrongWithdrawFee({\r\n                    required: getWithdrawFee(),\r\n                    passed: msg.value\r\n                });\r\n            }\r\n        }\r\n\r\n        updatePool();\r\n        uint256 pending = user.amount.mul(pool.accHandPerShare).div(1e12).add(user.earnedReward).sub(user.rewardDebt);\r\n        uint256 pendingWithDecimal = pending.div(1e18);\r\n        user.earnedReward = pending.sub(pendingWithDecimal.mul(1e18));\r\n        if(pendingWithDecimal > 0) {\r\n            mintHand(pendingWithDecimal);\r\n        }\r\n        if(_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n\r\n        user.rewardDebt = user.amount.mul(pool.accHandPerShare).div(1e12);  // error when withdraw\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() public payable {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        if (withdrawFee > 0) {\r\n            if (msg.value < getWithdrawFee()) {\r\n                revert WrongWithdrawFee({\r\n                    required: getWithdrawFee(),\r\n                    passed: msg.value\r\n                });\r\n            }\r\n        }\r\n\r\n        poolInfo[0].lpToken.safeTransfer(address(msg.sender), user.amount);\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        user.earnedReward = 0;\r\n        emit EmergencyWithdraw(msg.sender, user.amount);\r\n    }\r\n\r\n    //Withdraw with NFT by paying rest cost\r\n    function emergencyWithdrawWithRestNft() public payable {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        if (withdrawFee > 0) {\r\n            if (msg.value < getWithdrawFee()) {\r\n                revert WrongWithdrawFee({\r\n                    required: getWithdrawFee(),\r\n                    passed: msg.value\r\n                });\r\n            }\r\n        }\r\n\r\n        updatePool();\r\n        uint256 pending = user.amount.mul(poolInfo[0].accHandPerShare).div(1e12).add(user.earnedReward).sub(user.rewardDebt);\r\n        uint256 pendingWithDecimal = pending.div(1e18).add(1);\r\n        uint256 restAmountHand = pendingWithDecimal.mul(1e18).sub(pending);\r\n        uint256 payableBnbAmount = restAmountHand.mul(handPrice).div(1e18);\r\n        require(msg.value >= payableBnbAmount, \"not enough BNB!\");\r\n        poolInfo[0].lpToken.safeTransfer(address(msg.sender), user.amount);\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        user.earnedReward = 0;\r\n        mintHand(pendingWithDecimal);\r\n        emit Withdraw(msg.sender, user.amount);\r\n    }\r\n\r\n    function mintHand(uint256 _amountHands) private {\r\n        uint256 currentSupply = IHODLHAND(hand).totalSupply();\r\n        IHODLHAND(hand).purchase{value: _amountHands * IHODLHAND(hand).getPrice()}(_amountHands);\r\n        for(uint256 i; i < _amountHands; i++) {\r\n            IHODLHAND(hand).transferFrom(address(this), _msgSender(), currentSupply+i);\r\n        }\r\n    }\r\n\r\n    function withdrawBNB() public payable onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        payable(owner()).transfer(amount);\r\n    }\r\n\r\n    function getFee() public view returns(uint256) {\r\n        uint256 neededBNB;\r\n        address[] memory path = new address[](2);\r\n        path[0] = BUSDaddress;\r\n        path[1] = pancakeRouter.WETH();\r\n        neededBNB = pancakeRouter.getAmountsOut(depositFee, path)[1];\r\n        return neededBNB;\r\n    }\r\n\r\n    function getWithdrawFee() public view returns(uint256) {\r\n        uint256 neededBNB;\r\n        address[] memory path = new address[](2);\r\n        path[0] = BUSDaddress;\r\n        path[1] = pancakeRouter.WETH();\r\n        neededBNB = pancakeRouter.getAmountsOut(withdrawFee, path)[1];\r\n        return neededBNB;\r\n    }\r\n\r\n    function changeDepositFee(uint256 _depositFee) external onlyOwner {\r\n        depositFee = _depositFee*1e16;\r\n    }\r\n\r\n    function changeWithdrawFee(uint256 _withdrawFee) external onlyOwner {\r\n        withdrawFee = _withdrawFee*1e16;\r\n    }\r\n\r\n    function changeHandPrice(uint256 _newPrice) external onlyOwner {\r\n        handPrice = _newPrice;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getRestBNB(address _user) public view returns(uint256) {\r\n        UserInfo memory user = userInfo[_user];\r\n        //updatePool\r\n        PoolInfo memory pool = poolInfo[0];\r\n        if (block.number > pool.lastRewardBlock) {\r\n            uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n            if (lpSupply > 0) {\r\n                uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n                uint256 handReward = multiplier.mul(handPerBlock);\r\n                pool.accHandPerShare = pool.accHandPerShare.add(handReward.mul(1e12).div(lpSupply));\r\n            }\r\n        }\r\n        uint256 pending = user.amount.mul(pool.accHandPerShare).div(1e12).add(user.earnedReward).sub(user.rewardDebt);\r\n        uint256 pendingWithDecimal = pending.div(1e18).add(1);\r\n        uint256 restAmountHand = pendingWithDecimal.mul(1e18).sub(pending);\r\n        return restAmountHand.mul(handPrice).div(1e18);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IHODLHAND\",\"name\":\"_hand\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_handPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_handPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"passed\",\"type\":\"uint256\"}],\"name\":\"WrongDepositFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"passed\",\"type\":\"uint256\"}],\"name\":\"WrongWithdrawFee\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bonusEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositFee\",\"type\":\"uint256\"}],\"name\":\"changeDepositFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"changeHandPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawFee\",\"type\":\"uint256\"}],\"name\":\"changeWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawWithRestNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRestBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hand\",\"outputs\":[{\"internalType\":\"contract IHODLHAND\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"handPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"handPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accHandPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StakeHODLXearnHH", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "000000000000000000000000aebdbcc7d6821e3924ee5167b4138a43c19cf6810000000000000000000000007e82123bcb6465133d6e9e1ad94d0115de041b3d0000000000000000000000000000000000000000000000000000109ef22b4cd20000000000000000000000000000000000000000000000000000000001bd31a60000000000000000000000000000000000000000000000000000000001e6f126000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000429d069189e0000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a437e73af9f470f427e151e1461eca430136e78b06ad997f3aa77777f00c2d1b"}