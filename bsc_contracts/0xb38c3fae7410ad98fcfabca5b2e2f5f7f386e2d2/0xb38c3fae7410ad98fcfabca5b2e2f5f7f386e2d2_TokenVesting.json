{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\r\n// File: https://raw.githubusercontent.com/transmissions11/solmate/main/src/utils/ReentrancyGuard.sol\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Gas optimized reentrancy protection for smart contracts.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\nabstract contract ReentrancyGuard {\r\n    uint256 private locked = 1;\r\n\r\n    modifier nonReentrant() virtual {\r\n        require(locked == 1, \"REENTRANCY\");\r\n\r\n        locked = 2;\r\n\r\n        _;\r\n\r\n        locked = 1;\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/transmissions11/solmate/main/src/auth/Owned.sol\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\r\nabstract contract Owned {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            OWNERSHIP STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner() virtual {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             OWNERSHIP LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        owner = newOwner;\r\n\r\n        emit OwnershipTransferred(msg.sender, newOwner);\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/transmissions11/solmate/main/src/tokens/ERC20.sol\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/transmissions11/solmate/main/src/utils/SafeTransferLib.sol\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"APPROVE_FAILED\");\r\n    }\r\n}\r\n\r\n// File: TokenVesting.sol\r\n\r\n\r\npragma solidity ^0.8.19;\r\n\r\n// OpenZeppelin dependencies\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenVesting\r\n */\r\ncontract TokenVesting is Owned, ReentrancyGuard {\r\n    struct VestingSchedule {\r\n        // beneficiary of tokens after they are released\r\n        address beneficiary;\r\n        // cliff time of the vesting start in seconds since the UNIX epoch\r\n        uint256 cliff;\r\n        // start time of the vesting period in seconds since the UNIX epoch\r\n        uint256 start;\r\n        // duration of the vesting period in seconds\r\n        uint256 duration;\r\n        // duration of a slice period for the vesting in seconds\r\n        uint256 slicePeriodSeconds;\r\n        // whether or not the vesting is revocable\r\n        bool revocable;\r\n        // total amount of tokens to be released at the end of the vesting\r\n        uint256 amountTotal;\r\n        // amount of tokens released\r\n        uint256 released;\r\n        // whether or not the vesting has been revoked\r\n        bool revoked;\r\n    }\r\n\r\n    // address of the ERC20 token\r\n    ERC20 private immutable _token;\r\n\r\n    bytes32[] private vestingSchedulesIds;\r\n    mapping(bytes32 => VestingSchedule) private vestingSchedules;\r\n    uint256 private vestingSchedulesTotalAmount;\r\n    mapping(address => uint256) private holdersVestingCount;\r\n\r\n    /**\r\n     * @dev Reverts if the vesting schedule does not exist or has been revoked.\r\n     */\r\n    modifier onlyIfVestingScheduleNotRevoked(bytes32 vestingScheduleId) {\r\n        require(!vestingSchedules[vestingScheduleId].revoked);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a vesting contract.\r\n     * @param token_ address of the ERC20 token contract\r\n     */\r\n    constructor(address token_) Owned(msg.sender) {\r\n        // Check that the token address is not 0x0.\r\n        require(token_ != address(0x0));\r\n        // Set the token address.\r\n        _token = ERC20(token_);\r\n    }\r\n\r\n    /**\r\n     * @dev This function is called for plain Ether transfers, i.e. for every call with empty calldata.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev Fallback function is executed if none of the other functions match the function\r\n     * identifier or no data was provided with the function call.\r\n     */\r\n    fallback() external payable {}\r\n\r\n    /**\r\n     * @notice Creates a new vesting schedule for a beneficiary.\r\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n     * @param _start start time of the vesting period\r\n     * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n     * @param _duration duration in seconds of the period in which the tokens will vest\r\n     * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds\r\n     * @param _revocable whether the vesting is revocable or not\r\n     * @param _amount total amount of tokens to be released at the end of the vesting\r\n     */\r\n    function createVestingSchedule(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _slicePeriodSeconds,\r\n        bool _revocable,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        require(\r\n            getWithdrawableAmount() >= _amount,\r\n            \"TokenVesting: cannot create vesting schedule because not sufficient tokens\"\r\n        );\r\n        require(_duration > 0, \"TokenVesting: duration must be > 0\");\r\n        require(_amount > 0, \"TokenVesting: amount must be > 0\");\r\n        require(\r\n            _slicePeriodSeconds >= 1,\r\n            \"TokenVesting: slicePeriodSeconds must be >= 1\"\r\n        );\r\n        require(_duration >= _cliff, \"TokenVesting: duration must be >= cliff\");\r\n        bytes32 vestingScheduleId = computeNextVestingScheduleIdForHolder(\r\n            _beneficiary\r\n        );\r\n        uint256 cliff = _start + _cliff;\r\n        vestingSchedules[vestingScheduleId] = VestingSchedule(\r\n            _beneficiary,\r\n            cliff,\r\n            _start,\r\n            _duration,\r\n            _slicePeriodSeconds,\r\n            _revocable,\r\n            _amount,\r\n            0,\r\n            false\r\n        );\r\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount + _amount;\r\n        vestingSchedulesIds.push(vestingScheduleId);\r\n        uint256 currentVestingCount = holdersVestingCount[_beneficiary];\r\n        holdersVestingCount[_beneficiary] = currentVestingCount + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes the vesting schedule for given identifier.\r\n     * @param vestingScheduleId the vesting schedule identifier\r\n     */\r\n    function revoke(\r\n        bytes32 vestingScheduleId\r\n    ) external onlyOwner onlyIfVestingScheduleNotRevoked(vestingScheduleId) {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[\r\n            vestingScheduleId\r\n        ];\r\n        require(\r\n            vestingSchedule.revocable,\r\n            \"TokenVesting: vesting is not revocable\"\r\n        );\r\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\r\n        if (vestedAmount > 0) {\r\n            release(vestingScheduleId, vestedAmount);\r\n        }\r\n        uint256 unreleased = vestingSchedule.amountTotal -\r\n            vestingSchedule.released;\r\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - unreleased;\r\n        vestingSchedule.revoked = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the specified amount if possible.\r\n     * @param amount the amount to withdraw\r\n     */\r\n    function withdraw(uint256 amount) external nonReentrant onlyOwner {\r\n        require(\r\n            getWithdrawableAmount() >= amount,\r\n            \"TokenVesting: not enough withdrawable funds\"\r\n        );\r\n        /*\r\n         * @dev Replaced owner() with msg.sender => address of WITHDRAWER_ROLE\r\n         */\r\n        SafeTransferLib.safeTransfer(_token, msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Release vested amount of tokens.\r\n     * @param vestingScheduleId the vesting schedule identifier\r\n     * @param amount the amount to release\r\n     */\r\n    function release(\r\n        bytes32 vestingScheduleId,\r\n        uint256 amount\r\n    ) public nonReentrant onlyIfVestingScheduleNotRevoked(vestingScheduleId) {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[\r\n            vestingScheduleId\r\n        ];\r\n        bool isBeneficiary = msg.sender == vestingSchedule.beneficiary;\r\n\r\n        bool isReleasor = (msg.sender == owner);\r\n        require(\r\n            isBeneficiary || isReleasor,\r\n            \"TokenVesting: only beneficiary and owner can release vested tokens\"\r\n        );\r\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\r\n        require(\r\n            vestedAmount >= amount,\r\n            \"TokenVesting: cannot release tokens, not enough vested tokens\"\r\n        );\r\n        vestingSchedule.released = vestingSchedule.released + amount;\r\n        address payable beneficiaryPayable = payable(\r\n            vestingSchedule.beneficiary\r\n        );\r\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - amount;\r\n        SafeTransferLib.safeTransfer(_token, beneficiaryPayable, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of vesting schedules associated to a beneficiary.\r\n     * @return the number of vesting schedules\r\n     */\r\n    function getVestingSchedulesCountByBeneficiary(\r\n        address _beneficiary\r\n    ) external view returns (uint256) {\r\n        return holdersVestingCount[_beneficiary];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the vesting schedule id at the given index.\r\n     * @return the vesting id\r\n     */\r\n    function getVestingIdAtIndex(\r\n        uint256 index\r\n    ) external view returns (bytes32) {\r\n        require(\r\n            index < getVestingSchedulesCount(),\r\n            \"TokenVesting: index out of bounds\"\r\n        );\r\n        return vestingSchedulesIds[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the vesting schedule information for a given holder and index.\r\n     * @return the vesting schedule structure information\r\n     */\r\n    function getVestingScheduleByAddressAndIndex(\r\n        address holder,\r\n        uint256 index\r\n    ) external view returns (VestingSchedule memory) {\r\n        return\r\n            getVestingSchedule(\r\n                computeVestingScheduleIdForAddressAndIndex(holder, index)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total amount of vesting schedules.\r\n     * @return the total amount of vesting schedules\r\n     */\r\n    function getVestingSchedulesTotalAmount() external view returns (uint256) {\r\n        return vestingSchedulesTotalAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the ERC20 token managed by the vesting contract.\r\n     */\r\n    function getToken() external view returns (address) {\r\n        return address(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of vesting schedules managed by this contract.\r\n     * @return the number of vesting schedules\r\n     */\r\n    function getVestingSchedulesCount() public view returns (uint256) {\r\n        return vestingSchedulesIds.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the vested amount of tokens for the given vesting schedule identifier.\r\n     * @return the vested amount\r\n     */\r\n    function computeReleasableAmount(\r\n        bytes32 vestingScheduleId\r\n    )\r\n        external\r\n        view\r\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId)\r\n        returns (uint256)\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[\r\n            vestingScheduleId\r\n        ];\r\n        return _computeReleasableAmount(vestingSchedule);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the vesting schedule information for a given identifier.\r\n     * @return the vesting schedule structure information\r\n     */\r\n    function getVestingSchedule(\r\n        bytes32 vestingScheduleId\r\n    ) public view returns (VestingSchedule memory) {\r\n        return vestingSchedules[vestingScheduleId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that can be withdrawn by the owner.\r\n     * @return the amount of tokens\r\n     */\r\n    function getWithdrawableAmount() public view returns (uint256) {\r\n        return _token.balanceOf(address(this)) - vestingSchedulesTotalAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the next vesting schedule identifier for a given holder address.\r\n     */\r\n    function computeNextVestingScheduleIdForHolder(\r\n        address holder\r\n    ) public view returns (bytes32) {\r\n        return\r\n            computeVestingScheduleIdForAddressAndIndex(\r\n                holder,\r\n                holdersVestingCount[holder]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the last vesting schedule for a given holder address.\r\n     */\r\n    function getLastVestingScheduleForHolder(\r\n        address holder\r\n    ) external view returns (VestingSchedule memory) {\r\n        return\r\n            vestingSchedules[\r\n                computeVestingScheduleIdForAddressAndIndex(\r\n                    holder,\r\n                    holdersVestingCount[holder] - 1\r\n                )\r\n            ];\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the vesting schedule identifier for an address and an index.\r\n     */\r\n    function computeVestingScheduleIdForAddressAndIndex(\r\n        address holder,\r\n        uint256 index\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(holder, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the releasable amount of tokens for a vesting schedule.\r\n     * @return the amount of releasable tokens\r\n     */\r\n    function _computeReleasableAmount(\r\n        VestingSchedule memory vestingSchedule\r\n    ) internal view returns (uint256) {\r\n        // Retrieve the current time.\r\n        uint256 currentTime = getCurrentTime();\r\n        // If the current time is before the cliff, no tokens are releasable.\r\n        if ((currentTime < vestingSchedule.cliff) || vestingSchedule.revoked) {\r\n            return 0;\r\n        }\r\n        // If the current time is after the vesting period, all tokens are releasable,\r\n        // minus the amount already released.\r\n        else if (\r\n            currentTime >= vestingSchedule.start + vestingSchedule.duration\r\n        ) {\r\n            return vestingSchedule.amountTotal - vestingSchedule.released;\r\n        }\r\n        // Otherwise, some tokens are releasable.\r\n        else {\r\n            // Compute the number of full vesting periods that have elapsed.\r\n            uint256 timeFromStart = currentTime - vestingSchedule.start;\r\n            uint256 secondsPerSlice = vestingSchedule.slicePeriodSeconds;\r\n            uint256 vestedSlicePeriods = timeFromStart / secondsPerSlice;\r\n            uint256 vestedSeconds = vestedSlicePeriods * secondsPerSlice;\r\n            // Compute the amount of tokens that are vested.\r\n            uint256 vestedAmount = (vestingSchedule.amountTotal *\r\n                vestedSeconds) / vestingSchedule.duration;\r\n            // Subtract the amount already released and return.\r\n            return vestedAmount - vestingSchedule.released;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current time.\r\n     * @return the current timestamp in seconds.\r\n     */\r\n    function getCurrentTime() internal view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"computeNextVestingScheduleIdForHolder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vestingScheduleId\",\"type\":\"bytes32\"}],\"name\":\"computeReleasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"computeVestingScheduleIdForAddressAndIndex\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slicePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_revocable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createVestingSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getLastVestingScheduleForHolder\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slicePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"internalType\":\"struct TokenVesting.VestingSchedule\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVestingIdAtIndex\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vestingScheduleId\",\"type\":\"bytes32\"}],\"name\":\"getVestingSchedule\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slicePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"internalType\":\"struct TokenVesting.VestingSchedule\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVestingScheduleByAddressAndIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slicePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"internalType\":\"struct TokenVesting.VestingSchedule\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingSchedulesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getVestingSchedulesCountByBeneficiary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingSchedulesTotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vestingScheduleId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"vestingScheduleId\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenVesting", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000009dce13e71b11eb5df66ca269bd657696587fd4e2", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://263c01352cf04dc7168257fff2c1534586b22a8f6c085ff333e621fe5c723ac7"}