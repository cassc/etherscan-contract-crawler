{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/swaps/NFTMarket.sol\": {\r\n      \"content\": \"\\n\\npragma solidity ^0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IRainiNft1155 is IERC1155 {\\n  struct TokenVars {\\n    uint128 cardId;\\n    uint32 level;\\n    uint32 number; // to assign a numbering to NFTs\\n    bytes1 mintedContractChar;\\n  }\\n\\n  function tokenVars(uint256 _tokenId) external view returns (TokenVars memory);\\n}\\n\\ncontract NFTMarket is AccessControl, ReentrancyGuard {\\n\\n  bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n  bytes32 public constant BURNER_ROLE = keccak256(\\\"BURNER_ROLE\\\");\\n\\n  struct Listing {\\n    uint96 itemId;\\n    uint32 amount;\\n    uint32 expiryDate;\\n    uint16 cardLevel;\\n    bool isOffer;\\n    bool usesCardId;\\n    bool exists;\\n    address contractAddress;\\n    address owner;\\n    uint256 unitPrice;\\n  }\\n\\n  uint256 public maxListingId = 0;\\n\\n  uint256 public feesCollected;\\n\\n  mapping(address => bool) public approvedTokenContracts;  \\n  \\n  mapping(uint256 => Listing) public listings;\\n\\n  uint256 feeBasisPoints;\\n\\n  address payable public feeRecipient;\\n\\n  bool public selfDestructDisabled;\\n\\n  event ItemListed(uint96 listingId, uint96 itemId, uint16 cardLevel, bool usesCardId, address contractAddress, uint32 amount, uint256 unitPrice, bool isOffer, uint32 expiryDate);\\n\\n  event TokenSold(uint96 tokenId, address contractAddress, uint32 amount, uint256 unitPrice, address seller, address buyer, uint256 listingId);\\n\\n  event PriceChanged(uint256 listingId, uint256 unitPrice);\\n\\n  event ListingRemoved(uint256 listingId);\\n\\n  constructor(address payable _feeRecipient){\\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    _setupRole(MINTER_ROLE, _msgSender());\\n    _setupRole(BURNER_ROLE, _msgSender());\\n    feeRecipient = _feeRecipient;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \\\"NFTMarket: caller is not an admin\\\");\\n    _;\\n  }\\n\\n  function addTokenContract(address _tokenContract) \\n    external onlyOwner {\\n      approvedTokenContracts[_tokenContract] = true;\\n  }\\n\\n  function removeTokenContract(address _tokenContract) \\n    external onlyOwner {\\n      approvedTokenContracts[_tokenContract] = false;\\n  }\\n\\n  function setFeeBasisPoints(uint256 _feeBasisPoints) \\n    external onlyOwner {\\n      feeBasisPoints = _feeBasisPoints;\\n  }\\n\\n  function setFeeRecipient(address payable _feeRecipient) \\n    external onlyOwner {\\n      feeRecipient = _feeRecipient;\\n  }\\n\\n  struct listItemsData {\\n    uint256 maxListingId;\\n    uint256 escrowAmount;\\n  }\\n\\n  //List a number of items for sale at a fixed price.\\n  function listItems(uint96[] memory _id, uint16[] memory _cardLevel, bool[] memory _usesCardId, address[] memory _contractAddress, uint32[] memory _amount, uint256[] memory _unitPrice, bool _isOffer, uint32 _expiryDate) \\n    external payable nonReentrant {\\n      listItemsData memory _locals = listItemsData({\\n        maxListingId: maxListingId,\\n        escrowAmount: 0\\n      });\\n\\n      for (uint256 i = 0; i < _id.length; i++) {\\n        require((approvedTokenContracts[_contractAddress[i]]), \\\"NFTMarket: invalid token contract\\\");\\n        IRainiNft1155 tokenContract = IRainiNft1155(_contractAddress[i]);\\n\\n        require(_isOffer || tokenContract.isApprovedForAll(_msgSender(), address(this)), \\\"NFTMarket: Not approved for all\\\");\\n        require(_isOffer || tokenContract.balanceOf(_msgSender(), _id[i]) >=  _amount[i], \\\"NFTMarket: Not enough balance\\\");\\n\\n        _locals.maxListingId++;\\n        listings[_locals.maxListingId] = Listing({\\n          itemId: _id[i],\\n          usesCardId: _isOffer && _usesCardId[i],\\n          cardLevel: _isOffer && _usesCardId[i] ? _cardLevel[i] : 0,\\n          contractAddress: _contractAddress[i],\\n          amount: _amount[i],\\n          unitPrice: _unitPrice[i],\\n          expiryDate: _expiryDate,\\n          isOffer: _isOffer,\\n          exists: true,\\n          owner: _msgSender()\\n        });\\n\\n        emit ItemListed(uint96(_locals.maxListingId), _id[i], _isOffer && _usesCardId[i] ? _cardLevel[i] : 0, _isOffer && _usesCardId[i], _contractAddress[i], _amount[i], _unitPrice[i], _isOffer,  _expiryDate);\\n\\n        if (_isOffer) {\\n          _locals.escrowAmount += _unitPrice[i] * _amount[i];\\n        }\\n      }\\n\\n      maxListingId = _locals.maxListingId;\\n\\n      require(_locals.escrowAmount <= msg.value, \\\"Not enough ETH\\\");\\n\\n      // refund excess Eth\\n      (bool success, ) = _msgSender().call{ value: msg.value - _locals.escrowAmount }(\\\"\\\"); \\n      require(success, \\\"transfer failed\\\");\\n  }\\n\\n  function unlistItems(uint256[] memory _listingId) \\n    external nonReentrant {\\n      uint256 refundAmount = 0;\\n      for (uint256 i = 0; i < _listingId.length; i++) {\\n        Listing memory _listing = listings[_listingId[i]];\\n\\n        require(_listing.owner == _msgSender(), \\\"Not listing owner\\\");\\n        delete listings[_listingId[i]];\\n        emit ListingRemoved(_listingId[i]);\\n        if (_listing.isOffer) {\\n          // refund escrow\\n          refundAmount += _listing.amount * _listing.unitPrice;\\n        }\\n      }\\n      (bool success, ) = _msgSender().call{ value: refundAmount}(\\\"\\\"); \\n      require(success, \\\"transfer failed\\\");\\n  }\\n\\n  function repriceItems(uint256[] memory _listingId, uint256[] memory _unitPrice) \\n    external payable nonReentrant {\\n      int256 escrowDiff = 0;\\n\\n      for (uint256 i = 0; i < _listingId.length; i++) {\\n        Listing memory _listing = listings[_listingId[i]];\\n\\n        require(_listing.owner == _msgSender(), \\\"Not listing owner\\\");\\n\\n        if (_unitPrice[i] != 0) {\\n          if (_listing.isOffer) {\\n            escrowDiff += (int256(_unitPrice[i]) - int256(_listing.unitPrice)) * int32(_listing.amount);\\n          }\\n          listings[_listingId[i]].unitPrice = _unitPrice[i];\\n          emit PriceChanged(_listingId[i], _unitPrice[i]);\\n        }\\n      }\\n\\n      require(escrowDiff < 0 || uint256(escrowDiff) <= msg.value, \\\"Not enough ETH\\\");\\n\\n      uint256 refund = (escrowDiff > 0)  ? msg.value - uint256(escrowDiff) : msg.value + uint256(-escrowDiff);\\n      (bool success, ) = _msgSender().call{ value: refund }(\\\"\\\"); \\n      require(success, \\\"transfer failed\\\");\\n  }\\n\\n  struct BuySellData {\\n    uint256 totalCost;\\n    uint256 totalIncome;\\n    uint256 price;\\n    uint256 fee;\\n    uint256 feesCollected;\\n    uint256 count;\\n    address owner;\\n    uint256 i;\\n    uint256 j;\\n    bool success;\\n  }\\n\\n  // price is required because items can be repriced\\n  function buySell(uint256[] memory _listingId, uint256[][] memory _tokenIds, uint32[] memory _amount, uint256[] memory _unitPrice, bool _allOrNothing) \\n    external payable nonReentrant {\\n      BuySellData memory _locals = BuySellData({\\n        totalCost: 0,\\n        totalIncome: 0,\\n        price: 0,\\n        fee: 0,\\n        owner: address(0),\\n        feesCollected: 0,\\n        count: 0,\\n        i: 0,\\n        j: 0,\\n        success: false\\n      });\\n\\n      Listing memory _listing;\\n\\n      for (_locals.i = 0; _locals.i < _listingId.length; _locals.i++) {\\n        _listing = listings[_listingId[_locals.i]];\\n        if (_listing.exists \\n              && (_listing.unitPrice == _unitPrice[_locals.i]) \\n              && _listing.amount >= _amount[_locals.i]\\n              && (_listing.expiryDate == 0 || block.timestamp < _listing.expiryDate)) {\\n          IRainiNft1155 tokenContract = IRainiNft1155(_listing.contractAddress);\\n          _locals.owner = _listing.isOffer ? _msgSender() : _listing.owner;\\n\\n          _locals.success = false;\\n          if (tokenContract.isApprovedForAll(_locals.owner, address(this))) {\\n            if (_listing.usesCardId) {\\n              _locals.count = 0;\\n              for (_locals.j = 0; _locals.j < _tokenIds.length; _locals.j++) {\\n                IRainiNft1155.TokenVars memory _tokenVars =  tokenContract.tokenVars(_tokenIds[_locals.i][_locals.j]);\\n                if (_tokenVars.cardId == _listing.itemId && _tokenVars.level == _listing.cardLevel \\n                      && tokenContract.balanceOf(_locals.owner, _listing.itemId) >= 1) {\\n                    _locals.count++;\\n                  } else {\\n                    require(false, \\\"Bad token\\\");\\n                    break;\\n                  }\\n              }\\n              _locals.success = (_locals.count == _amount[_locals.i]);\\n              require(_locals.success, \\\"Not enough tokens\\\");\\n            } else {\\n              _locals.success = (tokenContract.balanceOf(_locals.owner, _listing.itemId) >=  _amount[_locals.i]);\\n              require(_locals.success, \\\"Not enough tokens\\\");\\n            }\\n          } else {\\n            require(!_allOrNothing, \\\"Transaction failed - seller not approved\\\");\\n          }\\n\\n          if (_locals.success) {\\n            if (_listing.amount == _amount[_locals.i]) {\\n              delete listings[_listingId[_locals.i]];\\n            } else {\\n              listings[_listingId[_locals.i]].amount -= _amount[_locals.i];\\n            }\\n            \\n            _locals.price = _listing.unitPrice * _amount[_locals.i];\\n            _locals.fee = _locals.price * feeBasisPoints / 10000;\\n\\n            _locals.feesCollected += _locals.fee;\\n\\n            if (!_listing.isOffer) {\\n              _locals.totalCost += _locals.price;\\n              require(_locals.totalCost <= msg.value + _locals.totalIncome, \\\"Not enough ETH\\\");\\n              tokenContract.safeTransferFrom(_listing.owner, _msgSender(), _listing.itemId, _amount[_locals.i], bytes('0x0'));\\n              emit TokenSold(_listing.itemId, address(tokenContract), _amount[_locals.i], _listing.unitPrice, _listing.owner, _msgSender(), _listingId[_locals.i]);\\n              // send Eth to seller\\n              (_locals.success, ) = _listing.owner.call{ value: _locals.totalCost - _locals.fee }(\\\"\\\");\\n              require(_locals.success, \\\"transfer failed\\\");\\n            } else {\\n              _locals.totalIncome += _locals.price - _locals.fee;\\n              if (_listing.usesCardId) {\\n                for (_locals.j = 0; _locals.j < _tokenIds.length; _locals.j++) {\\n                  tokenContract.safeTransferFrom(_msgSender(), _listing.owner, _tokenIds[_locals.i][_locals.j], 1, bytes('0x0'));\\n                  emit TokenSold(uint96(_tokenIds[_locals.i][_locals.j]), address(tokenContract), 1, _listing.unitPrice, _msgSender(), _listing.owner, _listingId[_locals.i]);\\n                }\\n              } else {\\n                tokenContract.safeTransferFrom(_msgSender(), _listing.owner, _listing.itemId, _amount[_locals.i], bytes('0x0'));\\n                emit TokenSold(_listing.itemId, address(tokenContract), _amount[_locals.i], _listing.unitPrice, _msgSender(), _listing.owner, _listingId[_locals.i]);\\n              }\\n            }\\n\\n          } else {\\n            require(!_allOrNothing, \\\"Transaction failed\\\");\\n          }\\n        } else {\\n          require(!_allOrNothing, \\\"Transaction failed\\\");\\n        }\\n      }\\n\\n      (_locals.success, ) = feeRecipient.call{ value: _locals.feesCollected }(\\\"\\\"); \\n      require(_locals.success, \\\"transfer failed\\\");\\n\\n      // Payout income and refund excess Eth\\n      (_locals.success, ) = _msgSender().call{ value: msg.value + _locals.totalIncome - _locals.totalCost }(\\\"\\\"); \\n      require(_locals.success, \\\"transfer failed\\\");\\n\\n      \\n  }\\n\\n  function disableSelfDestruct() onlyOwner external {\\n    selfDestructDisabled = true;\\n  }\\n\\n  function selfDestruct() onlyOwner external {\\n    require(!selfDestructDisabled);\\n    selfdestruct(feeRecipient);\\n  }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"listingId\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"itemId\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"cardLevel\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"usesCardId\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"amount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOffer\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"expiryDate\",\"type\":\"uint32\"}],\"name\":\"ItemListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"}],\"name\":\"ListingRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"tokenId\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"amount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"addTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokenContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_listingId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_tokenIds\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"_amount\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_unitPrice\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_allOrNothing\",\"type\":\"bool\"}],\"name\":\"buySell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableSelfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96[]\",\"name\":\"_id\",\"type\":\"uint96[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_cardLevel\",\"type\":\"uint16[]\"},{\"internalType\":\"bool[]\",\"name\":\"_usesCardId\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"_contractAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_amount\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_unitPrice\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_isOffer\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"_expiryDate\",\"type\":\"uint32\"}],\"name\":\"listItems\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listings\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"itemId\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"amount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expiryDate\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"cardLevel\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isOffer\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"usesCardId\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxListingId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"removeTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_listingId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_unitPrice\",\"type\":\"uint256[]\"}],\"name\":\"repriceItems\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestructDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setFeeBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_listingId\",\"type\":\"uint256[]\"}],\"name\":\"unlistItems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFTMarket", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000082f9d5fe6c46990f3c2536e83b2b4e1c0a91f27f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}