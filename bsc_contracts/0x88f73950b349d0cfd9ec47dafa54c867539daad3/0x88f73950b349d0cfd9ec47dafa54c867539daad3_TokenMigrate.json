{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.0;\r\n\r\nlibrary TransferHelper {\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract TokenMigrate {\r\n\r\n    event Migrated(address indexed from, uint256 amount);\r\n\r\n    address public oldTokenContract;\r\n    address public newTokenContract;\r\n    uint256 public totalMigratedTokens;\r\n\r\n    constructor (address _oldToken, address _newToken) {\r\n        oldTokenContract = _oldToken;\r\n        newTokenContract = _newToken;\r\n    }\r\n\r\n    function swapOldToNewToken(uint256 amount) public returns (uint256 swapped_tokens) {\r\n        require(IERC20(newTokenContract).balanceOf(address(this)) >= amount, \"This contract does not have enough NEW Tokens, contact owners\");\r\n        require(IERC20(oldTokenContract).balanceOf(msg.sender) >= amount, \"Not enough OLD Tokens\");\r\n        require(IERC20(oldTokenContract).allowance(msg.sender, address(this)) >= amount, \"Go to OLD Token contract and approve this contract\");\r\n\r\n        // Get users initial balance of both the new and old token\r\n        uint256 userOldTokenInitialBalance = IERC20(oldTokenContract).balanceOf(msg.sender);\r\n        uint256 userNewTokenInitialBalance = IERC20(newTokenContract).balanceOf(msg.sender);\r\n\r\n        // Get this contracts initial balance of both the new and old token\r\n        uint256 contractOldTokenInitialBalance = IERC20(oldTokenContract).balanceOf(address(this));\r\n        uint256 contractNewTokenInitialBalance = IERC20(newTokenContract).balanceOf(address(this));\r\n\r\n        // Transfer OLD token from the user to this contract and NEW token from this contract to the user\r\n        TransferHelper.safeTransferFrom(oldTokenContract, msg.sender, address(this), amount);\r\n        TransferHelper.safeTransfer(newTokenContract, msg.sender, amount);\r\n\r\n        // Make sure all balances is correct after the transfer\r\n        require(IERC20(oldTokenContract).balanceOf(address(this)) == (contractOldTokenInitialBalance + amount), \"Something went wrong transfer OLD token to this contract\");\r\n        require(IERC20(newTokenContract).balanceOf(address(this)) == (contractNewTokenInitialBalance - amount), \"Something went wrong transfer NEW token to the user\");\r\n        require(IERC20(oldTokenContract).balanceOf(msg.sender) == (userOldTokenInitialBalance - amount), \"Something went wrong, user OLD token balance is not correct\");\r\n        require(IERC20(newTokenContract).balanceOf(msg.sender) == (userNewTokenInitialBalance + amount), \"Something went wrong, user NEW token balance is not correct\");\r\n\r\n        emit Migrated(msg.sender, amount);\r\n        totalMigratedTokens += amount;\r\n        return amount;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"newTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapOldToNewToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapped_tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMigratedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenMigrate", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e56a473043eaab7947c0a2408cea623074500ee30000000000000000000000001555bb429075dc2aa97aefe99ef3ad7ea6cace78", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c42fffe3c4c0bd4f8e6a41b02eda6b7ab5b433efb417913e7435120f88a6fc75"}