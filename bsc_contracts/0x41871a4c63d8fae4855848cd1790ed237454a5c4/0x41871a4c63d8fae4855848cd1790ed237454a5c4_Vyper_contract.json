{"SourceCode": "# @version 0.3.3\r\n\"\"\"\r\n@title Curve Factory\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Permissionless pool deployer and registry\r\n\"\"\"\r\n\r\n\r\ninterface CryptoPool:\r\n    def balances(i: uint256) -> uint256: view\r\n    def initialize(\r\n        A: uint256,\r\n        gamma: uint256,\r\n        mid_fee: uint256,\r\n        out_fee: uint256,\r\n        allowed_extra_profit: uint256,\r\n        fee_gamma: uint256,\r\n        adjustment_step: uint256,\r\n        admin_fee: uint256,\r\n        ma_half_time: uint256,\r\n        initial_price: uint256,\r\n        _token: address,\r\n        _coins: address[2],\r\n        _precisions: uint256\r\n    ): nonpayable\r\n\r\ninterface ERC20:\r\n    def decimals() -> uint256: view\r\n\r\ninterface Token:\r\n    def initialize(_name: String[64], _symbol: String[32], _pool: address): nonpayable\r\n\r\n\r\nevent CryptoPoolDeployed:\r\n    pool: address\r\n    token: address\r\n    coins: address[2]\r\n    A: uint256\r\n    gamma: uint256\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    allowed_extra_profit: uint256\r\n    fee_gamma: uint256\r\n    adjustment_step: uint256\r\n    admin_fee: uint256\r\n    ma_half_time: uint256\r\n    initial_price: uint256\r\n    deployer: address\r\n\r\nevent UpdateFeeReceiver:\r\n    _old_fee_receiver: address\r\n    _new_fee_receiver: address\r\n\r\nevent UpdatePoolImplementation:\r\n    _old_pool_implementation: address\r\n    _new_pool_implementation: address\r\n\r\nevent UpdateTokenImplementation:\r\n    _old_token_implementation: address\r\n    _new_token_implementation: address\r\n\r\nevent TransferOwnership:\r\n    _old_owner: address\r\n    _new_owner: address\r\n\r\n\r\nstruct PoolArray:\r\n    token: address\r\n    coins: address[2]\r\n    decimals: uint256\r\n\r\n\r\nN_COINS: constant(int128) = 2\r\nA_MULTIPLIER: constant(uint256) = 10000\r\n\r\n# Limits\r\nMAX_ADMIN_FEE: constant(uint256) = 10 * 10 ** 9\r\nMIN_FEE: constant(uint256) = 5 * 10 ** 5  # 0.5 bps\r\nMAX_FEE: constant(uint256) = 10 * 10 ** 9\r\n\r\nMIN_GAMMA: constant(uint256) = 10 ** 10\r\nMAX_GAMMA: constant(uint256) = 2 * 10 ** 16\r\n\r\nMIN_A: constant(uint256) = N_COINS ** N_COINS * A_MULTIPLIER / 10\r\nMAX_A: constant(uint256) = N_COINS ** N_COINS * A_MULTIPLIER * 100000\r\n\r\n\r\nWETH: immutable(address)\r\n\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\n\r\n# fee receiver for plain pools\r\nfee_receiver: public(address)\r\n\r\npool_implementation: public(address)\r\ntoken_implementation: public(address)\r\n\r\n# mapping of coins -> pools for trading\r\n# a mapping key is generated for each pair of addresses via\r\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\r\nmarkets: HashMap[uint256, address[4294967296]]\r\nmarket_counts: HashMap[uint256, uint256]\r\n\r\npool_count: public(uint256)              # actual length of pool_list\r\npool_data: HashMap[address, PoolArray]\r\npool_list: public(address[4294967296])   # master list of pools\r\n\r\nget_pool_from_lp_token: public(HashMap[address, address])\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _fee_receiver: address,\r\n    _pool_implementation: address,\r\n    _token_implementation: address,\r\n    _weth: address\r\n):\r\n    self.fee_receiver = _fee_receiver\r\n    self.pool_implementation = _pool_implementation\r\n    self.token_implementation = _token_implementation\r\n\r\n    self.admin = msg.sender\r\n    WETH = _weth\r\n\r\n    log UpdateFeeReceiver(ZERO_ADDRESS, _fee_receiver)\r\n    log UpdatePoolImplementation(ZERO_ADDRESS, _pool_implementation)\r\n    log UpdateTokenImplementation(ZERO_ADDRESS, _token_implementation)\r\n    log TransferOwnership(ZERO_ADDRESS, msg.sender)\r\n\r\n\r\n# <--- Pool Deployers --->\r\n\r\n@external\r\ndef deploy_pool(\r\n    _name: String[32],\r\n    _symbol: String[32],\r\n    _coins: address[2],\r\n    A: uint256,\r\n    gamma: uint256,\r\n    mid_fee: uint256,\r\n    out_fee: uint256,\r\n    allowed_extra_profit: uint256,\r\n    fee_gamma: uint256,\r\n    adjustment_step: uint256,\r\n    admin_fee: uint256,\r\n    ma_half_time: uint256,\r\n    initial_price: uint256\r\n) -> address:\r\n    \"\"\"\r\n    @notice Deploy a new pool\r\n    @param _name Name of the new plain pool\r\n    @param _symbol Symbol for the new plain pool - will be concatenated with factory symbol\r\n    Other parameters need some description\r\n    @return Address of the deployed pool\r\n    \"\"\"\r\n    # Validate parameters\r\n    assert A > MIN_A-1\r\n    assert A < MAX_A+1\r\n    assert gamma > MIN_GAMMA-1\r\n    assert gamma < MAX_GAMMA+1\r\n    assert mid_fee > MIN_FEE-1\r\n    assert mid_fee < MAX_FEE-1\r\n    assert out_fee >= mid_fee\r\n    assert out_fee < MAX_FEE-1\r\n    assert admin_fee < 10**18+1\r\n    assert allowed_extra_profit < 10**16+1\r\n    assert fee_gamma < 10**18+1\r\n    assert fee_gamma > 0\r\n    assert adjustment_step < 10**18+1\r\n    assert adjustment_step > 0\r\n    assert ma_half_time < 7 * 86400\r\n    assert ma_half_time > 0\r\n    assert initial_price > 10**6\r\n    assert initial_price < 10**30\r\n    assert _coins[0] != _coins[1], \"Duplicate coins\"\r\n\r\n    decimals: uint256[2] = empty(uint256[2])\r\n    for i in range(2):\r\n        d: uint256 = ERC20(_coins[i]).decimals()\r\n        assert d < 19, \"Max 18 decimals for coins\"\r\n        decimals[i] = d\r\n    precisions: uint256 = (18 - decimals[0]) + shift(18 - decimals[1], 8)\r\n\r\n\r\n    name: String[64] = concat(\"Ellipsis.finance Crypto Pool: \", _name)\r\n\r\n    token: address = create_forwarder_to(self.token_implementation)\r\n    pool: address = create_forwarder_to(self.pool_implementation)\r\n\r\n    Token(token).initialize(name, _symbol, pool)\r\n    CryptoPool(pool).initialize(\r\n        A, gamma, mid_fee, out_fee, allowed_extra_profit, fee_gamma,\r\n        adjustment_step, admin_fee, ma_half_time, initial_price,\r\n        token, _coins, precisions)\r\n\r\n    length: uint256 = self.pool_count\r\n    self.pool_list[length] = pool\r\n    self.pool_count = length + 1\r\n    self.pool_data[pool].token = token\r\n    self.pool_data[pool].decimals = shift(decimals[0], 8) + decimals[1]\r\n    self.pool_data[pool].coins = _coins\r\n    self.get_pool_from_lp_token[token] = pool\r\n\r\n    key: uint256 = bitwise_xor(convert(_coins[0], uint256), convert(_coins[1], uint256))\r\n    length = self.market_counts[key]\r\n    self.markets[key][length] = pool\r\n    self.market_counts[key] = length + 1\r\n\r\n    log CryptoPoolDeployed(\r\n        pool, token, _coins,\r\n        A, gamma, mid_fee, out_fee, allowed_extra_profit, fee_gamma,\r\n        adjustment_step, admin_fee, ma_half_time, initial_price,\r\n        msg.sender)\r\n    return pool\r\n\r\n\r\n# <--- Admin / Guarded Functionality --->\r\n\r\n\r\n@external\r\ndef set_fee_receiver(_fee_receiver: address):\r\n    \"\"\"\r\n    @notice Set fee receiver\r\n    @param _fee_receiver Address that fees are sent to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    log UpdateFeeReceiver(self.fee_receiver, _fee_receiver)\r\n    self.fee_receiver = _fee_receiver\r\n\r\n\r\n@external\r\ndef set_pool_implementation(_pool_implementation: address):\r\n    \"\"\"\r\n    @notice Set pool implementation\r\n    @dev Set to ZERO_ADDRESS to prevent deployment of new pools\r\n    @param _pool_implementation Address of the new pool implementation\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    log UpdatePoolImplementation(self.pool_implementation, _pool_implementation)\r\n    self.pool_implementation = _pool_implementation\r\n\r\n\r\n@external\r\ndef set_token_implementation(_token_implementation: address):\r\n    \"\"\"\r\n    @notice Set token implementation\r\n    @dev Set to ZERO_ADDRESS to prevent deployment of new pools\r\n    @param _token_implementation Address of the new token implementation\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    log UpdateTokenImplementation(self.token_implementation, _token_implementation)\r\n    self.token_implementation = _token_implementation\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of this contract to `addr`\r\n    @param _addr Address of the new owner\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    self.future_admin = _addr\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    @dev Only callable by the new owner\r\n    \"\"\"\r\n    assert msg.sender == self.future_admin  # dev: future admin only\r\n\r\n    log TransferOwnership(self.admin, msg.sender)\r\n    self.admin = msg.sender\r\n\r\n\r\n# <--- Factory Getters --->\r\n\r\n\r\n@view\r\n@external\r\ndef get_market_count(_from: address, _to: address) -> uint256:\r\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\r\n    return self.market_counts[key]\r\n\r\n\r\n@view\r\n@external\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\r\n    return self.markets[key][i]\r\n\r\n\r\n# <--- Pool Getters --->\r\n\r\n\r\n@view\r\n@external\r\ndef get_coins(_pool: address) -> address[4]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    return [self.pool_data[_pool].coins[0], self.pool_data[_pool].coins[1], ZERO_ADDRESS, ZERO_ADDRESS]\r\n\r\n\r\n@view\r\n@external\r\ndef get_decimals(_pool: address) -> uint256[4]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    decimals: uint256 = self.pool_data[_pool].decimals\r\n    return [shift(decimals, -8), decimals % 256, 0, 0]\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances(_pool: address) -> uint256[4]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    return [CryptoPool(_pool).balances(0), CryptoPool(_pool).balances(1), 0, 0]\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (uint256, uint256, bool):\r\n    \"\"\"\r\n    @notice Convert coin addresses to indices for use with pool methods\r\n    @param _pool Pool address\r\n    @param _from Coin address to be used as `i` within a pool\r\n    @param _to Coin address to be used as `j` within a pool\r\n    @return uint256 `i`, uint256 `j`\r\n    \"\"\"\r\n    coins: address[2] = self.pool_data[_pool].coins\r\n\r\n    if _from == coins[0] and _to == coins[1]:\r\n        return 0, 1, False\r\n    elif _from == coins[1] and _to == coins[0]:\r\n        return 1, 0, False\r\n    else:\r\n        raise \"Coins not found\"\r\n\r\n\r\n@view\r\n@external\r\ndef get_eth_index(_pool: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the index of WETH for a pool\r\n    @dev Returns MAX_UINT256 if WETH is not a coin in the pool\r\n    \"\"\"\r\n    for i in range(2):\r\n        if self.pool_data[_pool].coins[i] == WETH:\r\n            return i\r\n    return MAX_UINT256\r\n\r\n\r\n@view\r\n@external\r\ndef get_lp_token(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Get the address of the LP token of a pool\r\n    \"\"\"\r\n    return self.pool_data[_pool].token\r\n\r\n\r\n# Compatibility getters (return nothing meaningful, included to work with the MetaRegistry)\r\n\r\n\r\n@view\r\n@external\r\ndef get_base_pool(_pool: address) -> address:\r\n    return ZERO_ADDRESS\r\n\r\n\r\n@view\r\n@external\r\ndef get_n_coins(_pool: address) -> uint256:\r\n    return 2\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_coins(_pool: address) -> address[4]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    return [self.pool_data[_pool].coins[0], self.pool_data[_pool].coins[1], ZERO_ADDRESS, ZERO_ADDRESS]\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_decimals(_pool: address) -> uint256[4]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    decimals: uint256 = self.pool_data[_pool].decimals\r\n    return [shift(decimals, -8), decimals % 256, 0, 0]\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_balances(_pool: address) -> uint256[4]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    return [CryptoPool(_pool).balances(0), CryptoPool(_pool).balances(1), 0, 0]\r\n\r\n\r\n@view\r\n@external\r\ndef is_meta(_pool: address) -> bool:\r\n    return False\r\n\r\n\r\n@view\r\n@external\r\ndef get_pool_asset_type(_pool: address) -> uint256:\r\n    return 4", "ABI": "[{\"name\":\"CryptoPoolDeployed\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"coins\",\"type\":\"address[2]\",\"indexed\":false},{\"name\":\"A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"admin_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_half_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_price\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"deployer\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFeeReceiver\",\"inputs\":[{\"name\":\"_old_fee_receiver\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_fee_receiver\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdatePoolImplementation\",\"inputs\":[{\"name\":\"_old_pool_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_pool_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateTokenImplementation\",\"inputs\":[{\"name\":\"_old_token_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_token_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"_old_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_fee_receiver\",\"type\":\"address\"},{\"name\":\"_pool_implementation\",\"type\":\"address\"},{\"name\":\"_token_implementation\",\"type\":\"address\"},{\"name\":\"_weth\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_pool\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coins\",\"type\":\"address[2]\"},{\"name\":\"A\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"mid_fee\",\"type\":\"uint256\"},{\"name\":\"out_fee\",\"type\":\"uint256\"},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"fee_gamma\",\"type\":\"uint256\"},{\"name\":\"adjustment_step\",\"type\":\"uint256\"},{\"name\":\"admin_fee\",\"type\":\"uint256\"},{\"name\":\"ma_half_time\",\"type\":\"uint256\"},{\"name\":\"initial_price\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_fee_receiver\",\"inputs\":[{\"name\":\"_fee_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_pool_implementation\",\"inputs\":[{\"name\":\"_pool_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_token_implementation\",\"inputs\":[{\"name\":\"_token_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_market_count\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[4]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_indices\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_eth_index\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_lp_token\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_base_pool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_n_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[4]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_meta\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_asset_type\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_from_lp_token\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.3", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000001bd9d93c074d64eafa2fbd8f11e11aa0a488ec560000000000000000000000001e97685aa5b1f9c6dc44af52a1bba8049f43226c00000000000000000000000019301e0a5cb34d0e665af745b1056d43926b9f99000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}