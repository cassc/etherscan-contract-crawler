{"SourceCode": "{\"LockpayStakingContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Owned.sol\\\";\\r\\n\\r\\nabstract contract ReentrancyGuard {\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    modifier nonReentrant() {\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ncontract LockpayStakingContract is Owned, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    uint256 private LockpayDecimals = 18;\\r\\n    address public LockPayV2Contract =\\r\\n        0xdCAC116fF1B4D3595E323a92902E85fBee1104bf;\\r\\n    address private LockpayStakeWallet;\\r\\n\\r\\n    struct Stake {\\r\\n        uint256 stakeOptionId;\\r\\n        uint256 startTS;\\r\\n        uint256 endTS;\\r\\n        uint256 amountStaked;\\r\\n        uint256 rewardAmountAtEnd;\\r\\n        uint256 counter;\\r\\n        bool claimed;\\r\\n        uint256 claimedTS;\\r\\n    }\\r\\n\\r\\n    struct Staker {\\r\\n        mapping (uint256 =\\u003e Stake) stakes;\\r\\n        bool isBlacklisted;\\r\\n        bool isDeclared;\\r\\n        uint256 stakeCounter;\\r\\n    }\\r\\n\\r\\n    struct StakeOption {\\r\\n        uint256 periodInSeconds;\\r\\n        bool isActive;\\r\\n        bool canStake;\\r\\n        bool canWithdraw;\\r\\n        bool isImportAllowed;\\r\\n        uint256 rewardMultiplicatorMilions;\\r\\n        uint256 totalTokensStaked;\\r\\n        uint256 activeTokensStaked;\\r\\n        uint256 totalTokensRewarded;\\r\\n        uint256 totalTokensClaimed;\\r\\n        uint256 activeStakers;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e Staker) private stakers;\\r\\n    mapping(uint256 =\\u003e StakeOption) public stakeOptions;\\r\\n    uint256 public stakeOptionsCounter = 0;\\r\\n\\r\\n    event STAKED(address indexed from, uint indexed counter, uint256 amount);\\r\\n    event CLAIMED(address indexed from, uint indexed counter, uint256 amount);\\r\\n\\r\\n    function STAKE(uint256 stakeOptionId, uint256 tokens)\\r\\n        external\\r\\n        nonReentrant\\r\\n        returns (bool)\\r\\n    {\\r\\n        require (!(stakers[msg.sender].isBlacklisted), \\\"you are blacklisted\\\");\\r\\n        require(tokens \\u003e 0, \\\"Stake amount should be correct\\\");\\r\\n        require(\\r\\n            stakeOptions[stakeOptionId].isActive \\u0026\\u0026\\r\\n                stakeOptions[stakeOptionId].canStake,\\r\\n            \\\"Stake option is not allowed to stake\\\"\\r\\n        );\\r\\n\\r\\n        \\r\\n        require(\\r\\n            IERC20(LockPayV2Contract).transferFrom(\\r\\n                msg.sender,\\r\\n                LockpayStakeWallet,\\r\\n                tokens\\r\\n            ),\\r\\n            \\\"Tokens cannot be transferred from user for locking\\\"\\r\\n        );\\r\\n\\r\\n        addStaker(stakeOptionId, msg.sender, tokens, block.timestamp);\\r\\n        emit STAKED(msg.sender, stakers[msg.sender].stakeCounter.sub(1), tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getStakerCounter(address addr) external view returns (uint256) {\\r\\n        return stakers[addr].stakeCounter;\\r\\n    }\\r\\n\\r\\n    function getStake(address addr, uint256 index) external view returns (Stake memory) {\\r\\n        return stakers[addr].stakes[index];\\r\\n    }\\r\\n\\r\\n    function addStaker(uint256 stakeOptionId, address addr, uint256 tokens, uint256 startPeriod) private {\\r\\n       \\r\\n        if(!stakers[addr].isDeclared) {\\r\\n            stakers[addr].isBlacklisted = false;\\r\\n            stakers[addr].isDeclared = true;\\r\\n            stakers[addr].stakeCounter = 0;\\r\\n        }\\r\\n        stakers[addr].stakes[stakers[addr].stakeCounter] = Stake({\\r\\n            stakeOptionId: stakeOptionId,\\r\\n            startTS: startPeriod,\\r\\n            endTS: startPeriod +\\r\\n                stakeOptions[stakeOptionId].periodInSeconds,\\r\\n            amountStaked: tokens,\\r\\n            rewardAmountAtEnd: tokens.mul(\\r\\n                stakeOptions[stakeOptionId].rewardMultiplicatorMilions\\r\\n            ).div(1000000),\\r\\n            claimed: false,\\r\\n            counter: stakers[addr].stakeCounter,\\r\\n            claimedTS: 0\\r\\n        });\\r\\n\\r\\n        stakers[addr].stakeCounter = stakers[addr].stakeCounter + 1;\\r\\n        stakeOptions[stakeOptionId].totalTokensStaked = stakeOptions[\\r\\n            stakeOptionId\\r\\n        ].totalTokensStaked.add(tokens);\\r\\n        stakeOptions[stakeOptionId].activeTokensStaked = stakeOptions[\\r\\n            stakeOptionId\\r\\n        ].activeTokensStaked.add(tokens);\\r\\n        stakeOptions[stakeOptionId].activeStakers = stakeOptions[stakeOptionId].activeStakers + 1;\\r\\n    }\\r\\n\\r\\n    function CLAIM(uint256 stakeId) external returns (bool) {\\r\\n        require (!(stakers[msg.sender].isBlacklisted), \\\"you are blacklisted\\\");\\r\\n        require(stakers[msg.sender].isDeclared, \\\"You are not staker\\\");\\r\\n        require(\\r\\n            stakers[msg.sender].stakes[stakeId].endTS \\u003c block.timestamp,\\r\\n            \\\"Stake Time is not over yet\\\"\\r\\n        );\\r\\n        require(\\r\\n            stakers[msg.sender].stakes[stakeId].claimed == false,\\r\\n            \\\"Already claimed\\\"\\r\\n        );\\r\\n\\r\\n        uint256 stakeOptionId = stakers[msg.sender]\\r\\n            .stakes[stakeId]\\r\\n            .stakeOptionId;\\r\\n\\r\\n        require(\\r\\n            stakeOptions[stakeOptionId].isActive \\u0026\\u0026\\r\\n                stakeOptions[stakeOptionId].canWithdraw,\\r\\n            \\\"Stake option is not allowed to stake\\\"\\r\\n        );\\r\\n\\r\\n        uint256 rewardAmount = stakers[msg.sender]\\r\\n            .stakes[stakeId]\\r\\n            .rewardAmountAtEnd;\\r\\n\\r\\n        require(\\r\\n            IERC20(LockPayV2Contract).transferFrom(\\r\\n                LockpayStakeWallet,\\r\\n                msg.sender,\\r\\n                rewardAmount\\r\\n            ),\\r\\n            \\\"Tokens cannot be transferred from user for locking\\\"\\r\\n        );\\r\\n\\r\\n        uint256 amountStaked = stakers[msg.sender].stakes[stakeId].amountStaked;\\r\\n\\r\\n        stakers[msg.sender].stakes[stakeId].claimed = true;\\r\\n        stakers[msg.sender].stakes[stakeId].claimedTS = block.timestamp;\\r\\n\\r\\n        stakeOptions[stakeOptionId].activeTokensStaked = stakeOptions[\\r\\n            stakeOptionId\\r\\n        ].activeTokensStaked.sub(amountStaked);\\r\\n        stakeOptions[stakeOptionId].totalTokensRewarded = stakeOptions[\\r\\n            stakeOptionId\\r\\n        ].totalTokensRewarded.add(rewardAmount).sub(amountStaked);\\r\\n        stakeOptions[stakeOptionId].totalTokensClaimed = stakeOptions[\\r\\n            stakeOptionId\\r\\n        ].totalTokensClaimed.add(rewardAmount);\\r\\n\\r\\n        stakeOptions[stakeOptionId].activeStakers = stakeOptions[stakeOptionId].activeStakers - 1;\\r\\n\\r\\n        emit CLAIMED(msg.sender, stakeId, rewardAmount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function addStakeOption( uint256 periodInSeconds, uint256 rewardMultiplicatorMilions) external onlyOwner {\\r\\n        stakeOptions[stakeOptionsCounter] = StakeOption({\\r\\n        periodInSeconds : periodInSeconds,\\r\\n        isActive: false,\\r\\n        canStake: false,\\r\\n        canWithdraw: false,\\r\\n        isImportAllowed: true,\\r\\n        rewardMultiplicatorMilions: rewardMultiplicatorMilions,\\r\\n        totalTokensStaked: 0,\\r\\n        activeTokensStaked: 0,\\r\\n        totalTokensRewarded: 0,\\r\\n        totalTokensClaimed:0,\\r\\n        activeStakers: 0\\r\\n        });\\r\\n        stakeOptionsCounter++;\\r\\n    }\\r\\n\\r\\n    function importStakers(uint256 stakeOptionId, address[] memory accounts, uint256[] memory startPeriods, uint256[] memory stakedTokens) external onlyOwner {\\r\\n        require(\\r\\n            stakeOptions[stakeOptionId].isImportAllowed,\\r\\n            \\\"Stake option is not allowed to stake\\\"\\r\\n        );\\r\\n        require (accounts.length \\u003e 0 \\u0026\\u0026 accounts.length == startPeriods.length \\u0026\\u0026 startPeriods.length == stakedTokens.length, \\\"Bad input data\\\");\\r\\n        for(uint256 i = 0; i \\u003c accounts.length; i++) {\\r\\n                addStaker(stakeOptionId, accounts[i], stakedTokens[i].mul(10 ** LockpayDecimals), startPeriods[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function blacklistStakers(address[] memory accounts, bool blacklisted) external onlyOwner {\\r\\n        for(uint256 i = 0; i \\u003c accounts.length; i++) {\\r\\n            stakers[accounts[i]].isBlacklisted = blacklisted;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setCanStake(uint256 stakeOptionId, bool newValue) external onlyOwner{\\r\\n        stakeOptions[stakeOptionId].canStake = newValue;\\r\\n    }\\r\\n    function setCanWithdraw(uint256 stakeOptionId, bool newValue) external onlyOwner{\\r\\n        stakeOptions[stakeOptionId].canWithdraw = newValue;\\r\\n    }\\r\\n\\r\\n    function activate(uint256 stakeOptionId) external onlyOwner{\\r\\n        stakeOptions[stakeOptionId].isActive = true;\\r\\n        stakeOptions[stakeOptionId].isImportAllowed = false;\\r\\n        stakeOptions[stakeOptionId].canStake = true;\\r\\n        stakeOptions[stakeOptionId].canWithdraw = true;\\r\\n    }\\r\\n\\r\\n    function setStakeWallet(address newValue) external onlyOwner{\\r\\n        LockpayStakeWallet = newValue;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8 \\u003c0.9.0;\\r\\n\\r\\ncontract Owned {\\r\\n    address private owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\r\\n\\r\\n    constructor() {\\r\\n        owner = payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        require(_newOwner != address(0), \\\"ERC20: sending to the zero address\\\");\\r\\n        owner = _newOwner;\\r\\n        emit OwnershipTransferred(msg.sender, _newOwner);\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8 \\u003c0.9.0;\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) \\u003c\\u003c 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) \\u003c\\u003c 255);\\r\\n\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n        require(c != MIN_INT256 || (a \\u0026 MIN_INT256) != (b \\u0026 MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n \\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n  \\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a \\u003c 0 ? -a : a;\\r\\n    }\\r\\n\\r\\n\\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a \\u003e= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity \\u003e=0.8 \\u003c0.9.0;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity \\u003e=0.8 \\u003c0.9.0;\\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b \\u003e= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\\r\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CLAIMED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"STAKED\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"}],\"name\":\"CLAIM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LockPayV2Contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeOptionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"STAKE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeOptionId\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardMultiplicatorMilions\",\"type\":\"uint256\"}],\"name\":\"addStakeOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"name\":\"blacklistStakers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeOptionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmountAtEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimedTS\",\"type\":\"uint256\"}],\"internalType\":\"struct LockpayStakingContract.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getStakerCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeOptionId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startPeriods\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakedTokens\",\"type\":\"uint256[]\"}],\"name\":\"importStakers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeOptionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"setCanStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeOptionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"setCanWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setStakeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"periodInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canWithdraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isImportAllowed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rewardMultiplicatorMilions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokensStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeTokensStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokensRewarded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokensClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeStakers\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeOptionsCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LockpayStakingContract", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0b71457b16312074acdf353c1bd6f4dd8174298e5f8080716de300071fdb8c1b"}