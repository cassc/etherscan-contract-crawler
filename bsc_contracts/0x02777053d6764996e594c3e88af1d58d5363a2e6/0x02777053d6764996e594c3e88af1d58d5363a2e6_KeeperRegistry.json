{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v0.8/KeeperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./KeeperBase.sol\\\";\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"./interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/KeeperCompatibleInterface.sol\\\";\\nimport \\\"./interfaces/KeeperRegistryInterface.sol\\\";\\nimport \\\"./interfaces/MigratableKeeperRegistryInterface.sol\\\";\\nimport \\\"./interfaces/UpkeepTranscoderInterface.sol\\\";\\nimport \\\"./interfaces/ERC677ReceiverInterface.sol\\\";\\n\\n/**\\n * @notice Registry for adding work for Chainlink Keepers to perform on client\\n * contracts. Clients must support the Upkeep interface.\\n */\\ncontract KeeperRegistry is\\n  TypeAndVersionInterface,\\n  ConfirmedOwner,\\n  KeeperBase,\\n  ReentrancyGuard,\\n  Pausable,\\n  KeeperRegistryExecutableInterface,\\n  MigratableKeeperRegistryInterface,\\n  ERC677ReceiverInterface\\n{\\n  using Address for address;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n\\n  address private constant ZERO_ADDRESS = address(0);\\n  address private constant IGNORE_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\\n  bytes4 private constant CHECK_SELECTOR = KeeperCompatibleInterface.checkUpkeep.selector;\\n  bytes4 private constant PERFORM_SELECTOR = KeeperCompatibleInterface.performUpkeep.selector;\\n  uint256 private constant PERFORM_GAS_MIN = 2_300;\\n  uint256 private constant CANCELATION_DELAY = 50;\\n  uint256 private constant PERFORM_GAS_CUSHION = 5_000;\\n  uint256 private constant REGISTRY_GAS_OVERHEAD = 80_000;\\n  uint256 private constant PPB_BASE = 1_000_000_000;\\n  uint64 private constant UINT64_MAX = 2**64 - 1;\\n  uint96 private constant LINK_TOTAL_SUPPLY = 1e27;\\n\\n  address[] private s_keeperList;\\n  EnumerableSet.UintSet private s_upkeepIDs;\\n  mapping(uint256 => Upkeep) private s_upkeep;\\n  mapping(address => KeeperInfo) private s_keeperInfo;\\n  mapping(address => address) private s_proposedPayee;\\n  mapping(uint256 => bytes) private s_checkData;\\n  mapping(address => MigrationPermission) private s_peerRegistryMigrationPermission;\\n  Storage private s_storage;\\n  uint256 private s_fallbackGasPrice; // not in config object for gas savings\\n  uint256 private s_fallbackLinkPrice; // not in config object for gas savings\\n  uint96 private s_ownerLinkBalance;\\n  uint256 private s_expectedLinkBalance;\\n  address private s_transcoder;\\n  address private s_registrar;\\n\\n  LinkTokenInterface public immutable LINK;\\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\\n  AggregatorV3Interface public immutable FAST_GAS_FEED;\\n\\n  /**\\n   * @notice versions:\\n   * - KeeperRegistry 1.2.0: allow funding within performUpkeep\\n   *                       : allow configurable registry maxPerformGas\\n   *                       : add function to let admin change upkeep gas limit\\n   *                       : add minUpkeepSpend requirement\\n                           : upgrade to solidity v0.8\\n   * - KeeperRegistry 1.1.0: added flatFeeMicroLink\\n   * - KeeperRegistry 1.0.0: initial release\\n   */\\n  string public constant override typeAndVersion = \\\"KeeperRegistry 1.2.0\\\";\\n\\n  error CannotCancel();\\n  error UpkeepNotActive();\\n  error MigrationNotPermitted();\\n  error UpkeepNotCanceled();\\n  error UpkeepNotNeeded();\\n  error NotAContract();\\n  error PaymentGreaterThanAllLINK();\\n  error OnlyActiveKeepers();\\n  error InsufficientFunds();\\n  error KeepersMustTakeTurns();\\n  error ParameterLengthError();\\n  error OnlyCallableByOwnerOrAdmin();\\n  error OnlyCallableByLINKToken();\\n  error InvalidPayee();\\n  error DuplicateEntry();\\n  error ValueNotChanged();\\n  error IndexOutOfRange();\\n  error TranscoderNotSet();\\n  error ArrayHasNoEntries();\\n  error GasLimitOutsideRange();\\n  error OnlyCallableByPayee();\\n  error OnlyCallableByProposedPayee();\\n  error GasLimitCanOnlyIncrease();\\n  error OnlyCallableByAdmin();\\n  error OnlyCallableByOwnerOrRegistrar();\\n  error InvalidRecipient();\\n  error InvalidDataLength();\\n  error TargetCheckReverted(bytes reason);\\n\\n  enum MigrationPermission {\\n    NONE,\\n    OUTGOING,\\n    INCOMING,\\n    BIDIRECTIONAL\\n  }\\n\\n  /**\\n   * @notice storage of the registry, contains a mix of config and state data\\n   */\\n  struct Storage {\\n    uint32 paymentPremiumPPB;\\n    uint32 flatFeeMicroLink;\\n    uint24 blockCountPerTurn;\\n    uint32 checkGasLimit;\\n    uint24 stalenessSeconds;\\n    uint16 gasCeilingMultiplier;\\n    uint96 minUpkeepSpend; // 1 evm word\\n    uint32 maxPerformGas;\\n    uint32 nonce; // 2 evm words\\n  }\\n\\n  struct Upkeep {\\n    uint96 balance;\\n    address lastKeeper; // 1 storage slot full\\n    uint32 executeGas;\\n    uint64 maxValidBlocknumber;\\n    address target; // 2 storage slots full\\n    uint96 amountSpent;\\n    address admin; // 3 storage slots full\\n  }\\n\\n  struct KeeperInfo {\\n    address payee;\\n    uint96 balance;\\n    bool active;\\n  }\\n\\n  struct PerformParams {\\n    address from;\\n    uint256 id;\\n    bytes performData;\\n    uint256 maxLinkPayment;\\n    uint256 gasLimit;\\n    uint256 adjustedGasWei;\\n    uint256 linkEth;\\n  }\\n\\n  event UpkeepRegistered(uint256 indexed id, uint32 executeGas, address admin);\\n  event UpkeepPerformed(\\n    uint256 indexed id,\\n    bool indexed success,\\n    address indexed from,\\n    uint96 payment,\\n    bytes performData\\n  );\\n  event UpkeepCanceled(uint256 indexed id, uint64 indexed atBlockHeight);\\n  event FundsAdded(uint256 indexed id, address indexed from, uint96 amount);\\n  event FundsWithdrawn(uint256 indexed id, uint256 amount, address to);\\n  event OwnerFundsWithdrawn(uint96 amount);\\n  event UpkeepMigrated(uint256 indexed id, uint256 remainingBalance, address destination);\\n  event UpkeepReceived(uint256 indexed id, uint256 startingBalance, address importedFrom);\\n  event ConfigSet(Config config);\\n  event KeepersUpdated(address[] keepers, address[] payees);\\n  event PaymentWithdrawn(address indexed keeper, uint256 indexed amount, address indexed to, address payee);\\n  event PayeeshipTransferRequested(address indexed keeper, address indexed from, address indexed to);\\n  event PayeeshipTransferred(address indexed keeper, address indexed from, address indexed to);\\n  event UpkeepGasLimitSet(uint256 indexed id, uint96 gasLimit);\\n\\n  /**\\n   * @param link address of the LINK Token\\n   * @param linkEthFeed address of the LINK/ETH price feed\\n   * @param fastGasFeed address of the Fast Gas price feed\\n   * @param config registry config settings\\n   */\\n  constructor(\\n    address link,\\n    address linkEthFeed,\\n    address fastGasFeed,\\n    Config memory config\\n  ) ConfirmedOwner(msg.sender) {\\n    LINK = LinkTokenInterface(link);\\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\\n    FAST_GAS_FEED = AggregatorV3Interface(fastGasFeed);\\n    setConfig(config);\\n  }\\n\\n  // ACTIONS\\n\\n  /**\\n   * @notice adds a new upkeep\\n   * @param target address to perform upkeep on\\n   * @param gasLimit amount of gas to provide the target contract when\\n   * performing upkeep\\n   * @param admin address to cancel upkeep and withdraw remaining funds\\n   * @param checkData data passed to the contract when checking for upkeep\\n   */\\n  function registerUpkeep(\\n    address target,\\n    uint32 gasLimit,\\n    address admin,\\n    bytes calldata checkData\\n  ) external override onlyOwnerOrRegistrar returns (uint256 id) {\\n    id = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), address(this), s_storage.nonce)));\\n    _createUpkeep(id, target, gasLimit, admin, 0, checkData);\\n    s_storage.nonce++;\\n    emit UpkeepRegistered(id, gasLimit, admin);\\n    return id;\\n  }\\n\\n  /**\\n   * @notice simulated by keepers via eth_call to see if the upkeep needs to be\\n   * performed. If upkeep is needed, the call then simulates performUpkeep\\n   * to make sure it succeeds. Finally, it returns the success status along with\\n   * payment information and the perform data payload.\\n   * @param id identifier of the upkeep to check\\n   * @param from the address to simulate performing the upkeep from\\n   */\\n  function checkUpkeep(uint256 id, address from)\\n    external\\n    override\\n    cannotExecute\\n    returns (\\n      bytes memory performData,\\n      uint256 maxLinkPayment,\\n      uint256 gasLimit,\\n      uint256 adjustedGasWei,\\n      uint256 linkEth\\n    )\\n  {\\n    Upkeep memory upkeep = s_upkeep[id];\\n\\n    bytes memory callData = abi.encodeWithSelector(CHECK_SELECTOR, s_checkData[id]);\\n    (bool success, bytes memory result) = upkeep.target.call{gas: s_storage.checkGasLimit}(callData);\\n\\n    if (!success) revert TargetCheckReverted(result);\\n\\n    (success, performData) = abi.decode(result, (bool, bytes));\\n    if (!success) revert UpkeepNotNeeded();\\n\\n    PerformParams memory params = _generatePerformParams(from, id, performData, false);\\n    _prePerformUpkeep(upkeep, params.from, params.maxLinkPayment);\\n\\n    return (performData, params.maxLinkPayment, params.gasLimit, params.adjustedGasWei, params.linkEth);\\n  }\\n\\n  /**\\n   * @notice executes the upkeep with the perform data returned from\\n   * checkUpkeep, validates the keeper's permissions, and pays the keeper.\\n   * @param id identifier of the upkeep to execute the data with.\\n   * @param performData calldata parameter to be passed to the target upkeep.\\n   */\\n  function performUpkeep(uint256 id, bytes calldata performData)\\n    external\\n    override\\n    whenNotPaused\\n    returns (bool success)\\n  {\\n    return _performUpkeepWithParams(_generatePerformParams(msg.sender, id, performData, true));\\n  }\\n\\n  /**\\n   * @notice prevent an upkeep from being performed in the future\\n   * @param id upkeep to be canceled\\n   */\\n  function cancelUpkeep(uint256 id) external override {\\n    uint64 maxValid = s_upkeep[id].maxValidBlocknumber;\\n    bool canceled = maxValid != UINT64_MAX;\\n    bool isOwner = msg.sender == owner();\\n\\n    if (canceled && !(isOwner && maxValid > block.number)) revert CannotCancel();\\n    if (!isOwner && msg.sender != s_upkeep[id].admin) revert OnlyCallableByOwnerOrAdmin();\\n\\n    uint256 height = block.number;\\n    if (!isOwner) {\\n      height = height + CANCELATION_DELAY;\\n    }\\n    s_upkeep[id].maxValidBlocknumber = uint64(height);\\n    s_upkeepIDs.remove(id);\\n\\n    emit UpkeepCanceled(id, uint64(height));\\n  }\\n\\n  /**\\n   * @notice adds LINK funding for an upkeep by transferring from the sender's\\n   * LINK balance\\n   * @param id upkeep to fund\\n   * @param amount number of LINK to transfer\\n   */\\n  function addFunds(uint256 id, uint96 amount) external override onlyActiveUpkeep(id) {\\n    s_upkeep[id].balance = s_upkeep[id].balance + amount;\\n    s_expectedLinkBalance = s_expectedLinkBalance + amount;\\n    LINK.transferFrom(msg.sender, address(this), amount);\\n    emit FundsAdded(id, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice uses LINK's transferAndCall to LINK and add funding to an upkeep\\n   * @dev safe to cast uint256 to uint96 as total LINK supply is under UINT96MAX\\n   * @param sender the account which transferred the funds\\n   * @param amount number of LINK transfer\\n   */\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external {\\n    if (msg.sender != address(LINK)) revert OnlyCallableByLINKToken();\\n    if (data.length != 32) revert InvalidDataLength();\\n    uint256 id = abi.decode(data, (uint256));\\n    if (s_upkeep[id].maxValidBlocknumber != UINT64_MAX) revert UpkeepNotActive();\\n\\n    s_upkeep[id].balance = s_upkeep[id].balance + uint96(amount);\\n    s_expectedLinkBalance = s_expectedLinkBalance + amount;\\n\\n    emit FundsAdded(id, sender, uint96(amount));\\n  }\\n\\n  /**\\n   * @notice removes funding from a canceled upkeep\\n   * @param id upkeep to withdraw funds from\\n   * @param to destination address for sending remaining funds\\n   */\\n  function withdrawFunds(uint256 id, address to) external validRecipient(to) onlyUpkeepAdmin(id) {\\n    if (s_upkeep[id].maxValidBlocknumber > block.number) revert UpkeepNotCanceled();\\n\\n    uint96 minUpkeepSpend = s_storage.minUpkeepSpend;\\n    uint96 amountLeft = s_upkeep[id].balance;\\n    uint96 amountSpent = s_upkeep[id].amountSpent;\\n\\n    uint96 cancellationFee = 0;\\n    // cancellationFee is supposed to be min(max(minUpkeepSpend - amountSpent,0), amountLeft)\\n    if (amountSpent < minUpkeepSpend) {\\n      cancellationFee = minUpkeepSpend - amountSpent;\\n      if (cancellationFee > amountLeft) {\\n        cancellationFee = amountLeft;\\n      }\\n    }\\n    uint96 amountToWithdraw = amountLeft - cancellationFee;\\n\\n    s_upkeep[id].balance = 0;\\n    s_ownerLinkBalance = s_ownerLinkBalance + cancellationFee;\\n\\n    s_expectedLinkBalance = s_expectedLinkBalance - amountToWithdraw;\\n    emit FundsWithdrawn(id, amountToWithdraw, to);\\n\\n    LINK.transfer(to, amountToWithdraw);\\n  }\\n\\n  /**\\n   * @notice withdraws LINK funds collected through cancellation fees\\n   */\\n  function withdrawOwnerFunds() external onlyOwner {\\n    uint96 amount = s_ownerLinkBalance;\\n\\n    s_expectedLinkBalance = s_expectedLinkBalance - amount;\\n    s_ownerLinkBalance = 0;\\n\\n    emit OwnerFundsWithdrawn(amount);\\n    LINK.transfer(msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice allows the admin of an upkeep to modify gas limit\\n   * @param id upkeep to be change the gas limit for\\n   * @param gasLimit new gas limit for the upkeep\\n   */\\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external override onlyActiveUpkeep(id) onlyUpkeepAdmin(id) {\\n    if (gasLimit < PERFORM_GAS_MIN || gasLimit > s_storage.maxPerformGas) revert GasLimitOutsideRange();\\n\\n    s_upkeep[id].executeGas = gasLimit;\\n\\n    emit UpkeepGasLimitSet(id, gasLimit);\\n  }\\n\\n  /**\\n   * @notice recovers LINK funds improperly transferred to the registry\\n   * @dev In principle this function\u2019s execution cost could exceed block\\n   * gas limit. However, in our anticipated deployment, the number of upkeeps and\\n   * keepers will be low enough to avoid this problem.\\n   */\\n  function recoverFunds() external onlyOwner {\\n    uint256 total = LINK.balanceOf(address(this));\\n    LINK.transfer(msg.sender, total - s_expectedLinkBalance);\\n  }\\n\\n  /**\\n   * @notice withdraws a keeper's payment, callable only by the keeper's payee\\n   * @param from keeper address\\n   * @param to address to send the payment to\\n   */\\n  function withdrawPayment(address from, address to) external validRecipient(to) {\\n    KeeperInfo memory keeper = s_keeperInfo[from];\\n    if (keeper.payee != msg.sender) revert OnlyCallableByPayee();\\n\\n    s_keeperInfo[from].balance = 0;\\n    s_expectedLinkBalance = s_expectedLinkBalance - keeper.balance;\\n    emit PaymentWithdrawn(from, keeper.balance, to, msg.sender);\\n\\n    LINK.transfer(to, keeper.balance);\\n  }\\n\\n  /**\\n   * @notice proposes the safe transfer of a keeper's payee to another address\\n   * @param keeper address of the keeper to transfer payee role\\n   * @param proposed address to nominate for next payeeship\\n   */\\n  function transferPayeeship(address keeper, address proposed) external {\\n    if (s_keeperInfo[keeper].payee != msg.sender) revert OnlyCallableByPayee();\\n    if (proposed == msg.sender) revert ValueNotChanged();\\n\\n    if (s_proposedPayee[keeper] != proposed) {\\n      s_proposedPayee[keeper] = proposed;\\n      emit PayeeshipTransferRequested(keeper, msg.sender, proposed);\\n    }\\n  }\\n\\n  /**\\n   * @notice accepts the safe transfer of payee role for a keeper\\n   * @param keeper address to accept the payee role for\\n   */\\n  function acceptPayeeship(address keeper) external {\\n    if (s_proposedPayee[keeper] != msg.sender) revert OnlyCallableByProposedPayee();\\n    address past = s_keeperInfo[keeper].payee;\\n    s_keeperInfo[keeper].payee = msg.sender;\\n    s_proposedPayee[keeper] = ZERO_ADDRESS;\\n\\n    emit PayeeshipTransferred(keeper, past, msg.sender);\\n  }\\n\\n  /**\\n   * @notice signals to keepers that they should not perform upkeeps until the\\n   * contract has been unpaused\\n   */\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  /**\\n   * @notice signals to keepers that they can perform upkeeps once again after\\n   * having been paused\\n   */\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  // SETTERS\\n\\n  /**\\n   * @notice updates the configuration of the registry\\n   * @param config registry config fields\\n   */\\n  function setConfig(Config memory config) public onlyOwner {\\n    if (config.maxPerformGas < s_storage.maxPerformGas) revert GasLimitCanOnlyIncrease();\\n    s_storage = Storage({\\n      paymentPremiumPPB: config.paymentPremiumPPB,\\n      flatFeeMicroLink: config.flatFeeMicroLink,\\n      blockCountPerTurn: config.blockCountPerTurn,\\n      checkGasLimit: config.checkGasLimit,\\n      stalenessSeconds: config.stalenessSeconds,\\n      gasCeilingMultiplier: config.gasCeilingMultiplier,\\n      minUpkeepSpend: config.minUpkeepSpend,\\n      maxPerformGas: config.maxPerformGas,\\n      nonce: s_storage.nonce\\n    });\\n    s_fallbackGasPrice = config.fallbackGasPrice;\\n    s_fallbackLinkPrice = config.fallbackLinkPrice;\\n    s_transcoder = config.transcoder;\\n    s_registrar = config.registrar;\\n    emit ConfigSet(config);\\n  }\\n\\n  /**\\n   * @notice update the list of keepers allowed to perform upkeep\\n   * @param keepers list of addresses allowed to perform upkeep\\n   * @param payees addresses corresponding to keepers who are allowed to\\n   * move payments which have been accrued\\n   */\\n  function setKeepers(address[] calldata keepers, address[] calldata payees) external onlyOwner {\\n    if (keepers.length != payees.length || keepers.length < 2) revert ParameterLengthError();\\n    for (uint256 i = 0; i < s_keeperList.length; i++) {\\n      address keeper = s_keeperList[i];\\n      s_keeperInfo[keeper].active = false;\\n    }\\n    for (uint256 i = 0; i < keepers.length; i++) {\\n      address keeper = keepers[i];\\n      KeeperInfo storage s_keeper = s_keeperInfo[keeper];\\n      address oldPayee = s_keeper.payee;\\n      address newPayee = payees[i];\\n      if (\\n        (newPayee == ZERO_ADDRESS) || (oldPayee != ZERO_ADDRESS && oldPayee != newPayee && newPayee != IGNORE_ADDRESS)\\n      ) revert InvalidPayee();\\n      if (s_keeper.active) revert DuplicateEntry();\\n      s_keeper.active = true;\\n      if (newPayee != IGNORE_ADDRESS) {\\n        s_keeper.payee = newPayee;\\n      }\\n    }\\n    s_keeperList = keepers;\\n    emit KeepersUpdated(keepers, payees);\\n  }\\n\\n  // GETTERS\\n\\n  /**\\n   * @notice read all of the details about an upkeep\\n   */\\n  function getUpkeep(uint256 id)\\n    external\\n    view\\n    override\\n    returns (\\n      address target,\\n      uint32 executeGas,\\n      bytes memory checkData,\\n      uint96 balance,\\n      address lastKeeper,\\n      address admin,\\n      uint64 maxValidBlocknumber,\\n      uint96 amountSpent\\n    )\\n  {\\n    Upkeep memory reg = s_upkeep[id];\\n    return (\\n      reg.target,\\n      reg.executeGas,\\n      s_checkData[id],\\n      reg.balance,\\n      reg.lastKeeper,\\n      reg.admin,\\n      reg.maxValidBlocknumber,\\n      reg.amountSpent\\n    );\\n  }\\n\\n  /**\\n   * @notice retrieve active upkeep IDs\\n   * @param startIndex starting index in list\\n   * @param maxCount max count to retrieve (0 = unlimited)\\n   * @dev the order of IDs in the list is **not guaranteed**, therefore, if making successive calls, one\\n   * should consider keeping the blockheight constant to ensure a wholistic picture of the contract state\\n   */\\n  function getActiveUpkeepIDs(uint256 startIndex, uint256 maxCount) external view override returns (uint256[] memory) {\\n    uint256 maxIdx = s_upkeepIDs.length();\\n    if (startIndex >= maxIdx) revert IndexOutOfRange();\\n    if (maxCount == 0) {\\n      maxCount = maxIdx - startIndex;\\n    }\\n    uint256[] memory ids = new uint256[](maxCount);\\n    for (uint256 idx = 0; idx < maxCount; idx++) {\\n      ids[idx] = s_upkeepIDs.at(startIndex + idx);\\n    }\\n    return ids;\\n  }\\n\\n  /**\\n   * @notice read the current info about any keeper address\\n   */\\n  function getKeeperInfo(address query)\\n    external\\n    view\\n    override\\n    returns (\\n      address payee,\\n      bool active,\\n      uint96 balance\\n    )\\n  {\\n    KeeperInfo memory keeper = s_keeperInfo[query];\\n    return (keeper.payee, keeper.active, keeper.balance);\\n  }\\n\\n  /**\\n   * @notice read the current state of the registry\\n   */\\n  function getState()\\n    external\\n    view\\n    override\\n    returns (\\n      State memory state,\\n      Config memory config,\\n      address[] memory keepers\\n    )\\n  {\\n    Storage memory store = s_storage;\\n    state.nonce = store.nonce;\\n    state.ownerLinkBalance = s_ownerLinkBalance;\\n    state.expectedLinkBalance = s_expectedLinkBalance;\\n    state.numUpkeeps = s_upkeepIDs.length();\\n    config.paymentPremiumPPB = store.paymentPremiumPPB;\\n    config.flatFeeMicroLink = store.flatFeeMicroLink;\\n    config.blockCountPerTurn = store.blockCountPerTurn;\\n    config.checkGasLimit = store.checkGasLimit;\\n    config.stalenessSeconds = store.stalenessSeconds;\\n    config.gasCeilingMultiplier = store.gasCeilingMultiplier;\\n    config.minUpkeepSpend = store.minUpkeepSpend;\\n    config.maxPerformGas = store.maxPerformGas;\\n    config.fallbackGasPrice = s_fallbackGasPrice;\\n    config.fallbackLinkPrice = s_fallbackLinkPrice;\\n    config.transcoder = s_transcoder;\\n    config.registrar = s_registrar;\\n    return (state, config, s_keeperList);\\n  }\\n\\n  /**\\n   * @notice calculates the minimum balance required for an upkeep to remain eligible\\n   * @param id the upkeep id to calculate minimum balance for\\n   */\\n  function getMinBalanceForUpkeep(uint256 id) external view returns (uint96 minBalance) {\\n    return getMaxPaymentForGas(s_upkeep[id].executeGas);\\n  }\\n\\n  /**\\n   * @notice calculates the maximum payment for a given gas limit\\n   * @param gasLimit the gas to calculate payment for\\n   */\\n  function getMaxPaymentForGas(uint256 gasLimit) public view returns (uint96 maxPayment) {\\n    (uint256 gasWei, uint256 linkEth) = _getFeedData();\\n    uint256 adjustedGasWei = _adjustGasPrice(gasWei, false);\\n    return _calculatePaymentAmount(gasLimit, adjustedGasWei, linkEth);\\n  }\\n\\n  /**\\n   * @notice retrieves the migration permission for a peer registry\\n   */\\n  function getPeerRegistryMigrationPermission(address peer) external view returns (MigrationPermission) {\\n    return s_peerRegistryMigrationPermission[peer];\\n  }\\n\\n  /**\\n   * @notice sets the peer registry migration permission\\n   */\\n  function setPeerRegistryMigrationPermission(address peer, MigrationPermission permission) external onlyOwner {\\n    s_peerRegistryMigrationPermission[peer] = permission;\\n  }\\n\\n  /**\\n   * @inheritdoc MigratableKeeperRegistryInterface\\n   */\\n  function migrateUpkeeps(uint256[] calldata ids, address destination) external override {\\n    if (\\n      s_peerRegistryMigrationPermission[destination] != MigrationPermission.OUTGOING &&\\n      s_peerRegistryMigrationPermission[destination] != MigrationPermission.BIDIRECTIONAL\\n    ) revert MigrationNotPermitted();\\n    if (s_transcoder == ZERO_ADDRESS) revert TranscoderNotSet();\\n    if (ids.length == 0) revert ArrayHasNoEntries();\\n    uint256 id;\\n    Upkeep memory upkeep;\\n    uint256 totalBalanceRemaining;\\n    bytes[] memory checkDatas = new bytes[](ids.length);\\n    Upkeep[] memory upkeeps = new Upkeep[](ids.length);\\n    for (uint256 idx = 0; idx < ids.length; idx++) {\\n      id = ids[idx];\\n      upkeep = s_upkeep[id];\\n      if (upkeep.admin != msg.sender) revert OnlyCallableByAdmin();\\n      if (upkeep.maxValidBlocknumber != UINT64_MAX) revert UpkeepNotActive();\\n      upkeeps[idx] = upkeep;\\n      checkDatas[idx] = s_checkData[id];\\n      totalBalanceRemaining = totalBalanceRemaining + upkeep.balance;\\n      delete s_upkeep[id];\\n      delete s_checkData[id];\\n      s_upkeepIDs.remove(id);\\n      emit UpkeepMigrated(id, upkeep.balance, destination);\\n    }\\n    s_expectedLinkBalance = s_expectedLinkBalance - totalBalanceRemaining;\\n    bytes memory encodedUpkeeps = abi.encode(ids, upkeeps, checkDatas);\\n    MigratableKeeperRegistryInterface(destination).receiveUpkeeps(\\n      UpkeepTranscoderInterface(s_transcoder).transcodeUpkeeps(\\n        UpkeepFormat.V1,\\n        MigratableKeeperRegistryInterface(destination).upkeepTranscoderVersion(),\\n        encodedUpkeeps\\n      )\\n    );\\n    LINK.transfer(destination, totalBalanceRemaining);\\n  }\\n\\n  /**\\n   * @inheritdoc MigratableKeeperRegistryInterface\\n   */\\n  UpkeepFormat public constant upkeepTranscoderVersion = UpkeepFormat.V1;\\n\\n  /**\\n   * @inheritdoc MigratableKeeperRegistryInterface\\n   */\\n  function receiveUpkeeps(bytes calldata encodedUpkeeps) external override {\\n    if (\\n      s_peerRegistryMigrationPermission[msg.sender] != MigrationPermission.INCOMING &&\\n      s_peerRegistryMigrationPermission[msg.sender] != MigrationPermission.BIDIRECTIONAL\\n    ) revert MigrationNotPermitted();\\n    (uint256[] memory ids, Upkeep[] memory upkeeps, bytes[] memory checkDatas) = abi.decode(\\n      encodedUpkeeps,\\n      (uint256[], Upkeep[], bytes[])\\n    );\\n    for (uint256 idx = 0; idx < ids.length; idx++) {\\n      _createUpkeep(\\n        ids[idx],\\n        upkeeps[idx].target,\\n        upkeeps[idx].executeGas,\\n        upkeeps[idx].admin,\\n        upkeeps[idx].balance,\\n        checkDatas[idx]\\n      );\\n      emit UpkeepReceived(ids[idx], upkeeps[idx].balance, msg.sender);\\n    }\\n  }\\n\\n  /**\\n   * @notice creates a new upkeep with the given fields\\n   * @param target address to perform upkeep on\\n   * @param gasLimit amount of gas to provide the target contract when\\n   * performing upkeep\\n   * @param admin address to cancel upkeep and withdraw remaining funds\\n   * @param checkData data passed to the contract when checking for upkeep\\n   */\\n  function _createUpkeep(\\n    uint256 id,\\n    address target,\\n    uint32 gasLimit,\\n    address admin,\\n    uint96 balance,\\n    bytes memory checkData\\n  ) internal whenNotPaused {\\n    if (!target.isContract()) revert NotAContract();\\n    if (gasLimit < PERFORM_GAS_MIN || gasLimit > s_storage.maxPerformGas) revert GasLimitOutsideRange();\\n    s_upkeep[id] = Upkeep({\\n      target: target,\\n      executeGas: gasLimit,\\n      balance: balance,\\n      admin: admin,\\n      maxValidBlocknumber: UINT64_MAX,\\n      lastKeeper: ZERO_ADDRESS,\\n      amountSpent: 0\\n    });\\n    s_expectedLinkBalance = s_expectedLinkBalance + balance;\\n    s_checkData[id] = checkData;\\n    s_upkeepIDs.add(id);\\n  }\\n\\n  /**\\n   * @dev retrieves feed data for fast gas/eth and link/eth prices. if the feed\\n   * data is stale it uses the configured fallback price. Once a price is picked\\n   * for gas it takes the min of gas price in the transaction or the fast gas\\n   * price in order to reduce costs for the upkeep clients.\\n   */\\n  function _getFeedData() private view returns (uint256 gasWei, uint256 linkEth) {\\n    uint32 stalenessSeconds = s_storage.stalenessSeconds;\\n    bool staleFallback = stalenessSeconds > 0;\\n    uint256 timestamp;\\n    int256 feedValue;\\n    (, feedValue, , timestamp, ) = FAST_GAS_FEED.latestRoundData();\\n    if ((staleFallback && stalenessSeconds < block.timestamp - timestamp) || feedValue <= 0) {\\n      gasWei = s_fallbackGasPrice;\\n    } else {\\n      gasWei = uint256(feedValue);\\n    }\\n    (, feedValue, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\\n    if ((staleFallback && stalenessSeconds < block.timestamp - timestamp) || feedValue <= 0) {\\n      linkEth = s_fallbackLinkPrice;\\n    } else {\\n      linkEth = uint256(feedValue);\\n    }\\n    return (gasWei, linkEth);\\n  }\\n\\n  /**\\n   * @dev calculates LINK paid for gas spent plus a configure premium percentage\\n   */\\n  function _calculatePaymentAmount(\\n    uint256 gasLimit,\\n    uint256 gasWei,\\n    uint256 linkEth\\n  ) private view returns (uint96 payment) {\\n    uint256 weiForGas = gasWei * (gasLimit + REGISTRY_GAS_OVERHEAD);\\n    uint256 premium = PPB_BASE + s_storage.paymentPremiumPPB;\\n    uint256 total = ((weiForGas * (1e9) * (premium)) / (linkEth)) + (uint256(s_storage.flatFeeMicroLink) * (1e12));\\n    if (total > LINK_TOTAL_SUPPLY) revert PaymentGreaterThanAllLINK();\\n    return uint96(total); // LINK_TOTAL_SUPPLY < UINT96_MAX\\n  }\\n\\n  /**\\n   * @dev calls target address with exactly gasAmount gas and data as calldata\\n   * or reverts if at least gasAmount gas is not available\\n   */\\n  function _callWithExactGas(\\n    uint256 gasAmount,\\n    address target,\\n    bytes memory data\\n  ) private returns (bool success) {\\n    assembly {\\n      let g := gas()\\n      // Compute g -= PERFORM_GAS_CUSHION and check for underflow\\n      if lt(g, PERFORM_GAS_CUSHION) {\\n        revert(0, 0)\\n      }\\n      g := sub(g, PERFORM_GAS_CUSHION)\\n      // if g - g//64 <= gasAmount, revert\\n      // (we subtract g//64 because of EIP-150)\\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\\n        revert(0, 0)\\n      }\\n      // solidity calls check that a contract actually exists at the destination, so we do the same\\n      if iszero(extcodesize(target)) {\\n        revert(0, 0)\\n      }\\n      // call and return whether we succeeded. ignore return data\\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\\n    }\\n    return success;\\n  }\\n\\n  /**\\n   * @dev calls the Upkeep target with the performData param passed in by the\\n   * keeper and the exact gas required by the Upkeep\\n   */\\n  function _performUpkeepWithParams(PerformParams memory params)\\n    private\\n    nonReentrant\\n    validUpkeep(params.id)\\n    returns (bool success)\\n  {\\n    Upkeep memory upkeep = s_upkeep[params.id];\\n    _prePerformUpkeep(upkeep, params.from, params.maxLinkPayment);\\n\\n    uint256 gasUsed = gasleft();\\n    bytes memory callData = abi.encodeWithSelector(PERFORM_SELECTOR, params.performData);\\n    success = _callWithExactGas(params.gasLimit, upkeep.target, callData);\\n    gasUsed = gasUsed - gasleft();\\n\\n    uint96 payment = _calculatePaymentAmount(gasUsed, params.adjustedGasWei, params.linkEth);\\n\\n    s_upkeep[params.id].balance = s_upkeep[params.id].balance - payment;\\n    s_upkeep[params.id].amountSpent = s_upkeep[params.id].amountSpent + payment;\\n    s_upkeep[params.id].lastKeeper = params.from;\\n    s_keeperInfo[params.from].balance = s_keeperInfo[params.from].balance + payment;\\n\\n    emit UpkeepPerformed(params.id, success, params.from, payment, params.performData);\\n    return success;\\n  }\\n\\n  /**\\n   * @dev ensures all required checks are passed before an upkeep is performed\\n   */\\n  function _prePerformUpkeep(\\n    Upkeep memory upkeep,\\n    address from,\\n    uint256 maxLinkPayment\\n  ) private view {\\n    if (!s_keeperInfo[from].active) revert OnlyActiveKeepers();\\n    if (upkeep.balance < maxLinkPayment) revert InsufficientFunds();\\n    if (upkeep.lastKeeper == from) revert KeepersMustTakeTurns();\\n  }\\n\\n  /**\\n   * @dev adjusts the gas price to min(ceiling, tx.gasprice) or just uses the ceiling if tx.gasprice is disabled\\n   */\\n  function _adjustGasPrice(uint256 gasWei, bool useTxGasPrice) private view returns (uint256 adjustedPrice) {\\n    adjustedPrice = gasWei * s_storage.gasCeilingMultiplier;\\n    if (useTxGasPrice && tx.gasprice < adjustedPrice) {\\n      adjustedPrice = tx.gasprice;\\n    }\\n  }\\n\\n  /**\\n   * @dev generates a PerformParams struct for use in _performUpkeepWithParams()\\n   */\\n  function _generatePerformParams(\\n    address from,\\n    uint256 id,\\n    bytes memory performData,\\n    bool useTxGasPrice\\n  ) private view returns (PerformParams memory) {\\n    uint256 gasLimit = s_upkeep[id].executeGas;\\n    (uint256 gasWei, uint256 linkEth) = _getFeedData();\\n    uint256 adjustedGasWei = _adjustGasPrice(gasWei, useTxGasPrice);\\n    uint96 maxLinkPayment = _calculatePaymentAmount(gasLimit, adjustedGasWei, linkEth);\\n\\n    return\\n      PerformParams({\\n        from: from,\\n        id: id,\\n        performData: performData,\\n        maxLinkPayment: maxLinkPayment,\\n        gasLimit: gasLimit,\\n        adjustedGasWei: adjustedGasWei,\\n        linkEth: linkEth\\n      });\\n  }\\n\\n  // MODIFIERS\\n\\n  /**\\n   * @dev ensures a upkeep is valid\\n   */\\n  modifier validUpkeep(uint256 id) {\\n    if (s_upkeep[id].maxValidBlocknumber <= block.number) revert UpkeepNotActive();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if called by anyone other than the admin of upkeep #id\\n   */\\n  modifier onlyUpkeepAdmin(uint256 id) {\\n    if (msg.sender != s_upkeep[id].admin) revert OnlyCallableByAdmin();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if called on a cancelled upkeep\\n   */\\n  modifier onlyActiveUpkeep(uint256 id) {\\n    if (s_upkeep[id].maxValidBlocknumber != UINT64_MAX) revert UpkeepNotActive();\\n    _;\\n  }\\n\\n  /**\\n   * @dev ensures that burns don't accidentally happen by sending to the zero\\n   * address\\n   */\\n  modifier validRecipient(address to) {\\n    if (to == ZERO_ADDRESS) revert InvalidRecipient();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if called by anyone other than the contract owner or registrar.\\n   */\\n  modifier onlyOwnerOrRegistrar() {\\n    if (msg.sender != owner() && msg.sender != s_registrar) revert OnlyCallableByOwnerOrRegistrar();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/KeeperBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract KeeperBase {\\n  error OnlySimulatedBackend();\\n\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function preventExecution() internal view {\\n    if (tx.origin != address(0)) {\\n      revert OnlySimulatedBackend();\\n    }\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    preventExecution();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface KeeperCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/KeeperRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice config of the registry\\n * @dev only used in params and return values\\n * @member paymentPremiumPPB payment premium rate oracles receive on top of\\n * being reimbursed for gas, measured in parts per billion\\n * @member flatFeeMicroLink flat fee paid to oracles for performing upkeeps,\\n * priced in MicroLink; can be used in conjunction with or independently of\\n * paymentPremiumPPB\\n * @member blockCountPerTurn number of blocks each oracle has during their turn to\\n * perform upkeep before it will be the next keeper's turn to submit\\n * @member checkGasLimit gas limit when checking for upkeep\\n * @member stalenessSeconds number of seconds that is allowed for feed data to\\n * be stale before switching to the fallback pricing\\n * @member gasCeilingMultiplier multiplier to apply to the fast gas feed price\\n * when calculating the payment ceiling for keepers\\n * @member minUpkeepSpend minimum LINK that an upkeep must spend before cancelling\\n * @member maxPerformGas max executeGas allowed for an upkeep on this registry\\n * @member fallbackGasPrice gas price used if the gas price feed is stale\\n * @member fallbackLinkPrice LINK price used if the LINK price feed is stale\\n * @member transcoder address of the transcoder contract\\n * @member registrar address of the registrar contract\\n */\\nstruct Config {\\n  uint32 paymentPremiumPPB;\\n  uint32 flatFeeMicroLink; // min 0.000001 LINK, max 4294 LINK\\n  uint24 blockCountPerTurn;\\n  uint32 checkGasLimit;\\n  uint24 stalenessSeconds;\\n  uint16 gasCeilingMultiplier;\\n  uint96 minUpkeepSpend;\\n  uint32 maxPerformGas;\\n  uint256 fallbackGasPrice;\\n  uint256 fallbackLinkPrice;\\n  address transcoder;\\n  address registrar;\\n}\\n\\n/**\\n * @notice config of the registry\\n * @dev only used in params and return values\\n * @member nonce used for ID generation\\n * @ownerLinkBalance withdrawable balance of LINK by contract owner\\n * @numUpkeeps total number of upkeeps on the registry\\n */\\nstruct State {\\n  uint32 nonce;\\n  uint96 ownerLinkBalance;\\n  uint256 expectedLinkBalance;\\n  uint256 numUpkeeps;\\n}\\n\\ninterface KeeperRegistryBaseInterface {\\n  function registerUpkeep(\\n    address target,\\n    uint32 gasLimit,\\n    address admin,\\n    bytes calldata checkData\\n  ) external returns (uint256 id);\\n\\n  function performUpkeep(uint256 id, bytes calldata performData) external returns (bool success);\\n\\n  function cancelUpkeep(uint256 id) external;\\n\\n  function addFunds(uint256 id, uint96 amount) external;\\n\\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external;\\n\\n  function getUpkeep(uint256 id)\\n    external\\n    view\\n    returns (\\n      address target,\\n      uint32 executeGas,\\n      bytes memory checkData,\\n      uint96 balance,\\n      address lastKeeper,\\n      address admin,\\n      uint64 maxValidBlocknumber,\\n      uint96 amountSpent\\n    );\\n\\n  function getActiveUpkeepIDs(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\\n\\n  function getKeeperInfo(address query)\\n    external\\n    view\\n    returns (\\n      address payee,\\n      bool active,\\n      uint96 balance\\n    );\\n\\n  function getState()\\n    external\\n    view\\n    returns (\\n      State memory,\\n      Config memory,\\n      address[] memory\\n    );\\n}\\n\\n/**\\n * @dev The view methods are not actually marked as view in the implementation\\n * but we want them to be easily queried off-chain. Solidity will not compile\\n * if we actually inherit from this interface, so we document it here.\\n */\\ninterface KeeperRegistryInterface is KeeperRegistryBaseInterface {\\n  function checkUpkeep(uint256 upkeepId, address from)\\n    external\\n    view\\n    returns (\\n      bytes memory performData,\\n      uint256 maxLinkPayment,\\n      uint256 gasLimit,\\n      int256 gasWei,\\n      int256 linkEth\\n    );\\n}\\n\\ninterface KeeperRegistryExecutableInterface is KeeperRegistryBaseInterface {\\n  function checkUpkeep(uint256 upkeepId, address from)\\n    external\\n    returns (\\n      bytes memory performData,\\n      uint256 maxLinkPayment,\\n      uint256 gasLimit,\\n      uint256 adjustedGasWei,\\n      uint256 linkEth\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/MigratableKeeperRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../UpkeepFormat.sol\\\";\\n\\ninterface MigratableKeeperRegistryInterface {\\n  /**\\n   * @notice Migrates upkeeps from one registry to another, including LINK and upkeep params.\\n   * Only callable by the upkeep admin. All upkeeps must have the same admin. Can only migrate active upkeeps.\\n   * @param upkeepIDs ids of upkeeps to migrate\\n   * @param destination the address of the registry to migrate to\\n   */\\n  function migrateUpkeeps(uint256[] calldata upkeepIDs, address destination) external;\\n\\n  /**\\n   * @notice Called by other registries when migrating upkeeps. Only callable by other registries.\\n   * @param encodedUpkeeps abi encoding of upkeeps to import - decoded by the transcoder\\n   */\\n  function receiveUpkeeps(bytes calldata encodedUpkeeps) external;\\n\\n  /**\\n   * @notice Specifies the version of upkeep data that this registry requires in order to import\\n   */\\n  function upkeepTranscoderVersion() external returns (UpkeepFormat version);\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/UpkeepTranscoderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"../UpkeepFormat.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\ninterface UpkeepTranscoderInterface {\\n  function transcodeUpkeeps(\\n    UpkeepFormat fromVersion,\\n    UpkeepFormat toVersion,\\n    bytes calldata encodedUpkeeps\\n  ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/ERC677ReceiverInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface ERC677ReceiverInterface {\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts/v0.8/UpkeepFormat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nenum UpkeepFormat {\\n  V1\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkEthFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fastGasFeed\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFeeMicroLink\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"minUpkeepSpend\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"maxPerformGas\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"transcoder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"}],\"internalType\":\"struct Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArrayHasNoEntries\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotCancel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DuplicateEntry\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitCanOnlyIncrease\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitOutsideRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDataLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KeepersMustTakeTurns\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationNotPermitted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyActiveKeepers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByLINKToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByOwnerOrAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByOwnerOrRegistrar\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByPayee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableByProposedPayee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlySimulatedBackend\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParameterLengthError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentGreaterThanAllLINK\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"TargetCheckReverted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TranscoderNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpkeepNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpkeepNotCanceled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpkeepNotNeeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueNotChanged\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFeeMicroLink\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"minUpkeepSpend\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"maxPerformGas\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"transcoder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"FundsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"keepers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"}],\"name\":\"KeepersUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"OwnerFundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"PaymentWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"atBlockHeight\",\"type\":\"uint64\"}],\"name\":\"UpkeepCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"gasLimit\",\"type\":\"uint96\"}],\"name\":\"UpkeepGasLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"UpkeepMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"payment\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"UpkeepPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"importedFrom\",\"type\":\"address\"}],\"name\":\"UpkeepReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"executeGas\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"UpkeepRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FAST_GAS_FEED\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK_ETH_FEED\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"acceptPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"addFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maxLinkPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjustedGasWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"linkEth\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCount\",\"type\":\"uint256\"}],\"name\":\"getActiveUpkeepIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"query\",\"type\":\"address\"}],\"name\":\"getKeeperInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"getMaxPaymentForGas\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"maxPayment\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMinBalanceForUpkeep\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"minBalance\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"peer\",\"type\":\"address\"}],\"name\":\"getPeerRegistryMigrationPermission\",\"outputs\":[{\"internalType\":\"enum KeeperRegistry.MigrationPermission\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"ownerLinkBalance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"expectedLinkBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numUpkeeps\",\"type\":\"uint256\"}],\"internalType\":\"struct State\",\"name\":\"state\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFeeMicroLink\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"minUpkeepSpend\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"maxPerformGas\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"transcoder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"}],\"internalType\":\"struct Config\",\"name\":\"config\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"keepers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUpkeep\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"executeGas\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"lastKeeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maxValidBlocknumber\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"amountSpent\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"migrateUpkeeps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedUpkeeps\",\"type\":\"bytes\"}],\"name\":\"receiveUpkeeps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"registerUpkeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFeeMicroLink\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"minUpkeepSpend\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"maxPerformGas\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"transcoder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"}],\"internalType\":\"struct Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"keepers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"}],\"name\":\"setKeepers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"peer\",\"type\":\"address\"},{\"internalType\":\"enum KeeperRegistry.MigrationPermission\",\"name\":\"permission\",\"type\":\"uint8\"}],\"name\":\"setPeerRegistryMigrationPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"name\":\"setUpkeepGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"transferPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upkeepTranscoderVersion\",\"outputs\":[{\"internalType\":\"enum UpkeepFormat\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawOwnerFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KeeperRegistry", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000404460c6a5ede2d891e8297795264fde62adbb75000000000000000000000000b38722f6a608646a538e882ee9972d15c86fc597000000000000000000000000f6ef201ae5d05a5cd04d71ab3c90c901d4489e880000000000000000000000000000000000000000000000000000000011e1a300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000632ea00000000000000000000000000000000000000000000000000000000000015f900000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004c4b400000000000000000000000000000000000000000000000000000000ba43b740000000000000000000000000000000000000000000000000000470de4df820000000000000000000000000000a59aa03de50a4383d90e1a4bb912a8dd795d1292000000000000000000000000db8e8e2ccb5c033938736aa89fe4fa1edfd15a1d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}