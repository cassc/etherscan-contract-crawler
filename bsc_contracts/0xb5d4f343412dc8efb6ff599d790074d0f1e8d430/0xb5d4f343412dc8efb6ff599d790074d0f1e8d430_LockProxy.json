{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/LockProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./libs/common/ZeroCopySource.sol\\\";\\nimport \\\"./libs/common/ZeroCopySink.sol\\\";\\nimport \\\"./libs/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libs/utils/Utils.sol\\\";\\nimport \\\"./libs/math/SafeMath.sol\\\";\\n\\nimport \\\"./Wallet.sol\\\";\\n\\ninterface CCM {\\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\\n}\\n\\ninterface CCMProxy {\\n    function getEthCrossChainManager() external view returns (address);\\n}\\n\\n/// @title The LockProxy contract for Switcheo TradeHub\\n/// @author Switcheo Network\\n/// @notice This contract faciliates deposits and withdrawals to Switcheo TradeHub.\\n/// @dev The contract also allows for additional features in the future through \\\"extension\\\" contracts.\\ncontract LockProxy is ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    // used for cross-chain addExtension and removeExtension methods\\n    struct ExtensionTxArgs {\\n        bytes extensionAddress;\\n    }\\n\\n    // used for cross-chain registerAsset method\\n    struct RegisterAssetTxArgs {\\n        bytes assetHash;\\n        bytes nativeAssetHash;\\n    }\\n\\n    // used for cross-chain lock and unlock methods\\n    struct TransferTxArgs {\\n        bytes fromAssetHash;\\n        bytes toAssetHash;\\n        bytes toAddress;\\n        bytes fromAddress;\\n        uint256 amount;\\n        uint256 feeAmount;\\n        bytes feeAddress;\\n        uint256 nonce;\\n    }\\n\\n    // used to create a unique salt for wallet creation\\n    bytes public constant SALT_PREFIX = \\\"switcheo-eth-wallet-factory-v1\\\";\\n    address public constant ETH_ADDRESS = address(0);\\n\\n    address public immutable swthToken;\\n    CCMProxy public immutable ccmProxy;\\n    uint64 public immutable counterpartChainId;\\n\\n    uint256 public currentNonce = 0;\\n\\n    // a mapping of assetHashes to the hash of\\n    // (associated proxy address on Switcheo TradeHub, associated asset hash on Switcheo TradeHub)\\n    mapping(address => bytes32) public registry;\\n\\n    // a record of signed messages to prevent replay attacks\\n    mapping(bytes32 => bool) public seenMessages;\\n\\n    // a mapping of extension contracts\\n    mapping(address => bool) public extensions;\\n\\n    // a record of created wallets\\n    mapping(address => bool) public wallets;\\n\\n    event LockEvent(\\n        address indexed tokenAddress,\\n        address indexed fromAddress,\\n        uint64 indexed toChainId,\\n        bytes toAssetHash,\\n        bytes toAddress,\\n        bytes txArgs\\n    );\\n\\n    event UnlockEvent(\\n        address indexed tokenAddress,\\n        address indexed toAddress,\\n        uint256 amount,\\n        bytes txArgs\\n    );\\n\\n    constructor(address _swthToken, address _ccmProxyAddress, uint64 _counterpartChainId) public {\\n        require(_counterpartChainId > 0, \\\"counterpartChainId cannot be zero\\\");\\n        require(_ccmProxyAddress != address(0), \\\"ccmProxyAddress cannot be empty\\\");\\n        require(_swthToken != address(0), \\\"swthToken cannot be empty\\\");\\n        swthToken = _swthToken;\\n        counterpartChainId = _counterpartChainId;\\n        ccmProxy = CCMProxy(_ccmProxyAddress);\\n    }\\n\\n    modifier onlyManagerContract() {\\n        require(\\n            msg.sender == ccmProxy.getEthCrossChainManager(),\\n            \\\"msg.sender is not CCM\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @dev Allow this contract to receive Ethereum\\n    receive() external payable {}\\n\\n    /// @dev Allow this contract to receive ERC223 tokens\\n    /// An empty implementation is required so that the ERC223 token will not\\n    /// throw an error on transfer, this is specific to ERC223 tokens which\\n    /// require this implementation, e.g. DGTX\\n    function tokenFallback(address, uint, bytes calldata) external {}\\n\\n    /// @dev Calculate the wallet address for the given owner and Switcheo TradeHub address\\n    /// @param _ownerAddress the Ethereum address which the user has control over, i.e. can sign msgs with\\n    /// @param _swthAddress the hex value of the user's Switcheo TradeHub address\\n    /// @param _bytecodeHash the hash of the wallet contract's bytecode\\n    /// @return the wallet address\\n    function getWalletAddress(\\n        address _ownerAddress,\\n        bytes calldata _swthAddress,\\n        bytes32 _bytecodeHash\\n    )\\n        external\\n        view\\n        returns (address)\\n    {\\n        bytes32 salt = _getSalt(\\n            _ownerAddress,\\n            _swthAddress\\n        );\\n\\n        bytes32 data = keccak256(\\n            abi.encodePacked(bytes1(0xff), address(this), salt, _bytecodeHash)\\n        );\\n\\n        return address(bytes20(data << 96));\\n    }\\n\\n    /// @dev Create the wallet for the given owner and Switcheo TradeHub address\\n    /// @param _ownerAddress the Ethereum address which the user has control over, i.e. can sign msgs with\\n    /// @param _swthAddress the hex value of the user's Switcheo TradeHub address\\n    /// @return true if success\\n    function createWallet(\\n        address _ownerAddress,\\n        bytes calldata _swthAddress\\n    )\\n        external\\n        nonReentrant\\n        returns (bool)\\n    {\\n        require(_ownerAddress != address(0), \\\"Empty ownerAddress\\\");\\n        require(_swthAddress.length != 0, \\\"Empty swthAddress\\\");\\n\\n        bytes32 salt = _getSalt(\\n            _ownerAddress,\\n            _swthAddress\\n        );\\n\\n        Wallet wallet = new Wallet{salt: salt}();\\n        wallet.initialize(_ownerAddress, _swthAddress);\\n        wallets[address(wallet)] = true;\\n\\n        return true;\\n    }\\n\\n    /// @dev Add a contract as an extension\\n    /// @param _argsBz the serialized ExtensionTxArgs\\n    /// @param _fromChainId the originating chainId\\n    /// @return true if success\\n    function addExtension(\\n        bytes calldata _argsBz,\\n        bytes calldata /* _fromContractAddr */,\\n        uint64 _fromChainId\\n    )\\n        external\\n        onlyManagerContract\\n        nonReentrant\\n        returns (bool)\\n    {\\n        require(_fromChainId == counterpartChainId, \\\"Invalid chain ID\\\");\\n\\n        ExtensionTxArgs memory args = _deserializeExtensionTxArgs(_argsBz);\\n        address extensionAddress = Utils.bytesToAddress(args.extensionAddress);\\n        extensions[extensionAddress] = true;\\n\\n        return true;\\n    }\\n\\n    /// @dev Remove a contract from the extensions mapping\\n    /// @param _argsBz the serialized ExtensionTxArgs\\n    /// @param _fromChainId the originating chainId\\n    /// @return true if success\\n    function removeExtension(\\n        bytes calldata _argsBz,\\n        bytes calldata /* _fromContractAddr */,\\n        uint64 _fromChainId\\n    )\\n        external\\n        onlyManagerContract\\n        nonReentrant\\n        returns (bool)\\n    {\\n        require(_fromChainId == counterpartChainId, \\\"Invalid chain ID\\\");\\n\\n        ExtensionTxArgs memory args = _deserializeExtensionTxArgs(_argsBz);\\n        address extensionAddress = Utils.bytesToAddress(args.extensionAddress);\\n        extensions[extensionAddress] = false;\\n\\n        return true;\\n    }\\n\\n    /// @dev Marks an asset as registered by mapping the asset's address to\\n    /// the specified _fromContractAddr and assetHash on Switcheo TradeHub\\n    /// @param _argsBz the serialized RegisterAssetTxArgs\\n    /// @param _fromContractAddr the associated contract address on Switcheo TradeHub\\n    /// @param _fromChainId the originating chainId\\n    /// @return true if success\\n    function registerAsset(\\n        bytes calldata _argsBz,\\n        bytes calldata _fromContractAddr,\\n        uint64 _fromChainId\\n    )\\n        external\\n        onlyManagerContract\\n        nonReentrant\\n        returns (bool)\\n    {\\n        require(_fromChainId == counterpartChainId, \\\"Invalid chain ID\\\");\\n\\n        RegisterAssetTxArgs memory args = _deserializeRegisterAssetTxArgs(_argsBz);\\n        _markAssetAsRegistered(\\n            Utils.bytesToAddress(args.nativeAssetHash),\\n            _fromContractAddr,\\n            args.assetHash\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @dev Performs a deposit from a Wallet contract\\n    /// @param _walletAddress address of the wallet contract, the wallet contract\\n    /// does not receive ETH in this call, but _walletAddress still needs to be payable\\n    /// since the wallet contract can receive ETH, there would be compile errors otherwise\\n    /// @param _tokenAddress address of the asset to deposit\\n    /// @param _targetProxyHash the associated proxy hash on Switcheo TradeHub\\n    /// @param _toAssetHash the associated asset hash on Switcheo TradeHub\\n    /// @param _feeAddress the hex version of the Switcheo TradeHub address to send the fee to\\n    /// @param _values[0]: amount, the number of tokens to deposit\\n    /// @param _values[1]: feeAmount, the number of tokens to be used as fees\\n    /// @param _values[2]: nonce, to prevent replay attacks\\n    /// @param _values[3]: callAmount, some tokens may burn an amount before transfer\\n    /// so we allow a callAmount to support these tokens\\n    /// @param _v: the v value of the wallet owner's signature\\n    /// @param _rs: the r, s values of the wallet owner's signature\\n    function lockFromWallet(\\n        address payable _walletAddress,\\n        address _tokenAddress,\\n        bytes calldata _targetProxyHash,\\n        bytes calldata _toAssetHash,\\n        bytes calldata _feeAddress,\\n        uint256[] calldata _values,\\n        uint8 _v,\\n        bytes32[] calldata _rs\\n    )\\n        external\\n        nonReentrant\\n        returns (bool)\\n    {\\n        require(wallets[_walletAddress], \\\"Invalid wallet address\\\");\\n\\n        Wallet wallet = Wallet(_walletAddress);\\n        _validateLockFromWallet(\\n            wallet.owner(),\\n            _tokenAddress,\\n            _targetProxyHash,\\n            _toAssetHash,\\n            _feeAddress,\\n            _values,\\n            _v,\\n            _rs\\n        );\\n\\n        // it is very important that this function validates the success of a transfer correctly\\n        // since, once this line is passed, the deposit is assumed to be successful\\n        // which will eventually result in the specified amount of tokens being minted for the\\n        // wallet.swthAddress on Switcheo TradeHub\\n        _transferInFromWallet(_walletAddress, _tokenAddress, _values[0], _values[3]);\\n\\n        _lock(\\n            _tokenAddress,\\n            _targetProxyHash,\\n            _toAssetHash,\\n            wallet.owner(),\\n            wallet.swthAddress(),\\n            _values,\\n            _feeAddress\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @dev Performs a deposit\\n    /// @param _tokenAddress the address of the token to deposit\\n    /// @param _targetProxyHash the associated proxy hash on Switcheo TradeHub\\n    /// @param _toAddress the hex version of the Switcheo TradeHub address to deposit to\\n    /// @param _toAssetHash the associated asset hash on Switcheo TradeHub\\n    /// @param _feeAddress the hex version of the Switcheo TradeHub address to send the fee to\\n    /// @param _values[0]: amount, the number of tokens to deposit\\n    /// @param _values[1]: feeAmount, the number of tokens to be used as fees\\n    /// @param _values[2]: callAmount, some tokens may burn an amount before transfer\\n    /// so we allow a callAmount to support these tokens\\n    function lock(\\n        address _tokenAddress,\\n        bytes calldata _targetProxyHash,\\n        bytes calldata _toAddress,\\n        bytes calldata _toAssetHash,\\n        bytes calldata _feeAddress,\\n        uint256[] calldata _values\\n    )\\n        external\\n        payable\\n        nonReentrant\\n        returns (bool)\\n    {\\n\\n        // it is very important that this function validates the success of a transfer correctly\\n        // since, once this line is passed, the deposit is assumed to be successful\\n        // which will eventually result in the specified amount of tokens being minted for the\\n        // _toAddress on Switcheo TradeHub\\n        _transferIn(_tokenAddress, _values[0], _values[2]);\\n\\n        _lock(\\n            _tokenAddress,\\n            _targetProxyHash,\\n            _toAssetHash,\\n            msg.sender,\\n            _toAddress,\\n            _values,\\n            _feeAddress\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @dev Performs a withdrawal that was initiated on Switcheo TradeHub\\n    /// @param _argsBz the serialized TransferTxArgs\\n    /// @param _fromContractAddr the associated contract address on Switcheo TradeHub\\n    /// @param _fromChainId the originating chainId\\n    /// @return true if success\\n    function unlock(\\n        bytes calldata _argsBz,\\n        bytes calldata _fromContractAddr,\\n        uint64 _fromChainId\\n    )\\n        external\\n        onlyManagerContract\\n        nonReentrant\\n        returns (bool)\\n    {\\n        require(_fromChainId == counterpartChainId, \\\"Invalid chain ID\\\");\\n\\n        TransferTxArgs memory args = _deserializeTransferTxArgs(_argsBz);\\n        require(args.fromAssetHash.length > 0, \\\"Invalid fromAssetHash\\\");\\n        require(args.toAssetHash.length == 20, \\\"Invalid toAssetHash\\\");\\n\\n        address tokenAddress = Utils.bytesToAddress(args.toAssetHash);\\n        address toAddress = Utils.bytesToAddress(args.toAddress);\\n\\n        _validateAssetRegistration(tokenAddress, _fromContractAddr, args.fromAssetHash);\\n        _transferOut(toAddress, tokenAddress, args.amount);\\n\\n        emit UnlockEvent(tokenAddress, toAddress, args.amount, _argsBz);\\n        return true;\\n    }\\n\\n    /// @dev Performs a transfer of funds, this is only callable by approved extension contracts\\n    /// the `nonReentrant` guard is intentionally not added to this function, to allow for more flexibility.\\n    /// The calling contract should be secure and have its own `nonReentrant` guard as needed.\\n    /// @param _receivingAddress the address to transfer to\\n    /// @param _tokenAddress the address of the asset to transfer\\n    /// @param _amount the amount to transfer\\n    /// @return true if success\\n    function extensionTransfer(\\n        address _receivingAddress,\\n        address _tokenAddress,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool)\\n    {\\n        require(\\n            extensions[msg.sender] == true,\\n            \\\"Invalid extension\\\"\\n        );\\n\\n        if (_tokenAddress == ETH_ADDRESS) {\\n            // we use `call` here since the _receivingAddress could be a contract\\n            // see https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\\n            // for more info\\n            (bool success,  ) = _receivingAddress.call{value: _amount}(\\\"\\\");\\n            require(success, \\\"Transfer failed\\\");\\n            return true;\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n\\n        // Fixes possible issue when current allowance is not zero.\\n        // For more info see issue 3.2 in:\\n        // https://github.com/Switcheo/switcheo-tradehub-eth/blob/master/audits/PeckShield-Audit-Report-Switcheo-v1.0-rc.pdf\\n        uint256 allowance = token.allowance(address(this), _receivingAddress);\\n        if (allowance > 0) {\\n          _callOptionalReturn(\\n              token,\\n              abi.encodeWithSelector(\\n                  token.approve.selector,\\n                  _receivingAddress,\\n                  0\\n              )\\n          );\\n        }\\n\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                _receivingAddress,\\n                _amount\\n            )\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @dev Marks an asset as registered by associating it to a specified Switcheo TradeHub proxy and asset hash\\n    /// @param _tokenAddress the address of the asset to mark\\n    /// @param _proxyAddress the associated proxy address on Switcheo TradeHub\\n    /// @param _toAssetHash the associated asset hash on Switcheo TradeHub\\n    function _markAssetAsRegistered(\\n        address _tokenAddress,\\n        bytes memory _proxyAddress,\\n        bytes memory _toAssetHash\\n    )\\n        private\\n    {\\n        require(_proxyAddress.length == 20, \\\"Invalid proxyAddress\\\");\\n        require(\\n            registry[_tokenAddress] == bytes32(0),\\n            \\\"Asset already registered\\\"\\n        );\\n\\n        bytes32 value = keccak256(abi.encodePacked(\\n            _proxyAddress,\\n            _toAssetHash\\n        ));\\n\\n        registry[_tokenAddress] = value;\\n    }\\n\\n    /// @dev Validates that an asset's registration matches the given params\\n    /// @param _tokenAddress the address of the asset to check\\n    /// @param _proxyAddress the expected proxy address on Switcheo TradeHub\\n    /// @param _toAssetHash the expected asset hash on Switcheo TradeHub\\n    function _validateAssetRegistration(\\n        address _tokenAddress,\\n        bytes memory _proxyAddress,\\n        bytes memory _toAssetHash\\n    )\\n        private\\n        view\\n    {\\n        require(_proxyAddress.length == 20, \\\"Invalid proxyAddress\\\");\\n        bytes32 value = keccak256(abi.encodePacked(\\n            _proxyAddress,\\n            _toAssetHash\\n        ));\\n        require(registry[_tokenAddress] == value, \\\"Asset not registered\\\");\\n    }\\n\\n    /// @dev validates the asset registration and calls the CCM contract\\n    function _lock(\\n        address _tokenAddress,\\n        bytes memory _targetProxyHash,\\n        bytes memory _toAssetHash,\\n        address _fromAddress,\\n        bytes memory _toAddress,\\n        uint256[] memory _amounts, // 0: amount, 1: feeAmount (avoid StackTooDeep error)\\n        bytes memory _feeAddress\\n    )\\n        private\\n    {\\n        uint256 amount = _amounts[0];\\n        uint256 feeAmount = _amounts[1];\\n        require(_targetProxyHash.length == 20, \\\"Invalid targetProxyHash\\\");\\n        require(_toAssetHash.length > 0, \\\"Empty toAssetHash\\\");\\n        require(_toAddress.length > 0, \\\"Empty toAddress\\\");\\n        require(amount > 0, \\\"Amount must be more than zero\\\");\\n        require(feeAmount < amount, \\\"Fee amount must be less than amount\\\");\\n\\n        _validateAssetRegistration(_tokenAddress, _targetProxyHash, _toAssetHash);\\n\\n        TransferTxArgs memory txArgs = TransferTxArgs({\\n            fromAssetHash: Utils.addressToBytes(_tokenAddress),\\n            toAssetHash: _toAssetHash,\\n            fromAddress: abi.encodePacked(_fromAddress),\\n            toAddress: _toAddress,\\n            amount: amount,\\n            feeAmount: feeAmount,\\n            feeAddress: _feeAddress,\\n            nonce: _getNextNonce()\\n        });\\n\\n        bytes memory txData = _serializeTransferTxArgs(txArgs);\\n        CCM ccm = _getCcm();\\n        require(\\n            ccm.crossChain(counterpartChainId, _targetProxyHash, \\\"unlock\\\", txData),\\n            \\\"EthCrossChainManager crossChain executed error!\\\"\\n        );\\n\\n        emit LockEvent(_tokenAddress, _fromAddress, counterpartChainId, _toAssetHash, _toAddress, txData);\\n    }\\n\\n    /// @dev validate the signature for lockFromWallet\\n    function _validateLockFromWallet(\\n        address _walletOwner,\\n        address _tokenAddress,\\n        bytes memory _targetProxyHash,\\n        bytes memory _toAssetHash,\\n        bytes memory _feeAddress,\\n        uint256[] memory _values,\\n        uint8 _v,\\n        bytes32[] memory _rs\\n    )\\n        private\\n    {\\n        bytes32 message = keccak256(abi.encodePacked(\\n            \\\"sendTokens\\\",\\n            _tokenAddress,\\n            _targetProxyHash,\\n            _toAssetHash,\\n            _feeAddress,\\n            _values[0],\\n            _values[1],\\n            _values[2]\\n        ));\\n\\n        require(seenMessages[message] == false, \\\"Message already seen\\\");\\n        seenMessages[message] = true;\\n        _validateSignature(message, _walletOwner, _v, _rs[0], _rs[1]);\\n    }\\n\\n    /// @dev transfers funds from a Wallet contract into this contract\\n    /// the difference between this contract's before and after balance must equal _amount\\n    /// this is assumed to be sufficient in ensuring that the expected amount\\n    /// of funds were transferred in\\n    function _transferInFromWallet(\\n        address payable _walletAddress,\\n        address _tokenAddress,\\n        uint256 _amount,\\n        uint256 _callAmount\\n    )\\n        private\\n    {\\n        Wallet wallet = Wallet(_walletAddress);\\n        if (_tokenAddress == ETH_ADDRESS) {\\n            uint256 before = address(this).balance;\\n\\n            wallet.sendETHToCreator(_callAmount);\\n\\n            uint256 transferred = address(this).balance.sub(before);\\n            require(transferred == _amount, \\\"ETH transferred does not match the expected amount\\\");\\n            return;\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint256 before = token.balanceOf(address(this));\\n\\n        wallet.sendERC20ToCreator(_tokenAddress, _callAmount);\\n\\n        uint256 transferred = token.balanceOf(address(this)).sub(before);\\n        require(transferred == _amount || _tokenAddress == swthToken, \\\"Tokens transferred does not match the expected amount\\\");\\n    }\\n\\n    /// @dev transfers funds from an address into this contract\\n    /// for ETH transfers, we only check that msg.value == _amount, and _callAmount is ignored\\n    /// for token transfers, the difference between this contract's before and after balance must equal _amount\\n    /// these checks are assumed to be sufficient in ensuring that the expected amount\\n    /// of funds were transferred in\\n    function _transferIn(\\n        address _tokenAddress,\\n        uint256 _amount,\\n        uint256 _callAmount\\n    )\\n        private\\n    {\\n        if (_tokenAddress == ETH_ADDRESS) {\\n            require(msg.value == _amount, \\\"ETH transferred does not match the expected amount\\\");\\n            return;\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint256 before = token.balanceOf(address(this));\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.transferFrom.selector,\\n                msg.sender,\\n                address(this),\\n                _callAmount\\n            )\\n        );\\n        uint256 transferred = token.balanceOf(address(this)).sub(before);\\n        require(transferred == _amount || _tokenAddress == swthToken, \\\"Tokens transferred does not match the expected amount\\\");\\n    }\\n\\n    /// @dev transfers funds from this contract to the _toAddress\\n    function _transferOut(\\n        address _toAddress,\\n        address _tokenAddress,\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        if (_tokenAddress == ETH_ADDRESS) {\\n            // we use `call` here since the _receivingAddress could be a contract\\n            // see https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\\n            // for more info\\n            (bool success,  ) = _toAddress.call{value: _amount}(\\\"\\\");\\n            require(success, \\\"Transfer failed\\\");\\n            return;\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.transfer.selector,\\n                _toAddress,\\n                _amount\\n            )\\n        );\\n    }\\n\\n    /// @dev validates a signature against the specified user address\\n    function _validateSignature(\\n        bytes32 _message,\\n        address _user,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        private\\n        pure\\n    {\\n        bytes32 prefixedMessage = keccak256(abi.encodePacked(\\n            \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n            _message\\n        ));\\n\\n        require(\\n          _user != address(0),\\n          \\\"Invalid signature\\\"\\n        );\\n\\n        require(\\n            _user == ecrecover(prefixedMessage, _v, _r, _s),\\n            \\\"Invalid signature\\\"\\n        );\\n    }\\n\\n    function _serializeTransferTxArgs(TransferTxArgs memory args) private pure returns (bytes memory) {\\n        bytes memory buff;\\n        buff = abi.encodePacked(\\n            ZeroCopySink.WriteVarBytes(args.fromAssetHash),\\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\\n            ZeroCopySink.WriteVarBytes(args.toAddress),\\n            ZeroCopySink.WriteUint255(args.amount),\\n            ZeroCopySink.WriteUint255(args.feeAmount),\\n            ZeroCopySink.WriteVarBytes(args.feeAddress),\\n            ZeroCopySink.WriteVarBytes(args.fromAddress),\\n            ZeroCopySink.WriteUint255(args.nonce)\\n        );\\n        return buff;\\n    }\\n\\n    function _deserializeTransferTxArgs(bytes memory valueBz) private pure returns (TransferTxArgs memory) {\\n        TransferTxArgs memory args;\\n        uint256 off = 0;\\n        (args.fromAssetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBz, off);\\n        (args.amount, off) = ZeroCopySource.NextUint255(valueBz, off);\\n        return args;\\n    }\\n\\n    function _deserializeRegisterAssetTxArgs(bytes memory valueBz) private pure returns (RegisterAssetTxArgs memory) {\\n        RegisterAssetTxArgs memory args;\\n        uint256 off = 0;\\n        (args.assetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\\n        (args.nativeAssetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\\n        return args;\\n    }\\n\\n    function _deserializeExtensionTxArgs(bytes memory valueBz) private pure returns (ExtensionTxArgs memory) {\\n        ExtensionTxArgs memory args;\\n        uint256 off = 0;\\n        (args.extensionAddress, off) = ZeroCopySource.NextVarBytes(valueBz, off);\\n        return args;\\n    }\\n\\n    function _getCcm() private view returns (CCM) {\\n      CCM ccm = CCM(ccmProxy.getEthCrossChainManager());\\n      return ccm;\\n    }\\n\\n    function _getNextNonce() private returns (uint256) {\\n      currentNonce = currentNonce.add(1);\\n      return currentNonce;\\n    }\\n\\n    function _getSalt(\\n        address _ownerAddress,\\n        bytes memory _swthAddress\\n    )\\n        private\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(\\n            SALT_PREFIX,\\n            _ownerAddress,\\n            _swthAddress\\n        ));\\n    }\\n\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(Utils.isContract(address(token)), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/Wallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./libs/utils/Utils.sol\\\";\\nimport \\\"./libs/token/ERC20/IERC20.sol\\\";\\n\\n/// @title The Wallet contract for Switcheo TradeHub\\n/// @author Switcheo Network\\n/// @notice This contract faciliates deposits for Switcheo TradeHub.\\n/// @dev This contract is used together with the LockProxy contract to allow users\\n/// to deposit funds without requiring them to have ETH\\ncontract Wallet {\\n    bool public isInitialized;\\n    address public creator;\\n    address public owner;\\n    bytes public swthAddress;\\n\\n    function initialize(address _owner, bytes calldata _swthAddress) external {\\n        require(isInitialized == false, \\\"Contract already initialized\\\");\\n        isInitialized = true;\\n        creator = msg.sender;\\n        owner = _owner;\\n        swthAddress = _swthAddress;\\n    }\\n\\n    /// @dev Allow this contract to receive Ethereum\\n    receive() external payable {}\\n\\n    /// @dev Allow this contract to receive ERC223 tokens\\n    // An empty implementation is required so that the ERC223 token will not\\n    // throw an error on transfer\\n    function tokenFallback(address, uint, bytes calldata) external {}\\n\\n    /// @dev send ETH from this contract to its creator\\n    function sendETHToCreator(uint256 _amount) external {\\n        require(msg.sender == creator, \\\"Sender must be creator\\\");\\n        // we use `call` here following the recommendation from\\n        // https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\\n        (bool success,  ) = creator.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    /// @dev send tokens from this contract to its creator\\n    function sendERC20ToCreator(address _assetId, uint256 _amount) external {\\n        require(msg.sender == creator, \\\"Sender must be creator\\\");\\n\\n        IERC20 token = IERC20(_assetId);\\n        Utils.callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.transfer.selector,\\n                creator,\\n                _amount\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/libs/common/ZeroCopySink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.\\n *\\n * Encode basic types in Solidity into bytes easily. It's designed to be used\\n * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain\\n * and the decoding rules on other chains should be consistent. Here we\\n * follow the underlying serialization rule with implementation found here:\\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go\\n *\\n * Using this library instead of the unchecked serialization method can help reduce\\n * the risk of serious bugs and handfule, so it's recommended to use it.\\n *\\n * Please note that risk can be minimized, yet not eliminated.\\n */\\nlibrary ZeroCopySink {\\n    /* @notice          Convert boolean value into bytes\\n    *  @param b         The boolean value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteBool(bool b) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            mstore(buff, 1)\\n            switch iszero(b)\\n            case 1 {\\n                mstore(add(buff, 0x20), shl(248, 0x00))\\n                // mstore8(add(buff, 0x20), 0x00)\\n            }\\n            default {\\n                mstore(add(buff, 0x20), shl(248, 0x01))\\n                // mstore8(add(buff, 0x20), 0x01)\\n            }\\n            mstore(0x40, add(buff, 0x21))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert byte value into bytes\\n    *  @param b         The byte value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteByte(byte b) internal pure returns (bytes memory) {\\n        return WriteUint8(uint8(b));\\n    }\\n\\n    /* @notice          Convert uint8 value into bytes\\n    *  @param v         The uint8 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            mstore(buff, 1)\\n            mstore(add(buff, 0x20), shl(248, v))\\n            // mstore(add(buff, 0x20), byte(0x1f, v))\\n            mstore(0x40, add(buff, 0x21))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert uint16 value into bytes\\n    *  @param v         The uint16 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x02\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x22))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert uint32 value into bytes\\n    *  @param v         The uint32 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x04\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x24))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert uint64 value into bytes\\n    *  @param v         The uint64 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x08\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x28))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert limited uint256 value into bytes\\n    *  @param v         The uint256 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds uint255 range\\\");\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x20\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x40))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Encode bytes format data into bytes\\n    *  @param data      The bytes array data\\n    *  @return          Encoded bytes array\\n    */\\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\\n        uint64 l = uint64(data.length);\\n        return abi.encodePacked(WriteVarUint(l), data);\\n    }\\n\\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\\n        if (v < 0xFD){\\n    \\t\\treturn WriteUint8(uint8(v));\\n    \\t} else if (v <= 0xFFFF) {\\n    \\t\\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\\n    \\t} else if (v <= 0xFFFFFFFF) {\\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\\n    \\t} else {\\n    \\t\\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\\n    \\t}\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/libs/common/ZeroCopySource.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.\\n *\\n * Decode into basic types in Solidity from bytes easily. It's designed to be used\\n * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain\\n * and the encoding rule on other chains should be consistent, and . Here we\\n * follow the underlying deserialization rule with implementation found here:\\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go\\n *\\n * Using this library instead of the unchecked serialization method can help reduce\\n * the risk of serious bugs and handfule, so it's recommended to use it.\\n *\\n * Please note that risk can be minimized, yet not eliminated.\\n */\\nlibrary ZeroCopySource {\\n    /* @notice              Read next byte as boolean type starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the boolean value\\n    *  @return              The the read boolean value and new offset\\n    */\\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"Offset exceeds limit\\\");\\n        // byte === bytes1\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        bool value;\\n        if (v == 0x01) {\\n\\t\\t    value = true;\\n    \\t} else if (v == 0x00) {\\n            value = false;\\n        } else {\\n            revert(\\\"NextBool value error\\\");\\n        }\\n        return (value, offset + 1);\\n    }\\n\\n    /* @notice              Read next byte starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the byte value\\n    *  @return              The read byte value and new offset\\n    */\\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"NextByte, Offset exceeds maximum\\\");\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        return (v, offset + 1);\\n    }\\n\\n    /* @notice              Read next byte as uint8 starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the byte value\\n    *  @return              The read uint8 value and new offset\\n    */\\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"NextUint8, Offset exceeds maximum\\\");\\n        uint8 v;\\n        assembly{\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x01))\\n            v := mload(sub(tmpbytes, 0x1f))\\n        }\\n        return (v, offset + 1);\\n    }\\n\\n    /* @notice              Read next two bytes as uint16 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint16 value\\n    *  @return              The read uint16 value and updated offset\\n    */\\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\\n        require(offset + 2 <= buff.length && offset < offset + 2, \\\"NextUint16, offset exceeds maximum\\\");\\n\\n        uint16 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0x01, bvalue))\\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x02))\\n            v := mload(sub(tmpbytes, 0x1e))\\n        }\\n        return (v, offset + 2);\\n    }\\n\\n\\n    /* @notice              Read next four bytes as uint32 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint32 value\\n    *  @return              The read uint32 value and updated offset\\n    */\\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\\n        require(offset + 4 <= buff.length && offset < offset + 4, \\\"NextUint32, offset exceeds maximum\\\");\\n        uint32 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x04\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 4);\\n    }\\n\\n    /* @notice              Read next eight bytes as uint64 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint64 value\\n    *  @return              The read uint64 value and updated offset\\n    */\\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\\n\\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\\n                            there are limits considering the numerical limits in multi-chain\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint256 value\\n    *  @return              The read uint256 value and updated offset\\n    */\\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\\n        require(offset + 32 <= buff.length && offset < offset + 32, \\\"NextUint255, offset exceeds maximum\\\");\\n        uint256 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x20\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(tmpbytes)\\n        }\\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds the range\\\");\\n        return (v, offset + 32);\\n    }\\n    /* @notice              Read next variable bytes starting from offset,\\n                            the decoding rule coming from multi-chain\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read variable bytes array value and updated offset\\n    */\\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\\n    /* @notice              Read next 32 bytes starting from offset,\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read bytes32 value and updated offset\\n    */\\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\\n        require(offset + 32 <= buff.length && offset < offset + 32, \\\"NextHash, offset exceeds maximum\\\");\\n        bytes32 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 32);\\n    }\\n\\n    /* @notice              Read next 20 bytes starting from offset,\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read bytes20 value and updated offset\\n    */\\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\\n        require(offset + 20 <= buff.length && offset < offset + 20, \\\"NextBytes20, offset exceeds maximum\\\");\\n        bytes20 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 20);\\n    }\\n\\n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\\n        byte v;\\n        (v, offset) = NextByte(buff, offset);\\n\\n        uint value;\\n        if (v == 0xFD) {\\n            // return NextUint16(buff, offset);\\n            (value, offset) = NextUint16(buff, offset);\\n            require(value >= 0xFD && value <= 0xFFFF, \\\"NextUint16, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFE) {\\n            // return NextUint32(buff, offset);\\n            (value, offset) = NextUint32(buff, offset);\\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFF) {\\n            // return NextUint64(buff, offset);\\n            (value, offset) = NextUint64(buff, offset);\\n            require(value > 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else{\\n            // return (uint8(v), offset);\\n            value = uint8(v);\\n            require(value < 0xFD, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/libs/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/libs/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/libs/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/jiarong/workspace/switcheo/switcheo-tradehub-eth/contracts/libs/utils/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\\nlibrary Utils {\\n\\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\\n    *  @param _bs   Source bytes array\\n    *  @return      bytes32\\n    */\\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\\n        require(_bs.length == 32, \\\"bytes length is not 32.\\\");\\n        assembly {\\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\\n            value := mload(add(_bs, 0x20))\\n        }\\n    }\\n\\n    /* @notice      Convert bytes to uint256\\n    *  @param _b    Source bytes should have length of 32\\n    *  @return      uint256\\n    */\\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\\n        require(_bs.length == 32, \\\"bytes length is not 32.\\\");\\n        assembly {\\n            // load 32 bytes from memory starting from position _bs + 32\\n            value := mload(add(_bs, 0x20))\\n        }\\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds the range\\\");\\n    }\\n\\n    /* @notice      Convert uint256 to bytes\\n    *  @param _b    uint256 that needs to be converted\\n    *  @return      bytes\\n    */\\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds the range\\\");\\n        assembly {\\n            // Get a location of some free memory and store it in result as\\n            // Solidity does for memory variables.\\n            bs := mload(0x40)\\n            // Put 0x20 at the first word, the length of bytes for uint256 value\\n            mstore(bs, 0x20)\\n            //In the next word, put value in bytes format to the next 32 bytes\\n            mstore(add(bs, 0x20), _value)\\n            // Update the free-memory pointer by padding our last write location to 32 bytes\\n            mstore(0x40, add(bs, 0x40))\\n        }\\n    }\\n\\n    /* @notice      Convert bytes to address\\n    *  @param _bs   Source bytes: bytes length must be 20\\n    *  @return      Converted address from source bytes\\n    */\\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\\n    {\\n        require(_bs.length == 20, \\\"bytes length does not match address\\\");\\n        assembly {\\n            // for _bs, first word store _bs.length, second word store _bs.value\\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\\n            addr := mload(add(_bs, 0x14))\\n        }\\n\\n    }\\n\\n    /* @notice      Convert address to bytes\\n    *  @param _addr Address need to be converted\\n    *  @return      Converted bytes from address\\n    */\\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\\n        assembly {\\n            // Get a location of some free memory and store it in result as\\n            // Solidity does for memory variables.\\n            bs := mload(0x40)\\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\\n            mstore(bs, 0x14)\\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\\n            mstore(add(bs, 0x20), shl(96, _addr))\\n            // Update the free-memory pointer by padding our last write location to 32 bytes\\n            mstore(0x40, add(bs, 0x40))\\n       }\\n    }\\n\\n    /* @notice          Do hash leaf as the multi-chain does\\n    *  @param _data     Data in bytes format\\n    *  @return          Hashed value in bytes32 format\\n    */\\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(byte(0x0), _data));\\n    }\\n\\n    /* @notice          Do hash children as the multi-chain does\\n    *  @param _l        Left node\\n    *  @param _r        Right node\\n    *  @return          Hashed value in bytes32 format\\n    */\\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\\n    }\\n\\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\\n    *  @param _preBytes     The bytes stored in storage\\n    *  @param _postBytes    The bytes stored in memory\\n    *  @return              Bool type indicating if they are equal\\n    */\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes_slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // fslot can contain both the length and contents of the array\\n                // if slength < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                // slength != 0\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes_slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\\n    *  @param _bytes        The original bytes needs to be sliced\\n    *  @param _start        The index of _bytes for the start of sliced bytes\\n    *  @param _length       The index of _bytes for the end of sliced bytes\\n    *  @return              The sliced bytes\\n    */\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                // lengthmod <= _length % 32\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m\\n    *  @param _keepers      The array consists of serveral address\\n    *  @param _signers      Some specific addresses to be looked into\\n    *  @param _m            The number requirement paramter\\n    *  @return              True means containment, false meansdo do not contain.\\n    */\\n    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\\n        uint m = 0;\\n        for(uint i = 0; i < _signers.length; i++){\\n            for (uint j = 0; j < _keepers.length; j++) {\\n                if (_signers[i] == _keepers[j]) {\\n                    m++;\\n                    delete _keepers[j];\\n                }\\n            }\\n        }\\n        return m >= _m;\\n    }\\n\\n    /* @notice              TODO\\n    *  @param key\\n    *  @return\\n    */\\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\\n         require(key.length >= 67, \\\"key lenggh is too short\\\");\\n         newkey = slice(key, 0, 35);\\n         if (uint8(key[66]) % 2 == 0){\\n             newkey[2] = byte(0x02);\\n         } else {\\n             newkey[2] = byte(0x03);\\n         }\\n         return newkey;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(\\n        IERC20 token,\\n        bytes memory data\\n    )\\n        internal\\n    {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(isContract(address(token)), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swthToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ccmProxyAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_counterpartChainId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"txArgs\",\"type\":\"bytes\"}],\"name\":\"LockEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"txArgs\",\"type\":\"bytes\"}],\"name\":\"UnlockEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALT_PREFIX\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"addExtension\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccmProxy\",\"outputs\":[{\"internalType\":\"contract CCMProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"counterpartChainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swthAddress\",\"type\":\"bytes\"}],\"name\":\"createWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receivingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"extensionTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"extensions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swthAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_bytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"getWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_targetProxyHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_toAssetHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_feeAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_walletAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_targetProxyHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_toAssetHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_feeAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"_rs\",\"type\":\"bytes32[]\"}],\"name\":\"lockFromWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"registerAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"removeExtension\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"seenMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swthToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LockProxy", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000250b211ee44459dad5cd3bca803dd6a7ecb5d46c000000000000000000000000abd7f7b89c5fd5d0aef06165f8173b1b83d7d5c90000000000000000000000000000000000000000000000000000000000000005", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}