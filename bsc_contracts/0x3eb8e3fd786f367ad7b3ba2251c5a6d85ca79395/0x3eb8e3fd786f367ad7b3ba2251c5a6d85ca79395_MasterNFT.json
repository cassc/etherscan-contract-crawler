{"SourceCode": "//SPDX-License-Identifier:MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary Counters {\r\n    struct Counter {\r\n        uint256 _value;\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n\r\ninterface IAccountRegistry {\r\n    event AccountCreated(\r\n        address account,\r\n        address implementation,\r\n        uint256 chainId,\r\n        address tokenContract,\r\n        uint256 tokenId,\r\n        uint256 salt\r\n    );\r\n\r\n    function createAccount(\r\n        address implementation,\r\n        uint256 chainId,\r\n        address tokenContract,\r\n        uint256 tokenId,\r\n        uint256 salt,\r\n        bytes calldata initData\r\n    ) external returns (address);\r\n\r\n    function account(\r\n        address implementation,\r\n        uint256 chainId,\r\n        address tokenContract,\r\n        uint256 tokenId,\r\n        uint256 salt\r\n    ) external view returns (address);\r\n}\r\n\r\ninterface ERC721Interface {\r\n    function ERC721Mint(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        string memory _tokenURI\r\n    ) external;\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function burn(uint256 tokenId) external;\r\n}\r\n\r\ninterface ERC1155Interface {\r\n    function ERC1155Mint(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        uint256 _tokenAmount,\r\n        bytes memory _data,\r\n        string memory _uri\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function balanceOf(\r\n        address account,\r\n        uint256 id\r\n    ) external view returns (uint256);\r\n\r\n    function uri(uint256 tokenId) external view returns (string memory);\r\n\r\n    function burn(address account, uint256 id, uint256 value) external;\r\n}\r\n\r\nerror Already_Sold();\r\nerror Payment_Error();\r\nerror ERC721_Token_Should_1();\r\nerror Atleast_One_Token();\r\nerror Empty_URI();\r\nerror Price_Mustbe_greater();\r\nerror No_Token();\r\nerror Not_Enough_Token();\r\nerror Type_Error();\r\nerror Withdraw_Failed();\r\nerror Not_Updater();\r\nerror FreeMint_Execeds();\r\nerror Not_Owner();\r\nerror Upkeep_Not_Needed();\r\nerror One_Token();\r\nerror Not_NFT_Owner();\r\nerror Only_NFT_Contract();\r\nerror NotListedReseller();\r\nerror Address_Zero();\r\nerror Length_Error();\r\nerror NotListedPaymentMethod();\r\nerror OnlyAdminCanCall();\r\n\r\ncontract MasterNFT is Ownable {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter private tokenId;\r\n    Counters.Counter private tokenSold;\r\n    Counters.Counter private resellId;\r\n    Counters.Counter private reSold;\r\n    uint256 private listingFee;\r\n    address private metadataUpdater;\r\n    address private ERC1155Address;\r\n    address private ERC721Address;\r\n    address private accountAddress;\r\n\r\n    IAccountRegistry private TBARegistry;\r\n    ERC1155Interface private ERC1155Token;\r\n    ERC721Interface private ERC721Token;\r\n    IERC20 private wisdomToken;\r\n    IERC20 private LRNToken;\r\n\r\n    uint256 private stableToLRNPrice;\r\n\r\n    mapping(uint256 => mapping(address => bool)) private isOwnerOfToken;\r\n    mapping(uint256 => mapping(address => uint256)) private EDAofToken;\r\n    mapping(address => bool) private isListedReseller;\r\n    mapping(address => bool) private isListedPaymentMethod;\r\n    mapping(address => address) private defaultPaymentMethod;\r\n    mapping(address => bool) private isAdmin;\r\n\r\n    enum AccessLevel {\r\n        PARTNER,\r\n        SUBSCRIBER\r\n    }\r\n    struct accessKey {\r\n        address Address;\r\n        bytes32 AccessPass;\r\n        string Api;\r\n    }\r\n\r\n    struct NFTMetadata {\r\n        TokenType tokenType;\r\n        membershipType typeOfMember;\r\n        uint256 expireDate;\r\n        accessKey acceses;\r\n        uint256 discount;\r\n        AccessLevel accessLevel;\r\n        uint256 mintPrice;\r\n        uint256 freeMint;\r\n        uint256 tokenId;\r\n        string REAddress;\r\n    }\r\n\r\n    enum membershipType {\r\n        GENERAL,\r\n        PROFESSIONAL,\r\n        VIP,\r\n        THOUGHTLEADER,\r\n        ENTERPRISE,\r\n        REALESTATE,\r\n        CURRENCY\r\n    }\r\n    enum TokenType {\r\n        ERC721,\r\n        ERC1155\r\n    }\r\n    struct MarketItem {\r\n        uint256 tokenId;\r\n        address seller;\r\n        address owner;\r\n        TokenType tokenType;\r\n        uint256 price;\r\n        bool sold;\r\n        uint256 couponPrice;\r\n        uint256 numberOfToken;\r\n    }\r\n\r\n    struct Subscription {\r\n        uint256 tokenId;\r\n        address subscriber;\r\n    }\r\n    Subscription[] private subscriptionList;\r\n    address[] private adminList;\r\n\r\n    mapping(uint256 => MarketItem) private tokenIdToMarketItem;\r\n    mapping(uint256 => MarketItem) private resellIdToMarketItem;\r\n    mapping(uint256 => NFTMetadata) private tokenIdToNFTMetadata;\r\n    mapping(address => mapping(uint256 => NFTMetadata))\r\n        private addressToIDToNFTMetadata;\r\n    mapping(uint256 => mapping(address => uint256))\r\n        private tokenIdToUserClaimedAt;\r\n    mapping(address => bool) private isMember;\r\n    mapping(uint256 => mapping(address => bool)) private subscriptionStatus;\r\n\r\n    event SubscriptionStatusUpdated(\r\n        uint256 indexed tokenId,\r\n        bool indexed status,\r\n        address indexed updater\r\n    );\r\n\r\n    event MembershipNFTMinted(NFTMetadata indexed metadata, uint256 price);\r\n\r\n    event BuyNFT(\r\n        address indexed buyer,\r\n        uint256 indexed tokenId,\r\n        uint256 indexed numberOfToken\r\n    );\r\n\r\n    event ManualTransfer(\r\n        address indexed recepiant,\r\n        uint256 tokenId,\r\n        uint256 indexed numberOfToken,\r\n        bool indexed isReseller\r\n    );\r\n\r\n    event TransferHelper(\r\n        address[] indexed addresses,\r\n        uint256[] indexed tokenIds,\r\n        address indexed from\r\n    );\r\n\r\n    event UpdateTokenContract(\r\n        address indexed address721,\r\n        address indexed address1155\r\n    );\r\n\r\n    event ListingFeeUpdated(uint256 indexed newFee);\r\n\r\n    event ListedPaymentMethod(address[] indexed Tokens, bool[] indexed modes);\r\n\r\n    event UserDefaultPaymentMethod(address indexed Token);\r\n\r\n    modifier updater() {\r\n        if (msg.sender != metadataUpdater) revert Not_Updater();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        if (!isAdmin[msg.sender]) revert OnlyAdminCanCall();\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _wisdomToken,\r\n        address _lrnToken,\r\n        address[] memory _paymentTokens,\r\n        uint256 _stlPrice,\r\n        uint256 _lFee,\r\n        address _erc1155,\r\n        address _erc721\r\n    ) {\r\n        ERC1155Address = _erc1155;\r\n        ERC721Address = _erc721;\r\n        ERC1155Token = ERC1155Interface(ERC1155Address);\r\n        ERC721Token = ERC721Interface(ERC721Address);\r\n        wisdomToken = IERC20(_wisdomToken);\r\n        LRNToken = IERC20(_lrnToken);\r\n        stableToLRNPrice = _stlPrice;\r\n        isListedPaymentMethod[_wisdomToken] = true;\r\n        isListedPaymentMethod[_lrnToken] = true;\r\n        listingFee = _lFee;\r\n        isAdmin[msg.sender] = true;\r\n        adminList.push(msg.sender);\r\n        for (uint256 i = 0; i < _paymentTokens.length; i++) {\r\n            isListedPaymentMethod[_paymentTokens[i]] = true;\r\n        }\r\n    }\r\n\r\n    function addAdminAddress(address[] memory _admins) public onlyOwner {\r\n        for (uint256 i = 0; i < _admins.length; i++) {\r\n            isAdmin[_admins[i]] = true;\r\n            adminList.push(_admins[i]);\r\n        }\r\n    }\r\n\r\n    function removeAdminAddress(address _admin) public onlyOwner {\r\n        isAdmin[_admin] = false;\r\n\r\n        for (uint256 i = 0; i < adminList.length; i++) {\r\n            if (adminList[i] == _admin) {\r\n                adminList[i] = adminList[adminList.length - 1];\r\n\r\n                adminList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateSubscriptionStatus(uint256 _tokenId, bool _status) public {\r\n        if (!isOwnerOfToken[_tokenId][msg.sender]) revert Not_Owner();\r\n        subscriptionStatus[_tokenId][msg.sender] = _status;\r\n        if (_status == true) {\r\n            subscriptionList.push(Subscription(_tokenId, msg.sender));\r\n        }\r\n        emit SubscriptionStatusUpdated(_tokenId, _status, msg.sender);\r\n    }\r\n\r\n    function mintMembershipNFT(\r\n        NFTMetadata memory _metadata,\r\n        uint256 _numberOfToken,\r\n        string memory _tokenURI,\r\n        uint256 _nftPrice,\r\n        uint256 _couponPrice,\r\n        bytes memory _data\r\n    ) public onlyAdmin {\r\n        if (_numberOfToken == 0) revert Atleast_One_Token();\r\n        if (_metadata.tokenType == TokenType.ERC721 && _numberOfToken > 1)\r\n            revert ERC721_Token_Should_1();\r\n        if (_metadata.typeOfMember != membershipType.CURRENCY && _nftPrice == 0)\r\n            revert Price_Mustbe_greater();\r\n        tokenId.increment();\r\n        uint256 _tokenId = tokenId.current();\r\n        NFTMetadata memory metadata = _metadata;\r\n        metadata.tokenId = _tokenId;\r\n        tokenIdToNFTMetadata[_tokenId] = metadata;\r\n        if (metadata.tokenType == TokenType.ERC721) {\r\n            ERC721Token.ERC721Mint(address(this), _tokenId, _tokenURI);\r\n        } else {\r\n            ERC1155Token.ERC1155Mint(\r\n                address(this),\r\n                _tokenId,\r\n                _numberOfToken,\r\n                _data,\r\n                _tokenURI\r\n            );\r\n        }\r\n        createMarketItem(\r\n            _tokenId,\r\n            msg.sender,\r\n            address(this),\r\n            _nftPrice,\r\n            _metadata.tokenType,\r\n            _numberOfToken,\r\n            _couponPrice,\r\n            false\r\n        );\r\n        emit MembershipNFTMinted(_metadata, _nftPrice);\r\n    }\r\n\r\n    function createMarketItem(\r\n        uint256 _id,\r\n        address _seller,\r\n        address _owner,\r\n        uint256 _price,\r\n        TokenType _tokenType,\r\n        uint256 _numberOfToken,\r\n        uint256 _couponPrice,\r\n        bool isResell\r\n    ) private {\r\n        if (_owner == address(0)) revert Address_Zero();\r\n        if (_price <= 0) revert Payment_Error();\r\n        if (isResell) {\r\n            resellIdToMarketItem[resellId.current()] = MarketItem(\r\n                _id,\r\n                _seller,\r\n                _owner,\r\n                _tokenType,\r\n                _price,\r\n                false,\r\n                _couponPrice,\r\n                _numberOfToken\r\n            );\r\n        } else {\r\n            if (_id > tokenId.current()) revert No_Token();\r\n            tokenIdToMarketItem[_id] = MarketItem(\r\n                _id,\r\n                _seller,\r\n                _owner,\r\n                _tokenType,\r\n                _price,\r\n                false,\r\n                _couponPrice,\r\n                _numberOfToken\r\n            );\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function buyNFT(\r\n        uint256 _id,\r\n        uint256 _numberOfToken,\r\n        bool isListed\r\n    ) external {\r\n        MarketItem storage nft;\r\n        if (isListed == true) {\r\n            nft = resellIdToMarketItem[_id];\r\n        } else {\r\n            nft = tokenIdToMarketItem[_id];\r\n        }\r\n        uint256 _tokenId = nft.tokenId;\r\n        if (nft.sold == true) revert Already_Sold();\r\n        if (_numberOfToken != 1) revert One_Token();\r\n        if (nft.price > 0) {\r\n            bool success;\r\n            if (defaultPaymentMethod[msg.sender] != address(0)) {\r\n                uint256 price;\r\n                if (defaultPaymentMethod[msg.sender] == address(LRNToken)) {\r\n                    price = (nft.price * stableToLRNPrice) / 10 ** 18;\r\n                } else {\r\n                    price = nft.price;\r\n                }\r\n                success = IERC20(defaultPaymentMethod[msg.sender]).transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    price\r\n                );\r\n            } else {\r\n                success = wisdomToken.transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    nft.price\r\n                );\r\n            }\r\n            if (!success) revert Payment_Error();\r\n        }\r\n        NFTMetadata storage metadata = tokenIdToNFTMetadata[_tokenId];\r\n        if (!isListed) {\r\n            EDAofToken[_tokenId][msg.sender] =\r\n                block.timestamp +\r\n                metadata.expireDate;\r\n        }\r\n        if (defaultPaymentMethod[msg.sender] != address(0)) {\r\n            uint256 price;\r\n            if (defaultPaymentMethod[msg.sender] == address(LRNToken)) {\r\n                price = (nft.price * stableToLRNPrice) / 10 ** 18;\r\n            } else {\r\n                price = nft.price;\r\n            }\r\n            if (isListed) {\r\n                uint256 applyR = (price * (100 - listingFee)) / 100;\r\n                IERC20(defaultPaymentMethod[msg.sender]).transfer(\r\n                    nft.seller,\r\n                    applyR\r\n                );\r\n            } else {\r\n                IERC20(defaultPaymentMethod[msg.sender]).transfer(\r\n                    nft.seller,\r\n                    price\r\n                );\r\n            }\r\n        } else {\r\n            if (isListed) {\r\n                uint256 applyR = (nft.price * (100 - listingFee)) / 100;\r\n                wisdomToken.transfer(nft.seller, applyR);\r\n            } else {\r\n                wisdomToken.transfer(nft.seller, nft.price);\r\n            }\r\n        }\r\n        if (nft.tokenType == TokenType.ERC1155) {\r\n            nft.numberOfToken -= _numberOfToken;\r\n            if (nft.numberOfToken == 0) {\r\n                nft.sold = true;\r\n                nft.price = 0;\r\n                nft.owner = address(0);\r\n                if (isListed) {\r\n                    reSold.increment();\r\n                } else {\r\n                    tokenSold.increment();\r\n                }\r\n            }\r\n        } else {\r\n            nft.sold = true;\r\n            nft.owner = msg.sender;\r\n            nft.seller = address(0);\r\n            nft.price = 0;\r\n            if (isListed) {\r\n                reSold.increment();\r\n            } else {\r\n                tokenSold.increment();\r\n            }\r\n        }\r\n        isOwnerOfToken[_tokenId][msg.sender] = true;\r\n\r\n        isMember[msg.sender] = true;\r\n        addressToIDToNFTMetadata[msg.sender][_tokenId] = metadata;\r\n        tokenIdToUserClaimedAt[_tokenId][msg.sender] = block.timestamp;\r\n        if (nft.tokenType == TokenType.ERC721) {\r\n            ERC721Token.transferFrom(address(this), msg.sender, _tokenId);\r\n        } else {\r\n            ERC1155Token.safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                _tokenId,\r\n                _numberOfToken,\r\n                \"0x00\"\r\n            );\r\n        }\r\n        emit BuyNFT(msg.sender, _tokenId, _numberOfToken);\r\n    }\r\n\r\n    function manualTransfer(\r\n        uint256 _tokenId,\r\n        uint256 _numberOfToken,\r\n        address _to,\r\n        bool isReseller\r\n    ) public onlyAdmin {\r\n        MarketItem storage nft = tokenIdToMarketItem[_tokenId];\r\n        if (nft.sold == true) revert Already_Sold();\r\n        if (isReseller) {\r\n            isListedReseller[_to] = true;\r\n        }\r\n        if (nft.tokenType == TokenType.ERC1155) {\r\n            nft.numberOfToken -= _numberOfToken;\r\n            if (nft.numberOfToken == 0) {\r\n                nft.sold = true;\r\n                nft.price = 0;\r\n                tokenSold.increment();\r\n                nft.owner = address(0);\r\n            }\r\n        } else {\r\n            nft.sold = true;\r\n            nft.owner = _to;\r\n            nft.seller = address(0);\r\n            nft.price = 0;\r\n            tokenSold.increment();\r\n        }\r\n        isOwnerOfToken[_tokenId][_to] = true;\r\n        NFTMetadata storage metadata = tokenIdToNFTMetadata[_tokenId];\r\n        EDAofToken[_tokenId][_to] = block.timestamp + metadata.expireDate;\r\n\r\n        isMember[_to] = true;\r\n        addressToIDToNFTMetadata[_to][_tokenId] = metadata;\r\n        if (nft.tokenType == TokenType.ERC721) {\r\n            ERC721Token.transferFrom(address(this), _to, _tokenId);\r\n        } else {\r\n            ERC1155Token.safeTransferFrom(\r\n                address(this),\r\n                _to,\r\n                _tokenId,\r\n                _numberOfToken,\r\n                \"0x00\"\r\n            );\r\n        }\r\n        emit ManualTransfer(_to, _tokenId, _numberOfToken, isReseller);\r\n    }\r\n\r\n    function transferHelper(\r\n        address[] memory _addresses,\r\n        uint256[] memory _tokenIds\r\n    ) public {\r\n        if (!isListedReseller[msg.sender]) {\r\n            revert NotListedReseller();\r\n        }\r\n        require(_addresses.length == _tokenIds.length, \"length error\");\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            address to = _addresses[i];\r\n            uint256 tId = _tokenIds[i];\r\n            uint256 numOfToken = 1;\r\n            MarketItem storage nft = tokenIdToMarketItem[tId];\r\n            if (nft.tokenType == TokenType.ERC1155) {\r\n                if (ERC1155Token.balanceOf(msg.sender, tId) == 1) {\r\n                    isOwnerOfToken[tId][msg.sender] = false;\r\n                }\r\n                if (ERC1155Token.balanceOf(msg.sender, tId) < numOfToken) {\r\n                    revert Not_Enough_Token();\r\n                }\r\n            } else if (nft.tokenType == TokenType.ERC721) {\r\n                isOwnerOfToken[tId][msg.sender] = false;\r\n                if (nft.owner != msg.sender) revert Not_Owner();\r\n            }\r\n            isOwnerOfToken[tId][to] = true;\r\n            NFTMetadata storage metadata = tokenIdToNFTMetadata[tId];\r\n            EDAofToken[tId][to] = block.timestamp + metadata.expireDate;\r\n            isMember[to] = true;\r\n            addressToIDToNFTMetadata[to][tId] = metadata;\r\n            if (nft.tokenType == TokenType.ERC721) {\r\n                ERC721Token.transferFrom(msg.sender, to, tId);\r\n            } else {\r\n                ERC1155Token.safeTransferFrom(\r\n                    msg.sender,\r\n                    to,\r\n                    tId,\r\n                    numOfToken,\r\n                    \"0x00\"\r\n                );\r\n            }\r\n        }\r\n\r\n        emit TransferHelper(_addresses, _tokenIds, msg.sender);\r\n    }\r\n\r\n    function resellNFT(\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        uint256 _numberOfToken\r\n    ) public {\r\n        isOwnerOfToken[_tokenId][msg.sender] = false;\r\n        MarketItem memory nft = tokenIdToMarketItem[_tokenId];\r\n        resellId.increment();\r\n        createMarketItem(\r\n            _tokenId,\r\n            msg.sender,\r\n            address(this),\r\n            _price,\r\n            nft.tokenType,\r\n            _numberOfToken,\r\n            nft.couponPrice,\r\n            true\r\n        );\r\n        if (nft.tokenType == TokenType.ERC721) {\r\n            ERC721Token.transferFrom(msg.sender, address(this), _tokenId);\r\n        } else {\r\n            ERC1155Token.safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _tokenId,\r\n                _numberOfToken,\r\n                \"0x00\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function burnNFT(\r\n        uint256 _tokenId,\r\n        uint256 _numberOfToken\r\n    ) public onlyAdmin {\r\n        NFTMetadata storage nft = tokenIdToNFTMetadata[_tokenId];\r\n        if (nft.tokenType == TokenType.ERC721) {\r\n            ERC721Token.burn(_tokenId);\r\n        } else {\r\n            ERC1155Token.burn(address(this), _tokenId, _numberOfToken);\r\n        }\r\n        delete tokenIdToNFTMetadata[_tokenId];\r\n        delete tokenIdToMarketItem[_tokenId];\r\n    }\r\n\r\n    function updateTokenContract(address _721, address _1155) public onlyOwner {\r\n        ERC721Address = _721;\r\n        ERC721Token = ERC721Interface(ERC721Address);\r\n        ERC1155Address = _1155;\r\n        ERC1155Token = ERC1155Interface(ERC1155Address);\r\n        emit UpdateTokenContract(_721, _1155);\r\n    }\r\n\r\n    function setlistingFee(uint256 _feeP) public onlyOwner {\r\n        listingFee = _feeP;\r\n        emit ListingFeeUpdated(_feeP);\r\n    }\r\n\r\n    function setWisdom(address _wisdom) public onlyOwner {\r\n        wisdomToken = IERC20(_wisdom);\r\n    }\r\n\r\n    function setLRNTokenCPrice(uint256 _price) public onlyOwner {\r\n        stableToLRNPrice = _price;\r\n    }\r\n\r\n    function setListedPaymentMethod(\r\n        address[] memory _tokens,\r\n        bool[] memory _modes\r\n    ) public onlyOwner {\r\n        if (_tokens.length != _modes.length) {\r\n            revert Length_Error();\r\n        }\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            isListedPaymentMethod[_tokens[i]] = _modes[i];\r\n        }\r\n        emit ListedPaymentMethod(_tokens, _modes);\r\n    }\r\n\r\n    function setUserDefaultPaymentMethod(address _token) public {\r\n        if (!isListedPaymentMethod[_token]) {\r\n            revert NotListedPaymentMethod();\r\n        }\r\n        defaultPaymentMethod[msg.sender] = _token;\r\n\r\n        emit UserDefaultPaymentMethod(_token);\r\n    }\r\n\r\n    function fetchMyNFTs() public view returns (MarketItem[] memory) {\r\n        uint256 totalItemCount = tokenId.current();\r\n        uint256 itemCount = 0;\r\n        uint256 currentIndex = 0;\r\n\r\n        for (uint256 i = 0; i < totalItemCount; i++) {\r\n            if (isOwnerOfToken[i + 1][msg.sender]) {\r\n                itemCount += 1;\r\n            }\r\n        }\r\n        MarketItem[] memory items = new MarketItem[](itemCount);\r\n        for (uint256 i = 0; i < totalItemCount; i++) {\r\n            if (isOwnerOfToken[i + 1][msg.sender]) {\r\n                uint256 currentId = i + 1;\r\n                MarketItem storage currentItem = tokenIdToMarketItem[currentId];\r\n                items[currentIndex] = currentItem;\r\n                currentIndex += 1;\r\n            }\r\n        }\r\n        return items;\r\n    }\r\n\r\n    function fetchMWNFTs()\r\n        public\r\n        view\r\n        returns (uint256[] memory, uint256[] memory, address[] memory)\r\n    {\r\n        uint256 total = tokenId.current();\r\n        uint256 iCount = 0;\r\n        uint256 currentIndex = 0;\r\n        for (uint256 i = 0; i < total; i++) {\r\n            if (isOwnerOfToken[i + 1][msg.sender]) {\r\n                iCount += 1;\r\n            }\r\n        }\r\n        uint256[] memory tokenIds = new uint256[](iCount);\r\n        uint256[] memory numberOfTokens = new uint256[](iCount);\r\n        address[] memory tokenAddress = new address[](iCount);\r\n        for (uint256 i = 0; i < total; i++) {\r\n            if (isOwnerOfToken[i + 1][msg.sender]) {\r\n                uint256 currentId = i + 1;\r\n                tokenIds[currentIndex] = currentId;\r\n                MarketItem storage currentItem = tokenIdToMarketItem[currentId];\r\n                if (currentItem.tokenType == TokenType.ERC1155) {\r\n                    numberOfTokens[currentIndex] = ERC1155Token.balanceOf(\r\n                        msg.sender,\r\n                        currentId\r\n                    );\r\n                    tokenAddress[currentIndex] = ERC1155Address;\r\n                } else {\r\n                    numberOfTokens[currentIndex] = 1;\r\n                    tokenAddress[currentIndex] = ERC721Address;\r\n                }\r\n                currentIndex += 1;\r\n            }\r\n        }\r\n        return (tokenIds, numberOfTokens, tokenAddress);\r\n    }\r\n\r\n    function setMetadataUpdater(address _updater) external {\r\n        if (metadataUpdater == address(0)) {\r\n            metadataUpdater = _updater;\r\n        } else {\r\n            if (msg.sender != owner()) revert Not_Owner();\r\n            metadataUpdater = _updater;\r\n        }\r\n    }\r\n\r\n    function updateMI(\r\n        uint256 _tokenId,\r\n        address _nOwner,\r\n        address _seller\r\n    ) public {\r\n        if (msg.sender != ERC721Address || msg.sender != ERC1155Address)\r\n            revert Only_NFT_Contract();\r\n        MarketItem storage item = tokenIdToMarketItem[_tokenId];\r\n        item.owner = _nOwner;\r\n        item.seller = _seller;\r\n    }\r\n\r\n    function withdrawAsset(\r\n        address _ERC20token,\r\n        address payable _to\r\n    ) public onlyOwner {\r\n        uint256 tokenBalance = IERC20(_ERC20token).balanceOf(address(this));\r\n        if (tokenBalance > 0) {\r\n            IERC20(_ERC20token).transfer(_to, tokenBalance);\r\n        }\r\n        (bool success, ) = _to.call{value: address(this).balance}(\"\");\r\n        if (!success) revert Withdraw_Failed();\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external pure returns (bytes4) {\r\n        return\r\n            bytes4(\r\n                keccak256(\r\n                    \"onERC1155Received(address,address,uint256,uint256,bytes)\"\r\n                )\r\n            );\r\n    }\r\n\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) external pure returns (bytes4) {\r\n        return\r\n            bytes4(\r\n                keccak256(\"onERC721Received(address,address,uint256,bytes)\")\r\n            );\r\n    }\r\n\r\n    function updateMetadata(\r\n        uint256 _tokenId,\r\n        address _owner\r\n    ) external updater returns (bool) {\r\n        NFTMetadata storage newMetadata = addressToIDToNFTMetadata[_owner][\r\n            _tokenId\r\n        ];\r\n        if (\r\n            (tokenIdToUserClaimedAt[_tokenId][_owner] + 30 days) <\r\n            block.timestamp\r\n        ) {\r\n            uint256 expireTime = EDAofToken[_tokenId][_owner];\r\n            if (expireTime > block.timestamp + 30 days) {\r\n                tokenIdToUserClaimedAt[_tokenId][_owner] = block.timestamp;\r\n                newMetadata.freeMint = tokenIdToNFTMetadata[_tokenId].freeMint;\r\n            }\r\n        }\r\n        if (newMetadata.freeMint < 1) {\r\n            // revert FreeMint_Execeds();\r\n            return false;\r\n        } else {\r\n            newMetadata.freeMint = newMetadata.freeMint - 1;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function fetchMarketNft() public view returns (MarketItem[] memory) {\r\n        uint256 totalItem = tokenId.current();\r\n        uint256 unsoldItem = totalItem - tokenSold.current();\r\n        uint256 currentIndex = 0;\r\n        MarketItem[] memory items = new MarketItem[](unsoldItem);\r\n        for (uint256 i = 0; i < totalItem; i++) {\r\n            if (tokenIdToMarketItem[i + 1].owner == address(this)) {\r\n                uint256 currentId = i + 1;\r\n                MarketItem storage currentItem = tokenIdToMarketItem[currentId];\r\n                items[currentIndex] = currentItem;\r\n                currentIndex += 1;\r\n            }\r\n        }\r\n        return items;\r\n    }\r\n\r\n    function fetchListedNft() public view returns (MarketItem[] memory) {\r\n        uint256 totalItem = resellId.current();\r\n        uint256 unsoldItem = totalItem - reSold.current();\r\n        uint256 currentIndex = 0;\r\n        MarketItem[] memory items = new MarketItem[](unsoldItem);\r\n        for (uint256 i = 0; i < totalItem; i++) {\r\n            if (resellIdToMarketItem[i + 1].owner == address(this)) {\r\n                uint256 currentId = i + 1;\r\n                MarketItem storage currentItem = resellIdToMarketItem[\r\n                    currentId\r\n                ];\r\n                items[currentIndex] = currentItem;\r\n                currentIndex += 1;\r\n            }\r\n        }\r\n        return items;\r\n    }\r\n\r\n    function getIsAdmin(address _wallet) public view returns (bool) {\r\n        return isAdmin[_wallet];\r\n    }\r\n\r\n    function getAdminList() public view returns (address[] memory) {\r\n        return adminList;\r\n    }\r\n\r\n    function getTokenIdToMetadata(\r\n        uint256 _tokenId\r\n    ) external view returns (NFTMetadata memory) {\r\n        return tokenIdToNFTMetadata[_tokenId];\r\n    }\r\n\r\n    function getUserOwnedNFTId(\r\n        address _user\r\n    ) public view returns (uint256[] memory) {\r\n        uint256[] memory ids = new uint256[](tokenId.current());\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = 1; i <= tokenId.current(); i++) {\r\n            if (isOwnerOfToken[i][_user]) {\r\n                NFTMetadata memory item = tokenIdToNFTMetadata[i];\r\n                if (\r\n                    item.typeOfMember != membershipType.REALESTATE &&\r\n                    item.typeOfMember != membershipType.CURRENCY\r\n                ) {\r\n                    ids[count] = i;\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n        assembly {\r\n            mstore(ids, count)\r\n        }\r\n\r\n        for (uint256 i = 0; i < count - 1; i++) {\r\n            for (uint256 j = i + 1; j < count; j++) {\r\n                if (ids[i] < ids[j]) {\r\n                    uint256 temp = ids[i];\r\n                    ids[i] = ids[j];\r\n                    ids[j] = temp;\r\n                }\r\n            }\r\n        }\r\n\r\n        return ids;\r\n    }\r\n\r\n    function getAddressToTokenIdToMetadata(\r\n        address _owner,\r\n        uint256 _tokenId\r\n    ) external view returns (NFTMetadata memory) {\r\n        return addressToIDToNFTMetadata[_owner][_tokenId];\r\n    }\r\n\r\n    function getTokenIdToMarketItem(\r\n        uint256 _tokenId\r\n    ) external view returns (MarketItem memory) {\r\n        return tokenIdToMarketItem[_tokenId];\r\n    }\r\n\r\n    function getTokenId() external view returns (uint256) {\r\n        return tokenId.current();\r\n    }\r\n\r\n    function getTokenContract(TokenType _type) public view returns (address) {\r\n        if (_type == TokenType.ERC721) {\r\n            return ERC721Address;\r\n        } else {\r\n            return ERC1155Address;\r\n        }\r\n    }\r\n\r\n    function getTokenURI(\r\n        TokenType _tokenType,\r\n        uint256 _tokenId\r\n    ) public view returns (string memory) {\r\n        if (_tokenType == TokenType.ERC721) {\r\n            return ERC721Token.tokenURI(_tokenId);\r\n        } else {\r\n            return ERC1155Token.uri(_tokenId);\r\n        }\r\n    }\r\n\r\n    function getIsMember(address _isMember) public view returns (bool) {\r\n        return isMember[_isMember];\r\n    }\r\n\r\n    function getIsOwnerOfToken(\r\n        uint256 _id,\r\n        address _owner\r\n    ) public view returns (bool) {\r\n        return isOwnerOfToken[_id][_owner];\r\n    }\r\n\r\n    function getEDAofToken(\r\n        uint256 _id,\r\n        address _owner\r\n    ) public view returns (uint256) {\r\n        return EDAofToken[_id][_owner];\r\n    }\r\n\r\n    function increaseValidity(uint256 _id) public {\r\n        NFTMetadata storage metadata = tokenIdToNFTMetadata[_id];\r\n        MarketItem storage nft = tokenIdToMarketItem[_id];\r\n        bool success;\r\n        if (defaultPaymentMethod[msg.sender] != address(0)) {\r\n            success = IERC20(defaultPaymentMethod[msg.sender]).transfer(\r\n                owner(),\r\n                nft.price\r\n            );\r\n        } else {\r\n            success = wisdomToken.transfer(owner(), nft.price);\r\n        }\r\n        if (success) {\r\n            EDAofToken[_id][msg.sender] = block.timestamp + metadata.expireDate;\r\n        } else {\r\n            revert Payment_Error();\r\n        }\r\n    }\r\n\r\n    function balanceOf(\r\n        TokenType _tokenType,\r\n        address _owner,\r\n        uint256 _tokenId\r\n    ) public view returns (uint256) {\r\n        if (_tokenType == TokenType.ERC721) {\r\n            return ERC721Token.balanceOf(_owner);\r\n        } else {\r\n            return ERC1155Token.balanceOf(_owner, _tokenId);\r\n        }\r\n    }\r\n\r\n    function getStableToLRNPrice() public view returns (uint256) {\r\n        return stableToLRNPrice;\r\n    }\r\n\r\n    function getPreTBA(\r\n        address _implementation,\r\n        uint256 _chainId,\r\n        address _tokenContract,\r\n        uint256 _tokenId,\r\n        uint256 _salt\r\n    ) public view returns (address) {\r\n        return\r\n            TBARegistry.account(\r\n                _implementation,\r\n                _chainId,\r\n                _tokenContract,\r\n                _tokenId,\r\n                _salt\r\n            );\r\n    }\r\n\r\n    function createTBA(\r\n        address _implementation,\r\n        uint256 _chainId,\r\n        address _tokenContract,\r\n        uint256 _tokenId,\r\n        uint256 _salt,\r\n        bytes calldata _initData\r\n    ) public returns (address) {\r\n        return\r\n            TBARegistry.createAccount(\r\n                _implementation,\r\n                _chainId,\r\n                _tokenContract,\r\n                _tokenId,\r\n                _salt,\r\n                _initData\r\n            );\r\n    }\r\n\r\n    function getIsListedPaymentMethod(\r\n        address _token\r\n    ) public view returns (bool) {\r\n        return isListedPaymentMethod[_token];\r\n    }\r\n\r\n    function getUserDefaultPaymentMethod(\r\n        address _user\r\n    ) public view returns (address) {\r\n        return defaultPaymentMethod[_user];\r\n    }\r\n\r\n    function getSubscriptionList() public view returns (Subscription[] memory) {\r\n        return subscriptionList;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wisdomToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lrnToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_paymentTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_stlPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc1155\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc721\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Address_Zero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Already_Sold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Atleast_One_Token\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721_Token_Should_1\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Length_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"No_Token\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotListedPaymentMethod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotListedReseller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Not_Enough_Token\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Not_Owner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Not_Updater\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"One_Token\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAdminCanCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Only_NFT_Contract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Payment_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Price_Mustbe_greater\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Withdraw_Failed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"numberOfToken\",\"type\":\"uint256\"}],\"name\":\"BuyNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"Tokens\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"bool[]\",\"name\":\"modes\",\"type\":\"bool[]\"}],\"name\":\"ListedPaymentMethod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"ListingFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recepiant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"numberOfToken\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isReseller\",\"type\":\"bool\"}],\"name\":\"ManualTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum MasterNFT.membershipType\",\"name\":\"typeOfMember\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expireDate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"AccessPass\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"Api\",\"type\":\"string\"}],\"internalType\":\"struct MasterNFT.accessKey\",\"name\":\"acceses\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"enum MasterNFT.AccessLevel\",\"name\":\"accessLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"REAddress\",\"type\":\"string\"}],\"indexed\":true,\"internalType\":\"struct MasterNFT.NFTMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"MembershipNFTMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"SubscriptionStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"TransferHelper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"address721\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"address1155\",\"type\":\"address\"}],\"name\":\"UpdateTokenContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"}],\"name\":\"UserDefaultPaymentMethod\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_admins\",\"type\":\"address[]\"}],\"name\":\"addAdminAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"_tokenType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfToken\",\"type\":\"uint256\"}],\"name\":\"burnNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfToken\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"}],\"name\":\"buyNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_initData\",\"type\":\"bytes\"}],\"name\":\"createTBA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchListedNft\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"couponPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfToken\",\"type\":\"uint256\"}],\"internalType\":\"struct MasterNFT.MarketItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchMWNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchMarketNft\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"couponPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfToken\",\"type\":\"uint256\"}],\"internalType\":\"struct MasterNFT.MarketItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchMyNFTs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"couponPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfToken\",\"type\":\"uint256\"}],\"internalType\":\"struct MasterNFT.MarketItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAddressToTokenIdToMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum MasterNFT.membershipType\",\"name\":\"typeOfMember\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expireDate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"AccessPass\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"Api\",\"type\":\"string\"}],\"internalType\":\"struct MasterNFT.accessKey\",\"name\":\"acceses\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"enum MasterNFT.AccessLevel\",\"name\":\"accessLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"REAddress\",\"type\":\"string\"}],\"internalType\":\"struct MasterNFT.NFTMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdminList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getEDAofToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getIsAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getIsListedPaymentMethod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_isMember\",\"type\":\"address\"}],\"name\":\"getIsMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getIsOwnerOfToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"getPreTBA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableToLRNPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubscriptionList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"}],\"internalType\":\"struct MasterNFT.Subscription[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenIdToMarketItem\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"couponPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfToken\",\"type\":\"uint256\"}],\"internalType\":\"struct MasterNFT.MarketItem\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenIdToMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum MasterNFT.membershipType\",\"name\":\"typeOfMember\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expireDate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"AccessPass\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"Api\",\"type\":\"string\"}],\"internalType\":\"struct MasterNFT.accessKey\",\"name\":\"acceses\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"enum MasterNFT.AccessLevel\",\"name\":\"accessLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"REAddress\",\"type\":\"string\"}],\"internalType\":\"struct MasterNFT.NFTMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"_tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserDefaultPaymentMethod\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserOwnedNFTId\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"increaseValidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isReseller\",\"type\":\"bool\"}],\"name\":\"manualTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum MasterNFT.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum MasterNFT.membershipType\",\"name\":\"typeOfMember\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expireDate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"AccessPass\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"Api\",\"type\":\"string\"}],\"internalType\":\"struct MasterNFT.accessKey\",\"name\":\"acceses\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"enum MasterNFT.AccessLevel\",\"name\":\"accessLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"REAddress\",\"type\":\"string\"}],\"internalType\":\"struct MasterNFT.NFTMetadata\",\"name\":\"_metadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfToken\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nftPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_couponPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"mintMembershipNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdminAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfToken\",\"type\":\"uint256\"}],\"name\":\"resellNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setLRNTokenCPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_modes\",\"type\":\"bool[]\"}],\"name\":\"setListedPaymentMethod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_updater\",\"type\":\"address\"}],\"name\":\"setMetadataUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setUserDefaultPaymentMethod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wisdom\",\"type\":\"address\"}],\"name\":\"setWisdom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeP\",\"type\":\"uint256\"}],\"name\":\"setlistingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"transferHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_nOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"updateMI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"updateMetadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateSubscriptionStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_1155\",\"type\":\"address\"}],\"name\":\"updateTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ERC20token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MasterNFT", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000516fd028824399d69722d8abc5929b5eb1815b89000000000000000000000000f3a672f68a6f750a17a199d32fe22f48088b840800000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000015af1d78b58c4000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000002c047eefbebffb9fda3fa1e10d08e7fafaeb4254000000000000000000000000c348360124f318060cb9f06a67bd7576e96e4aef0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bce8cde93f3e8cca30d7b05821bf4b9f019f9e6131937494a105d2029981d76c"}