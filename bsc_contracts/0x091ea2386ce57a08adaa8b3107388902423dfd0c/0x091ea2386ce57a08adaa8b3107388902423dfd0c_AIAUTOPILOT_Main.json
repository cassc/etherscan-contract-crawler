{"SourceCode": "pragma solidity 0.6.0; \r\n\r\n//*******************************************************************************//\r\n//------------------ Contract to  AI AUTO PILOT 100% Decentralized -------------------//\r\n//-------------------------\u24b6\u24be \u24b6\u24ca\u24c9\u24c4 \u24c5\u24be\u24c1\u24c4\u24c9-----------------------//\r\n//-------------------------\u2591A\u2591I\u2591 \u2591A\u2591U\u2591T\u2591O\u2591 \u2591P\u2591I\u2591L\u2591O\u2591T\u2591-------------------//\r\n//*******************************************************************************//\r\ncontract owned\r\n{\r\n    address internal owner;\r\n    address internal newOwner;\r\n    address public signer;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        signer = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlySigner {\r\n        require(msg.sender == signer, 'caller must be signer');\r\n        _;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         token interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    //function isUserExists(address userAddress) external returns (bool);\r\n    function balanceOf(address _user) external view returns(uint);\r\n    function currentRate() external view returns(uint);\r\n }\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------        MAIN contract         -------------------//\r\n//*******************************************************************//\r\n\r\ncontract AIAUTOPILOT_Main is owned {\r\n\r\n    // Replace below address with main token token\r\n    address public tokenAddress;\r\n    address public rewadAddress;\r\n   \r\n    uint public lastID_User = 1;\r\n    //uint public maxDownLimit = 2;\r\n    uint[31] public lastIDCount;\r\n\r\n    uint[11] public levelFee;\r\n\r\n\r\n  \r\n    uint nextJoinWait = 2 hours;\r\n    uint nextReJoinWait = 1 hours;\r\n\r\n\r\n    mapping(address => uint) public ActiveDirect;\r\n\r\n    mapping(address => uint[10]) public ActiveUnit;\r\n\r\n\r\n    mapping(address => uint[10]) public nextJoinPending;  \r\n\r\n    mapping(address => uint[4]) public lastJoinTime;\r\n\r\n\r\n    \r\n    mapping(address => uint[10]) public boostPending;\r\n    mapping(address => uint[10]) public boosedCounter;\r\n\r\n\r\n    uint[31] public nextMemberFillIndex;  \r\n    uint[31] public nextMemberFillBox;   \r\n\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint parent;\r\n        uint referrerID;\r\n        uint directCount;\r\n        uint directBoost;\r\n    }\r\n\r\n    mapping(address => address[]) public directAddress;\r\n\r\n    \r\n\r\n    struct TotalInfo {\r\n        uint32 user;        \r\n        uint32 activeUnits;\r\n        uint32 pendingUnits;        \r\n        uint32 boostUnits;\r\n        uint32 boostUnits1;\r\n        uint32 boostUnits2;\r\n    }\r\n\r\n    struct UserIncomeInfo {         \r\n        uint32 UnitIncome;\r\n        uint32 DirectIncome;\r\n        uint32 LevelIncome;\r\n    }\r\n\r\n    mapping(address => UserIncomeInfo) public UserIncomeInfos;\r\n    bool public doUS; // enable or disable update stat\r\n\r\n    TotalInfo public total;\r\n\r\n    mapping(address => userInfo[31]) public userInfos;\r\n    mapping(uint => address) public refAddressbyUID;\r\n    mapping(address=> uint) public uidByRefAddress;\r\n    mapping(address=> uint) public dboostRefAddress;\r\n\r\n\r\n    //userID => _level => address\r\n    mapping(uint => mapping(uint => address)) public userAddressByID;\r\n  \r\n    function init() public onlyOwner returns(bool){\r\n\r\n        levelFee[0] = 5 * (10 ** 18);\r\n        levelFee[1] = 5 * (10 ** 18);\r\n        levelFee[2] = 10 * (10 ** 18);\r\n        levelFee[3] = 15 * (10 ** 18);\r\n        levelFee[4] = 25 * (10 ** 18);\r\n        levelFee[5] = 50 * (10 ** 18);\r\n        levelFee[6] = 100 * (10 ** 18);\r\n        levelFee[7] = 200 * (10 ** 18);\r\n        levelFee[8] = 300 * (10 ** 18);\r\n        levelFee[9] = 500 * (10 ** 18);\r\n        levelFee[10] = 1000 * (10 ** 18);\r\n\r\n        require(lastIDCount[0]==0, \"can be called only once\");\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n\r\n        temp.joined = true;\r\n        temp.id = 1;\r\n        temp.parent = 1;\r\n        temp.referrerID = 1;\r\n        //temp.directCount = 2 ** 100;\r\n        temp.directCount = 100;\r\n        temp.directBoost = 1000;\r\n\r\n\r\n        userInfos[owner][0] = temp;\r\n        userAddressByID[1][0] = owner;\r\n        refAddressbyUID[1] = owner;\r\n\r\n        dboostRefAddress[owner] = 1000;\r\n\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), 2505 * (10 ** 18));\r\n\r\n        for(uint i=1;i<31;i++)\r\n        {\r\n            lastIDCount[i]++;\r\n            userInfos[owner][i] = temp;\r\n            userAddressByID[1][i] = owner;\r\n        }\r\n\r\n    }\r\n\r\n    function setTokenNAddress(address _tokenAddress, address _rewadAddress) public onlyOwner returns(bool)\r\n    {\r\n        tokenAddress = _tokenAddress;\r\n        rewadAddress = _rewadAddress;        \r\n        return true;\r\n    }\r\n\r\n    function settimer(uint _nextJoinWait, uint _nextULPWait) public onlyOwner returns(bool)\r\n    {\r\n        // put timeing is second minute hour day \r\n        nextJoinWait = _nextJoinWait;\r\n        nextReJoinWait = _nextULPWait;\r\n        \r\n        return true;\r\n    }\r\n    function toggleDoUS() public onlyOwner returns(bool)\r\n    {\r\n        doUS = !doUS;\r\n        return true;\r\n    }\r\n\r\n    function regUser(uint uinRefID) public returns(bool) \r\n    {\r\n        uint fee = levelFee[0];\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), fee);\r\n        _regUser(msg.sender, uinRefID, fee);\r\n        return true;\r\n    }\r\n\r\n    function regUser_top_byother(uint uinRefID, address _useraddress) public returns(bool) \r\n    {\r\n        uint fee = levelFee[0];\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), fee);\r\n        _regUser(_useraddress, uinRefID, fee);\r\n        return true;\r\n    }\r\n\r\n    event regUserEv(address _user,uint userid, address _referrer, uint refID,address parent, uint parentid,  uint timeNow, uint uid);\r\n    function _regUser(address _user, uint uinRefID, uint fee) internal returns(bool) \r\n    {\r\n        address _ref = refAddressbyUID[uinRefID];\r\n\r\n        uint _referrerID = userInfos[_ref][0].id;\r\n        if(_referrerID == 0) _referrerID = 1;\r\n        //require(tokenInterface(tigerAddress).isUserExists(_user), \"user not exists\");\r\n        require(msg.sender == tx.origin, \"contract can't call\");\r\n        require(!userInfos[_user][0].joined, \"already joined\");\r\n        require(_referrerID <= lastIDCount[0], \"Invalid ref id\");\r\n\r\n        \r\n\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];       \r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[_user][0] = temp;\r\n        userAddressByID[temp.id][0] = _user;\r\n\r\n\r\n        userInfos[_ref][0].directCount++;\r\n\r\n        userInfos[_ref][0].directBoost++;\r\n        \r\n        dboostRefAddress[_ref]++;\r\n\r\n        tokenInterface(tokenAddress).transfer(_ref, fee/2);\r\n        US(_ref, 1, 5);\r\n      \r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        lastJoinTime[_user][0] = now;\r\n      \r\n        ActiveUnit[_user][0]++;\r\n        ActiveDirect[_ref]++;\r\n\r\n        directAddress[_ref].push(_user);\r\n        lastID_User++;\r\n       // uint uid = (uint(now) % 10000000) + uint(now);\r\n        uint uid = lastID_User;\r\n        uidByRefAddress[_user] = uid;\r\n        refAddressbyUID[uid] = _user;\r\n\r\n        total.user++;        \r\n        total.activeUnits++;\r\n       \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n\r\n        \r\n        emit regUserEv(_user,temp.id, _ref, _referrerID,userAddressByID[temp.parent][0], temp.parent, now, uid);\r\n        return true;\r\n    }\r\n    \r\n   \r\n    event buyUserEv(address _user,uint _level, address _idplaceaddress, uint _amt, uint _time);\r\n    \r\n    function BuyLevel(uint _level) public returns(bool)\r\n    {\r\n       BuyULP(_level, msg.sender);\r\n       emit buyUserEv(msg.sender,_level, msg.sender, levelFee[_level+1], now);\r\n       return true;\r\n   }\r\n\r\n   function BuyLevel_Own(uint _level, address _useraddress) public returns(bool)\r\n   {\r\n       BuyULP(_level, _useraddress);\r\n       emit buyUserEv(_useraddress,_level, msg.sender, levelFee[_level+1], now);\r\n       return true;\r\n   }\r\n\r\n\r\n    event enterMoreEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function BuyULP(uint _Level, address _useradd) internal returns(bool){\r\n        require(userInfos[_useradd][0].joined, \"register first\");\r\n        require(_Level < 10, \"Invalid Level\");\r\n\r\n            uint[10] memory upLvl = [ uint(0),uint(4),uint(7),uint(10),uint(13),uint(16),uint(19),uint(22),uint(25),uint(28)];\r\n\r\n            if(_Level<=3)\r\n            {\r\n                require(lastJoinTime[_useradd][_Level] + nextReJoinWait <= now, \"please wait time little more\");\r\n            }\r\n           \r\n            uint fee = levelFee[_Level+1];\r\n            tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), fee);\r\n\r\n            if(_Level==0)\r\n            {\r\n                address _ref = userAddressByID[userInfos[_useradd][_Level].referrerID][_Level];\r\n                tokenInterface(tokenAddress).transfer(_ref, fee/2);\r\n                US(_ref, 1, 5);\r\n            }\r\n           \r\n            \r\n            ActiveUnit[_useradd][_Level]++;\r\n            \r\n            userInfo memory temp;\r\n            lastIDCount[upLvl[_Level]]++;\r\n            temp.joined = true;\r\n            temp.id = lastIDCount[upLvl[_Level]];\r\n            temp.directCount = userInfos[_useradd][0].directCount;\r\n            uint _referrerID = userInfos[_useradd][0].referrerID;\r\n            bool pay;\r\n\r\n            (temp.parent, pay) = findFreeReferrer(upLvl[_Level]);\r\n            temp.referrerID = _referrerID;\r\n\r\n            userInfos[_useradd][upLvl[_Level]] = temp;\r\n            userAddressByID[temp.id][upLvl[_Level]] = _useradd;\r\n\r\n            if(_Level<=3)\r\n            {\r\n                lastJoinTime[_useradd][_Level] = now;\r\n            }\r\n\r\n            if(pay) \r\n            {\r\n                payForLevel(temp.parent, upLvl[_Level]);\r\n                buyLevel(userAddressByID[temp.parent][_Level], upLvl[_Level]+1);\r\n            }\r\n            \r\n            emit enterMoreEv(_useradd,temp.id, userAddressByID[temp.parent][upLvl[_Level]],temp.parent,now);\r\n\r\n     \r\n        return true;\r\n    }    \r\n\r\n    event joinNextEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);    \r\n    function joinNext(uint _level) public returns(bool){\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        uint unit_level = 0;\r\n       if(_level==0)\r\n       {\r\n         require(nextJoinPending[msg.sender][0] > 0, \"no pending next join\");\r\n         require(lastJoinTime[msg.sender][0] + nextJoinWait <= now, \"please wait time little more\");\r\n         nextJoinPending[msg.sender][0]--;\r\n         ActiveUnit[msg.sender][0]++;\r\n         lastJoinTime[msg.sender][0] = now;\r\n         unit_level = 0 ; \r\n         address _ref;\r\n         _ref = userAddressByID[userInfos[msg.sender][0].referrerID][0];\r\n         tokenInterface(tokenAddress).transfer(_ref, levelFee[0]/2);\r\n         US(_ref, 1, 5);\r\n       }\r\n       else if(_level>=1)\r\n       {\r\n         require(nextJoinPending[msg.sender][_level] > 0, \"no pending next join\");\r\n         nextJoinPending[msg.sender][_level]--;\r\n         ActiveUnit[msg.sender][_level]++;\r\n         unit_level = 4 + ((_level -1)*3) ; \r\n       }\r\n       \r\n        userInfo memory temp;\r\n        lastIDCount[unit_level]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[unit_level];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(unit_level);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][unit_level] = temp;\r\n        userAddressByID[temp.id][unit_level] = msg.sender;\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, unit_level);\r\n            buyLevel(userAddressByID[temp.parent][0], unit_level + 1);\r\n        }\r\n\r\n        \r\n        \r\n         \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits-1;       \r\n                \r\n        \r\n       \r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n   \r\n\r\n    event buyLevelEv(uint level, address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function buyLevel(address _user, uint _level) internal returns(bool)\r\n    {\r\n        userInfo memory temp = userInfos[_user][0];\r\n\r\n        lastIDCount[_level]++;\r\n        temp.id = lastIDCount[_level];\r\n        if(_level == 0) temp.directCount = userInfos[_user][0].directCount;\r\n\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(_level);\r\n \r\n\r\n        userInfos[_user][_level] = temp;\r\n        userAddressByID[temp.id][_level] = _user;\r\n\r\n        address parentAddress = userAddressByID[temp.parent][_level];\r\n\r\n\r\n        if(pay)\r\n        {\r\n            \r\n            // Level1 //\r\n            if(_level < 3 ) payForLevel(temp.parent, _level); // for 0,1,2 only\r\n            if(_level <= 2 ) buyLevel(parentAddress, _level + 1); //upgrade for 0,1,2 only\r\n            if(_level == 3 ) \r\n            {\r\n                boostPending[parentAddress][0]++;              \r\n            }\r\n\r\n             // Level2 //\r\n\r\n            if (_level >= 4)\r\n            {\r\n                //uint[10] memory upLvl = [ uint(0),uint(4),uint(7),uint(10),uint(13),uint(16),uint(19),uint(22),uint(25),uint(28)];\r\n\r\n                //uint factor = 4 + ((_level - 4) * 3);\r\n                 uint factor;\r\n                 uint blevel;\r\n                if(_level>=4 && _level<=6)\r\n                {\r\n                    factor=4;\r\n                    blevel=1;\r\n                } \r\n                else if(_level>=7 && _level<=9){ factor=7; blevel=2;\r\n                } \r\n                else if(_level>=10 && _level<=12) { factor=10; blevel=3;\r\n                } \r\n                else if(_level>=13 && _level<=15){ factor=13; blevel=4;\r\n                } \r\n                else if(_level>=16 && _level<=18) {factor=16;blevel=5;\r\n                } \r\n                else if(_level>=19 && _level<=21) {factor=19;blevel=6;\r\n                } \r\n                else if(_level>=22 && _level<=24) {factor=22;blevel=7;\r\n                } \r\n                else if(_level>=25 && _level<=27) {factor=25;blevel=8;\r\n                } \r\n                else if(_level>=28 && _level<=30) {factor=28;blevel=9;\r\n                } \r\n\r\n                //uint factor = 4 + ((_level - 4) * 3);\r\n                if(_level >= factor  && _level < factor+2 ) payForLevel(temp.parent, _level); // for 0,1, only\r\n                if(_level >= factor  && _level <= factor+1 ) buyLevel(parentAddress, _level + 1); //upgrade for 0,1, only\r\n                if(_level == factor+2 ) \r\n                {\r\n                    boostPending[parentAddress][blevel]++;              \r\n                }\r\n            }\r\n          \r\n        }\r\n        emit buyLevelEv(_level, msg.sender, temp.id, userAddressByID[temp.parent][0], temp.parent, now);\r\n        return true;\r\n    }\r\n\r\n    event boostEv(address user, uint boostCount, uint remainingBoost, uint timeNow);\r\n    function boost(uint _level) public returns(bool)\r\n    {\r\n        uint[10] memory dBoost = [uint(2),uint(3),uint(3),uint(4),uint(5),uint(10),uint(15),uint(18),uint(30),uint(50)];\r\n        uint[10] memory Nextjoin = [uint(2),uint(3),uint(5),uint(9),uint(14),uint(28),uint(56),uint(85),uint(182),uint(216)];\r\n        \r\n        uint payLvl = 3 + (_level * 3);\r\n        if ( payLvl > 30 ) payLvl = 30;\r\n       // if(_level==0)\r\n        //{\r\n            require(boostPending[msg.sender][_level] > 0, \"not eligible\" );\r\n            //require(userInfos[msg.sender][_level].directBoost >= dBoost[_level], \"Direct not eligible\" );\r\n            require(dboostRefAddress[msg.sender] >= dBoost[_level], \"Direct not eligible\" );\r\n\r\n            boosedCounter[msg.sender][_level]++;\r\n            payForLevel(userInfos[msg.sender][payLvl].id, payLvl);\r\n            nextJoinPending[msg.sender][0] += Nextjoin[_level];\r\n            if(_level<9)\r\n            {\r\n                 nextJoinPending[msg.sender][_level+1]++;\r\n            }           \r\n            boostPending[msg.sender][_level]--;\r\n            dboostRefAddress[msg.sender] -= dBoost[_level];\r\n            //userInfos[msg.sender][0].directBoost -= dBoost[_level];\r\n           \r\n       // }      \r\n        emit boostEv(msg.sender, boosedCounter[msg.sender][_level], boostPending[msg.sender][_level], now);  \r\n\r\n        return true;\r\n    }\r\n    \r\n\r\n    event payForLevelEv(uint level, uint parentID,address paidTo, uint amount, bool direct, uint timeNow);\r\n    function payForLevel(uint _pID, uint _level) internal returns (bool){\r\n        \r\n        address _user = userAddressByID[_pID][_level];\r\n       \r\n        if(_level == 3)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 15 * (10 ** 18));\r\n            US(_user, 0, 13);\r\n            emit payForLevelEv(_level,_pID,_user, 15 * (10 ** 18), false, now);\r\n          \r\n            tokenInterface(tokenAddress).transfer(rewadAddress, 1 * (10 ** 18));\r\n            \r\n            for(uint i=1; i<=8; i++)\r\n            {\r\n                _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n                tokenInterface(tokenAddress).transfer(_user, 5 * (10 ** 17)); \r\n                US(_user, 2, 1);\r\n                emit payForLevelEv(_level,_pID,_user, 5 * (10 ** 17), true, now);\r\n            }\r\n             \r\n        }\r\n\r\n        uint[9] memory p1 = [uint(2),uint(2),uint(4),uint(8),uint(16),uint(32),uint(48),uint(86),uint(100)]; // to user 1st\r\n        uint[9] memory p2 = [uint(3),uint(3),uint(6),uint(12),uint(24),uint(48),uint(72),uint(114),uint(200)]; // to user 2nd\r\n        uint[9] memory p3 = [uint(25),uint(35),uint(50),uint(130),uint(260),uint(620),uint(880),uint(1300),uint(4905)]; // to user 3rd\r\n        uint[9] memory p4 = [uint(3),uint(5),uint(3),uint(4),uint(8),uint(16),uint(19),uint(18),uint(415)]; // to reward\r\n        uint[9] memory p5 = [uint(1),uint(2),uint(3),uint(5),uint(10),uint(20),uint(30),uint(50),uint(100)]; // to loop\r\n\r\n        if (_level <= 3) return true;\r\n\r\n        uint i = ( _level / 3 ) - 1;\r\n\r\n        if(_level % 3 == 1) \r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user,p1[i] * (10 ** 18));\r\n            US(_user, 0, uint32(p1[i]));\r\n            emit payForLevelEv(_level,_pID,_user, p1[i] * (10 ** 18), false, now);            \r\n        }\r\n        else if(_level% 3 == 2 )\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user,p2[i] * (10 ** 18));\r\n            US(_user, 0, uint32(p2[i]));\r\n            emit payForLevelEv(_level,_pID,_user, p2[i] * (10 ** 18), false, now); \r\n        }\r\n        else if(_level % 3 == 0)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, p3[i-1] * (10 ** 18));\r\n            US(_user, 0, uint32(p3[i-1]));\r\n            emit payForLevelEv(_level,_pID,_user, p3[i-1] * (10 ** 18), false, now);            \r\n           \r\n            tokenInterface(tokenAddress).transfer(rewadAddress, p4[i-1] * (10 ** 18));\r\n\r\n            for(uint j=1; j<=8; j++)\r\n            {\r\n                _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n                tokenInterface(tokenAddress).transfer(_user, p5[i-1] * (10 ** 18)); \r\n                US(_user, 2, uint32(p5[i-1]));\r\n                emit payForLevelEv(_level,_pID,_user, p5[i-1] * (10 ** 18), true, now);\r\n            }\r\n\r\n        }\r\n\r\n    }  \r\n\r\n    function US(address _user,uint8 _type, uint32 _amount) internal \r\n    {\r\n        if (doUS)\r\n        {\r\n            if(_type == 0 ) UserIncomeInfos[_user].UnitIncome = UserIncomeInfos[_user].UnitIncome + _amount ;\r\n            else if (_type == 1 ) UserIncomeInfos[_user].DirectIncome =  UserIncomeInfos[_user].DirectIncome + _amount;\r\n            else if (_type == 2 ) UserIncomeInfos[_user].LevelIncome =  UserIncomeInfos[_user].LevelIncome + _amount;\r\n        }\r\n    }\r\n\r\n  \r\n\r\n    //function findFreeReferrer(uint _level) internal returns(uint,bool) {\r\n    function findFreeReferrer(uint _level) public returns(uint,bool) {\r\n\r\n        bool pay;\r\n\r\n        uint currentID = nextMemberFillIndex[_level];\r\n\r\n        if(nextMemberFillBox[_level] == 0)\r\n        {\r\n            nextMemberFillBox[_level] = 1;\r\n        }   \r\n        else\r\n        {\r\n            nextMemberFillIndex[_level]++;\r\n            nextMemberFillBox[_level] = 0;\r\n            pay = true;\r\n        }\r\n        return (currentID+1,pay);\r\n    }\r\n\r\n\r\n    //a = join, b = ulp join\r\n    function timeRemains(address _user) public view returns(uint, uint, uint, uint)\r\n    {\r\n        uint a; // UNIT TIME\r\n        uint b; // ULP TIME\r\n        uint c;\r\n        uint d;\r\n        if( nextJoinPending[_user][0] == 0 || lastJoinTime[_user][0] + nextJoinWait < now) \r\n        {\r\n            a = 0;\r\n        }\r\n        else\r\n        {\r\n            a = (lastJoinTime[_user][0] + nextJoinWait) - now;\r\n        }\r\n               \r\n        if(lastJoinTime[_user][1] + nextReJoinWait < now) \r\n        {\r\n            b = 0;\r\n        }\r\n        else\r\n        {\r\n            b = (lastJoinTime[_user][1] + nextReJoinWait) - now ;\r\n        }\r\n        \r\n        if(lastJoinTime[_user][2] + nextReJoinWait < now) \r\n        {\r\n            c = 0;\r\n        }\r\n        else\r\n        {\r\n            c = (lastJoinTime[_user][2] + nextReJoinWait) - now ;\r\n        }\r\n        \r\n        if(lastJoinTime[_user][3] + nextReJoinWait < now) \r\n        {\r\n            d = 0;\r\n        }\r\n        else\r\n        {\r\n            d = (lastJoinTime[_user][3] + nextReJoinWait) - now ;\r\n        }\r\n        return (a,b,c,d);\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBoost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"boostEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"buyLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_idplaceaddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"buyUserEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"enterMoreEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"joinNextEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"payForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"regUserEv\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ActiveDirect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ActiveUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"BuyLevel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"BuyLevel_Own\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserIncomeInfos\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"UnitIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"DirectIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"LevelIncome\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boosedCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"boost\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boostPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dboostRefAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"joinNext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastID_User\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastJoinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextJoinPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refAddressbyUID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uinRefID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uinRefID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"regUser_top_byother\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewadAddress\",\"type\":\"address\"}],\"name\":\"setTokenNAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextJoinWait\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextULPWait\",\"type\":\"uint256\"}],\"name\":\"settimer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"timeRemains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDoUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"user\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"activeUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pendingUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits2\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uidByRefAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directBoost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AIAUTOPILOT_Main", "CompilerVersion": "v0.6.0+commit.26b70077", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b96ac9e4c29e089a41739ab8f168e03386283553472690d8f5c0cc06c4fcd579"}