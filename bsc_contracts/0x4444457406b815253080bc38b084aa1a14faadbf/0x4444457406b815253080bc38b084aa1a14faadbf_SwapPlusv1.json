{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/SwapPlusv1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./interfaces/IWETH.sol\\\";\\r\\nimport \\\"./interfaces/ISmartRouter.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2.sol\\\";\\r\\n\\r\\nimport \\\"./utils/Ownable.sol\\\";\\r\\nimport \\\"./utils/SafeERC20.sol\\\";\\r\\n\\r\\ncontract SwapPlusv1 is Ownable {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  struct swapRouter {\\r\\n    string platform;\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint256 amountOutMin;\\r\\n    uint256 meta; // fee, flag(stable), 0=v2\\r\\n    uint256 percent;\\r\\n  }\\r\\n  struct swapLine {\\r\\n    swapRouter[] swaps;\\r\\n  }\\r\\n  struct swapBlock {\\r\\n    swapLine[] lines;\\r\\n  }\\r\\n\\r\\n  address public WETH;\\r\\n  address public treasury;\\r\\n  uint256 public swapFee = 3000;\\r\\n  uint256 public managerDecimal = 1000000;\\r\\n  mapping (address => bool) public noFeeWallets;\\r\\n  mapping (address => bool) public managers;\\r\\n\\r\\n  mapping(string => address) public routers;\\r\\n\\r\\n  event SwapPlus(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountUsed, uint256 amountOut);\\r\\n\\r\\n  constructor(\\r\\n    address _WETH,\\r\\n    address _treasury\\r\\n  ) {\\r\\n    routers[\\\"PancakeV3\\\"] = 0x13f4EA83D0bd40E75C8222255bc855a974568Dd4;\\r\\n    routers[\\\"PancakeStable\\\"] = 0x13f4EA83D0bd40E75C8222255bc855a974568Dd4;\\r\\n    routers[\\\"PancakeV2\\\"] = 0x13f4EA83D0bd40E75C8222255bc855a974568Dd4;\\r\\n    routers[\\\"ApeSwap\\\"] = 0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607;\\r\\n    routers[\\\"Biswap\\\"] = 0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8;\\r\\n    routers[\\\"Babyswap\\\"] = 0x8317c460C22A9958c27b4B6403b98d2Ef4E2ad32;\\r\\n\\r\\n    WETH = _WETH;\\r\\n    treasury = _treasury;\\r\\n    managers[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  modifier onlyManager() {\\r\\n    require(managers[msg.sender], \\\"LC swap+: !manager\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n  }\\r\\n\\r\\n  function swap(address tokenIn, uint256 amount, address tokenOut, address recipient, swapBlock[] calldata swBlocks) public payable returns(uint256, uint256) {\\r\\n    uint256 usedAmount = amount;\\r\\n    if (tokenIn != address(0)) {\\r\\n      usedAmount = IERC20(tokenIn).balanceOf(address(this));\\r\\n      IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amount);\\r\\n      usedAmount = IERC20(tokenIn).balanceOf(address(this)) - usedAmount;\\r\\n    }\\r\\n    else {\\r\\n      usedAmount = msg.value;\\r\\n    }\\r\\n\\r\\n    if (noFeeWallets[msg.sender] == false) {\\r\\n      usedAmount = _cutFee(tokenIn, usedAmount);\\r\\n    }\\r\\n\\r\\n    if (tokenIn == address(0)) {\\r\\n      IWETH(WETH).deposit{value: usedAmount}();\\r\\n    }\\r\\n\\r\\n    uint256 blockLen = swBlocks.length;\\r\\n    uint256 inAmount = usedAmount;\\r\\n    uint256 outAmount = 0;\\r\\n    for (uint256 x=0; x<blockLen; x++) {\\r\\n      uint256 lineLen = swBlocks[x].lines.length;\\r\\n      outAmount = 0;\\r\\n      for (uint256 y=0; y<lineLen; y++) {\\r\\n        outAmount += _swap(swBlocks[x].lines[y], inAmount);\\r\\n      }\\r\\n      inAmount = outAmount;\\r\\n    }\\r\\n\\r\\n    if (tokenOut == address(0)) {\\r\\n      IWETH(WETH).withdraw(outAmount);\\r\\n      (bool success, ) = payable(recipient).call{value: outAmount}(\\\"\\\");\\r\\n      require(success, \\\"LC swap+: Failed receipt\\\");\\r\\n    }\\r\\n    else {\\r\\n      IERC20(tokenOut).safeTransfer(recipient, outAmount);\\r\\n    }\\r\\n\\r\\n    emit SwapPlus(tokenIn, tokenOut, amount, usedAmount, outAmount);\\r\\n\\r\\n    return (usedAmount, outAmount);\\r\\n  }\\r\\n\\r\\n  function _swap(swapLine memory line, uint256 amount) internal returns(uint256) {\\r\\n    uint256 swLen = line.swaps.length;\\r\\n    uint256 inAmount = amount;\\r\\n    uint256 outAmount = 0;\\r\\n    for (uint256 x=0; x<swLen; x++) {\\r\\n      _approveTokenIfNeeded(line.swaps[x].tokenIn, routers[line.swaps[x].platform], inAmount);\\r\\n      if (_compareStrings(line.swaps[x].platform, \\\"PancakeV3\\\")) {\\r\\n        ISmartRouter.ExactInputSingleParams memory pm = ISmartRouter.ExactInputSingleParams({\\r\\n          tokenIn: line.swaps[x].tokenIn,\\r\\n          tokenOut: line.swaps[x].tokenOut,\\r\\n          fee: uint24(line.swaps[x].meta),\\r\\n          recipient: address(this),\\r\\n          amountIn: inAmount * line.swaps[x].percent / managerDecimal,\\r\\n          amountOutMinimum: line.swaps[x].amountOutMin,\\r\\n          sqrtPriceLimitX96: 0\\r\\n        });\\r\\n        outAmount = ISmartRouter(routers[\\\"PancakeV3\\\"]).exactInputSingle{value:0}(pm);\\r\\n      }\\r\\n      else if (_compareStrings(line.swaps[x].platform, \\\"PancakeStable\\\")) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = line.swaps[x].tokenIn;\\r\\n        path[1] = line.swaps[x].tokenOut;\\r\\n        uint256[] memory flag = new uint256[](1);\\r\\n        flag[0] = line.swaps[x].meta;\\r\\n        outAmount = ISmartRouter(routers[\\\"PancakeStable\\\"]).exactInputStableSwap{value:0}(\\r\\n          path, flag, inAmount * line.swaps[x].percent / managerDecimal, line.swaps[x].amountOutMin, address(this)\\r\\n        );\\r\\n      }\\r\\n      else if (_compareStrings(line.swaps[x].platform, \\\"PancakeV2\\\")) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = line.swaps[x].tokenIn;\\r\\n        path[1] = line.swaps[x].tokenOut;\\r\\n        outAmount = ISmartRouter(routers[\\\"PancakeV2\\\"]).swapExactTokensForTokens{value:0}(\\r\\n          inAmount * line.swaps[x].percent / managerDecimal, line.swaps[x].amountOutMin, path, address(this)\\r\\n        );\\r\\n      }\\r\\n      else if (routers[line.swaps[x].platform] != address(0)) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = line.swaps[x].tokenIn;\\r\\n        path[1] = line.swaps[x].tokenOut;\\r\\n        uint256[] memory amounts = IUniswapV2(routers[line.swaps[x].platform]).swapExactTokensForTokens(\\r\\n          inAmount * line.swaps[x].percent / managerDecimal,\\r\\n          line.swaps[x].amountOutMin,\\r\\n          path,\\r\\n          address(this),\\r\\n          block.timestamp\\r\\n        );\\r\\n        outAmount = amounts[amounts.length - 1];\\r\\n      }\\r\\n      inAmount = outAmount;\\r\\n    }\\r\\n    return outAmount;\\r\\n  }\\r\\n\\r\\n  function _cutFee(address token, uint256 _amount) internal returns(uint256) {\\r\\n    if (_amount > 0) {\\r\\n      uint256 fee = _amount * swapFee / managerDecimal;\\r\\n      if (fee > 0) {\\r\\n        if (token == address(0)) {\\r\\n          (bool success, ) = payable(treasury).call{value: fee}(\\\"\\\");\\r\\n          require(success, \\\"LC swap+: Failed cut fee\\\");\\r\\n        }\\r\\n        else {\\r\\n          IERC20(token).safeTransfer(treasury, fee);\\r\\n        }\\r\\n      }\\r\\n      return _amount - fee;\\r\\n    }\\r\\n    return 0;\\r\\n  }\\r\\n\\r\\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) private {\\r\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\r\\n      IERC20(token).safeApprove(spender, 0);\\r\\n      IERC20(token).safeApprove(spender, type(uint256).max);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setManager(address account, bool access) public onlyOwner {\\r\\n    managers[account] = access;\\r\\n  }\\r\\n\\r\\n  function setNoFeeWallets(address account, bool access) public onlyManager {\\r\\n    noFeeWallets[account] = access;\\r\\n  }\\r\\n\\r\\n  function setSwapFee(uint256 _swapFee) public onlyManager {\\r\\n    swapFee = _swapFee;\\r\\n  }\\r\\n\\r\\n  function setTreasury(address _treasury) public onlyManager {\\r\\n    treasury = _treasury;\\r\\n  }\\r\\n\\r\\n  function addUniv2Router(string memory _platform, address _router) public onlyManager {\\r\\n    routers[_platform] = _router;\\r\\n  }\\r\\n\\r\\n  function withdraw(address token, uint256 amount) public onlyManager {\\r\\n    if (token == address(0)) {\\r\\n      if (amount > address(this).balance) {\\r\\n        amount = address(this).balance;\\r\\n      }\\r\\n      if (amount > 0) {\\r\\n        (bool success1, ) = msg.sender.call{value: amount}(\\\"\\\");\\r\\n        require(success1, \\\"LC swap+: Failed revoke\\\");\\r\\n      }\\r\\n    }\\r\\n    else {\\r\\n      uint256 balance = IERC20(token).balanceOf(address(this));\\r\\n      if (amount > balance) {\\r\\n        amount = balance;\\r\\n      }\\r\\n      if (amount > 0) {\\r\\n        IERC20(token).safeTransfer(msg.sender, amount);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _compareStrings(string memory a, string memory b) internal pure returns (bool) {\\r\\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20Permit {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n  function nonces(address owner) external view returns (uint256);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"./draft-IERC20Permit.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    unchecked {\\r\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n      uint256 newAllowance = oldAllowance - value;\\r\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function safePermit(\\r\\n    IERC20Permit token,\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal {\\r\\n    uint256 nonceBefore = token.nonces(owner);\\r\\n    token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    uint256 nonceAfter = token.nonces(owner);\\r\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n  }\\r\\n\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n  function deposit() external payable;\\r\\n  function withdraw(uint amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IUniswapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IUniswapV2 {\\r\\n  function swapExactTokensForTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n\\r\\n  function swapTokensForExactTokens(\\r\\n    uint amountOut,\\r\\n    uint amountInMax,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n\\r\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/ISmartRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface ISmartRouter {\\r\\n  function exactInputStableSwap(\\r\\n    address[] calldata path,\\r\\n    uint256[] calldata flag,\\r\\n    uint256 amountIn,\\r\\n    uint256 amountOutMin,\\r\\n    address to\\r\\n  ) external payable  returns (uint256 amountOut);\\r\\n  function exactOutputStableSwap(\\r\\n    address[] calldata path,\\r\\n    uint256[] calldata flag,\\r\\n    uint256 amountOut,\\r\\n    uint256 amountInMax,\\r\\n    address to\\r\\n  ) external payable returns (uint256 amountIn);\\r\\n\\r\\n  function swapExactTokensForTokens(\\r\\n    uint256 amountIn,\\r\\n    uint256 amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to\\r\\n  ) external payable returns (uint256 amountOut);\\r\\n  function swapTokensForExactTokens(\\r\\n    uint256 amountOut,\\r\\n    uint256 amountInMax,\\r\\n    address[] calldata path,\\r\\n    address to\\r\\n  ) external payable returns (uint256 amountIn);\\r\\n\\r\\n  struct ExactInputSingleParams {\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint24 fee;\\r\\n    address recipient;\\r\\n    uint256 amountIn;\\r\\n    uint256 amountOutMinimum;\\r\\n    uint160 sqrtPriceLimitX96;\\r\\n  }\\r\\n  struct ExactInputParams {\\r\\n    bytes path;\\r\\n    address recipient;\\r\\n    uint256 amountIn;\\r\\n    uint256 amountOutMinimum;\\r\\n  }\\r\\n  struct ExactOutputSingleParams {\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint24 fee;\\r\\n    address recipient;\\r\\n    uint256 amountOut;\\r\\n    uint256 amountInMaximum;\\r\\n    uint160 sqrtPriceLimitX96;\\r\\n  }\\r\\n  struct ExactOutputParams {\\r\\n    bytes path;\\r\\n    address recipient;\\r\\n    uint256 amountOut;\\r\\n    uint256 amountInMaximum;\\r\\n  }\\r\\n  function exactInputSingle(ExactInputSingleParams memory params)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint256 amountOut);\\r\\n  function exactInput(ExactInputParams memory params) external payable returns (uint256 amountOut);\\r\\n  function exactOutputSingle(ExactOutputSingleParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint256 amountIn);\\r\\n  function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"SwapPlus\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"addUniv2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noFeeWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"routers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setNoFeeWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct SwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SwapPlusv1.swapBlock[]\",\"name\":\"swBlocks\",\"type\":\"tuple[]\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SwapPlusv1", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000e839eb365cad6ca88b8d519d1475fa74eb9e8485", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}