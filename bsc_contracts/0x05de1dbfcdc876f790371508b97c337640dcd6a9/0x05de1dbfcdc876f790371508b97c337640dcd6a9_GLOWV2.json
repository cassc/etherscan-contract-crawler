{"SourceCode": "{\"Glow.sol\":{\"content\":\"/*\\r\\n* TG: https://t.me/GLOW_Token_Official\\r\\n* Website: https://glowtoken.online\\r\\n* Author: @DaisyOfficialTG\\r\\n*/\\r\\n//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Libraries.sol\\\";\\r\\n\\r\\ncontract GLOWV2 is Ownable, IBEP20{\\r\\n    \\r\\n    uint256 private constant _totalSupply = 1_000_000_000_000_000*(10**9);\\r\\n    uint8 private constant _decimals = 9;\\r\\n    \\r\\n    // Liquidity Lock\\r\\n    uint256 private fixedLockTime=60 days;\\r\\n    uint256 public liquidityUnlockSeconds;\\r\\n    //\\r\\n    bool private _airDropDone;\\r\\n    bool private _tradingEnabled;\\r\\n    // Lottery\\r\\n    bool public lotteryEnabled;\\r\\n    address[] holders;\\r\\n    uint256 private _nonce;\\r\\n    uint256 currentIndex;\\r\\n    // Limits\\r\\n    uint256 private _balanceLimitDivider=100;\\r\\n    uint256 private _maxWalletSize=_totalSupply/_balanceLimitDivider;\\r\\n    uint256 private _maxSellSize=_totalSupply/_balanceLimitDivider;\\r\\n    // Swap \\u0026 Liquify\\r\\n    uint8 public swapThreshold=35;\\r\\n    bool public swapEnabled;\\r\\n    bool private _inSwap;\\r\\n    bool private _addingLP;\\r\\n    bool private _removingLP;\\r\\n    // Distributor\\r\\n    uint256 public distributorGas=600000;\\r\\n    DividendDistributor distributor;\\r\\n    address public distributorAddress;\\r\\n    // PancakeSwap\\r\\n    IPancakeRouter02 private _pancakeRouter;\\r\\n    address public pancakeRouterAddress=0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    address public pancakePairAddress;\\r\\n    // Misc. Addresses\\r\\n    address public burnWallet=0x000000000000000000000000000000000000dEaD;\\r\\n    address public BUSD=0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\r\\n    address public WBNB=0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\r\\n    // Team Addresses\\r\\n    address public coFounder_1=0x8e68D30Ae71E32bA1e13cDce606838f70ca83C3C;\\r\\n    address public coFounder_2=0xf545d69BC89711CA855e6c24fd7fC935ce5B604B;\\r\\n    address public coFounder_3=0x09B658C800Bb644a51A3d6eA88D5714eb4ACe4E7;\\r\\n    address public VPCustomerRelations=0x999C8324f34b40437d2625ad4f79D801F15138Cf;\\r\\n    address public VPOperations=0xC5D74A9bA8ba15e62c1d5C814ce3b8aC0dA686f7;\\r\\n    address public headDevelopment=0x0209564AcaF3c354BB681E27b018fdcFD8E109d3;\\r\\n    address public developer_1=0xB4e06da1aB74E1742b73Da6a1B9D0eFBb761119b;\\r\\n    address public developer_2=0x66FF2BF3937b4a196479Df61235f3Ed4118C2bD7;\\r\\n    address public developer_3=0x4f509E30853F77b03a45f6e41F8273e82B55C174;\\r\\n    mapping(address=\\u003ebool) private _excludeFromLottery;\\r\\n    mapping(address=\\u003euint256) holderIndexes; \\r\\n    mapping(address=\\u003ebool) private _blacklist;\\r\\n    mapping(address=\\u003euint256) private _balances;\\r\\n    mapping(address=\\u003emapping(address =\\u003e uint256)) private _allowances;\\r\\n    mapping(address=\\u003ebool)private _excludeFromFees;\\r\\n    mapping(address=\\u003ebool)private _excludeFromRewards;\\r\\n    mapping(address=\\u003ebool)private _marketMakers;\\r\\n    Tracker private _tracker;\\r\\n    struct Tracker {\\r\\n        uint256 totalLPBNB;\\r\\n        uint256 totalMarketingBNB;\\r\\n        uint256 totalCharityBNB;\\r\\n        uint256 totalRewardBNB;\\r\\n        uint256 totalLotteryBNB;\\r\\n        uint256 totalRewardPayout;\\r\\n    }\\r\\n    Taxes private _taxes;\\r\\n    struct Taxes {\\r\\n        uint8 maxBuyTax;\\r\\n        uint8 maxSellTax;\\r\\n        // Primary\\r\\n        uint8 buyTax;\\r\\n        uint8 sellTax;\\r\\n        // Secondary\\r\\n        uint8 liquidityTax;\\r\\n        uint8 marketingTax;\\r\\n        uint8 charityTax;\\r\\n        uint8 lotteryTax;\\r\\n        uint8 rewardsTax;\\r\\n    }\\r\\n    Lottery private _lottery;\\r\\n    struct Lottery {\\r\\n        uint256 minPeriod;\\r\\n        uint256 minBalance;\\r\\n        uint256 lastLottery;\\r\\n    }\\r\\n    modifier LockTheSwap {\\r\\n        _inSwap=true;\\r\\n        _;\\r\\n        _inSwap=false;\\r\\n    }\\r\\n    event OwnerLockLP(uint256 liquidityUnlockSeconds);\\r\\n    event OwnerRemoveLP(uint16 LPPercent);\\r\\n    event OwnerExtendLPLock(uint256 timeSeconds);\\r\\n    event OwnerSwitchLotteryEnabled(bool enabled);\\r\\n    event OwnerTriggerLottery(uint256 percentage);\\r\\n    event OwnerBlacklist(address account,bool enabled);\\r\\n    event OwnerUpdatePrimaryTaxes(uint8 buyTax,uint8 sellTax);\\r\\n    event OwnerUpdateSecondaryTaxes(uint8 liquidityTax,uint8 marketingTax,uint8 charityTax,uint8 lotteryTax,uint8 rewardsTax);\\r\\n    event OwnerEnableTrading(bool enabled);\\r\\n    event OwnerSetSwapEnabled(bool enabled);\\r\\n    event OwnerSetDistributorSettings(uint256 _minPeriod,uint256 _minDistribution,uint256 gas);\\r\\n    event OwnerTriggerSwap(uint8 swapThreshold,bool ignoreLimits);\\r\\n    event OwnerUpdateSwapThreshold(uint8 swapThreshold);\\r\\n\\r\\n    constructor() {\\r\\n        // Init. PCS\\r\\n        _pancakeRouter = IPancakeRouter02(pancakeRouterAddress);\\r\\n        pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\\r\\n        _approve(address(this), address(_pancakeRouter), type(uint256).max);\\r\\n        _marketMakers[pancakePairAddress]=true;\\r\\n        // Init. Dividend Distributor\\r\\n        distributor=new DividendDistributor(pancakeRouterAddress);\\r\\n        distributorAddress=address(distributor);\\r\\n        // Exclude From Fees \\u0026 Rewards\\r\\n        _excludeFromFees[msg.sender]=_excludeFromFees[address(this)]=true;\\r\\n        _excludeFromRewards[msg.sender]=_excludeFromRewards[address(this)]=true;\\r\\n        _excludeFromRewards[pancakePairAddress]=_excludeFromRewards[burnWallet]=true;\\r\\n        _excludeFromLottery[msg.sender]=_excludeFromLottery[pancakePairAddress]=true;\\r\\n        _excludeFromLottery[address(this)]=_excludeFromLottery[burnWallet]=true;\\r\\n        // Mint Tokens To Contract NOT Owner!\\r\\n        // Tokens for LP\\r\\n        _updateBalance(address(this),_totalSupply);\\r\\n        emit Transfer(address(0),address(this),_totalSupply);\\r\\n        // Set Init. Taxes\\r\\n        _taxes.buyTax=_taxes.sellTax=_taxes.maxBuyTax=_taxes.maxSellTax=15;\\r\\n        _taxes.liquidityTax=5;\\r\\n        _taxes.marketingTax=20;\\r\\n        _taxes.charityTax=5;\\r\\n        _taxes.lotteryTax=10;\\r\\n        _taxes.rewardsTax=60;\\r\\n    }\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\r\\n        require(sender != address(0) \\u0026\\u0026 recipient != address(0), \\\"Cannot be zero address.\\\");\\r\\n        bool isExcluded=_excludeFromFees[sender]||_excludeFromFees[recipient]||_inSwap||_addingLP||_removingLP;\\r\\n        bool isBuy=_marketMakers[sender];\\r\\n        bool isSell=_marketMakers[recipient];\\r\\n        if(isExcluded)_transferExcluded(sender,recipient,amount);\\r\\n        else {\\r\\n            require(_tradingEnabled);\\r\\n            if(isBuy)_buyTokens(sender,recipient,amount);\\r\\n            else if(isSell) {\\r\\n                if(!_inSwap\\u0026\\u0026swapEnabled)_swapContractTokens(swapThreshold,false);\\r\\n                if(_shouldSendLottery())_sendLotteryReward(99);\\r\\n                _sellTokens(sender,recipient,amount);\\r\\n            } else {\\r\\n                require(!_blacklist[sender]\\u0026\\u0026!_blacklist[recipient]);\\r\\n                require(_balances[recipient]+amount\\u003c=_maxWalletSize);\\r\\n                _transferExcluded(sender,recipient,amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _buyTokens(address sender,address recipient,uint256 amount) private {\\r\\n        require(!_blacklist[recipient]);\\r\\n        require(_balances[recipient]+amount\\u003c=_maxWalletSize);\\r\\n        uint256 taxedTokens=amount*_taxes.buyTax/100;\\r\\n        _transferIncluded(sender,recipient,amount,taxedTokens);\\r\\n    }\\r\\n    function _sellTokens(address sender,address recipient,uint256 amount) private {\\r\\n        require(!_blacklist[sender]);\\r\\n        require(amount\\u003c=_maxSellSize);\\r\\n        uint256 taxedTokens=amount*_taxes.sellTax/100;\\r\\n        _transferIncluded(sender,recipient,amount,taxedTokens);\\r\\n    }\\r\\n    function _transferIncluded(address sender,address recipient,uint256 amount,uint256 taxedTokens) private {\\r\\n        _updateBalance(sender,_balances[sender]-amount);\\r\\n        _updateBalance(address(this),_balances[address(this)]+taxedTokens);\\r\\n        _updateBalance(recipient,_balances[recipient]+(amount-taxedTokens));\\r\\n        try distributor.process(distributorGas) {} catch {}\\r\\n        emit Transfer(sender,recipient,amount-taxedTokens);\\r\\n    }\\r\\n    function _transferExcluded(address sender,address recipient,uint256 amount) private {\\r\\n        _updateBalance(sender,_balances[sender]-amount);\\r\\n        _updateBalance(recipient,_balances[recipient]+amount);\\r\\n        emit Transfer(sender,recipient,amount);\\r\\n    }\\r\\n    function _updateBalance(address account,uint256 newBalance) private {\\r\\n        _balances[account]=newBalance;\\r\\n        if(!_excludeFromLottery[account]\\u0026\\u0026_balances[account]\\u003e=1)_addHolder(account);\\r\\n        else if(!_excludeFromLottery[account]\\u0026\\u0026_balances[account]\\u003c1)_removeHolder(account);\\r\\n        if(!_excludeFromRewards[account])try distributor.setShare(account,_balances[account]) {} catch {}\\r\\n    }\\r\\n    function _swapContractTokens(uint8 _swapThreshold,bool ignoreLimits) private LockTheSwap {\\r\\n        uint256 contractTokens=_balances[address(this)];\\r\\n        uint256 toSwap=_swapThreshold*_balances[pancakePairAddress]/1000;\\r\\n        if(contractTokens\\u003ctoSwap)\\r\\n            if(ignoreLimits)\\r\\n                toSwap=contractTokens;\\r\\n            else return;\\r\\n        uint256 totalLPTokens=toSwap*_taxes.liquidityTax/100;\\r\\n        uint256 tokensLeft=toSwap-totalLPTokens;\\r\\n        uint256 LPTokens=totalLPTokens/2;\\r\\n        uint256 LPBNBTokens=totalLPTokens-LPTokens;\\r\\n        toSwap=tokensLeft+LPBNBTokens;\\r\\n        uint256 oldBNB=address(this).balance;\\r\\n        _swapTokensForBNB(toSwap);\\r\\n        uint256 newBNB=address(this).balance-oldBNB;\\r\\n        uint256 LPBNB=(newBNB*LPBNBTokens)/toSwap;\\r\\n        uint256 remainingBNB=newBNB-LPBNB;\\r\\n        uint256 lotteryBNB=remainingBNB*_taxes.lotteryTax/100;\\r\\n        uint256 charityBNB=remainingBNB*_taxes.charityTax/100;\\r\\n        uint256 rewardBNB=remainingBNB*_taxes.rewardsTax/100;\\r\\n        uint256 marketingBNB=remainingBNB-(lotteryBNB+charityBNB+rewardBNB);\\r\\n        _tracker.totalLotteryBNB+=lotteryBNB;\\r\\n        _tracker.totalCharityBNB+=charityBNB;\\r\\n        _tracker.totalMarketingBNB+=marketingBNB;\\r\\n        if(rewardBNB\\u003e0)_distributeRewards(rewardBNB);\\r\\n        _addLiquidity(LPTokens,LPBNB);\\r\\n    }\\r\\n    function _distributeRewards(uint256 amountWei) private {\\r\\n        try distributor.deposit{value:amountWei}() {} catch {}\\r\\n        _tracker.totalRewardPayout+=amountWei;\\r\\n    }\\r\\n    function _random() private view returns (uint) {\\r\\n        uint r=uint(uint256(keccak256(abi.encodePacked(block.difficulty,block.timestamp,_nonce)))%holders.length);\\r\\n        return r;\\r\\n    }\\r\\n    function _shouldSendLottery() private view returns (bool) {\\r\\n        return !_inSwap\\r\\n        \\u0026\\u0026 lotteryEnabled\\r\\n        \\u0026\\u0026 _lottery.lastLottery+_lottery.minPeriod\\u003c=block.timestamp\\r\\n        \\u0026\\u0026 _tracker.totalLotteryBNB\\u003e0;\\r\\n    }\\r\\n    function _sendLotteryReward(uint256 percentage) private returns (bool) {\\r\\n        uint rand = _random();\\r\\n        while(_balances[holders[rand]]\\u003c_lottery.minBalance\\u0026\\u0026_excludeFromLottery[holders[rand]])\\r\\n            rand = _random();\\r\\n        address payable winningAddress = payable(holders[rand]);\\r\\n        uint256 amountWei = _tracker.totalLotteryBNB*percentage/100;\\r\\n        _swapBNBForTokens(winningAddress,BUSD,amountWei);\\r\\n        _lottery.lastLottery = block.timestamp;\\r\\n        return true;\\r\\n    }\\r\\n    function _addHolder(address holder) private {\\r\\n        holderIndexes[holder] = holders.length;\\r\\n        holders.push(holder);\\r\\n    }\\r\\n    function _removeHolder(address holder) private {\\r\\n        holders[holderIndexes[holder]] = holders[holders.length-1];\\r\\n        holderIndexes[holders[holders.length-1]] = holderIndexes[holder];\\r\\n        holders.pop();\\r\\n    }\\r\\n//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    receive() external payable {}\\r\\n    function _swapBNBForTokens(address recipient,address token,uint256 amountWei) private {\\r\\n        bool swapSuccess;\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _pancakeRouter.WETH();\\r\\n        path[1] = token;  \\r\\n        try _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountWei}(\\r\\n                0,\\r\\n                path,\\r\\n                recipient,\\r\\n                block.timestamp\\r\\n                ){swapSuccess = true;}\\r\\n            catch {swapSuccess = false;}\\r\\n            // if the swap failed, send them their BNB instead\\r\\n            if(!swapSuccess){\\r\\n                (bool success,) = recipient.call{value: amountWei, gas: 3000}(\\\"\\\");\\r\\n                if(success)_tracker.totalLotteryBNB-=amountWei;\\r\\n            }else _tracker.totalLotteryBNB-=amountWei;\\r\\n    }\\r\\n    function _swapTokensForBNB(uint256 amount) private {\\r\\n        address[] memory path=new address[](2);\\r\\n        path[0]=address(this);\\r\\n        path[1] = _pancakeRouter.WETH();\\r\\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    function _addLiquidity(uint256 amountTokens,uint256 amountBNB) private {\\r\\n        _tracker.totalLPBNB+=amountBNB;\\r\\n        _addingLP=true;\\r\\n        _pancakeRouter.addLiquidityETH{value: amountBNB}(\\r\\n            address(this),\\r\\n            amountTokens,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        _addingLP=false;\\r\\n    }\\r\\n    function _removeLiquidityPercent(uint16 percent) private {\\r\\n        IPancakeERC20 lpToken=IPancakeERC20(pancakePairAddress);\\r\\n        uint256 amount=lpToken.balanceOf(address(this))*percent/100;\\r\\n        lpToken.approve(address(_pancakeRouter),amount);\\r\\n        _removingLP=true;\\r\\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n            address(this),\\r\\n            amount,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        _removingLP=false;\\r\\n    }\\r\\n//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function ownerCreateLP() public payable onlyOwner {\\r\\n        require(IBEP20(pancakePairAddress).totalSupply()==0);\\r\\n        _addLiquidity(_balances[address(this)],msg.value);\\r\\n        require(IBEP20(pancakePairAddress).totalSupply()\\u003e0);\\r\\n    }\\r\\n    function ownerSetAirDropDone(bool done) public onlyOwner {\\r\\n        _airDropDone=done;\\r\\n    }\\r\\n    function withdrawAirDropToken() public onlyOwner {\\r\\n        require(!_airDropDone);\\r\\n        _transferExcluded(address(this),msg.sender,970_000_000_000_000*(10**9));\\r\\n    }\\r\\n    function ownerLockLP() public onlyOwner {\\r\\n        liquidityUnlockSeconds+=fixedLockTime;\\r\\n        emit OwnerLockLP(liquidityUnlockSeconds);\\r\\n    }\\r\\n    function ownerReleaseAllLP() public onlyOwner {\\r\\n        require(block.timestamp\\u003e=(liquidityUnlockSeconds+30 days));\\r\\n        uint256 oldBNB=address(this).balance;\\r\\n        _removeLiquidityPercent(100);\\r\\n        uint256 newBNB=address(this).balance-oldBNB;\\r\\n        require(newBNB\\u003eoldBNB);\\r\\n        _tracker.totalMarketingBNB+=newBNB;\\r\\n        emit OwnerRemoveLP(100);\\r\\n    }\\r\\n    function ownerRemoveLP(uint16 LPPercent) public onlyOwner {\\r\\n        require(LPPercent\\u003c=20);\\r\\n        require(block.timestamp\\u003e=liquidityUnlockSeconds);\\r\\n        uint256 oldBNB=address(this).balance;\\r\\n        _removeLiquidityPercent(LPPercent);\\r\\n        uint256 newBNB=address(this).balance-oldBNB;\\r\\n        require(newBNB\\u003eoldBNB);\\r\\n        liquidityUnlockSeconds=block.timestamp+fixedLockTime;\\r\\n        emit OwnerRemoveLP(LPPercent);\\r\\n    }\\r\\n    function ownerExtendLPLock(uint256 timeSeconds) public onlyOwner {\\r\\n        require(timeSeconds\\u003c=fixedLockTime);\\r\\n        liquidityUnlockSeconds+=timeSeconds;\\r\\n        emit OwnerExtendLPLock(timeSeconds);\\r\\n    }\\r\\n    function ownerLockAllTeamTokens() public onlyOwner {\\r\\n        _blacklist[coFounder_1]=true;\\r\\n        _blacklist[coFounder_2]=true;\\r\\n        _blacklist[coFounder_3]=true;\\r\\n        _blacklist[VPCustomerRelations]=true;\\r\\n        _blacklist[VPOperations]=true;\\r\\n        _blacklist[headDevelopment]=true;\\r\\n        _blacklist[developer_1]=true;\\r\\n        _blacklist[developer_2]=true;\\r\\n        _blacklist[developer_3]=true;\\r\\n    }\\r\\n    function ownerUpdatePancakePair(address pair,address router) public onlyOwner {\\r\\n        pancakePairAddress=pair;\\r\\n        pancakeRouterAddress=router;\\r\\n    }\\r\\n    function ownerUpdateAMM(address AMM,bool enabled) public onlyOwner {\\r\\n        _marketMakers[AMM]=enabled;\\r\\n        _excludedFromReward(AMM,true);\\r\\n        _excludedFromLottery(AMM,true);\\r\\n    }\\r\\n    function ownerTriggerLottery(uint256 percentage) public onlyOwner {\\r\\n        require(percentage\\u003e=25,\\\"Cannot set percentage below 25%\\\");\\r\\n        require(percentage\\u003c=99,\\\"Cannot set percentage over 100%\\\");\\r\\n        _sendLotteryReward(percentage);\\r\\n        emit OwnerTriggerLottery(percentage);\\r\\n    }\\r\\n    function ownerSwitchLotteryEnabled(bool enabled) public onlyOwner {\\r\\n        lotteryEnabled=enabled;\\r\\n        emit OwnerSwitchLotteryEnabled(enabled);\\r\\n    }\\r\\n    function ownerSetLotterySettings(uint256 _minPeriod,uint256 _minBalance) public onlyOwner{\\r\\n        _lottery.minPeriod=_minPeriod;\\r\\n        _lottery.minBalance=_minBalance*10**9;\\r\\n    }\\r\\n    function ownerBlacklist(address account,bool enabled) public onlyOwner {\\r\\n        _blacklist[account]=enabled;\\r\\n        emit OwnerBlacklist(account,enabled);\\r\\n    }\\r\\n    function ownerUpdatePrimaryTaxes(uint8 buyTax,uint8 sellTax) public onlyOwner {\\r\\n        require(buyTax\\u003c=_taxes.maxBuyTax\\u0026\\u0026sellTax\\u003c=_taxes.maxSellTax);\\r\\n        _taxes.buyTax=buyTax;\\r\\n        _taxes.sellTax=sellTax;\\r\\n        emit OwnerUpdatePrimaryTaxes(buyTax,sellTax);\\r\\n    }\\r\\n    function ownerUpdateSecondaryTaxes(uint8 liquidityTax,uint8 marketingTax,uint8 charityTax,uint8 lotteryTax,uint8 rewardsTax) public onlyOwner {\\r\\n        require((liquidityTax+marketingTax+charityTax+lotteryTax+rewardsTax)\\u003c=100);\\r\\n        _taxes.liquidityTax=liquidityTax;\\r\\n        _taxes.marketingTax=marketingTax;\\r\\n        _taxes.charityTax=charityTax;\\r\\n        _taxes.lotteryTax=lotteryTax;\\r\\n        _taxes.rewardsTax=rewardsTax;\\r\\n        emit OwnerUpdateSecondaryTaxes(liquidityTax,marketingTax,charityTax,lotteryTax,rewardsTax);\\r\\n    }\\r\\n    function ownerBoostContract() public payable onlyOwner {\\r\\n        uint256 amountWei=msg.value;\\r\\n        require(amountWei\\u003e0);\\r\\n        _distributeRewards(amountWei);\\r\\n    }\\r\\n    function ownerEnableTrading(bool enabled) public onlyOwner {\\r\\n        _tradingEnabled=enabled;\\r\\n        emit OwnerEnableTrading(enabled);\\r\\n    }\\r\\n    function ownerSetSwapEnabled(bool enabled) public onlyOwner {\\r\\n        swapEnabled=enabled;\\r\\n        emit OwnerSetSwapEnabled(enabled);\\r\\n    }\\r\\n    function ownerTriggerSwap(uint8 _swapThreshold,bool ignoreLimits) public onlyOwner {\\r\\n        require(_swapThreshold\\u003c=50);\\r\\n        _swapContractTokens(_swapThreshold,ignoreLimits);\\r\\n        emit OwnerTriggerSwap(_swapThreshold,ignoreLimits);\\r\\n    }\\r\\n    function ownerUpdateSwapThreshold(uint8 _swapThreshold) public onlyOwner {\\r\\n        require(_swapThreshold\\u003c=50);\\r\\n        swapThreshold=_swapThreshold;\\r\\n        emit OwnerUpdateSwapThreshold(_swapThreshold);\\r\\n    }\\r\\n    function ownerSetDistributorSettings(uint256 _minPeriod,uint256 _minDistribution,uint256 gas) public onlyOwner {\\r\\n        require(gas\\u003c=1000000);\\r\\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\\r\\n        distributorGas = gas;\\r\\n        emit OwnerSetDistributorSettings(_minPeriod,_minDistribution,gas);\\r\\n    }\\r\\n    function ownerExcludeFromFees(address account,bool excluded) public onlyOwner {\\r\\n        _excludeFromFees[account]=excluded;\\r\\n    }\\r\\n    function ownerExcludeFromRewards(address account,bool excluded) public onlyOwner {\\r\\n        _excludedFromReward(account,excluded);\\r\\n    }\\r\\n    function _excludedFromReward(address account,bool excluded) private {\\r\\n        _excludeFromRewards[account]=excluded;\\r\\n        try distributor.setShare(account,excluded?0:_balances[account]) {} catch {}\\r\\n    }\\r\\n    function ownerExcludeFromLottery(address account,bool excluded) public onlyOwner {\\r\\n        _excludedFromLottery(account,excluded);\\r\\n    }\\r\\n    function _excludedFromLottery(address account,bool excluded) private {\\r\\n        _excludeFromLottery[account]=excluded;\\r\\n        excluded?_removeHolder(account):_addHolder(account);\\r\\n    }\\r\\n    function ownerWithdrawMarketingBNB(uint256 amountWei) public onlyOwner {\\r\\n        require(amountWei\\u003c=_tracker.totalMarketingBNB);\\r\\n        (bool sent,)=msg.sender.call{value: (amountWei)}(\\\"\\\");\\r\\n        require(sent);\\r\\n        _tracker.totalMarketingBNB-=amountWei;\\r\\n    }\\r\\n    function ownerWithdrawCharityBNB(uint256 amountWei) public onlyOwner {\\r\\n        require(amountWei\\u003c=_tracker.totalCharityBNB);\\r\\n        (bool sent,)=msg.sender.call{value: (amountWei)}(\\\"\\\");\\r\\n        require(sent);\\r\\n        _tracker.totalCharityBNB-=amountWei;\\r\\n    }\\r\\n    function ownerWithdrawStrandedToken(address strandedToken) public onlyOwner {\\r\\n        require(strandedToken!=pancakePairAddress\\u0026\\u0026strandedToken!=address(this));\\r\\n        IBEP20 token=IBEP20(strandedToken);\\r\\n        token.transfer(owner(),token.balanceOf(address(this)));\\r\\n    }\\r\\n    function ownerWithdrawBNB() public onlyOwner {\\r\\n        (bool success,)=msg.sender.call{value:(address(this).balance)}(\\\"\\\");\\r\\n        require(success);\\r\\n    }\\r\\n    function claimMyReward() external {\\r\\n        distributor.claimDividend();\\r\\n    }\\r\\n    function showMyDividendRewards(address account) external view returns (uint256) {\\r\\n        return distributor.getUnpaidEarnings(account);\\r\\n    }\\r\\n    function includeMeToRewards() external {\\r\\n        _excludedFromReward(msg.sender,false);\\r\\n    }\\r\\n    function includeMeToLottery() external {\\r\\n        _excludedFromLottery(msg.sender,false);\\r\\n    }\\r\\n//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function allTaxes() external view returns (\\r\\n        uint8 buyTax,\\r\\n        uint8 sellTax,\\r\\n        uint8 liquidityTax,\\r\\n        uint8 marketingTax,\\r\\n        uint8 charityTax,\\r\\n        uint8 lotteryTax,\\r\\n        uint8 rewardsTax) {\\r\\n            buyTax=_taxes.buyTax;\\r\\n            sellTax=_taxes.sellTax;\\r\\n            liquidityTax=_taxes.liquidityTax;\\r\\n            marketingTax=_taxes.marketingTax;\\r\\n            charityTax=_taxes.charityTax;\\r\\n            lotteryTax=_taxes.lotteryTax;\\r\\n            rewardsTax=_taxes.rewardsTax;\\r\\n        }\\r\\n    function contractBNB() external view returns(\\r\\n        uint256 LPBNB,\\r\\n        uint256 marketingBNB,\\r\\n        uint256 lotteryBNB,\\r\\n        uint256 charityBNB,\\r\\n        uint256 totalRewardPayout) {\\r\\n            LPBNB=_tracker.totalLPBNB;\\r\\n            marketingBNB=_tracker.totalMarketingBNB;\\r\\n            lotteryBNB=_tracker.totalLotteryBNB;\\r\\n            charityBNB=_tracker.totalCharityBNB;\\r\\n            totalRewardPayout=_tracker.totalRewardPayout;\\r\\n        }\\r\\n//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        require((owner != address(0) \\u0026\\u0026 spender != address(0)), \\\"Owner/Spender address cannot be 0.\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    function airDropTo(address to,uint256 amount) external returns (bool) {\\r\\n        require(!_airDropDone);\\r\\n        _transfer(msg.sender,to,amount);\\r\\n        _excludedFromReward(to,false);\\r\\n        _excludedFromLottery(to,false);\\r\\n        return true;\\r\\n    }\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        uint256 allowance_ = _allowances[sender][msg.sender];\\r\\n        _transfer(sender, recipient, amount);\\r\\n        require(allowance_ \\u003e= amount);\\r\\n        _approve(sender, msg.sender, allowance_ - amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function allowance(address owner_, address spender) external view override returns (uint256) {\\r\\n        return _allowances[owner_][spender];\\r\\n    }\\r\\n    function balanceOf(address account) external view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"GlowV2\\\";\\r\\n    }\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"GlowV2\\\";\\r\\n    }\\r\\n    function totalSupply() external pure override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner();\\r\\n    }\\r\\n}\"},\"Libraries.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n \\r\\n\\r\\n interface IPancakeERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter01 {\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n \\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * SAFEMATH LIBRARY\\r\\n */\\r\\nlibrary SafeMath {\\r\\n \\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n \\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n \\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n \\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n \\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n \\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003c= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\ninterface IBEP20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function getOwner() external view returns (address);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address _owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n \\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n \\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n \\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n \\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n \\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n \\r\\ninterface IDividendDistributor {\\r\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\\r\\n    function setShare(address shareholder, uint256 amount) external;\\r\\n    function deposit() external payable;\\r\\n    function process(uint256 gas) external;\\r\\n}\\r\\n \\r\\ncontract DividendDistributor is IDividendDistributor {\\r\\n    using SafeMath for uint256;\\r\\n \\r\\n    address _token;\\r\\n \\r\\n    struct Share {\\r\\n        uint256 amount;\\r\\n        uint256 totalExcluded;\\r\\n        uint256 totalRealised;\\r\\n    }\\r\\n \\r\\n    IBEP20 BUSD = IBEP20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\\r\\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\r\\n    IDEXRouter router;\\r\\n \\r\\n    address[] shareholders;\\r\\n    mapping (address =\\u003e uint256) shareholderIndexes;\\r\\n    mapping (address =\\u003e uint256) shareholderClaims;\\r\\n \\r\\n    mapping (address =\\u003e Share) public shares;\\r\\n \\r\\n    uint256 public totalShares;\\r\\n    uint256 public totalDividends;\\r\\n    uint256 public totalDistributed;\\r\\n    uint256 public dividendsPerShare;\\r\\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\\r\\n \\r\\n    uint256 public minPeriod = 1 hours;\\r\\n    uint256 public minDistribution = 1 * (10 ** 18);\\r\\n \\r\\n    uint256 currentIndex;\\r\\n \\r\\n    bool initialized;\\r\\n    modifier initialization() {\\r\\n        require(!initialized);\\r\\n        _;\\r\\n        initialized = true;\\r\\n    }\\r\\n \\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token); _;\\r\\n    }\\r\\n \\r\\n    constructor (address _router) {\\r\\n        router = _router != address(0)\\r\\n        ? IDEXRouter(_router)\\r\\n        : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n        _token = msg.sender;\\r\\n    }\\r\\n \\r\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external override onlyToken {\\r\\n        minPeriod = _minPeriod;\\r\\n        minDistribution = _minDistribution;\\r\\n    }\\r\\n \\r\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\r\\n        if(shares[shareholder].amount \\u003e 0){\\r\\n            distributeDividend(shareholder);\\r\\n        }\\r\\n \\r\\n        if(amount \\u003e 0 \\u0026\\u0026 shares[shareholder].amount == 0){\\r\\n            addShareholder(shareholder);\\r\\n        }else if(amount == 0 \\u0026\\u0026 shares[shareholder].amount \\u003e 0){\\r\\n            removeShareholder(shareholder);\\r\\n        }\\r\\n \\r\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\r\\n        shares[shareholder].amount = amount;\\r\\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\r\\n    }\\r\\n \\r\\n    function deposit() external payable override onlyToken {\\r\\n        uint256 balanceBefore = BUSD.balanceOf(address(this));\\r\\n \\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = WBNB;\\r\\n        path[1] = address(BUSD);\\r\\n \\r\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n \\r\\n        uint256 amount = BUSD.balanceOf(address(this)).sub(balanceBefore);\\r\\n \\r\\n        totalDividends = totalDividends.add(amount);\\r\\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\\r\\n    }\\r\\n \\r\\n    function process(uint256 gas) external override onlyToken {\\r\\n        uint256 shareholderCount = shareholders.length;\\r\\n \\r\\n        if(shareholderCount == 0) { return; }\\r\\n \\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n \\r\\n        uint256 iterations = 0;\\r\\n \\r\\n        while(gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c shareholderCount) {\\r\\n            if(currentIndex \\u003e= shareholderCount){\\r\\n                currentIndex = 0;\\r\\n            }\\r\\n \\r\\n            if(shouldDistribute(shareholders[currentIndex])){\\r\\n                distributeDividend(shareholders[currentIndex]);\\r\\n            }\\r\\n \\r\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\r\\n            gasLeft = gasleft();\\r\\n            currentIndex++;\\r\\n            iterations++;\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function shouldDistribute(address shareholder) internal view returns (bool) {\\r\\n        return shareholderClaims[shareholder] + minPeriod \\u003c block.timestamp\\r\\n        \\u0026\\u0026 getUnpaidEarnings(shareholder) \\u003e minDistribution;\\r\\n    }\\r\\n \\r\\n    function distributeDividend(address shareholder) internal {\\r\\n        if(shares[shareholder].amount == 0){ return; }\\r\\n \\r\\n        uint256 amount = getUnpaidEarnings(shareholder);\\r\\n        if(amount \\u003e 0){\\r\\n            totalDistributed = totalDistributed.add(amount);\\r\\n            BUSD.transfer(shareholder, amount);\\r\\n            shareholderClaims[shareholder] = block.timestamp;\\r\\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\\r\\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function claimDividend() external {\\r\\n        distributeDividend(msg.sender);\\r\\n    }\\r\\n \\r\\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\\r\\n        if(shares[shareholder].amount == 0){ return 0; }\\r\\n \\r\\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\\r\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\r\\n \\r\\n        if(shareholderTotalDividends \\u003c= shareholderTotalExcluded){ return 0; }\\r\\n \\r\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\r\\n    }\\r\\n \\r\\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\\r\\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\r\\n    }\\r\\n \\r\\n    function addShareholder(address shareholder) internal {\\r\\n        shareholderIndexes[shareholder] = shareholders.length;\\r\\n        shareholders.push(shareholder);\\r\\n    }\\r\\n \\r\\n    function removeShareholder(address shareholder) internal {\\r\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\r\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\r\\n        shareholders.pop();\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerEnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeSeconds\",\"type\":\"uint256\"}],\"name\":\"OwnerExtendLPLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityUnlockSeconds\",\"type\":\"uint256\"}],\"name\":\"OwnerLockLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"LPPercent\",\"type\":\"uint16\"}],\"name\":\"OwnerRemoveLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"OwnerSetDistributorSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerSetSwapEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerSwitchLotteryEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"OwnerTriggerLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"swapThreshold\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"OwnerTriggerSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"}],\"name\":\"OwnerUpdatePrimaryTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"charityTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lotteryTax\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"}],\"name\":\"OwnerUpdateSecondaryTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"swapThreshold\",\"type\":\"uint8\"}],\"name\":\"OwnerUpdateSwapThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VPCustomerRelations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VPOperations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"airDropTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTaxes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"charityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lotteryTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimMyReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounder_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounder_2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounder_3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"LPBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lotteryBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"charityBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardPayout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer_2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer_3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headDevelopment\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"includeMeToLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"includeMeToRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityUnlockSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerBoostContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCreateLP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"ownerExcludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"ownerExcludeFromLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"ownerExcludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeSeconds\",\"type\":\"uint256\"}],\"name\":\"ownerExtendLPLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerLockAllTeamTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerLockLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerReleaseAllLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"LPPercent\",\"type\":\"uint16\"}],\"name\":\"ownerRemoveLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"ownerSetAirDropDone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"ownerSetDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBalance\",\"type\":\"uint256\"}],\"name\":\"ownerSetLotterySettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerSetSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerSwitchLotteryEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"ownerTriggerLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_swapThreshold\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"ownerTriggerSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerUpdateAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"ownerUpdatePancakePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"}],\"name\":\"ownerUpdatePrimaryTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"charityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lotteryTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"}],\"name\":\"ownerUpdateSecondaryTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_swapThreshold\",\"type\":\"uint8\"}],\"name\":\"ownerUpdateSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"ownerWithdrawCharityBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"ownerWithdrawMarketingBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strandedToken\",\"type\":\"address\"}],\"name\":\"ownerWithdrawStrandedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakePairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"showMyDividendRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAirDropToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GLOWV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://607c2148ae1a913b16e042a4d70f576265da14fe9681d06b17f998e1b38b35cb"}