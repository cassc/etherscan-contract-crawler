{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Ecto.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"./interfaces/IBEP20.sol\\\";\\r\\nimport \\\"./interfaces/IDEXFactory.sol\\\";\\r\\nimport \\\"./interfaces/IDEXRouter.sol\\\";\\r\\nimport \\\"./DividendDistributor.sol\\\";\\r\\nimport \\\"./Airdropper.sol\\\";\\r\\nimport \\\"./abstracts/Auth.sol\\\";\\r\\n\\r\\ncontract Ecto is IBEP20, Auth {\\r\\n    /* BEP20 attributes */\\r\\n    string constant _name = \\\"LittleGhosts Ectoplasm\\\";\\r\\n    string constant _symbol = \\\"ECTO\\\";\\r\\n    uint8 constant _decimals = 9;\\r\\n    uint256 constant _totalSupply = 1 * (10**12) * (10**_decimals);\\r\\n    mapping(address => uint256) _balances;\\r\\n    mapping(address => mapping(address => uint256)) _allowances;\\r\\n\\r\\n    /* ECTO token attributes */\\r\\n    uint256 public launchedAt;\\r\\n    bool public tradingOpen = false;\\r\\n\\r\\n    /* ECTO token restrictions */\\r\\n    uint256 public _maxTxAmount = (_totalSupply * 2) / 200;\\r\\n    uint256 public _walletMax = (_totalSupply * 3) / 100;\\r\\n    bool public restrictWhales = true;\\r\\n\\r\\n    /* ECTO token bypass restrictions */\\r\\n    mapping(address => bool) public isFeeExempt;\\r\\n    mapping(address => bool) public isTxLimitExempt;\\r\\n    mapping(address => bool) public isDividendExempt;\\r\\n\\r\\n    /* Reward token attributes */\\r\\n    uint256 public liquidityFee = 7;\\r\\n    uint256 public rewardsFee = 8;\\r\\n    uint256 public extraFeeOnSell = 0;\\r\\n    uint256 public totalFee = 0;\\r\\n    uint256 public totalFeeIfSelling = 0;\\r\\n    bool inSwapAndLiquify;\\r\\n    bool public swapAndLiquifyEnabled = true;\\r\\n    uint256 public swapThreshold = (_totalSupply * 5) / 4000;\\r\\n\\r\\n    /* Constant variables */\\r\\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\\r\\n\\r\\n    /* Circulating Supply */\\r\\n    address[] public circulatingSupplyExclusions = [DEAD, ZERO];\\r\\n\\r\\n    /* Router */\\r\\n    address routerAddress;\\r\\n    IDEXRouter public router;\\r\\n    address public pair;\\r\\n\\r\\n    /* Reward tokens */\\r\\n    address rewardToken;\\r\\n    bool rewardTokenHasTxFee = false; //Flag for whether the reward token charges transaction fees (transfer, trading, etc)\\r\\n\\r\\n    /* Dividend distributor */\\r\\n    DividendDistributor public dividendDistributor;\\r\\n    uint256 distributorGas = 500000;\\r\\n\\r\\n    /* Airdropper */\\r\\n    Airdropper public airdropper;\\r\\n    address public oldEctoContractAddress;\\r\\n\\r\\n    /* Team wallet */\\r\\n    address public teamWallet;\\r\\n\\r\\n    event TradingStatusChanged(bool status);\\r\\n    event RouterChanged(address newRouterAddress);\\r\\n    event DistributorChanged(address distributor);\\r\\n    event TeamWalletChanged(address newTeamWallet);\\r\\n    event AddedToCirculatingSupplyExclusion(address _address);\\r\\n    event RemovedFromCirculatingSupplyExclusion(address _address);\\r\\n\\r\\n    modifier lockTheSwap() {\\r\\n        inSwapAndLiquify = true;\\r\\n        _;\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _oldContractAddress,\\r\\n        address _routerAddress,\\r\\n        address _rewardToken,\\r\\n        address _teamWallet\\r\\n    ) Auth(msg.sender) {\\r\\n        /* Set _oldContractAddress */\\r\\n        oldEctoContractAddress = _oldContractAddress;\\r\\n\\r\\n        /* Set _routerAddress */\\r\\n        routerAddress = _routerAddress;\\r\\n        router = IDEXRouter(routerAddress);\\r\\n\\r\\n        /* Set _rewardToken */\\r\\n        rewardToken = _rewardToken;\\r\\n\\r\\n        /* Set _teamWallet */\\r\\n        teamWallet = _teamWallet;\\r\\n\\r\\n        /* Create pair */\\r\\n        pair = IDEXFactory(router.factory()).createPair(\\r\\n            router.WETH(),\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        /* Create dividend distributor */\\r\\n        dividendDistributor = new DividendDistributor(\\r\\n            _routerAddress,\\r\\n            _rewardToken\\r\\n        );\\r\\n\\r\\n        /* Create airdropper */\\r\\n        airdropper = new Airdropper(_oldContractAddress);\\r\\n\\r\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\r\\n        _allowances[address(airdropper)][address(airdropper)] = type(uint256)\\r\\n            .max;\\r\\n\\r\\n        isFeeExempt[msg.sender] = true;\\r\\n        isFeeExempt[address(this)] = true;\\r\\n        isFeeExempt[address(airdropper)] = true;\\r\\n\\r\\n        isTxLimitExempt[msg.sender] = true;\\r\\n        isTxLimitExempt[pair] = true;\\r\\n        isTxLimitExempt[address(airdropper)] = true;\\r\\n\\r\\n        isDividendExempt[pair] = true;\\r\\n        isDividendExempt[address(airdropper)] = true;\\r\\n        isDividendExempt[msg.sender] = true;\\r\\n        isDividendExempt[address(this)] = true;\\r\\n        isDividendExempt[DEAD] = true;\\r\\n        isDividendExempt[ZERO] = true;\\r\\n\\r\\n        authorizations[address(airdropper)] = true;\\r\\n\\r\\n        totalFee = liquidityFee + rewardsFee;\\r\\n        totalFeeIfSelling = totalFee + extraFeeOnSell;\\r\\n\\r\\n        _balances[address(airdropper)] = _totalSupply;\\r\\n        emit Transfer(address(0), address(airdropper), _totalSupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external pure override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    function getCirculatingSupply() external view returns (uint256) {\\r\\n        uint256 result = _totalSupply;\\r\\n        for (uint256 i = 0; i < circulatingSupplyExclusions.length; i++) {\\r\\n            result = result - balanceOf(circulatingSupplyExclusions[i]);\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function allowance(address holder, address spender)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[holder][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount)\\r\\n        public\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _allowances[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approveMax(address spender) external returns (bool) {\\r\\n        return approve(spender, type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function launched() internal view returns (bool) {\\r\\n        return launchedAt != 0;\\r\\n    }\\r\\n\\r\\n    function launch() internal {\\r\\n        launchedAt = block.number;\\r\\n    }\\r\\n\\r\\n    function changeTxLimit(uint256 newLimit) external authorized {\\r\\n        _maxTxAmount = newLimit;\\r\\n    }\\r\\n\\r\\n    function changeWalletLimit(uint256 newLimit) external authorized {\\r\\n        _walletMax = newLimit;\\r\\n    }\\r\\n\\r\\n    function changeRewardToken(address token, bool chargeTxFee)\\r\\n        external\\r\\n        authorized\\r\\n    {\\r\\n        rewardToken = token;\\r\\n        rewardTokenHasTxFee = chargeTxFee;\\r\\n        dividendDistributor.setRewardToken(token, chargeTxFee);\\r\\n    }\\r\\n\\r\\n    function changeRestrictWhales(bool newValue) external authorized {\\r\\n        restrictWhales = newValue;\\r\\n    }\\r\\n\\r\\n    function changeIsFeeExempt(address holder, bool exempt)\\r\\n        external\\r\\n        authorized\\r\\n    {\\r\\n        isFeeExempt[holder] = exempt;\\r\\n    }\\r\\n\\r\\n    function changeIsTxLimitExempt(address holder, bool exempt)\\r\\n        external\\r\\n        authorized\\r\\n    {\\r\\n        isTxLimitExempt[holder] = exempt;\\r\\n    }\\r\\n\\r\\n    function changeIsDividendExempt(address holder, bool exempt)\\r\\n        external\\r\\n        authorized\\r\\n    {\\r\\n        require(holder != address(this) && holder != pair);\\r\\n        isDividendExempt[holder] = exempt;\\r\\n\\r\\n        if (exempt) {\\r\\n            dividendDistributor.setShare(holder, 0);\\r\\n        } else {\\r\\n            dividendDistributor.setShare(holder, _balances[holder]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function changeFees(\\r\\n        uint256 newLiqFee,\\r\\n        uint256 newRewardFee,\\r\\n        uint256 newExtraSellFee\\r\\n    ) external authorized {\\r\\n        liquidityFee = newLiqFee;\\r\\n        rewardsFee = newRewardFee;\\r\\n        extraFeeOnSell = newExtraSellFee;\\r\\n\\r\\n        totalFee = liquidityFee + rewardsFee;\\r\\n        totalFeeIfSelling = totalFee + extraFeeOnSell;\\r\\n    }\\r\\n\\r\\n    function changeSwapBackSettings(\\r\\n        bool enableSwapBack,\\r\\n        uint256 newSwapBackLimit\\r\\n    ) external authorized {\\r\\n        swapAndLiquifyEnabled = enableSwapBack;\\r\\n        swapThreshold = newSwapBackLimit;\\r\\n    }\\r\\n\\r\\n    function changeDistributionCriteria(\\r\\n        uint256 newinPeriod,\\r\\n        uint256 newMinDistribution\\r\\n    ) external authorized {\\r\\n        dividendDistributor.setDistributionCriteria(\\r\\n            newinPeriod,\\r\\n            newMinDistribution\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function changeDistributorSettings(uint256 gas) external authorized {\\r\\n        require(gas < 1500000);\\r\\n        distributorGas = gas;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _transferFrom(msg.sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\\r\\n            require(\\r\\n                _allowances[sender][msg.sender] >= amount,\\r\\n                \\\"Insufficient Allowance\\\"\\r\\n            );\\r\\n            _allowances[sender][msg.sender] =\\r\\n                _allowances[sender][msg.sender] -\\r\\n                amount;\\r\\n        }\\r\\n        return _transferFrom(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        if (inSwapAndLiquify) {\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n        }\\r\\n\\r\\n        require(_balances[sender] >= amount, \\\"Insufficient Balance\\\");\\r\\n        _balances[sender] = _balances[sender] - amount;\\r\\n\\r\\n        if (!isTxLimitExempt[recipient] && restrictWhales) {\\r\\n            require(\\r\\n                _balances[recipient] + amount <= _walletMax,\\r\\n                \\\"Exceeding wallet max\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (!authorizations[sender] && !authorizations[recipient]) {\\r\\n            require(tradingOpen, \\\"Trading not open yet\\\");\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            amount <= _maxTxAmount || isTxLimitExempt[sender],\\r\\n            \\\"TX Limit Exceeded\\\"\\r\\n        );\\r\\n\\r\\n        if (!launched() && recipient == pair) {\\r\\n            require(_balances[sender] > 0);\\r\\n            launch();\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            msg.sender != pair &&\\r\\n            !inSwapAndLiquify &&\\r\\n            swapAndLiquifyEnabled &&\\r\\n            _balances[address(this)] >= swapThreshold\\r\\n        ) {\\r\\n            swapBack();\\r\\n        }\\r\\n\\r\\n        //Exchange tokens\\r\\n        uint256 finalAmount = !isFeeExempt[sender] && !isFeeExempt[recipient]\\r\\n            ? takeFee(sender, recipient, amount)\\r\\n            : amount;\\r\\n        _balances[recipient] = _balances[recipient] + finalAmount;\\r\\n\\r\\n        // Dividend tracker\\r\\n        if (!isDividendExempt[sender]) {\\r\\n            try\\r\\n                dividendDistributor.setShare(sender, _balances[sender])\\r\\n            {} catch {}\\r\\n        }\\r\\n\\r\\n        if (!isDividendExempt[recipient]) {\\r\\n            try\\r\\n                dividendDistributor.setShare(recipient, _balances[recipient])\\r\\n            {} catch {}\\r\\n        }\\r\\n\\r\\n        try dividendDistributor.process(distributorGas) {} catch {}\\r\\n\\r\\n        emit Transfer(sender, recipient, finalAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _basicTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        require(_balances[sender] >= amount, \\\"Insufficient Balance\\\");\\r\\n\\r\\n        _balances[sender] = _balances[sender] - amount;\\r\\n        _balances[recipient] = _balances[recipient] + amount;\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function takeFee(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (uint256) {\\r\\n        uint256 feeApplicable = pair == recipient\\r\\n            ? totalFeeIfSelling\\r\\n            : totalFee;\\r\\n        uint256 feeAmount = (amount * feeApplicable) / 100;\\r\\n\\r\\n        _balances[address(this)] = _balances[address(this)] + feeAmount;\\r\\n        emit Transfer(sender, address(this), feeAmount);\\r\\n\\r\\n        return amount - feeAmount;\\r\\n    }\\r\\n\\r\\n    function tradingStatus(bool newStatus) external onlyOwner {\\r\\n        tradingOpen = newStatus;\\r\\n\\r\\n        emit TradingStatusChanged(newStatus);\\r\\n    }\\r\\n\\r\\n    function transferToWallet(address payable recipient, uint256 amount)\\r\\n        private\\r\\n    {\\r\\n        recipient.transfer(amount);\\r\\n    }\\r\\n\\r\\n    function swapBack() internal lockTheSwap {\\r\\n        uint256 tokensToLiquify = _balances[address(this)];\\r\\n        uint256 amountToSwap = tokensToLiquify;\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amountToSwap,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 amountBNB = address(this).balance;\\r\\n\\r\\n        uint256 totalBNBFee = totalFee;\\r\\n\\r\\n        uint256 amountBNBLiquidity = (amountBNB * liquidityFee) / totalBNBFee;\\r\\n        uint256 amountBNBReflection = (amountBNB * rewardsFee) / totalBNBFee;\\r\\n\\r\\n        try\\r\\n            dividendDistributor.deposit{value: amountBNBReflection}()\\r\\n        {} catch {}\\r\\n\\r\\n        transferToWallet(payable(teamWallet), amountBNBLiquidity);\\r\\n    }\\r\\n\\r\\n    function switchRouter(address _newRouterAddress) external onlyOwner {\\r\\n        router = IDEXRouter(_newRouterAddress);\\r\\n        pair = IDEXFactory(router.factory()).createPair(\\r\\n            router.WETH(),\\r\\n            address(this)\\r\\n        );\\r\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\r\\n\\r\\n        dividendDistributor.setRouter(_newRouterAddress);\\r\\n\\r\\n        isTxLimitExempt[pair] = true;\\r\\n\\r\\n        isDividendExempt[pair] = true;\\r\\n\\r\\n        emit RouterChanged(_newRouterAddress);\\r\\n    }\\r\\n\\r\\n    function switchDistributor(address _newDistributor) external onlyOwner {\\r\\n        DividendDistributor _dividendDistributor = DividendDistributor(\\r\\n            _newDistributor\\r\\n        );\\r\\n\\r\\n        address[] memory _shareHolders = dividendDistributor.getShareHolders();\\r\\n        uint256[] memory _shareholderIndexes = new uint256[](\\r\\n            _shareHolders.length\\r\\n        );\\r\\n        uint256[] memory _shareholderClaims = new uint256[](\\r\\n            _shareHolders.length\\r\\n        );\\r\\n        uint256[] memory _amounts = new uint256[](_shareHolders.length);\\r\\n        uint256[] memory _totalExcludes = new uint256[](_shareHolders.length);\\r\\n        uint256[] memory _totalRealises = new uint256[](_shareHolders.length);\\r\\n\\r\\n        for (uint256 i = 0; i < _shareHolders.length; i++) {\\r\\n            _shareholderIndexes[i] = dividendDistributor.shareholderIndexes(\\r\\n                _shareHolders[i]\\r\\n            );\\r\\n            _shareholderClaims[i] = dividendDistributor.shareholderClaims(\\r\\n                _shareHolders[i]\\r\\n            );\\r\\n\\r\\n            (\\r\\n                uint256 _amount,\\r\\n                uint256 _totalExcluded,\\r\\n                uint256 _totalRealised\\r\\n            ) = dividendDistributor.shares(_shareHolders[i]);\\r\\n            _amounts[i] = _amount;\\r\\n            _totalExcludes[i] = _totalExcluded;\\r\\n            _totalRealises[i] = _totalRealised;\\r\\n        }\\r\\n\\r\\n        (\\r\\n            uint256 _currentIndex,\\r\\n            uint256 _totalShares,\\r\\n            uint256 _totalDividends,\\r\\n            uint256 _totalDistributed,\\r\\n            uint256 _dividendsPerShare\\r\\n        ) = dividendDistributor.getDistributorState();\\r\\n\\r\\n        _dividendDistributor.migrateDistributorStates(\\r\\n            _shareHolders,\\r\\n            _shareholderIndexes,\\r\\n            _shareholderClaims,\\r\\n            _amounts,\\r\\n            _totalExcludes,\\r\\n            _totalRealises,\\r\\n            _currentIndex,\\r\\n            _totalShares,\\r\\n            _totalDividends,\\r\\n            _totalDistributed,\\r\\n            _dividendsPerShare\\r\\n        );\\r\\n\\r\\n        dividendDistributor = _dividendDistributor;\\r\\n\\r\\n        emit DistributorChanged(_newDistributor);\\r\\n    }\\r\\n\\r\\n    function switchTeamWallet(address _newTeamWallet) external onlyOwner {\\r\\n        teamWallet = _newTeamWallet;\\r\\n\\r\\n        emit TeamWalletChanged(_newTeamWallet);\\r\\n    }\\r\\n\\r\\n    function addToCirculatingSupplyExclusion(address _address)\\r\\n        external\\r\\n        authorized\\r\\n    {\\r\\n        bool exists = false;\\r\\n        for (uint256 i = 0; i < circulatingSupplyExclusions.length; i++) {\\r\\n            address exclusion = circulatingSupplyExclusions[i];\\r\\n            if (exclusion == _address) {\\r\\n                exists = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (!exists) {\\r\\n            circulatingSupplyExclusions.push(_address);\\r\\n            emit AddedToCirculatingSupplyExclusion(_address);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFromCirculatingSupplyExclusion(address _address)\\r\\n        external\\r\\n        authorized\\r\\n    {\\r\\n        bool found = false;\\r\\n        uint256 i = 0;\\r\\n        for (i; i < circulatingSupplyExclusions.length; i++) {\\r\\n            address exclusion = circulatingSupplyExclusions[i];\\r\\n            if (exclusion == _address) {\\r\\n                found = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (found) {\\r\\n            circulatingSupplyExclusions[i] = circulatingSupplyExclusions[\\r\\n                circulatingSupplyExclusions.length - 1\\r\\n            ];\\r\\n            circulatingSupplyExclusions.pop();\\r\\n            emit RemovedFromCirculatingSupplyExclusion(_address);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\ninterface IBEP20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function getOwner() external view returns (address);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address _owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDEXFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDEXRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint amountA,\\r\\n            uint amountB,\\r\\n            uint liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint amountToken,\\r\\n            uint amountETH,\\r\\n            uint liquidity\\r\\n        );\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/DividendDistributor.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"./interfaces/IDividendDistributor.sol\\\";\\r\\nimport \\\"./interfaces/IDEXRouter.sol\\\";\\r\\nimport \\\"./interfaces/IBEP20.sol\\\";\\r\\nimport \\\"./abstracts/TokenGuard.sol\\\";\\r\\nimport \\\"./structs/Share.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ncontract DividendDistributor is\\r\\n    IDividendDistributor,\\r\\n    ReentrancyGuard,\\r\\n    TokenGuard\\r\\n{\\r\\n    IDEXRouter router;\\r\\n    address routerAddress;\\r\\n\\r\\n    IBEP20 RewardToken;\\r\\n    address rewardTokenAddress;\\r\\n    bool rewardTokenHasTxFee = false;\\r\\n\\r\\n    address[] shareholders;\\r\\n    mapping(address => uint256) public shareholderIndexes;\\r\\n    mapping(address => uint256) public shareholderClaims;\\r\\n    mapping(address => Share) public shares;\\r\\n\\r\\n    uint256 public totalShares;\\r\\n    uint256 public totalDividends;\\r\\n    uint256 public totalDistributed;\\r\\n    uint256 public dividendsPerShare;\\r\\n    uint256 public dividendsPerShareAccuracyFactor = 10**36;\\r\\n\\r\\n    uint256 public minPeriod = 30 minutes;\\r\\n    uint256 public minDistribution = 1 * (10**18);\\r\\n\\r\\n    uint256 public currentIndex;\\r\\n\\r\\n    bool initialized;\\r\\n    modifier initialization() {\\r\\n        require(!initialized);\\r\\n        _;\\r\\n        initialized = true;\\r\\n    }\\r\\n\\r\\n    constructor(address _router, address _rewardToken)\\r\\n        ReentrancyGuard()\\r\\n        TokenGuard()\\r\\n    {\\r\\n        routerAddress = _router;\\r\\n        router = IDEXRouter(routerAddress);\\r\\n        rewardTokenAddress = _rewardToken;\\r\\n        RewardToken = IBEP20(rewardTokenAddress);\\r\\n    }\\r\\n\\r\\n    function setDistributionCriteria(\\r\\n        uint256 newMinPeriod,\\r\\n        uint256 newMinDistribution\\r\\n    ) external override onlyToken {\\r\\n        minPeriod = newMinPeriod;\\r\\n        minDistribution = newMinDistribution;\\r\\n\\r\\n        emit DistributionCriteriaChanged(newMinPeriod, newMinDistribution);\\r\\n    }\\r\\n\\r\\n    function setRewardToken(address token, bool chargeTxFee)\\r\\n        external\\r\\n        onlyToken\\r\\n    {\\r\\n        RewardToken = IBEP20(token); //BUSD\\r\\n        rewardTokenHasTxFee = chargeTxFee;\\r\\n\\r\\n        emit RewardTokenChanged(token, chargeTxFee);\\r\\n    }\\r\\n\\r\\n    function setShare(address shareholder, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyToken\\r\\n        nonReentrant\\r\\n    {\\r\\n        if (shares[shareholder].amount > 0) {\\r\\n            distributeDividend(shareholder);\\r\\n        }\\r\\n\\r\\n        if (amount > 0 && shares[shareholder].amount == 0) {\\r\\n            addShareholder(shareholder);\\r\\n        } else if (amount == 0 && shares[shareholder].amount > 0) {\\r\\n            removeShareholder(shareholder);\\r\\n        }\\r\\n\\r\\n        totalShares = totalShares - shares[shareholder].amount + amount;\\r\\n        shares[shareholder].amount = amount;\\r\\n        shares[shareholder].totalExcluded = getCumulativeDividends(\\r\\n            shares[shareholder].amount\\r\\n        );\\r\\n\\r\\n        emit HolderShareChanged(\\r\\n            shareholder,\\r\\n            amount,\\r\\n            shares[shareholder].totalExcluded\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setRouter(address _router) external override onlyToken {\\r\\n        router = IDEXRouter(_router);\\r\\n        emit RouterChanged(_router);\\r\\n    }\\r\\n\\r\\n    function deposit() external payable override onlyToken {\\r\\n        uint256 balanceBefore = RewardToken.balanceOf(address(this));\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = router.WETH();\\r\\n        path[1] = address(RewardToken);\\r\\n\\r\\n        if (rewardTokenHasTxFee) {\\r\\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\r\\n                value: msg.value\\r\\n            }(0, path, address(this), block.timestamp);\\r\\n        } else {\\r\\n            router.swapExactETHForTokens{value: msg.value}(\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 amount = RewardToken.balanceOf(address(this)) - balanceBefore;\\r\\n        totalDividends = totalDividends + amount;\\r\\n        dividendsPerShare =\\r\\n            dividendsPerShare +\\r\\n            ((dividendsPerShareAccuracyFactor * amount) / totalShares);\\r\\n\\r\\n        emit Deposited(\\r\\n            address(RewardToken),\\r\\n            amount,\\r\\n            totalDividends,\\r\\n            dividendsPerShare\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function process(uint256 gas) external override onlyToken nonReentrant {\\r\\n        uint256 shareholderCount = shareholders.length;\\r\\n\\r\\n        if (shareholderCount == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 iterations = 0;\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n\\r\\n        while (gasUsed < gas && iterations < shareholderCount) {\\r\\n            if (currentIndex >= shareholderCount) {\\r\\n                currentIndex = 0;\\r\\n            }\\r\\n\\r\\n            if (shouldDistribute(shareholders[currentIndex])) {\\r\\n                distributeDividend(shareholders[currentIndex]);\\r\\n            }\\r\\n\\r\\n            gasUsed = gasUsed + (gasLeft - gasleft());\\r\\n            gasLeft = gasleft();\\r\\n            currentIndex++;\\r\\n            iterations++;\\r\\n        }\\r\\n\\r\\n        emit Processed(gasUsed, gasLeft, currentIndex, iterations);\\r\\n    }\\r\\n\\r\\n    function shouldDistribute(address shareholder)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return\\r\\n            shareholderClaims[shareholder] + minPeriod < block.timestamp &&\\r\\n            getUnpaidEarnings(shareholder) > minDistribution;\\r\\n    }\\r\\n\\r\\n    function distributeDividend(address shareholder) internal {\\r\\n        if (shares[shareholder].amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 amount = getUnpaidEarnings(shareholder);\\r\\n        if (amount > 0) {\\r\\n            totalDistributed = totalDistributed + amount;\\r\\n            RewardToken.transfer(shareholder, amount);\\r\\n            shareholderClaims[shareholder] = block.timestamp;\\r\\n            shares[shareholder].totalRealised =\\r\\n                shares[shareholder].totalRealised +\\r\\n                amount;\\r\\n            shares[shareholder].totalExcluded = getCumulativeDividends(\\r\\n                shares[shareholder].amount\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimDividend() external nonReentrant {\\r\\n        require(shouldDistribute(msg.sender), \\\"Too soon. Need to wait!\\\");\\r\\n        distributeDividend(msg.sender);\\r\\n    }\\r\\n\\r\\n    function getUnpaidEarnings(address shareholder)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (shares[shareholder].amount == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 shareholderTotalDividends = getCumulativeDividends(\\r\\n            shares[shareholder].amount\\r\\n        );\\r\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\r\\n\\r\\n        if (shareholderTotalDividends <= shareholderTotalExcluded) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return shareholderTotalDividends - shareholderTotalExcluded;\\r\\n    }\\r\\n\\r\\n    function getCumulativeDividends(uint256 share)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (share * dividendsPerShare) / dividendsPerShareAccuracyFactor;\\r\\n    }\\r\\n\\r\\n    function addShareholder(address shareholder) internal {\\r\\n        shareholderIndexes[shareholder] = shareholders.length;\\r\\n        shareholders.push(shareholder);\\r\\n    }\\r\\n\\r\\n    function removeShareholder(address shareholder) internal {\\r\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\\r\\n            shareholders.length - 1\\r\\n        ];\\r\\n        shareholderIndexes[\\r\\n            shareholders[shareholders.length - 1]\\r\\n        ] = shareholderIndexes[shareholder];\\r\\n        shareholders.pop();\\r\\n    }\\r\\n\\r\\n    function getShareHolders() public view returns (address[] memory) {\\r\\n        address[] memory _shareHolders = new address[](shareholders.length);\\r\\n        for (uint256 i = 0; i < shareholders.length; i++) {\\r\\n            _shareHolders[i] = shareholders[i];\\r\\n        }\\r\\n        return _shareHolders;\\r\\n    }\\r\\n\\r\\n    function getDistributorState()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        return (\\r\\n            currentIndex,\\r\\n            totalShares,\\r\\n            totalDividends,\\r\\n            totalDistributed,\\r\\n            dividendsPerShare\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function migrateDistributorStates(\\r\\n        address[] memory _shareHolders,\\r\\n        uint256[] memory _shareholderIndexes,\\r\\n        uint256[] memory _shareholderClaims,\\r\\n        uint256[] memory _amounts,\\r\\n        uint256[] memory _totalExcludes,\\r\\n        uint256[] memory _totalRealises,\\r\\n        uint256 _currentIndex,\\r\\n        uint256 _totalShares,\\r\\n        uint256 _totalDividends,\\r\\n        uint256 _totalDistributed,\\r\\n        uint256 _dividendsPerShare\\r\\n    ) external override {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Airdropper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"./interfaces/IBEP20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice This contract aids migration for a BEP20 token.\\r\\n * @dev This contract assumes the total supply of the new token is the same as the total supply of\\r\\n * old token, and will migrate tokens with 1:1 ratio.\\r\\n */\\r\\ncontract Airdropper {\\r\\n    /* Constant variables */\\r\\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    /* Address of the old token */\\r\\n    address public oldTokenAddress;\\r\\n\\r\\n    /* Address of the new token */\\r\\n    address public newTokenAddress;\\r\\n\\r\\n    /* To keep track of migrated tokens for burned address */\\r\\n    uint256 public burned;\\r\\n\\r\\n    /* Token that will be received in exchange of new token */\\r\\n    IBEP20 internal OldToken;\\r\\n\\r\\n    /* Token that will be airdropped */\\r\\n    IBEP20 internal NewToken;\\r\\n\\r\\n    constructor(address _oldTokenAddress) {\\r\\n        /* Set old BEP20 token */\\r\\n        oldTokenAddress = _oldTokenAddress;\\r\\n        OldToken = IBEP20(_oldTokenAddress);\\r\\n\\r\\n        /* Set new BEP20 token */\\r\\n        newTokenAddress = msg.sender;\\r\\n        NewToken = IBEP20(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Allows users to migrate all of their old tokens at once\\r\\n     */\\r\\n    function migrate() external {\\r\\n        uint256 _balance = OldToken.balanceOf(msg.sender);\\r\\n        require(_balance > 0, \\\"You have nothing to migrate\\\");\\r\\n\\r\\n        OldToken.transferFrom(msg.sender, address(this), _balance);\\r\\n        NewToken.transferFrom(address(this), msg.sender, _balance);\\r\\n\\r\\n        emit Migrated(msg.sender, _balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Allows users to migrate part of their old tokens\\r\\n     * @param _amount the amount of tokens to migrate\\r\\n     */\\r\\n    function migrate(uint256 _amount) external {\\r\\n        uint256 _balance = OldToken.balanceOf(msg.sender);\\r\\n        require(_amount > 0, \\\"Amount cannot be zero\\\");\\r\\n        require(_balance > 0, \\\"You have nothing to migrate\\\");\\r\\n        require(_balance >= _amount, \\\"Insufficient balance for migration\\\");\\r\\n\\r\\n        OldToken.transferFrom(msg.sender, address(this), _amount);\\r\\n        NewToken.transferFrom(address(this), msg.sender, _amount);\\r\\n\\r\\n        emit Migrated(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Match the amount of new tokens in the burned address with the old tokens\\r\\n     * that were sent to the burned address\\r\\n     */\\r\\n    function burn() external {\\r\\n        uint256 _balance = OldToken.balanceOf(DEAD);\\r\\n        require(_balance > burned, \\\"Nothing to burn\\\");\\r\\n\\r\\n        uint256 _toBurn = _balance - burned;\\r\\n        burned = _balance;\\r\\n        NewToken.transferFrom(address(this), DEAD, _toBurn);\\r\\n\\r\\n        emit Burned(msg.sender, _toBurn);\\r\\n    }\\r\\n\\r\\n    event Migrated(address _user, uint256 _amount);\\r\\n    event Burned(address _caller, uint256 _burned);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/abstracts/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nabstract contract Auth {\\r\\n    address internal owner;\\r\\n    mapping(address => bool) internal authorizations;\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n        authorizations[_owner] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be contract owner\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be authorized\\r\\n     */\\r\\n    modifier authorized() {\\r\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Authorize address. Owner only\\r\\n     */\\r\\n    function authorize(address adr) public onlyOwner {\\r\\n        authorizations[adr] = true;\\r\\n\\r\\n        emit Authorized(adr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Remove address' authorization. Owner only\\r\\n     */\\r\\n    function unauthorize(address adr) public onlyOwner {\\r\\n        authorizations[adr] = false;\\r\\n\\r\\n        emit Unauthorized(adr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Check if address is owner\\r\\n     */\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return account == owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Return address' authorization status\\r\\n     */\\r\\n    function isAuthorized(address adr) public view returns (bool) {\\r\\n        return authorizations[adr];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\r\\n     */\\r\\n    function transferOwnership(address payable adr) public onlyOwner {\\r\\n        owner = adr;\\r\\n        authorizations[adr] = true;\\r\\n        emit OwnershipTransferred(adr);\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address owner);\\r\\n    event Authorized(address adr);\\r\\n    event Unauthorized(address adr);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDividendDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\ninterface IDividendDistributor {\\r\\n    function setDistributionCriteria(\\r\\n        uint256 _minPeriod,\\r\\n        uint256 _minDistribution\\r\\n    ) external;\\r\\n\\r\\n    function setShare(address shareholder, uint256 amount) external;\\r\\n\\r\\n    function setRouter(address _router) external;\\r\\n\\r\\n    function deposit() external payable;\\r\\n\\r\\n    function process(uint256 gas) external;\\r\\n\\r\\n    function migrateDistributorStates(\\r\\n        address[] memory _shareHolders,\\r\\n        uint256[] memory _shareholderIndexes,\\r\\n        uint256[] memory _shareholderClaims,\\r\\n        uint256[] memory _amounts,\\r\\n        uint256[] memory _totalExcludes,\\r\\n        uint256[] memory _totalRealises,\\r\\n        uint256 _currentIndex,\\r\\n        uint256 _totalShares,\\r\\n        uint256 _totalDividends,\\r\\n        uint256 _totalDistributed,\\r\\n        uint256 _dividendsPerShare\\r\\n    ) external;\\r\\n\\r\\n    event DistributionCriteriaChanged(\\r\\n        uint256 newMinPeriod,\\r\\n        uint256 newMinDistribution\\r\\n    );\\r\\n\\r\\n    event HolderShareChanged(\\r\\n        address indexed shareholder,\\r\\n        uint256 amount,\\r\\n        uint256 totalExcluded\\r\\n    );\\r\\n\\r\\n    event RewardTokenChanged(address indexed token, bool chargeTxFee);\\r\\n\\r\\n    event Deposited(\\r\\n        address rewardToken,\\r\\n        uint256 amount,\\r\\n        uint256 totalDividends,\\r\\n        uint256 dividendsPerShare\\r\\n    );\\r\\n\\r\\n    event Processed(\\r\\n        uint256 gasUsed,\\r\\n        uint256 gasLeft,\\r\\n        uint256 currentIndex,\\r\\n        uint256 iterations\\r\\n    );\\r\\n\\r\\n    event RouterChanged(address _router);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/abstracts/TokenGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nabstract contract TokenGuard {\\r\\n    address _token;\\r\\n\\r\\n    constructor() {\\r\\n        _token = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getTokenGuard() external view returns (address) {\\r\\n        return _token;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/structs/Share.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nstruct Share {\\r\\n    uint256 amount;\\r\\n    uint256 totalExcluded;\\r\\n    uint256 totalRealised;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddedToCirculatingSupplyExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"}],\"name\":\"DistributorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemovedFromCirculatingSupplyExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouterAddress\",\"type\":\"address\"}],\"name\":\"RouterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTeamWallet\",\"type\":\"address\"}],\"name\":\"TeamWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"TradingStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_walletMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToCirculatingSupplyExclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropper\",\"outputs\":[{\"internalType\":\"contract Airdropper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newinPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinDistribution\",\"type\":\"uint256\"}],\"name\":\"changeDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"changeDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiqFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newRewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newExtraSellFee\",\"type\":\"uint256\"}],\"name\":\"changeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"changeIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"changeIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"changeIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"changeRestrictWhales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"chargeTxFee\",\"type\":\"bool\"}],\"name\":\"changeRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enableSwapBack\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"newSwapBackLimit\",\"type\":\"uint256\"}],\"name\":\"changeSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"changeTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"changeWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"circulatingSupplyExclusions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendDistributor\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDividendExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldEctoContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeFromCirculatingSupplyExclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restrictWhales\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDistributor\",\"type\":\"address\"}],\"name\":\"switchDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRouterAddress\",\"type\":\"address\"}],\"name\":\"switchRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTeamWallet\",\"type\":\"address\"}],\"name\":\"switchTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeeIfSelling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"tradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Ecto", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ea340b35207b2c795c5ccf9a1b78befc838516e800000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000896986db81727b2c7253ce533df44fc6a42d7a78", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}