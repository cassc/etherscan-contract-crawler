{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.7;\\n\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\t\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\n\\t\\treturn msg.data;\\n\\t}\\n} \\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications. \\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n\\tmapping(address =\\u003e uint256) private _balances;\\n\\t\\n\\tmapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\tmapping(address =\\u003e bool) _feesExempted;\\n\\taddress[] private _feesExemptedAccounts;\\n\\t\\n\\tuint256 private _maxSupply;\\n\\tuint256 private _totalSupply;\\n\\tuint256 private _totalBurned = 0;\\n\\tuint256 private _totalFees = 0;\\n\\t\\n\\tstring private _name;\\n\\tstring private _symbol;\\n\\t\\n\\t\\n\\taddress private _deployer           = 0x68FcDA406EbAC47150A4EA0D75ecb39FA892712D;\\n\\taddress private _feesAddress        = 0x17147745e20C49C4C27fA1472A33b1E56dc2cc44;\\n\\taddress private _burnAddress        = 0x630eFD9DF80F4d981d08D85c70CCb9BD8a11AD9D;\\n\\taddress private _liquidPoolAddress  = 0x604485b9333e90b83700939E038fF655E0E569C5;\\n\\taddress private _prizesPoolAddress  = 0xD8C69Df5514ed472B323709c269c1E2Bec94C796;\\n\\taddress private _holdersPoolAddress = 0xe07af194EDD94A5FAa3FE186159f4bE2826590b3;\\n\\t\\n\\t/**\\n\\t * @dev Sets the values for {name} and {symbol}.\\n\\t *\\n\\t * The default value of {decimals} is 18. To select a different value for\\n\\t * {decimals} you should overload it.\\n\\t *\\n\\t * All two of these values are immutable: they can only be set once during\\n\\t * construction.\\n\\t */\\n\\tconstructor(string memory name_, string memory symbol_) {\\n\\t\\t_name = name_;\\n\\t\\t_symbol = symbol_;\\n\\t\\t\\n\\t\\t_feesExempted[_deployer] = true;\\n\\t\\t_feesExempted[_feesAddress] = true;\\n\\t\\t_feesExempted[_burnAddress] = true;\\n\\t\\t_feesExempted[_liquidPoolAddress] = true;\\n\\t\\t_feesExempted[_prizesPoolAddress] = true;\\n\\t\\t_feesExempted[_holdersPoolAddress] = true;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Returns the name of the token.\\n\\t */\\n\\tfunction name() public view virtual override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Returns the symbol of the token, usually a shorter version of the\\n\\t * name.\\n\\t */\\n\\tfunction symbol() public view virtual override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Returns the number of decimals used to get its user representation.\\n\\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n\\t * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n\\t *\\n\\t * Tokens usually opt for a value of 18, imitating the relationship between\\n\\t * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n\\t * overridden;\\n\\t *\\n\\t * NOTE: This information is only used for _display_ purposes: it in\\n\\t * no way affects any of the arithmetic of the contract, including\\n\\t * {IERC20-balanceOf} and {IERC20-transfer}.\\n\\t */\\n\\tfunction decimals() public view virtual override returns (uint8) {\\n\\t\\treturn 8;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev See {IERC20-maxSupply}.\\n\\t */\\n\\tfunction maxSupply() public view virtual override returns (uint256) {\\n\\t\\treturn _maxSupply;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev See {IERC20-totalSupply}.\\n\\t */\\n\\tfunction totalSupply() public view virtual override returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\t/**\\n\\t * @dev See {IERC20-totalSupply}.\\n\\t */\\n\\tfunction totalBurned() public view virtual override returns (uint256) {\\n\\t\\treturn _totalBurned;\\n\\t}\\n\\t/**\\n\\t * @dev See {IERC20-totalSupply}.\\n\\t */\\n\\tfunction totalFees() public view virtual override returns (uint256) {\\n\\t\\treturn _totalFees;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev See {IERC20-balanceOf}.\\n\\t */\\n\\tfunction balanceOf(address account) public view virtual override returns (uint256) {\\n\\t\\treturn _balances[account];\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev See {IERC20-transfer}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `recipient` cannot be the zero address.\\n\\t * - the caller must have a balance of at least `amount`.\\n\\t */\\n\\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n\\t\\tuint256 fees = _calculateFees(_msgSender(), amount);\\n\\t\\t_transfer(_msgSender(), recipient, amount);\\n\\t\\t_deductFees(_msgSender(), fees);\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev See {IERC20-allowance}.\\n\\t */\\n\\tfunction allowance(address owner, address spender) public view virtual override returns (uint256) {\\n\\t\\treturn _allowances[owner][spender];\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev See {IERC20-approve}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `spender` cannot be the zero address.\\n\\t */\\n\\tfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Exempt address {account} from paying fees.\\n\\t * \\n\\t * NOTE:\\n\\t * It is required to exempt fees from all addresses owned \\n\\t * by token exchanges (i.e. UniSwap, PancakeSwap etc),\\n\\t * otherwise transactions will get reverted!\\n\\t * \\n\\t * It is due to the way our Fee system work.\\n\\t * Fees are being charged from {sender} at rate of 13.68%\\n\\t * so owner must have {amount} + {fees} at the time of request.\\n\\t * \\n\\t * Example:\\n\\t * If you send 1,000,000 tokens, your account must have\\n\\t * at least 1,136,800 tokens at the time of request.\\n\\t * \\n\\t * Exchanges may have issues with this fee system,\\n\\t * that\\u0027s why they must be exempted from paying fees.\\n\\t * \\n\\t * @dev\\n\\t * Before you create own liquidity pool, please contact us\\n\\t * \\n\\t * \\n\\t * \\n\\t */\\n\\tfunction exemptFees(address account) public virtual returns (bool) {\\n\\t\\trequire(_msgSender()  == _deployer, \\\"ERC20: fees exemption must be changed by deployer\\\");\\n\\t\\t_feesExemptedAccounts.push(account);\\n\\t\\t_feesExempted[account] = true;\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Returns an array of all accounts exempted from paying fees.\\n\\t * \\n\\t */\\n\\tfunction feesExemptedAccounts() public view returns (address[] memory) {\\n\\t\\treturn _feesExemptedAccounts;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev See {IERC20-transferFrom}.\\n\\t *\\n\\t * Emits an {Approval} event indicating the updated allowance. This is not\\n\\t * required by the EIP. See the note at the beginning of {ERC20}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `sender` and `recipient` cannot be the zero address.\\n\\t * - `sender` must have a balance of at least `amount`.\\n\\t * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\n\\t * `amount`.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) public virtual override returns (bool) {\\n\\t\\tuint256 fees = _calculateFees(sender, amount);\\n\\t\\t_transfer(sender, recipient, amount);\\n\\t\\t\\n\\t\\tuint256 currentAllowance = _allowances[sender][_msgSender()];\\n\\t\\trequire(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_approve(sender, _msgSender(), currentAllowance - amount);\\n\\t\\t}\\n\\t\\t\\n\\t\\t_deductFees(sender, fees);\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Emits {GroupTransfer} event indicating successful transfer.\\n\\t * \\n\\t * Transfer to multiple addresses {recipents} in one request\\n\\t * from the requester\\u0027s account for the seperated amounts \\n\\t * for each address specified in array {amounts}\\n\\t * \\n\\t * NOTE:\\n\\t * Make sure you have enough tokens to cover transfer amount + fees (13.68%).\\n\\t * Otherwise your transaction will get rejected.\\n\\t * \\n\\t * Requirements:\\n\\t * - `recipents` must not be empty \\n\\t * - `amounts` must have same length as `recipents`\\n\\t * \\n\\t */\\n\\tfunction groupTransfer(\\n\\t\\taddress[] memory recipents,\\n\\t\\tuint256[] memory amounts\\n\\t) public virtual returns (bool) {\\n\\t\\tuint256 total = 0;\\n\\t\\tuint totalRecipents = recipents.length;\\n\\t\\trequire (totalRecipents \\u003e 0 \\u0026\\u0026 totalRecipents == amounts.length, \\\"ERC20: groupTranfer must have equal recipents and amounts\\\");\\n\\t\\tfor(uint i = 0; i \\u003c totalRecipents; i++) {\\n\\t\\t\\tuint256 amount = amounts[i];\\n\\t\\t\\t_transfer(_msgSender(), recipents[i], amounts[i]);\\n\\t\\t\\ttotal += amount;\\n\\t\\t}\\n\\t\\t\\n\\t\\temit GroupTransfer(_msgSender(), recipents, amounts, total);\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t\\n\\t/**\\n\\t * Transfer from the requester\\u0027s account to multiple addresses \\n\\t * to specified {recipents} in one request for a fixed {amount}\\n\\t * \\n\\t * Requirements:\\n\\t * - `recipents` must not be empty \\n\\t * \\n\\t */\\n\\tfunction airDrop (\\n\\t\\taddress[] memory recipents,\\n\\t\\tuint256 amount\\n\\t) public virtual returns (bool) {\\n\\t\\t\\n\\t\\tuint256 total = 0;\\n\\t\\tuint256 totalRecipents = recipents.length;\\n\\t\\trequire (totalRecipents \\u003e 0, \\\"ERC20: airDrop must at least 1 recipent\\\");\\n\\t\\tfor(uint256 i = 0; i \\u003c totalRecipents; i++) {\\n\\t\\t\\t_transfer(_msgSender(), recipents[i], amount);\\n\\t\\t\\ttotal += amount;\\n\\t\\t}\\n\\t\\t\\n\\t\\temit AirDrop(_msgSender(), recipents, amount, total);\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t\\n\\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n\\t *\\n\\t * This is an alternative to {approve} that can be used as a mitigation for\\n\\t * problems described in {IERC20-approve}.\\n\\t *\\n\\t * Emits an {Approval} event indicating the updated allowance.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `spender` cannot be the zero address.\\n\\t * - `spender` must have allowance for the caller of at least\\n\\t * `subtractedValue`.\\n\\t */\\n\\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n\\t\\tuint256 currentAllowance = _allowances[_msgSender()][spender];\\n\\t\\trequire(currentAllowance \\u003e= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n\\t *\\n\\t * This internal function is equivalent to {transfer}, and can be used to\\n\\t * e.g. implement automatic token fees, slashing mechanisms, etc.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `sender` cannot be the zero address.\\n\\t * - `recipient` cannot be the zero address.\\n\\t * - `sender` must have a balance of at least `amount`.\\n\\t */\\n\\t\\n\\tfunction _transfer(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\trequire(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n\\t\\trequire(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\t\\t\\n\\t\\t_beforeTokenTransfer(sender, recipient, amount);\\n\\t\\t\\n\\t\\tuint256 senderBalance = _balances[sender];\\n\\t\\trequire(senderBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_balances[sender] = senderBalance - amount;\\n\\t\\t}\\n\\t\\t_balances[recipient] += amount;\\n\\t\\t\\n\\t\\temit Transfer(sender, recipient, amount);\\n\\t\\t\\n\\t\\t_afterTokenTransfer(sender, recipient, amount);\\n\\t}\\n\\t\\n\\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n\\t * the total supply.\\n\\t *\\n\\t * Emits a {Transfer} event with `from` set to the zero address.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `account` cannot be the zero address.\\n\\t */\\n\\tfunction _mint(address account, uint256 amount) internal virtual {\\n\\t\\trequire(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\t\\t\\n\\t\\t_beforeTokenTransfer(address(0), account, amount);\\n\\t\\t\\n\\t\\t_totalSupply += amount;\\n\\t\\t_maxSupply = _totalSupply;\\n\\t\\t_balances[account] += amount;\\n\\t\\temit Transfer(address(0), account, amount);\\n\\t\\t\\n\\t\\t_afterTokenTransfer(address(0), account, amount);\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Destroys `amount` tokens from `account`, reducing the\\n\\t * total supply.\\n\\t *\\n\\t * Emits a {Transfer} event with `to` set to the zero address.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `account` cannot be the zero address.\\n\\t * - `account` must have at least `amount` tokens.\\n\\t */\\n\\tfunction _burn(address account, uint256 amount) internal virtual {\\n\\t\\trequire(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\t\\t\\n\\t\\t_beforeTokenTransfer(account, address(0), amount);\\n\\t\\t\\n\\t\\tuint256 accountBalance = _balances[account];\\n\\t\\trequire(accountBalance \\u003e= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_balances[account] = accountBalance - amount;\\n\\t\\t\\t//_transfer(account, address(0), amount);\\n\\t\\t}\\n\\t\\t_totalSupply -= amount;\\n\\t\\t_totalBurned += amount;\\n\\t\\t\\n\\t\\t_afterTokenTransfer(account, address(0), amount);\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n\\t *\\n\\t * This internal function is equivalent to `approve`, and can be used to\\n\\t * e.g. set automatic allowances for certain subsystems, etc.\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `owner` cannot be the zero address.\\n\\t * - `spender` cannot be the zero address.\\n\\t */\\n\\tfunction _approve(\\n\\t\\taddress owner,\\n\\t\\taddress spender,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\trequire(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n\\t\\trequire(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\t\\t\\n\\t\\t_allowances[owner][spender] = amount;\\n\\t\\temit Approval(owner, spender, amount);\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Hook that is called before any transfer of tokens. This includes\\n\\t * minting and burning.\\n\\t *\\n\\t * Calling conditions:\\n\\t *\\n\\t * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\n\\t * will be transferred to `to`.\\n\\t * - when `from` is zero, `amount` tokens will be minted for `to`.\\n\\t * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\n\\t * - `from` and `to` are never both zero.\\n\\t *\\n\\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n\\t */\\n\\tfunction _beforeTokenTransfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\t\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Hook that is called after any transfer of tokens. This includes\\n\\t * minting and burning.\\n\\t *\\n\\t * Calling conditions:\\n\\t *\\n\\t * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\n\\t * has been transferred to `to`.\\n\\t * - when `from` is zero, `amount` tokens have been minted for `to`.\\n\\t * - when `to` is zero, `amount` of ``from``\\u0027s tokens have been burned.\\n\\t * - `from` and `to` are never both zero.\\n\\t *\\n\\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n\\t */\\n\\tfunction _afterTokenTransfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\t\\n\\t}\\n\\t\\n\\t/**\\n\\t * Calculates fees to be charged AFTER {_transfer} is successful.\\n\\t * \\n\\t * The fees are estimated to be 13.68% for every transaction.\\n\\t * Account won\\u0027t be charged fees if transaction sender doesn\\u0027t \\n\\t * have enough to cover them.\\n\\t * \\n\\t * It protects network from sending too many transactions\\n\\t * \\n\\t */\\n\\tfunction _calculateFees(address owner, uint256 amount) internal virtual returns (uint256) {\\n\\t\\tuint256 ownerBalanceAfter = _balances[owner] - amount;\\n\\t\\tif(_feesExempted[owner] || ownerBalanceAfter \\u003c 10000000000) {\\n\\t\\t\\treturn uint256(0);\\n\\t\\t}\\n\\t\\tuint256 feesToCollect = (amount/10000) * 1368;\\n\\t\\tif(ownerBalanceAfter \\u003c feesToCollect) {\\n\\t\\t\\treturn ownerBalanceAfter;\\n\\t\\t} \\n\\t\\treturn feesToCollect;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Calculates fees to be charged AFTER {_transfer} is successful.\\n\\t * \\n\\t * \\n\\t * \\n\\t */\\n\\tfunction _deductFees(address owner, uint256 amount) internal virtual  {\\n\\t\\t//increaseAllowance(owner, amount);\\n\\t\\tif(amount \\u003e 1000000) {\\n\\t\\t\\t_transfer(owner, _feesAddress, amount);\\n\\t\\t\\t_totalFees += amount;\\n\\t\\t\\t_redistributeFees();\\n\\t\\t}\\n\\t}\\n\\t\\n\\t/**\\n\\t * Calculates fees to be charged AFTER {_transfer} is successful.\\n\\t * \\n\\t * \\n\\t * \\n\\t */\\n\\tfunction _redistributeFees() internal virtual {\\n\\t\\tuint256 feesBalance = _balances[_feesAddress];\\n\\t\\tif(feesBalance \\u003e= 1000000000000000) {  // 10,000,000\\n\\t\\t\\t_transfer(_feesAddress, _burnAddress,        (feesBalance/10000) * 456);\\n\\t\\t\\t_transfer(_feesAddress, _liquidPoolAddress,  (feesBalance/10000) * 456);\\n\\t\\t\\t_transfer(_feesAddress, _holdersPoolAddress, (feesBalance/10000) * 456);\\n\\t\\t\\t_transfer(_feesAddress, _prizesPoolAddress,  (feesBalance/10000) * 456);\\n\\t\\t\\t\\n\\t\\t\\t//emit FeesRedistributed(_feesAddress, feesBalance/3, feesBalance/3, feesBalance/6, feesBalance/6);\\n\\t\\t}\\n\\t}\\n} \\n\"},\"ERC20Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n\\t/**\\n\\t * @dev Destroys `amount` tokens from the caller.\\n\\t *\\n\\t * See {ERC20-_burn}.\\n\\t */\\n\\tfunction burn(uint256 amount) public virtual {\\n\\t\\t_burn(_msgSender(), amount);\\n\\t}\\n\\t\\n\\t/**\\n\\t * @dev Destroys `amount` tokens from `account`, deducting from the caller\\u0027s\\n\\t * allowance.\\n\\t *\\n\\t * See {ERC20-_burn} and {ERC20-allowance}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must have allowance for ``accounts``\\u0027s tokens of at least\\n\\t * `amount`.\\n\\t */\\n\\tfunction burnFrom(address account, uint256 amount) public virtual {\\n\\t\\tuint256 currentAllowance = allowance(account, _msgSender());\\n\\t\\trequire(currentAllowance \\u003e= amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\t\\tunchecked {\\n\\t\\t\\t_approve(account, _msgSender(), currentAllowance - amount);\\n\\t\\t}\\n\\t\\t_burn(account, amount);\\n\\t}\\n} \\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n\\t\\n\\t/**\\n\\t * @dev Returns the maximum amount of tokens ever existed.\\n\\t */\\n\\tfunction maxSupply() external view returns (uint256);\\n\\t\\n\\t/**\\n\\t * @dev Returns the amount of tokens in existence.\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\t\\n\\t/**\\n\\t * @dev Returns the total amount of tokens burned.\\n\\t */\\n\\tfunction totalBurned() external view returns (uint256);\\n\\t\\n\\t/**\\n\\t * @dev Returns the total amount of fees collected.\\n\\t */\\n\\tfunction totalFees() external view returns (uint256);\\n\\t\\n\\t/**\\n\\t * @dev Returns the amount of tokens owned by `account`.\\n\\t */\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\t\\n\\t/**\\n\\t * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\t\\n\\t/**\\n\\t * @dev Returns the remaining number of tokens that `spender` will be\\n\\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n\\t * zero by default.\\n\\t *\\n\\t * This value changes when {approve} or {transferFrom} are called.\\n\\t */\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\n\\t\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n\\t * that someone may use both the old and the new allowance by unfortunate\\n\\t * transaction ordering. One possible solution to mitigate this race\\n\\t * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n\\t * desired value afterwards:\\n\\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\t\\n\\t/**\\n\\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n\\t * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n\\t * allowance.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\t\\n\\t/**\\n\\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n\\t * another (`to`).\\n\\t *\\n\\t * Note that `value` may be zero.\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\t\\n\\t/**\\n\\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n\\t * a call to {approve}. `value` is the new allowance.\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n\\t\\n\\tevent Burn(address indexed account, uint256 amount);\\n\\t\\n\\tevent FeesCollected(address indexed account, uint256 amount);\\n\\t\\n\\tevent FeesRedistributed(address indexed account, uint256 burn, uint256 liquid, uint256 hold, uint256 prize);\\n\\t\\n\\tevent GroupTransfer(address indexed from, address[] indexed recipients, uint256[] valueEach, uint256 totalValue);\\n\\t\\n\\tevent AirDrop(address indexed from, address[] indexed recipients, uint256 valueEach, uint256 valueTotal);\\n}\\n\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n\\t/**\\n\\t * @dev Returns the name of the token.\\n\\t */\\n\\tfunction name() external view returns (string memory);\\n\\t\\n\\t/**\\n\\t * @dev Returns the symbol of the token.\\n\\t */\\n\\tfunction symbol() external view returns (string memory);\\n\\t\\n\\t/**\\n\\t * @dev Returns the decimals places of the token.\\n\\t */\\n\\tfunction decimals() external view returns (uint8);\\n} \\n\"},\"SGCT_Token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\n\\ncontract SGCT_Token is ERC20, ERC20Burnable {\\n\\taddress private _liquidPoolAddress  = 0x604485b9333e90b83700939E038fF655E0E569C5;\\n\\taddress private _prizesPoolAddress  = 0xD8C69Df5514ed472B323709c269c1E2Bec94C796;\\n\\tconstructor(\\n\\t\\tstring memory name_,\\n\\t\\tstring memory symbol_,\\n\\t\\tuint256 totalSupply_\\n\\t) ERC20(name_, symbol_) {\\n\\t\\tuint256 totalSupply = (10**decimals())*totalSupply_;\\n\\t\\t_mint(_liquidPoolAddress, (totalSupply/100) * 90); // 80% Initial liquidity \\n\\t\\t_mint(_prizesPoolAddress, (totalSupply/100) * 10); // 20% Airdrops, Rewards, Community\\n\\t}\\n}\\n\\n\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueEach\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueTotal\",\"type\":\"uint256\"}],\"name\":\"AirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"FeesRedistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"valueEach\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalValue\",\"type\":\"uint256\"}],\"name\":\"GroupTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipents\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"airDrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"exemptFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesExemptedAccounts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipents\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"groupTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SGCT_Token", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000a9df8c8000000000000000000000000000000000000000000000000000000000000000019537175696447616d6520436f6d6d756e69747920546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000045347435400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://59af2ce1f7105dc5e21dbb08b0623cd4ff26075532e874f4ade4c1a9fe9782da"}