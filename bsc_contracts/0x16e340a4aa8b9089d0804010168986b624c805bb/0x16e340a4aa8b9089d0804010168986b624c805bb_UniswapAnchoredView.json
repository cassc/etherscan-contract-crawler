{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Ola/Peripheral/PriceOracle/open-oracle/Uniswap/UniswapAnchoredView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../OpenOraclePriceData.sol\\\";\\nimport \\\"./UniswapConfig.sol\\\";\\nimport \\\"./UniswapLib.sol\\\";\\n\\ninterface RegistryForUAV {\\n    function getPriceForAsset(address cToken) external view returns (uint256);\\n}\\n\\nstruct Observation {\\n    uint timestamp;\\n    uint acc;\\n}\\n\\ncontract UniswapAnchoredView is UniswapConfig {\\n    using FixedPoint for *;\\n\\n    string[] public autoPokingSymbols;\\n\\n    /// @notice The Open Oracle Price Data contract\\n    OpenOraclePriceData public immutable priceData;\\n\\n    /// @notice The number of wei in 1 ETH\\n    uint public constant ethBaseUnit = 1e18;\\n\\n    /// @notice A common scaling factor to maintain precision\\n    uint public constant expScale = 1e18;\\n\\n    /// @notice The Open Oracle Reporter\\n    address public immutable reporter;\\n\\n    /// @notice The highest ratio of the new price to the anchor price that will still trigger the price to be updated\\n    uint public immutable upperBoundAnchorRatio;\\n\\n    /// @notice The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\\n    uint public immutable lowerBoundAnchorRatio;\\n\\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\\n    uint public immutable anchorPeriod;\\n\\n    /// @notice Official prices by symbol hash\\n    mapping(bytes32 => uint) public prices;\\n\\n    /// @notice Last 'Official price' update timestamp\\n    /// OLA_ADDITIONS : This field\\n    mapping(bytes32 => uint) public pricesLastUpdate;\\n\\n    /// @notice Circuit breaker for using anchor price oracle directly, ignoring reporter\\n    bool public reporterInvalidated;\\n\\n    /// @notice The old observation for each symbolHash\\n    mapping(bytes32 => Observation) public oldObservations;\\n\\n    /// @notice The new observation for each symbolHash\\n    mapping(bytes32 => Observation) public newObservations;\\n\\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\\n    event PriceGuarded(string symbol, uint reporter, uint anchor);\\n\\n    /// @notice The event emitted when the stored price is updated\\n    event PriceUpdated(string symbol, uint price);\\n\\n    /// @notice The event emitted when anchor price is updated\\n    event AnchorPriceUpdated(string symbol, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\\n\\n    /// @notice The event emitted when the uniswap window changes\\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\\n\\n    /// @notice The event emitted when reporter invalidates itself\\n    event ReporterInvalidated(address reporter);\\n\\n    bytes32 constant ethHash = keccak256(abi.encodePacked(\\\"ETH\\\"));\\n    bytes32 constant rotateHash = keccak256(abi.encodePacked(\\\"rotate\\\"));\\n    string public referenceAssetSymbol;\\n    bytes32 public referenceAssetHash;\\n    uint public usdBaseUnit;\\n    address public registry;\\n\\n    /**\\n     * @notice Construct a uniswap anchored view for a set of token configurations\\n     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\\n     * @param reporter_ The reporter whose prices are to be used\\n     * @param referenceAssetSymbol_ The asset('s symbol) to measure the prices of all other (non fixed) assets against.\\n     * @param usdBaseUnit_ Amount that equal to 1 scaled by the base USD token decimals.\\n     * @param anchorToleranceMantissa_ The percentage tolerance that the reporter may deviate from the uniswap anchor\\n     * @param anchorPeriod_ The minimum amount of time required for the old uniswap price accumulator to be replaced\\n     * @param configs The static token configurations which define what prices are supported and how\\n     */\\n    constructor(OpenOraclePriceData priceData_,\\n                address reporter_,\\n                string memory referenceAssetSymbol_,\\n                uint usdBaseUnit_,\\n                uint anchorToleranceMantissa_,\\n                uint anchorPeriod_,\\n                address registry_,\\n                TokenConfig[] memory configs,\\n                string[] memory _autoPokingSymbols) UniswapConfig(configs) public {\\n        priceData = priceData_;\\n        reporter = reporter_;\\n        anchorPeriod = anchorPeriod_;\\n        registry = registry_;\\n        autoPokingSymbols = _autoPokingSymbols;\\n\\n        referenceAssetSymbol = referenceAssetSymbol_;\\n        referenceAssetHash = keccak256(abi.encodePacked(referenceAssetSymbol));\\n        usdBaseUnit = usdBaseUnit_;\\n\\n        // Allow the tolerance to be whatever the deployer chooses, but prevent under/overflow (and prices from being 0)\\n        upperBoundAnchorRatio = anchorToleranceMantissa_ > uint(-1) - 100e16 ? uint(-1) : 100e16 + anchorToleranceMantissa_;\\n        lowerBoundAnchorRatio = anchorToleranceMantissa_ < 100e16 ? 100e16 - anchorToleranceMantissa_ : 1;\\n\\n        for (uint i = 0; i < configs.length; i++) {\\n            TokenConfig memory config = configs[i];\\n            require(config.baseUnit > 0, \\\"baseUnit must be greater than zero\\\");\\n            address uniswapMarket = config.uniswapMarket;\\n            if (config.priceSource == PriceSource.REPORTER || config.priceSource == PriceSource.UNISWAP) {\\n                require(uniswapMarket != address(0), \\\"reported prices must have an anchor\\\");\\n                bytes32 symbolHash = config.symbolHash;\\n                uint cumulativePrice = currentCumulativePrice(config);\\n                oldObservations[symbolHash].timestamp = block.timestamp;\\n                newObservations[symbolHash].timestamp = block.timestamp;\\n                oldObservations[symbolHash].acc = cumulativePrice;\\n                newObservations[symbolHash].acc = cumulativePrice;\\n                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\\n            } else {\\n                require(uniswapMarket == address(0), \\\"only reported prices utilize an anchor\\\");\\n            }\\n\\n            require(PriceSource.ORACLE != config.priceSource || address(0) != registry_, \\\"Registry address required for using oracle asset\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the array of symbols that can be auto poked.\\n     */\\n    function getAllAutoPokingSymbols() external view returns (string[] memory) {\\n        return autoPokingSymbols;\\n    }\\n\\n    /**\\n     * @notice Get the official price for a symbol\\n     * @param symbol The symbol to fetch the price of\\n     * @return Price denominated in USD, with 6 decimals\\n     */\\n    function price(string memory symbol) external view returns (uint) {\\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\\n        return priceInternal(config);\\n    }\\n\\n    function priceInternal(TokenConfig memory config) internal view returns (uint) {\\n        if (config.priceSource == PriceSource.REPORTER || config.priceSource == PriceSource.UNISWAP || config.priceSource == PriceSource.SIGNED_ONLY || config.priceSource == PriceSource.ORACLE) return prices[config.symbolHash];\\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\\n        if (config.priceSource == PriceSource.FIXED_ETH) {\\n            uint usdPerEth = prices[ethHash];\\n            require(usdPerEth > 0, \\\"ETH price not set, cannot convert to dollars\\\");\\n            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the price an asset\\n     * @param asset The asset to get the price of\\n     * @return The asset price mantissa (scaled by 1e18).\\n     *  Zero means the price is unavailable.\\n     */\\n    function getAssetPrice(address asset) external view returns (uint) {\\n        return getAssetPriceInternal(asset);\\n    }\\n\\n    /**\\n     * @notice Get the price update timestamp for the asset\\n     * @param asset The asset address for price update timestamp retrieval.\\n     * @return Last price update timestamp for the asset\\n     */\\n    function getAssetPriceUpdateTimestamp(address asset) external view returns (uint) {\\n        return getAssetPriceUpdateTimestampInternal(asset);\\n    }\\n\\n    /**\\n     * @notice Get the underlying price of a cToken\\n     * @dev Implements the PriceOracle interface for Compound v2.\\n     * @param cToken The cToken address for price retrieval\\n     * @return Price denominated in USD, with 18 decimals, for the given cToken address\\n     */\\n    function getUnderlyingPrice(address cToken) external view returns (uint) {\\n        return getAssetPriceInternal(CErc20ForUniswapConfig(cToken).underlying());\\n    }\\n\\n    /**\\n     * OLA_ADDITIONS : This function\\n     * @notice Get the price update timestamp for the cToken underlying\\n     * @dev Implements the PriceOracle interface for Compound v2.\\n     * @param cToken The cToken address for price update timestamp retrieval.\\n     * @return Last price update timestamp for the cToken underlying asset\\n     */\\n    function getUnderlyingPriceUpdateTimestamp(address cToken) external view returns (uint) {\\n        return getAssetPriceUpdateTimestampInternal(CErc20ForUniswapConfig(cToken).underlying());\\n    }\\n\\n    /**\\n     * @notice Post open oracle reporter prices, and recalculate stored price by comparing to anchor\\n     * @dev We let anyone pay to post anything, but only prices from configured reporter will be stored in the view.\\n     * @param messages The messages to post to the oracle\\n     * @param signatures The signatures for the corresponding messages\\n     * @param symbols The symbols to compare to anchor for authoritative reading\\n     */\\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\\n        require(messages.length == signatures.length, \\\"messages and signatures must be 1:1\\\");\\n\\n        // Save the prices\\n        for (uint i = 0; i < messages.length; i++) {\\n            TokenConfig memory config = getTokenConfigBySymbol(symbols[i]);\\n            if (config.priceSource == PriceSource.REPORTER || config.priceSource == PriceSource.SIGNED_ONLY) {\\n                priceData.put(messages[i], signatures[i]);\\n            }\\n        }\\n\\n        // OLA_ADDITIONS : Using 'core asset price' instead of 'ethPrice\\n        uint referenceAssetPrice = fetchReferenceAssetPrice();\\n\\n        // Try to update the view storage\\n        for (uint i = 0; i < symbols.length; i++) {\\n            postPriceInternal(symbols[i], referenceAssetPrice);\\n        }\\n    }\\n\\n    /**\\n     * @notice Post open oracle reporter prices, and recalculate stored price by comparing to anchor\\n     * @dev We let anyone pay to post anything, but only prices from configured reporter will be stored in the view.\\n     * @param symbols The symbols to compare to anchor for authoritative reading\\n     */\\n    function freshenPrices(string[] calldata symbols) external {\\n        // OLA_ADDITIONS : Using 'core asset price' instead of 'ethPrice\\n        uint referenceAssetPrice = fetchReferenceAssetPrice();\\n\\n        // Try to update the view storage\\n        for (uint i = 0; i < symbols.length; i++) {\\n            postPriceInternal(symbols[i], referenceAssetPrice);\\n        }\\n    }\\n\\n    /**\\n     * @notice Recalculates stored prices for all by comparing to anchor\\n     * @dev Only prices from configured UNISWAP will be recalculated in the view.\\n     */\\n    function freshensAllPrices() external {\\n        string[] memory symbols = autoPokingSymbols;\\n        // OLA_ADDITIONS : Using 'core asset price' instead of 'ethPrice\\n        uint referenceAssetPrice = fetchReferenceAssetPrice();\\n\\n        // Try to update the view storage\\n        for (uint i = 0; i < symbols.length; i++) {\\n            postPriceInternal(symbols[i], referenceAssetPrice);\\n        }\\n    }\\n\\n    function getAssetPriceInternal(address asset) internal view returns (uint) {\\n        TokenConfig memory config;\\n\\n        config = getTokenConfigByUnderlying(asset);\\n\\n        // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\\n        // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\\n        return mul(1e30, priceInternal(config)) / config.baseUnit;\\n    }\\n\\n    function getAssetPriceUpdateTimestampInternal(address asset) internal view returns (uint) {\\n        TokenConfig memory config;\\n\\n        config = getTokenConfigByUnderlying(asset);\\n\\n        return pricesLastUpdate[config.symbolHash];\\n    }\\n\\n    // OLA_ADDITIONS : Using 'referenceAssetPrice' instead of 'ethPrice'\\n    function postPriceInternal(string memory symbol, uint referenceAssetPrice) internal {\\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\\n        require(config.priceSource == PriceSource.REPORTER ||\\n                config.priceSource == PriceSource.UNISWAP ||\\n                config.priceSource == PriceSource.SIGNED_ONLY ||\\n                config.priceSource == PriceSource.ORACLE, \\\"only reporter, uniswap, oracle or signed-only prices get posted\\\");\\n\\n        // OLA_ADDITIONS : Updating 'last price update timestamp' together with the prices\\n        uint lastUpdateTimestamp = block.timestamp;\\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\\n\\n        if (referenceAssetHash == symbolHash) {\\n            prices[referenceAssetHash] = referenceAssetPrice;\\n            pricesLastUpdate[referenceAssetHash] = lastUpdateTimestamp;\\n        }\\n\\n        // OLA_ADDITIONS : Support of 'signed-only' price posting\\n        // Signed-Only prices do not require 'anchorPrice' (which is taken from a pair)\\n        if (config.priceSource == PriceSource.SIGNED_ONLY) {\\n            uint reporterPrice = priceData.getPrice(reporter, symbol);\\n\\n            prices[symbolHash] = reporterPrice;\\n            // OLA_ADDITIONS : Updating price timestamp\\n            pricesLastUpdate[symbolHash] = lastUpdateTimestamp;\\n\\n            emit PriceUpdated(symbol, reporterPrice);\\n\\n            return;\\n        }\\n\\n        if (config.priceSource == PriceSource.ORACLE) {\\n            uint oraclePrice = getPriceFromOracle(config);\\n            prices[symbolHash] = oraclePrice;\\n            pricesLastUpdate[symbolHash] = lastUpdateTimestamp;\\n            emit PriceUpdated(symbol, oraclePrice);\\n        }\\n\\n\\n        uint anchorPrice;\\n        if (symbolHash == referenceAssetHash) {\\n            anchorPrice = referenceAssetPrice;\\n        } else {\\n            uint256 conversionFactor = config.isDirectMarket? config.priceScale: referenceAssetPrice;\\n            anchorPrice = fetchAnchorPrice(symbol, config, conversionFactor);\\n        }\\n\\n\\n        if (config.priceSource == PriceSource.UNISWAP || reporterInvalidated) {\\n            prices[symbolHash] = anchorPrice;\\n            // OLA_ADDITIONS : Updating price timestamp\\n            pricesLastUpdate[symbolHash] = lastUpdateTimestamp;\\n            emit PriceUpdated(symbol, anchorPrice);\\n        } else {\\n            // OLA_ADDITIONS : Moves 'priceData.getPrice' inside to save gas on swap based asses\\n            uint reporterPrice = priceData.getPrice(reporter, symbol);\\n            if (isWithinAnchor(reporterPrice, anchorPrice)) {\\n                prices[symbolHash] = reporterPrice;\\n                // OLA_ADDITIONS : Updating price timestamp\\n                pricesLastUpdate[symbolHash] = lastUpdateTimestamp;\\n                emit PriceUpdated(symbol, reporterPrice);\\n            } else {\\n                emit PriceGuarded(symbol, reporterPrice, anchorPrice);\\n            }\\n        }\\n    }\\n\\n    function isWithinAnchor(uint reporterPrice, uint anchorPrice) internal view returns (bool) {\\n        if (reporterPrice > 0) {\\n            uint anchorRatio = mul(anchorPrice, 100e16) / reporterPrice;\\n            return anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Fetches the current token/eth price accumulator from uniswap.\\n     */\\n    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\\n        if (config.isUniswapReversed) {\\n            return cumulativePrice1;\\n        } else {\\n            return cumulativePrice0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\\n     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\\n     */\\n//    function fetchEthPrice() internal returns (uint) {\\n//        return fetchAnchorPrice(\\\"ETH\\\", getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\\n//    }\\n\\n    function getPriceFromOracle(TokenConfig memory config) internal view returns (uint256 price) {\\n        price = RegistryForUAV(registry).getPriceForAsset(config.underlying);\\n        price = mul(price, 1e6);\\n        price = mul(price, config.baseUnit);\\n        price = price / 1e36;\\n    }\\n\\n    /**\\n     * @dev Fetches the current core/usd price from uniswap, with 6 decimals of precision.\\n     *  Conversion factor is 1e18 for core/usdc market, since we decode uniswap price statically with 18 decimals.\\n     */\\n    function fetchReferenceAssetPrice() internal returns (uint) {\\n        uint256 price;\\n        TokenConfig memory config = getTokenConfigBySymbolHash(referenceAssetHash);\\n\\n        if (PriceSource.REPORTER == config.priceSource || PriceSource.UNISWAP == config.priceSource) {\\n            price = fetchAnchorPrice(referenceAssetSymbol, config, ethBaseUnit);\\n        } else if (PriceSource.ORACLE == config.priceSource) {\\n            price = getPriceFromOracle(config);\\n        } else {\\n            price = priceData.getPrice(reporter, referenceAssetSymbol);\\n        }\\n        require(price != 0, \\\"Reference asset price unavailable\\\");\\n        \\n        return price;\\n    }\\n\\n    /**\\n     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\\n     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\\n     */\\n    function fetchAnchorPrice(string memory symbol, TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\\n\\n        // This should be impossible, but better safe than sorry\\n        require(block.timestamp > oldTimestamp, \\\"now must come after before\\\");\\n        uint timeElapsed = block.timestamp - oldTimestamp;\\n\\n        // Calculate uniswap time-weighted average price\\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\\n        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\\n        uint anchorPrice;\\n\\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\\n\\n        // In the case of non-ETH tokens\\n        // a. pokeWindowValues already handled uniswap reversed cases, so priceAverage will always be Token/ETH TWAP price.\\n        // b. conversionFactor Scale = 1e(18 + 6 - tokenDecimals)). We assume that tokenDecimals is 18. If not, than probably there is a mistake here.\\n        // unscaledPriceMantissa = priceAverage(token/ETH TWAP price) * expScale * conversionFactor\\n        // so ->\\n        // anchorPrice = priceAverage * tokenBaseUnit / ethBaseUnit * ETH_price * 1e6\\n        //             = priceAverage * conversionFactor * tokenBaseUnit / ethBaseUnit\\n        //             = unscaledPriceMantissa / expScale * tokenBaseUnit / ethBaseUnit\\n        anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\\n\\n        if (keccak256(abi.encodePacked(symbol)) == referenceAssetHash) {\\n            anchorPrice = mul(anchorPrice, 1e6) / usdBaseUnit;\\n        }\\n\\n        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\\n\\n        return anchorPrice;\\n    }\\n\\n    /**\\n     * @dev Get time-weighted average prices for a token at the current timestamp.\\n     *  Update new and old observations of lagging window if period elapsed.\\n     */\\n    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\\n        bytes32 symbolHash = config.symbolHash;\\n        uint cumulativePrice = currentCumulativePrice(config);\\n\\n        Observation memory newObservation = newObservations[symbolHash];\\n\\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\\n        if (timeElapsed >= anchorPeriod) {\\n            oldObservations[symbolHash].timestamp = newObservation.timestamp;\\n            oldObservations[symbolHash].acc = newObservation.acc;\\n\\n            newObservations[symbolHash].timestamp = block.timestamp;\\n            newObservations[symbolHash].acc = cumulativePrice;\\n            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\\n        }\\n        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\\n    }\\n\\n    /**\\n     * @notice Invalidate the reporter, and fall back to using anchor directly in all cases\\n     * @dev Only the reporter may sign a message which allows it to invalidate itself.\\n     *  To be used in cases of emergency, if the reporter thinks their key may be compromised.\\n     * @param message The data that was presumably signed\\n     * @param signature The fingerprint of the data + private key\\n     */\\n    function invalidateReporter(bytes memory message, bytes memory signature) external {\\n        (string memory decodedMessage, ) = abi.decode(message, (string, address));\\n        require(keccak256(abi.encodePacked(decodedMessage)) == rotateHash, \\\"invalid message must be 'rotate'\\\");\\n        require(source(message, signature) == reporter, \\\"invalidation message must come from the reporter\\\");\\n        reporterInvalidated = true;\\n        emit ReporterInvalidated(reporter);\\n    }\\n\\n    /**\\n     * @notice Recovers the source address which signed a message\\n     * @dev Comparing to a claimed address would add nothing,\\n     *  as the caller could simply perform the recover and claim that address.\\n     * @param message The data that was presumably signed\\n     * @param signature The fingerprint of the data + private key\\n     * @return The source address which signed the message, presumably\\n     */\\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(message)));\\n        return ecrecover(hash, v, r, s);\\n    }\\n\\n    /// @dev Overflow proof multiplication\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) return 0;\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Ola/Peripheral/PriceOracle/open-oracle/OpenOraclePriceData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./OpenOracleData.sol\\\";\\n\\n/**\\n * @title The Open Oracle Price Data Contract\\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\\n * @author Compound Labs, Inc.\\n */\\ncontract OpenOraclePriceData is OpenOracleData {\\n    ///@notice The event emitted when a source writes to its storage\\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\\n\\n    ///@notice The fundamental unit of storage for a reporter source\\n    struct Datum {\\n        uint64 timestamp;\\n        uint64 value;\\n    }\\n\\n    /**\\n     * @dev The most recent authenticated data from all sources.\\n     *  This is private because dynamic mapping keys preclude auto-generated getters.\\n     */\\n    mapping(address => mapping(string => Datum)) private data;\\n\\n    /**\\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\\n     * @param message The payload containing the timestamp, and (key, value) pairs\\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\\n     * @return The keys that were written\\n     */\\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\\n        (address source, uint64 timestamp, string memory key, uint64 value) = decodeMessage(message, signature);\\n        return putInternal(source, timestamp, key, value);\\n    }\\n\\n    function putInternal(address source, uint64 timestamp, string memory key, uint64 value) internal returns (string memory) {\\n        // Only update if newer than stored, according to source\\n        Datum storage prior = data[source][key];\\n        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes && source != address(0)) {\\n            data[source][key] = Datum(timestamp, value);\\n            emit Write(source, key, timestamp, value);\\n        } else {\\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\\n        }\\n        return key;\\n    }\\n\\n    function decodeMessage(bytes calldata message, bytes calldata signature) internal returns (address, uint64, string memory, uint64) {\\n        // Recover the source address\\n        address source = source(message, signature);\\n\\n        // Decode the message and check the kind\\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\\\"prices\\\")), \\\"Kind of data must be 'prices'\\\");\\n        return (source, timestamp, key, value);\\n    }\\n\\n    /**\\n     * @notice Read a single key from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\\n     */\\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\\n        Datum storage datum = data[source][key];\\n        return (datum.timestamp, datum.value);\\n    }\\n\\n    /**\\n     * @notice Read only the value for a single key from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The price value (defaults to 0)\\n     */\\n    function getPrice(address source, string calldata key) external view returns (uint64) {\\n        return data[source][key].value;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Ola/Peripheral/PriceOracle/open-oracle/Uniswap/UniswapConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface CErc20ForUniswapConfig {\\n    function underlying() external view returns (address);\\n}\\n\\ncontract UniswapConfig {\\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\\n    enum PriceSource {\\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\\n        REPORTER,   /// implies the price is set by the reporter\\n        UNISWAP,     /// implies the price is set by uniswap\\n        SIGNED_ONLY, /// implies the price is set by a reporter without a matching pair\\n        ORACLE       /// implies the price is being fetched from an oracle\\n    }\\n    \\n    /// @dev Describe how the USD price should be determined for an asset.\\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\\n    struct TokenConfig {\\n        address underlying;\\n        bytes32 symbolHash;\\n        uint256 baseUnit;\\n        PriceSource priceSource;\\n        uint256 fixedPrice;\\n        address uniswapMarket;\\n        bool isUniswapReversed;\\n        bool isDirectMarket; // Indicated that the market is to a stable coin, no need to use a reference asset\\n        uint256 priceScale; // Should be (18 + 6 - ScaleTokenDecimals) - ScaleTokenDecimals is the decimals of the token we want the price in. (Ex. BNB in USDC, this value will be (18 + 6 - [USDC's decimals]))\\n    }\\n\\n    /// @notice The max number of tokens this contract is hardcoded to support\\n    /// @dev Do not change this variable without updating all the fields throughout the contract.\\n    uint public constant maxTokens = 15;\\n\\n    /// @notice The number of tokens this contract actually supports\\n    uint public immutable numTokens;\\n\\n    address internal immutable underlying00;\\n    address internal immutable underlying01;\\n    address internal immutable underlying02;\\n    address internal immutable underlying03;\\n    address internal immutable underlying04;\\n    address internal immutable underlying05;\\n    address internal immutable underlying06;\\n    address internal immutable underlying07;\\n    address internal immutable underlying08;\\n    address internal immutable underlying09;\\n    address internal immutable underlying10;\\n    address internal immutable underlying11;\\n    address internal immutable underlying12;\\n    address internal immutable underlying13;\\n    address internal immutable underlying14;\\n    // address internal immutable underlying15;\\n    // address internal immutable underlying16;\\n    // address internal immutable underlying17;\\n    // address internal immutable underlying18;\\n    // address internal immutable underlying19;\\n    // address internal immutable underlying20;\\n    // address internal immutable underlying21;\\n    // address internal immutable underlying22;\\n    // address internal immutable underlying23;\\n    // address internal immutable underlying24;\\n    // address internal immutable underlying25;\\n    // address internal immutable underlying26;\\n    // address internal immutable underlying27;\\n    // address internal immutable underlying28;\\n    // address internal immutable underlying29;\\n\\n    bytes32 internal immutable symbolHash00;\\n    bytes32 internal immutable symbolHash01;\\n    bytes32 internal immutable symbolHash02;\\n    bytes32 internal immutable symbolHash03;\\n    bytes32 internal immutable symbolHash04;\\n    bytes32 internal immutable symbolHash05;\\n    bytes32 internal immutable symbolHash06;\\n    bytes32 internal immutable symbolHash07;\\n    bytes32 internal immutable symbolHash08;\\n    bytes32 internal immutable symbolHash09;\\n    bytes32 internal immutable symbolHash10;\\n    bytes32 internal immutable symbolHash11;\\n    bytes32 internal immutable symbolHash12;\\n    bytes32 internal immutable symbolHash13;\\n    bytes32 internal immutable symbolHash14;\\n    // bytes32 internal immutable symbolHash15;\\n    // bytes32 internal immutable symbolHash16;\\n    // bytes32 internal immutable symbolHash17;\\n    // bytes32 internal immutable symbolHash18;\\n    // bytes32 internal immutable symbolHash19;\\n    // bytes32 internal immutable symbolHash20;\\n    // bytes32 internal immutable symbolHash21;\\n    // bytes32 internal immutable symbolHash22;\\n    // bytes32 internal immutable symbolHash23;\\n    // bytes32 internal immutable symbolHash24;\\n    // bytes32 internal immutable symbolHash25;\\n    // bytes32 internal immutable symbolHash26;\\n    // bytes32 internal immutable symbolHash27;\\n    // bytes32 internal immutable symbolHash28;\\n    // bytes32 internal immutable symbolHash29;\\n\\n    uint256 internal immutable baseUnit00;\\n    uint256 internal immutable baseUnit01;\\n    uint256 internal immutable baseUnit02;\\n    uint256 internal immutable baseUnit03;\\n    uint256 internal immutable baseUnit04;\\n    uint256 internal immutable baseUnit05;\\n    uint256 internal immutable baseUnit06;\\n    uint256 internal immutable baseUnit07;\\n    uint256 internal immutable baseUnit08;\\n    uint256 internal immutable baseUnit09;\\n    uint256 internal immutable baseUnit10;\\n    uint256 internal immutable baseUnit11;\\n    uint256 internal immutable baseUnit12;\\n    uint256 internal immutable baseUnit13;\\n    uint256 internal immutable baseUnit14;\\n    // uint256 internal immutable baseUnit15;\\n    // uint256 internal immutable baseUnit16;\\n    // uint256 internal immutable baseUnit17;\\n    // uint256 internal immutable baseUnit18;\\n    // uint256 internal immutable baseUnit19;\\n    // uint256 internal immutable baseUnit20;\\n    // uint256 internal immutable baseUnit21;\\n    // uint256 internal immutable baseUnit22;\\n    // uint256 internal immutable baseUnit23;\\n    // uint256 internal immutable baseUnit24;\\n    // uint256 internal immutable baseUnit25;\\n    // uint256 internal immutable baseUnit26;\\n    // uint256 internal immutable baseUnit27;\\n    // uint256 internal immutable baseUnit28;\\n    // uint256 internal immutable baseUnit29;\\n\\n    PriceSource internal immutable priceSource00;\\n    PriceSource internal immutable priceSource01;\\n    PriceSource internal immutable priceSource02;\\n    PriceSource internal immutable priceSource03;\\n    PriceSource internal immutable priceSource04;\\n    PriceSource internal immutable priceSource05;\\n    PriceSource internal immutable priceSource06;\\n    PriceSource internal immutable priceSource07;\\n    PriceSource internal immutable priceSource08;\\n    PriceSource internal immutable priceSource09;\\n    PriceSource internal immutable priceSource10;\\n    PriceSource internal immutable priceSource11;\\n    PriceSource internal immutable priceSource12;\\n    PriceSource internal immutable priceSource13;\\n    PriceSource internal immutable priceSource14;\\n    // PriceSource internal immutable priceSource15;\\n    // PriceSource internal immutable priceSource16;\\n    // PriceSource internal immutable priceSource17;\\n    // PriceSource internal immutable priceSource18;\\n    // PriceSource internal immutable priceSource19;\\n    // PriceSource internal immutable priceSource20;\\n    // PriceSource internal immutable priceSource21;\\n    // PriceSource internal immutable priceSource22;\\n    // PriceSource internal immutable priceSource23;\\n    // PriceSource internal immutable priceSource24;\\n    // PriceSource internal immutable priceSource25;\\n    // PriceSource internal immutable priceSource26;\\n    // PriceSource internal immutable priceSource27;\\n    // PriceSource internal immutable priceSource28;\\n    // PriceSource internal immutable priceSource29;\\n\\n    uint256 internal immutable fixedPrice00;\\n    uint256 internal immutable fixedPrice01;\\n    uint256 internal immutable fixedPrice02;\\n    uint256 internal immutable fixedPrice03;\\n    uint256 internal immutable fixedPrice04;\\n    uint256 internal immutable fixedPrice05;\\n    uint256 internal immutable fixedPrice06;\\n    uint256 internal immutable fixedPrice07;\\n    uint256 internal immutable fixedPrice08;\\n    uint256 internal immutable fixedPrice09;\\n    uint256 internal immutable fixedPrice10;\\n    uint256 internal immutable fixedPrice11;\\n    uint256 internal immutable fixedPrice12;\\n    uint256 internal immutable fixedPrice13;\\n    uint256 internal immutable fixedPrice14;\\n    // uint256 internal immutable fixedPrice15;\\n    // uint256 internal immutable fixedPrice16;\\n    // uint256 internal immutable fixedPrice17;\\n    // uint256 internal immutable fixedPrice18;\\n    // uint256 internal immutable fixedPrice19;\\n    // uint256 internal immutable fixedPrice20;\\n    // uint256 internal immutable fixedPrice21;\\n    // uint256 internal immutable fixedPrice22;\\n    // uint256 internal immutable fixedPrice23;\\n    // uint256 internal immutable fixedPrice24;\\n    // uint256 internal immutable fixedPrice25;\\n    // uint256 internal immutable fixedPrice26;\\n    // uint256 internal immutable fixedPrice27;\\n    // uint256 internal immutable fixedPrice28;\\n    // uint256 internal immutable fixedPrice29;\\n\\n    address internal immutable uniswapMarket00;\\n    address internal immutable uniswapMarket01;\\n    address internal immutable uniswapMarket02;\\n    address internal immutable uniswapMarket03;\\n    address internal immutable uniswapMarket04;\\n    address internal immutable uniswapMarket05;\\n    address internal immutable uniswapMarket06;\\n    address internal immutable uniswapMarket07;\\n    address internal immutable uniswapMarket08;\\n    address internal immutable uniswapMarket09;\\n    address internal immutable uniswapMarket10;\\n    address internal immutable uniswapMarket11;\\n    address internal immutable uniswapMarket12;\\n    address internal immutable uniswapMarket13;\\n    address internal immutable uniswapMarket14;\\n    // address internal immutable uniswapMarket15;\\n    // address internal immutable uniswapMarket16;\\n    // address internal immutable uniswapMarket17;\\n    // address internal immutable uniswapMarket18;\\n    // address internal immutable uniswapMarket19;\\n    // address internal immutable uniswapMarket20;\\n    // address internal immutable uniswapMarket21;\\n    // address internal immutable uniswapMarket22;\\n    // address internal immutable uniswapMarket23;\\n    // address internal immutable uniswapMarket24;\\n    // address internal immutable uniswapMarket25;\\n    // address internal immutable uniswapMarket26;\\n    // address internal immutable uniswapMarket27;\\n    // address internal immutable uniswapMarket28;\\n    // address internal immutable uniswapMarket29;\\n\\n    bool internal immutable isUniswapReversed00;\\n    bool internal immutable isUniswapReversed01;\\n    bool internal immutable isUniswapReversed02;\\n    bool internal immutable isUniswapReversed03;\\n    bool internal immutable isUniswapReversed04;\\n    bool internal immutable isUniswapReversed05;\\n    bool internal immutable isUniswapReversed06;\\n    bool internal immutable isUniswapReversed07;\\n    bool internal immutable isUniswapReversed08;\\n    bool internal immutable isUniswapReversed09;\\n    bool internal immutable isUniswapReversed10;\\n    bool internal immutable isUniswapReversed11;\\n    bool internal immutable isUniswapReversed12;\\n    bool internal immutable isUniswapReversed13;\\n    bool internal immutable isUniswapReversed14;\\n    // bool internal immutable isUniswapReversed15;\\n    // bool internal immutable isUniswapReversed16;\\n    // bool internal immutable isUniswapReversed17;\\n    // bool internal immutable isUniswapReversed18;\\n    // bool internal immutable isUniswapReversed19;\\n    // bool internal immutable isUniswapReversed20;\\n    // bool internal immutable isUniswapReversed21;\\n    // bool internal immutable isUniswapReversed22;\\n    // bool internal immutable isUniswapReversed23;\\n    // bool internal immutable isUniswapReversed24;\\n    // bool internal immutable isUniswapReversed25;\\n    // bool internal immutable isUniswapReversed26;\\n    // bool internal immutable isUniswapReversed27;\\n    // bool internal immutable isUniswapReversed28;\\n    // bool internal immutable isUniswapReversed29;\\n\\n    bool[30] internal isDirectMarkets;\\n\\n    bool internal immutable isDirectMarket00;\\n    bool internal immutable isDirectMarket01;\\n    bool internal immutable isDirectMarket02;\\n    bool internal immutable isDirectMarket03;\\n    bool internal immutable isDirectMarket04;\\n    bool internal immutable isDirectMarket05;\\n    bool internal immutable isDirectMarket06;\\n    bool internal immutable isDirectMarket07;\\n    bool internal immutable isDirectMarket08;\\n    bool internal immutable isDirectMarket09;\\n    bool internal immutable isDirectMarket10;\\n    bool internal immutable isDirectMarket11;\\n    bool internal immutable isDirectMarket12;\\n    bool internal immutable isDirectMarket13;\\n    bool internal immutable isDirectMarket14;\\n    // bool internal immutable isDirectMarket15;\\n    // bool internal immutable isDirectMarket16;\\n    // bool internal immutable isDirectMarket17;\\n    // bool internal immutable isDirectMarket18;\\n    // bool internal immutable isDirectMarket19;\\n    // bool internal immutable isDirectMarket20;\\n    // bool internal immutable isDirectMarket21;\\n    // bool internal immutable isDirectMarket22;\\n    // bool internal immutable isDirectMarket23;\\n    // bool internal immutable isDirectMarket24;\\n    // bool internal immutable isDirectMarket25;\\n    // bool internal immutable isDirectMarket26;\\n    // bool internal immutable isDirectMarket27;\\n    // bool internal immutable isDirectMarket28;\\n    // bool internal immutable isDirectMarket29;\\n\\n    uint256 internal immutable priceScale00;\\n    uint256 internal immutable priceScale01;\\n    uint256 internal immutable priceScale02;\\n    uint256 internal immutable priceScale03;\\n    uint256 internal immutable priceScale04;\\n    uint256 internal immutable priceScale05;\\n    uint256 internal immutable priceScale06;\\n    uint256 internal immutable priceScale07;\\n    uint256 internal immutable priceScale08;\\n    uint256 internal immutable priceScale09;\\n    uint256 internal immutable priceScale10;\\n    uint256 internal immutable priceScale11;\\n    uint256 internal immutable priceScale12;\\n    uint256 internal immutable priceScale13;\\n    uint256 internal immutable priceScale14;\\n\\n    /**\\n     * @notice Construct an immutable store of configs into the contract data\\n     * @param configs The configs for the supported assets\\n     */\\n    constructor(TokenConfig[] memory configs) public {\\n        require(configs.length <= maxTokens, \\\"too many configs\\\");\\n        numTokens = configs.length;\\n\\n        underlying00 = get(configs, 0).underlying;\\n        underlying01 = get(configs, 1).underlying;\\n        underlying02 = get(configs, 2).underlying;\\n        underlying03 = get(configs, 3).underlying;\\n        underlying04 = get(configs, 4).underlying;\\n        underlying05 = get(configs, 5).underlying;\\n        underlying06 = get(configs, 6).underlying;\\n        underlying07 = get(configs, 7).underlying;\\n        underlying08 = get(configs, 8).underlying;\\n        underlying09 = get(configs, 9).underlying;\\n        underlying10 = get(configs, 10).underlying;\\n        underlying11 = get(configs, 11).underlying;\\n        underlying12 = get(configs, 12).underlying;\\n        underlying13 = get(configs, 13).underlying;\\n        underlying14 = get(configs, 14).underlying;\\n        // underlying15 = get(configs, 15).underlying;\\n        // underlying16 = get(configs, 16).underlying;\\n        // underlying17 = get(configs, 17).underlying;\\n        // underlying18 = get(configs, 18).underlying;\\n        // underlying19 = get(configs, 19).underlying;\\n        // underlying20 = get(configs, 20).underlying;\\n        // underlying21 = get(configs, 21).underlying;\\n        // underlying22 = get(configs, 22).underlying;\\n        // underlying23 = get(configs, 23).underlying;\\n        // underlying24 = get(configs, 24).underlying;\\n        // underlying25 = get(configs, 25).underlying;\\n        // underlying26 = get(configs, 26).underlying;\\n        // underlying27 = get(configs, 27).underlying;\\n        // underlying28 = get(configs, 28).underlying;\\n        // underlying29 = get(configs, 29).underlying;\\n\\n        symbolHash00 = get(configs, 0).symbolHash;\\n        symbolHash01 = get(configs, 1).symbolHash;\\n        symbolHash02 = get(configs, 2).symbolHash;\\n        symbolHash03 = get(configs, 3).symbolHash;\\n        symbolHash04 = get(configs, 4).symbolHash;\\n        symbolHash05 = get(configs, 5).symbolHash;\\n        symbolHash06 = get(configs, 6).symbolHash;\\n        symbolHash07 = get(configs, 7).symbolHash;\\n        symbolHash08 = get(configs, 8).symbolHash;\\n        symbolHash09 = get(configs, 9).symbolHash;\\n        symbolHash10 = get(configs, 10).symbolHash;\\n        symbolHash11 = get(configs, 11).symbolHash;\\n        symbolHash12 = get(configs, 12).symbolHash;\\n        symbolHash13 = get(configs, 13).symbolHash;\\n        symbolHash14 = get(configs, 14).symbolHash;\\n        // symbolHash15 = get(configs, 15).symbolHash;\\n        // symbolHash16 = get(configs, 16).symbolHash;\\n        // symbolHash17 = get(configs, 17).symbolHash;\\n        // symbolHash18 = get(configs, 18).symbolHash;\\n        // symbolHash19 = get(configs, 19).symbolHash;\\n        // symbolHash20 = get(configs, 20).symbolHash;\\n        // symbolHash21 = get(configs, 21).symbolHash;\\n        // symbolHash22 = get(configs, 22).symbolHash;\\n        // symbolHash23 = get(configs, 23).symbolHash;\\n        // symbolHash24 = get(configs, 24).symbolHash;\\n        // symbolHash25 = get(configs, 25).symbolHash;\\n        // symbolHash26 = get(configs, 26).symbolHash;\\n        // symbolHash27 = get(configs, 27).symbolHash;\\n        // symbolHash28 = get(configs, 28).symbolHash;\\n        // symbolHash29 = get(configs, 29).symbolHash;\\n\\n        baseUnit00 = get(configs, 0).baseUnit;\\n        baseUnit01 = get(configs, 1).baseUnit;\\n        baseUnit02 = get(configs, 2).baseUnit;\\n        baseUnit03 = get(configs, 3).baseUnit;\\n        baseUnit04 = get(configs, 4).baseUnit;\\n        baseUnit05 = get(configs, 5).baseUnit;\\n        baseUnit06 = get(configs, 6).baseUnit;\\n        baseUnit07 = get(configs, 7).baseUnit;\\n        baseUnit08 = get(configs, 8).baseUnit;\\n        baseUnit09 = get(configs, 9).baseUnit;\\n        baseUnit10 = get(configs, 10).baseUnit;\\n        baseUnit11 = get(configs, 11).baseUnit;\\n        baseUnit12 = get(configs, 12).baseUnit;\\n        baseUnit13 = get(configs, 13).baseUnit;\\n        baseUnit14 = get(configs, 14).baseUnit;\\n        // baseUnit15 = get(configs, 15).baseUnit;\\n        // baseUnit16 = get(configs, 16).baseUnit;\\n        // baseUnit17 = get(configs, 17).baseUnit;\\n        // baseUnit18 = get(configs, 18).baseUnit;\\n        // baseUnit19 = get(configs, 19).baseUnit;\\n        // baseUnit20 = get(configs, 20).baseUnit;\\n        // baseUnit21 = get(configs, 21).baseUnit;\\n        // baseUnit22 = get(configs, 22).baseUnit;\\n        // baseUnit23 = get(configs, 23).baseUnit;\\n        // baseUnit24 = get(configs, 24).baseUnit;\\n        // baseUnit25 = get(configs, 25).baseUnit;\\n        // baseUnit26 = get(configs, 26).baseUnit;\\n        // baseUnit27 = get(configs, 27).baseUnit;\\n        // baseUnit28 = get(configs, 28).baseUnit;\\n        // baseUnit29 = get(configs, 29).baseUnit;\\n\\n        priceSource00 = get(configs, 0).priceSource;\\n        priceSource01 = get(configs, 1).priceSource;\\n        priceSource02 = get(configs, 2).priceSource;\\n        priceSource03 = get(configs, 3).priceSource;\\n        priceSource04 = get(configs, 4).priceSource;\\n        priceSource05 = get(configs, 5).priceSource;\\n        priceSource06 = get(configs, 6).priceSource;\\n        priceSource07 = get(configs, 7).priceSource;\\n        priceSource08 = get(configs, 8).priceSource;\\n        priceSource09 = get(configs, 9).priceSource;\\n        priceSource10 = get(configs, 10).priceSource;\\n        priceSource11 = get(configs, 11).priceSource;\\n        priceSource12 = get(configs, 12).priceSource;\\n        priceSource13 = get(configs, 13).priceSource;\\n        priceSource14 = get(configs, 14).priceSource;\\n        // priceSource15 = get(configs, 15).priceSource;\\n        // priceSource16 = get(configs, 16).priceSource;\\n        // priceSource17 = get(configs, 17).priceSource;\\n        // priceSource18 = get(configs, 18).priceSource;\\n        // priceSource19 = get(configs, 19).priceSource;\\n        // priceSource20 = get(configs, 20).priceSource;\\n        // priceSource21 = get(configs, 21).priceSource;\\n        // priceSource22 = get(configs, 22).priceSource;\\n        // priceSource23 = get(configs, 23).priceSource;\\n        // priceSource24 = get(configs, 24).priceSource;\\n        // priceSource25 = get(configs, 25).priceSource;\\n        // priceSource26 = get(configs, 26).priceSource;\\n        // priceSource27 = get(configs, 27).priceSource;\\n        // priceSource28 = get(configs, 28).priceSource;\\n        // priceSource29 = get(configs, 29).priceSource;\\n\\n        fixedPrice00 = get(configs, 0).fixedPrice;\\n        fixedPrice01 = get(configs, 1).fixedPrice;\\n        fixedPrice02 = get(configs, 2).fixedPrice;\\n        fixedPrice03 = get(configs, 3).fixedPrice;\\n        fixedPrice04 = get(configs, 4).fixedPrice;\\n        fixedPrice05 = get(configs, 5).fixedPrice;\\n        fixedPrice06 = get(configs, 6).fixedPrice;\\n        fixedPrice07 = get(configs, 7).fixedPrice;\\n        fixedPrice08 = get(configs, 8).fixedPrice;\\n        fixedPrice09 = get(configs, 9).fixedPrice;\\n        fixedPrice10 = get(configs, 10).fixedPrice;\\n        fixedPrice11 = get(configs, 11).fixedPrice;\\n        fixedPrice12 = get(configs, 12).fixedPrice;\\n        fixedPrice13 = get(configs, 13).fixedPrice;\\n        fixedPrice14 = get(configs, 14).fixedPrice;\\n        // fixedPrice15 = get(configs, 15).fixedPrice;\\n        // fixedPrice16 = get(configs, 16).fixedPrice;\\n        // fixedPrice17 = get(configs, 17).fixedPrice;\\n        // fixedPrice18 = get(configs, 18).fixedPrice;\\n        // fixedPrice19 = get(configs, 19).fixedPrice;\\n        // fixedPrice20 = get(configs, 20).fixedPrice;\\n        // fixedPrice21 = get(configs, 21).fixedPrice;\\n        // fixedPrice22 = get(configs, 22).fixedPrice;\\n        // fixedPrice23 = get(configs, 23).fixedPrice;\\n        // fixedPrice24 = get(configs, 24).fixedPrice;\\n        // fixedPrice25 = get(configs, 25).fixedPrice;\\n        // fixedPrice26 = get(configs, 26).fixedPrice;\\n        // fixedPrice27 = get(configs, 27).fixedPrice;\\n        // fixedPrice28 = get(configs, 28).fixedPrice;\\n        // fixedPrice29 = get(configs, 29).fixedPrice;\\n\\n        uniswapMarket00 = get(configs, 0).uniswapMarket;\\n        uniswapMarket01 = get(configs, 1).uniswapMarket;\\n        uniswapMarket02 = get(configs, 2).uniswapMarket;\\n        uniswapMarket03 = get(configs, 3).uniswapMarket;\\n        uniswapMarket04 = get(configs, 4).uniswapMarket;\\n        uniswapMarket05 = get(configs, 5).uniswapMarket;\\n        uniswapMarket06 = get(configs, 6).uniswapMarket;\\n        uniswapMarket07 = get(configs, 7).uniswapMarket;\\n        uniswapMarket08 = get(configs, 8).uniswapMarket;\\n        uniswapMarket09 = get(configs, 9).uniswapMarket;\\n        uniswapMarket10 = get(configs, 10).uniswapMarket;\\n        uniswapMarket11 = get(configs, 11).uniswapMarket;\\n        uniswapMarket12 = get(configs, 12).uniswapMarket;\\n        uniswapMarket13 = get(configs, 13).uniswapMarket;\\n        uniswapMarket14 = get(configs, 14).uniswapMarket;\\n        // uniswapMarket15 = get(configs, 15).uniswapMarket;\\n        // uniswapMarket16 = get(configs, 16).uniswapMarket;\\n        // uniswapMarket17 = get(configs, 17).uniswapMarket;\\n        // uniswapMarket18 = get(configs, 18).uniswapMarket;\\n        // uniswapMarket19 = get(configs, 19).uniswapMarket;\\n        // uniswapMarket20 = get(configs, 20).uniswapMarket;\\n        // uniswapMarket21 = get(configs, 21).uniswapMarket;\\n        // uniswapMarket22 = get(configs, 22).uniswapMarket;\\n        // uniswapMarket23 = get(configs, 23).uniswapMarket;\\n        // uniswapMarket24 = get(configs, 24).uniswapMarket;\\n        // uniswapMarket25 = get(configs, 25).uniswapMarket;\\n        // uniswapMarket26 = get(configs, 26).uniswapMarket;\\n        // uniswapMarket27 = get(configs, 27).uniswapMarket;\\n        // uniswapMarket28 = get(configs, 28).uniswapMarket;\\n        // uniswapMarket29 = get(configs, 29).uniswapMarket;\\n\\n        isUniswapReversed00 = get(configs, 0).isUniswapReversed;\\n        isUniswapReversed01 = get(configs, 1).isUniswapReversed;\\n        isUniswapReversed02 = get(configs, 2).isUniswapReversed;\\n        isUniswapReversed03 = get(configs, 3).isUniswapReversed;\\n        isUniswapReversed04 = get(configs, 4).isUniswapReversed;\\n        isUniswapReversed05 = get(configs, 5).isUniswapReversed;\\n        isUniswapReversed06 = get(configs, 6).isUniswapReversed;\\n        isUniswapReversed07 = get(configs, 7).isUniswapReversed;\\n        isUniswapReversed08 = get(configs, 8).isUniswapReversed;\\n        isUniswapReversed09 = get(configs, 9).isUniswapReversed;\\n        isUniswapReversed10 = get(configs, 10).isUniswapReversed;\\n        isUniswapReversed11 = get(configs, 11).isUniswapReversed;\\n        isUniswapReversed12 = get(configs, 12).isUniswapReversed;\\n        isUniswapReversed13 = get(configs, 13).isUniswapReversed;\\n        isUniswapReversed14 = get(configs, 14).isUniswapReversed;\\n        // isUniswapReversed15 = get(configs, 15).isUniswapReversed;\\n        // isUniswapReversed16 = get(configs, 16).isUniswapReversed;\\n        // isUniswapReversed17 = get(configs, 17).isUniswapReversed;\\n        // isUniswapReversed18 = get(configs, 18).isUniswapReversed;\\n        // isUniswapReversed19 = get(configs, 19).isUniswapReversed;\\n        // isUniswapReversed20 = get(configs, 20).isUniswapReversed;\\n        // isUniswapReversed21 = get(configs, 21).isUniswapReversed;\\n        // isUniswapReversed22 = get(configs, 22).isUniswapReversed;\\n        // isUniswapReversed23 = get(configs, 23).isUniswapReversed;\\n        // isUniswapReversed24 = get(configs, 24).isUniswapReversed;\\n        // isUniswapReversed25 = get(configs, 25).isUniswapReversed;\\n        // isUniswapReversed26 = get(configs, 26).isUniswapReversed;\\n        // isUniswapReversed27 = get(configs, 27).isUniswapReversed;\\n        // isUniswapReversed28 = get(configs, 28).isUniswapReversed;\\n        // isUniswapReversed29 = get(configs, 29).isUniswapReversed;\\n\\n        isDirectMarket00 = get(configs, 0).isDirectMarket;\\n        isDirectMarket01 = get(configs, 1).isDirectMarket;\\n        isDirectMarket02 = get(configs, 2).isDirectMarket;\\n        isDirectMarket03 = get(configs, 3).isDirectMarket;\\n        isDirectMarket04 = get(configs, 4).isDirectMarket;\\n        isDirectMarket05 = get(configs, 5).isDirectMarket;\\n        isDirectMarket06 = get(configs, 6).isDirectMarket;\\n        isDirectMarket07 = get(configs, 7).isDirectMarket;\\n        isDirectMarket08 = get(configs, 8).isDirectMarket;\\n        isDirectMarket09 = get(configs, 9).isDirectMarket;\\n        isDirectMarket10 = get(configs, 10).isDirectMarket;\\n        isDirectMarket11 = get(configs, 11).isDirectMarket;\\n        isDirectMarket12 = get(configs, 12).isDirectMarket;\\n        isDirectMarket13 = get(configs, 13).isDirectMarket;\\n        isDirectMarket14 = get(configs, 14).isDirectMarket;\\n        // isDirectMarket15 = get(configs, 15).isDirectMarket;\\n        // isDirectMarket16 = get(configs, 16).isDirectMarket;\\n        // isDirectMarket17 = get(configs, 17).isDirectMarket;\\n        // isDirectMarket18 = get(configs, 18).isDirectMarket;\\n        // isDirectMarket19 = get(configs, 19).isDirectMarket;\\n        // isDirectMarket20 = get(configs, 20).isDirectMarket;\\n        // isDirectMarket21 = get(configs, 21).isDirectMarket;\\n        // isDirectMarket22 = get(configs, 22).isDirectMarket;\\n        // isDirectMarket23 = get(configs, 23).isDirectMarket;\\n        // isDirectMarket24 = get(configs, 24).isDirectMarket;\\n        // isDirectMarket25 = get(configs, 25).isDirectMarket;\\n        // isDirectMarket26 = get(configs, 26).isDirectMarket;\\n        // isDirectMarket27 = get(configs, 27).isDirectMarket;\\n        // isDirectMarket28 = get(configs, 28).isDirectMarket;\\n        // isDirectMarket29 = get(configs, 29).isDirectMarket;\\n\\n        priceScale00 = get(configs, 0).priceScale;\\n        priceScale01 = get(configs, 1).priceScale;\\n        priceScale02 = get(configs, 2).priceScale;\\n        priceScale03 = get(configs, 3).priceScale;\\n        priceScale04 = get(configs, 4).priceScale;\\n        priceScale05 = get(configs, 5).priceScale;\\n        priceScale06 = get(configs, 6).priceScale;\\n        priceScale07 = get(configs, 7).priceScale;\\n        priceScale08 = get(configs, 8).priceScale;\\n        priceScale09 = get(configs, 9).priceScale;\\n        priceScale10 = get(configs, 10).priceScale;\\n        priceScale11 = get(configs, 11).priceScale;\\n        priceScale12 = get(configs, 12).priceScale;\\n        priceScale13 = get(configs, 13).priceScale;\\n        priceScale14 = get(configs, 14).priceScale;\\n        \\n    }\\n\\n    function get(TokenConfig[] memory configs, uint i) internal pure returns (TokenConfig memory) {\\n        if (i < configs.length)\\n            return configs[i];\\n        return TokenConfig({\\n            underlying: address(0),\\n            symbolHash: bytes32(0),\\n            baseUnit: uint256(0),\\n            priceSource: PriceSource(0),\\n            fixedPrice: uint256(0),\\n            uniswapMarket: address(0),\\n            isUniswapReversed: false,\\n            isDirectMarket: false,\\n            priceScale: uint256(0)\\n        });\\n    }\\n\\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\\n        if (underlying == underlying00) return 0;\\n        if (underlying == underlying01) return 1;\\n        if (underlying == underlying02) return 2;\\n        if (underlying == underlying03) return 3;\\n        if (underlying == underlying04) return 4;\\n        if (underlying == underlying05) return 5;\\n        if (underlying == underlying06) return 6;\\n        if (underlying == underlying07) return 7;\\n        if (underlying == underlying08) return 8;\\n        if (underlying == underlying09) return 9;\\n        if (underlying == underlying10) return 10;\\n        if (underlying == underlying11) return 11;\\n        if (underlying == underlying12) return 12;\\n        if (underlying == underlying13) return 13;\\n        if (underlying == underlying14) return 14;\\n        // if (underlying == underlying15) return 15;\\n        // if (underlying == underlying16) return 16;\\n        // if (underlying == underlying17) return 17;\\n        // if (underlying == underlying18) return 18;\\n        // if (underlying == underlying19) return 19;\\n        // if (underlying == underlying20) return 20;\\n        // if (underlying == underlying21) return 21;\\n        // if (underlying == underlying22) return 22;\\n        // if (underlying == underlying23) return 23;\\n        // if (underlying == underlying24) return 24;\\n        // if (underlying == underlying25) return 25;\\n        // if (underlying == underlying26) return 26;\\n        // if (underlying == underlying27) return 27;\\n        // if (underlying == underlying28) return 28;\\n        // if (underlying == underlying29) return 29;\\n\\n        return uint(-1);\\n    }\\n\\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\\n        if (symbolHash == symbolHash00) return 0;\\n        if (symbolHash == symbolHash01) return 1;\\n        if (symbolHash == symbolHash02) return 2;\\n        if (symbolHash == symbolHash03) return 3;\\n        if (symbolHash == symbolHash04) return 4;\\n        if (symbolHash == symbolHash05) return 5;\\n        if (symbolHash == symbolHash06) return 6;\\n        if (symbolHash == symbolHash07) return 7;\\n        if (symbolHash == symbolHash08) return 8;\\n        if (symbolHash == symbolHash09) return 9;\\n        if (symbolHash == symbolHash10) return 10;\\n        if (symbolHash == symbolHash11) return 11;\\n        if (symbolHash == symbolHash12) return 12;\\n        if (symbolHash == symbolHash13) return 13;\\n        if (symbolHash == symbolHash14) return 14;\\n        // if (symbolHash == symbolHash15) return 15;\\n        // if (symbolHash == symbolHash16) return 16;\\n        // if (symbolHash == symbolHash17) return 17;\\n        // if (symbolHash == symbolHash18) return 18;\\n        // if (symbolHash == symbolHash19) return 19;\\n        // if (symbolHash == symbolHash20) return 20;\\n        // if (symbolHash == symbolHash21) return 21;\\n        // if (symbolHash == symbolHash22) return 22;\\n        // if (symbolHash == symbolHash23) return 23;\\n        // if (symbolHash == symbolHash24) return 24;\\n        // if (symbolHash == symbolHash25) return 25;\\n        // if (symbolHash == symbolHash26) return 26;\\n        // if (symbolHash == symbolHash27) return 27;\\n        // if (symbolHash == symbolHash28) return 28;\\n        // if (symbolHash == symbolHash29) return 29;\\n\\n        return uint(-1);\\n    }\\n\\n    /**\\n     * @notice Get the i-th config, according to the order they were passed in originally\\n     * @param i The index of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\\n        require(i < numTokens, \\\"token config not found\\\");\\n\\n        if (i == 1) return TokenConfig({underlying: underlying01, symbolHash: symbolHash01, baseUnit: baseUnit01, priceSource: priceSource01, fixedPrice: fixedPrice01, uniswapMarket: uniswapMarket01, isUniswapReversed: isUniswapReversed01, isDirectMarket: isDirectMarket01, priceScale: priceScale01});\\n        if (i == 0) return TokenConfig({underlying: underlying00, symbolHash: symbolHash00, baseUnit: baseUnit00, priceSource: priceSource00, fixedPrice: fixedPrice00, uniswapMarket: uniswapMarket00, isUniswapReversed: isUniswapReversed00, isDirectMarket: isDirectMarket00, priceScale: priceScale00});\\n        if (i == 2) return TokenConfig({underlying: underlying02, symbolHash: symbolHash02, baseUnit: baseUnit02, priceSource: priceSource02, fixedPrice: fixedPrice02, uniswapMarket: uniswapMarket02, isUniswapReversed: isUniswapReversed02, isDirectMarket: isDirectMarket02, priceScale: priceScale02});\\n        if (i == 3) return TokenConfig({underlying: underlying03, symbolHash: symbolHash03, baseUnit: baseUnit03, priceSource: priceSource03, fixedPrice: fixedPrice03, uniswapMarket: uniswapMarket03, isUniswapReversed: isUniswapReversed03, isDirectMarket: isDirectMarket03, priceScale: priceScale03});\\n        if (i == 4) return TokenConfig({underlying: underlying04, symbolHash: symbolHash04, baseUnit: baseUnit04, priceSource: priceSource04, fixedPrice: fixedPrice04, uniswapMarket: uniswapMarket04, isUniswapReversed: isUniswapReversed04, isDirectMarket: isDirectMarket04, priceScale: priceScale04});\\n        if (i == 5) return TokenConfig({underlying: underlying05, symbolHash: symbolHash05, baseUnit: baseUnit05, priceSource: priceSource05, fixedPrice: fixedPrice05, uniswapMarket: uniswapMarket05, isUniswapReversed: isUniswapReversed05, isDirectMarket: isDirectMarket05, priceScale: priceScale05});\\n        if (i == 6) return TokenConfig({underlying: underlying06, symbolHash: symbolHash06, baseUnit: baseUnit06, priceSource: priceSource06, fixedPrice: fixedPrice06, uniswapMarket: uniswapMarket06, isUniswapReversed: isUniswapReversed06, isDirectMarket: isDirectMarket06, priceScale: priceScale06});\\n        if (i == 7) return TokenConfig({underlying: underlying07, symbolHash: symbolHash07, baseUnit: baseUnit07, priceSource: priceSource07, fixedPrice: fixedPrice07, uniswapMarket: uniswapMarket07, isUniswapReversed: isUniswapReversed07, isDirectMarket: isDirectMarket07, priceScale: priceScale07});\\n        if (i == 8) return TokenConfig({underlying: underlying08, symbolHash: symbolHash08, baseUnit: baseUnit08, priceSource: priceSource08, fixedPrice: fixedPrice08, uniswapMarket: uniswapMarket08, isUniswapReversed: isUniswapReversed08, isDirectMarket: isDirectMarket08, priceScale: priceScale08});\\n        if (i == 9) return TokenConfig({underlying: underlying09, symbolHash: symbolHash09, baseUnit: baseUnit09, priceSource: priceSource09, fixedPrice: fixedPrice09, uniswapMarket: uniswapMarket09, isUniswapReversed: isUniswapReversed09, isDirectMarket: isDirectMarket09, priceScale: priceScale09});\\n\\n        if (i == 10) return TokenConfig({underlying: underlying10, symbolHash: symbolHash10, baseUnit: baseUnit10, priceSource: priceSource10, fixedPrice: fixedPrice10, uniswapMarket: uniswapMarket10, isUniswapReversed: isUniswapReversed10, isDirectMarket: isDirectMarket10, priceScale: priceScale10});\\n        if (i == 11) return TokenConfig({underlying: underlying11, symbolHash: symbolHash11, baseUnit: baseUnit11, priceSource: priceSource11, fixedPrice: fixedPrice11, uniswapMarket: uniswapMarket11, isUniswapReversed: isUniswapReversed11, isDirectMarket: isDirectMarket11, priceScale: priceScale11});\\n        if (i == 12) return TokenConfig({underlying: underlying12, symbolHash: symbolHash12, baseUnit: baseUnit12, priceSource: priceSource12, fixedPrice: fixedPrice12, uniswapMarket: uniswapMarket12, isUniswapReversed: isUniswapReversed12, isDirectMarket: isDirectMarket12, priceScale: priceScale12});\\n        if (i == 13) return TokenConfig({underlying: underlying13, symbolHash: symbolHash13, baseUnit: baseUnit13, priceSource: priceSource13, fixedPrice: fixedPrice13, uniswapMarket: uniswapMarket13, isUniswapReversed: isUniswapReversed13, isDirectMarket: isDirectMarket13, priceScale: priceScale13});\\n        if (i == 14) return TokenConfig({underlying: underlying14, symbolHash: symbolHash14, baseUnit: baseUnit14, priceSource: priceSource14, fixedPrice: fixedPrice14, uniswapMarket: uniswapMarket14, isUniswapReversed: isUniswapReversed14, isDirectMarket: isDirectMarket14, priceScale: priceScale14});\\n        // if (i == 15) return TokenConfig({underlying: underlying15, symbolHash: symbolHash15, baseUnit: baseUnit15, priceSource: priceSource15, fixedPrice: fixedPrice15, uniswapMarket: uniswapMarket15, isUniswapReversed: isUniswapReversed15, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 16) return TokenConfig({underlying: underlying16, symbolHash: symbolHash16, baseUnit: baseUnit16, priceSource: priceSource16, fixedPrice: fixedPrice16, uniswapMarket: uniswapMarket16, isUniswapReversed: isUniswapReversed16, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 17) return TokenConfig({underlying: underlying17, symbolHash: symbolHash17, baseUnit: baseUnit17, priceSource: priceSource17, fixedPrice: fixedPrice17, uniswapMarket: uniswapMarket17, isUniswapReversed: isUniswapReversed17, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 18) return TokenConfig({underlying: underlying18, symbolHash: symbolHash18, baseUnit: baseUnit18, priceSource: priceSource18, fixedPrice: fixedPrice18, uniswapMarket: uniswapMarket18, isUniswapReversed: isUniswapReversed18, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 19) return TokenConfig({underlying: underlying19, symbolHash: symbolHash19, baseUnit: baseUnit19, priceSource: priceSource19, fixedPrice: fixedPrice19, uniswapMarket: uniswapMarket19, isUniswapReversed: isUniswapReversed19, isDirectMarket: isDirectMarkets[i]});\\n\\n        // if (i == 20) return TokenConfig({underlying: underlying20, symbolHash: symbolHash20, baseUnit: baseUnit20, priceSource: priceSource20, fixedPrice: fixedPrice20, uniswapMarket: uniswapMarket20, isUniswapReversed: isUniswapReversed20, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 21) return TokenConfig({underlying: underlying21, symbolHash: symbolHash21, baseUnit: baseUnit21, priceSource: priceSource21, fixedPrice: fixedPrice21, uniswapMarket: uniswapMarket21, isUniswapReversed: isUniswapReversed21, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 22) return TokenConfig({underlying: underlying22, symbolHash: symbolHash22, baseUnit: baseUnit22, priceSource: priceSource22, fixedPrice: fixedPrice22, uniswapMarket: uniswapMarket22, isUniswapReversed: isUniswapReversed22, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 23) return TokenConfig({underlying: underlying23, symbolHash: symbolHash23, baseUnit: baseUnit23, priceSource: priceSource23, fixedPrice: fixedPrice23, uniswapMarket: uniswapMarket23, isUniswapReversed: isUniswapReversed23, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 24) return TokenConfig({underlying: underlying24, symbolHash: symbolHash24, baseUnit: baseUnit24, priceSource: priceSource24, fixedPrice: fixedPrice24, uniswapMarket: uniswapMarket24, isUniswapReversed: isUniswapReversed24, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 25) return TokenConfig({underlying: underlying25, symbolHash: symbolHash25, baseUnit: baseUnit25, priceSource: priceSource25, fixedPrice: fixedPrice25, uniswapMarket: uniswapMarket25, isUniswapReversed: isUniswapReversed25, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 26) return TokenConfig({underlying: underlying26, symbolHash: symbolHash26, baseUnit: baseUnit26, priceSource: priceSource26, fixedPrice: fixedPrice26, uniswapMarket: uniswapMarket26, isUniswapReversed: isUniswapReversed26, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 27) return TokenConfig({underlying: underlying27, symbolHash: symbolHash27, baseUnit: baseUnit27, priceSource: priceSource27, fixedPrice: fixedPrice27, uniswapMarket: uniswapMarket27, isUniswapReversed: isUniswapReversed27, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 28) return TokenConfig({underlying: underlying28, symbolHash: symbolHash28, baseUnit: baseUnit28, priceSource: priceSource28, fixedPrice: fixedPrice28, uniswapMarket: uniswapMarket28, isUniswapReversed: isUniswapReversed28, isDirectMarket: isDirectMarkets[i]});\\n        // if (i == 29) return TokenConfig({underlying: underlying29, symbolHash: symbolHash29, baseUnit: baseUnit29, priceSource: priceSource29, fixedPrice: fixedPrice29, uniswapMarket: uniswapMarket29, isUniswapReversed: isUniswapReversed29, isDirectMarket: isDirectMarkets[i]});\\n    }\\n\\n    /**\\n     * @notice Get the config for symbol\\n     * @param symbol The symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\\n    }\\n\\n    /**\\n     * @notice Get the config for the symbolHash\\n     * @param symbolHash The keccack256 of the symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\\n        uint index = getSymbolHashIndex(symbolHash);\\n        if (index != uint(-1)) {\\n            return getTokenConfig(index);\\n        }\\n\\n        revert(\\\"token config by symbol hash not found\\\");\\n    }\\n\\n    /**\\n     * @notice Get the config for an underlying asset\\n     * @param underlying The address of the underlying asset of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\\n        uint index = getUnderlyingIndex(underlying);\\n        if (index != uint(-1)) {\\n            return getTokenConfig(index);\\n        }\\n\\n        revert(\\\"token config by underlying not found\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Ola/Peripheral/PriceOracle/open-oracle/Uniswap/UniswapLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.7.6;\\n\\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << 112) / denominator);\\n    }\\n\\n    // decode a uq112x112 into a uint with 18 decimals of precision\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\\n        // instead, get close to:\\n        //  (x * 1e18) >> 112\\n        // without risk of overflowing, e.g.:\\n        //  (x) / 2 ** (112 - lg(1e18))\\n        return uint(self._x) / 5192296858534827;\\n    }\\n}\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2PairForStateReading(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2PairForStateReading(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2PairForStateReading(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2PairForStateReading {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/Ola/Peripheral/PriceOracle/open-oracle/OpenOracleData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title The Open Oracle Data Base Contract\\n * @author Compound Labs, Inc.\\n */\\ncontract OpenOracleData {\\n    /**\\n     * @notice The event emitted when a source writes to its storage\\n     */\\n    //event Write(address indexed source, <Key> indexed key, string kind, uint64 timestamp, <Value> value);\\n\\n    /**\\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\\n     * @param message The payload containing the timestamp, and (key, value) pairs\\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\\n     * @return The keys that were written\\n     */\\n    //function put(bytes calldata message, bytes calldata signature) external returns (<Key> memory);\\n\\n    /**\\n     * @notice Read a single key with a pre-defined type signature from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\\n     */\\n    //function get(address source, <Key> key) external view returns (uint, <Value>);\\n\\n    /**\\n     * @notice Recovers the source address which signed a message\\n     * @dev Comparing to a claimed address would add nothing,\\n     *  as the caller could simply perform the recover and claim that address.\\n     * @param message The data that was presumably signed\\n     * @param signature The fingerprint of the data + private key\\n     * @return The source address which signed the message, presumably\\n     */\\n    function source(bytes memory message, bytes memory signature) public view returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(message)));\\n        return ecrecover(hash, v, r, s);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract OpenOraclePriceData\",\"name\":\"priceData_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reporter_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"referenceAssetSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"usdBaseUnit_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"anchorToleranceMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"anchorPeriod_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirectMarket\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceScale\",\"type\":\"uint256\"}],\"internalType\":\"struct UniswapConfig.TokenConfig[]\",\"name\":\"configs\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"_autoPokingSymbols\",\"type\":\"string[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"}],\"name\":\"AnchorPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reporter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchor\",\"type\":\"uint256\"}],\"name\":\"PriceGuarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reporter\",\"type\":\"address\"}],\"name\":\"ReporterInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"UniswapWindowUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"anchorPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPokingSymbols\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBaseUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"symbols\",\"type\":\"string[]\"}],\"name\":\"freshenPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freshensAllPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllAutoPokingSymbols\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getAssetPriceUpdateTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getTokenConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirectMarket\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceScale\",\"type\":\"uint256\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getTokenConfigBySymbol\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirectMarket\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceScale\",\"type\":\"uint256\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"}],\"name\":\"getTokenConfigBySymbolHash\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirectMarket\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceScale\",\"type\":\"uint256\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getTokenConfigByUnderlying\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirectMarket\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceScale\",\"type\":\"uint256\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPriceUpdateTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"invalidateReporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerBoundAnchorRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"newObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oldObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"messages\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"string[]\",\"name\":\"symbols\",\"type\":\"string[]\"}],\"name\":\"postPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceData\",\"outputs\":[{\"internalType\":\"contract OpenOraclePriceData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pricesLastUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referenceAssetHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referenceAssetSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reporter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reporterInvalidated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"source\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperBoundAnchorRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdBaseUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapAnchoredView", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000030b8ccb18f9d30e0528212352d77e6d7712fa3e2000000000000000000000000fceadafab14d46e20144f48824d0c09b1a03f2bc00000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000002c68af0bb14000000000000000000000000000000000000000000000000000000000000000007080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000007200000000000000000000000000000000000000000000000000000000000000003424e4200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee3ed03c38e59dc60c7b69c2a4bf68f9214acd953252b5a90e8f5f59583e9bc3ae0000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000058f876857a02d6762e0101bb5c46a8c1ed44dc16000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000603c7f932ed1fc6575303d8fb018fdcbb0f39a950b89facb1a2c6f00c78330d3e775c00ebe0f0485b995c2e024ad890f56b33bff0000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f65c1c0478efde3c19b49ecbe7acc57bb6b1d713000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d23811058eb6e7967d9a00dc3886e75610c4abba87873ff534e19279601d65ebcbf55f60bd69a2558d361c99bc4543c1d690f4810000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d71710c21fba293eb12e0ca079fe37f50ad17d42000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f606bd19b1e61574ed625d9ea96c841d4e247a3225bca7788d8c23352e368ccd4774eb5b5fc3d40422de2c14e98631ab71f334150000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fc84b031a5221ced00b6470744af5e5da5710ddc0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000f424000000000000000000000000053e562b9b7e5e94b81f10e96ee70ad06df3d2657f86c22a1408065a9abd23455416b8809c13c500c78c6c5199844d6915e03dd690000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036ae10a4d16311959b607ee98bc4a8a653a33b1f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}