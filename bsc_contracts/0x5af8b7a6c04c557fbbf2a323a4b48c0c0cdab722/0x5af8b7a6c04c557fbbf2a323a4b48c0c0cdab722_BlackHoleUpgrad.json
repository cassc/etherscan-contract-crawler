{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-11-12\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\nlibrary DateTime {\r\n    /*\r\n     *  Date and Time utilities for ethereum contracts\r\n     *\r\n     */\r\n\r\n    function getNowDateTime() public view returns (uint32) {\r\n        uint256 ts = block.timestamp + 8 hours;\r\n        return uint32(ts / 1 days);\r\n    }\r\n\r\n    function tsToDateTime(uint256 ts) public pure returns (uint32) {\r\n        return uint32((ts + 8 hours) / 1 days);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(uint256 amount) external returns (uint256);\r\n\r\n    function destroy(uint256 amount) external returns (uint256);\r\n\r\n    function getPrice() external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PublicReward {\r\n    constructor(address USDT, address HD) {\r\n        IERC20(USDT).approve(msg.sender, ~uint256(0));\r\n        IERC20(HD).approve(msg.sender, ~uint256(0));\r\n    }\r\n}\r\n\r\ncontract BlackHoleUpgrad is Ownable, ReentrancyGuard {\r\n    struct User {\r\n        Team team;\r\n        uint8 level; // \u7b49\u7ea7\r\n        uint64 latestLevelPowerTs; // \u6700\u65b0\u66f4\u65b0\u65f6\u95f4\r\n        uint64 latestLPPowerTs; // \u6700\u65b0\u66f4\u65b0\u65f6\u95f4\r\n        uint64 latestClaimTs; // \u6700\u65b0\u9886\u53d6\u65f6\u95f4\r\n        uint256 claimedHDReward; // \u5df2\u9886\u53d6HD\u5956\u52b1\r\n        uint256 claimedUSDTReward; // \u5df2\u9886\u53d6USDT\u5956\u52b1\r\n        uint256 bourtUSDT; // \u5df2\u8d2d\u4e70USDT\u6570\r\n        mapping(uint32 => uint256) teamReward; // \u56e2\u961fBH\u5956\u52b1\r\n        mapping(uint32 => uint256) lpPower; // lp\u7b97\u529b\r\n        mapping(uint32 => uint256) levelPower; // \u7b49\u7ea7\u7b97\u529b\r\n        mapping(uint32 => uint256) dailyTransaction; // \u6bcf\u65e5\u4ea4\u6613\u989d\r\n    }\r\n\r\n    struct Team {\r\n        address add;\r\n        address[] redirects; // \u76f4\u63a8\r\n        address left; // \u5de6\u8282\u70b9\r\n        address right; //  \u53f3\u8282\u70b9\r\n        address middle; //  \u4e2d\u95f4\u8282\u70b9\r\n        address top; // \u7236\u8282\u70b9\r\n        address leader; // \u9886\u5bfc\r\n        uint16 floor; // \u6240\u5728\u5c42\r\n        uint16 reachFloor; // \u6700\u4e0b\u9762\u6ee1\u5c42\u7684\u8be5\u5c42\u5c42\u6570\r\n        uint32 nextCount; // \u76f4\u63a5\u5b50\u8282\u70b9\u6570\r\n        uint32 childCount; // \u5b50\u8282\u70b9\u6570\r\n        uint32 index; // \u6240\u5728\u5c42\u7684\u5e8f\u53f7\r\n        uint32 latestIndex; // \u4e0a\u6b21\u6ed1\u843d\u6240\u5728\u7236\u8282\u70b9\u5e8f\u53f7\r\n        uint64 initTime; // \u521d\u59cb\u5316\u65f6\u95f4\r\n        mapping(uint32 => mapping(uint16 => uint32)) floorChildInfo; // \u4e0b\u9762\u6bcf\u5c42\u7684\u76f4\u63a5\u5b50\u8282\u4fe1\u606f\r\n    }\r\n\r\n    IERC20 USDT;\r\n    IERC20 HD;\r\n\r\n    PublicReward public publicReward;\r\n\r\n    ISwapRouter router;\r\n    IUniswapV2Pair pair;\r\n    mapping(uint256 => mapping(uint256 => address)) public floorUsers;\r\n    mapping(address => User) users;\r\n    mapping(bytes32 => bool) verifiedMessage;\r\n\r\n    // \u6bcf\u4e00\u7ea7\u6240\u9700\u8981\u7684\u6295\u8d44\u989d\r\n    uint256[] public levelPrice;\r\n\r\n    uint256[] public levelUSDTLimit;\r\n\r\n    uint256 latestdailyTotalLevelPowerTs;\r\n    uint256 latestdailyTotalLPPowerTs;\r\n    mapping(uint256 => uint256) public dailyTotalLPPower;\r\n    mapping(uint256 => uint256) public dailyTotalLevelPower;\r\n    mapping(uint256 => uint256) public dailyPublicUSDTReward;\r\n    mapping(uint256 => uint256) public dailyPublicHDReward;\r\n    mapping(uint256 => uint256) public dailyLPPowerValue;\r\n\r\n    mapping(uint256 => bool) public isPublicRewardEveryDay;\r\n    uint256 public publicRewardEveryDayCount;\r\n    uint256 public publicRewardEveryDayBase;\r\n    // \u6bcf\u65e5\u4ea4\u6613\u989d\u4e0a\u9650\r\n    uint256 dailyTransactionLimit;\r\n\r\n    // must\r\n    address private delegateContract;\r\n    address private delegateUpgradContract;\r\n    address deadAddress;\r\n\r\n    function _publicRewardEveryday(uint256 nowDate) private {\r\n        if (isPublicRewardEveryDay[nowDate]) {\r\n            return;\r\n        }\r\n        publicRewardEveryDayCount += 1;\r\n        isPublicRewardEveryDay[nowDate] = true;\r\n        uint256 amount = (publicRewardEveryDayBase * 52) / 10000;\r\n        publicRewardEveryDayBase = publicRewardEveryDayBase - amount;\r\n        (, uint256 HDTotalBalance) = _getPairTokenAmount();\r\n        uint256 LPAmount;\r\n        if (amount > HDTotalBalance) {\r\n            LPAmount = pair.balanceOf(address(this)) / 2;\r\n        } else {\r\n            LPAmount = (pair.totalSupply() * amount) / HDTotalBalance;\r\n        }\r\n        (uint USDTAmount, uint HDAmount) = router.removeLiquidity(\r\n            address(USDT),\r\n            address(HD),\r\n            LPAmount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint256 _toLP = (USDTAmount * 666) / 1000;\r\n        uint256 _toBuy = USDTAmount - _toLP;\r\n        _addLiquidity(_toLP);\r\n        HDAmount += _buyHD(_toBuy);\r\n        _addPubilcHDReward(HDAmount, nowDate);\r\n    }\r\n\r\n    function _invite(address add, address _leader) private {\r\n        (bool success, ) = delegateContract.delegatecall(\r\n            abi.encodeWithSignature(\r\n                \"inviteProxy(address,address)\",\r\n                add,\r\n                _leader\r\n            )\r\n        );\r\n        require(success, \"invite failed\");\r\n    }\r\n\r\n    function _subUserLPPower(User storage user, uint256 power) private {\r\n        uint32 nowDateTime = DateTime.getNowDateTime();\r\n        _updateUserLPPowerBefore(user, nowDateTime);\r\n        if (user.lpPower[nowDateTime] > power) {\r\n            user.lpPower[nowDateTime] -= power;\r\n        } else {\r\n            user.lpPower[nowDateTime] = 0;\r\n        }\r\n    }\r\n\r\n    function _addUserLPPower(User storage user, uint256 power) private {\r\n        uint32 nowDateTime = DateTime.getNowDateTime();\r\n        _updateUserLPPowerBefore(user, nowDateTime);\r\n        user.lpPower[nowDateTime] += power;\r\n    }\r\n\r\n    function _addUserLevelPower(User storage user, uint256 power) private {\r\n        uint32 nowDateTime = DateTime.getNowDateTime();\r\n        _updateUserLevelPowerBefore(user, nowDateTime);\r\n        user.levelPower[nowDateTime] += power;\r\n    }\r\n\r\n    function _subUserLevelPower(User storage user, uint256 power) private {\r\n        uint32 nowDateTime = DateTime.getNowDateTime();\r\n        _updateUserLevelPowerBefore(user, nowDateTime);\r\n        if (user.levelPower[nowDateTime] > power) {\r\n            user.levelPower[nowDateTime] -= power;\r\n        } else {\r\n            user.levelPower[nowDateTime] = 0;\r\n        }\r\n    }\r\n\r\n    function _updateUserLPPowerBefore(\r\n        User storage user,\r\n        uint256 nowDateTime\r\n    ) private {\r\n        _updateDailyTotalLPPowerBefore(nowDateTime);\r\n        uint32 latestday = DateTime.tsToDateTime(user.latestLPPowerTs);\r\n        uint256 latestTs2 = user.latestLPPowerTs + 1 days;\r\n        uint32 latestday2 = DateTime.tsToDateTime(latestTs2);\r\n        uint256 yesterday = DateTime.tsToDateTime(block.timestamp - 1 days);\r\n        uint256 value = _updateLPPowerValue(yesterday);\r\n        if (latestday < nowDateTime && user.lpPower[latestday] > 0) {\r\n            (uint256 _totalLPReward, ) = _getPublicRewardAmountByDate(\r\n                user.team.add,\r\n                latestday\r\n            );\r\n            while (user.lpPower[latestday2] == 0 && latestday2 <= nowDateTime) {\r\n                if (dailyLPPowerValue[latestday] == 0) {\r\n                    dailyLPPowerValue[latestday] = value;\r\n                }\r\n                value = dailyLPPowerValue[latestday];\r\n\r\n                if ((_totalLPReward * value) / 1e18 > user.lpPower[latestday]) {\r\n                    user.lpPower[latestday2] = 0;\r\n                } else {\r\n                    user.lpPower[latestday2] =\r\n                        user.lpPower[latestday] -\r\n                        ((_totalLPReward * value) / 1e18);\r\n                }\r\n                latestday = latestday2;\r\n                (, _totalLPReward) = _getPublicRewardAmountByDate(\r\n                    user.team.add,\r\n                    latestday\r\n                );\r\n                latestTs2 += 1 days;\r\n                latestday2 = DateTime.tsToDateTime(latestTs2);\r\n            }\r\n        }\r\n        if (\r\n            DateTime.tsToDateTime(block.timestamp) >\r\n            DateTime.tsToDateTime(user.latestLPPowerTs)\r\n        ) {\r\n            user.latestLPPowerTs = _getTs();\r\n        }\r\n    }\r\n\r\n    function _updateUserLevelPowerBefore(\r\n        User storage user,\r\n        uint256 nowDateTime\r\n    ) private {\r\n        _updateDailyTotalLevelPowerBefore(nowDateTime);\r\n        uint32 latestday = DateTime.tsToDateTime(user.latestLevelPowerTs);\r\n        uint256 latestTs2 = user.latestLevelPowerTs + 1 days;\r\n        uint32 latestday2 = DateTime.tsToDateTime(latestTs2);\r\n        if (latestday < nowDateTime && user.levelPower[latestday] > 0) {\r\n            (, uint256 _totalLevelReward) = _getPublicRewardAmountByDate(\r\n                user.team.add,\r\n                latestday\r\n            );\r\n            while (\r\n                user.levelPower[latestday2] == 0 && latestday2 <= nowDateTime\r\n            ) {\r\n                if (_totalLevelReward > user.levelPower[latestday]) {\r\n                    user.levelPower[latestday2] = 0;\r\n                } else {\r\n                    user.levelPower[latestday2] =\r\n                        user.levelPower[latestday] -\r\n                        _totalLevelReward;\r\n                }\r\n\r\n                latestday = latestday2;\r\n                (, _totalLevelReward) = _getPublicRewardAmountByDate(\r\n                    user.team.add,\r\n                    latestday\r\n                );\r\n                latestTs2 += 1 days;\r\n                latestday2 = DateTime.tsToDateTime(latestTs2);\r\n            }\r\n        }\r\n        if (\r\n            DateTime.tsToDateTime(block.timestamp) >\r\n            DateTime.tsToDateTime(user.latestLevelPowerTs)\r\n        ) {\r\n            user.latestLevelPowerTs = _getTs();\r\n        }\r\n    }\r\n\r\n    function _updateDailyTotalLPPowerBefore(uint256 nowDateTime) private {\r\n        uint256 latestday = DateTime.tsToDateTime(latestdailyTotalLPPowerTs);\r\n        uint256 latestTs2 = latestdailyTotalLPPowerTs + 1 days;\r\n        uint256 latestday2 = DateTime.tsToDateTime(latestTs2);\r\n        uint256 yesterday = DateTime.tsToDateTime(block.timestamp - 1 days);\r\n        uint256 value = _updateLPPowerValue(yesterday);\r\n        if (latestday < nowDateTime && dailyTotalLPPower[latestday] > 0) {\r\n            while (\r\n                dailyTotalLPPower[latestday2] == 0 && latestday2 <= nowDateTime\r\n            ) {\r\n                if (dailyLPPowerValue[latestday] == 0) {\r\n                    dailyLPPowerValue[latestday] = value;\r\n                }\r\n                value = dailyLPPowerValue[latestday];\r\n                if (\r\n                    (dailyPublicHDReward[latestday] * value) / 1e18 >\r\n                    dailyTotalLPPower[latestday]\r\n                ) {\r\n                    dailyTotalLPPower[latestday2] = 0;\r\n                } else {\r\n                    dailyTotalLPPower[latestday2] =\r\n                        dailyTotalLPPower[latestday] -\r\n                        ((dailyPublicHDReward[latestday] * value) / 1e18);\r\n                }\r\n                latestday = latestday2;\r\n                latestTs2 += 1 days;\r\n                latestday2 = DateTime.tsToDateTime(latestTs2);\r\n            }\r\n        }\r\n        if (\r\n            DateTime.tsToDateTime(block.timestamp) >\r\n            DateTime.tsToDateTime(latestdailyTotalLPPowerTs)\r\n        ) {\r\n            latestdailyTotalLPPowerTs = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function _updateDailyTotalLevelPowerBefore(uint256 nowDateTime) private {\r\n        uint256 latestday = DateTime.tsToDateTime(latestdailyTotalLevelPowerTs);\r\n        uint256 latestTs2 = latestdailyTotalLevelPowerTs + 1 days;\r\n        uint256 latestday2 = DateTime.tsToDateTime(latestTs2);\r\n\r\n        if (latestday < nowDateTime && dailyTotalLevelPower[latestday] > 0) {\r\n            while (\r\n                dailyTotalLevelPower[latestday2] == 0 &&\r\n                latestday2 <= nowDateTime\r\n            ) {\r\n                if (\r\n                    dailyPublicUSDTReward[latestday] <\r\n                    dailyTotalLevelPower[latestday]\r\n                ) {\r\n                    dailyTotalLevelPower[latestday2] =\r\n                        dailyTotalLevelPower[latestday] -\r\n                        dailyPublicUSDTReward[latestday];\r\n                } else {\r\n                    dailyTotalLevelPower[latestday2] = 0;\r\n                }\r\n                latestday = latestday2;\r\n                latestTs2 += 1 days;\r\n                latestday2 = DateTime.tsToDateTime(latestTs2);\r\n            }\r\n        }\r\n        if (\r\n            DateTime.tsToDateTime(block.timestamp) >\r\n            DateTime.tsToDateTime(latestdailyTotalLevelPowerTs)\r\n        ) {\r\n            latestdailyTotalLevelPowerTs = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function _updateLPPowerValue(uint256 dateTime) private returns (uint256) {\r\n        if (dailyLPPowerValue[dateTime] == 0) {\r\n            uint256 value = _calculateLPPowerValue();\r\n            dailyLPPowerValue[dateTime] = value;\r\n        }\r\n        return dailyLPPowerValue[dateTime];\r\n    }\r\n\r\n    function _addDailyTotalLPPower(uint256 power) private {\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        _updateDailyTotalLPPowerBefore(nowDateTime);\r\n        dailyTotalLPPower[nowDateTime] += power;\r\n    }\r\n\r\n    function _subDailyTotalLPPower(uint256 power) private {\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        _updateDailyTotalLPPowerBefore(nowDateTime);\r\n        dailyTotalLPPower[nowDateTime] -= power;\r\n    }\r\n\r\n    function _addDailyTotalLevelPower(uint256 power) private {\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        _updateDailyTotalLevelPowerBefore(nowDateTime);\r\n        dailyTotalLevelPower[nowDateTime] += power;\r\n    }\r\n\r\n    function _subDailyTotalLevelPower(uint256 power) private {\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        _updateDailyTotalLevelPowerBefore(nowDateTime);\r\n        dailyTotalLevelPower[nowDateTime] -= power;\r\n    }\r\n\r\n    function _getUserPower(\r\n        User storage user\r\n    ) private view returns (uint256 lpPower, uint256 levelPower) {\r\n        uint32 latestDate1 = DateTime.tsToDateTime(user.latestLPPowerTs);\r\n        uint32 latestDate2 = DateTime.tsToDateTime(user.latestLevelPowerTs);\r\n        return (user.lpPower[latestDate1], user.levelPower[latestDate2]);\r\n    }\r\n\r\n    function _buyHD(uint256 amount) private returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(HD);\r\n        uint256 HDBalance = HD.balanceOf(address(this));\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        return HD.balanceOf(address(this)) - HDBalance;\r\n    }\r\n\r\n    function _getUSDTOut(uint256 HDAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(HD);\r\n        path[1] = address(USDT);\r\n        uint256[] memory amounts = router.getAmountsOut(HDAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _getHDOut(uint256 USDTAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(HD);\r\n        uint256[] memory amounts = router.getAmountsOut(USDTAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _addLiquidity(uint256 USDTAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(HD);\r\n        uint256 HDAmount = _getHDOut(USDTAmount) * 2;\r\n        HD.mint(HDAmount);\r\n        (, uint256 b, ) = router.addLiquidity(\r\n            address(USDT),\r\n            address(HD),\r\n            USDTAmount,\r\n            ~uint256(0),\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if (b < HDAmount) HD.destroy(HDAmount - b);\r\n    }\r\n\r\n    function _removeLiquidity(uint256 liquidity) private returns (uint, uint) {\r\n        (uint a, uint b) = router.removeLiquidity(\r\n            address(USDT),\r\n            address(HD),\r\n            liquidity,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        HD.destroy(b);\r\n        return (a, b);\r\n    }\r\n\r\n    function _addPubilcUSDTReward(uint256 amount, uint256 nowDateTime) private {\r\n        dailyPublicUSDTReward[nowDateTime] += amount;\r\n        require(USDT.transfer(address(publicReward), amount), \"transfer error\");\r\n    }\r\n\r\n    function _addPubilcHDReward(uint256 amount, uint256 nowDateTime) private {\r\n        dailyPublicHDReward[nowDateTime] += amount;\r\n        require(HD.transfer(address(publicReward), amount), \"transfer error\");\r\n    }\r\n\r\n    function _getTs() private view returns (uint64) {\r\n        return uint64(block.timestamp);\r\n    }\r\n\r\n    function _income(\r\n        uint256 price,\r\n        address leader,\r\n        uint256 nowDateTime\r\n    ) private {\r\n        User storage user = users[msg.sender];\r\n        uint256 _totalLevelPower;\r\n        uint256 _totalLPPower;\r\n\r\n        uint256 publicRewardAmount = (price) / 10; // \u5168\u7f51\r\n        _addPubilcUSDTReward(publicRewardAmount, nowDateTime);\r\n        uint256 buyAmount = (price * 304) / 1000;\r\n        uint256 teamHDAmount = _buyHD(buyAmount);\r\n        uint256 addLPAmount = price - publicRewardAmount - buyAmount;\r\n        _addLiquidity(addLPAmount);\r\n        (_totalLPPower, _totalLevelPower) = _teamIncome(\r\n            leader,\r\n            teamHDAmount,\r\n            price,\r\n            user.level,\r\n            nowDateTime\r\n        );\r\n        _totalLevelPower = (price - _totalLevelPower);\r\n        _totalLPPower += price;\r\n        _addDailyTotalLPPower(_totalLPPower);\r\n        _addDailyTotalLevelPower(_totalLevelPower);\r\n    }\r\n\r\n    struct _Res {\r\n        uint256 totalLPPower;\r\n        uint256 totalLevelPower;\r\n        uint256 addPubilcHDRewardAmount;\r\n    }\r\n\r\n    function _teamIncome(\r\n        address leader,\r\n        uint256 teamHDAmount,\r\n        uint256 price,\r\n        uint256 userLevel,\r\n        uint256 nowDateTime\r\n    ) private returns (uint256, uint256) {\r\n        User storage leaderUser = users[leader];\r\n        uint256 leaderReward = (teamHDAmount * 2) / 3;\r\n        uint256 teamOtherReward = (teamHDAmount - leaderReward - 10) / 10;\r\n        uint256 addPubilcHDRewardAmount;\r\n        uint256 _totalLPPower;\r\n        uint256 _totalLevelPower;\r\n        if (leaderUser.level >= userLevel) {\r\n            (addPubilcHDRewardAmount, _totalLevelPower) = _levelPowerIncome(\r\n                leaderUser,\r\n                leaderReward,\r\n                _getUSDTOut(leaderReward),\r\n                uint32(nowDateTime)\r\n            );\r\n            uint256 leaderLPPowerAmount = (price * 3) / 10;\r\n            _addUserLPPower(leaderUser, leaderLPPowerAmount);\r\n            _totalLPPower = leaderLPPowerAmount;\r\n        } else {\r\n            addPubilcHDRewardAmount = leaderReward;\r\n        }\r\n        _Res memory res = _teamOtherIncome(msg.sender, price, teamOtherReward);\r\n        _totalLPPower += res.totalLPPower;\r\n        _totalLevelPower += res.totalLevelPower;\r\n        addPubilcHDRewardAmount += res.addPubilcHDRewardAmount;\r\n        if (addPubilcHDRewardAmount > 0) {\r\n            _addPubilcHDReward(addPubilcHDRewardAmount, nowDateTime);\r\n        }\r\n        return (_totalLPPower, _totalLevelPower);\r\n    }\r\n\r\n    function _teamOtherIncome(\r\n        address _user,\r\n        uint256 price,\r\n        uint256 teamOtherReward\r\n    ) private returns (_Res memory) {\r\n        // ten level\r\n        _Res memory res;\r\n        uint i;\r\n        User storage user = users[_user];\r\n        uint256 level = user.level;\r\n        // \u70e7\u4f24\u6570\r\n        uint256 USDTOut = _getUSDTOut(teamOtherReward);\r\n        uint32 nowDateTime = DateTime.getNowDateTime();\r\n        while (user.team.top != address(0) && i < 10) {\r\n            user = users[user.team.top];\r\n            if (user.level >= level) {\r\n                (\r\n                    uint256 __addPubilcHDRewardAmount,\r\n                    uint256 __totalLevelPower\r\n                ) = _levelPowerIncome(\r\n                        user,\r\n                        teamOtherReward,\r\n                        USDTOut,\r\n                        nowDateTime\r\n                    );\r\n                res.addPubilcHDRewardAmount += __addPubilcHDRewardAmount;\r\n                res.totalLevelPower += __totalLevelPower;\r\n                _addUserLPPower(user, (price * 2) / 100);\r\n                res.totalLPPower += (price * 2) / 100;\r\n            } else {\r\n                res.addPubilcHDRewardAmount += teamOtherReward;\r\n            }\r\n            ++i;\r\n        }\r\n        if (i < 10) {\r\n            res.addPubilcHDRewardAmount += teamOtherReward * (10 - i);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function _calculateLPAmount(\r\n        uint256 HDamount\r\n    ) private view returns (uint256, uint256) {\r\n        uint256 expectedUSDTAmount = _getUSDTOut(HDamount);\r\n        uint256 lpTotalSupply = pair.totalSupply();\r\n        (uint256 USDTTotalBalance, ) = _getPairTokenAmount();\r\n        uint256 LPAmount = (lpTotalSupply * expectedUSDTAmount) /\r\n            USDTTotalBalance;\r\n        return (LPAmount, expectedUSDTAmount);\r\n    }\r\n\r\n    function _getPairTokenAmount()\r\n        private\r\n        view\r\n        returns (uint256 USDTTotalBalance, uint256 HDTotalBalance)\r\n    {\r\n        (uint256 amount0, uint256 amount1, ) = pair.getReserves();\r\n        address token0 = pair.token0();\r\n        if (token0 == address(USDT)) {\r\n            USDTTotalBalance = amount0;\r\n            HDTotalBalance = amount1;\r\n        } else {\r\n            USDTTotalBalance = amount1;\r\n            HDTotalBalance = amount0;\r\n        }\r\n    }\r\n\r\n    function _calculateLPPowerValue() private view returns (uint256) {\r\n        return _getUSDTOut(1 * 1e18) / 2;\r\n    }\r\n\r\n    function _levelPowerIncome(\r\n        User storage user,\r\n        uint256 amount,\r\n        uint256 USDTOut,\r\n        uint32 nowDateTime\r\n    ) private returns (uint256, uint256) {\r\n        uint256 _totalLevelPower;\r\n        uint256 addPubilcHDRewardAmount;\r\n        (, uint256 levelPower) = _getUserPower(user);\r\n        //token\r\n        if (USDTOut >= levelPower) {\r\n            uint256 HDOut;\r\n            if (levelPower > 1e18) {\r\n                HDOut = _getHDOut(levelPower);\r\n            }\r\n            if (HDOut < amount) {\r\n                addPubilcHDRewardAmount = amount - HDOut;\r\n\r\n                amount = HDOut;\r\n            }\r\n            _subUserLevelPower(user, levelPower);\r\n            _totalLevelPower = levelPower;\r\n        } else {\r\n            _subUserLevelPower(user, USDTOut);\r\n            _totalLevelPower = USDTOut;\r\n        }\r\n        if (amount > 0) {\r\n            user.teamReward[nowDateTime] += amount;\r\n            require(HD.transfer(user.team.add, amount), \"transfer error\");\r\n        }\r\n        return (addPubilcHDRewardAmount, _totalLevelPower);\r\n    }\r\n\r\n    function _buy(uint256 amount) private {\r\n        User storage user = users[msg.sender];\r\n        uint256 userLevel = user.level;\r\n\r\n        require(user.team.initTime > 0, \"user not exist\");\r\n        require(userLevel >= 3, \"level error\");\r\n        uint256 usdtBalance = USDT.balanceOf(msg.sender);\r\n        require(usdtBalance >= amount, \"balance error\");\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n        user.bourtUSDT += amount;\r\n\r\n        require(\r\n            user.bourtUSDT <= levelUSDTLimit[userLevel] * 10 ** USDT.decimals(),\r\n            \"bourtUSDT error\"\r\n        );\r\n\r\n        uint32 nowDateTime = DateTime.getNowDateTime();\r\n        user.dailyTransaction[nowDateTime] += amount;\r\n\r\n        require(\r\n            user.dailyTransaction[nowDateTime] <=\r\n                dailyTransactionLimit * 10 ** USDT.decimals(),\r\n            \"dailyTransaction error\"\r\n        );\r\n\r\n        uint256 addLPAmount = (amount * 666) / 1000;\r\n        _addLiquidity(addLPAmount);\r\n        uint256 buyAmount = amount - addLPAmount;\r\n\r\n        uint256 HDAmount = _buyHD(buyAmount);\r\n        uint256 toUserAmount = (HDAmount * 8982) / 10000;\r\n        require(HD.transfer(msg.sender, toUserAmount), \"transfer error\");\r\n        _addPubilcHDReward(HDAmount - toUserAmount, nowDateTime);\r\n        uint256 _totalLPPower;\r\n        uint256 toUserLPPowerAmount = ((amount * 7) / 10);\r\n        _totalLPPower += toUserLPPowerAmount;\r\n        _addUserLPPower(user, toUserLPPowerAmount);\r\n\r\n        User storage leader = users[user.team.leader];\r\n        if (leader.level >= userLevel) {\r\n            uint256 leaderLPPowerAmount = ((amount * 3) / 10);\r\n            _totalLPPower += leaderLPPowerAmount;\r\n            _addUserLPPower(leader, leaderLPPowerAmount);\r\n        }\r\n        uint256 otherTeamAmount = (amount * 1) / 10;\r\n        uint i;\r\n        while (user.team.top != address(0) && i < 10) {\r\n            user = users[user.team.top];\r\n            if (user.level >= userLevel) {\r\n                _totalLPPower += otherTeamAmount;\r\n                _addUserLPPower(user, otherTeamAmount);\r\n            }\r\n            ++i;\r\n        }\r\n        _addDailyTotalLPPower(_totalLPPower);\r\n    }\r\n\r\n    function _sell(uint256 amount) private returns (uint256) {\r\n        User storage user = users[msg.sender];\r\n        require(user.team.initTime > 0, \"user not exist\");\r\n        uint256 HDBalance = HD.balanceOf(msg.sender);\r\n        require(HDBalance >= amount, \"balance error\");\r\n        require(user.level >= 1, \"level error\");\r\n        require(\r\n            HD.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n        HD.destroy(amount);\r\n        (uint256 LPAmount, uint256 expectedUSDTAmount) = _calculateLPAmount(\r\n            amount\r\n        );\r\n        (uint256 USDTAmount, ) = _removeLiquidity(LPAmount);\r\n        if (USDTAmount > expectedUSDTAmount) {\r\n            USDTAmount = expectedUSDTAmount;\r\n        }\r\n        uint32 nowDateTime = DateTime.getNowDateTime();\r\n\r\n        user.dailyTransaction[nowDateTime] += USDTAmount;\r\n        require(\r\n            user.dailyTransaction[nowDateTime] <=\r\n                dailyTransactionLimit * 10 ** USDT.decimals(),\r\n            \"dailyTransaction error\"\r\n        );\r\n        uint256 USDTToUserAmount = (USDTAmount * 85) / 100;\r\n        require(USDT.transfer(msg.sender, USDTToUserAmount), \"transfer error\");\r\n        uint256 USDTToBuy = USDTAmount - USDTToUserAmount;\r\n        uint256 _toLP = (USDTToBuy * 666) / 1000;\r\n        uint256 _toBuy = USDTToBuy - _toLP;\r\n        _addLiquidity(_toLP);\r\n        uint256 HDAmount = _buyHD(_toBuy);\r\n        _addPubilcHDReward(HDAmount, nowDateTime);\r\n        _publicRewardEveryday(nowDateTime);\r\n        return USDTToUserAmount;\r\n    }\r\n\r\n    function _getPublicRewardAmountByDate(\r\n        address _user,\r\n        uint32 dateTime\r\n    ) private view returns (uint256 _totalLPReward, uint256 _totalLevelReward) {\r\n        User storage user = users[_user];\r\n        _totalLPReward = (\r\n            dailyTotalLPPower[dateTime] == 0\r\n                ? 0\r\n                : ((dailyPublicHDReward[dateTime] * user.lpPower[dateTime]) /\r\n                    dailyTotalLPPower[dateTime])\r\n        );\r\n        _totalLevelReward = dailyTotalLevelPower[dateTime] == 0\r\n            ? 0\r\n            : ((dailyPublicUSDTReward[dateTime] * user.levelPower[dateTime]) /\r\n                dailyTotalLevelPower[dateTime]);\r\n    }\r\n\r\n    function _getPublicRewardAmount(\r\n        address _user\r\n    ) private view returns (uint256 _totalLPReward, uint256 _totalLevelReward) {\r\n        User storage user = users[_user];\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        uint256 latestClaimday = DateTime.tsToDateTime(user.latestClaimTs);\r\n        if (nowDateTime == latestClaimday) {\r\n            return (0, 0);\r\n        }\r\n        uint256 ts;\r\n        if (user.latestClaimTs == 0) {\r\n            ts = user.team.initTime;\r\n        } else {\r\n            ts = user.latestClaimTs;\r\n        }\r\n        uint32 dateTime = DateTime.tsToDateTime(ts);\r\n\r\n        while (dateTime < nowDateTime) {\r\n            _totalLPReward += (\r\n                dailyTotalLPPower[dateTime] == 0\r\n                    ? 0\r\n                    : ((dailyPublicHDReward[dateTime] *\r\n                        user.lpPower[dateTime]) / dailyTotalLPPower[dateTime])\r\n            );\r\n\r\n            _totalLevelReward += dailyTotalLevelPower[dateTime] == 0\r\n                ? 0\r\n                : ((dailyPublicUSDTReward[dateTime] *\r\n                    user.levelPower[dateTime]) /\r\n                    dailyTotalLevelPower[dateTime]);\r\n            ts += 1 days;\r\n            dateTime = DateTime.tsToDateTime(ts);\r\n        }\r\n        return (_totalLPReward, _totalLevelReward);\r\n    }\r\n\r\n    function buy(uint256 amount) public {\r\n        _buy(amount);\r\n    }\r\n\r\n    function sell(uint256 amount) public returns (uint256) {\r\n        return _sell(amount);\r\n    }\r\n\r\n    // \u5347\u7ea7\r\n    function upgrade() public {\r\n        User storage user = users[msg.sender];\r\n        require(user.level < 12, \"level error\");\r\n        address leader = user.team.leader;\r\n        uint256 usdtBalance = USDT.balanceOf(msg.sender);\r\n        uint256 price = levelPrice[user.level + 1] * 10 ** USDT.decimals();\r\n        require(usdtBalance >= price, \"balance error\");\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), price),\r\n            \"transfer error\"\r\n        );\r\n        user.level += 1;\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        // _updateDailyTotalLevelPowerBefore(nowDateTime);\r\n        // _updateDailyTotalLPPowerBefore(nowDateTime);\r\n        _addUserLevelPower(user, price);\r\n        _addUserLPPower(user, price);\r\n        _income(price, leader, nowDateTime);\r\n        _publicRewardEveryday(nowDateTime);\r\n    }\r\n\r\n    function claim() public {\r\n        User storage user = users[msg.sender];\r\n        require(user.team.initTime > 0, \"user not exist\");\r\n        uint256 _totalLPReward;\r\n        uint256 _totalLevelReward;\r\n        uint256 nowDateTime = DateTime.getNowDateTime();\r\n        _updateUserLPPowerBefore(user, nowDateTime);\r\n        _updateUserLevelPowerBefore(user, nowDateTime);\r\n        (_totalLPReward, _totalLevelReward) = _getPublicRewardAmount(\r\n            msg.sender\r\n        );\r\n        user.latestClaimTs = _getTs();\r\n        if (_totalLPReward > 0) {\r\n            user.claimedHDReward += _totalLPReward;\r\n            HD.transferFrom(\r\n                address(publicReward),\r\n                address(this),\r\n                _totalLPReward\r\n            );\r\n            HD.transfer(msg.sender, _totalLPReward);\r\n        }\r\n        if (_totalLevelReward > 0) {\r\n            user.claimedUSDTReward += _totalLevelReward;\r\n            USDT.transferFrom(\r\n                address(publicReward),\r\n                msg.sender,\r\n                _totalLevelReward\r\n            );\r\n        }\r\n        _publicRewardEveryday(nowDateTime);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyLPPowerValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyPublicHDReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyPublicUSDTReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalLPPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalLevelPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"floorUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPublicRewardEveryDay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelUSDTLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicReward\",\"outputs\":[{\"internalType\":\"contract PublicReward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicRewardEveryDayBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicRewardEveryDayCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlackHoleUpgrad", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "DateTime:71d9865bb10b2f66575e90d3faac132c7597ea24", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5eb953721dbe15ac49344804a8687b5cd0e75ae538a736cdf000a350c2bbf90b"}