{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\ncontract Stake is Ownable {\r\n    using SafeMath for uint256;\r\n    address public tnrToken;\r\n\r\n    struct RewardData {\r\n        uint256 rewardRate3;\r\n        uint256 rewardRate6;\r\n        uint256 rewardRate12;\r\n        uint256 divisorRate;\r\n        uint8 term0;\r\n        uint8 term1;\r\n        uint8 term2;\r\n        address owner;\r\n        uint256 commission;\r\n    }\r\n\r\n    struct StakerData {\r\n        address tokenAddress;\r\n        uint256 startStaking;\r\n        uint256 endStaking;\r\n        uint256 totalStaked;\r\n        uint256 reward;\r\n        uint256 rate;\r\n        uint256 rateDiv;\r\n    }\r\n\r\n    mapping(address => StakerData[]) private stakers;\r\n    mapping(address => RewardData) public reward;\r\n    mapping(address => bool) public stakingTokens;\r\n\r\n    mapping(address => uint256) private totalReward;\r\n\r\n    event TokensStaked(address indexed user, uint256 amount, uint256 duration);\r\n    event TokensUnstaked(address indexed user, uint256 amount);\r\n\r\n    constructor(\r\n        address _token, \r\n\r\n        address _tnrToken, \r\n        uint256 _commission\r\n    ) {\r\n        stakingTokens[_token] = true;\r\n        stakingTokens[_tnrToken] = true;\r\n\r\n        tnrToken = _tnrToken;\r\n\r\n        reward[_token] = RewardData(\r\n            6,\r\n            6,\r\n            6,\r\n            100,\r\n            2,\r\n            3, \r\n            6,\r\n            msg.sender,\r\n            _commission\r\n        );\r\n\r\n        reward[_tnrToken] = RewardData(\r\n            10,\r\n            12,\r\n            14,\r\n            100,\r\n            3,\r\n            6, \r\n            12,\r\n            msg.sender,\r\n            0\r\n        );\r\n    }\r\n\r\n    function getStakerData() public view returns(StakerData[] memory) {\r\n        return stakers[msg.sender];\r\n    }\r\n\r\n    function getMaxAvail(address _token, uint256 _duration) public view returns(uint256) {\r\n        require(stakingTokens[_token], \"Token staking is not active\");\r\n\r\n        if (_duration < reward[_token].term0 || IERC20(_token).balanceOf(address(this)) <= totalReward[_token]) {\r\n            return 0;\r\n\r\n        } else if (_duration < reward[_token].term1) {\r\n            return IERC20(_token).balanceOf(address(this)).sub(totalReward[_token])\r\n                .mul(reward[_token].divisorRate)\r\n                .mul(12)\r\n                .div(reward[_token].term0)\r\n                .div(reward[_token].rewardRate3);\r\n\r\n        } else if (_duration < reward[_token].term2) {\r\n            return IERC20(_token).balanceOf(address(this)).sub(totalReward[_token])\r\n                .mul(reward[_token].divisorRate)\r\n                .mul(12)\r\n                .div(reward[_token].term1)\r\n                .div(reward[_token].rewardRate6);\r\n        } else {\r\n            return IERC20(_token).balanceOf(address(this)).sub(totalReward[_token])\r\n                .mul(reward[_token].divisorRate)\r\n                .mul(12)\r\n                .div(reward[_token].term2)\r\n                .div(reward[_token].rewardRate12);        \r\n        }\r\n    }\r\n\r\n    function stake(address _token, uint256 _amount, uint256 _duration) public {\r\n        require(stakingTokens[_token], \"Token staking is not active\");\r\n        require(_amount > 0, \"Amount must be greater than zero\");\r\n        require(_duration >= reward[_token].term0, \"Duration must be greater than or equal MIN month\");\r\n\r\n        if (_duration < reward[_token].term1) {\r\n            require(getMaxAvail(_token, reward[_token].term0) >= _amount, \"Amount is more than available\");\r\n\r\n            stakers[msg.sender].push(StakerData(\r\n                _token,\r\n                block.timestamp,\r\n                block.timestamp.add(uint256(2592000).mul(reward[_token].term0)), \r\n                _amount, \r\n                _amount.mul(reward[_token].rewardRate3).div(reward[_token].divisorRate).mul(reward[_token].term0).div(12),\r\n                reward[_token].rewardRate3,\r\n                reward[_token].divisorRate\r\n            ));\r\n\r\n        } else if (_duration < reward[_token].term2) {\r\n            require(getMaxAvail(_token, reward[_token].term1) >= _amount, \"Amount is more than available\");\r\n\r\n            stakers[msg.sender].push(StakerData(\r\n                _token,\r\n                block.timestamp,\r\n                block.timestamp.add(uint256(2592000).mul(reward[_token].term1)), \r\n                _amount, \r\n                _amount.mul(reward[_token].rewardRate6).div(reward[_token].divisorRate).mul(reward[_token].term1).div(12),\r\n                reward[_token].rewardRate6,\r\n                reward[_token].divisorRate\r\n            ));\r\n\r\n        } else {\r\n            require(getMaxAvail(_token, reward[_token].term2) >= _amount, \"Amount is more than available\");\r\n\r\n            stakers[msg.sender].push(StakerData(\r\n                _token,\r\n                block.timestamp,\r\n                block.timestamp.add(uint256(2592000).mul(reward[_token].term2)), \r\n                _amount, \r\n                _amount.mul(reward[_token].rewardRate12).div(reward[_token].divisorRate).mul(reward[_token].term2).div(12),\r\n                reward[_token].rewardRate12,\r\n                reward[_token].divisorRate\r\n            ));\r\n\r\n        }\r\n\r\n        totalReward[_token] = totalReward[_token].add(stakers[msg.sender][stakers[msg.sender].length.sub(1)].totalStaked).add(stakers[msg.sender][stakers[msg.sender].length.sub(1)].reward);\r\n        \r\n        if (_token != tnrToken) {\r\n            IERC20(tnrToken).transferFrom(msg.sender, address(this), reward[_token].commission);\r\n        }\r\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\r\n        emit TokensStaked(msg.sender, _amount, _duration);\r\n    }\r\n\r\n    function claim(address _token, uint256 _index) public {\r\n        require(stakers[msg.sender].length > 0, \"Stake already withdraw\");\r\n\r\n        uint256 _claimAmount = 0;\r\n\r\n        if (stakers[msg.sender][_index].tokenAddress == _token && stakers[msg.sender][_index].endStaking < block.timestamp) {\r\n            _claimAmount = _claimAmount.add(stakers[msg.sender][_index].totalStaked).add(stakers[msg.sender][_index].reward);\r\n            totalReward[_token] = totalReward[_token].sub(stakers[msg.sender][_index].totalStaked.add(stakers[msg.sender][_index].reward));\r\n            stakers[msg.sender][stakers[msg.sender].length.sub(1)] = stakers[msg.sender][_index];\r\n            emit TokensUnstaked(msg.sender, stakers[msg.sender][_index].totalStaked.add(stakers[msg.sender][_index].reward));\r\n            stakers[msg.sender].pop();\r\n        }\r\n\r\n        require(_claimAmount > 0, \"Available for claim 0\");\r\n\r\n        IERC20(_token).transfer(msg.sender, _claimAmount);\r\n    }\r\n\r\n    // only owner token\r\n\r\n    function withdraw(address _token, uint256 _amount) public {\r\n        require(reward[_token].owner == msg.sender, \"You're not the owner\");\r\n        require(IERC20(_token).balanceOf(address(this)) >= totalReward[_token].add(_amount), \"The balance is equal to or less than the reward\");\r\n        IERC20(_token).transfer(\r\n            msg.sender, \r\n            _amount);\r\n    }\r\n\r\n    function maxWithdraw(address _token) public onlyOwner view returns(uint256) {\r\n        require(reward[_token].owner == msg.sender, \"You're not the owner\");\r\n        return IERC20(_token).balanceOf(address(this)).sub(totalReward[_token]);\r\n    }\r\n\r\n    function setRewardRate(\r\n        address _token, \r\n        uint256 _rewardRate3, \r\n        uint256 _rewardRate6, \r\n        uint256 _rewardRate12, \r\n        uint256 _divisorRate,\r\n        uint8 _term0,\r\n        uint8 _term1,\r\n        uint8 _term2,\r\n        uint256 _commission\r\n    ) public {\r\n        require(reward[_token].owner == msg.sender, \"You're not the owner\");\r\n        reward[_token].rewardRate3 = _rewardRate3;\r\n        reward[_token].rewardRate6 = _rewardRate6;\r\n        reward[_token].rewardRate12 = _rewardRate12;\r\n        reward[_token].divisorRate = _divisorRate;\r\n        reward[_token].term0 = _term0;\r\n        reward[_token].term1 = _term1;\r\n        reward[_token].term2 = _term2;\r\n        reward[_token].commission = _commission;\r\n    }\r\n\r\n    // only owner contract\r\n\r\n    function getStakersData(address _address) public onlyOwner view returns(StakerData[] memory) {\r\n        return stakers[_address];\r\n    }\r\n\r\n    function setCommissionToken(address _token) public onlyOwner {\r\n        tnrToken = _token;\r\n    }\r\n\r\n    function addToken(\r\n        address _token, \r\n        uint256 _rewardRate3, \r\n        uint256 _rewardRate6, \r\n        uint256 _rewardRate12, \r\n        uint256 _divisorRate,\r\n        uint8 _term0,\r\n        uint8 _term1,\r\n        uint8 _term2,\r\n        address _ownerToken,\r\n        uint256 _commission\r\n    ) public onlyOwner() {\r\n        require(!stakingTokens[_token], \"Token has already been added\");\r\n        stakingTokens[_token] = true;\r\n        reward[_token].rewardRate3 = _rewardRate3;\r\n        reward[_token].rewardRate6 = _rewardRate6;\r\n        reward[_token].rewardRate12 = _rewardRate12;\r\n        reward[_token].divisorRate = _divisorRate;\r\n        reward[_token].term0 = _term0;\r\n        reward[_token].term1 = _term1;\r\n        reward[_token].term2 = _term2;\r\n        reward[_token].owner = _ownerToken;\r\n        reward[_token].commission = _commission;\r\n    }\r\n\r\n    function deleteToken(address _token) public onlyOwner() {\r\n        require(stakingTokens[_token], \"Token has already been delete\");\r\n        stakingTokens[_token] = false;\r\n        IERC20(_token).transfer(\r\n            reward[_token].owner, \r\n            IERC20(_token).balanceOf(address(this)).sub(totalReward[_token])\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tnrToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"TokensStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensUnstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate12\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_divisorRate\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_term0\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_term1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_term2\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_ownerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"deleteToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"getMaxAvail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakerData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateDiv\",\"type\":\"uint256\"}],\"internalType\":\"struct Stake.StakerData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakersData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateDiv\",\"type\":\"uint256\"}],\"internalType\":\"struct Stake.StakerData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardRate3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate12\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisorRate\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"term0\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"term1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"term2\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setCommissionToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate6\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate12\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_divisorRate\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_term0\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_term1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_term2\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tnrToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Stake", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000a80d88d15c315a8f40229fed2d01551747b97fd20000000000000000000000000000000000000000000000a2a15d09519be00000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ea4a50dbf5297938644f81b494380435fd043f1ada618a6e27675fc5edb7701a"}