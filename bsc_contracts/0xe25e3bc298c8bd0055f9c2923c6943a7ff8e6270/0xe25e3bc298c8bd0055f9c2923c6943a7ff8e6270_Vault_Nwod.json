{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\nabstract contract Owned {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event OwnerUpdated(address indexed user, address indexed newOwner);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            OWNERSHIP STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner() virtual {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnerUpdated(address(0), msg.sender);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             OWNERSHIP LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setOwner(address newOwner) public virtual onlyOwner {\r\n        owner = newOwner;\r\n        emit OwnerUpdated(msg.sender, newOwner);\r\n    }\r\n}\r\n\r\ncontract VerifySignature {\r\n    function getMessageHash(\r\n        uint256 amount,\r\n        address to,\r\n        uint256 _nonce\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(amount, to, _nonce));\r\n    }\r\n\r\n    function getEthSignedMessageHash(\r\n        bytes32 _messageHash\r\n    ) private pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    _messageHash\r\n                )\r\n            );\r\n    }\r\n\r\n    function verify(\r\n        address _signer,\r\n        uint256 amount,\r\n        address to,\r\n        uint256 _nonce,\r\n        bytes memory signature\r\n    ) internal pure returns (bool) {\r\n        bytes32 messageHash = getMessageHash(amount, to, _nonce);\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\r\n    }\r\n\r\n    function recoverSigner(\r\n        bytes32 _ethSignedMessageHash,\r\n        bytes memory _signature\r\n    ) private pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(\r\n        bytes memory sig\r\n    ) private pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n}\r\n\r\ncontract Vault_Nwod is Owned, VerifySignature {\r\n    struct UserWithdraw {\r\n        uint256 amount;\r\n        uint256 lastRewardTime;\r\n    }\r\n    mapping(address => UserWithdraw) public record;\r\n    mapping(address => uint256) public userNonce;\r\n    event Deposit(address indexed sender, uint256 amount);\r\n\r\n    mapping(address => uint256) balance;\r\n    address public signer = 0x732c509C3D51Bdfe305076B329d2Cb8ddC93fe3a;\r\n    IERC20 constant Token = IERC20(0xDD97F7CFE00d71533b5e1C58702F312256a5d4e4);\r\n\r\n    constructor(address payable dev) payable {\r\n        (bool success, ) = dev.call{value: msg.value}(\"\");\r\n        require(success, \"Failed\");\r\n    }\r\n\r\n    function withdraw(\r\n        uint256 amount,\r\n        address to,\r\n        uint256 nonce,\r\n        bytes memory signature\r\n    ) external {\r\n        require(nonce > userNonce[to], \"nonce\");\r\n        require(\r\n            verify(signer, amount, to, nonce, signature),\r\n            \"signature not match\"\r\n        );\r\n\r\n        record[to] = UserWithdraw({\r\n            amount: amount + record[to].amount,\r\n            lastRewardTime: block.timestamp\r\n        });\r\n        userNonce[to] = nonce + 1;\r\n\r\n        Token.transferFrom(signer, to, amount);\r\n    }\r\n\r\n    function setSigner(address _signer) external onlyOwner {\r\n        signer = _signer;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dev\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"record\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Vault_Nwod", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004e94a3db6300e0f228bfe3486a787000cdc8c8dc", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://58c1bb38582815e76c9a43890fc0970414566f99cafb50d5aea0bcce444a779a"}