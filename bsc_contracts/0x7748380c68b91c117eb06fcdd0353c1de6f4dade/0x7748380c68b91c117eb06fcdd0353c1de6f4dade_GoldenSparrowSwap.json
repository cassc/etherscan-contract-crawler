{"SourceCode": "/******************************************************************************\r\nSwapping Contract Where User Can Swap Their Old Golden Sparrow V2 (GSPV2) Token With New One Golden Sparrow Foundation (GSF) In 1:1 Ratio No Deduction\r\nWebsite Link : https://www.goldensparrow.info\r\n\r\n*********************************************************************************/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8;\r\nabstract contract SafeMath {\r\n        /* Addition of Two Number */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    /* Subscription of Two Number */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    /* Multiplication of Two Number */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    /* Divison of Two Number */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    /* Modulus of Two Number */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 { \r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender,address recipient,uint amount ) external returns (bool);\r\n    function decimals() external returns (uint8);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract GoldenSparrowSwap is SafeMath {\r\n    address payable private primaryAdmin;\r\n    IERC20 private fromToken;\r\n    IERC20 private toToken;\r\n\r\n    event BlockWalletAddress();\r\n    event UnblockWalletAddress();\r\n\r\n    mapping (address => bool) public checkUserBlocked;\r\n\r\n    constructor() {\r\n        address payable msgSender = payable(msg.sender);\r\n        primaryAdmin = msgSender;\r\n\t}\r\n\r\n    /**\r\n    * @dev called by the owner to block wallet address in case any needed\r\n    */\r\n    function blockWalletAddress(address WalletAddress) onlyOwner public {\r\n        checkUserBlocked[WalletAddress] = true;\r\n        emit BlockWalletAddress();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to Unblock Wallet Address that earlier blocked\r\n    */\r\n    function unblockWalletAddress(address WalletAddress) onlyOwner public {\r\n        checkUserBlocked[WalletAddress] = false;\r\n        emit UnblockWalletAddress();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return primaryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the swap token contract address.\r\n     */\r\n    function fromTokenContractAddress() public view returns (IERC20) {\r\n        return fromToken;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the native token contract address.\r\n     */\r\n    function toTokenContractAddress() public view returns (IERC20) {\r\n        return toToken;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(primaryAdmin == payable(msg.sender), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(primaryAdmin, address(0));\r\n        primaryAdmin = payable(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address payable newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(primaryAdmin, newOwner);\r\n        primaryAdmin = newOwner;\r\n    }\r\n\r\n    struct UserSwapDetails {\r\n        uint256 totalFromToken;\r\n        uint256 totalToToken;\r\n        uint lastUpdatedUTCDateTime;\r\n\t}\r\n\r\n\tmapping (address => UserSwapDetails) public userswapdetails;\r\n\r\n    event Swap(address _user, uint256 _nativeTokensQty,uint256 _swapTokensQty);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function updateFromTokenContractAddress(IERC20 _fromToken) public onlyOwner() {\r\n        require(primaryAdmin==msg.sender, 'Admin what?');\r\n        fromToken=_fromToken;\r\n    }\r\n\r\n    function updateToTokenContractAddress(IERC20 _toToken) public onlyOwner() {\r\n        require(primaryAdmin==msg.sender, 'Admin what?');   \r\n        toToken=_toToken;\r\n    }\r\n\r\n    function SwapToken(uint256 _TokenQty) public returns (bool) {\r\n       UserSwapDetails storage _UserSwapDetails = userswapdetails[msg.sender];\r\n       _UserSwapDetails.totalFromToken += _TokenQty;\r\n       _UserSwapDetails.totalToToken += _TokenQty;\r\n       _UserSwapDetails.lastUpdatedUTCDateTime = view_GetCurrentTimeStamp();\r\n       fromToken.transferFrom(msg.sender, address(this), _TokenQty);\r\n       if(!checkUserBlocked[msg.sender]){\r\n          toToken.transfer(msg.sender, _TokenQty);\r\n       }\r\n       emit Swap(msg.sender, _TokenQty,_TokenQty);\r\n       return true;\r\n    }\r\n\r\n    //Contarct Owner Can Sent From Token on Smart Contract\r\n    function _setupFromToken(uint256 _SwapToken) public onlyOwner() {\r\n        require(primaryAdmin==msg.sender, 'Admin what?');\r\n        fromToken.transferFrom(msg.sender, address(this), _SwapToken);\r\n    }\r\n\r\n    //Contarct Owner Can Take Back From Token from Smart Contract\r\n    function _reverseFromToken(uint256 _SwapToken) public onlyOwner() {\r\n        require(primaryAdmin==msg.sender, 'Admin what?');\r\n        fromToken.transfer(primaryAdmin, _SwapToken);\r\n    }\r\n\r\n    //Contarct Owner Can Sent To Token on Smart Contract\r\n    function _setupToToken(uint256 _NativeToken) public onlyOwner() {\r\n        require(primaryAdmin==msg.sender, 'Admin what?');\r\n        toToken.transferFrom(msg.sender, address(this), _NativeToken);\r\n    }\r\n\r\n    //Contarct Owner Can Take Back To Token from Smart Contract\r\n    function _reverseToToken(uint256 _NativeToken) public onlyOwner() {\r\n        require(primaryAdmin==msg.sender, 'Admin what?');\r\n        toToken.transfer(primaryAdmin, _NativeToken);\r\n    }\r\n\r\n    //View Get Current Time Stamp\r\n    function view_GetCurrentTimeStamp() public view returns(uint _timestamp){\r\n       return (block.timestamp);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BlockWalletAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nativeTokensQty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_swapTokensQty\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnblockWalletAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_TokenQty\",\"type\":\"uint256\"}],\"name\":\"SwapToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_SwapToken\",\"type\":\"uint256\"}],\"name\":\"_reverseFromToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_NativeToken\",\"type\":\"uint256\"}],\"name\":\"_reverseToToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_SwapToken\",\"type\":\"uint256\"}],\"name\":\"_setupFromToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_NativeToken\",\"type\":\"uint256\"}],\"name\":\"_setupToToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"WalletAddress\",\"type\":\"address\"}],\"name\":\"blockWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"checkUserBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fromTokenContractAddress\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toTokenContractAddress\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"WalletAddress\",\"type\":\"address\"}],\"name\":\"unblockWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_fromToken\",\"type\":\"address\"}],\"name\":\"updateFromTokenContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_toToken\",\"type\":\"address\"}],\"name\":\"updateToTokenContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userswapdetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFromToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalToToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdatedUTCDateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"view_GetCurrentTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GoldenSparrowSwap", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2fb21d00a2c4e7d46ec0aa3f05402e02c20e1322096fd316268c83c34d063e12"}