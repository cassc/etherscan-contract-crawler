{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/LimitOrderManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"openzeppelin/security/ReentrancyGuard.sol\\\";\\nimport {ILBPair} from \\\"joe-v2/interfaces/ILBPair.sol\\\";\\nimport {ILBFactory} from \\\"joe-v2/interfaces/ILBFactory.sol\\\";\\nimport {LiquidityConfigurations} from \\\"joe-v2/libraries/math/LiquidityConfigurations.sol\\\";\\nimport {Constants} from \\\"joe-v2/libraries/Constants.sol\\\";\\nimport {PackedUint128Math} from \\\"joe-v2/libraries/math/PackedUint128Math.sol\\\";\\nimport {Uint256x256Math} from \\\"joe-v2/libraries/math/Uint256x256Math.sol\\\";\\nimport {SafeCast} from \\\"joe-v2/libraries/math/SafeCast.sol\\\";\\nimport {IWNATIVE} from \\\"joe-v2/interfaces/IWNATIVE.sol\\\";\\n\\nimport {ILimitOrderManager} from \\\"./interfaces/ILimitOrderManager.sol\\\";\\n\\n/**\\n * @title Limit Order Manager\\n * @author Trader Joe\\n * @notice This contracts allows users to place limit orders using the Liquidity Book protocol.\\n * It allows to create orders for any Liquidity Book pair V2.1.\\n *\\n * The flow of the Limit Order Manager is the following:\\n * - Users create orders for a specific pair, type (bid or ask), price (bin id) and amount\\n *  (in token Y for bid orders and token X for ask orders) which will be added to the liquidity book pair.\\n * - Users can cancel orders, which will remove the liquidity from the liquidity book pair according to the order amount\\n * and send the token amounts back to the user (the amounts depend on the bin composition).\\n * - Users can execute orders, which will remove the liquidity from the order and send the token to the\\n * Limit Order Manager contract.\\n * - Users can claim their executed orders, which will send a portion of the token received from the execution\\n * to the user (the share depends on the total executed amount of the orders).\\n *\\n * Users can place orders using the `placeOrder` function by specifying the following parameters:\\n * - `tokenX`: the token X of the liquidity book pair\\n * - `tokenY`: the token Y of the liquidity book pair\\n * - `binStep`: the bin step of the liquidity book pair\\n * - `orderType`: the order type (bid or ask)\\n * - `binId`: the bin id of the order, which is the price of the order\\n * - `amount`: the amount of token to be used for the order, in token Y for bid orders and token X for ask orders\\n * Orders can't be placed in the active bin id. Bid orders need to be placed in a bin id lower than the active id,\\n * while ask orders need to be placed in a bin id greater than the active bin id.\\n *\\n * Users can cancel orders using the `cancelOrder` function by specifying the same parameters as for `placeOrder` but\\n * without the `amount` parameter.\\n * If the order is already executed, it can't be cancelled, and user will need to claim the filled amount.\\n * If the user is trying to cancel an order that is inside the active bin id, he may receive a partially filled order,\\n * according to the active bin composition.\\n *\\n * Users can claim orders using the `claimOrder` function by specifying the same parameters as for `placeOrder` but\\n * without the `amount` parameter.\\n * If the order is not already executed, but that it can be executed, it will be executed first and then claimed.\\n * If the order isn't executable, it can't be claimed and the transaction will revert.\\n * If the order is already executed, the user will receive the filled amount.\\n *\\n * Users can execute orders using the `executeOrder` function by specifying the same parameters as for `placeOrder` but\\n * without the `amount` parameter.\\n * If the order can't be executed or if it is already executed, the transaction will not revert but will return false.\\n */\\ncontract LimitOrderManager is ReentrancyGuard, ILimitOrderManager {\\n    using SafeERC20 for IERC20;\\n    using PackedUint128Math for bytes32;\\n    using Uint256x256Math for uint256;\\n    using SafeCast for uint256;\\n\\n    ILBFactory private immutable _factory;\\n    IWNATIVE private immutable _wNative;\\n\\n    /**\\n     * @dev Mapping of order key (pair, order type, bin id) to positions.\\n     */\\n    mapping(bytes32 => Positions) private _positions;\\n\\n    /**\\n     * @dev Mapping of user address to mapping of order key (pair, order type, bin id) to order.\\n     */\\n    mapping(address => mapping(bytes32 => Order)) private _orders;\\n\\n    uint256 private _executorFeeShare;\\n\\n    /**\\n     * @notice Constructor of the Limit Order Manager.\\n     * @param factory The address of the Liquidity Book factory.\\n     * @param wNative The address of the WNative token.\\n     */\\n    constructor(ILBFactory factory, IWNATIVE wNative) {\\n        if (address(factory) == address(0) || address(wNative) == address(0)) revert LimitOrderManager__ZeroAddress();\\n\\n        _factory = factory;\\n        _wNative = wNative;\\n\\n        _setExecutorFeeShare(Constants.BASIS_POINT_MAX);\\n    }\\n\\n    /**\\n     * @notice Returns the name of the Limit Order Manager.\\n     * @return The name of the Limit Order Manager.\\n     */\\n    function name() external pure override returns (string memory) {\\n        return \\\"Joe Limit Order Manager\\\";\\n    }\\n\\n    /**\\n     * @notice Returns the address of the Liquidity Book factory.\\n     * @return The address of the Liquidity Book factory.\\n     */\\n    function getFactory() external view override returns (ILBFactory) {\\n        return _factory;\\n    }\\n\\n    /**\\n     * @notice Returns the address of the WNative token.\\n     * @return The address of the WNative token.\\n     */\\n    function getWNative() external view override returns (IERC20) {\\n        return _wNative;\\n    }\\n\\n    /**\\n     * @notice Returns the executor fee share.\\n     * @return The executor fee share.\\n     */\\n    function getExecutorFeeShare() external view override returns (uint256) {\\n        return _executorFeeShare;\\n    }\\n\\n    /**\\n     * @notice Returns the order of the user for the given parameters.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param user The user address.\\n     * @return The order of the user for the given parameters.\\n     */\\n    function getOrder(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId, address user)\\n        external\\n        view\\n        override\\n        returns (Order memory)\\n    {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        return _orders[user][_getOrderKey(lbPair, orderType, binId)];\\n    }\\n\\n    /**\\n     * @notice Returns the last position id for the given parameters.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return The last position id for the given parameters.\\n     */\\n    function getLastPositionId(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n        return _positions[_getOrderKey(lbPair, orderType, binId)].lastId;\\n    }\\n\\n    /**\\n     * @notice Returns the position for the given parameters.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param positionId The position id.\\n     * @return The position for the given parameters.\\n     */\\n    function getPosition(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderType orderType,\\n        uint24 binId,\\n        uint256 positionId\\n    ) external view override returns (Position memory) {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n        return _positions[_getOrderKey(lbPair, orderType, binId)].at[positionId];\\n    }\\n\\n    /**\\n     * @notice Return whether the order is executable or not.\\n     * Will return false if the order is already executed or if it is not executable.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return Whether the order is executable or not.\\n     */\\n    function isOrderExecutable(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        // Get the order key\\n        bytes32 orderKey = _getOrderKey(lbPair, orderType, binId);\\n\\n        // Get the positions for the order key to get the last position id\\n        Positions storage positions = _positions[orderKey];\\n        uint256 positionId = positions.lastId;\\n\\n        // Get the position at the last position id\\n        Position storage position = positions.at[positionId];\\n\\n        // Return whether the position is executable or not, that is, if the position id is greater than 0,\\n        // the position is not already withdrawn and the order is executable\\n        return (positionId > 0 && !position.withdrawn && _isOrderExecutable(lbPair, orderType, binId));\\n    }\\n\\n    /**\\n     * @notice Returns the current amounts of the order for the given parameters.\\n     * Depending on the current bin id, the amounts might fluctuate.\\n     * The amount returned will be the value that the user will receive if the order is cancelled.\\n     * If it's fully converted to the other token, then it's the amount that the user will receive after the order\\n     * is claimed.\\n     * If the order was already claimed, it will return 0.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param user The user address.\\n     * @return amountX The amount of token X.\\n     * @return amountY The amount of token Y.\\n     * @return executionFeeX The execution fee of token X, if the order is executed. If the order is cancelled or was\\n     * already executed, it will be 0.\\n     * @return executionFeeY The execution fee of token Y, if the order is executed. If the order is cancelled or was\\n     * already executed, it will be 0.\\n     */\\n    function getCurrentAmounts(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderType orderType,\\n        uint24 binId,\\n        address user\\n    ) external view override returns (uint256 amountX, uint256 amountY, uint256 executionFeeX, uint256 executionFeeY) {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n        bytes32 orderKey = _getOrderKey(lbPair, orderType, binId);\\n\\n        Order storage order = _orders[user][orderKey];\\n        Position storage position = _positions[orderKey].at[order.positionId];\\n\\n        uint256 orderLiquidity = order.liquidity;\\n\\n        if (position.withdrawn) {\\n            uint256 amount = orderLiquidity.mulDivRoundDown(position.amount, position.liquidity);\\n\\n            (amountX, amountY) = orderType == OrderType.BID ? (amount, uint256(0)) : (uint256(0), amount);\\n        } else {\\n            uint256 totalLiquidity = lbPair.totalSupply(binId);\\n            if (totalLiquidity == 0) return (0, 0, 0, 0);\\n\\n            (uint256 binReserveX, uint256 binReserveY) = lbPair.getBin(binId);\\n\\n            amountX = orderLiquidity.mulDivRoundDown(binReserveX, totalLiquidity);\\n            amountY = orderLiquidity.mulDivRoundDown(binReserveY, totalLiquidity);\\n\\n            (executionFeeX, executionFeeY) = _getExecutionFee(lbPair, amountX, amountY);\\n        }\\n    }\\n\\n    /**\\n     * @notice Preview the execution fee sent to the executor if the order is executed.\\n     * @dev This is the base fee minus the protocol fee of the liquidity book pair.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @return fee The executor fee, in 1e18 precision.\\n     */\\n    function getExecutionFee(IERC20 tokenX, IERC20 tokenY, uint16 binStep)\\n        external\\n        view\\n        override\\n        returns (uint256 fee)\\n    {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n        (fee,) = _getExecutionFee(lbPair, 1e18, 1e18);\\n    }\\n\\n    /**\\n     * @notice Place an order.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param amount The amount of the order.\\n     * @return orderPlaced True if the order was placed, false otherwise.\\n     * @return orderPositionId The position id of the order.\\n     */\\n    function placeOrder(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId, uint256 amount)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        returns (bool orderPlaced, uint256 orderPositionId)\\n    {\\n        (IERC20 tokenIn, IERC20 tokenOut) = orderType == OrderType.BID ? (tokenY, tokenX) : (tokenX, tokenY);\\n\\n        if (\\n            (address(tokenIn) != address(0) && msg.value != 0) || (address(tokenIn) == address(0) && amount > msg.value)\\n        ) {\\n            revert LimitOrderManager__InvalidNativeAmount();\\n        }\\n\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        (orderPlaced, orderPositionId) = _placeOrder(lbPair, tokenIn, tokenOut, amount, orderType, binId);\\n\\n        if (!orderPlaced) amount = 0;\\n        if (msg.value > amount) _transferNativeToken(msg.sender, msg.value - amount);\\n    }\\n\\n    /**\\n     * @notice Cancel an order.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param minAmountX The minimum amount of token X to receive.\\n     * @param minAmountY The minimum amount of token Y to receive.\\n     * @return orderPositionId The position id of the order.\\n     */\\n    function cancelOrder(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderType orderType,\\n        uint24 binId,\\n        uint256 minAmountX,\\n        uint256 minAmountY\\n    ) external override nonReentrant returns (uint256 orderPositionId) {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        return _cancelOrder(lbPair, tokenX, tokenY, orderType, binId, minAmountX, minAmountY);\\n    }\\n\\n    /**\\n     * @notice Claim an order.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return orderPositionId The position id of the order.\\n     */\\n    function claimOrder(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 orderPositionId)\\n    {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        return _claimOrder(lbPair, tokenX, tokenY, orderType, binId);\\n    }\\n\\n    /**\\n     * @notice Execute an order.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return executed True if the order was executed, false otherwise.\\n     * @return positionId The position id.\\n     */\\n    function executeOrders(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        override\\n        nonReentrant\\n        returns (bool executed, uint256 positionId)\\n    {\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        return _executeOrders(lbPair, tokenX, tokenY, orderType, binId);\\n    }\\n\\n    /**\\n     * @notice Place multiple orders.\\n     * @param orders The orders to place.\\n     * @return orderPlaced True if the order was placed, false otherwise.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchPlaceOrders(PlaceOrderParams[] calldata orders)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        returns (bool[] memory orderPlaced, uint256[] memory orderPositionIds)\\n    {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        uint256 nativeAmount;\\n\\n        orderPositionIds = new uint256[](orders.length);\\n        orderPlaced = new bool[](orders.length);\\n\\n        for (uint256 i; i < orders.length;) {\\n            PlaceOrderParams calldata order = orders[i];\\n\\n            (IERC20 tokenIn, IERC20 tokenOut) =\\n                order.orderType == OrderType.BID ? (order.tokenY, order.tokenX) : (order.tokenX, order.tokenY);\\n\\n            if (address(tokenIn) == address(0) && (nativeAmount += order.amount) > msg.value) {\\n                revert LimitOrderManager__InvalidNativeAmount();\\n            }\\n\\n            ILBPair lbPair = _getLBPair(order.tokenX, order.tokenY, order.binStep);\\n\\n            (bool placed, uint256 positionId) =\\n                _placeOrder(lbPair, tokenIn, tokenOut, order.amount, order.orderType, order.binId);\\n\\n            orderPlaced[i] = placed;\\n            orderPositionIds[i] = positionId;\\n\\n            if (address(tokenIn) == address(0) && !placed) nativeAmount -= order.amount;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (msg.value > nativeAmount) _transferNativeToken(msg.sender, msg.value - nativeAmount);\\n    }\\n\\n    /**\\n     * @notice Cancel multiple orders.\\n     * @param orders The orders to cancel.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchCancelOrders(CancelOrderParams[] calldata orders)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256[] memory orderPositionIds)\\n    {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        orderPositionIds = new uint256[](orders.length);\\n\\n        for (uint256 i; i < orders.length;) {\\n            CancelOrderParams calldata order = orders[i];\\n\\n            ILBPair lbPair = _getLBPair(order.tokenX, order.tokenY, order.binStep);\\n\\n            orderPositionIds[i] = _cancelOrder(\\n                lbPair, order.tokenX, order.tokenY, order.orderType, order.binId, order.minAmountX, order.minAmountY\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim multiple orders.\\n     * @param orders The orders to claim.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchClaimOrders(OrderParams[] calldata orders)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256[] memory orderPositionIds)\\n    {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        orderPositionIds = new uint256[](orders.length);\\n\\n        for (uint256 i; i < orders.length;) {\\n            OrderParams calldata order = orders[i];\\n\\n            ILBPair lbPair = _getLBPair(order.tokenX, order.tokenY, order.binStep);\\n\\n            orderPositionIds[i] = _claimOrder(lbPair, order.tokenX, order.tokenY, order.orderType, order.binId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute multiple orders.\\n     * @param orders The orders to execute.\\n     * @return orderExecuted True if the order was executed, false otherwise.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchExecuteOrders(OrderParams[] calldata orders)\\n        external\\n        override\\n        nonReentrant\\n        returns (bool[] memory orderExecuted, uint256[] memory orderPositionIds)\\n    {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        orderPositionIds = new uint256[](orders.length);\\n        orderExecuted = new bool[](orders.length);\\n\\n        for (uint256 i; i < orders.length;) {\\n            OrderParams calldata order = orders[i];\\n\\n            ILBPair lbPair = _getLBPair(order.tokenX, order.tokenY, order.binStep);\\n\\n            (orderExecuted[i], orderPositionIds[i]) =\\n                _executeOrders(lbPair, order.tokenX, order.tokenY, order.orderType, order.binId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Place multiple orders for the same pair.\\n     * @dev This function saves a bit of gas, as it avoids calling multiple time the _getLBPair function.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orders The orders to place.\\n     * @return orderPlaced True if the order was placed, false otherwise.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchPlaceOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        PlaceOrderParamsSamePair[] calldata orders\\n    ) external payable override nonReentrant returns (bool[] memory orderPlaced, uint256[] memory orderPositionIds) {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        orderPositionIds = new uint256[](orders.length);\\n        orderPlaced = new bool[](orders.length);\\n\\n        uint256 nativeAmount;\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        for (uint256 i; i < orders.length;) {\\n            PlaceOrderParamsSamePair calldata order = orders[i];\\n\\n            (IERC20 tokenIn, IERC20 tokenOut) = order.orderType == OrderType.BID ? (tokenY, tokenX) : (tokenX, tokenY);\\n\\n            if (address(tokenIn) == address(0) && (nativeAmount += order.amount) > msg.value) {\\n                revert LimitOrderManager__InvalidNativeAmount();\\n            }\\n\\n            (bool placed, uint256 positionId) =\\n                _placeOrder(lbPair, tokenIn, tokenOut, order.amount, order.orderType, order.binId);\\n\\n            orderPlaced[i] = placed;\\n            orderPositionIds[i] = positionId;\\n\\n            if (address(tokenIn) == address(0) && !placed) nativeAmount -= order.amount;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (msg.value > nativeAmount) _transferNativeToken(msg.sender, msg.value - nativeAmount);\\n    }\\n\\n    /**\\n     * @notice Cancel multiple orders for the same pair.\\n     * @dev This function saves a bit of gas, as it avoids calling multiple time the _getLBPair function.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orders The orders to cancel.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchCancelOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        CancelOrderParamsSamePair[] calldata orders\\n    ) external override nonReentrant returns (uint256[] memory orderPositionIds) {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        orderPositionIds = new uint256[](orders.length);\\n\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        for (uint256 i; i < orders.length;) {\\n            CancelOrderParamsSamePair calldata order = orders[i];\\n\\n            orderPositionIds[i] =\\n                _cancelOrder(lbPair, tokenX, tokenY, order.orderType, order.binId, order.minAmountX, order.minAmountY);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim multiple orders for the same pair.\\n     * @dev This function saves a bit of gas, as it avoids calling multiple time the _getLBPair function.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orders The orders to claim.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchClaimOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderParamsSamePair[] calldata orders\\n    ) external override nonReentrant returns (uint256[] memory orderPositionIds) {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        orderPositionIds = new uint256[](orders.length);\\n\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        for (uint256 i; i < orders.length;) {\\n            OrderParamsSamePair calldata order = orders[i];\\n\\n            orderPositionIds[i] = _claimOrder(lbPair, tokenX, tokenY, order.orderType, order.binId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute multiple orders for the same pair.\\n     * @dev This function saves a bit of gas, as it avoids calling multiple time the _getLBPair function.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @param orders The orders to execute.\\n     * @return orderExecuted Whether the orders have been executed.\\n     * @return orderPositionIds The position ids of the orders.\\n     */\\n    function batchExecuteOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderParamsSamePair[] calldata orders\\n    ) external override nonReentrant returns (bool[] memory orderExecuted, uint256[] memory orderPositionIds) {\\n        if (orders.length == 0) revert LimitOrderManager__InvalidBatchLength();\\n\\n        orderPositionIds = new uint256[](orders.length);\\n        orderExecuted = new bool[](orders.length);\\n\\n        ILBPair lbPair = _getLBPair(tokenX, tokenY, binStep);\\n\\n        for (uint256 i; i < orders.length;) {\\n            OrderParamsSamePair calldata order = orders[i];\\n\\n            (orderExecuted[i], orderPositionIds[i]) =\\n                _executeOrders(lbPair, tokenX, tokenY, order.orderType, order.binId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the executor fee share.\\n     * @dev Only the factory owner can call this function. The remaining share is sent to the users.\\n     * @param executorFeeShare The executor fee share, in basis points.\\n     */\\n    function setExecutorFeeShare(uint256 executorFeeShare) external override {\\n        if (msg.sender != _factory.owner()) revert LimitOrderManager__OnlyFactoryOwner();\\n\\n        _setExecutorFeeShare(executorFeeShare);\\n    }\\n\\n    /**\\n     * @notice Allow the contract to receive native token, only if they come from the wrapped native token contract.\\n     */\\n    receive() external payable {\\n        if (msg.sender != address(_wNative)) revert LimitOrderManager__OnlyWNative();\\n    }\\n\\n    /**\\n     * @dev Get the liquidity book pair address from the factory.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binStep The bin step of the liquidity book pair.\\n     * @return lbPair The liquidity book pair.\\n     */\\n    function _getLBPair(IERC20 tokenX, IERC20 tokenY, uint16 binStep) private view returns (ILBPair lbPair) {\\n        tokenX = address(tokenX) == address(0) ? IERC20(address(_wNative)) : tokenX;\\n        tokenY = address(tokenY) == address(0) ? IERC20(address(_wNative)) : tokenY;\\n\\n        lbPair = _factory.getLBPairInformation(tokenX, tokenY, binStep).LBPair;\\n\\n        // Check if the liquidity book pair is valid, that is, if the lbPair address is not 0.\\n        if (address(lbPair) == address(0)) revert LimitOrderManager__InvalidPair();\\n\\n        // Check if the token X of the liquidity book pair is the same as the token X of the order.\\n        // We revert here because if the tokens are in the wrong order, then the price of the order will be wrong.\\n        if (lbPair.getTokenX() != tokenX) revert LimitOrderManager__InvalidTokenOrder();\\n    }\\n\\n    /**\\n     * @dev Return whether the order is valid or not.\\n     * An order is valid if the order type is bid and the bin id is lower than the active id,\\n     * or if the order type is ask and the bin id is greater than the active id. This is to prevent adding\\n     * orders to the active bin and to add liquidity to a bin that can't receive the token sent.\\n     * @param lbPair The liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return valid Whether the order is valid or not.\\n     */\\n    function _isOrderValid(ILBPair lbPair, OrderType orderType, uint24 binId) private view returns (bool) {\\n        uint24 activeId = lbPair.getActiveId();\\n        return ((orderType == OrderType.BID && binId < activeId) || (orderType == OrderType.ASK && binId > activeId));\\n    }\\n\\n    /**\\n     * @dev Return whether the order is executable or not.\\n     * An order is executable if the bin was crossed, if the order type is bid and the bin id is now lower than\\n     * to the active id, or if the order type is ask and the bin id is now greater than the active id.\\n     * This is to only allow executing orders that are fully filled.\\n     * @param lbPair The liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return executable Whether the order is executable or not.\\n     */\\n    function _isOrderExecutable(ILBPair lbPair, OrderType orderType, uint24 binId) private view returns (bool) {\\n        uint24 activeId = lbPair.getActiveId();\\n        return ((orderType == OrderType.BID && binId > activeId) || (orderType == OrderType.ASK && binId < activeId));\\n    }\\n\\n    /**\\n     * @dev Transfer the amount of token to the recipient. If the token is the zero address, then transfer the amount\\n     * of native token to the recipient.\\n     * @param token The token to transfer.\\n     * @param to The recipient of the transfer.\\n     * @param amount The amount to transfer.\\n     */\\n    function _transfer(IERC20 token, address to, uint256 amount) private {\\n        if (address(token) == address(0)) {\\n            _wNative.withdraw(amount);\\n            _transferNativeToken(to, amount);\\n        } else {\\n            token.safeTransfer(to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfer native token to the recipient.\\n     * @param to The recipient of the transfer.\\n     * @param amount The amount to transfer.\\n     */\\n    function _transferNativeToken(address to, uint256 amount) private {\\n        (bool success,) = to.call{value: amount}(\\\"\\\");\\n        if (!success) revert LimitOrderManager__TransferFailed();\\n    }\\n\\n    /**\\n     * @dev Transfer the amount of token from the sender to the recipient. If the token is the zero address, then\\n     * first deposit the amount of native token from the sender to the contract, then transfer the amount of native\\n     * token from the contract to the recipient.\\n     * @param token The token to transfer.\\n     * @param to The recipient of the transfer.\\n     * @param amount The amount to transfer.\\n     */\\n    function _transferFromSender(IERC20 token, address to, uint256 amount) private {\\n        if (address(token) == address(0)) {\\n            _wNative.deposit{value: amount}();\\n            IERC20(_wNative).safeTransfer(to, amount);\\n        } else {\\n            token.safeTransferFrom(msg.sender, to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Place an order.\\n     * If the user already have an order with the same parameters and that it's not executed yet, instead of creating a\\n     * new order, the amount of the previous order is increased by the amount of the new order.\\n     * If the user already have an order with the same parameters and that it's executed, the order is claimed if\\n     * it was not claimed yet and a new order is created  overwriting the previous one.\\n     * @param lbPair The liquidity book pair.\\n     * @param tokenIn The token in of the order.\\n     * @param tokenOut The token out of the order.\\n     * @param amount The amount of the order.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return orderPlaced True if the order was placed, false otherwise.\\n     * @return orderPositionId The position id of the order.\\n     */\\n    function _placeOrder(\\n        ILBPair lbPair,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amount,\\n        OrderType orderType,\\n        uint24 binId\\n    ) private returns (bool orderPlaced, uint256 orderPositionId) {\\n        // Check if the order is valid.\\n        if (!_isOrderValid(lbPair, orderType, binId)) return (false, 0);\\n\\n        // Deposit the amount sent by the user to the liquidity book pair.\\n        (bytes32 amounts, uint256 liquidity) = _depositToLBPair(lbPair, tokenIn, orderType, binId, amount);\\n\\n        // Get the order key.\\n        bytes32 orderKey = _getOrderKey(lbPair, orderType, binId);\\n\\n        // Get the position of the order.\\n        Positions storage positions = _positions[orderKey];\\n\\n        // Get the last position id and the last position.\\n        uint256 positionId = positions.lastId;\\n        Position storage position = positions.at[positionId];\\n\\n        // If the last position id is 0 or the last position is withdrawn, create a new position.\\n        if (positionId == 0 || position.withdrawn) {\\n            ++positionId;\\n            positions.lastId = positionId;\\n\\n            position = positions.at[positionId];\\n        }\\n\\n        // Update the liquidity of the position.\\n        position.liquidity += liquidity;\\n\\n        // Get the current user order.\\n        Order storage order = _orders[msg.sender][orderKey];\\n\\n        // Get the position id of the current user order.\\n        orderPositionId = order.positionId;\\n\\n        // If the position id of the order is smaller than the current position id, the order needs to be claimed,\\n        // unless the position id of the order is 0.\\n        if (orderPositionId < positionId) {\\n            // If the position id of the order is not 0, claim the order from the position.\\n            if (orderPositionId != 0) {\\n                _claimOrderFromPosition(positions.at[orderPositionId], order, tokenOut, orderPositionId, orderKey);\\n            }\\n\\n            // Set the position id of the order to the current position id.\\n            orderPositionId = positionId;\\n            order.positionId = orderPositionId;\\n        }\\n\\n        // Update the order liquidity.\\n        order.liquidity += liquidity;\\n\\n        emit OrderPlaced(\\n            msg.sender, lbPair, binId, orderType, orderPositionId, liquidity, amounts.decodeX(), amounts.decodeY()\\n        );\\n\\n        return (true, orderPositionId);\\n    }\\n\\n    /**\\n     * @dev Claim an order.\\n     * If the order is not claimable, the function reverts.\\n     * If the order is not claimable but executable, the order is first executed and then claimed.\\n     * If the order is claimable, the order is claimed and the user receives the tokens.\\n     * @param lbPair The liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return orderPositionId The position id of the order.\\n     */\\n    function _claimOrder(ILBPair lbPair, IERC20 tokenX, IERC20 tokenY, OrderType orderType, uint24 binId)\\n        private\\n        returns (uint256 orderPositionId)\\n    {\\n        // Get the order key.\\n        bytes32 orderKey = _getOrderKey(lbPair, orderType, binId);\\n\\n        // Get the current user order.\\n        Order storage order = _orders[msg.sender][orderKey];\\n\\n        // Get the position id of the current user order.\\n        orderPositionId = order.positionId;\\n\\n        // If the position id of the order is 0, the order is not claimable, therefore revert.\\n        if (orderPositionId == 0) revert LimitOrderManager__OrderNotClaimable();\\n\\n        // Get the position of the order.\\n        Position storage position = _positions[orderKey].at[orderPositionId];\\n\\n        // If the position is not withdrawn, try to execute the order.\\n        if (!position.withdrawn) {\\n            (bool orderExecuted,) = _executeOrders(lbPair, tokenX, tokenY, orderType, binId);\\n            if (!orderExecuted) revert LimitOrderManager__OrderNotExecutable();\\n        }\\n\\n        // Claim the order from the position, which will transfer the amount of the filled order to the user.\\n        _claimOrderFromPosition(\\n            position, order, orderType == OrderType.BID ? tokenX : tokenY, orderPositionId, orderKey\\n        );\\n    }\\n\\n    /**\\n     * @dev Claim an order from a position.\\n     * This function does not check if the order is claimable or not, therefore it needs to be called by a function\\n     * that does the necessary checks.\\n     * @param position The position of the order.\\n     * @param order The order.\\n     * @param token The token of the order.\\n     * @param orderPositionId The position id of the order.\\n     * @param orderKey The order key.\\n     */\\n    function _claimOrderFromPosition(\\n        Position storage position,\\n        Order storage order,\\n        IERC20 token,\\n        uint256 orderPositionId,\\n        bytes32 orderKey\\n    ) private {\\n        // Get the order liquidity.\\n        uint256 orderLiquidity = order.liquidity;\\n\\n        // Set the order liquidity and position id to 0.\\n        order.positionId = 0;\\n        order.liquidity = 0;\\n\\n        // Calculate the amount of the order.\\n        uint256 amount = orderLiquidity.mulDivRoundDown(position.amount, position.liquidity);\\n\\n        // Update the liquidity and the amount of the position from the amounts withdrawn.\\n        position.amount -= uint128(amount);\\n        position.liquidity -= orderLiquidity;\\n\\n        // Transfer the amount of the order to the user.\\n        _transfer(token, msg.sender, amount);\\n\\n        // Get the order key components (liquidity book pair, order type, bin id) from the order key to emit the event.\\n        (ILBPair lbPair, OrderType orderType, uint24 binId) = _getOrderKeyComponents(orderKey);\\n        (uint256 amountX, uint256 amountY) = orderType == OrderType.BID ? (amount, uint256(0)) : (uint256(0), amount);\\n\\n        emit OrderClaimed(msg.sender, lbPair, binId, orderType, orderPositionId, orderLiquidity, amountX, amountY);\\n    }\\n\\n    /**\\n     * @dev Cancel an order.\\n     * If the order is not placed, the function reverts.\\n     * If the order is already executed, the function reverts.\\n     * If the order is placed, the order is cancelled and the liquidity is withdrawn from the liquidity book pair.\\n     * The liquidity is then transferred back to the user (the amounts depend on the bin composition).\\n     * @param lbPair The liquidity book pair.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param minAmountX The minimum amount of token X to receive on withdrawal from the liquidity book pair.\\n     * @param minAmountY The minimum amount of token Y to receive on withdrawal from the liquidity book pair.\\n     * @return orderPositionId The position id of the order.\\n     */\\n    function _cancelOrder(\\n        ILBPair lbPair,\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        OrderType orderType,\\n        uint24 binId,\\n        uint256 minAmountX,\\n        uint256 minAmountY\\n    ) private returns (uint256 orderPositionId) {\\n        // Get the order key.\\n        bytes32 orderKey = _getOrderKey(lbPair, orderType, binId);\\n\\n        // Get the current user order.\\n        Order storage order = _orders[msg.sender][orderKey];\\n\\n        // Get the position id of the current user order.\\n        orderPositionId = order.positionId;\\n\\n        // If the position id of the order is 0, the order is not placed, therefore revert.\\n        if (orderPositionId == 0) revert LimitOrderManager__OrderNotPlaced();\\n\\n        // Get the position of the order.\\n        Position storage position = _positions[orderKey].at[orderPositionId];\\n\\n        // If the position is withdrawn, the order is already executed, therefore revert.\\n        if (position.withdrawn) revert LimitOrderManager__OrderAlreadyExecuted();\\n\\n        // Get the order liquidity.\\n        uint256 orderLiquidity = order.liquidity;\\n\\n        // Set the order liquidity and position id to 0.\\n        order.positionId = 0;\\n        order.liquidity = 0;\\n\\n        // Decrease the position liquidity by the order liquidity.\\n        position.liquidity -= orderLiquidity;\\n\\n        // Withdraw the liquidity from the liquidity book pair.\\n        (uint256 amountX, uint256 amountY) =\\n            _withdrawFromLBPair(lbPair, tokenX, tokenY, binId, orderLiquidity, msg.sender);\\n\\n        // If the amounts withdrawn are less than the minimum amounts, revert.\\n        if (amountX < minAmountX || amountY < minAmountY) revert LimitOrderManager__InsufficientWithdrawalAmounts();\\n\\n        emit OrderCancelled(msg.sender, lbPair, binId, orderType, orderPositionId, orderLiquidity, amountX, amountY);\\n    }\\n\\n    /**\\n     * @dev Execute the orders of a lbPair, order type and bin id.\\n     * If the bin is not executable, the function returns false.\\n     * If the bin is executable, the function executes the orders of the bin.\\n     * @param lbPair The liquidity book pair.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return executed True if the orders are executed, false otherwise.\\n     * @return positionId The position id of the executed orders.\\n     */\\n    function _executeOrders(ILBPair lbPair, IERC20 tokenX, IERC20 tokenY, OrderType orderType, uint24 binId)\\n        private\\n        returns (bool executed, uint256 positionId)\\n    {\\n        // Check if the bin is executable.\\n        if (!_isOrderExecutable(lbPair, orderType, binId)) return (false, 0);\\n\\n        // Get the order key.\\n        bytes32 orderKey = _getOrderKey(lbPair, orderType, binId);\\n\\n        // Get the positions of the order.\\n        Positions storage positions = _positions[orderKey];\\n\\n        // Get the last position id of the order.\\n        positionId = positions.lastId;\\n\\n        // If the position id is 0, there are no orders to execute.\\n        if (positionId == 0) return (false, 0);\\n\\n        // Get the last position of the order.\\n        Position storage position = _positions[orderKey].at[positionId];\\n\\n        // If the position is withdrawn, the orders are already executed.\\n        if (position.withdrawn) return (false, 0);\\n        position.withdrawn = true;\\n\\n        // Get the position liquidity.\\n        uint256 positionLiquidity = position.liquidity;\\n\\n        // If the position liquidity is 0, there are no orders to execute.\\n        if (positionLiquidity == 0) return (false, 0);\\n\\n        // Withdraw the liquidity from the liquidity book pair.\\n        (uint128 amountX, uint128 amountY) =\\n            _withdrawFromLBPair(lbPair, tokenX, tokenY, binId, positionLiquidity, address(this));\\n\\n        // If the order type is bid, the withdrawn liquidity is only composed of token X,\\n        // otherwise the withdrawn liquidity is only composed of token Y.\\n        position.amount = orderType == OrderType.BID ? amountX : amountY;\\n\\n        emit OrderExecuted(msg.sender, lbPair, binId, orderType, positionId, positionLiquidity, amountX, amountY);\\n\\n        return (true, positionId);\\n    }\\n\\n    /**\\n     * @dev Deposit liquidity to a liquidity book pair.\\n     * @param lbPair The liquidity book pair.\\n     * @param token The token to deposit.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param amount The amount of the token to deposit.\\n     * @return amounts The amounts of the tokens deposited.\\n     * @return liquidity The liquidity deposited.\\n     */\\n    function _depositToLBPair(ILBPair lbPair, IERC20 token, OrderType orderType, uint24 binId, uint256 amount)\\n        private\\n        returns (bytes32 amounts, uint256 liquidity)\\n    {\\n        // If the amount is 0, revert.\\n        if (amount == 0) revert LimitOrderManager__ZeroAmount();\\n\\n        // Get the liquidity configurations, which is just adding liquidity to a single bin.\\n        bytes32[] memory liquidityConfigurations = new bytes32[](1);\\n\\n        (uint64 distributionX, uint64 distributionY) =\\n            orderType == OrderType.BID ? (uint64(0), 1e18) : (1e18, uint64(0));\\n\\n        liquidityConfigurations[0] = LiquidityConfigurations.encodeParams(distributionX, distributionY, binId);\\n\\n        // Send the amount of the token to the liquidity book pair.\\n        _transferFromSender(token, address(lbPair), amount);\\n\\n        // Mint the liquidity to the liquidity book pair.\\n        (bytes32 packedAmountIn, bytes32 packedAmountExcess, uint256[] memory liquidities) =\\n            lbPair.mint(address(this), liquidityConfigurations, msg.sender);\\n\\n        // Get the amount of token X and token Y deposited, which is the amount of the token minus the excess\\n        // as it's sent back to the `msg.sender` directly.\\n        amounts = packedAmountIn.sub(packedAmountExcess);\\n\\n        // Get the liquidity deposited.\\n        liquidity = liquidities[0];\\n    }\\n\\n    /**\\n     * @dev Withdraw liquidity from a liquidity book pair.\\n     * @param lbPair The liquidity book pair.\\n     * @param tokenX The token X of the liquidity book pair.\\n     * @param tokenY The token Y of the liquidity book pair.\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @param liquidity The liquidity to withdraw.\\n     * @param to The address to withdraw the liquidity to.\\n     * @return amountX The amount of token X withdrawn.\\n     * @return amountY The amount of token Y withdrawn.\\n     */\\n    function _withdrawFromLBPair(\\n        ILBPair lbPair,\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint24 binId,\\n        uint256 liquidity,\\n        address to\\n    ) private returns (uint128 amountX, uint128 amountY) {\\n        if (address(tokenX) == address(0) || address(tokenY) == address(0)) revert LimitOrderManager__ZeroAddress();\\n\\n        // Get the ids and amounts of the liquidity to burn.\\n        uint256[] memory ids = new uint256[](1);\\n        uint256[] memory amounts = new uint256[](1);\\n\\n        ids[0] = binId;\\n        amounts[0] = liquidity;\\n\\n        // Get the current balance of the token X and token Y.\\n        uint256 balanceX = tokenX.balanceOf(to);\\n        uint256 balanceY = tokenY.balanceOf(to);\\n\\n        // Burn the liquidity from the liquidity book pair, sending the tokens directly to `to` address.\\n        lbPair.burn(address(this), to, ids, amounts);\\n\\n        // Get the amount of token X and token Y withdrawn.\\n        amountX = (tokenX.balanceOf(to) - balanceX).safe128();\\n        amountY = (tokenY.balanceOf(to) - balanceY).safe128();\\n\\n        // If `to` is `address(this)`, it means this is an order that is being executed.\\n        if (to == address(this)) {\\n            (uint128 feeAmountX, uint128 feeAmountY) = _getExecutionFee(lbPair, amountX, amountY);\\n\\n            // Update the amount of token X and token Y to the amount minus the fee amount.\\n            amountX -= feeAmountX;\\n            amountY -= feeAmountY;\\n\\n            // Transfer the fee amount of token X and token Y to the executor.\\n            if (feeAmountX > 0) _transfer(tokenX, msg.sender, feeAmountX);\\n            if (feeAmountY > 0) _transfer(tokenY, msg.sender, feeAmountY);\\n\\n            emit ExecutionFeePaid(msg.sender, tokenX, tokenY, feeAmountX, feeAmountY);\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the execution fee of a liquidity book pair.\\n     * The fee is calculated to be the base fee minus the protocol share, as we're sure that if a bin was crossed,\\n     * the position received at least `baseFeeAmount - protocolShareAmount` fees. The fees in excess will still be\\n     * sent to the users.\\n     * @param lbPair The liquidity book pair.\\n     * @param amountX The amount of token X.\\n     * @param amountY The amount of token Y.\\n     * @return feeAmountX The fee amount of token X.\\n     * @return feeAmountY The fee amount of token Y.\\n     */\\n    function _getExecutionFee(ILBPair lbPair, uint256 amountX, uint256 amountY)\\n        private\\n        view\\n        returns (uint128 feeAmountX, uint128 feeAmountY)\\n    {\\n        // Get the static fee parameter of the liquidity book pair.\\n        (uint256 baseFactor,,,,, uint256 protocolShare,) = lbPair.getStaticFeeParameters();\\n\\n        // Calculate the base fee percentage for LPs (removing the protocol share).\\n        // We take `1e16` as one because `binStep`, `baseFactor`, `protocolShare` and `_executorFeeShare` are all\\n        // in basis points. This is an approximation of the actual fee if the bin was crossed directly.\\n        uint256 executorFee =\\n            uint256(lbPair.getBinStep()) * baseFactor * (Constants.BASIS_POINT_MAX - protocolShare) * _executorFeeShare;\\n\\n        feeAmountX = (amountX * executorFee / 1e16).safe128();\\n        feeAmountY = (amountY * executorFee / 1e16).safe128();\\n    }\\n\\n    /**\\n     * @dev Sets the executor fee share.\\n     * @param executorFeeShare The executor fee share.\\n     */\\n    function _setExecutorFeeShare(uint256 executorFeeShare) private {\\n        if (executorFeeShare > Constants.BASIS_POINT_MAX) revert LimitOrderManager__InvalidExecutorFeeShare();\\n\\n        _executorFeeShare = executorFeeShare;\\n\\n        emit ExecutorFeeShareSet(executorFeeShare);\\n    }\\n\\n    /**\\n     * @dev Get the order key.\\n     * The order key is composed of the liquidity book pair, the order type and the bin id, packed as follow:\\n     * - [255 - 96]: liquidity book pair address.\\n     * - [95 - 88]: order type (bid or ask)\\n     * - [87 - 24]: empty bits.\\n     * - [23 - 0]: bin id.\\n     * @param pair The liquidity book pair.\\n     * @param orderType The order type (bid or ask).\\n     * @param binId The bin id of the order, which is the price of the order.\\n     * @return key The order key.\\n     */\\n    function _getOrderKey(ILBPair pair, OrderType orderType, uint24 binId) private pure returns (bytes32 key) {\\n        assembly {\\n            key := shl(96, pair)\\n            key := or(key, shl(88, and(orderType, 0xff)))\\n            key := or(key, and(binId, 0xffffff))\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the order key components.\\n     * @param key The order key, packed as follow:\\n     * - [255 - 96]: liquidity book pair address.\\n     * - [95 - 88]: order type (bid or ask)\\n     * - [87 - 24]: empty bits.\\n     * - [23 - 0]: bin id.\\n     * @return pair The liquidity book pair.\\n     * @return orderType The order type (bid or ask).\\n     * @return binId The bin id of the order, which is the price of the order.\\n     */\\n    function _getOrderKeyComponents(bytes32 key)\\n        private\\n        pure\\n        returns (ILBPair pair, OrderType orderType, uint24 binId)\\n    {\\n        // Get the order key components from the order key.\\n        assembly {\\n            pair := shr(96, key)\\n            orderType := and(shr(88, key), 0xff)\\n            binId := and(key, 0xffffff)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/interfaces/ILBPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport {ILBFactory} from \\\"./ILBFactory.sol\\\";\\nimport {ILBFlashLoanCallback} from \\\"./ILBFlashLoanCallback.sol\\\";\\nimport {ILBToken} from \\\"./ILBToken.sol\\\";\\n\\ninterface ILBPair is ILBToken {\\n    error LBPair__ZeroBorrowAmount();\\n    error LBPair__AddressZero();\\n    error LBPair__AlreadyInitialized();\\n    error LBPair__EmptyMarketConfigs();\\n    error LBPair__FlashLoanCallbackFailed();\\n    error LBPair__FlashLoanInsufficientAmount();\\n    error LBPair__InsufficientAmountIn();\\n    error LBPair__InsufficientAmountOut();\\n    error LBPair__InvalidInput();\\n    error LBPair__InvalidStaticFeeParameters();\\n    error LBPair__OnlyFactory();\\n    error LBPair__OnlyProtocolFeeRecipient();\\n    error LBPair__OutOfLiquidity();\\n    error LBPair__TokenNotSupported();\\n    error LBPair__ZeroAmount(uint24 id);\\n    error LBPair__ZeroAmountsOut(uint24 id);\\n    error LBPair__ZeroShares(uint24 id);\\n    error LBPair__MaxTotalFeeExceeded();\\n\\n    struct MintArrays {\\n        uint256[] ids;\\n        bytes32[] amounts;\\n        uint256[] liquidityMinted;\\n    }\\n\\n    event DepositedToBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\\n\\n    event WithdrawnFromBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\\n\\n    event CompositionFees(address indexed sender, uint24 id, bytes32 totalFees, bytes32 protocolFees);\\n\\n    event CollectedProtocolFees(address indexed feeRecipient, bytes32 protocolFees);\\n\\n    event Swap(\\n        address indexed sender,\\n        address indexed to,\\n        uint24 id,\\n        bytes32 amountsIn,\\n        bytes32 amountsOut,\\n        uint24 volatilityAccumulator,\\n        bytes32 totalFees,\\n        bytes32 protocolFees\\n    );\\n\\n    event StaticFeeParametersSet(\\n        address indexed sender,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    );\\n\\n    event FlashLoan(\\n        address indexed sender,\\n        ILBFlashLoanCallback indexed receiver,\\n        uint24 activeId,\\n        bytes32 amounts,\\n        bytes32 totalFees,\\n        bytes32 protocolFees\\n    );\\n\\n    event OracleLengthIncreased(address indexed sender, uint16 oracleLength);\\n\\n    event ForcedDecay(address indexed sender, uint24 idReference, uint24 volatilityReference);\\n\\n    function initialize(\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator,\\n        uint24 activeId\\n    ) external;\\n\\n    function getFactory() external view returns (ILBFactory factory);\\n\\n    function getTokenX() external view returns (IERC20 tokenX);\\n\\n    function getTokenY() external view returns (IERC20 tokenY);\\n\\n    function getBinStep() external view returns (uint16 binStep);\\n\\n    function getReserves() external view returns (uint128 reserveX, uint128 reserveY);\\n\\n    function getActiveId() external view returns (uint24 activeId);\\n\\n    function getBin(uint24 id) external view returns (uint128 binReserveX, uint128 binReserveY);\\n\\n    function getNextNonEmptyBin(bool swapForY, uint24 id) external view returns (uint24 nextId);\\n\\n    function getProtocolFees() external view returns (uint128 protocolFeeX, uint128 protocolFeeY);\\n\\n    function getStaticFeeParameters()\\n        external\\n        view\\n        returns (\\n            uint16 baseFactor,\\n            uint16 filterPeriod,\\n            uint16 decayPeriod,\\n            uint16 reductionFactor,\\n            uint24 variableFeeControl,\\n            uint16 protocolShare,\\n            uint24 maxVolatilityAccumulator\\n        );\\n\\n    function getVariableFeeParameters()\\n        external\\n        view\\n        returns (uint24 volatilityAccumulator, uint24 volatilityReference, uint24 idReference, uint40 timeOfLastUpdate);\\n\\n    function getOracleParameters()\\n        external\\n        view\\n        returns (uint8 sampleLifetime, uint16 size, uint16 activeSize, uint40 lastUpdated, uint40 firstTimestamp);\\n\\n    function getOracleSampleAt(uint40 lookupTimestamp)\\n        external\\n        view\\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed);\\n\\n    function getPriceFromId(uint24 id) external view returns (uint256 price);\\n\\n    function getIdFromPrice(uint256 price) external view returns (uint24 id);\\n\\n    function getSwapIn(uint128 amountOut, bool swapForY)\\n        external\\n        view\\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\\n\\n    function getSwapOut(uint128 amountIn, bool swapForY)\\n        external\\n        view\\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\\n\\n    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);\\n\\n    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\\n\\n    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\\n        external\\n        returns (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted);\\n\\n    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\\n        external\\n        returns (bytes32[] memory amounts);\\n\\n    function collectProtocolFees() external returns (bytes32 collectedProtocolFees);\\n\\n    function increaseOracleLength(uint16 newLength) external;\\n\\n    function setStaticFeeParameters(\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    ) external;\\n\\n    function forceDecay() external;\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/interfaces/ILBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nimport {ILBPair} from \\\"./ILBPair.sol\\\";\\nimport {IPendingOwnable} from \\\"./IPendingOwnable.sol\\\";\\n\\n/**\\n * @title Liquidity Book Factory Interface\\n * @author Trader Joe\\n * @notice Required interface of LBFactory contract\\n */\\ninterface ILBFactory is IPendingOwnable {\\n    error LBFactory__IdenticalAddresses(IERC20 token);\\n    error LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\\n    error LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\\n    error LBFactory__AddressZero();\\n    error LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\\n    error LBFactory__LBPairDoesNotExist(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\\n    error LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\\n    error LBFactory__FlashLoanFeeAboveMax(uint256 fees, uint256 maxFees);\\n    error LBFactory__BinStepTooLow(uint256 binStep);\\n    error LBFactory__PresetIsLockedForUsers(address user, uint256 binStep);\\n    error LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\\n    error LBFactory__BinStepHasNoPreset(uint256 binStep);\\n    error LBFactory__PresetOpenStateIsAlreadyInTheSameState();\\n    error LBFactory__SameFeeRecipient(address feeRecipient);\\n    error LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\\n    error LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\\n    error LBFactory__SameImplementation(address LBPairImplementation);\\n    error LBFactory__ImplementationNotSet();\\n\\n    /**\\n     * @dev Structure to store the LBPair information, such as:\\n     * binStep: The bin step of the LBPair\\n     * LBPair: The address of the LBPair\\n     * createdByOwner: Whether the pair was created by the owner of the factory\\n     * ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\\n     */\\n    struct LBPairInformation {\\n        uint16 binStep;\\n        ILBPair LBPair;\\n        bool createdByOwner;\\n        bool ignoredForRouting;\\n    }\\n\\n    event LBPairCreated(\\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBPair LBPair, uint256 pid\\n    );\\n\\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\\n\\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\\n\\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\\n\\n    event LBPairIgnoredStateChanged(ILBPair indexed LBPair, bool ignored);\\n\\n    event PresetSet(\\n        uint256 indexed binStep,\\n        uint256 baseFactor,\\n        uint256 filterPeriod,\\n        uint256 decayPeriod,\\n        uint256 reductionFactor,\\n        uint256 variableFeeControl,\\n        uint256 protocolShare,\\n        uint256 maxVolatilityAccumulator\\n    );\\n\\n    event PresetOpenStateChanged(uint256 indexed binStep, bool indexed isOpen);\\n\\n    event PresetRemoved(uint256 indexed binStep);\\n\\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\\n\\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\\n\\n    function getMinBinStep() external pure returns (uint256);\\n\\n    function getFeeRecipient() external view returns (address);\\n\\n    function getMaxFlashLoanFee() external pure returns (uint256);\\n\\n    function getFlashLoanFee() external view returns (uint256);\\n\\n    function getLBPairImplementation() external view returns (address);\\n\\n    function getNumberOfLBPairs() external view returns (uint256);\\n\\n    function getLBPairAtIndex(uint256 id) external returns (ILBPair);\\n\\n    function getNumberOfQuoteAssets() external view returns (uint256);\\n\\n    function getQuoteAssetAtIndex(uint256 index) external view returns (IERC20);\\n\\n    function isQuoteAsset(IERC20 token) external view returns (bool);\\n\\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\\n        external\\n        view\\n        returns (LBPairInformation memory);\\n\\n    function getPreset(uint256 binStep)\\n        external\\n        view\\n        returns (\\n            uint256 baseFactor,\\n            uint256 filterPeriod,\\n            uint256 decayPeriod,\\n            uint256 reductionFactor,\\n            uint256 variableFeeControl,\\n            uint256 protocolShare,\\n            uint256 maxAccumulator,\\n            bool isOpen\\n        );\\n\\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\\n\\n    function getOpenBinSteps() external view returns (uint256[] memory openBinStep);\\n\\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\\n        external\\n        view\\n        returns (LBPairInformation[] memory LBPairsBinStep);\\n\\n    function setLBPairImplementation(address lbPairImplementation) external;\\n\\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\\n        external\\n        returns (ILBPair pair);\\n\\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external;\\n\\n    function setPreset(\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator,\\n        bool isOpen\\n    ) external;\\n\\n    function setPresetOpenState(uint16 binStep, bool isOpen) external;\\n\\n    function removePreset(uint16 binStep) external;\\n\\n    function setFeesParametersOnPair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        uint16 baseFactor,\\n        uint16 filterPeriod,\\n        uint16 decayPeriod,\\n        uint16 reductionFactor,\\n        uint24 variableFeeControl,\\n        uint16 protocolShare,\\n        uint24 maxVolatilityAccumulator\\n    ) external;\\n\\n    function setFeeRecipient(address feeRecipient) external;\\n\\n    function setFlashLoanFee(uint256 flashLoanFee) external;\\n\\n    function addQuoteAsset(IERC20 quoteAsset) external;\\n\\n    function removeQuoteAsset(IERC20 quoteAsset) external;\\n\\n    function forceDecay(ILBPair lbPair) external;\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/libraries/math/LiquidityConfigurations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {PackedUint128Math} from \\\"./PackedUint128Math.sol\\\";\\nimport {Encoded} from \\\"./Encoded.sol\\\";\\n\\n/**\\n * @title Liquidity Book Liquidity Configurations Library\\n * @author Trader Joe\\n * @notice This library contains functions to encode and decode the config of a pool and interact with the encoded bytes32.\\n */\\nlibrary LiquidityConfigurations {\\n    using PackedUint128Math for bytes32;\\n    using PackedUint128Math for uint128;\\n    using Encoded for bytes32;\\n\\n    error LiquidityConfigurations__InvalidConfig();\\n\\n    uint256 private constant OFFSET_ID = 0;\\n    uint256 private constant OFFSET_DISTRIBUTION_Y = 24;\\n    uint256 private constant OFFSET_DISTRIBUTION_X = 88;\\n\\n    uint256 private constant PRECISION = 1e18;\\n\\n    /**\\n     * @dev Encode the distributionX, distributionY and id into a single bytes32\\n     * @param distributionX The distribution of the first token\\n     * @param distributionY The distribution of the second token\\n     * @param id The id of the pool\\n     * @return config The encoded config as follows:\\n     * [0 - 24[: id\\n     * [24 - 88[: distributionY\\n     * [88 - 152[: distributionX\\n     * [152 - 256[: empty\\n     */\\n    function encodeParams(uint64 distributionX, uint64 distributionY, uint24 id)\\n        internal\\n        pure\\n        returns (bytes32 config)\\n    {\\n        config = config.set(distributionX, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_X);\\n        config = config.set(distributionY, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_Y);\\n        config = config.set(id, Encoded.MASK_UINT24, OFFSET_ID);\\n    }\\n\\n    /**\\n     * @dev Decode the distributionX, distributionY and id from a single bytes32\\n     * @param config The encoded config as follows:\\n     * [0 - 24[: id\\n     * [24 - 88[: distributionY\\n     * [88 - 152[: distributionX\\n     * [152 - 256[: empty\\n     * @return distributionX The distribution of the first token\\n     * @return distributionY The distribution of the second token\\n     * @return id The id of the bin to add the liquidity to\\n     */\\n    function decodeParams(bytes32 config)\\n        internal\\n        pure\\n        returns (uint64 distributionX, uint64 distributionY, uint24 id)\\n    {\\n        distributionX = config.decodeUint64(OFFSET_DISTRIBUTION_X);\\n        distributionY = config.decodeUint64(OFFSET_DISTRIBUTION_Y);\\n        id = config.decodeUint24(OFFSET_ID);\\n\\n        if (uint256(config) > type(uint152).max || distributionX > PRECISION || distributionY > PRECISION) {\\n            revert LiquidityConfigurations__InvalidConfig();\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the amounts and id from a config and amountsIn\\n     * @param config The encoded config as follows:\\n     * [0 - 24[: id\\n     * [24 - 88[: distributionY\\n     * [88 - 152[: distributionX\\n     * [152 - 256[: empty\\n     * @param amountsIn The amounts to distribute as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @return amounts The distributed amounts as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @return id The id of the bin to add the liquidity to\\n     */\\n    function getAmountsAndId(bytes32 config, bytes32 amountsIn) internal pure returns (bytes32, uint24) {\\n        (uint64 distributionX, uint64 distributionY, uint24 id) = decodeParams(config);\\n\\n        (uint128 x1, uint128 x2) = amountsIn.decode();\\n\\n        assembly {\\n            x1 := div(mul(x1, distributionX), PRECISION)\\n            x2 := div(mul(x2, distributionY), PRECISION)\\n        }\\n\\n        return (x1.encode(x2), id);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Constants Library\\n * @author Trader Joe\\n * @notice Set of constants for Liquidity Book contracts\\n */\\nlibrary Constants {\\n    uint8 internal constant SCALE_OFFSET = 128;\\n    uint256 internal constant SCALE = 1 << SCALE_OFFSET;\\n\\n    uint256 internal constant PRECISION = 1e18;\\n    uint256 internal constant SQUARED_PRECISION = PRECISION * PRECISION;\\n\\n    uint256 internal constant MAX_FEE = 0.1e18; // 10%\\n    uint256 internal constant MAX_PROTOCOL_SHARE = 2_500; // 25% of the fee\\n\\n    uint256 internal constant BASIS_POINT_MAX = 10_000;\\n\\n    /// @dev The expected return after a successful flash loan\\n    bytes32 internal constant CALLBACK_SUCCESS = keccak256(\\\"LBPair.onFlashLoan\\\");\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/libraries/math/PackedUint128Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {Constants} from \\\"../Constants.sol\\\";\\n\\n/**\\n * @title Liquidity Book Packed Uint128 Math Library\\n * @author Trader Joe\\n * @notice This library contains functions to encode and decode two uint128 into a single bytes32\\n * and interact with the encoded bytes32.\\n */\\nlibrary PackedUint128Math {\\n    error PackedUint128Math__AddOverflow();\\n    error PackedUint128Math__SubUnderflow();\\n    error PackedUint128Math__MultiplierTooLarge();\\n\\n    uint256 private constant OFFSET = 128;\\n    uint256 private constant MASK_128 = 0xffffffffffffffffffffffffffffffff;\\n    uint256 private constant MASK_128_PLUS_ONE = MASK_128 + 1;\\n\\n    /**\\n     * @dev Encodes two uint128 into a single bytes32\\n     * @param x1 The first uint128\\n     * @param x2 The second uint128\\n     * @return z The encoded bytes32 as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     */\\n    function encode(uint128 x1, uint128 x2) internal pure returns (bytes32 z) {\\n        assembly {\\n            z := or(and(x1, MASK_128), shl(OFFSET, x2))\\n        }\\n    }\\n\\n    /**\\n     * @dev Encodes a uint128 into a single bytes32 as the first uint128\\n     * @param x1 The uint128\\n     * @return z The encoded bytes32 as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: empty\\n     */\\n    function encodeFirst(uint128 x1) internal pure returns (bytes32 z) {\\n        assembly {\\n            z := and(x1, MASK_128)\\n        }\\n    }\\n\\n    /**\\n     * @dev Encodes a uint128 into a single bytes32 as the second uint128\\n     * @param x2 The uint128\\n     * @return z The encoded bytes32 as follows:\\n     * [0 - 128[: empty\\n     * [128 - 256[: x2\\n     */\\n    function encodeSecond(uint128 x2) internal pure returns (bytes32 z) {\\n        assembly {\\n            z := shl(OFFSET, x2)\\n        }\\n    }\\n\\n    /**\\n     * @dev Encodes a uint128 into a single bytes32 as the first or second uint128\\n     * @param x The uint128\\n     * @param first Whether to encode as the first or second uint128\\n     * @return z The encoded bytes32 as follows:\\n     * if first:\\n     * [0 - 128[: x\\n     * [128 - 256[: empty\\n     * else:\\n     * [0 - 128[: empty\\n     * [128 - 256[: x\\n     */\\n    function encode(uint128 x, bool first) internal pure returns (bytes32 z) {\\n        return first ? encodeFirst(x) : encodeSecond(x);\\n    }\\n\\n    /**\\n     * @dev Decodes a bytes32 into two uint128\\n     * @param z The encoded bytes32 as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @return x1 The first uint128\\n     * @return x2 The second uint128\\n     */\\n    function decode(bytes32 z) internal pure returns (uint128 x1, uint128 x2) {\\n        assembly {\\n            x1 := and(z, MASK_128)\\n            x2 := shr(OFFSET, z)\\n        }\\n    }\\n\\n    /**\\n     * @dev Decodes a bytes32 into a uint128 as the first uint128\\n     * @param z The encoded bytes32 as follows:\\n     * [0 - 128[: x\\n     * [128 - 256[: any\\n     * @return x The first uint128\\n     */\\n    function decodeX(bytes32 z) internal pure returns (uint128 x) {\\n        assembly {\\n            x := and(z, MASK_128)\\n        }\\n    }\\n\\n    /**\\n     * @dev Decodes a bytes32 into a uint128 as the second uint128\\n     * @param z The encoded bytes32 as follows:\\n     * [0 - 128[: any\\n     * [128 - 256[: y\\n     * @return y The second uint128\\n     */\\n    function decodeY(bytes32 z) internal pure returns (uint128 y) {\\n        assembly {\\n            y := shr(OFFSET, z)\\n        }\\n    }\\n\\n    /**\\n     * @dev Decodes a bytes32 into a uint128 as the first or second uint128\\n     * @param z The encoded bytes32 as follows:\\n     * if first:\\n     * [0 - 128[: x1\\n     * [128 - 256[: empty\\n     * else:\\n     * [0 - 128[: empty\\n     * [128 - 256[: x2\\n     * @param first Whether to decode as the first or second uint128\\n     * @return x The decoded uint128\\n     */\\n    function decode(bytes32 z, bool first) internal pure returns (uint128 x) {\\n        return first ? decodeX(z) : decodeY(z);\\n    }\\n\\n    /**\\n     * @dev Adds two encoded bytes32, reverting on overflow on any of the uint128\\n     * @param x The first bytes32 encoded as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @param y The second bytes32 encoded as follows:\\n     * [0 - 128[: y1\\n     * [128 - 256[: y2\\n     * @return z The sum of x and y encoded as follows:\\n     * [0 - 128[: x1 + y1\\n     * [128 - 256[: x2 + y2\\n     */\\n    function add(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\\n        assembly {\\n            z := add(x, y)\\n        }\\n\\n        if (z < x || uint128(uint256(z)) < uint128(uint256(x))) {\\n            revert PackedUint128Math__AddOverflow();\\n        }\\n    }\\n\\n    /**\\n     * @dev Adds an encoded bytes32 and two uint128, reverting on overflow on any of the uint128\\n     * @param x The bytes32 encoded as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @param y1 The first uint128\\n     * @param y2 The second uint128\\n     * @return z The sum of x and y encoded as follows:\\n     * [0 - 128[: x1 + y1\\n     * [128 - 256[: x2 + y2\\n     */\\n    function add(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\\n        return add(x, encode(y1, y2));\\n    }\\n\\n    /**\\n     * @dev Subtracts two encoded bytes32, reverting on underflow on any of the uint128\\n     * @param x The first bytes32 encoded as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @param y The second bytes32 encoded as follows:\\n     * [0 - 128[: y1\\n     * [128 - 256[: y2\\n     * @return z The difference of x and y encoded as follows:\\n     * [0 - 128[: x1 - y1\\n     * [128 - 256[: x2 - y2\\n     */\\n    function sub(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\\n        assembly {\\n            z := sub(x, y)\\n        }\\n\\n        if (z > x || uint128(uint256(z)) > uint128(uint256(x))) {\\n            revert PackedUint128Math__SubUnderflow();\\n        }\\n    }\\n\\n    /**\\n     * @dev Subtracts an encoded bytes32 and two uint128, reverting on underflow on any of the uint128\\n     * @param x The bytes32 encoded as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @param y1 The first uint128\\n     * @param y2 The second uint128\\n     * @return z The difference of x and y encoded as follows:\\n     * [0 - 128[: x1 - y1\\n     * [128 - 256[: x2 - y2\\n     */\\n    function sub(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\\n        return sub(x, encode(y1, y2));\\n    }\\n\\n    /**\\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\\n     * @param x The first bytes32 encoded as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @param y The second bytes32 encoded as follows:\\n     * [0 - 128[: y1\\n     * [128 - 256[: y2\\n     * @return x1 < y1 || x2 < y2\\n     */\\n    function lt(bytes32 x, bytes32 y) internal pure returns (bool) {\\n        (uint128 x1, uint128 x2) = decode(x);\\n        (uint128 y1, uint128 y2) = decode(y);\\n\\n        return x1 < y1 || x2 < y2;\\n    }\\n\\n    /**\\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\\n     * @param x The first bytes32 encoded as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @param y The second bytes32 encoded as follows:\\n     * [0 - 128[: y1\\n     * [128 - 256[: y2\\n     * @return x1 < y1 || x2 < y2\\n     */\\n    function gt(bytes32 x, bytes32 y) internal pure returns (bool) {\\n        (uint128 x1, uint128 x2) = decode(x);\\n        (uint128 y1, uint128 y2) = decode(y);\\n\\n        return x1 > y1 || x2 > y2;\\n    }\\n\\n    /**\\n     * @dev Multiplies an encoded bytes32 by a uint128 then divides the result by 10_000, rounding down\\n     * The result can't overflow as the multiplier needs to be smaller or equal to 10_000\\n     * @param x The bytes32 encoded as follows:\\n     * [0 - 128[: x1\\n     * [128 - 256[: x2\\n     * @param multiplier The uint128 to multiply by (must be smaller or equal to 10_000)\\n     * @return z The product of x and multiplier encoded as follows:\\n     * [0 - 128[: floor((x1 * multiplier) / 10_000)\\n     * [128 - 256[: floor((x2 * multiplier) / 10_000)\\n     */\\n    function scalarMulDivBasisPointRoundDown(bytes32 x, uint128 multiplier) internal pure returns (bytes32 z) {\\n        if (multiplier == 0) return 0;\\n\\n        uint256 BASIS_POINT_MAX = Constants.BASIS_POINT_MAX;\\n        if (multiplier > BASIS_POINT_MAX) revert PackedUint128Math__MultiplierTooLarge();\\n\\n        (uint128 x1, uint128 x2) = decode(x);\\n\\n        assembly {\\n            x1 := div(mul(x1, multiplier), BASIS_POINT_MAX)\\n            x2 := div(mul(x2, multiplier), BASIS_POINT_MAX)\\n        }\\n\\n        return encode(x1, x2);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/libraries/math/Uint256x256Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Uint256x256 Math Library\\n * @author Trader Joe\\n * @notice Helper contract used for full precision calculations\\n */\\nlibrary Uint256x256Math {\\n    error Uint256x256Math__MulShiftOverflow();\\n    error Uint256x256Math__MulDivOverflow();\\n\\n    /**\\n     * @notice Calculates floor(x*y/denominator) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The denominator cannot be zero\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function mulDivRoundDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\\n\\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\\n    }\\n\\n    /**\\n     * @notice Calculates ceil(x*y/denominator) with full precision\\n     * The result will be rounded up\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The denominator cannot be zero\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function mulDivRoundUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        result = mulDivRoundDown(x, y, denominator);\\n        if (mulmod(x, y, denominator) != 0) result += 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / 2**offset) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param offset The offset as an uint256, can't be greater than 256\\n     * @return result The result as an uint256\\n     */\\n    function mulShiftRoundDown(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\\n\\n        if (prod0 != 0) result = prod0 >> offset;\\n        if (prod1 != 0) {\\n            // Make sure the result is less than 2^256.\\n            if (prod1 >= 1 << offset) revert Uint256x256Math__MulShiftOverflow();\\n\\n            unchecked {\\n                result += prod1 << (256 - offset);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / 2**offset) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param offset The offset as an uint256, can't be greater than 256\\n     * @return result The result as an uint256\\n     */\\n    function mulShiftRoundUp(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\\n        result = mulShiftRoundDown(x, y, offset);\\n        if (mulmod(x, y, 1 << offset) != 0) result += 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x << offset / y) with full precision\\n     * The result will be rounded down\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param offset The number of bit to shift x as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function shiftDivRoundDown(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n\\n        prod0 = x << offset; // Least significant 256 bits of the product\\n        unchecked {\\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\\n        }\\n\\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\\n    }\\n\\n    /**\\n     * @notice Calculates ceil(x << offset / y) with full precision\\n     * The result will be rounded up\\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n     * Requirements:\\n     * - The offset needs to be strictly lower than 256\\n     * - The result must fit within uint256\\n     * Caveats:\\n     * - This function does not work with fixed-point numbers\\n     * @param x The multiplicand as an uint256\\n     * @param offset The number of bit to shift x as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @return result The result as an uint256\\n     */\\n    function shiftDivRoundUp(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\\n        result = shiftDivRoundDown(x, offset, denominator);\\n        if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\\n    }\\n\\n    /**\\n     * @notice Helper function to return the result of `x * y` as 2 uint256\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @return prod0 The least significant 256 bits of the product\\n     * @return prod1 The most significant 256 bits of the product\\n     */\\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to return the result of `x * y / denominator` with full precision\\n     * @param x The multiplicand as an uint256\\n     * @param y The multiplier as an uint256\\n     * @param denominator The divisor as an uint256\\n     * @param prod0 The least significant 256 bits of the product\\n     * @param prod1 The most significant 256 bits of the product\\n     * @return result The result as an uint256\\n     */\\n    function _getEndOfDivRoundDown(uint256 x, uint256 y, uint256 denominator, uint256 prod0, uint256 prod1)\\n        private\\n        pure\\n        returns (uint256 result)\\n    {\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n        } else {\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\\n            if (prod1 >= denominator) revert Uint256x256Math__MulDivOverflow();\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\\n            // See https://cs.stackexchange.com/q/138556/92363\\n            unchecked {\\n                // Does not overflow because the denominator cannot be zero at this stage in the function\\n                uint256 lpotdod = denominator & (~denominator + 1);\\n                assembly {\\n                    // Divide denominator by lpotdod.\\n                    denominator := div(denominator, lpotdod)\\n\\n                    // Divide [prod1 prod0] by lpotdod.\\n                    prod0 := div(prod0, lpotdod)\\n\\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n                }\\n\\n                // Shift in bits from prod1 into prod0\\n                prod0 |= prod1 * lpotdod;\\n\\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n                // four bits. That is, denominator * inv = 1 mod 2^4\\n                uint256 inverse = (3 * denominator) ^ 2;\\n\\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n                // in modular arithmetic, doubling the correct bits in each step\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n                // is no longer required.\\n                result = prod0 * inverse;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/libraries/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Safe Cast Library\\n * @author Trader Joe\\n * @notice This library contains functions to safely cast uint256 to different uint types.\\n */\\nlibrary SafeCast {\\n    error SafeCast__Exceeds248Bits();\\n    error SafeCast__Exceeds240Bits();\\n    error SafeCast__Exceeds232Bits();\\n    error SafeCast__Exceeds224Bits();\\n    error SafeCast__Exceeds216Bits();\\n    error SafeCast__Exceeds208Bits();\\n    error SafeCast__Exceeds200Bits();\\n    error SafeCast__Exceeds192Bits();\\n    error SafeCast__Exceeds184Bits();\\n    error SafeCast__Exceeds176Bits();\\n    error SafeCast__Exceeds168Bits();\\n    error SafeCast__Exceeds160Bits();\\n    error SafeCast__Exceeds152Bits();\\n    error SafeCast__Exceeds144Bits();\\n    error SafeCast__Exceeds136Bits();\\n    error SafeCast__Exceeds128Bits();\\n    error SafeCast__Exceeds120Bits();\\n    error SafeCast__Exceeds112Bits();\\n    error SafeCast__Exceeds104Bits();\\n    error SafeCast__Exceeds96Bits();\\n    error SafeCast__Exceeds88Bits();\\n    error SafeCast__Exceeds80Bits();\\n    error SafeCast__Exceeds72Bits();\\n    error SafeCast__Exceeds64Bits();\\n    error SafeCast__Exceeds56Bits();\\n    error SafeCast__Exceeds48Bits();\\n    error SafeCast__Exceeds40Bits();\\n    error SafeCast__Exceeds32Bits();\\n    error SafeCast__Exceeds24Bits();\\n    error SafeCast__Exceeds16Bits();\\n    error SafeCast__Exceeds8Bits();\\n\\n    /**\\n     * @dev Returns x on uint248 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint248\\n     */\\n    function safe248(uint256 x) internal pure returns (uint248 y) {\\n        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint240 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint240\\n     */\\n    function safe240(uint256 x) internal pure returns (uint240 y) {\\n        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint232 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint232\\n     */\\n    function safe232(uint256 x) internal pure returns (uint232 y) {\\n        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint224 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint224\\n     */\\n    function safe224(uint256 x) internal pure returns (uint224 y) {\\n        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint216 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint216\\n     */\\n    function safe216(uint256 x) internal pure returns (uint216 y) {\\n        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint208 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint208\\n     */\\n    function safe208(uint256 x) internal pure returns (uint208 y) {\\n        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint200 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint200\\n     */\\n    function safe200(uint256 x) internal pure returns (uint200 y) {\\n        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint192 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint192\\n     */\\n    function safe192(uint256 x) internal pure returns (uint192 y) {\\n        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint184 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint184\\n     */\\n    function safe184(uint256 x) internal pure returns (uint184 y) {\\n        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint176 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint176\\n     */\\n    function safe176(uint256 x) internal pure returns (uint176 y) {\\n        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint168 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint168\\n     */\\n    function safe168(uint256 x) internal pure returns (uint168 y) {\\n        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint160 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint160\\n     */\\n    function safe160(uint256 x) internal pure returns (uint160 y) {\\n        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint152 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint152\\n     */\\n    function safe152(uint256 x) internal pure returns (uint152 y) {\\n        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint144 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint144\\n     */\\n    function safe144(uint256 x) internal pure returns (uint144 y) {\\n        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint136 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint136\\n     */\\n    function safe136(uint256 x) internal pure returns (uint136 y) {\\n        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint128 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint128\\n     */\\n    function safe128(uint256 x) internal pure returns (uint128 y) {\\n        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint120 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint120\\n     */\\n    function safe120(uint256 x) internal pure returns (uint120 y) {\\n        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint112 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint112\\n     */\\n    function safe112(uint256 x) internal pure returns (uint112 y) {\\n        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint104 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint104\\n     */\\n    function safe104(uint256 x) internal pure returns (uint104 y) {\\n        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint96 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint96\\n     */\\n    function safe96(uint256 x) internal pure returns (uint96 y) {\\n        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint88 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint88\\n     */\\n    function safe88(uint256 x) internal pure returns (uint88 y) {\\n        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint80 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint80\\n     */\\n    function safe80(uint256 x) internal pure returns (uint80 y) {\\n        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint72 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint72\\n     */\\n    function safe72(uint256 x) internal pure returns (uint72 y) {\\n        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint64 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint64\\n     */\\n    function safe64(uint256 x) internal pure returns (uint64 y) {\\n        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint56 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint56\\n     */\\n    function safe56(uint256 x) internal pure returns (uint56 y) {\\n        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint48 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint48\\n     */\\n    function safe48(uint256 x) internal pure returns (uint48 y) {\\n        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint40 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint40\\n     */\\n    function safe40(uint256 x) internal pure returns (uint40 y) {\\n        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint32 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint32\\n     */\\n    function safe32(uint256 x) internal pure returns (uint32 y) {\\n        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint24 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint24\\n     */\\n    function safe24(uint256 x) internal pure returns (uint24 y) {\\n        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint16 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint16\\n     */\\n    function safe16(uint256 x) internal pure returns (uint16 y) {\\n        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits();\\n    }\\n\\n    /**\\n     * @dev Returns x on uint8 and check that it does not overflow\\n     * @param x The value as an uint256\\n     * @return y The value as an uint8\\n     */\\n    function safe8(uint256 x) internal pure returns (uint8 y) {\\n        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/interfaces/IWNATIVE.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title WNATIVE Interface\\n * @notice Required interface of Wrapped NATIVE contract\\n */\\ninterface IWNATIVE is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILimitOrderManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport {ILBPair} from \\\"joe-v2/interfaces/ILBPair.sol\\\";\\nimport {ILBFactory} from \\\"joe-v2/interfaces/ILBFactory.sol\\\";\\n\\n/**\\n * @title Limit Order Manager Interface\\n * @author Trader Joe\\n * @notice Interface to interact with the Limit Order Manager contract\\n */\\ninterface ILimitOrderManager {\\n    error LimitOrderManager__ZeroAddress();\\n    error LimitOrderManager__ZeroAmount();\\n    error LimitOrderManager__TransferFailed();\\n    error LimitOrderManager__InsufficientWithdrawalAmounts();\\n    error LimitOrderManager__InvalidPair();\\n    error LimitOrderManager__InvalidBatchLength();\\n    error LimitOrderManager__InvalidTokenOrder();\\n    error LimitOrderManager__InvalidNativeAmount();\\n    error LimitOrderManager__InvalidExecutorFeeShare();\\n    error LimitOrderManager__OrderAlreadyExecuted();\\n    error LimitOrderManager__OrderNotClaimable();\\n    error LimitOrderManager__OrderNotPlaced();\\n    error LimitOrderManager__OrderNotExecutable();\\n    error LimitOrderManager__OnlyWNative();\\n    error LimitOrderManager__OnlyFactoryOwner();\\n\\n    /**\\n     * @dev Order type,\\n     * BID: buy tokenX with tokenY\\n     * ASK: sell tokenX for tokenY\\n     */\\n    enum OrderType {\\n        BID,\\n        ASK\\n    }\\n\\n    /**\\n     * @dev Order structure:\\n     * - positionId: The position id of the order, used to identify to which position the order belongs\\n     * - liquidity: The amount of liquidity in the order\\n     */\\n    struct Order {\\n        uint256 positionId;\\n        uint256 liquidity;\\n    }\\n\\n    /**\\n     * @dev Positions structure:\\n     * - lastId: The last position id\\n     * - at: The positions, indexed by position id\\n     * We use a mapping instead of an array as we need to be able to query the last position id\\n     * to know if a position exists or not, which would be impossible with an array.\\n     */\\n    struct Positions {\\n        uint256 lastId;\\n        mapping(uint256 => Position) at;\\n    }\\n\\n    /**\\n     * @dev Position structure:\\n     * - liquidity: The amount of liquidity in the position, it is the sum of the liquidity of all orders\\n     * - amount: The amount of token after the execution of the position, once the orders are executed\\n     * - withdrawn: Whether the position has been withdrawn or not\\n     */\\n    struct Position {\\n        uint256 liquidity;\\n        uint128 amount;\\n        bool withdrawn;\\n    }\\n\\n    /**\\n     * @dev Place order params structure, used to place multiple orders in a single transaction.\\n     */\\n    struct PlaceOrderParams {\\n        IERC20 tokenX;\\n        IERC20 tokenY;\\n        uint16 binStep;\\n        OrderType orderType;\\n        uint24 binId;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @dev Cancel order params structure, used to cancel multiple orders in a single transaction.\\n     */\\n    struct CancelOrderParams {\\n        IERC20 tokenX;\\n        IERC20 tokenY;\\n        uint16 binStep;\\n        OrderType orderType;\\n        uint24 binId;\\n        uint256 minAmountX;\\n        uint256 minAmountY;\\n    }\\n\\n    /**\\n     * @dev Order params structure, used to cancel, claim and execute multiple orders in a single transaction.\\n     */\\n    struct OrderParams {\\n        IERC20 tokenX;\\n        IERC20 tokenY;\\n        uint16 binStep;\\n        OrderType orderType;\\n        uint24 binId;\\n    }\\n\\n    /**\\n     * @dev Place order params structure for the same LB pair, used to place multiple orders in a single transaction\\n     * for the same LB pair\\n     */\\n    struct PlaceOrderParamsSamePair {\\n        OrderType orderType;\\n        uint24 binId;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @dev Cancel order params structure for the same LB pair, used to cancel multiple orders in a single transaction\\n     * for the same LB pair\\n     */\\n    struct CancelOrderParamsSamePair {\\n        OrderType orderType;\\n        uint24 binId;\\n        uint256 minAmountX;\\n        uint256 minAmountY;\\n    }\\n\\n    /**\\n     * @dev Order params structure for the same LB pair, used to cancel, claim and execute multiple orders in a single\\n     * transaction for the same LB pair\\n     */\\n    struct OrderParamsSamePair {\\n        OrderType orderType;\\n        uint24 binId;\\n    }\\n\\n    event OrderPlaced(\\n        address indexed user,\\n        ILBPair indexed lbPair,\\n        uint24 indexed binId,\\n        OrderType orderType,\\n        uint256 positionId,\\n        uint256 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    event OrderCancelled(\\n        address indexed user,\\n        ILBPair indexed lbPair,\\n        uint24 indexed binId,\\n        OrderType orderType,\\n        uint256 positionId,\\n        uint256 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    event OrderClaimed(\\n        address indexed user,\\n        ILBPair indexed lbPair,\\n        uint24 indexed binId,\\n        OrderType orderType,\\n        uint256 positionId,\\n        uint256 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    event OrderExecuted(\\n        address indexed sender,\\n        ILBPair indexed lbPair,\\n        uint24 indexed binId,\\n        OrderType orderType,\\n        uint256 positionId,\\n        uint256 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    event ExecutionFeePaid(address indexed executor, IERC20 tokenX, IERC20 tokenY, uint256 amountX, uint256 amountY);\\n\\n    event ExecutorFeeShareSet(uint256 executorFeeShare);\\n\\n    function name() external pure returns (string memory);\\n\\n    function getFactory() external view returns (ILBFactory);\\n\\n    function getWNative() external view returns (IERC20);\\n\\n    function getExecutorFeeShare() external view returns (uint256);\\n\\n    function getOrder(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId, address user)\\n        external\\n        view\\n        returns (Order memory);\\n\\n    function getLastPositionId(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPosition(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderType orderType,\\n        uint24 binId,\\n        uint256 positionId\\n    ) external view returns (Position memory);\\n\\n    function isOrderExecutable(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getCurrentAmounts(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderType orderType,\\n        uint24 binId,\\n        address user\\n    ) external view returns (uint256 amountX, uint256 amountY, uint256 feeX, uint256 feeY);\\n\\n    function getExecutionFee(IERC20 tokenX, IERC20 tokenY, uint16 binStep) external view returns (uint256 fee);\\n\\n    function placeOrder(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId, uint256 amount)\\n        external\\n        payable\\n        returns (bool orderPlaced, uint256 orderPositionId);\\n\\n    function cancelOrder(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderType orderType,\\n        uint24 binId,\\n        uint256 minAmountX,\\n        uint256 minAmountY\\n    ) external returns (uint256 orderPositionId);\\n\\n    function claimOrder(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        returns (uint256 orderPositionId);\\n\\n    function executeOrders(IERC20 tokenX, IERC20 tokenY, uint16 binStep, OrderType orderType, uint24 binId)\\n        external\\n        returns (bool orderExecuted, uint256 positionId);\\n\\n    function batchPlaceOrders(PlaceOrderParams[] calldata orders)\\n        external\\n        payable\\n        returns (bool[] memory orderPlaced, uint256[] memory positionIds);\\n\\n    function batchCancelOrders(CancelOrderParams[] calldata orders) external returns (uint256[] memory positionIds);\\n\\n    function batchClaimOrders(OrderParams[] calldata orders) external returns (uint256[] memory positionIds);\\n\\n    function batchExecuteOrders(OrderParams[] calldata orders)\\n        external\\n        returns (bool[] memory orderExecuted, uint256[] memory positionIds);\\n\\n    function batchPlaceOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        PlaceOrderParamsSamePair[] calldata orders\\n    ) external payable returns (bool[] memory orderPlaced, uint256[] memory positionIds);\\n\\n    function batchCancelOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        CancelOrderParamsSamePair[] calldata orders\\n    ) external returns (uint256[] memory positionIds);\\n\\n    function batchClaimOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderParamsSamePair[] calldata orders\\n    ) external returns (uint256[] memory positionIds);\\n\\n    function batchExecuteOrdersSamePair(\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        uint16 binStep,\\n        OrderParamsSamePair[] calldata orders\\n    ) external returns (bool[] memory orderExecuted, uint256[] memory positionIds);\\n\\n    function setExecutorFeeShare(uint256 executorFeeShare) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/interfaces/ILBFlashLoanCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Liquidity Book Flashloan Callback Interface\\n/// @author Trader Joe\\n/// @notice Required interface to interact with LB flash loans\\ninterface ILBFlashLoanCallback {\\n    function LBFlashLoanCallback(\\n        address sender,\\n        IERC20 tokenX,\\n        IERC20 tokenY,\\n        bytes32 amounts,\\n        bytes32 totalFees,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/interfaces/ILBToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Token Interface\\n * @author Trader Joe\\n * @notice Interface to interact with the LBToken.\\n */\\ninterface ILBToken {\\n    error LBToken__AddressThisOrZero();\\n    error LBToken__InvalidLength();\\n    error LBToken__SelfApproval(address owner);\\n    error LBToken__SpenderNotApproved(address from, address spender);\\n    error LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\\n    error LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\\n\\n    event TransferBatch(\\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\\n\\n    function approveForAll(address spender, bool approved) external;\\n\\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/interfaces/IPendingOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Pending Ownable Interface\\n * @author Trader Joe\\n * @notice Required interface of Pending Ownable contract used for LBFactory\\n */\\ninterface IPendingOwnable {\\n    error PendingOwnable__AddressZero();\\n    error PendingOwnable__NoPendingOwner();\\n    error PendingOwnable__NotOwner();\\n    error PendingOwnable__NotPendingOwner();\\n    error PendingOwnable__PendingOwnerAlreadySet();\\n\\n    event PendingOwnerSet(address indexed pendingOwner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function setPendingOwner(address pendingOwner) external;\\n\\n    function revokePendingOwner() external;\\n\\n    function becomeOwner() external;\\n\\n    function renounceOwnership() external;\\n}\\n\"\r\n    },\r\n    \"lib/joe-v2/src/libraries/math/Encoded.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Liquidity Book Encoded Library\\n * @author Trader Joe\\n * @notice Helper contract used for decoding bytes32 sample\\n */\\nlibrary Encoded {\\n    uint256 internal constant MASK_UINT1 = 0x1;\\n    uint256 internal constant MASK_UINT8 = 0xff;\\n    uint256 internal constant MASK_UINT12 = 0xfff;\\n    uint256 internal constant MASK_UINT14 = 0x3fff;\\n    uint256 internal constant MASK_UINT16 = 0xffff;\\n    uint256 internal constant MASK_UINT20 = 0xfffff;\\n    uint256 internal constant MASK_UINT24 = 0xffffff;\\n    uint256 internal constant MASK_UINT40 = 0xffffffffff;\\n    uint256 internal constant MASK_UINT64 = 0xffffffffffffffff;\\n    uint256 internal constant MASK_UINT128 = 0xffffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Internal function to set a value in an encoded bytes32 using a mask and offset\\n     * @dev This function can overflow\\n     * @param encoded The previous encoded value\\n     * @param value The value to encode\\n     * @param mask The mask\\n     * @param offset The offset\\n     * @return newEncoded The new encoded value\\n     */\\n    function set(bytes32 encoded, uint256 value, uint256 mask, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes32 newEncoded)\\n    {\\n        assembly {\\n            newEncoded := and(encoded, not(shl(offset, mask)))\\n            newEncoded := or(newEncoded, shl(offset, and(value, mask)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to set a bool in an encoded bytes32 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The previous encoded value\\n     * @param boolean The bool to encode\\n     * @param offset The offset\\n     * @return newEncoded The new encoded value\\n     */\\n    function setBool(bytes32 encoded, bool boolean, uint256 offset) internal pure returns (bytes32 newEncoded) {\\n        return set(encoded, boolean ? 1 : 0, MASK_UINT1, offset);\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample using a mask and offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param mask The mask\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decode(bytes32 encoded, uint256 mask, uint256 offset) internal pure returns (uint256 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a bool using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return boolean The decoded value as a bool\\n     */\\n    function decodeBool(bytes32 encoded, uint256 offset) internal pure returns (bool boolean) {\\n        assembly {\\n            boolean := and(shr(offset, encoded), MASK_UINT1)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint8 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint8(bytes32 encoded, uint256 offset) internal pure returns (uint8 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT8)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint12 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value as a uint16, since uint12 is not supported\\n     */\\n    function decodeUint12(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT12)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint14 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value as a uint16, since uint14 is not supported\\n     */\\n    function decodeUint14(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT14)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint16 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint16(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT16)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint20 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value as a uint24, since uint20 is not supported\\n     */\\n    function decodeUint20(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT20)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint24 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint24(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT24)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint40 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint40(bytes32 encoded, uint256 offset) internal pure returns (uint40 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT40)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint64 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint64(bytes32 encoded, uint256 offset) internal pure returns (uint64 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT64)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to decode a bytes32 sample into a uint128 using an offset\\n     * @dev This function can overflow\\n     * @param encoded The encoded value\\n     * @param offset The offset\\n     * @return value The decoded value\\n     */\\n    function decodeUint128(bytes32 encoded, uint256 offset) internal pure returns (uint128 value) {\\n        assembly {\\n            value := and(shr(offset, encoded), MASK_UINT128)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/joe-v2/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"joe-v2/=lib/joe-v2/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ILBFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract IWNATIVE\",\"name\":\"wNative\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LimitOrderManager__InsufficientWithdrawalAmounts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__InvalidBatchLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__InvalidExecutorFeeShare\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__InvalidNativeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__InvalidPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__InvalidTokenOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__OnlyFactoryOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__OnlyWNative\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__OrderAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__OrderNotClaimable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__OrderNotExecutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__OrderNotPlaced\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrderManager__ZeroAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PackedUint128Math__SubUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeCast__Exceeds128Bits\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Uint256x256Math__MulDivOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"ExecutionFeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executorFeeShare\",\"type\":\"uint256\"}],\"name\":\"ExecutorFeeShareSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ILBPair\",\"name\":\"lbPair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ILBPair\",\"name\":\"lbPair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"OrderClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ILBPair\",\"name\":\"lbPair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ILBPair\",\"name\":\"lbPair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"name\":\"OrderPlaced\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"minAmountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountY\",\"type\":\"uint256\"}],\"internalType\":\"struct ILimitOrderManager.CancelOrderParams[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchCancelOrders\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"minAmountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountY\",\"type\":\"uint256\"}],\"internalType\":\"struct ILimitOrderManager.CancelOrderParamsSamePair[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchCancelOrdersSamePair\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"internalType\":\"struct ILimitOrderManager.OrderParams[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchClaimOrders\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"internalType\":\"struct ILimitOrderManager.OrderParamsSamePair[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchClaimOrdersSamePair\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"internalType\":\"struct ILimitOrderManager.OrderParams[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchExecuteOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"orderExecuted\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"internalType\":\"struct ILimitOrderManager.OrderParamsSamePair[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchExecuteOrdersSamePair\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"orderExecuted\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ILimitOrderManager.PlaceOrderParams[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchPlaceOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"orderPlaced\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ILimitOrderManager.PlaceOrderParamsSamePair[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"batchPlaceOrdersSamePair\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"orderPlaced\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"orderPositionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"minAmountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountY\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderPositionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"name\":\"claimOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderPositionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"name\":\"executeOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getCurrentAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionFeeX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionFeeY\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"}],\"name\":\"getExecutionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutorFeeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFactory\",\"outputs\":[{\"internalType\":\"contract ILBFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"name\":\"getLastPositionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"internalType\":\"struct ILimitOrderManager.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"}],\"internalType\":\"struct ILimitOrderManager.Position\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWNative\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"}],\"name\":\"isOrderExecutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"binStep\",\"type\":\"uint16\"},{\"internalType\":\"enum ILimitOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"binId\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"placeOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"orderPlaced\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderPositionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"executorFeeShare\",\"type\":\"uint256\"}],\"name\":\"setExecutorFeeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LimitOrderManager", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008e42f2f4101563bf679975178e880fd87d3efd4e000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}