{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract BitFineDAPP is Ownable {\r\n\r\n    IDEXRouter public router;\r\n\r\n    address constant zero = address(0);\r\n    address constant dead = address(0xdead);\r\n\r\n    uint256 public minimumDeposit = 25 * 1e16;\r\n    \r\n    uint256 maxProfitPercent = 20000;\r\n\r\n    uint256[] ROIAmount = [30,70,110,150,200];\r\n    uint256[] ROIRequirement = [0,1,3,10,25];\r\n\r\n    uint256[] topWinnerReward = [1500,3500,5000];\r\n    uint256[] referralAmount = [500,100,75,50,25];\r\n\r\n    uint256[] withdrawFee = [3500,2000,1000];\r\n    uint256[] withdrawFilter = [0,1e17,1e18];\r\n\r\n    address tokenAddress = 0x07D675Fa3C17259E6F2999A998ec099Ae27aeee1;\r\n    uint256 depositFeeToTop3 = 250;\r\n    uint256 depositFeeToSwap = 250;\r\n\r\n    address treasuryWallet = 0xDfa46f9fdFa76bEcB20ccf023879E4521a010d6E;\r\n    address[] marketingWallet = [0x6F6d6E7D05EF8C87f50183b017133037D891a6A9,0x0EbEC1DC1877003EEd15431f15352eC868A5D971,0x33bf98f8ae9009b9c2cD57BfD0dD838D4668eFa5];\r\n    uint256 depositFeeToMarketing = 600;\r\n    uint256 withdrawFeeToTreasury = 5000;\r\n\r\n    uint day = 86400;\r\n    uint256 denominator = 10000;\r\n\r\n    address[] users;\r\n\r\n    struct userData {\r\n        uint256 balance;\r\n        uint256 unclaimROI;\r\n        uint256 commission;\r\n        uint256 withdraw;\r\n        uint256 actionBlock;\r\n        address referral;\r\n        mapping(uint256 => address[]) referee;\r\n        mapping(uint256 => uint256) claimed;\r\n        mapping(uint256 => uint256) receiveETH;\r\n        bool registered;\r\n    }\r\n\r\n    mapping(address => userData) user;\r\n\r\n    uint256 genesisBlock;\r\n\r\n    struct Top3Data {\r\n        address[] account;\r\n        uint256[] amount;\r\n        uint256 reward;\r\n        bool init;\r\n    }\r\n\r\n    struct Top3Winner {\r\n        address[] account;\r\n        uint256[] amount;\r\n    }\r\n\r\n    mapping(uint256 => Top3Data) top3;\r\n    mapping(uint256 => Top3Winner) top3Winner;\r\n    mapping(address => mapping(uint256 => uint256)) public top3Key;\r\n    mapping(address => mapping(uint256 => bool)) public isTopAdsigned;\r\n    mapping(address => mapping(uint256 => bool)) public isTopClaimed;\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor() {\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        register(msg.sender,zero,referralAmount.length);\r\n        genesisBlock = block.timestamp;\r\n    }\r\n\r\n    function getUsers() public view returns (address[] memory) {\r\n        return users;\r\n    }\r\n\r\n    function getTop3WinnerReward() public view returns (uint256[] memory) {\r\n        return topWinnerReward;\r\n    }\r\n\r\n    function getTop3Winner(uint256 round) public view returns (address[] memory,uint256[] memory) {\r\n        return (top3Winner[round].account,top3Winner[round].amount);\r\n    }\r\n\r\n    function getUserData(address account) public view returns\r\n    (   uint256 balance_,\r\n        uint256 unclaimROI_,\r\n        uint256 commission_,\r\n        uint256 withdraw_,\r\n        uint256 actionBlock_,\r\n        address referral_,\r\n        bool registered_\r\n    ) {\r\n        return (\r\n            user[account].balance,\r\n            user[account].unclaimROI,\r\n            user[account].commission,\r\n            user[account].withdraw,\r\n            user[account].actionBlock,\r\n            user[account].referral,\r\n            user[account].registered\r\n        );\r\n    }\r\n\r\n    function getTop3Data(uint256 round) public view returns\r\n    (\r\n        address[] memory account_,\r\n        uint256[] memory amount_,\r\n        uint256 reward_,\r\n        bool init_\r\n    ) {\r\n        return (\r\n            top3[round].account,\r\n            top3[round].amount,\r\n            top3[round].reward,\r\n            top3[round].init\r\n        );\r\n    }\r\n\r\n    function getUserRefereeMapping(address account,uint256 deeplevel) public view returns (address[] memory) {\r\n        return user[account].referee[deeplevel];\r\n    }\r\n\r\n    function getUserReferralMapping(address account,uint256 upperlevel) public view returns (address[] memory) {\r\n        address[] memory referrals = new address[](upperlevel);\r\n        for(uint256 i=0; i<upperlevel; i++){\r\n            referrals[i] = user[account].referral;\r\n            account = user[account].referral;\r\n        }\r\n        return referrals;\r\n    }\r\n\r\n    function getUserClaimed(address account,uint256 slot) public view returns (uint256) {\r\n        return (user[account].claimed[slot]);\r\n    }\r\n\r\n    function getReceiveETH(address account,uint256 slot) public view returns (uint256) {\r\n        return (user[account].receiveETH[slot]);\r\n    }\r\n\r\n    function register(address referee,address referral,uint256 deepLevel) internal {\r\n        if(!user[referee].registered){\r\n            user[referee].registered = true;\r\n            user[referee].referral = referral;\r\n            users.push(referee);\r\n            for(uint256 i = 0; i < deepLevel; i++){\r\n                if(!isDeadAddress(referral)){\r\n                    user[referral].referee[i].push(referee);\r\n                }\r\n                referral = user[referral].referral;\r\n            }\r\n        }\r\n    }\r\n\r\n    function deposit(address referee,address referral) public payable noReentrant returns (bool) {\r\n        require(msg.value>=minimumDeposit,\"BitFine Revert: Need More ETH For Deposit\");\r\n        if(!user[referee].registered){\r\n            require(user[referral].registered,\"BitFine Revert: Referral Address Must Be Registered\");\r\n            require(referee!=referral,\"BitFine Revert: Referee Must Not Be Referral\");\r\n            claimInternal(referral);\r\n            register(referee,referral,referralAmount.length);\r\n        }\r\n        claimInternal(referee);\r\n        address[] memory upline = new address[](referralAmount.length);\r\n        upline = getUserReferralMapping(referee,referralAmount.length);\r\n        updateTop3Amount(upline[0],msg.value);\r\n        uint256 amountToSplit = getFeeAmount(msg.value,depositFeeToMarketing,denominator)/marketingWallet.length;\r\n        for(uint256 i = 0; i < marketingWallet.length; i++){\r\n            sendValue(marketingWallet[i],amountToSplit);\r\n        }\r\n        autoLiquidity(getFeeAmount(msg.value,depositFeeToSwap,denominator));\r\n        for(uint256 i = 0; i < referralAmount.length; i++){\r\n            uint256 receiveETH = getFeeAmount(msg.value,referralAmount[i],denominator);\r\n            uint256 toCommission = getNonOverpayAmount(upline[i],receiveETH);\r\n            user[upline[i]].commission += toCommission;\r\n            user[upline[i]].receiveETH[i] += toCommission;\r\n        }\r\n        user[referee].balance += msg.value;\r\n        return true;\r\n    }\r\n\r\n    function updateTop3Amount(address account,uint256 amount) internal {\r\n        uint256 round = getCurrentRound();\r\n        if(!top3[round].init){\r\n            top3[round].init = true;\r\n            top3Winner[round].account = new address[](topWinnerReward.length);\r\n            top3Winner[round].amount = new uint256[](topWinnerReward.length);\r\n        }\r\n        top3[round].reward += amount;\r\n        if(!isTopAdsigned[account][round]){\r\n            top3[round].account.push(account);\r\n            top3[round].amount.push(amount);\r\n            isTopAdsigned[account][round] = true;\r\n            top3Key[account][round] = top3[round].account.length - 1;\r\n        }else{\r\n            top3[round].amount[top3Key[account][round]] += amount;\r\n        }\r\n        uint256 score = top3[round].amount[top3Key[account][round]];\r\n        (bool isWinner,uint256 index) = isTopWinner(account,round);\r\n        if(isWinner){\r\n            top3Winner[round].account[index] = account;\r\n            top3Winner[round].amount[index] = score;\r\n        }else{\r\n            for (uint256 i = 0; i < topWinnerReward.length ; i++) {\r\n                if(score > top3Winner[round].amount[i]){\r\n                    top3Winner[round].account[i] = account;\r\n                    top3Winner[round].amount[i] = score;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        sortWinnerData(round);\r\n    }\r\n\r\n    function isTopWinner(address account,uint256 round) public view returns (bool,uint256) {\r\n        if(top3Winner[round].account.length>0){\r\n            for (uint256 i = 0; i < top3Winner[round].account.length ; i++) {\r\n                if(top3Winner[round].account[i]==account){\r\n                    return (true,i);\r\n                }\r\n            }\r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n    function sortWinnerData(uint256 round) internal {\r\n        for (uint256 i = 1; i < topWinnerReward.length; i++) {\r\n            address addr = top3Winner[round].account[i];\r\n            uint256 key = top3Winner[round].amount[i];\r\n            int j = int(i) - 1;\r\n            while ((int(j) >= 0) && (top3Winner[round].amount[uint256(j)] > key)) {\r\n                top3Winner[round].account[uint256(j+1)] = top3Winner[round].account[uint256(j)];\r\n                top3Winner[round].amount[uint256(j+1)] = top3Winner[round].amount[uint256(j)];\r\n                j--;\r\n            }\r\n            top3Winner[round].account[uint256(j+1)] = addr;\r\n            top3Winner[round].amount[uint256(j+1)] = key;\r\n        }\r\n    }\r\n\r\n    function getCurrentRound() public view returns (uint256) {\r\n        if(block.timestamp>genesisBlock){\r\n            uint256 period = block.timestamp - genesisBlock;\r\n            return period / day;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function autoLiquidity(uint256 amount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = tokenAddress;\r\n        try router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amount / 2 }(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        ) {} catch {}\r\n\r\n        uint256 amountTokenDesired = IERC20(tokenAddress).balanceOf(address(this));\r\n        IERC20(tokenAddress).approve(address(router),amountTokenDesired);\r\n\r\n        try router.addLiquidityETH{ value: amount / 2 }(\r\n            tokenAddress,\r\n            amountTokenDesired,\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        ) {} catch {}\r\n    }\r\n\r\n    function getROI(address account) public view returns (uint256) {\r\n        uint256 i = ROIRequirement.length - 1;\r\n        do{\r\n            if(user[account].referee[0].length>=ROIRequirement[i]){\r\n                return ROIAmount[i];\r\n            }\r\n            i--;\r\n        }while(i>0);\r\n        return ROIAmount[0];\r\n    }\r\n\r\n    function claimROI(address account) external noReentrant returns (bool) {\r\n        claimInternal(account);\r\n        uint256 unclaimROI = user[account].unclaimROI;\r\n        uint256 amountToWithdraw = takeFeeAmount(unclaimROI,getWithdrawFee(unclaimROI),denominator);\r\n        uint256 amountToMarketing = getFeeAmount(unclaimROI,getWithdrawFee(unclaimROI),denominator);\r\n        uint256 amountToTreasury = getFeeAmount(amountToMarketing,withdrawFeeToTreasury,denominator);\r\n        uint256 amountToSplit = (amountToMarketing - amountToTreasury) / marketingWallet.length;\r\n        user[account].unclaimROI = 0;\r\n        user[account].withdraw += amountToWithdraw;\r\n        user[account].claimed[0] += amountToWithdraw;\r\n        sendValue(account,amountToWithdraw);\r\n        sendValue(treasuryWallet,amountToTreasury);\r\n        for(uint256 i = 0; i < marketingWallet.length; i++){\r\n            sendValue(marketingWallet[i],amountToSplit);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function claimCommission(address account) external noReentrant returns (bool) {\r\n        uint256 commission = user[account].commission;\r\n        user[account].commission = 0;\r\n        user[account].withdraw += commission;\r\n        user[account].claimed[1] += commission;\r\n        sendValue(account,commission);\r\n        return true;\r\n    }\r\n\r\n    function claimTop3Reward(address account,uint256 round) external noReentrant returns (bool) {\r\n        require(!isTopClaimed[account][round],\"BitFine Revert: This Account Was Claimed\");\r\n        require(getCurrentRound()>round,\"BitFine Revert: This Round Was Not Ended\");\r\n        isTopClaimed[account][round] = true;\r\n        bool isWinner;\r\n        uint256 index;\r\n        for(uint256 i = 0; i < topWinnerReward.length; i++){\r\n            if(account==top3Winner[round].account[i]){\r\n                isWinner = true; index = i;\r\n                break;\r\n            }\r\n        }\r\n        require(isWinner,\"BitFine Revert: This Account Does Not Win This Round\");\r\n        uint256 rewardToBeClaim = top3[round].reward * topWinnerReward[index] / denominator;\r\n        user[account].claimed[2] += rewardToBeClaim;\r\n        sendValue(account,rewardToBeClaim);\r\n        return true;\r\n    }\r\n\r\n    function claimInternal(address account) internal {\r\n        uint256 toClaimAmount = getROIRewards(account);\r\n        user[account].actionBlock = block.timestamp;\r\n        user[account].unclaimROI += toClaimAmount;\r\n    }\r\n\r\n    function getAccountReward(address account) public view returns (uint256) {\r\n        return getROIRewards(account) + user[account].unclaimROI;\r\n    }\r\n\r\n    function getROIRewards(address account) public view returns (uint256) {\r\n        if(user[account].actionBlock>0){\r\n            uint256 period = block.timestamp - user[account].actionBlock;\r\n            uint256 ROI = user[account].balance * getROI(account) / denominator;\r\n            uint256 reward = ROI * period / day;\r\n            return getNonOverpayAmount(account,reward);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getNonOverpayAmount(address account,uint256 amount) internal view returns (uint256) {\r\n        if(getLimitAmount(account) + amount > getMaxEarnAmount(account)){\r\n            return getMaxEarnAmount(account) - getLimitAmount(account);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function getMaxEarnAmount(address account) internal view returns (uint256) {\r\n        return user[account].balance * maxProfitPercent / 10000;\r\n    }\r\n\r\n    function getLimitAmount(address account) internal view returns (uint256) {\r\n        return user[account].withdraw + user[account].unclaimROI + user[account].commission;\r\n    }\r\n\r\n    function getmaxProfitPercent() public view returns (uint256) {\r\n        return maxProfitPercent;\r\n    }\r\n\r\n    function getReferralAmount() public view returns (uint256[] memory) {\r\n        return referralAmount;\r\n    }\r\n\r\n    function getWithdrawFees() public view returns (uint256[] memory,uint256[] memory) {\r\n        return (withdrawFee,withdrawFilter);\r\n    }\r\n\r\n    function getROIAmount() public view returns (uint256[] memory,uint256[] memory) {\r\n        return (ROIAmount,ROIRequirement);\r\n    }\r\n\r\n    function getMarketingFees() public view returns \r\n    (\r\n        address treasuryWallet_,\r\n        address[] memory marketingWallet_,\r\n        uint256 depositFeeToTop3_,\r\n        uint256 depositFeeToMarketing_,\r\n        uint256 withdrawFeeToTreasury_\r\n    ) {\r\n        return (\r\n            treasuryWallet,\r\n            marketingWallet,\r\n            depositFeeToTop3,\r\n            depositFeeToMarketing,\r\n            withdrawFeeToTreasury\r\n        );\r\n    }\r\n\r\n    function getExternalReacts() public view returns \r\n    (\r\n        address tokenAddress_,\r\n        uint256 depositFeeToSwap_\r\n    ) {\r\n        return (\r\n            tokenAddress,\r\n            depositFeeToSwap\r\n        );\r\n    }\r\n\r\n    function updateGenesisBlock(uint256 blockstamp) public onlyOwner returns (bool) {\r\n        genesisBlock = blockstamp;\r\n        return true;\r\n    }\r\n\r\n    function updateMinimumDeposit(uint256 amountETH) public onlyOwner returns (bool) {\r\n        minimumDeposit = amountETH;\r\n        return true;\r\n    }\r\n\r\n    function updateMaxProfitPercent(uint256 maxProfit) public onlyOwner returns (bool) {\r\n        maxProfitPercent = maxProfit;\r\n        return true;\r\n    }\r\n\r\n    function updateReferralAmount(uint256[] memory amounts) public onlyOwner returns (bool) {\r\n        referralAmount = amounts;\r\n        return true;\r\n    }\r\n\r\n    function updateROIAmount(uint256[] memory amounts,uint256[] memory requirements) public onlyOwner returns (bool) {\r\n        ROIAmount = amounts;\r\n        ROIRequirement = requirements;\r\n        return true;\r\n    }\r\n\r\n    function updateWithdrawFees(uint256[] memory fees,uint256[] memory filters) public onlyOwner returns (bool) {\r\n        withdrawFee = fees;\r\n        withdrawFilter = filters;\r\n        return true;\r\n    }\r\n\r\n    function updateMarketingWallet(address treasury,address[] memory marketing,uint256 feeTop,uint256 feeDeposit,uint256 feeTreasury) public onlyOwner returns (bool) {\r\n        treasuryWallet = treasury;\r\n        marketingWallet = marketing;\r\n        depositFeeToTop3 = feeTop;\r\n        depositFeeToMarketing = feeDeposit;\r\n        withdrawFeeToTreasury = feeTreasury;\r\n        return true;\r\n    }\r\n\r\n    function updateExternalReacts(address token,uint256 feeSwap) public onlyOwner returns (bool) {\r\n        tokenAddress = token;\r\n        depositFeeToSwap = feeSwap;\r\n        return true;\r\n    }\r\n\r\n    function updateTopWinnerReward(uint256[] memory rewards) public onlyOwner returns (bool) {\r\n        topWinnerReward = rewards;\r\n        return true;\r\n    }\r\n\r\n    function getWithdrawFee(uint256 amount) internal view returns (uint256) {\r\n        uint256 i = withdrawFilter.length - 1;\r\n        do{\r\n            if(amount>=withdrawFilter[i]){\r\n                return withdrawFee[i];\r\n            }\r\n            i--;\r\n        }while(i>0);\r\n        return withdrawFee[0];\r\n    }\r\n\r\n    function getFeeAmount(uint256 amount,uint256 fee,uint256 deno) internal pure returns (uint256) {\r\n        return amount * fee / deno;\r\n    }\r\n\r\n    function takeFeeAmount(uint256 amount,uint256 fee,uint256 deno) internal pure returns (uint256) {\r\n        return amount - getFeeAmount(amount,fee,deno);\r\n    }\r\n\r\n    function isDeadAddress(address account) internal pure returns (bool) {\r\n        if(account == zero || account == dead){ return true; }\r\n        return false;\r\n    }\r\n\r\n    function callWithData(address to,bytes memory data) public onlyOwner returns (bytes memory) {\r\n        (bool success,bytes memory result) = to.call(data);\r\n        require(success);\r\n        return result;\r\n    }\r\n\r\n    function callWithValue(address to,bytes memory data,uint256 amount) public onlyOwner returns (bytes memory) {\r\n        (bool success,bytes memory result) = to.call{ value: amount }(data);\r\n        require(success);\r\n        return result;\r\n    }\r\n\r\n    function sendValue(address to,uint256 amount) internal {\r\n        if(!isDeadAddress(to) && amount > 0){\r\n            (bool success,) = to.call{ value: amount }(\"\");\r\n            require(success,\"BitFine Revert: Fail To Send ETH\");\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callWithData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"callWithValue\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimCommission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimROI\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"claimTop3Reward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExternalReacts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositFeeToSwap_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketingFees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"treasuryWallet_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"marketingWallet_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"depositFeeToTop3_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFeeToMarketing_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFeeToTreasury_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getROIAmount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getROIRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getReceiveETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReferralAmount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getTop3Data\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"account_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"init_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getTop3Winner\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTop3WinnerReward\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getUserClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unclaimROI_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actionBlock_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"registered_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deeplevel\",\"type\":\"uint256\"}],\"name\":\"getUserRefereeMapping\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"upperlevel\",\"type\":\"uint256\"}],\"name\":\"getUserReferralMapping\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawFees\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getmaxProfitPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTopAdsigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTopClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"isTopWinner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"top3Key\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeSwap\",\"type\":\"uint256\"}],\"name\":\"updateExternalReacts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockstamp\",\"type\":\"uint256\"}],\"name\":\"updateGenesisBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"marketing\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"feeTop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTreasury\",\"type\":\"uint256\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxProfit\",\"type\":\"uint256\"}],\"name\":\"updateMaxProfitPercent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"updateMinimumDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"requirements\",\"type\":\"uint256[]\"}],\"name\":\"updateROIAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"updateReferralAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"}],\"name\":\"updateTopWinnerReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"filters\",\"type\":\"uint256[]\"}],\"name\":\"updateWithdrawFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BitFineDAPP", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://20099e8e6dc745ace3779611081e115a67de8136b133e9fdd0552313343fcafe"}