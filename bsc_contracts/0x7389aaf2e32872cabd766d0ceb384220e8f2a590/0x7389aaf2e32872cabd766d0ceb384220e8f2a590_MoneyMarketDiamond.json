{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248) {\\n        require(value >= type(int248).min && value <= type(int248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return int248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240) {\\n        require(value >= type(int240).min && value <= type(int240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return int240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232) {\\n        require(value >= type(int232).min && value <= type(int232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return int232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224) {\\n        require(value >= type(int224).min && value <= type(int224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return int224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216) {\\n        require(value >= type(int216).min && value <= type(int216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return int216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208) {\\n        require(value >= type(int208).min && value <= type(int208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return int208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200) {\\n        require(value >= type(int200).min && value <= type(int200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return int200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192) {\\n        require(value >= type(int192).min && value <= type(int192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return int192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184) {\\n        require(value >= type(int184).min && value <= type(int184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return int184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176) {\\n        require(value >= type(int176).min && value <= type(int176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return int176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168) {\\n        require(value >= type(int168).min && value <= type(int168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return int168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160) {\\n        require(value >= type(int160).min && value <= type(int160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return int160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152) {\\n        require(value >= type(int152).min && value <= type(int152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return int152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144) {\\n        require(value >= type(int144).min && value <= type(int144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return int144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136) {\\n        require(value >= type(int136).min && value <= type(int136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return int136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120) {\\n        require(value >= type(int120).min && value <= type(int120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return int120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112) {\\n        require(value >= type(int112).min && value <= type(int112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return int112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104) {\\n        require(value >= type(int104).min && value <= type(int104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return int104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96) {\\n        require(value >= type(int96).min && value <= type(int96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return int96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88) {\\n        require(value >= type(int88).min && value <= type(int88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return int88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80) {\\n        require(value >= type(int80).min && value <= type(int80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return int80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72) {\\n        require(value >= type(int72).min && value <= type(int72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return int72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56) {\\n        require(value >= type(int56).min && value <= type(int56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return int56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48) {\\n        require(value >= type(int48).min && value <= type(int48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return int48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40) {\\n        require(value >= type(int40).min && value <= type(int40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return int40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24) {\\n        require(value >= type(int24).min && value <= type(int24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return int24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/MoneyMarketDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// interfaces\\nimport { IMMDiamondLoupe } from \\\"./interfaces/IMMDiamondLoupe.sol\\\";\\nimport { IMMDiamondCut } from \\\"./interfaces/IMMDiamondCut.sol\\\";\\nimport { IMiniFL } from \\\"./interfaces/IMiniFL.sol\\\";\\nimport { IERC173 } from \\\"./interfaces/IERC173.sol\\\";\\nimport { IERC165 } from \\\"./interfaces/IERC165.sol\\\";\\n\\n// libraries\\nimport { LibDiamond } from \\\"./libraries/LibDiamond.sol\\\";\\nimport { LibMoneyMarket01 } from \\\"./libraries/LibMoneyMarket01.sol\\\";\\n\\ncontract MoneyMarketDiamond {\\n  error MoneyMarketDiamond_InvalidAddress();\\n\\n  constructor(address _diamondCutFacet, address _miniFL) {\\n    // set contract owner\\n    LibDiamond.setContractOwner(msg.sender);\\n\\n    // register DiamondCut facet\\n    IMMDiamondCut.FacetCut[] memory cut = new IMMDiamondCut.FacetCut[](1);\\n    bytes4[] memory functionSelectors = new bytes4[](1);\\n    functionSelectors[0] = IMMDiamondCut.diamondCut.selector;\\n    cut[0] = IMMDiamondCut.FacetCut({\\n      facetAddress: _diamondCutFacet,\\n      action: IMMDiamondCut.FacetCutAction.Add,\\n      functionSelectors: functionSelectors\\n    });\\n    LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n\\n    // adding ERC165 data\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n    ds.supportedInterfaces[type(IMMDiamondCut).interfaceId] = true;\\n    ds.supportedInterfaces[type(IMMDiamondLoupe).interfaceId] = true;\\n    ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n\\n    // initialize money market states\\n    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs = LibMoneyMarket01.moneyMarketDiamondStorage();\\n    moneyMarketDs.miniFL = IMiniFL(_miniFL);\\n  }\\n\\n  // Find facet for function that is called and execute the\\n  // function if a facet is found and return any value.\\n  fallback() external payable {\\n    LibDiamond.DiamondStorage storage ds;\\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n    // get diamond storage\\n    assembly {\\n      ds.slot := position\\n    }\\n    // get facet from function selector\\n    address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n    require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n    // Execute external function from facet using delegatecall and return any value.\\n    assembly {\\n      // copy function selector and any arguments\\n      calldatacopy(0, 0, calldatasize())\\n      // execute function call using the facet\\n      let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n      // get any return value\\n      returndatacopy(0, 0, returndatasize())\\n      // return any return value or error back to the caller\\n      switch result\\n      case 0 {\\n        revert(0, returndatasize())\\n      }\\n      default {\\n        return(0, returndatasize())\\n      }\\n    }\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IAlpacaV2Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\ninterface IAlpacaV2Oracle {\\n  /// @dev Errors\\n  error AlpacaV2Oracle_InvalidLPAddress();\\n  error AlpacaV2Oracle_InvalidOracleAddress();\\n\\n  /// @dev Return value in USD for the given lpAmount.\\n  function lpToDollar(uint256 _lpAmount, address _lpToken) external view returns (uint256, uint256);\\n\\n  /// @dev Return amount of LP for the given USD.\\n  function dollarToLp(uint256 _dollarAmount, address _lpToken) external view returns (uint256, uint256);\\n\\n  /// @dev Return value of given token in USD.\\n  function getTokenPrice(address _token) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\ninterface IDebtToken {\\n  error DebtToken_UnApprovedHolder();\\n  error DebtToken_NoSelfTransfer();\\n\\n  function initialize(address asset_, address moneyMarket_) external;\\n\\n  function setOkHolders(address[] calldata _okHolders, bool _isOk) external;\\n\\n  function mint(address to, uint256 amount) external;\\n\\n  function burn(address from, uint256 amount) external;\\n\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IERC165 {\\n  /// @notice Query if a contract implements an interface\\n  /// @param interfaceId The interface identifier, as specified in ERC-165\\n  /// @dev Interface identification is specified in ERC-165. This function\\n  ///  uses less than 30,000 gas.\\n  /// @return `true` if the contract implements `interfaceID` and\\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n  /// @dev This emits when ownership of a contract changes.\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /// @notice Get the address of the owner\\n  /// @return owner_ The address of the owner.\\n  function owner() external view returns (address owner_);\\n\\n  /// @notice Set the address of the new owner of the contract\\n  /// @dev Set _newOwner to address(0) to renounce any ownership.\\n  /// @param _newOwner The address of the new owner of the contract\\n  function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IERC20 {\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IFeeModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\ninterface IFeeModel {\\n  function getFeeBps(uint256 _total, uint256 _used) external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IInterestBearingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\n\\ninterface IInterestBearingToken is IERC20 {\\n  function initialize(address underlying_, address owner_) external;\\n\\n  function onDeposit(\\n    address receiver,\\n    uint256 assets,\\n    uint256 shares\\n  ) external;\\n\\n  function onWithdraw(\\n    address owner,\\n    address receiver,\\n    uint256 assets,\\n    uint256 shares\\n  ) external;\\n\\n  function decimals() external view returns (uint8);\\n\\n  function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n  function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\ninterface IInterestRateModel {\\n  function getInterestRate(uint256 debt, uint256 floating) external view returns (uint256);\\n\\n  function CEIL_SLOPE_1() external view returns (uint256);\\n\\n  function CEIL_SLOPE_2() external view returns (uint256);\\n\\n  function CEIL_SLOPE_3() external view returns (uint256);\\n\\n  function MAX_INTEREST_SLOPE_1() external view returns (uint256);\\n\\n  function MAX_INTEREST_SLOPE_2() external view returns (uint256);\\n\\n  function MAX_INTEREST_SLOPE_3() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IMMDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IMMDiamondCut {\\n  enum FacetCutAction {\\n    Add,\\n    Replace,\\n    Remove\\n  }\\n  // Add=0, Replace=1, Remove=2\\n\\n  struct FacetCut {\\n    address facetAddress;\\n    FacetCutAction action;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IMMDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IMMDiamondLoupe {\\n  /// These functions are expected to be called frequently\\n  /// by tools.\\n\\n  struct Facet {\\n    address facetAddress;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Gets all facet addresses and their four byte function selectors.\\n  /// @return facets_ Facet\\n  function facets() external view returns (Facet[] memory facets_);\\n\\n  /// @notice Gets all the function selectors supported by a specific facet.\\n  /// @param _facet The facet address.\\n  /// @return facetFunctionSelectors_\\n  function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n  /// @notice Get all the facet addresses used by a diamond.\\n  /// @return facetAddresses_\\n  function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n  /// @notice Gets the facet that supports the given selector.\\n  /// @dev If facet is not found return address(0).\\n  /// @param _functionSelector The function selector.\\n  /// @return facetAddress_ The facet address.\\n  function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/interfaces/IMiniFL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IMiniFL {\\n  function poolLength() external view returns (uint256);\\n\\n  function totalAllocPoint() external view returns (uint256);\\n\\n  function alpacaPerSecond() external view returns (uint256);\\n\\n  function getUserTotalAmountOf(uint256 _pid, address _user) external view returns (uint256 _totalAmount);\\n\\n  function getPoolAllocPoint(uint256 _pid) external view returns (uint256 _allocPoint);\\n\\n  function getStakingReserves(uint256 _pid) external view returns (uint256 _reserveAmount);\\n\\n  function pendingAlpaca(uint256 _pid, address _user) external view returns (uint256);\\n\\n  function getUserAmountFundedBy(\\n    address _funder,\\n    address _for,\\n    uint256 _pid\\n  ) external view returns (uint256 _stakingAmount);\\n\\n  function addPool(\\n    uint256 _allocPoint,\\n    address _stakingToken,\\n    bool _withUpdate\\n  ) external returns (uint256 _pid);\\n\\n  function deposit(\\n    address _for,\\n    uint256 _pid,\\n    uint256 _amountToDeposit\\n  ) external;\\n\\n  function withdraw(\\n    address _from,\\n    uint256 _pid,\\n    uint256 _amountToWithdraw\\n  ) external;\\n\\n  function harvest(uint256 _pid) external;\\n\\n  function harvestMany(uint256[] calldata _pids) external;\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/libraries/LibConstant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\nlibrary LibConstant {\\n  enum AssetTier {\\n    UNLISTED,\\n    ISOLATE,\\n    CROSS,\\n    COLLATERAL\\n  }\\n\\n  struct TokenConfig {\\n    AssetTier tier;\\n    uint16 collateralFactor;\\n    uint16 borrowingFactor;\\n    uint64 to18ConversionFactor;\\n    uint256 maxCollateral;\\n    uint256 maxBorrow; // shared global limit\\n  }\\n\\n  uint256 internal constant MAX_BPS = 10000;\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IMMDiamondCut } from \\\"../interfaces/IMMDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n  struct FacetAddressAndPosition {\\n    address facetAddress;\\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n  }\\n\\n  struct FacetFunctionSelectors {\\n    bytes4[] functionSelectors;\\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n  }\\n\\n  struct DiamondStorage {\\n    // maps function selector to the facet address and\\n    // the position of the selector in the facetFunctionSelectors.selectors array\\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n    // maps facet addresses to function selectors\\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n    // facet addresses\\n    address[] facetAddresses;\\n    // Used to query if a contract implements an interface.\\n    // Used to implement ERC-165.\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    // owner of the contract\\n    address contractOwner;\\n    address pendingOwner;\\n  }\\n\\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function setContractOwner(address _newOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    address previousOwner = ds.contractOwner;\\n    ds.contractOwner = _newOwner;\\n    emit OwnershipTransferred(previousOwner, _newOwner);\\n  }\\n\\n  function setPendingOwner(address _newPendingOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    ds.pendingOwner = _newPendingOwner;\\n  }\\n\\n  function contractOwner() internal view returns (address contractOwner_) {\\n    contractOwner_ = diamondStorage().contractOwner;\\n  }\\n\\n  function pendingOwner() internal view returns (address pendingOwner_) {\\n    pendingOwner_ = diamondStorage().pendingOwner;\\n  }\\n\\n  function enforceIsContractOwner() internal view {\\n    require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n  }\\n\\n  event DiamondCut(IMMDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  // Internal function version of diamondCut\\n  function diamondCut(\\n    IMMDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n      IMMDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n      if (action == IMMDiamondCut.FacetCutAction.Add) {\\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else if (action == IMMDiamondCut.FacetCutAction.Replace) {\\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else if (action == IMMDiamondCut.FacetCutAction.Remove) {\\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else {\\n        revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n      }\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n      removeFunction(ds, oldFacetAddress, selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    // if function does not exist then do nothing and return\\n    require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      removeFunction(ds, oldFacetAddress, selector);\\n    }\\n  }\\n\\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n    enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n    ds.facetAddresses.push(_facetAddress);\\n  }\\n\\n  function addFunction(\\n    DiamondStorage storage ds,\\n    bytes4 _selector,\\n    uint96 _selectorPosition,\\n    address _facetAddress\\n  ) internal {\\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n  }\\n\\n  function removeFunction(\\n    DiamondStorage storage ds,\\n    address _facetAddress,\\n    bytes4 _selector\\n  ) internal {\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n    // an immutable function is a function defined directly in a diamond\\n    require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n    // replace selector with last selector, then delete last selector\\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n    // if not the same then replace _selector with lastSelector\\n    if (selectorPosition != lastSelectorPosition) {\\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n    }\\n    // delete the last selector\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n    delete ds.selectorToFacetAndPosition[_selector];\\n\\n    // if no more selectors for facet address then delete the facet address\\n    if (lastSelectorPosition == 0) {\\n      // replace facet address with last facet address and delete last facet address\\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n      if (facetAddressPosition != lastFacetAddressPosition) {\\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n      }\\n      ds.facetAddresses.pop();\\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n    }\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n    if (_init == address(0)) {\\n      return;\\n    }\\n    enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n      if (error.length > 0) {\\n        // bubble up error\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n          let returndata_size := mload(error)\\n          revert(add(32, error), returndata_size)\\n        }\\n      } else {\\n        revert InitializationFunctionReverted(_init, _calldata);\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_contract)\\n    }\\n    require(contractSize > 0, _errorMessage);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/libraries/LibDoublyLinkedList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\nlibrary LibDoublyLinkedList {\\n  error LibDoublyLinkedList_Existed();\\n  error LibDoublyLinkedList_NotExisted();\\n  error LibDoublyLinkedList_NotInitialized();\\n\\n  address internal constant START = address(1);\\n  address internal constant END = address(1);\\n  address internal constant EMPTY = address(0);\\n\\n  struct List {\\n    uint256 size;\\n    mapping(address => address) next;\\n    mapping(address => uint256) amount;\\n    mapping(address => address) prev;\\n  }\\n\\n  struct Node {\\n    address token;\\n    uint256 amount;\\n  }\\n\\n  function initIfNotExist(List storage list) internal {\\n    // 1(START) <> 0(EMPTY)\\n    // 1(START).next = 1(END)\\n    // 1(END).prev = 1(START)\\n    // 1(START) <> 1(END)\\n    if (list.next[START] == EMPTY) {\\n      list.next[START] = END;\\n      list.prev[END] = START;\\n    }\\n  }\\n\\n  function has(List storage list, address addr) internal view returns (bool) {\\n    return list.next[addr] != EMPTY;\\n  }\\n\\n  /// @dev removing will cut `addr` from the link\\n  /// ex. `addr` is BTC\\n  ///     START <> ETH <> BTC <> END => START <> ETH <> END\\n  function updateOrRemove(\\n    List storage list,\\n    address addr,\\n    uint256 amount\\n  ) internal {\\n    address nextOfAddr = list.next[addr];\\n\\n    // Check\\n    if (nextOfAddr == EMPTY) {\\n      revert LibDoublyLinkedList_NotExisted();\\n    }\\n\\n    // Effect\\n    // skip removing if `amount` still remain\\n    //\\n    // ex. remove BTC:\\n    //  START   = 1\\n    //  BTC     = 2 (assume)\\n    //  ETH     = 3 (assume)\\n    //  END     = 1\\n    //  [Current link]: 1 <> 3 <> 2 <> 1\\n    //\\n    //  `addr` = 2, since removing BTC\\n    //  prevOfAddr = 3\\n    //  nextOfAddr = 1\\n    //\\n    //  Step 1: 3(prevOfAddr).next  = 1   -->   1 <- 3 -> 1\\n    //  Step 2: 1(nextOfAddr).prev  = 3   -->   3 <- 1 -> 0\\n    //  [Current link]: 1 <> 3 <> 1\\n    //\\n    //  Step 3: 2.prev = 0    -->   0 <- 2 -> 1\\n    //  Step 4: 2.next = 0    -->   0 <- 2 -> 0\\n    //  [Current link]: 1 <> 3 <> 1\\n    if (amount == 0) {\\n      address prevOfAddr = list.prev[addr];\\n\\n      // cut the node from current link\\n      // step 1: set next of (prev of `addr`) to be next of `addr`\\n      list.next[prevOfAddr] = nextOfAddr;\\n      // step 2: set prev of (next of `addr`) to be prev of `addr`\\n      list.prev[nextOfAddr] = prevOfAddr;\\n\\n      // cut current link from the node\\n      // step 3: set next of `addr` to be EMPTY\\n      list.next[addr] = EMPTY;\\n      // step 4: set prev of `addr` to be EMPTY\\n      list.prev[addr] = EMPTY;\\n\\n      --list.size;\\n    }\\n\\n    list.amount[addr] = amount;\\n  }\\n\\n  /// @dev adding will put `addr` after `START`\\n  /// ex. START <> BTC <> END => START <> addr <> BTC <> END\\n  function addOrUpdate(\\n    List storage list,\\n    address addr,\\n    uint256 amount\\n  ) internal {\\n    // Check\\n    // prevent create empty node\\n    if (amount == 0) {\\n      return;\\n    }\\n\\n    // Effect\\n    // skip adding if `addr` already existed\\n    //\\n    // ex. add `addr`:\\n    //  START   = 1\\n    //  BTC     = 2 (assume)\\n    //  END     = 1\\n    //  [Current link]: 1 <> 2 <> 1\\n    //\\n    //  `addr`  = 3 (assume)\\n    //  Initial of 3  -->  0 <- 3 -> 0\\n    //\\n    //  Step 1: 3.next  = 2   -->   0 <- 3 -> 2\\n    //  Step 2: 2.prev  = 3   -->   3 <- 2 -> 1\\n    //  [Current link]: 0 <> 3 <> 2 <> 1\\n    //\\n    //  Step 3: 3.prev = 1    -->   1 <- 3 -> 2\\n    //  Step 4: 1.next = 3    -->   0 <- 1 -> 3\\n    //  [Current link]: 1 <> 3 <> 2 <> 1\\n    if (!has(list, addr)) {\\n      // add `addr` to the link after `START`\\n      address nextOfStart = list.next[START];\\n      // step 1: set next of `addr` to be next of `START`\\n      list.next[addr] = nextOfStart;\\n      // step 2: set prev of next of `START` to be `addr`\\n      list.prev[nextOfStart] = addr;\\n\\n      // step 3: set prev of `addr` to be `START`\\n      list.prev[addr] = START;\\n      // step 4: set next of `START` to be `addr`\\n      list.next[START] = addr;\\n\\n      unchecked {\\n        ++list.size;\\n      }\\n    }\\n\\n    list.amount[addr] = amount;\\n  }\\n\\n  function getAmount(List storage list, address addr) internal view returns (uint256) {\\n    return list.amount[addr];\\n  }\\n\\n  function getAll(List storage list) internal view returns (Node[] memory) {\\n    Node[] memory nodes = new Node[](list.size);\\n    if (list.size == 0) {\\n      return nodes;\\n    }\\n    address curr = list.next[START];\\n    for (uint256 i; curr != END; ) {\\n      nodes[i] = Node({ token: curr, amount: list.amount[curr] });\\n      curr = list.next[curr];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return nodes;\\n  }\\n\\n  function getPreviousOf(List storage list, address addr) internal view returns (address) {\\n    return list.prev[addr];\\n  }\\n\\n  function getNextOf(List storage list, address addr) internal view returns (address) {\\n    return list.next[addr];\\n  }\\n\\n  function length(List storage list) internal view returns (uint256) {\\n    return list.size;\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/libraries/LibFullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary LibFullMath {\\n  /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n  function mulDiv(\\n    uint256 a,\\n    uint256 b,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n    unchecked {\\n      // 512-bit multiply [prod1 prod0] = a * b\\n      // Compute the product mod 2**256 and mod 2**256 - 1\\n      // then use the Chinese Remainder Theorem to reconstruct\\n      // the 512 bit result. The result is stored in two 256\\n      // variables such that product = prod1 * 2**256 + prod0\\n      uint256 prod0; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(a, b, not(0))\\n        prod0 := mul(a, b)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n      // Handle non-overflow cases, 256 by 256 division\\n      if (prod1 == 0) {\\n        require(denominator > 0);\\n        assembly {\\n          result := div(prod0, denominator)\\n        }\\n        return result;\\n      }\\n\\n      // Make sure the result is less than 2**256.\\n      // Also prevents denominator == 0\\n      require(denominator > prod1);\\n\\n      ///////////////////////////////////////////////\\n      // 512 by 256 division.\\n      ///////////////////////////////////////////////\\n\\n      // Make division exact by subtracting the remainder from [prod1 prod0]\\n      // Compute remainder using mulmod\\n      uint256 remainder;\\n      assembly {\\n        remainder := mulmod(a, b, denominator)\\n      }\\n      // Subtract 256 bit number from 512 bit number\\n      assembly {\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n      // Factor powers of two out of denominator\\n      // Compute largest power of two divisor of denominator.\\n      // Always >= 1.\\n      uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n      // Divide denominator by power of two\\n      assembly {\\n        denominator := div(denominator, twos)\\n      }\\n\\n      // Divide [prod1 prod0] by the factors of two\\n      assembly {\\n        prod0 := div(prod0, twos)\\n      }\\n      // Shift in bits from prod1 into prod0. For this we need\\n      // to flip `twos` such that it is 2**256 / twos.\\n      // If twos is zero, then it becomes one\\n      assembly {\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n      prod0 |= prod1 * twos;\\n\\n      // Invert denominator mod 2**256\\n      // Now that denominator is an odd number, it has an inverse\\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n      // Compute the inverse by starting with a seed that is correct\\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n      uint256 inv = (3 * denominator) ^ 2;\\n      // Now use Newton-Raphson iteration to improve the precision.\\n      // Thanks to Hensel's lifting lemma, this also works in modular\\n      // arithmetic, doubling the correct bits in each step.\\n      inv *= 2 - denominator * inv; // inverse mod 2**8\\n      inv *= 2 - denominator * inv; // inverse mod 2**16\\n      inv *= 2 - denominator * inv; // inverse mod 2**32\\n      inv *= 2 - denominator * inv; // inverse mod 2**64\\n      inv *= 2 - denominator * inv; // inverse mod 2**128\\n      inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n      // Because the division is now exact we can divide by multiplying\\n      // with the modular inverse of denominator. This will give us the\\n      // correct result modulo 2**256. Since the precoditions guarantee\\n      // that the outcome is less than 2**256, this is the final result.\\n      // We don't need to compute the high bits of the result and prod1\\n      // is no longer required.\\n      result = prod0 * inv;\\n      return result;\\n    }\\n  }\\n\\n  /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  function mulDivRoundingUp(\\n    uint256 a,\\n    uint256 b,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n    result = mulDiv(a, b, denominator);\\n    unchecked {\\n      if (mulmod(a, b, denominator) > 0) {\\n        require(result < type(uint256).max);\\n        result++;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n   */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n   */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/libraries/LibMoneyMarket01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\n// libs\\nimport { LibDoublyLinkedList } from \\\"./LibDoublyLinkedList.sol\\\";\\nimport { LibFullMath } from \\\"./LibFullMath.sol\\\";\\nimport { LibShareUtil } from \\\"./LibShareUtil.sol\\\";\\nimport { LibConstant } from \\\"./LibConstant.sol\\\";\\nimport { LibSafeToken } from \\\"../libraries/LibSafeToken.sol\\\";\\n\\n// interfaces\\nimport { IERC20 } from \\\"../interfaces/IERC20.sol\\\";\\nimport { IInterestBearingToken } from \\\"../interfaces/IInterestBearingToken.sol\\\";\\nimport { IAlpacaV2Oracle } from \\\"../interfaces/IAlpacaV2Oracle.sol\\\";\\nimport { IInterestRateModel } from \\\"../interfaces/IInterestRateModel.sol\\\";\\nimport { IFeeModel } from \\\"../interfaces/IFeeModel.sol\\\";\\nimport { IMiniFL } from \\\"../interfaces/IMiniFL.sol\\\";\\nimport { IDebtToken } from \\\"../interfaces/IDebtToken.sol\\\";\\n\\nlibrary LibMoneyMarket01 {\\n  using LibDoublyLinkedList for LibDoublyLinkedList.List;\\n  using SafeCast for uint256;\\n  using LibSafeToken for IERC20;\\n\\n  // keccak256(\\\"moneymarket.diamond.storage\\\");\\n  bytes32 internal constant MONEY_MARKET_STORAGE_POSITION =\\n    0x2758c6926500ec9dc8ab8cea4053d172d4f50d9b78a6c2ee56aa5dd18d2c800b;\\n\\n  uint256 internal constant MAX_REPURCHASE_FEE_BPS = 1000;\\n\\n  error LibMoneyMarket01_BadSubAccountId();\\n  error LibMoneyMarket01_InvalidToken(address _token);\\n  error LibMoneyMarket01_UnsupportedDecimals();\\n  error LibMoneyMarket01_InvalidAssetTier();\\n  error LibMoneyMarket01_ExceedCollateralLimit();\\n  error LibMoneyMarket01_TooManyCollateralRemoved();\\n  error LibMoneyMarket01_BorrowingPowerTooLow();\\n  error LibMoneyMarket01_NotEnoughToken();\\n  error LibMoneyMarket01_NumberOfTokenExceedLimit();\\n  error LibMoneyMarket01_FeeOnTransferTokensNotSupported();\\n  error LibMoneyMarket01_EmergencyPaused();\\n  error LibMoneyMarket01_UnAuthorized();\\n  error LibMoneyMarket01_SubAccountHealthy();\\n\\n  event LogWithdraw(address indexed _user, address _token, address _ibToken, uint256 _amountIn, uint256 _amountOut);\\n  event LogAccrueInterest(address indexed _token, uint256 _totalInterest, uint256 _totalToProtocolReserve);\\n  event LogRemoveDebt(\\n    address indexed _account,\\n    address indexed _subAccount,\\n    address indexed _token,\\n    uint256 _removedDebtShare,\\n    uint256 _removedDebtAmount,\\n    uint256 _numOfDebt\\n  );\\n\\n  event LogRemoveCollateral(\\n    address indexed _account,\\n    address indexed _subAccount,\\n    address indexed _token,\\n    uint256 _amount\\n  );\\n\\n  event LogAddCollateral(\\n    address indexed _account,\\n    address indexed _subAccount,\\n    address indexed _token,\\n    address _caller,\\n    uint256 _amount\\n  );\\n\\n  event LogOverCollatBorrow(\\n    address indexed _account,\\n    address indexed _subAccount,\\n    address indexed _token,\\n    uint256 _borrowedAmount,\\n    uint256 _debtShare,\\n    uint256 _numOfDebt\\n  );\\n\\n  event LogWriteOffSubAccountDebt(\\n    address indexed subAccount,\\n    address indexed token,\\n    uint256 debtShareWrittenOff,\\n    uint256 debtValueWrittenOff\\n  );\\n\\n  struct ProtocolConfig {\\n    mapping(address => uint256) maxTokenBorrow; // token limit per account\\n    uint256 borrowingPowerLimit;\\n  }\\n\\n  // Storage\\n  struct MoneyMarketDiamondStorage {\\n    // ---- addresses ---- //\\n    address liquidationTreasury;\\n    address ibTokenImplementation;\\n    address debtTokenImplementation;\\n    IAlpacaV2Oracle oracle;\\n    IFeeModel repurchaseRewardModel;\\n    IMiniFL miniFL;\\n    bool emergencyPaused; // flag for pausing deposit and borrow on the money market\\n    // ---- ib tokens ---- //\\n    mapping(address => address) tokenToIbTokens; // token address => ibToken address\\n    mapping(address => address) ibTokenToTokens; // ibToken address => token address\\n    // ---- debt tokens ---- //\\n    mapping(address => address) tokenToDebtTokens; // token address => debtToken address\\n    // ---- miniFL pools ---- //\\n    mapping(address => uint256) miniFLPoolIds; // token address => pool id\\n    // ---- lending ---- //\\n    mapping(address => uint256) globalDebts; // token address => over + non collat debt\\n    // ---- over-collateralized lending ---- //\\n    mapping(address => uint256) overCollatDebtValues; // borrower address => debt amount in borrowed token\\n    mapping(address => uint256) overCollatDebtShares; // borrower address => debt shares\\n    mapping(address => uint256) collats; // token address => total collateral of a token\\n    mapping(address => IInterestRateModel) interestModels; // token address => over-collat interest model\\n    // ---- non-collateralized lending ---- //\\n    mapping(address => LibDoublyLinkedList.List) nonCollatAccountDebtValues; // account => list token debt\\n    mapping(address => LibDoublyLinkedList.List) nonCollatTokenDebtValues; // token => debt of each account\\n    mapping(address => ProtocolConfig) protocolConfigs; // account => ProtocolConfig\\n    mapping(address => mapping(address => IInterestRateModel)) nonCollatInterestModels; // [account][token] => non-collat interest model\\n    mapping(address => bool) nonCollatBorrowerOk; // can this address do non collat borrow\\n    // ---- subAccounts ---- //\\n    mapping(address => LibDoublyLinkedList.List) subAccountCollats; // subAccount => list of subAccount's all collateral\\n    mapping(address => LibDoublyLinkedList.List) subAccountDebtShares; // subAccount => list of subAccount's all debt\\n    // ---- tokens ---- //\\n    mapping(address => LibConstant.TokenConfig) tokenConfigs; // token address => config\\n    mapping(address => uint256) debtLastAccruedAt; // token address => last interest accrual timestamp, shared between over and non collat\\n    // ---- whitelists ---- //\\n    mapping(address => bool) liquidationStratOk; // liquidation strategies that can be used during liquidation process\\n    mapping(address => bool) liquidatorsOk; // allowed to initiate liquidation process\\n    mapping(address => bool) accountManagersOk; // allowed to manipulate account/subaccount on behalf of end users\\n    mapping(address => bool) riskManagersOk; // allowed to set risk control parameters\\n    // ---- reserves ---- //\\n    mapping(address => uint256) protocolReserves; // token address => amount that is reserved for protocol\\n    mapping(address => uint256) reserves; // token address => amount that is available in protocol\\n    // ---- protocol params ---- //\\n    uint256 minDebtSize; // minimum debt that borrower must maintain\\n    // maximum number of token in the linked list\\n    uint8 maxNumOfCollatPerSubAccount;\\n    uint8 maxNumOfDebtPerSubAccount;\\n    uint8 maxNumOfDebtPerNonCollatAccount;\\n    // counting of non collat borrowers\\n    uint8 countNonCollatBorrowers;\\n    // liquidation params\\n    uint16 maxLiquidateBps; // maximum portion of debt that is allowed to be repurchased / liquidated per transaction\\n    uint16 liquidationThresholdBps; // threshold that allow subAccount to be liquidated if borrowing power goes below threshold\\n    // fees\\n    uint16 lendingFeeBps; // fee that is charged from lending interest by protocol, goes to protocolReserve\\n    uint16 repurchaseFeeBps; // fee that is charged during repurchase by protocol, goes to liquidationTreasury\\n    uint16 liquidationFeeBps; // fee that is charged during liquidation by protocol, goes to liquidationTreasury\\n  }\\n\\n  /// @dev Get money market storage\\n  /// @return moneyMarketStorage The storage of money market\\n  function moneyMarketDiamondStorage() internal pure returns (MoneyMarketDiamondStorage storage moneyMarketStorage) {\\n    assembly {\\n      moneyMarketStorage.slot := MONEY_MARKET_STORAGE_POSITION\\n    }\\n  }\\n\\n  /// @dev Calculate sub account address\\n  /// @param primary The account address\\n  /// @param subAccountId A sub account id\\n  /// @return The sub account address\\n  function getSubAccount(address primary, uint256 subAccountId) internal pure returns (address) {\\n    // revert if subAccountId is greater than 255\\n    if (subAccountId > 255) {\\n      revert LibMoneyMarket01_BadSubAccountId();\\n    }\\n    // sub account address is the XOR of primary address and subAccountId\\n    // primary address is 20 bytes long, so it is (20 * 8) = 160 bits long\\n    //\\n    // calculation:\\n    // sub account address = primary XOR subAccountId\\n    //\\n    // example:\\n    //  - primary           = 0x0...88\\n    //  - subAccountId      = 2\\n    //\\n    //  sub account address = 0x0...88 XOR 2\\n    //                      = 0x0...8a\\n    return address(uint160(primary) ^ uint160(subAccountId));\\n  }\\n\\n  /// @dev Calculate total borrowing power of a sub account\\n  /// @param _subAccount The sub account address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _totalBorrowingPower The total borrowing power of a sub account\\n  function getTotalBorrowingPower(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _totalBorrowingPower)\\n  {\\n    // get all collats of a sub account\\n    LibDoublyLinkedList.Node[] memory _collats = moneyMarketDs.subAccountCollats[_subAccount].getAll();\\n\\n    address _collatToken;\\n    uint256 _tokenPrice;\\n    LibConstant.TokenConfig memory _tokenConfig;\\n\\n    uint256 _collatsLength = _collats.length;\\n\\n    // sum up total borrowing power\\n    for (uint256 _i; _i < _collatsLength; ) {\\n      _collatToken = _collats[_i].token;\\n\\n      // get collat token price in USD\\n      _tokenPrice = getPriceUSD(_collatToken, moneyMarketDs);\\n      _tokenConfig = moneyMarketDs.tokenConfigs[_collatToken];\\n\\n      // calulation:\\n      // _totalBorrowingPower += amount * tokenPrice * collateralFactor\\n      //\\n      // example:\\n      //  - amount                = 100\\n      //  - tokenPrice            = 1\\n      //  - collateralFactor      = 9000 (need to divide by LibConstant.MAX_BPS)\\n      //\\n      //  _totalBorrowingPower   += 100 * 1 * (9000/10000)\\n      //                         += 90\\n      _totalBorrowingPower += LibFullMath.mulDiv(\\n        _collats[_i].amount * _tokenConfig.to18ConversionFactor * _tokenConfig.collateralFactor,\\n        _tokenPrice,\\n        1e22\\n      );\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Calculate total non collat token debt of a token\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _totalNonCollatDebt The total non collat token debt\\n  function getNonCollatTokenDebt(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _totalNonCollatDebt)\\n  {\\n    // get all non collat token debt values of _token\\n    LibDoublyLinkedList.Node[] memory _nonCollatDebts = moneyMarketDs.nonCollatTokenDebtValues[_token].getAll();\\n\\n    uint256 _length = _nonCollatDebts.length;\\n\\n    // sum up total non collat token debt of _token\\n    for (uint256 _i; _i < _length; ) {\\n      _totalNonCollatDebt += _nonCollatDebts[_i].amount;\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Calculate total used borrowing power of a sub account\\n  /// @param _subAccount The sub account address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _totalUsedBorrowingPower The total used borrowing power of a sub account\\n  /// @return _hasIsolateAsset True if sub account has isolate asset\\n  function getTotalUsedBorrowingPower(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _totalUsedBorrowingPower, bool _hasIsolateAsset)\\n  {\\n    // get all borrowed positions of a sub account\\n    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();\\n\\n    uint256 _borrowedLength = _borrowed.length;\\n\\n    address _borrowedToken;\\n    LibConstant.TokenConfig memory _tokenConfig;\\n\\n    // sum up total used borrowing power from each borrowed token\\n    for (uint256 _i; _i < _borrowedLength; ) {\\n      _borrowedToken = _borrowed[_i].token;\\n      _tokenConfig = moneyMarketDs.tokenConfigs[_borrowedToken];\\n\\n      if (_tokenConfig.tier == LibConstant.AssetTier.ISOLATE) {\\n        _hasIsolateAsset = true;\\n      }\\n\\n      _totalUsedBorrowingPower += usedBorrowingPower(\\n        LibShareUtil.shareToValue(\\n          _borrowed[_i].amount,\\n          moneyMarketDs.overCollatDebtValues[_borrowedToken],\\n          moneyMarketDs.overCollatDebtShares[_borrowedToken]\\n        ),\\n        getPriceUSD(_borrowedToken, moneyMarketDs),\\n        _tokenConfig.borrowingFactor,\\n        _tokenConfig.to18ConversionFactor\\n      );\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Calculate total used borrowing power of a non collat borrower\\n  /// @param _account The non collat borrower address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _totalUsedBorrowingPower The total used borrowing power of a non collat borrower\\n  function getTotalNonCollatUsedBorrowingPower(address _account, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _totalUsedBorrowingPower)\\n  {\\n    // get all borrowed positions of a non collat borrower\\n    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.nonCollatAccountDebtValues[_account].getAll();\\n\\n    uint256 _borrowedLength = _borrowed.length;\\n\\n    LibConstant.TokenConfig memory _tokenConfig;\\n    address _borrowedToken;\\n\\n    // sum up total used borrowing power from each borrowed token\\n    for (uint256 _i; _i < _borrowedLength; ) {\\n      _borrowedToken = _borrowed[_i].token;\\n      _tokenConfig = moneyMarketDs.tokenConfigs[_borrowedToken];\\n\\n      _totalUsedBorrowingPower += usedBorrowingPower(\\n        _borrowed[_i].amount,\\n        getPriceUSD(_borrowedToken, moneyMarketDs),\\n        _tokenConfig.borrowingFactor,\\n        _tokenConfig.to18ConversionFactor\\n      );\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Calculate used borrowing power of a token\\n  /// @param _subAccount The sub account address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _totalBorrowedUSDValue The total borrowed USD value of a sub account\\n  function getTotalBorrowedUSDValue(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _totalBorrowedUSDValue)\\n  {\\n    // get all borrowed positions of a sub account\\n    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();\\n\\n    uint256 _borrowedLength = _borrowed.length;\\n\\n    address _borrowedToken;\\n    uint256 _borrowedAmount;\\n\\n    // sum up total borrowed USD value from each borrowed token\\n    for (uint256 _i; _i < _borrowedLength; ) {\\n      _borrowedToken = _borrowed[_i].token;\\n\\n      _borrowedAmount = LibShareUtil.shareToValue(\\n        _borrowed[_i].amount,\\n        moneyMarketDs.overCollatDebtValues[_borrowedToken],\\n        moneyMarketDs.overCollatDebtShares[_borrowedToken]\\n      );\\n\\n      // calulation:\\n      // _totalBorrowedUSDValue += _borrowedAmount * tokenPrice\\n      //\\n      // example:\\n      //  - _borrowedAmount       = 100\\n      //  - tokenPrice            = 1.5\\n      //\\n      //  _totalBorrowingPower   += 100 * 1.5\\n      //                         += 150\\n      _totalBorrowedUSDValue += LibFullMath.mulDiv(\\n        _borrowedAmount * moneyMarketDs.tokenConfigs[_borrowedToken].to18ConversionFactor,\\n        getPriceUSD(_borrowedToken, moneyMarketDs),\\n        1e18\\n      );\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Calculate used borrowing power of a token\\n  /// @param _borrowedAmount The borrowed amount\\n  /// @param _tokenPrice The token price\\n  /// @param _borrowingFactor The borrowing factor\\n  /// @param _to18ConversionFactor The conversion factor to 18 decimals\\n  function usedBorrowingPower(\\n    uint256 _borrowedAmount,\\n    uint256 _tokenPrice,\\n    uint256 _borrowingFactor,\\n    uint256 _to18ConversionFactor\\n  ) internal pure returns (uint256 _usedBorrowingPower) {\\n    // calulation:\\n    // usedBorrowingPower = borrowedAmountE18 * tokenPrice * (LibConstant.MAX_BPS / borrowingFactor)\\n    //\\n    // example:\\n    //  - borrowedAmountE18   = 100 (omit 1e18)\\n    //  - tokenPrice          = 1.5\\n    //  - LibConstant.MAX_BPS             = 10000\\n    //  - borrowingFactor     = 9000\\n    //\\n    //  usedBorrowingPower    = 100 * 1.5 * (10000 / 9000)\\n    //                        = 100 * 1.5 * 1.11111\\n    //                        = 166.67\\n    _usedBorrowingPower = LibFullMath.mulDiv(\\n      _borrowedAmount * _to18ConversionFactor,\\n      _tokenPrice,\\n      1e14 * _borrowingFactor // gas savings: 1e14 = 1e18 / LibConstant.MAX_BPS\\n    );\\n  }\\n\\n  /// @dev Calculate global pending interest of a token\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _globalPendingInterest The global pending interest of a token\\n  function getGlobalPendingInterest(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _globalPendingInterest)\\n  {\\n    uint256 _lastAccrualTimestamp = moneyMarketDs.debtLastAccruedAt[_token];\\n\\n    // skip if interest has already been accrued within this block\\n    if (block.timestamp > _lastAccrualTimestamp) {\\n      // get a period of time since last accrual in seconds\\n      uint256 _secondsSinceLastAccrual;\\n      // safe to use unchecked\\n      //    because at this statement, block.timestamp is always greater than _lastAccrualTimestamp\\n      unchecked {\\n        _secondsSinceLastAccrual = block.timestamp - _lastAccrualTimestamp;\\n      }\\n      // get all non collat borrowers\\n      LibDoublyLinkedList.Node[] memory _borrowedAccounts = moneyMarketDs.nonCollatTokenDebtValues[_token].getAll();\\n      uint256 _accountLength = _borrowedAccounts.length;\\n      uint256 _nonCollatInterestPerSec;\\n\\n      // sum up total non collat interest per second from each non collat borrower\\n      // calulation:\\n      // _nonCollatInterestPerSec += (nonCollatInterestRate * borrowedAmount)\\n      //\\n      // example:\\n      //  - nonCollatInterestRate   = 0.1\\n      //  - borrowedAmount          = 100\\n      //\\n      //  _nonCollatInterestPerSec += 0.1 * 100\\n      //                           += 10\\n      for (uint256 _i; _i < _accountLength; ) {\\n        _nonCollatInterestPerSec += (getNonCollatInterestRate(_borrowedAccounts[_i].token, _token, moneyMarketDs) *\\n          _borrowedAccounts[_i].amount);\\n\\n        unchecked {\\n          ++_i;\\n        }\\n      }\\n\\n      // calulations:\\n      // _globalPendingInterest = (nonCollatInterestAmountPerSec + overCollatInterestAmountPerSec) * _secondsSinceLastAccrual\\n      // overCollatInterestAmountPerSec = overCollatInterestRate * overCollatDebtValue\\n      //\\n      // example:\\n      //  - nonCollatInterestAmountPerSec   = 20\\n      //  - overCollatInterestAmountPerSec  = 0.1 * 50\\n      //  - _secondsSinceLastAccrual        = 3200\\n      //\\n      //  _globalPendingInterest            = (20 + (0.1 * 50)) * 3200\\n      //                                    = 25 * 3200\\n      //                                    = 80000\\n      _globalPendingInterest =\\n        ((_nonCollatInterestPerSec +\\n          (getOverCollatInterestRate(_token, moneyMarketDs) * moneyMarketDs.overCollatDebtValues[_token])) *\\n          _secondsSinceLastAccrual) /\\n        1e18;\\n    }\\n  }\\n\\n  /// @dev Get over collat interest rate of a token\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _interestRate The interest rate of a token\\n  function getOverCollatInterestRate(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _interestRate)\\n  {\\n    // get interest model of a token\\n    IInterestRateModel _interestModel = moneyMarketDs.interestModels[_token];\\n    // return 0 if interest model does not exist\\n    // otherwise, return interest rate from interest model\\n    if (address(_interestModel) == address(0)) {\\n      return 0;\\n    }\\n    _interestRate = _interestModel.getInterestRate(moneyMarketDs.globalDebts[_token], moneyMarketDs.reserves[_token]);\\n  }\\n\\n  /// @dev Get non collat interest rate\\n  /// @param _account The account address\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _interestRate The non collat interest rate\\n  function getNonCollatInterestRate(\\n    address _account,\\n    address _token,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal view returns (uint256 _interestRate) {\\n    // get interest model of a token in a non collat account\\n    IInterestRateModel _interestModel = moneyMarketDs.nonCollatInterestModels[_account][_token];\\n    // return 0 if interest model does not exist\\n    // otherwise, return interest rate from interest model\\n    if (address(_interestModel) == address(0)) {\\n      return 0;\\n    }\\n    _interestRate = _interestModel.getInterestRate(moneyMarketDs.globalDebts[_token], moneyMarketDs.reserves[_token]);\\n  }\\n\\n  /// @dev Accrue over collat interest of a token\\n  /// @param _token The token address\\n  /// @param _timePast The time past since last accrual\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _overCollatInterest The over collat interest of a token\\n  function accrueOverCollatInterest(\\n    address _token,\\n    uint256 _timePast,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal returns (uint256 _overCollatInterest) {\\n    // cache to save gas\\n    uint256 _totalDebtValue = moneyMarketDs.overCollatDebtValues[_token];\\n    _overCollatInterest = (getOverCollatInterestRate(_token, moneyMarketDs) * _timePast * _totalDebtValue) / 1e18;\\n\\n    // update overcollat debt\\n    moneyMarketDs.overCollatDebtValues[_token] = _totalDebtValue + _overCollatInterest;\\n  }\\n\\n  /// @dev Accrue over collat and non collat interest of a token\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  function accrueInterest(address _token, MoneyMarketDiamondStorage storage moneyMarketDs) internal {\\n    uint256 _lastAccrualTimestamp = moneyMarketDs.debtLastAccruedAt[_token];\\n    // skip if interest has already been accrued within this block\\n    if (block.timestamp > _lastAccrualTimestamp) {\\n      // get a period of time since last accrual in seconds\\n      uint256 _secondsSinceLastAccrual;\\n      // safe to use unchecked\\n      //    because at this statement, block.timestamp is always greater than _lastAccrualTimestamp\\n      unchecked {\\n        _secondsSinceLastAccrual = block.timestamp - _lastAccrualTimestamp;\\n      }\\n      // accrue interest\\n      uint256 _overCollatInterest = accrueOverCollatInterest(_token, _secondsSinceLastAccrual, moneyMarketDs);\\n      uint256 _nonCollatInterest = accrueNonCollatInterest(_token, _secondsSinceLastAccrual, moneyMarketDs);\\n\\n      // update global debt\\n      uint256 _totalInterest = _overCollatInterest + _nonCollatInterest;\\n      moneyMarketDs.globalDebts[_token] += _totalInterest;\\n\\n      // update timestamp\\n      moneyMarketDs.debtLastAccruedAt[_token] = block.timestamp;\\n\\n      // book protocol's revenue\\n      // calculation:\\n      // _protocolFee = (_totalInterest * lendingFeeBps) / LibConstant.MAX_BPS\\n      //\\n      // example:\\n      //  - _totalInterest = 1\\n      //  - lendingFeeBps  = 1900\\n      //  - LibConstant.MAX_BPS        = 10000\\n      //\\n      //  _protocolFee     = (1 * 1900) / 10000\\n      //                   = 0.19\\n      uint256 _protocolFee = (_totalInterest * moneyMarketDs.lendingFeeBps) / LibConstant.MAX_BPS;\\n      moneyMarketDs.protocolReserves[_token] += _protocolFee;\\n\\n      emit LogAccrueInterest(_token, _totalInterest, _protocolFee);\\n    }\\n  }\\n\\n  /// @dev Accrue non collat interest of a token\\n  /// @param _token The token address\\n  /// @param _timePast The time past since last accrual\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _totalNonCollatInterest The total non collat interest of a token\\n  function accrueNonCollatInterest(\\n    address _token,\\n    uint256 _timePast,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal returns (uint256 _totalNonCollatInterest) {\\n    // get all non collat borrowers\\n    LibDoublyLinkedList.Node[] memory _borrowedAccounts = moneyMarketDs.nonCollatTokenDebtValues[_token].getAll();\\n    uint256 _accountLength = _borrowedAccounts.length;\\n    address _account;\\n    uint256 _currentAccountDebt;\\n    uint256 _accountInterest;\\n    uint256 _newNonCollatDebtValue;\\n\\n    // sum up all non collat interest of a token\\n    for (uint256 _i; _i < _accountLength; ) {\\n      _account = _borrowedAccounts[_i].token;\\n      _currentAccountDebt = _borrowedAccounts[_i].amount;\\n\\n      // calculate interest\\n      // calculation:\\n      // _accountInterest = nonCollatInterestRate * _timePast * _currentAccountDebt\\n      //\\n      // example:\\n      //  - nonCollatInterestRate = 0.1\\n      //  - _timePast             = 3200\\n      //  - _currentAccountDebt   = 100\\n      //\\n      //  _accountInterest        = 0.1 * 3200 * 100\\n      //                          = 32000\\n      _accountInterest =\\n        (getNonCollatInterestRate(_account, _token, moneyMarketDs) * _timePast * _currentAccountDebt) /\\n        1e18;\\n\\n      // update non collat debt states\\n      _newNonCollatDebtValue = _currentAccountDebt + _accountInterest;\\n      // 1. account debt\\n      moneyMarketDs.nonCollatAccountDebtValues[_account].addOrUpdate(_token, _newNonCollatDebtValue);\\n      // 2. token debt\\n      moneyMarketDs.nonCollatTokenDebtValues[_token].addOrUpdate(_account, _newNonCollatDebtValue);\\n\\n      // accumulate total non collat interest\\n      _totalNonCollatInterest += _accountInterest;\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Accrue interest of all borrowed positions of a sub account\\n  /// @param _subAccount The sub account address\\n  /// @param moneyMarketDs The storage of money market\\n  function accrueBorrowedPositionsOf(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs) internal {\\n    // get all borrowed positions of a sub account\\n    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();\\n\\n    uint256 _borrowedLength = _borrowed.length;\\n\\n    // accrue interest of all borrowed positions\\n    for (uint256 _i; _i < _borrowedLength; ) {\\n      accrueInterest(_borrowed[_i].token, moneyMarketDs);\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Accrue interest of all non collat borrowed positions of a non collat borrower\\n  /// @param _account The non collat borrower address\\n  /// @param moneyMarketDs The storage of money market\\n  function accrueNonCollatBorrowedPositionsOf(address _account, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n  {\\n    // get all borrowed positions of a non collat borrower\\n    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.nonCollatAccountDebtValues[_account].getAll();\\n\\n    uint256 _borrowedLength = _borrowed.length;\\n\\n    // accrue interest of all borrowed positions\\n    for (uint256 _i; _i < _borrowedLength; ) {\\n      accrueInterest(_borrowed[_i].token, moneyMarketDs);\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /// @dev Get total amount of a token in money market\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return The total amount of a token in money market\\n  function getTotalToken(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    // calculation:\\n    // totalToken   = amount of token remains in money market + debt - protocol reserve\\n    // debt         = over collat debt + non collat debt\\n    //\\n    // example:\\n    //  - amount of token remains in money markey = 100\\n    //  - over collat debt                        = 200\\n    //  - non collat debt                         = 300\\n    //  - protocol reserve                        = 50\\n    //\\n    //  totalToken                                = 100 + (200 + 300) - 50\\n    //                                            = 100 + (500) - 50\\n    //                                            = 550\\n    return\\n      (moneyMarketDs.reserves[_token] + moneyMarketDs.globalDebts[_token]) - (moneyMarketDs.protocolReserves[_token]);\\n  }\\n\\n  /// @dev Get total amount of a token in money market with pending interest\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return The total amount of a token in money market with pending interest\\n  function getTotalTokenWithPendingInterest(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    // calculation:\\n    // totalTokenWithPendingInterest = totalToken + ((pendingInterest * (LibConstant.MAX_BPS - lendingFeeBps)) / LibConstant.MAX_BPS)\\n    //\\n    // example:\\n    //  - totalToken                  = 550\\n    //  - pendingInterest             = 100\\n    //  - lendingFeeBps               = 1900\\n    //  - LibConstant.MAX_BPS                     = 10000\\n    //\\n    //  totalTokenWithPendingInterest = 550 + ((100 * (10000 - 1900)) / 10000)\\n    //                                = 550 + ((100 * 8100) / 10000)\\n    //                                = 550 + (810000 / 10000)\\n    //                                = 550 + 81\\n    //                                = 631\\n    return\\n      getTotalToken(_token, moneyMarketDs) +\\n      ((getGlobalPendingInterest(_token, moneyMarketDs) * (LibConstant.MAX_BPS - moneyMarketDs.lendingFeeBps)) /\\n        LibConstant.MAX_BPS);\\n  }\\n\\n  /// @dev Get price of a token in USD\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _price The price of a token in USD\\n  function getPriceUSD(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n    returns (uint256 _price)\\n  {\\n    address _underlyingToken = moneyMarketDs.ibTokenToTokens[_token];\\n    // If the token is ibToken, do an additional shareToValue before pricing\\n    // otherwise, just get the price from oracle\\n    if (_underlyingToken != address(0)) {\\n      uint256 _underlyingTokenPrice;\\n      (_underlyingTokenPrice, ) = moneyMarketDs.oracle.getTokenPrice(_underlyingToken);\\n      // TODO: optimize this\\n      uint256 _totalSupply = IERC20(_token).totalSupply();\\n      uint256 _totalToken = getTotalTokenWithPendingInterest(_underlyingToken, moneyMarketDs);\\n\\n      _price = LibShareUtil.shareToValue(_underlyingTokenPrice, _totalToken, _totalSupply);\\n    } else {\\n      (_price, ) = moneyMarketDs.oracle.getTokenPrice(_token);\\n    }\\n  }\\n\\n  /// @dev Get to18ConversionFactor of a token\\n  /// @param _token The token address\\n  /// @return The to18ConversionFactor of a token\\n  function to18ConversionFactor(address _token) internal view returns (uint64) {\\n    // get decimals of a token\\n    uint256 _decimals = IERC20(_token).decimals();\\n    // revert if decimals > 18\\n    if (_decimals > 18) {\\n      revert LibMoneyMarket01_UnsupportedDecimals();\\n    }\\n    // in case the decimal is in 18 digits, the factor is 1\\n    // and can skip the below calculation\\n    if (_decimals == 18) {\\n      return 1;\\n    }\\n    // calculate conversion factor\\n    // calculation:\\n    // conversionFactor = 10^(18 - decimals)\\n    //\\n    // example:\\n    //  - decimals        = 6\\n    //\\n    //  conversionFactor  = 10^(18 - 6)\\n    //                    = 10^(12)\\n    //                    = 1e12\\n    uint256 _conversionFactor = 10**(18 - _decimals);\\n    return uint64(_conversionFactor);\\n  }\\n\\n  /// @dev Add collat to sub account\\n  /// @param _account The account address\\n  /// @param _subAccount The sub account address\\n  /// @param _token The token address\\n  /// @param _addAmount The amount to add\\n  /// @param moneyMarketDs The storage of money market\\n  function addCollatToSubAccount(\\n    address _account,\\n    address _subAccount,\\n    address _token,\\n    uint256 _addAmount,\\n    bool _skipMiniFL,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal {\\n    // validation\\n    //  1. revert if token is not collateral\\n    if (moneyMarketDs.tokenConfigs[_token].tier != LibConstant.AssetTier.COLLATERAL) {\\n      revert LibMoneyMarket01_InvalidAssetTier();\\n    }\\n    //  2. revert if _addAmount + currentCollatAmount exceed max collateral amount of a token\\n    if (_addAmount + moneyMarketDs.collats[_token] > moneyMarketDs.tokenConfigs[_token].maxCollateral) {\\n      revert LibMoneyMarket01_ExceedCollateralLimit();\\n    }\\n\\n    // init list\\n    LibDoublyLinkedList.List storage subAccountCollateralList = moneyMarketDs.subAccountCollats[_subAccount];\\n    subAccountCollateralList.initIfNotExist();\\n\\n    // TODO: optimize this\\n    uint256 _currentCollatAmount = subAccountCollateralList.getAmount(_token);\\n    // update states\\n    //  1. update sub account collateral amount\\n    subAccountCollateralList.addOrUpdate(_token, _currentCollatAmount + _addAmount);\\n    // revert if number of collateral tokens exceed limit per sub account\\n    if (subAccountCollateralList.length() > moneyMarketDs.maxNumOfCollatPerSubAccount) {\\n      revert LibMoneyMarket01_NumberOfTokenExceedLimit();\\n    }\\n    //  2. update total collateral amount of a token in money market\\n    moneyMarketDs.collats[_token] += _addAmount;\\n\\n    // if called by transferCollateral, does not need to deposit to miniFL\\n    // as during removeCollateral in transfer, token wasn't withdrawn from miniFL\\n    if (!_skipMiniFL) {\\n      // stake token to miniFL, when user add collateral by ibToken\\n      uint256 _poolId = moneyMarketDs.miniFLPoolIds[_token];\\n\\n      // If the collateral token has no miniFL's poolID associated with it\\n      // skip the deposit to miniFL process\\n      // This generally applies to non-ibToken collateral\\n      if (_poolId != 0) {\\n        IMiniFL _miniFL = moneyMarketDs.miniFL;\\n        IERC20(_token).safeApprove(address(_miniFL), _addAmount);\\n        _miniFL.deposit(_account, _poolId, _addAmount);\\n      }\\n    }\\n\\n    emit LogAddCollateral(_account, _subAccount, _token, msg.sender, _addAmount);\\n  }\\n\\n  /// @dev Remove collat from sub account\\n  /// @param _account The account address\\n  /// @param _subAccount The sub account address\\n  /// @param _token The token address\\n  /// @param _removeAmount The amount to remove\\n  /// @param moneyMarketDs The storage of money market\\n  function removeCollatFromSubAccount(\\n    address _account,\\n    address _subAccount,\\n    address _token,\\n    uint256 _removeAmount,\\n    bool _skipMiniFl,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal {\\n    // get current collateral amount of a token\\n    LibDoublyLinkedList.List storage _subAccountCollatList = moneyMarketDs.subAccountCollats[_subAccount];\\n    uint256 _currentCollatAmount = _subAccountCollatList.getAmount(_token);\\n\\n    // revert if insufficient collateral amount to remove\\n    if (_removeAmount > _currentCollatAmount) {\\n      revert LibMoneyMarket01_TooManyCollateralRemoved();\\n    }\\n    // update states\\n    //  1. update sub account collateral amount\\n    _subAccountCollatList.updateOrRemove(_token, _currentCollatAmount - _removeAmount);\\n    //  2. update total collateral amount of a token in money market\\n    moneyMarketDs.collats[_token] -= _removeAmount;\\n\\n    // if called by transferCollateral, does not need to withdraw from miniFL\\n    if (!_skipMiniFl) {\\n      // In the subsequent call, money market should get hold of physical token to proceed\\n      // Thus, we need to withdraw the physical token from miniFL first\\n      uint256 _poolId = moneyMarketDs.miniFLPoolIds[_token];\\n\\n      // If the collateral token has no miniFL's poolID associated with it\\n      // skip the withdrawal from miniFL process\\n      // This generally applies to non-ibToken collateral\\n      if (_poolId != 0) {\\n        moneyMarketDs.miniFL.withdraw(_account, _poolId, _removeAmount);\\n      }\\n    }\\n\\n    emit LogRemoveCollateral(_account, _subAccount, _token, _removeAmount);\\n  }\\n\\n  /// @dev Validate if sub account is healthy\\n  /// @param _subAccount The sub account address\\n  /// @param moneyMarketDs The storage of money market\\n  function validateSubaccountIsHealthy(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)\\n    internal\\n    view\\n  {\\n    uint256 _totalBorrowingPower = getTotalBorrowingPower(_subAccount, moneyMarketDs);\\n    (uint256 _totalUsedBorrowingPower, ) = getTotalUsedBorrowingPower(_subAccount, moneyMarketDs);\\n    // revert if total borrowing power is less than total used borrowing power\\n    // in case of price change, this can happen\\n    if (_totalBorrowingPower < _totalUsedBorrowingPower) {\\n      revert LibMoneyMarket01_BorrowingPowerTooLow();\\n    }\\n  }\\n\\n  /// @dev Remove over collat debt from sub account\\n  /// @param _account The account address\\n  /// @param _subAccount The sub account address\\n  /// @param _repayToken The token address\\n  /// @param _debtShareToRemove The debt share to remove\\n  /// @param _debtValueToRemove The debt value to remove\\n  /// @param moneyMarketDs The storage of money market\\n  function removeOverCollatDebtFromSubAccount(\\n    address _account,\\n    address _subAccount,\\n    address _repayToken,\\n    uint256 _debtShareToRemove,\\n    uint256 _debtValueToRemove,\\n    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal {\\n    LibDoublyLinkedList.List storage userDebtShare = moneyMarketDs.subAccountDebtShares[_subAccount];\\n    // get current debt share of a token\\n    uint256 _currentDebtShare = userDebtShare.getAmount(_repayToken);\\n\\n    // update states\\n    //  1. update sub account debt share\\n    userDebtShare.updateOrRemove(_repayToken, _currentDebtShare - _debtShareToRemove);\\n    //  2. update total over collat debt share of a token in money market\\n    moneyMarketDs.overCollatDebtShares[_repayToken] -= _debtShareToRemove;\\n    //  3. update total over collat debt value of a token in money market\\n    moneyMarketDs.overCollatDebtValues[_repayToken] -= _debtValueToRemove;\\n    //  4. update total debt value of a token in money market\\n    moneyMarketDs.globalDebts[_repayToken] -= _debtValueToRemove;\\n\\n    // withdraw debt token from miniFL\\n    IMiniFL _miniFL = moneyMarketDs.miniFL;\\n    address _debtToken = moneyMarketDs.tokenToDebtTokens[_repayToken];\\n    _miniFL.withdraw(_account, moneyMarketDs.miniFLPoolIds[_debtToken], _debtShareToRemove);\\n\\n    // burn debt token\\n    IDebtToken(_debtToken).burn(address(this), _debtShareToRemove);\\n\\n    emit LogRemoveDebt(\\n      _account,\\n      _subAccount,\\n      _repayToken,\\n      _debtShareToRemove,\\n      _debtValueToRemove,\\n      userDebtShare.length()\\n    );\\n  }\\n\\n  /// @dev Transfer collat from one sub account to another\\n  /// @param _toSubAccount The sub account address to transfer to\\n  /// @param _token The token address\\n  /// @param _transferAmount The amount to transfer\\n  /// @param moneyMarketDs The storage of money market\\n  function transferCollat(\\n    address _toSubAccount,\\n    address _token,\\n    uint256 _transferAmount,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal {\\n    // init list\\n    LibDoublyLinkedList.List storage toSubAccountCollateralList = moneyMarketDs.subAccountCollats[_toSubAccount];\\n    toSubAccountCollateralList.initIfNotExist();\\n\\n    uint256 _currentCollatAmount = toSubAccountCollateralList.getAmount(_token);\\n    // update toSubAccount collateral amount\\n    toSubAccountCollateralList.addOrUpdate(_token, _currentCollatAmount + _transferAmount);\\n    // revert if number of collateral tokens exceed limit per sub account\\n    if (toSubAccountCollateralList.length() > moneyMarketDs.maxNumOfCollatPerSubAccount) {\\n      revert LibMoneyMarket01_NumberOfTokenExceedLimit();\\n    }\\n  }\\n\\n  /// @dev Get over collat debt share and amount\\n  /// @param _subAccount The sub account address\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _debtShare The debt share\\n  /// @return _debtAmount The debt amount\\n  function getOverCollatDebtShareAndAmountOf(\\n    address _subAccount,\\n    address _token,\\n    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal view returns (uint256 _debtShare, uint256 _debtAmount) {\\n    _debtShare = moneyMarketDs.subAccountDebtShares[_subAccount].getAmount(_token);\\n\\n    // Note: precision loss 1 wei when convert share back to value\\n    _debtAmount = LibShareUtil.shareToValue(\\n      _debtShare,\\n      moneyMarketDs.overCollatDebtValues[_token],\\n      moneyMarketDs.overCollatDebtShares[_token]\\n    );\\n  }\\n\\n  /// @dev Get non collat debt amount\\n  /// @param _account The non collat borrower address\\n  /// @param _token The token address\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _debtAmount The debt amount\\n  function getNonCollatDebt(\\n    address _account,\\n    address _token,\\n    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal view returns (uint256 _debtAmount) {\\n    _debtAmount = moneyMarketDs.nonCollatAccountDebtValues[_account].getAmount(_token);\\n  }\\n\\n  /// @dev Do over collat borrow\\n  /// @param _account The account address\\n  /// @param _subAccount The sub account address\\n  /// @param _token The token address\\n  /// @param _amount The amount to borrow\\n  /// @param moneyMarketDs The storage of money market\\n  /// @return _shareToAdd The share value to add\\n  function overCollatBorrow(\\n    address _account,\\n    address _subAccount,\\n    address _token,\\n    uint256 _amount,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal returns (uint256 _shareToAdd) {\\n    LibDoublyLinkedList.List storage userDebtShare = moneyMarketDs.subAccountDebtShares[_subAccount];\\n    IMiniFL _miniFL = moneyMarketDs.miniFL;\\n\\n    userDebtShare.initIfNotExist();\\n\\n    // get share value to update states\\n    _shareToAdd = LibShareUtil.valueToShareRoundingUp(\\n      _amount,\\n      moneyMarketDs.overCollatDebtShares[_token],\\n      moneyMarketDs.overCollatDebtValues[_token]\\n    );\\n\\n    // update over collat debt\\n    moneyMarketDs.overCollatDebtShares[_token] += _shareToAdd;\\n    moneyMarketDs.overCollatDebtValues[_token] += _amount;\\n\\n    // update global debt\\n    moneyMarketDs.globalDebts[_token] += _amount;\\n\\n    // update user's debtshare\\n    userDebtShare.addOrUpdate(_token, userDebtShare.getAmount(_token) + _shareToAdd);\\n    // revert if number of debt tokens exceed limit per sub account\\n    uint256 _userDebtShareLen = userDebtShare.length();\\n    if (_userDebtShareLen > moneyMarketDs.maxNumOfDebtPerSubAccount) {\\n      revert LibMoneyMarket01_NumberOfTokenExceedLimit();\\n    }\\n\\n    // mint debt token to money market and stake to miniFL\\n    address _debtToken = moneyMarketDs.tokenToDebtTokens[_token];\\n\\n    // pool for debt token always exist\\n    // since pool is created during AdminFacet.openMarket()\\n    IDebtToken(_debtToken).mint(address(this), _shareToAdd);\\n    IERC20(_debtToken).safeApprove(address(_miniFL), _shareToAdd);\\n    _miniFL.deposit(_account, moneyMarketDs.miniFLPoolIds[_debtToken], _shareToAdd);\\n\\n    emit LogOverCollatBorrow(_account, _subAccount, _token, _amount, _shareToAdd, _userDebtShareLen);\\n  }\\n\\n  /// @dev Do non collat borrow\\n  /// @param _account The non collat borrower address\\n  /// @param _token The token address\\n  /// @param _amount The amount to borrow\\n  /// @param moneyMarketDs The storage of money market\\n  function nonCollatBorrow(\\n    address _account,\\n    address _token,\\n    uint256 _amount,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal {\\n    // init lists\\n    //  1. debtValue\\n    LibDoublyLinkedList.List storage debtValue = moneyMarketDs.nonCollatAccountDebtValues[_account];\\n    debtValue.initIfNotExist();\\n\\n    //  2. tokenDebts\\n    LibDoublyLinkedList.List storage tokenDebts = moneyMarketDs.nonCollatTokenDebtValues[_token];\\n    tokenDebts.initIfNotExist();\\n\\n    // update account debt\\n    uint256 _newAccountDebt = debtValue.getAmount(_token) + _amount;\\n    uint256 _newTokenDebt = tokenDebts.getAmount(msg.sender) + _amount;\\n\\n    debtValue.addOrUpdate(_token, _newAccountDebt);\\n\\n    // revert if number of debt value exceed limit per non collat account\\n    if (debtValue.length() > moneyMarketDs.maxNumOfDebtPerNonCollatAccount) {\\n      revert LibMoneyMarket01_NumberOfTokenExceedLimit();\\n    }\\n\\n    tokenDebts.addOrUpdate(msg.sender, _newTokenDebt);\\n\\n    // update global debt\\n    moneyMarketDs.globalDebts[_token] += _amount;\\n  }\\n\\n  /// @dev SafeTransferFrom that revert when not receiving full amount (have fee on transfer)\\n  /// @param _token The token address\\n  /// @param _from The address to pull token from\\n  /// @param _amount The amount to pull\\n  function pullExactTokens(\\n    address _token,\\n    address _from,\\n    uint256 _amount\\n  ) internal {\\n    // get the token balance of money market before transfer\\n    uint256 _balanceBefore = IERC20(_token).balanceOf(address(this));\\n    // transfer token from _from to money market\\n    IERC20(_token).safeTransferFrom(_from, address(this), _amount);\\n    // check if the token balance of money market is increased by _amount\\n    // if fee on transer tokens is not supported this will revert\\n    if (IERC20(_token).balanceOf(address(this)) - _balanceBefore != _amount) {\\n      revert LibMoneyMarket01_FeeOnTransferTokensNotSupported();\\n    }\\n  }\\n\\n  /// @dev SafeTransferFrom that return actual amount received\\n  /// @param _token The token address\\n  /// @param _from The address to pull token from\\n  /// @param _amount The amount to pull\\n  /// @return _actualAmountReceived The actual amount received\\n  function unsafePullTokens(\\n    address _token,\\n    address _from,\\n    uint256 _amount\\n  ) internal returns (uint256 _actualAmountReceived) {\\n    // get the token balance of money market before transfer\\n    uint256 _balanceBefore = IERC20(_token).balanceOf(address(this));\\n    // transfer token from _from to money market\\n    IERC20(_token).safeTransferFrom(_from, address(this), _amount);\\n    // return actual amount received = balance after transfer - balance before transfer\\n    _actualAmountReceived = IERC20(_token).balanceOf(address(this)) - _balanceBefore;\\n  }\\n\\n  /// @dev Check if the money market is live, revert when not live\\n  /// @param moneyMarketDs The storage of money market\\n  function onlyLive(MoneyMarketDiamondStorage storage moneyMarketDs) internal view {\\n    if (moneyMarketDs.emergencyPaused) {\\n      revert LibMoneyMarket01_EmergencyPaused();\\n    }\\n  }\\n\\n  /// @dev Check if caller is account manager, revert when not account manager\\n  /// @param moneyMarketDs The storage of money market\\n  function onlyAccountManager(MoneyMarketDiamondStorage storage moneyMarketDs) internal view {\\n    if (!moneyMarketDs.accountManagersOk[msg.sender]) {\\n      revert LibMoneyMarket01_UnAuthorized();\\n    }\\n  }\\n\\n  /// @dev Write off the subaccount's debt that has no collateral backed\\n  /// WARNING: Only called this when all interests have been accrued\\n  /// @param _subAccount The subAccount to be written off\\n  /// @param moneyMarketDs The storage of money market\\n  function writeOffBadDebt(\\n    address _account,\\n    address _subAccount,\\n    MoneyMarketDiamondStorage storage moneyMarketDs\\n  ) internal {\\n    // skip this if there're still collaterals under the subAccount\\n    if (moneyMarketDs.subAccountCollats[_subAccount].size != 0) {\\n      return;\\n    }\\n\\n    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();\\n\\n    address _token;\\n    uint256 _shareToRemove;\\n    uint256 _amountToRemove;\\n    uint256 _length = _borrowed.length;\\n\\n    // loop over all outstanding debt\\n    for (uint256 _i; _i < _length; ) {\\n      _token = _borrowed[_i].token;\\n      _shareToRemove = _borrowed[_i].amount;\\n\\n      // Price in the actual amount to be written off\\n      _amountToRemove = LibShareUtil.shareToValue(\\n        _shareToRemove,\\n        moneyMarketDs.overCollatDebtValues[_token],\\n        moneyMarketDs.overCollatDebtShares[_token]\\n      );\\n\\n      // Reset debts of the token under subAccount\\n      removeOverCollatDebtFromSubAccount(_account, _subAccount, _token, _shareToRemove, _amountToRemove, moneyMarketDs);\\n\\n      emit LogWriteOffSubAccountDebt(_subAccount, _token, _shareToRemove, _amountToRemove);\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/libraries/LibSafeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { IERC20 } from \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary LibSafeToken {\\n  function safeTransfer(\\n    IERC20 _token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    require(isContract(_token), \\\"!contract\\\");\\n    (bool success, bytes memory data) = address(_token).call(\\n      abi.encodeWithSelector(_token.transfer.selector, to, value)\\n    );\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransfer\\\");\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 _token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    require(isContract(_token), \\\"!not contract\\\");\\n    (bool success, bytes memory data) = address(_token).call(\\n      abi.encodeWithSelector(_token.transferFrom.selector, from, to, value)\\n    );\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransferFrom\\\");\\n  }\\n\\n  function safeApprove(\\n    IERC20 _token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    require(isContract(_token), \\\"!not contract\\\");\\n    (bool success, bytes memory data) = address(_token).call(\\n      abi.encodeWithSelector(_token.approve.selector, to, value)\\n    );\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeApprove\\\");\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _addValue\\n  ) internal {\\n    require(isContract(_token), \\\"!not contract\\\");\\n    uint256 currentAllowance = _token.allowance(msg.sender, _spender);\\n    (bool success, bytes memory data) = address(_token).call(\\n      abi.encodeWithSelector(_token.approve.selector, _spender, currentAllowance + _addValue)\\n    );\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeIncreaseAllowance\\\");\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _substractValue\\n  ) internal {\\n    unchecked {\\n      require(isContract(_token), \\\"!not contract\\\");\\n      uint256 currentAllowance = _token.allowance(address(this), _spender);\\n      require(currentAllowance >= _substractValue, \\\"LibSafeToken: decreased allowance below zero\\\");\\n      (bool success, bytes memory data) = address(_token).call(\\n        abi.encodeWithSelector(_token.approve.selector, _spender, currentAllowance - _substractValue)\\n      );\\n      require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeDecreaseAllowance\\\");\\n    }\\n  }\\n\\n  function safeTransferETH(address to, uint256 value) internal {\\n    // solhint-disable-next-line no-call-value\\n    (bool success, ) = to.call{ value: value }(new bytes(0));\\n    require(success, \\\"!safeTransferETH\\\");\\n  }\\n\\n  function isContract(IERC20 account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/money-market/libraries/LibShareUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\npragma solidity 0.8.19;\\n\\nimport { LibFullMath } from \\\"./LibFullMath.sol\\\";\\n\\nlibrary LibShareUtil {\\n  function shareToValue(\\n    uint256 _shareAmount,\\n    uint256 _totalValue,\\n    uint256 _totalShare\\n  ) internal pure returns (uint256) {\\n    if (_totalShare == 0) {\\n      return _shareAmount;\\n    }\\n    return LibFullMath.mulDiv(_shareAmount, _totalValue, _totalShare);\\n  }\\n\\n  function valueToShare(\\n    uint256 _tokenAmount,\\n    uint256 _totalShare,\\n    uint256 _totalValue\\n  ) internal pure returns (uint256) {\\n    if (_totalShare == 0) {\\n      return _tokenAmount;\\n    }\\n    return LibFullMath.mulDiv(_tokenAmount, _totalShare, _totalValue);\\n  }\\n\\n  function valueToShareRoundingUp(\\n    uint256 _tokenAmount,\\n    uint256 _totalShare,\\n    uint256 _totalValue\\n  ) internal pure returns (uint256) {\\n    uint256 _shares = valueToShare(_tokenAmount, _totalShare, _totalValue);\\n    uint256 _shareValues = shareToValue(_shares, _totalValue, _totalShare);\\n    if (_shareValues + 1 == _tokenAmount) {\\n      _shares += 1;\\n    }\\n    return _shares;\\n  }\\n\\n  function shareToValueRoundingUp(\\n    uint256 _shareAmount,\\n    uint256 _totalValue,\\n    uint256 _totalShare\\n  ) internal pure returns (uint256) {\\n    uint256 _values = shareToValue(_shareAmount, _totalValue, _totalShare);\\n    uint256 _valueShares = valueToShare(_values, _totalShare, _totalValue);\\n    if (_valueShares + 1 == _shareAmount) {\\n      _values += 1;\\n    }\\n    return _values;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_miniFL\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initializationContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"InitializationFunctionReverted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MoneyMarketDiamond_InvalidAddress\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MoneyMarketDiamond", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000002e28cbf8995969d4ea1f03ffb6f25dab8afee45c0000000000000000000000004579587ae043131999ce3d9c66199726972e3fb7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xe6f38b2b81a3401f8c28286d5bd5345502e33917", "SwarmSource": ""}