{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\n/************************************************************\r\n *                                                          *\r\n *        github: https://github.com/metabasenet/mnb        *\r\n *                                                          *\r\n ************************************************************\r\n *                                                          *\r\n *           H5 app: https://mnb.metabasenet.site           *\r\n *                                                          *\r\n ************************************************************/\r\n \r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    function sqrt3(uint y) internal pure returns (uint z) {\r\n        z = sqrt(y * 10**12);\r\n        z = sqrt(z * 10**6);\r\n        z = sqrt(z * 10**6);\r\n    }\r\n\r\n    // decimals = 18;\r\n    // (10**decimals) ** 0.125\r\n    function vote2power(uint y) internal pure returns (uint z) {\r\n        if (y >= 6**8 * 1 ether) {\r\n            z = z * 6 / 100;\r\n        } else {\r\n            z = y * sqrt3(y) / 17782794100;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswap {\r\n    \r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    \r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    \r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n}\r\n\r\ncontract MNB {\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = 'Metabase Network On BSC';\r\n    string public constant symbol = 'MNB';\r\n    uint8 public constant decimals = 18;\r\n    uint  public totalSupply;\r\n\r\n    mapping(address => uint) public balances;\r\n    mapping(address => Airdrop) public airdrops;\r\n\r\n    function balanceOf(address owner) external view returns(uint ret) {\r\n        ret = balances[owner];\r\n        if (spreads[owner].parent == address(0)) {\r\n            ret = ret.add(airdrops[owner].vote); \r\n        } else {\r\n            ret = ret.add(spreads[owner].vote);\r\n        }\r\n    }\r\n\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function pairFor(address factory,bytes memory code_hash) private view returns (address addr) {\r\n        (address token0, address token1) = address(this) < USDT ? (address(this),USDT) : (USDT,address(this));\r\n        addr = address(uint160(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                code_hash\r\n            )))));\r\n    }\r\n\r\n    constructor() {\r\n        \r\n        pair = pairFor(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73,hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5');\r\n        \r\n        uint _totalSupply = 1000_000 ether;\r\n        _mint(msg.sender, _totalSupply);\r\n        begin = block.number;\r\n        spreads_length = 1;\r\n        spreads[msg.sender] = Info({\r\n            parent : address(this),\r\n            cycle : 1,\r\n            vote : 0,\r\n            vote_power : 0,\r\n            real_power : 0,\r\n            lock_number : 0,\r\n            child : new address[](0)});\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balances[to] = balances[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balances[from] = balances[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {        \r\n        balances[from] = balances[from].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferVote(address to, uint value) external returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        airdrops[to].vote = airdrops[to].vote.add(value);\r\n        if (spreads[to].parent != address(0)) {\r\n            spreads[to].vote = spreads[to].vote.add(value);\r\n            spreads[to].vote_power = SafeMath.vote2power(spreads[to].vote);\r\n        }\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        if (allowance[from][msg.sender] < (2**256 - 1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    struct LP {\r\n        uint lp;\r\n        uint quantity;\r\n        uint weight;\r\n        uint lock_number;\r\n    }\r\n\r\n    struct Airdrop {\r\n        uint cycle;\r\n        uint vote;\r\n    }\r\n    // \r\n    uint public whole_weight = 0;\r\n    // \r\n    uint public whole_quantity = 0;\r\n    //\r\n    mapping(address => LP) public lps;\r\n\r\n    uint public begin;\r\n    // \r\n    uint public height = 0;\r\n    //\r\n    uint public constant height_profit = 0.05 ether;\r\n    // \r\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    uint public constant cycle_period = 15 * 24 * 60 * 20;\r\n    // \r\n    uint public constant cycle_profit = 15 * 24 * 60 * 20 * (0.05 ether);\r\n    \r\n    address public pair;\r\n\r\n    function addLiquidity(uint amount) external returns (uint usdt_amount, uint liquidity) { \r\n        require(spreads[msg.sender].parent != address(0), \"Parent address is not a generalization set\");\r\n        (uint reserveA, uint reserveB,) = IUniswap(pair).getReserves();\r\n        usdt_amount = address(this) < USDT ? amount.mul(reserveB) / reserveA : amount.mul(reserveA) / reserveB;\r\n        _transfer(msg.sender, pair, amount);\r\n        IUniswap(USDT).transferFrom(msg.sender, pair, usdt_amount);\r\n        liquidity = IUniswap(pair).mint(address(this));\r\n\r\n        updateLP();\r\n        lps[msg.sender].lp = lps[msg.sender].lp.add(liquidity);\r\n        lps[msg.sender].lock_number = block.number;\r\n        Add(msg.sender,amount);\r\n    }\r\n\r\n    function removeLiquidity(uint liquidity) external returns (uint amountMNB, uint amountUSDT) {\r\n        require(spreads[msg.sender].parent != address(0), \"Parent address is not a generalization set\");\r\n        require(block.number > (lps[msg.sender].lock_number + cycle_period * 2),\"The unlocking date has not yet arrived\");\r\n        \r\n        uint lp = lps[msg.sender].lp;\r\n        assert(liquidity <= lp);\r\n        IUniswap(pair).transfer(pair, liquidity);\r\n        (uint amount0, uint amount1) = IUniswap(pair).burn(msg.sender);\r\n        (amountMNB, amountUSDT) = address(this) < USDT ? (amount0, amount1) : (amount1, amount0);\r\n    \r\n        updateLP();\r\n        lps[msg.sender].lp = lp.sub(liquidity);\r\n        Del(msg.sender,lps[msg.sender].quantity.mul(liquidity) / lp);\r\n    }\r\n\r\n    function updateLP() private {\r\n        if (whole_weight > 0) {\r\n            uint add_height = block.number.sub(begin.add(height));\r\n            if (add_height > 0) {\r\n                height = height.add(add_height);\r\n                whole_quantity = whole_quantity.add(add_height.mul(height_profit));\r\n            }\r\n        }\r\n    }\r\n\r\n    function Add(address addr,uint q) private {\r\n        if (whole_quantity > 0) {\r\n            uint x = whole_weight.mul(q) / whole_quantity;\r\n            whole_quantity = whole_quantity.add(q);\r\n            whole_weight = whole_weight.add(x);\r\n            lps[addr].quantity = lps[addr].quantity.add(q);\r\n            lps[addr].weight = lps[addr].weight.add(x);\r\n        } else {\r\n            whole_quantity = q;\r\n            whole_weight = q;\r\n            lps[addr].weight = q;\r\n            lps[addr].quantity = q;\r\n        }\r\n    }\r\n\r\n    function Del(address addr,uint q) private {\r\n        uint quantity = lps[addr].quantity;\r\n        if (quantity > 0) {\r\n            if (q > quantity) {\r\n                q = quantity;\r\n            }\r\n            uint weight = lps[addr].weight;\r\n            uint new_weight = weight.mul(q) / quantity;\r\n            uint out_quantity = whole_quantity.mul(new_weight) / whole_weight;\r\n            _mint(msg.sender,out_quantity.sub(q));\r\n            \r\n            lps[addr].weight = weight.sub(new_weight);\r\n            lps[addr].quantity = quantity.sub(q);\r\n            whole_weight  = whole_weight.sub(new_weight);\r\n            whole_quantity = whole_quantity.sub(out_quantity);\r\n        }\r\n    }\r\n\r\n    struct Info {\r\n        address parent;\r\n        address[] child;\r\n        //       \r\n        uint cycle;\r\n        // Voting\r\n        uint vote;\r\n        // Voting power\r\n        uint vote_power;\r\n        // Real computing power\r\n        uint real_power;\r\n        // Voting lock number\r\n        uint lock_number;\r\n    }\r\n\r\n    mapping(address => Info) public spreads;\r\n    uint public spreads_length;\r\n}\r\n\r\ncontract Mining is MNB\r\n{\r\n    using SafeMath for uint;\r\n    bytes32 private DOMAIN_SEPARATOR;\r\n\r\n    //keccak256(\"popularize(address addr)\");\r\n    bytes32 private constant PERMIT_TYPEHASH = 0x21cf163f92d861d4d1aca6cf2580b603353711f20e52675c104cd16e528edf30;\r\n\r\n    //keccak256(\"setChild(address addr_old,address addr_new)\");\r\n    bytes32 private constant PERMIT_TYPEHASH_SETCHILD = 0x9d76e746d4f1502d91350b8de3086a0a837140a295a5bc95668fa2a961dca549;\r\n\r\n    struct power_profit {\r\n        uint power;\r\n        uint profit;\r\n    }\r\n    \r\n    uint public whole_power = 0;\r\n    mapping(uint => power_profit) public power_profit_whole;\r\n    uint public cycle = 1;\r\n  \r\n    event Popularize(address indexed parent, address indexed children,uint indexed cycle,uint timestamp);\r\n    event VoteIn(address indexed addr,uint indexed cycle,uint timestamp,uint value);\r\n    event VoteOut(address indexed addr,uint indexed cycle,uint timestamp,uint value);\r\n    \r\n    /**\r\n     * @dev constructor\r\n     */\r\n    constructor() {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        emit Popularize(address(this), msg.sender,cycle,block.timestamp);\r\n    }\r\n\r\n    function popularizeFast(address addr,address temp,\r\n        uint8 addr_v, bytes32 addr_r, bytes32 addr_s,\r\n        uint8 temp_v, bytes32 temp_r, bytes32 temp_s)\r\n        external returns (bool ret)\r\n    {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, temp))\r\n            )\r\n        );\r\n        require(addr == ecrecover(digest, addr_v, addr_r, addr_s),\"signature data1 error\");\r\n        require(temp == ecrecover(keccak256(abi.encodePacked(msg.sender)),temp_v, temp_r, temp_s),\"signature data2 error\");\r\n        return popularize(addr);\r\n    }\r\n\r\n    function popularize(address addr,uint8 v, bytes32 r, bytes32 s) external returns (bool ret)\r\n    {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, msg.sender))\r\n            )\r\n        );\r\n        require(addr == ecrecover(digest, v, r, s),\"signature data error\");\r\n        return popularize(addr);\r\n    }\r\n\r\n    /**\r\n     * @dev popularize\r\n     */\r\n    function popularize(address addr) private returns (bool ret)\r\n    {\r\n        require(spreads[msg.sender].parent != address(0), \"Parent address is not a generalization set\");\r\n        require(spreads[addr].parent == address(0), \"Address has been promoted\");\r\n        require(spreads[msg.sender].child.length < 36,\"Promotion data cannot be greater than 36\");\r\n        spreads[addr] = Info({\r\n            parent : msg.sender,\r\n            cycle : cycle,\r\n            vote : airdrops[addr].vote,\r\n            vote_power : SafeMath.vote2power(airdrops[addr].vote),\r\n            real_power : 0,\r\n            lock_number : 0,\r\n            child : new address[](0)});\r\n        spreads[msg.sender].child.push(addr);\r\n        spreads_length++;\r\n        airdrops[addr].cycle = cycle + 120;\r\n        emit Popularize(msg.sender,addr,cycle,block.timestamp);\r\n        ret = true;\r\n    }\r\n\r\n    function setChild(address addr_old,address addr_new,uint8 v, bytes32 r, bytes32 s) external {\r\n        assert(spreads[addr_old].parent == msg.sender && spreads[addr_new].parent == address(0));\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH_SETCHILD,addr_old,addr_new))\r\n            )\r\n        );\r\n        require(addr_old == ecrecover(digest, v, r, s),\"signature data error\");\r\n        spreads[addr_new] = Info({\r\n            parent : spreads[addr_old].parent,\r\n            cycle : spreads[addr_old].cycle,\r\n            vote : spreads[addr_old].vote,\r\n            vote_power : spreads[addr_old].vote_power,\r\n            real_power : spreads[addr_old].real_power,\r\n            lock_number : spreads[addr_old].lock_number,\r\n            child : spreads[addr_old].child});\r\n        for (uint i = 0; i < spreads[msg.sender].child.length; i++) {\r\n            if (spreads[msg.sender].child[i] == addr_old) {\r\n                spreads[msg.sender].child[i] = addr_new;\r\n            }    \r\n        }\r\n        for (uint i = 0; i < spreads[addr_old].child.length; i++) {\r\n            spreads[spreads[addr_old].child[i]].parent = addr_new;\r\n        }\r\n        delete spreads[addr_old];\r\n        \r\n        assert(airdrops[addr_new].cycle == 0 && airdrops[addr_new].vote == 0);\r\n        airdrops[addr_new].cycle = airdrops[addr_old].cycle;\r\n        airdrops[addr_new].vote = airdrops[addr_old].vote;\r\n        airdrops[addr_old].cycle = 0;\r\n        airdrops[addr_old].vote = 0;\r\n        \r\n        assert(balances[addr_new] == 0);\r\n        balances[addr_new] = balances[addr_old];\r\n        balances[addr_old] = 0;\r\n    \r\n        lps[addr_new] = LP({\r\n            lp : lps[addr_old].lp,\r\n            quantity : lps[addr_old].quantity,\r\n            weight : lps[addr_old].weight,\r\n            lock_number : lps[addr_old].lock_number     \r\n        });\r\n        delete lps[addr_old];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev voteIn\r\n     */\r\n    function voteIn(uint256 value) external returns (uint ret)\r\n    {\r\n        _update();\r\n        require(spreads[msg.sender].parent != address(0), \"Parent address is not a generalization set\");\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        spreads[msg.sender].vote = spreads[msg.sender].vote.add(value);\r\n        spreads[msg.sender].vote_power = SafeMath.vote2power(spreads[msg.sender].vote);\r\n        emit VoteIn(msg.sender,cycle,block.timestamp,value);\r\n        _voteMining(msg.sender);\r\n        ret = value;\r\n    }\r\n\r\n    /**\r\n     * @dev voteOut\r\n     */\r\n    function voteOut(uint256 value) external returns (uint ret)\r\n    {\r\n        _update();\r\n        require(spreads[msg.sender].parent != address(0), \"Parent address is not a generalization set\");\r\n        require(block.number > (spreads[msg.sender].lock_number + cycle_period * 2),\"The unlocking date has not yet arrived\");\r\n        \r\n        uint vote = airdrops[msg.sender].vote;\r\n        if (vote > 0) {\r\n            if (cycle <= airdrops[msg.sender].cycle) {\r\n                require(spreads[msg.sender].vote.sub(value) >= vote,\"Air drop cannot be claimed in advance\");\r\n            } else if (cycle <= airdrops[msg.sender].cycle.add(50)) {\r\n                require(spreads[msg.sender].vote.sub(value) >= vote * (airdrops[msg.sender].cycle.add(50).sub(cycle)) / 50,\"Too many airdrops\");\r\n            }\r\n        }\r\n        spreads[msg.sender].vote = spreads[msg.sender].vote.sub(value);\r\n        spreads[msg.sender].vote_power = SafeMath.vote2power(spreads[msg.sender].vote);\r\n        balances[msg.sender] = balances[msg.sender].add(value);\r\n        emit VoteOut(msg.sender,cycle,block.timestamp,value);\r\n        ret = value;\r\n    }\r\n\r\n    /**\r\n     * @dev voteMining()\r\n     */\r\n    function voteMining() external returns (uint mint,uint f)\r\n    {\r\n        require(spreads[msg.sender].parent != address(0), \"Parent address is not a generalization set\");\r\n        return _voteMining(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev parents(address addr)\r\n     */\r\n    function parents(address addr) private view returns(\r\n        address[] memory addrs,\r\n        uint[] memory powers,\r\n        uint power_sum) \r\n    {\r\n        power_sum = 0;\r\n        uint l = 0;\r\n        address addr_temp = addr;\r\n        while (spreads[addr_temp].parent != address(this)) {\r\n            addr_temp = spreads[addr_temp].parent;\r\n            l++;\r\n        }\r\n        powers = new uint[](l);\r\n        addrs = new address[](l);\r\n        l = 0;\r\n        addr_temp = addr;\r\n        while (spreads[addr_temp].parent != address(this)) {\r\n            addr_temp = spreads[addr_temp].parent;\r\n            addrs[l] = addr_temp;\r\n            uint pow = spreads[addr_temp].vote_power;\r\n            powers[l] = pow;\r\n            power_sum = power_sum.add(pow);\r\n            l++;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev _voteMining\r\n     */\r\n    function _voteMining(address addr) private returns (uint mint,uint f)\r\n    {\r\n        _update();\r\n        if (spreads[addr].cycle < cycle) {\r\n            uint old_cycle = spreads[addr].cycle;\r\n            uint old_profit = power_profit_whole[old_cycle].profit;\r\n            uint old_power = power_profit_whole[old_cycle].power;\r\n            if (old_power > 0) {\r\n                uint v = old_profit.mul(spreads[addr].real_power) / old_power;\r\n                if (cycle > 120) {\r\n                    _mint(addr,v);\r\n                } else {\r\n                    (address[] memory addrs, uint[] memory powers,uint power_sum) = parents(addr);\r\n                    uint p = v.mul(2) / 10;\r\n                    if (power_sum > 0) {\r\n                        for (uint i = 0; i < addrs.length; i++) {\r\n                            // 256 MNT 5.12pow \r\n                            if (powers[i] >= 5.12 ether) {\r\n                                uint ret = p.mul(powers[i]) / power_sum;\r\n                                _mint(addrs[i], ret);\r\n                            }\r\n                        }\r\n                    }\r\n                    _mint(addr,v.sub(p));\r\n                }\r\n                mint = v;\r\n            }\r\n            spreads[addr].real_power = 0;\r\n            spreads[addr].cycle = cycle;\r\n        }\r\n        uint old_s = spreads[addr].real_power;\r\n        uint s = spreadPower(addr);\r\n        if (s > old_s) {\r\n            whole_power = whole_power.add(s.sub(old_s));\r\n            spreads[addr].real_power = s;\r\n            spreads[addr].lock_number = block.number;\r\n            f = s;\r\n        } else {\r\n            f = 0;\r\n        }\r\n    }\r\n\r\n    function _update() private returns (bool) {\r\n        if (block.number > begin.add(cycle.mul(cycle_period))) {\r\n            power_profit_whole[cycle] = power_profit({\r\n                power : whole_power,\r\n                profit : cycle_profit });\r\n            whole_power = 0;\r\n            cycle += 1;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev spreadChild\r\n     */\r\n    function spreadChild(address addr) public view returns (\r\n        address[] memory addrs,\r\n        uint[] memory votes,\r\n        uint[] memory powers) \r\n    {\r\n        addrs = spreads[addr].child;\r\n        uint n = spreads[addr].child.length;\r\n        votes = new uint[](n);\r\n        powers = new uint[](n);\r\n        for (uint i = 0; i < n; i++) {\r\n            votes[i] = spreads[addrs[i]].vote;\r\n            powers[i] = spreads[addrs[i]].vote_power;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev spreadParent(address addr)\r\n     */\r\n    function spreadParent(address addr) external view returns(\r\n        address[] memory addrs,\r\n        uint[] memory powers,\r\n        uint power_sum) \r\n    {\r\n        if (spreads[addr].parent == address(0) ) {\r\n            return (new address[](0),new uint[](0),0);\r\n        } else {\r\n            return parents(addr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev spreadPower\r\n     */\r\n    function spreadPower(address addr) public view returns (uint power_)\r\n    {\r\n        uint v = spreads[addr].vote_power;\r\n        uint sum = v.mul(4);\r\n        sum = sum.add(SafeMath.min(v,spreads[spreads[addr].parent].vote_power).mul(2));\r\n\r\n        uint n = spreads[addr].child.length;\r\n        for (uint i = 0; i < n; i++) {\r\n            sum = sum.add(SafeMath.min(v,spreads[spreads[addr].child[i]].vote_power));\r\n        }\r\n        power_ = sum;\r\n    }\r\n\r\n    function number2timestamp(uint number) private view returns(uint ts) {\r\n        if (block.number > number) {\r\n            ts = block.timestamp - (block.number - number) * 3;\r\n        } else if (block.number < number) {\r\n            ts = block.timestamp + (number - block.number) * 3;\r\n        } else {\r\n            ts = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function profit(address addr) external view returns(\r\n        uint lp_value, uint lp_ratio,\r\n        uint pow_value,uint pow_ratio,\r\n        bool reflect,  uint pow_out_time, uint lp_out_time,\r\n        uint number, uint timestamp) \r\n    {\r\n        number = block.number;\r\n        timestamp = block.timestamp;\r\n        if (lps[addr].weight == 0) {\r\n            lp_value = 0;\r\n            lp_ratio = 0;\r\n        } else {\r\n            uint add = block.number - begin - height;\r\n            lp_value = (whole_quantity + add * height_profit) * lps[addr].weight / whole_weight - lps[addr].quantity;\r\n            if (lp_value == 2**256 - 1) {\r\n                lp_value = 0;\r\n            }\r\n            lp_ratio = lps[addr].weight * 10**6 / whole_weight;\r\n        }\r\n        if (spreads[addr].real_power == 0) {\r\n            pow_value = 0;\r\n            pow_ratio = 0;\r\n        } else {\r\n            if (spreads[addr].cycle == cycle) {\r\n                if (cycle > 120) {\r\n                    pow_value = (cycle_profit * spreads[addr].real_power) / whole_power;\r\n                } else {\r\n                    pow_value = (cycle_profit * spreads[addr].real_power * 8) / (whole_power * 10);\r\n                }\r\n                pow_ratio = spreads[addr].real_power * 10**6 / whole_power;\r\n            } else {\r\n                if (spreads[addr].cycle > 120) {\r\n                    pow_value = cycle_profit * spreads[addr].real_power / power_profit_whole[spreads[addr].cycle].power;\r\n                } else {\r\n                    pow_value = (cycle_profit * spreads[addr].real_power * 8) / (power_profit_whole[spreads[addr].cycle].power * 10);\r\n                }\r\n                pow_ratio = spreads[addr].real_power * 10**6 / power_profit_whole[spreads[addr].cycle].power;\r\n            }\r\n        }\r\n\r\n        if (spreads[addr].cycle > 0 && block.number > begin + spreads[addr].cycle * cycle_period) {\r\n            reflect = true;\r\n        } else {\r\n            reflect = false;\r\n        }\r\n        if (spreads[addr].lock_number > 0) {\r\n            pow_out_time = number2timestamp(spreads[addr].lock_number + cycle_period * 2);\r\n        } else {\r\n            pow_out_time = 0;\r\n        }\r\n        if (lps[addr].lock_number > 0) {\r\n            lp_out_time = number2timestamp(lps[addr].lock_number + cycle_period * 2);\r\n        } else {\r\n            lp_out_time = 0;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"children\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Popularize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"VoteIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"VoteOut\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdt_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"airdrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vote\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"begin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycle_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycle_profit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"height\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"height_profit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lock_number\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"popularize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ret\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"temp\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"addr_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"addr_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"addr_s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"temp_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"temp_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"temp_s\",\"type\":\"bytes32\"}],\"name\":\"popularizeFast\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ret\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"power_profit_whole\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"profit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lp_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lp_ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pow_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pow_ratio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"reflect\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pow_out_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lp_out_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_old\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr_new\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"setChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"spreadChild\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"votes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"powers\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"spreadParent\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"powers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"power_sum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"spreadPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"power_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"spreads\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vote_power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"real_power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lock_number\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spreads_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"voteIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"f\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"voteOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whole_power\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whole_quantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whole_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Mining", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a1bf93c950bf7599ad13dacf9a03d8264a14b7d5ab103d3af7fddee10bbaf123"}