{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/p2pbet/bets/binary/P2PBinaryBetProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../../processing/TokenProcessing.sol\\\";\\nimport \\\"./BinaryDTOs.sol\\\";\\nimport \\\"./BinaryProcessor.sol\\\";\\n\\ncontract P2PBinaryBetProvider is TokenProcessing, BinaryProcessor {\\n    mapping(uint => BinaryDTOs.BinaryBet) private binaryBets;\\n    mapping(uint => BinaryDTOs.BinaryMatchingInfo) private matchingInfo;\\n    mapping(address => mapping(uint => BinaryDTOs.JoinBinaryBetClientList)) private clientInfo;\\n    mapping(address => uint[]) private clientBets;\\n    mapping(address => uint) public clientBetsLength;\\n    uint public binaryBetIdCounter;\\n    bool public cancelEnabled = false;\\n\\n    constructor(address mainToken, address[] memory owners) TokenProcessing(mainToken) {\\n        for (uint i = 0; i < owners.length; i++) {\\n            addOwner(owners[i]);\\n        }\\n    }\\n\\n    function setCancelEnabled(bool enable) public onlyOwner {\\n        cancelEnabled = enable;\\n    }\\n\\n    function getClientBets(address client, uint offset, uint size) external view returns (uint[] memory) {\\n        uint resultSize = size;\\n        for (uint i = offset; i < offset + size; i++) {\\n            if (clientBets[client].length <= i) {\\n                resultSize = i - offset;\\n                break;\\n            }\\n        }\\n        uint[] memory result = new uint[](resultSize);\\n        for (uint i = offset; i < offset + resultSize; i++) {\\n            result[i - offset] = clientBets[client][i];\\n        }\\n        return result;\\n    }\\n\\n    function getBinaryBet(uint betId) external view returns (BinaryDTOs.BinaryBet memory, uint, uint) {\\n        BinaryDTOs.BinaryMatchingInfo storage info = matchingInfo[betId];\\n        return (binaryBets[betId], info.leftAmount, info.rightAmount);\\n    }\\n\\n    function getBinaryClientJoins(address client, uint betId) external view returns (BinaryDTOs.JoinBinaryBetClient[] memory) {\\n        BinaryDTOs.JoinBinaryBetClient[] memory clientList = new BinaryDTOs.JoinBinaryBetClient[](clientInfo[client][betId].length);\\n        for (uint i = 0; i < clientInfo[client][betId].length; i++) {\\n            clientList[i] = extractJoinBinaryBetClientByRef(matchingInfo[betId], clientInfo[client][betId].joinListRefs[i]);\\n        }\\n        return clientList;\\n    }\\n\\n    function refundBinaryBet(uint betId, address client) public {\\n        BinaryDTOs.BinaryBet storage binaryBet = binaryBets[betId];\\n        require(keccak256(abi.encodePacked(binaryBet.finalValue)) == keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PBinaryBetProvider: refund - binary haven't to be open\\\");\\n        require(keccak256(abi.encodePacked(binaryBet.lockedValue)) == keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PBinaryBetProvider: refund - binary haven't to be open\\\");\\n        require(binaryBet.expirationTime + getTimestampExpirationDelay() < block.timestamp, \\\"P2PBinaryBetProvider: refund - expiration error\\\");\\n\\n        uint mainTokenToRefund = processRefundingBinaryBet(matchingInfo[betId], clientInfo[client][betId]);\\n        require(mainTokenToRefund > 0, \\\"P2PBinaryBetProvider: refund - nothing\\\");\\n        withdrawalMainToken(client, mainTokenToRefund);\\n\\n        emit BinaryBetRefunded(\\n            betId,\\n            client,\\n            mainTokenToRefund\\n        );\\n    }\\n\\n    function takeBinaryPrize(uint betId, address client, bool useAlterFee) public {\\n        BinaryDTOs.BinaryBet storage binaryBet = binaryBets[betId];\\n        require(keccak256(abi.encodePacked(binaryBet.finalValue)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PBinaryBetProvider: take prize - binary bet wasn't closed\\\");\\n        require(keccak256(abi.encodePacked(binaryBet.lockedValue)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PBinaryBetProvider: take prize - binary bet wasn't closed\\\");\\n\\n        uint wonAmount = takePrize(binaryBet, matchingInfo[betId], clientInfo[client][betId]);\\n\\n        require(wonAmount > 0, \\\"P2PBinaryBetProvider: take prize - nothing\\\");\\n\\n        uint wonAmountAfterFee = takeFeeFromAmount(msg.sender, wonAmount, useAlterFee);\\n\\n        withdrawalMainToken(client, wonAmountAfterFee);\\n\\n        emit BinaryPrizeTaken(\\n            betId,\\n            client,\\n            wonAmountAfterFee,\\n            useAlterFee\\n        );\\n    }\\n\\n    function getBinaryWonAmount(uint betId, address client) public view returns (uint) {\\n        BinaryDTOs.BinaryBet storage binaryBet = binaryBets[betId];\\n        if (keccak256(abi.encodePacked(binaryBet.finalValue)) == keccak256(abi.encodePacked(\\\"\\\"))) {\\n            return 0;\\n        }\\n\\n        return evaluatePrize(binaryBet, matchingInfo[betId], clientInfo[client][betId]);\\n    }\\n\\n    function closeBinaryBet(uint betId, string calldata lockedValue, string calldata finalValue, bool sideWon) external onlyCompany {\\n        require(keccak256(abi.encodePacked(finalValue)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PBinaryBetProvider: close error - binary bet can't be closed with empty final value\\\");\\n        require(keccak256(abi.encodePacked(lockedValue)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PBinaryBetProvider: close error - binary bet can't be closed with empty locked value\\\");\\n        BinaryDTOs.BinaryBet storage binaryBet = binaryBets[betId];\\n        require(binaryBet.expirationTime < block.timestamp, \\\"P2PBinaryBetProvider: close error - expiration error\\\");\\n        require(binaryBet.expirationTime + getTimestampExpirationDelay() > block.timestamp, \\\"P2PBinaryBetProvider: close error - expiration error with delay\\\");\\n        require(keccak256(abi.encodePacked(binaryBet.finalValue)) == keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PBinaryBetProvider: close error - bet already closed\\\");\\n\\n        binaryBet.finalValue = finalValue;\\n        binaryBet.lockedValue = lockedValue;\\n        binaryBet.sideWon = sideWon;\\n\\n        emit BinaryBetClosed(\\n            betId,\\n            lockedValue,\\n            finalValue,\\n            sideWon\\n        );\\n    }\\n\\n    function cancelBinaryJoin(uint betId, uint joinIdRef) external {\\n        require(cancelEnabled, \\\"P2PBinaryBetProvider: cancel disabled\\\");\\n\\n        BinaryDTOs.JoinBinaryBetClient storage clientJoin = extractJoinBinaryBetClientByRef(matchingInfo[betId], clientInfo[msg.sender][betId].joinListRefs[joinIdRef]);\\n\\n        require(clientJoin.amount != 0, \\\"P2PBinaryBetProvider: cancel - free amount empty\\\");\\n        require(binaryBets[betId].lockTime >= block.timestamp, \\\"P2PBinaryBetProvider: cancel - lock time\\\");\\n\\n        uint mainTokenToRefund = cancelBinaryBet(matchingInfo[betId], clientJoin);\\n        withdrawalMainToken(msg.sender, mainTokenToRefund);\\n\\n        emit BinaryBetCancelled(\\n            betId,\\n            msg.sender,\\n            joinIdRef,\\n            mainTokenToRefund\\n        );\\n    }\\n\\n    function createBinaryBet(BinaryDTOs.CreateBinaryRequest calldata createRequest) external onlyCompany returns (uint) {\\n        // lock - 60 * 3\\n        // expiration - 60 * 3\\n        require(createRequest.lockTime >= block.timestamp + 3 * 60, \\\"P2PBinaryBetProvider: create - lock time\\\");\\n        require(createRequest.expirationTime >= createRequest.lockTime + 3 * 60, \\\"P2PBinaryBetProvider: create - expirationTime time\\\");\\n\\n        uint betId = binaryBetIdCounter++;\\n        binaryBets[betId] = BinaryDTOs.BinaryBet(\\n            betId,\\n            createRequest.eventId,\\n            createRequest.lockTime,\\n            createRequest.expirationTime,\\n            \\\"\\\",\\n            \\\"\\\",\\n            false\\n        );\\n\\n        emit BinaryBetCreated(\\n            betId,\\n            createRequest.eventId,\\n            createRequest.lockTime,\\n            createRequest.expirationTime,\\n            msg.sender\\n        );\\n\\n        return betId;\\n    }\\n\\n    function joinBinaryBet(uint betId, BinaryDTOs.JoinBinaryRequest calldata joinRequest) public {\\n        require(binaryBets[betId].lockTime >= block.timestamp, \\\"CustomBetProvider: cancel - lock time\\\");\\n        clientBets[msg.sender].push(betId);\\n        clientBetsLength[msg.sender]++;\\n\\n        BinaryDTOs.JoinBinaryBetClientList storage clientBetList = clientInfo[msg.sender][betId];\\n\\n        // deposit amounts\\n        DepositedValue memory depositedValue = deposit(msg.sender, joinRequest.amount);\\n\\n        uint mainAmount = depositedValue.mainAmount;\\n\\n        BinaryDTOs.JoinBinaryBetClient memory joinBetClient = BinaryDTOs.JoinBinaryBetClient(\\n            0,\\n            msg.sender,\\n            mainAmount,\\n            joinRequest.side,\\n            clientBetList.length\\n        );\\n\\n\\n        // Custom bet enrichment with matching\\n        uint sidePointer = joinBinaryBet(matchingInfo[betId], joinBetClient);\\n\\n        // Add to client info sidePointer\\n        clientBetList.joinListRefs[clientBetList.length++] = BinaryDTOs.JoinBinaryBetClientRef(joinBetClient.side, sidePointer);\\n\\n        emit BinaryBetJoined(\\n            joinRequest.side,\\n            joinRequest.amount,\\n            msg.sender,\\n            betId,\\n            joinBetClient.id,\\n            clientBetList.length - 1\\n        );\\n    }\\n\\n    event BinaryBetCreated(\\n        uint id,\\n        string eventId,\\n        uint lockTime,\\n        uint expirationTime,\\n        address indexed creator\\n    );\\n\\n    event BinaryBetJoined(\\n        bool side,\\n        uint mainAmount,\\n        address indexed client,\\n        uint betId,\\n        uint joinId,\\n        uint joinRefId\\n    );\\n\\n    event BinaryBetCancelled(\\n        uint betId,\\n        address indexed client,\\n        uint joinIdRef,\\n        uint mainTokenRefunded\\n    );\\n\\n    event BinaryBetClosed(\\n        uint betId,\\n        string lockedValue,\\n        string finalValue,\\n        bool sideWon\\n    );\\n\\n    event BinaryPrizeTaken(\\n        uint betId,\\n        address indexed client,\\n        uint amount,\\n        bool useAlterFee\\n    );\\n\\n    event BinaryBetRefunded(\\n        uint betId,\\n        address indexed client,\\n        uint mainTokenRefunded\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/p2pbet/processing/TokenProcessing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Ownable.sol\\\";\\nimport \\\"./CompanyVault.sol\\\";\\nimport \\\"./AlternativeTokenHelper.sol\\\";\\nimport \\\"./FeeConfiguration.sol\\\";\\n\\nabstract contract TokenProcessing is CompanyVault, AlternativeTokenHelper, FeeConfiguration {\\n    event FeeTaken(uint amount, address indexed targetAddress, bool isAlternative);\\n\\n    struct DepositedValue {\\n        uint mainAmount;\\n    }\\n\\n    constructor(address mainToken) CompanyVault(mainToken) {}\\n\\n    // Deposit amount from sender\\n    function deposit(address sender, uint amount) internal returns (DepositedValue memory) {\\n        require(amount > 0, \\\"TokenProcessing - deposit zero amount\\\");\\n        depositToken(getMainIERC20Token(), sender, amount);\\n        return DepositedValue(amount);\\n    }\\n\\n    // Withdrawal main tokens to user\\n    // Used only in take prize and bet cancellation\\n    function withdrawalMainToken(address recipient, uint amount) internal {\\n        bool result = getMainIERC20Token().transfer(recipient, amount);\\n        require(result, \\\"TokenProcessing: withdrawal token failed\\\");\\n    }\\n\\n\\n    // Evaluate fee from amount and take it. Return the rest of it.\\n    function takeFeeFromAmount(address winner, uint amount, bool useAlternativeFee) internal returns (uint) {\\n        if (useAlternativeFee) {\\n            require(isAlternativeTokenEnabled(), \\\"TokenProcessing: alternative token disabled\\\");\\n            uint alternativeFeePart = applyAlternativeFee(amount);\\n            uint feeInAlternativeToken = evaluateAlternativeAmount(alternativeFeePart, address(getMainIERC20Token()), address(getAlternativeIERC20Token()));\\n            depositToken(getAlternativeIERC20Token(), winner, feeInAlternativeToken);\\n            increaseFee(feeInAlternativeToken, address(getAlternativeIERC20Token()));\\n            return amount;\\n        } else {\\n            uint feePart = applyCompanyFee(amount);\\n            increaseFee(feePart, address(getMainIERC20Token()));\\n            return amount - feePart;\\n        }\\n    }\\n\\n\\n    // Deposit amount of tokens from sender to this contract\\n    function depositToken(IERC20 token, address sender, uint amount) internal {\\n        require(token.allowance(sender, address(this)) >= amount, \\\"TokenProcessing: depositMainToken, not enough funds to deposit token\\\");\\n\\n        bool result = token.transferFrom(sender, address(this), amount);\\n        require(result, \\\"TokenProcessing: depositMainToken, transfer from failed\\\");\\n    }\\n\\n    // Start take company fee from main token company balance\\n    function takeFeeStart(uint amount, address targetAddress, bool isAlternative) external onlyOwner {\\n        if (isAlternative) {\\n            require(amount <= getCompanyFeeBalance(address(getAlternativeIERC20Token())), \\\"CompanyVault: take fee amount exeeds alter token balance\\\");\\n        } else {\\n            require(amount <= getCompanyFeeBalance(address(getMainIERC20Token())), \\\"CompanyVault: take fee amount exeeds token balance\\\");\\n        }\\n\\n        uint votingCode = startVoting(\\\"TAKE_FEE\\\");\\n        takeFeeVoting = SecurityDTOs.TakeFee(\\n            amount,\\n            targetAddress,\\n            isAlternative,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireTakeFee() external onlyOwner {\\n        pass(takeFeeVoting.votingCode);\\n\\n        IERC20 token;\\n        if (takeFeeVoting.isAlternative) {\\n            token = getAlternativeIERC20Token();\\n            decreaseFee(takeFeeVoting.amount, address(getAlternativeIERC20Token()));\\n        } else {\\n            token = getMainIERC20Token();\\n            decreaseFee(takeFeeVoting.amount, address(getMainIERC20Token()));\\n        }\\n\\n        bool result = token.transfer(takeFeeVoting.targetAddress, takeFeeVoting.amount);\\n        require(result, \\\"TokenProcessing: take fee transfer failed\\\");\\n        emit FeeTaken(takeFeeVoting.amount, takeFeeVoting.targetAddress, takeFeeVoting.isAlternative);\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/bets/binary/BinaryDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nlibrary BinaryDTOs {\\n    struct BinaryBet {\\n        uint id;\\n        string eventId;\\n        uint lockTime;\\n        uint expirationTime;\\n\\n        string lockedValue;\\n        string finalValue;\\n        bool sideWon;\\n    }\\n\\n    struct BinaryMatchingInfo {\\n        // side == true\\n        mapping(uint => JoinBinaryBetClient) leftSide;\\n        uint leftLength;\\n        // side == false\\n        mapping(uint => JoinBinaryBetClient) rightSide;\\n        uint rightLength;\\n\\n        uint leftAmount;\\n        uint rightAmount;\\n    }\\n\\n    struct JoinBinaryBetClientList {\\n        mapping(uint => JoinBinaryBetClientRef) joinListRefs;\\n        uint length;\\n    }\\n\\n    struct JoinBinaryBetClientRef {\\n        bool side;\\n        uint id;\\n    }\\n\\n    struct JoinBinaryBetClient {\\n        uint id;\\n        address client;\\n        uint amount;\\n        bool side;\\n        uint joinRefId;\\n    }\\n\\n    struct CreateBinaryRequest {\\n        string eventId;\\n        uint lockTime;\\n        uint expirationTime;\\n    }\\n\\n    struct JoinBinaryRequest {\\n        bool side;\\n        uint amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/p2pbet/bets/binary/BinaryProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./BinaryDTOs.sol\\\";\\n\\nabstract contract BinaryProcessor {\\n    // Refund main token and alter token(if pay alter fee)\\n    // Only after expiration + expirationDelay call without bet closed action\\n    function processRefundingBinaryBet(BinaryDTOs.BinaryMatchingInfo storage info, BinaryDTOs.JoinBinaryBetClientList storage clientList) internal returns (uint) {\\n        uint resultAmount;\\n        for (uint i = 0; i < clientList.length; ++i) {\\n            BinaryDTOs.JoinBinaryBetClient storage joinClient = extractJoinBinaryBetClientByRef(info, clientList.joinListRefs[i]);\\n            resultAmount += joinClient.amount;\\n\\n            joinClient.amount = 0;\\n        }\\n\\n        return resultAmount;\\n    }\\n\\n    // Evaluate mainToken for giving prize and modify joins\\n    // returns (mainToken amount)\\n    function takePrize(BinaryDTOs.BinaryBet storage bet, BinaryDTOs.BinaryMatchingInfo storage info, BinaryDTOs.JoinBinaryBetClientList storage clientList) internal returns (uint) {\\n        uint resultAmount;\\n        for (uint i = 0; i < clientList.length; ++i) {\\n            BinaryDTOs.JoinBinaryBetClient storage joinClient = extractJoinBinaryBetClientByRef(info, clientList.joinListRefs[i]);\\n            if (joinClient.side) {\\n                // left side\\n                if (bet.sideWon) {\\n                    resultAmount += applyCoefficient(joinClient.amount, info.leftAmount, info.rightAmount, true);\\n                }\\n            } else {\\n                // right side\\n                if (!bet.sideWon) {\\n                    resultAmount += applyCoefficient(joinClient.amount, info.leftAmount, info.rightAmount, false);\\n                }\\n            }\\n\\n            joinClient.amount = 0;\\n        }\\n\\n        return resultAmount;\\n    }\\n\\n    // Evaluate mainToken for giving prize\\n    // returns (mainToken amount)\\n    function evaluatePrize(BinaryDTOs.BinaryBet storage bet, BinaryDTOs.BinaryMatchingInfo storage info, BinaryDTOs.JoinBinaryBetClientList storage clientList) internal view returns (uint) {\\n        uint resultAmount;\\n        for (uint i = 0; i < clientList.length; ++i) {\\n            BinaryDTOs.JoinBinaryBetClient storage joinClient = extractJoinBinaryBetClientByRef(info, clientList.joinListRefs[i]);\\n            if (joinClient.side) {\\n                // left side\\n                if (bet.sideWon) {\\n                    resultAmount += applyCoefficient(joinClient.amount, info.leftAmount, info.rightAmount, true);\\n                }\\n            } else {\\n                // right side\\n                if (!bet.sideWon) {\\n                    resultAmount += applyCoefficient(joinClient.amount, info.leftAmount, info.rightAmount, false);\\n                }\\n            }\\n        }\\n\\n        return resultAmount;\\n    }\\n\\n\\n    // Evaluate mainToken and alternativeToken for refunding\\n    // returns (mainToken amount, alternativeToken amount)\\n    function cancelBinaryBet(BinaryDTOs.BinaryMatchingInfo storage info, BinaryDTOs.JoinBinaryBetClient storage joinClient) internal returns (uint) {\\n        uint amount = joinClient.amount;\\n        if (joinClient.side) {\\n            // left side\\n            info.leftAmount -= amount;\\n        } else {\\n            // right side\\n            info.rightAmount -= amount;\\n        }\\n\\n        joinClient.amount = 0;\\n\\n        return amount;\\n    }\\n\\n    function joinBinaryBet(BinaryDTOs.BinaryMatchingInfo storage info, BinaryDTOs.JoinBinaryBetClient memory joinBinaryRequestBet) internal returns (uint) {\\n        if (joinBinaryRequestBet.side) {\\n            // left side\\n            joinBinaryRequestBet.id = info.leftLength;\\n            info.leftSide[info.leftLength++] = joinBinaryRequestBet;\\n            info.leftAmount += joinBinaryRequestBet.amount;\\n            return info.leftLength - 1;\\n        } else {\\n            // right side\\n            joinBinaryRequestBet.id = info.rightLength;\\n            info.rightSide[info.rightLength++] = joinBinaryRequestBet;\\n            info.rightAmount += joinBinaryRequestBet.amount;\\n            return info.rightLength - 1;\\n        }\\n    }\\n\\n    function extractJoinBinaryBetClientByRef(BinaryDTOs.BinaryMatchingInfo storage info, BinaryDTOs.JoinBinaryBetClientRef storage ref) internal view returns (BinaryDTOs.JoinBinaryBetClient storage) {\\n        if (ref.side) {\\n            return info.leftSide[ref.id];\\n        } else {\\n            return info.rightSide[ref.id];\\n        }\\n    }\\n\\n    function applyCoefficient(uint amountToEvaluate, uint leftAmount, uint rightAmount, bool direct) private pure returns (uint) {\\n        uint totalAmount = leftAmount + rightAmount;\\n        if (direct) {\\n            return ((amountToEvaluate * totalAmount * 10 ** 18) / leftAmount) / 10 ** 18;\\n        } else {\\n            return ((amountToEvaluate * totalAmount * 10 ** 18) / rightAmount) / 10 ** 18;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/p2pbet/security/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"./SecurityDTOs.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    mapping(address => bool) public owners;\\n    address private _company;\\n    uint public totalOwners;\\n\\n    event CompanyTransferred(address indexed previousCompany, address indexed newCompany);\\n\\n    event AddOwner(address indexed newOwner);\\n    event RemoveOwner(address indexed ownerToRemove);\\n\\n    modifier onlyOwner() {\\n        require(owners[_msgSender()], \\\"Security: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function removeOwner(address ownerToRemove) internal {\\n        require(owners[ownerToRemove], \\\"Security: now owner\\\");\\n\\n        owners[ownerToRemove] = false;\\n        totalOwners--;\\n        emit RemoveOwner(ownerToRemove);\\n    }\\n\\n    function addOwner(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Security: new owner is the zero address\\\");\\n        require(!owners[newOwner], \\\"Security: already owner\\\");\\n\\n        owners[newOwner] = true;\\n        totalOwners++;\\n        emit AddOwner(newOwner);\\n    }\\n\\n\\n\\n    /**\\n     * @dev Returns the address of the current company.\\n     */\\n    function company() public view virtual returns (address) {\\n        return _company;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the company.\\n     */\\n    modifier onlyCompany() {\\n        require(company() == _msgSender(), \\\"Security: caller is not the company\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers company rights of the contract to a new account (`newCompany`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferCompany(address newCompany) internal {\\n        require(newCompany != address(0), \\\"Security: new company is the zero address\\\");\\n\\n        emit CompanyTransferred(_company, newCompany);\\n        _company = newCompany;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/p2pbet/processing/CompanyVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Security.sol\\\";\\nimport \\\"../utils/IERC20.sol\\\";\\n\\nabstract contract CompanyVault is Security {\\n    SecurityDTOs.ChangeAlterToken public changeAlterToken;\\n    IERC20 internal _IERC20token;\\n    IERC20 internal _AlternativeIERC20token;\\n    mapping(address => uint) private feeBalance;\\n    bool private _alternativeTokenEnabled;\\n    uint private _timestampExpirationDelay;\\n\\n    event ChangeAlterToken(address indexed newAlterToken);\\n    event ChangeTimestampDelay(uint timestampExpirationDelay);\\n\\n    constructor (address mainToken) {\\n        _IERC20token = IERC20(mainToken);\\n        _timestampExpirationDelay = 2 * 60 * 60;\\n    }\\n\\n    // Set expiration delay\\n    function setTimestampExpirationDelay(uint timestampExpirationDelay) external onlyOwner {\\n        _timestampExpirationDelay = timestampExpirationDelay;\\n        emit ChangeTimestampDelay(timestampExpirationDelay);\\n    }\\n\\n    // Change alter token start voting\\n    function changeAlternativeTokenStart(address alternativeToken) external onlyOwner {\\n        require(address(getMainIERC20Token()) != alternativeToken, \\\"CompanyVault: main token and alter token can't be the same\\\");\\n        uint votingCode = startVoting(\\\"CHANGE_ALTER_TOKEN\\\");\\n        changeAlterToken = SecurityDTOs.ChangeAlterToken(\\n            alternativeToken,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    // Acquire alter token start voting\\n    function acquireNewAlternativeToken() external onlyOwner {\\n        pass(changeAlterToken.votingCode);\\n        _AlternativeIERC20token = IERC20(changeAlterToken.newAlterToken);\\n        emit ChangeAlterToken(changeAlterToken.newAlterToken);\\n    }\\n\\n    // Get expiration delay to refund\\n    function getTimestampExpirationDelay() public view returns (uint) {\\n        return _timestampExpirationDelay;\\n    }\\n\\n    // Enable/disable alternative token usage\\n    function enableAlternativeToken(bool enable) external onlyOwner {\\n        _alternativeTokenEnabled = enable;\\n    }\\n\\n    // Status of alternative token\\n    function isAlternativeTokenEnabled() public view returns (bool) {\\n        return _alternativeTokenEnabled;\\n    }\\n\\n    // Get main IERC20 interface\\n    function getMainIERC20Token() public view returns (IERC20) {\\n        return _IERC20token;\\n    }\\n\\n    // Get alternative IERC20 interface\\n    function getAlternativeIERC20Token() public view returns (IERC20) {\\n        return _AlternativeIERC20token;\\n    }\\n\\n    // Get fee company balance\\n    function getCompanyFeeBalance(address token) public view returns (uint) {\\n        return feeBalance[token];\\n    }\\n\\n    // Increase main or alter token fee. Calls only from take prize.\\n    function increaseFee(uint amount, address token) internal {\\n        feeBalance[token] += amount;\\n    }\\n\\n    // Decrease main or alter token fee. Calls only from take fee.\\n    function decreaseFee(uint amount, address token) internal {\\n        feeBalance[token] -= amount;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/processing/AlternativeTokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Security.sol\\\";\\nimport \\\"../utils/IPancakeRouter01.sol\\\";\\n\\nabstract contract AlternativeTokenHelper is Security {\\n    SwapRouter public swapRouter;\\n\\n    event SetRouter(address indexed newSwapRouter);\\n\\n    function setRouter(address router) onlyOwner external {\\n        swapRouter = SwapRouter(router);\\n        emit SetRouter(router);\\n    }\\n\\n    function evaluateAlternativeAmount(uint mainAmount, address mainToken, address alternativeToken) internal view returns (uint) {\\n        address[] memory path = new address[](2);\\n        path[0] = mainToken;\\n        path[1] = alternativeToken;\\n        return swapRouter.getAmountsOut(mainAmount, path)[0];\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/processing/FeeConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Security.sol\\\";\\n\\nabstract contract FeeConfiguration is Security {\\n    //DECIMALS 6 for 100%\\n    uint private _companyFee;\\n    //DECIMALS 6 for 100%\\n    uint private _alternativeFee;\\n\\n    event CompanyFeeChanged(uint previousCompanyFee, uint newCompanyFee);\\n    event CompanyAlterFeeChanged(uint previousAlternativeFee, uint newAlternativeFee);\\n\\n    // Set company fee for all bets with main token fee\\n    function setCompanyFee(uint companyFee) external onlyOwner {\\n        require(companyFee <= 2 * 10 ** 5);\\n        emit CompanyFeeChanged(_companyFee, companyFee);\\n        _companyFee = companyFee;\\n    }\\n\\n    // Set company fee for all bets with alternative token fee\\n    function setAlternativeFeeFee(uint alternativeFee) external onlyOwner {\\n        require(alternativeFee <= 2 * 10 ** 5);\\n        emit CompanyAlterFeeChanged(_alternativeFee, alternativeFee);\\n        _alternativeFee = alternativeFee;\\n    }\\n\\n    // Get company fee(main token)\\n    function getCompanyFee() external view returns (uint) {\\n        return _companyFee;\\n    }\\n\\n    // Get alternative company fee(alternative token)\\n    function getAlternativeFee() external view returns (uint) {\\n        return _alternativeFee;\\n    }\\n\\n    // Apply company fee and return company fee part\\n    function applyCompanyFee(uint amount) internal view returns (uint) {\\n        return (amount * _companyFee) / 10 ** 6;\\n    }\\n\\n    // Apply alternative company fee and return alternative fee part\\n    function applyAlternativeFee(uint amount) internal view returns (uint) {\\n        return (amount * _alternativeFee) / 10 ** 6;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.2;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/security/SecurityDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nlibrary SecurityDTOs {\\n    struct ChangeAlterToken {\\n        address newAlterToken;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct AddOwner {\\n        address newOwner;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct RemoveOwner {\\n        address ownerToRemove;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct TransferCompany {\\n        address newCompanyAddress;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct TakeFee {\\n        uint amount;\\n        address targetAddress;\\n        bool isAlternative;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct VotingInfo {\\n        address initiator;\\n        uint currentNumberOfVotesPositive;\\n        uint currentNumberOfVotesNegative;\\n        uint startedDate;\\n        string votingCode;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/security/Security.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./Voting.sol\\\";\\n\\nabstract contract Security is Voting {\\n    SecurityDTOs.AddOwner public addOwnerVoting;\\n    SecurityDTOs.TransferCompany public transferCompanyVoting;\\n    SecurityDTOs.RemoveOwner public removeOwnerVoting;\\n    SecurityDTOs.TakeFee public takeFeeVoting;\\n\\n\\n    // Start voting for add owner\\n    function ownerAddStart(address newOwner) external onlyOwner {\\n        require(!owners[newOwner], \\\"Security: already owner\\\");\\n\\n        uint votingCode = startVoting(\\\"ADD_OWNER\\\");\\n        addOwnerVoting = SecurityDTOs.AddOwner(\\n            newOwner,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireNewOwner() external onlyOwner {\\n        pass(addOwnerVoting.votingCode);\\n        addOwner(addOwnerVoting.newOwner);\\n    }\\n\\n    function transferCompanyStart(address newCompany) public virtual onlyOwner {\\n        require(newCompany != address(0), \\\"Security: new company is the zero address\\\");\\n\\n        uint votingCode = startVoting(\\\"TRANSFER_COMPANY\\\");\\n        transferCompanyVoting = SecurityDTOs.TransferCompany(\\n            newCompany,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireTransferCompany() external onlyOwner {\\n        pass(transferCompanyVoting.votingCode);\\n        transferCompany(transferCompanyVoting.newCompanyAddress);\\n    }\\n\\n    // Start voting removing owner\\n    function ownerToRemoveStart(address ownerToRemove) external onlyOwner {\\n        require(owners[ownerToRemove], \\\"Security: is not owner\\\");\\n\\n        uint votingCode = startVoting(\\\"REMOVE_OWNER\\\");\\n        removeOwnerVoting = SecurityDTOs.RemoveOwner(\\n            ownerToRemove,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireOwnerToRemove() external onlyOwner {\\n        pass(removeOwnerVoting.votingCode);\\n        removeOwner(removeOwnerVoting.ownerToRemove);\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/utils/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/p2pbet/security/Voting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\nabstract contract Voting is Ownable {\\n    event VotingStarted(string code, uint votingNumber, address indexed initiator);\\n    event VotingResult(string code, uint votingNumber, bool passed);\\n\\n    bool public votingActive;\\n    SecurityDTOs.VotingInfo public votingInfo;\\n    uint private votingNumber;\\n    mapping(uint => mapping(address => bool)) public voted;\\n\\n\\n    function startVoting(string memory votingCode) internal returns (uint) {\\n        require(!votingActive, \\\"Voting: there is active voting already\\\");\\n        require(totalOwners >= 3, \\\"Voting: not enough owners for starting new vote\\\");\\n        votingInfo = SecurityDTOs.VotingInfo(\\n            _msgSender(),\\n            0,\\n            0,\\n            block.timestamp,\\n            votingCode\\n        );\\n        votingActive = true;\\n        votingNumber++;\\n\\n        votePositive();\\n        emit VotingStarted(\\n            votingCode,\\n            votingNumber,\\n            _msgSender()\\n        );\\n\\n        return votingNumber;\\n    }\\n\\n    // End voting with success\\n    function pass(uint toCheckVotingNumber) internal {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(toCheckVotingNumber == votingNumber, \\\"Voting: old voting found\\\");\\n        require(votingInfo.currentNumberOfVotesPositive > totalOwners / 2, \\\"Voting: not enough positive votes\\\");\\n        require(votingInfo.startedDate + 60 * 60 * 72 < block.timestamp || votingInfo.currentNumberOfVotesPositive == totalOwners, \\\"Voting: 72 hours have not yet passed\\\");\\n\\n        votingActive = false;\\n        emit VotingResult(\\n            votingInfo.votingCode,\\n            votingNumber,\\n            true\\n        );\\n    }\\n\\n\\n    // Close voting\\n    function close() external onlyOwner {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(votingInfo.startedDate + 144 * 60 * 60 < block.timestamp || votingInfo.currentNumberOfVotesNegative > totalOwners / 2, \\\"Voting: condition close error\\\");\\n        votingActive = false;\\n        emit VotingResult(\\n            votingInfo.votingCode,\\n            votingNumber,\\n            false\\n        );\\n    }\\n\\n    function votePositive() public onlyOwner {\\n        vote();\\n        votingInfo.currentNumberOfVotesPositive++;\\n    }\\n\\n    function voteNegative() external onlyOwner {\\n        vote();\\n        votingInfo.currentNumberOfVotesNegative++;\\n    }\\n\\n    function vote() private {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(!voted[votingNumber][_msgSender()], \\\"Voting: already voted\\\");\\n        voted[votingNumber][_msgSender()] = true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/utils/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\ninterface SwapRouter {\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mainToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"joinIdRef\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mainTokenRefunded\",\"type\":\"uint256\"}],\"name\":\"BinaryBetCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lockedValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sideWon\",\"type\":\"bool\"}],\"name\":\"BinaryBetClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"BinaryBetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mainAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"joinId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"joinRefId\",\"type\":\"uint256\"}],\"name\":\"BinaryBetJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mainTokenRefunded\",\"type\":\"uint256\"}],\"name\":\"BinaryBetRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useAlterFee\",\"type\":\"bool\"}],\"name\":\"BinaryPrizeTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAlterToken\",\"type\":\"address\"}],\"name\":\"ChangeAlterToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestampExpirationDelay\",\"type\":\"uint256\"}],\"name\":\"ChangeTimestampDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAlternativeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAlternativeFee\",\"type\":\"uint256\"}],\"name\":\"CompanyAlterFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousCompanyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCompanyFee\",\"type\":\"uint256\"}],\"name\":\"CompanyFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousCompany\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCompany\",\"type\":\"address\"}],\"name\":\"CompanyTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAlternative\",\"type\":\"bool\"}],\"name\":\"FeeTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"}],\"name\":\"RemoveOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSwapRouter\",\"type\":\"address\"}],\"name\":\"SetRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passed\",\"type\":\"bool\"}],\"name\":\"VotingResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"VotingStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acquireNewAlternativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireOwnerToRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireTakeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireTransferCompany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addOwnerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"binaryBetIdCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joinIdRef\",\"type\":\"uint256\"}],\"name\":\"cancelBinaryJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeAlterToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAlterToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alternativeToken\",\"type\":\"address\"}],\"name\":\"changeAlternativeTokenStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clientBetsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lockedValue\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"sideWon\",\"type\":\"bool\"}],\"name\":\"closeBinaryBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"company\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"internalType\":\"struct BinaryDTOs.CreateBinaryRequest\",\"name\":\"createRequest\",\"type\":\"tuple\"}],\"name\":\"createBinaryBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableAlternativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlternativeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlternativeIERC20Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getBinaryBet\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lockedValue\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"sideWon\",\"type\":\"bool\"}],\"internalType\":\"struct BinaryDTOs.BinaryBet\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getBinaryClientJoins\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"joinRefId\",\"type\":\"uint256\"}],\"internalType\":\"struct BinaryDTOs.JoinBinaryBetClient[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"getBinaryWonAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getClientBets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCompanyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getCompanyFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMainIERC20Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimestampExpirationDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAlternativeTokenEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BinaryDTOs.JoinBinaryRequest\",\"name\":\"joinRequest\",\"type\":\"tuple\"}],\"name\":\"joinBinaryBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerAddStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"}],\"name\":\"ownerToRemoveStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"refundBinaryBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeOwnerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"alternativeFee\",\"type\":\"uint256\"}],\"name\":\"setAlternativeFeeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setCancelEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"companyFee\",\"type\":\"uint256\"}],\"name\":\"setCompanyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestampExpirationDelay\",\"type\":\"uint256\"}],\"name\":\"setTimestampExpirationDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract SwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useAlterFee\",\"type\":\"bool\"}],\"name\":\"takeBinaryPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAlternative\",\"type\":\"bool\"}],\"name\":\"takeFeeStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeFeeVoting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAlternative\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCompany\",\"type\":\"address\"}],\"name\":\"transferCompanyStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferCompanyVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newCompanyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteNegative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votePositive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNumberOfVotesPositive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentNumberOfVotesNegative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedDate\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"votingCode\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "P2PBinaryBetProvider", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000800000000000000000000000056279d7d92d11381a1b6fb84678b69640c324551000000000000000000000000ff0c626d969cc8359ff213057d467f607dd3882f000000000000000000000000829ae661c7c5dc3fc38eea1035edc85c288d0b90000000000000000000000000e1a8f12fc65c9c9dd1071d6a120ecb44ecfb153c0000000000000000000000005f7d70ff357920efc801b8f54b81f9bbe78e13e0000000000000000000000000726d39f0f9ef36c3dcbc71cc39ff1d3981fe0f950000000000000000000000000853ac2e9a241e5876ef89b47c2639405403b1110000000000000000000000009f9e88112da06c7a42513298a5415cc208b36b99", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}