{"SourceCode": "// SPDX-License-Identifier: NONE\n\npragma solidity 0.8.6;\n\n\n\n// Part: IForwarder\n\ninterface IForwarder {\n\n    function forward(\n        address target,\n        bytes calldata callData\n    ) external payable returns (bool success, bytes memory returnData);\n\n}\n\n// Part: IPriceOracle\n\ninterface IPriceOracle {\n\n    function getAUTOPerETH() external view returns (uint);\n\n    function getGasPriceFast() external view returns (uint);\n}\n\n// Part: IRegistry\n\n/**\n* @title    Registry\n* @notice   A contract which is essentially a glorified forwarder.\n*           It essentially brings together people who want things executed,\n*           and people who want to do that execution in return for a fee.\n*           Users register the details of what they want executed, which\n*           should always revert unless their execution condition is true,\n*           and executors execute the request when the condition is true.\n*           Only a specific executor is allowed to execute requests at any\n*           given time, as determined by the StakeManager, which requires\n*           staking AUTO tokens. This is infrastructure, and an integral\n*           piece of the future of web3. It also provides the spark of life\n*           for a new form of organism - cyber life. We are the gods now.\n* @author   Quantaf1re (James Key)\n*/\ninterface IRegistry {\n    \n    // The address vars are 20b, total 60, calldata is 4b + n*32b usually, which\n    // has a factor of 32. uint112 since the current ETH supply of ~115m can fit\n    // into that and it's the highest such that 2 * uint112 + 3 * bool is < 256b\n    struct Request {\n        address payable user;\n        address target;\n        address payable referer;\n        bytes callData;\n        uint112 initEthSent;\n        uint112 ethForCall;\n        bool verifyUser;\n        bool insertFeeAmount;\n        bool payWithAUTO;\n        bool isAlive;\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                      Hashed Requests                     //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    /**\n     * @notice  Creates a new request, logs the request info in an event, then saves\n     *          a hash of it on-chain in `_hashedReqs`. Uses the default for whether\n     *          to pay in ETH or AUTO\n     * @param target    The contract address that needs to be called\n     * @param referer       The referer to get rewarded for referring the sender\n     *                      to using Autonomy. Usally the address of a dapp owner\n     * @param callData  The calldata of the call that the request is to make, i.e.\n     *                  the fcn identifier + inputs, encoded\n     * @param ethForCall    The ETH to send with the call\n     * @param verifyUser  Whether the 1st input of the calldata equals the sender.\n     *                      Needed for dapps to know who the sender is whilst\n     *                      ensuring that the sender intended\n     *                      that fcn and contract to be called - dapps will\n     *                      require that msg.sender is the Verified Forwarder,\n     *                      and only requests that have `verifyUser` = true will\n     *                      be forwarded via the Verified Forwarder, so any calls\n     *                      coming from it are guaranteed to have the 1st argument\n     *                      be the sender\n     * @param insertFeeAmount     Whether the gas estimate of the executor should be inserted\n     *                      into the callData\n     * @param isAlive       Whether or not the request should be deleted after it's executed\n     *                      for the first time. If `true`, the request will exist permanently\n     *                      (tho it can be cancelled any time), therefore executing the same\n     *                      request repeatedly aslong as the request is executable,\n     *                      and can be used to create fully autonomous contracts - the\n     *                      first single-celled cyber life. We are the gods now\n     * @return id   The id of the request, equal to the index in `_hashedReqs`\n     */\n    function newReq(\n        address target,\n        address payable referer,\n        bytes calldata callData,\n        uint112 ethForCall,\n        bool verifyUser,\n        bool insertFeeAmount,\n        bool isAlive\n    ) external payable returns (uint id);\n\n    /**\n     * @notice  Creates a new request, logs the request info in an event, then saves\n     *          a hash of it on-chain in `_hashedReqs`\n     * @param target    The contract address that needs to be called\n     * @param referer       The referer to get rewarded for referring the sender\n     *                      to using Autonomy. Usally the address of a dapp owner\n     * @param callData  The calldata of the call that the request is to make, i.e.\n     *                  the fcn identifier + inputs, encoded\n     * @param ethForCall    The ETH to send with the call\n     * @param verifyUser  Whether the 1st input of the calldata equals the sender.\n     *                      Needed for dapps to know who the sender is whilst\n     *                      ensuring that the sender intended\n     *                      that fcn and contract to be called - dapps will\n     *                      require that msg.sender is the Verified Forwarder,\n     *                      and only requests that have `verifyUser` = true will\n     *                      be forwarded via the Verified Forwarder, so any calls\n     *                      coming from it are guaranteed to have the 1st argument\n     *                      be the sender\n     * @param insertFeeAmount     Whether the gas estimate of the executor should be inserted\n     *                      into the callData\n     * @param payWithAUTO   Whether the sender wants to pay for the request in AUTO\n     *                      or ETH. Paying in AUTO reduces the fee\n     * @param isAlive       Whether or not the request should be deleted after it's executed\n     *                      for the first time. If `true`, the request will exist permanently\n     *                      (tho it can be cancelled any time), therefore executing the same\n     *                      request repeatedly aslong as the request is executable,\n     *                      and can be used to create fully autonomous contracts - the\n     *                      first single-celled cyber life. We are the gods now\n     * @return id   The id of the request, equal to the index in `_hashedReqs`\n     */\n    function newReqPaySpecific(\n        address target,\n        address payable referer,\n        bytes calldata callData,\n        uint112 ethForCall,\n        bool verifyUser,\n        bool insertFeeAmount,\n        bool payWithAUTO,\n        bool isAlive\n    ) external payable returns (uint id);\n\n    /**\n     * @notice  Gets all keccak256 hashes of encoded requests. Completed requests will be 0x00\n     * @return  [bytes32[]] An array of all hashes\n     */\n    function getHashedReqs() external view returns (bytes32[] memory);\n\n    /**\n     * @notice  Gets part of the keccak256 hashes of encoded requests. Completed requests will be 0x00.\n     *          Needed since the array will quickly grow to cost more gas than the block limit to retrieve.\n     *          so it can be viewed in chunks. E.g. for an array of x = [4, 5, 6, 7], x[1, 2] returns [5],\n     *          the same as lists in Python\n     * @param startIdx  [uint] The starting index from which to start getting the slice (inclusive)\n     * @param endIdx    [uint] The ending index from which to start getting the slice (exclusive)\n     * @return  [bytes32[]] An array of all hashes\n     */\n    function getHashedReqsSlice(uint startIdx, uint endIdx) external view returns (bytes32[] memory);\n\n    /**\n     * @notice  Gets the total number of requests that have been made, hashed, and stored\n     * @return  [uint] The total number of hashed requests\n     */\n    function getHashedReqsLen() external view returns (uint);\n    \n    /**\n     * @notice      Gets a single hashed request\n     * @param id    [uint] The id of the request, which is its index in the array\n     * @return      [bytes32] The sha3 hash of the request\n     */\n    function getHashedReq(uint id) external view returns (bytes32);\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                Hashed Requests Unverified                //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    /**\n     * @notice  Creates a new hashed request by blindly storing a raw hash on-chain. It's \n     *          'unverified' because when executing it, it's impossible to tell whether any\n     *          ETH was initially sent with the request etc, so executing this request requires\n     *          that the request which hashes to `hashedIpfsReq` has `ethForCall` = 0,\n     *          `initEthSend` = 0, `verifyUser` = false, and `payWithAUTO` = true\n     * @param id    [bytes32] The hash to save. The hashing algo isn't keccak256 like with `newReq`,\n     *          it instead uses sha256 so that it's compatible with ipfs - the hash stored on-chain\n     *          should be able to be used in ipfs to point to the request which hashes to `hashedIpfsReq`.\n     *          Because ipfs doesn't hash only the data stored, it hashes a prepends a few bytes to the\n     *          encoded data and appends a few bytes to the data, the hash has to be over [prefix + data + postfix]\n     * @return id   The id of the request, equal to the index in `_hashedReqsUnveri`\n     */\n    function newHashedReqUnveri(bytes32 hashedIpfsReq) external returns (uint id);\n\n    /**\n     * @notice  Gets part of the sha256 hashes of ipfs-encoded requests. Completed requests will be 0x00.\n     *          Needed since the array will quickly grow to cost more gas than the block limit to retrieve.\n     *          so it can be viewed in chunks. E.g. for an array of x = [4, 5, 6, 7], x[1, 2] returns [5],\n     *          the same as lists in Python\n     * @param startIdx  [uint] The starting index from which to start getting the slice (inclusive)\n     * @param endIdx    [uint] The ending index from which to start getting the slice (exclusive)\n     * @return  [bytes32[]] An array of all hashes\n     */\n    function getHashedReqsUnveriSlice(uint startIdx, uint endIdx) external view returns (bytes32[] memory);\n    \n    /**\n     * @notice  Gets all sha256 hashes of ipfs-encoded requests. Completed requests will be 0x00\n     * @return  [bytes32[]] An array of all hashes\n     */\n    function getHashedReqsUnveri() external view returns (bytes32[] memory);\n\n    /**\n     * @notice  Gets the total number of unverified requests that have been stored\n     * @return  [uint] The total number of hashed unverified requests\n     */\n    function getHashedReqsUnveriLen() external view returns (uint);\n    \n    /**\n     * @notice      Gets a single hashed unverified request\n     * @param id    [uint] The id of the request, which is its index in the array\n     * @return      [bytes32] The sha256 hash of the ipfs-encoded request\n     */\n    function getHashedReqUnveri(uint id) external view returns (bytes32);\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                        Bytes Helpers                     //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    /**\n     * @notice      Encode a request into bytes\n     * @param r     [request] The request to be encoded\n     * @return      [bytes] The bytes array of the encoded request\n     */\n    function getReqBytes(Request memory r) external pure returns (bytes memory);\n\n    /**\n     * @notice      Encode a request into bytes the same way ipfs does - by doing hash(prefix | request | postfix)\n     * @param r     [request] The request to be encoded\n     * @param dataPrefix    [bytes] The prefix that ipfs prepends to this data before hashing\n     * @param dataPostfix   [bytes] The postfix that ipfs appends to this data before hashing\n     * @return  [bytes] The bytes array of the encoded request\n     */\n    function getIpfsReqBytes(\n        bytes memory r,\n        bytes memory dataPrefix,\n        bytes memory dataPostfix\n    ) external pure returns (bytes memory);\n\n    /**\n     * @notice      Get the hash of an encoded request, encoding into bytes the same way ipfs\n     *              does - by doing hash(prefix | request | postfix)\n     * @param r     [request] The request to be encoded\n     * @param dataPrefix    [bytes] The prefix that ipfs prepends to this data before hashing\n     * @param dataPostfix   [bytes] The postfix that ipfs appends to this data before hashing\n     * @return  [bytes32] The sha256 hash of the ipfs-encoded request\n     */\n    function getHashedIpfsReq(\n        bytes memory r,\n        bytes memory dataPrefix,\n        bytes memory dataPostfix\n    ) external pure returns (bytes32);\n\n    /**\n     * @notice      Get the decoded request back from encoded bytes\n     * @param rBytes    [bytes] The encoded bytes version of a request\n     * @return r    [Request] The request as a struct\n     */\n    function getReqFromBytes(bytes memory rBytes) external pure returns (Request memory r);\n\n    function insertToCallData(bytes calldata callData, uint expectedGas, uint startIdx) external pure returns (bytes memory);\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                         Executions                       //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    /**\n     * @notice      Execute a hashedReq. Calls the `target` with `callData`, then\n     *              charges the user the fee, and gives it to the executor\n     * @param id    [uint] The index of the request in `_hashedReqs`\n     * @param r     [request] The full request struct that fully describes the request.\n     *              Typically known by seeing the `HashedReqAdded` event emitted with `newReq`\n     * @param expectedGas   [uint] The gas that the executor expects the execution to cost,\n     *                      known by simulating the the execution of this tx locally off-chain.\n     *                      This can be forwarded as part of the requested call such that the\n     *                      receiving contract knows how much gas the whole execution cost and\n     *                      can do something to compensate the exact amount (e.g. as part of a trade).\n     *                      Cannot be more than 10% above the measured gas cost by the end of execution\n     * @return gasUsed      [uint] The gas that was used as part of the execution. Used to know `expectedGas`\n     */\n    function executeHashedReq(\n        uint id,\n        Request calldata r,\n        uint expectedGas\n    ) external returns (uint gasUsed);\n\n    /**\n     * @notice      Execute a hashedReqUnveri. Hashes `r`, `dataPrefix`, and `dataSuffix`\n     *              together in the same way that ipfs does such that the hash stored on-chain\n     *              is the same as the hash used to look up on ipfs to see the raw request.\n     *              Since `newHashedReqUnveri` does no verification at all since it can't,\n     *              `executeHashedReqUnveri` has to instead. There are some things it can't\n     *              know, like the amount of ETH sent in the original request call, so they're\n     *              forced to be zero\n     * @param id    [uint] The index of the request in `_hashedReqs`\n     * @param r     [request] The full request struct that fully describes the request. Typically\n     *              known by looking up the hash on ipfs\n     * @param dataPrefix    [bytes] The data prepended to the bytes form of `r` before being hashed\n     *                      in ipfs\n     * @param dataSuffix    [bytes] The data appended to the bytes form of `r` before being hashed\n     *                      in ipfs\n     * @param expectedGas   [uint] The gas that the executor expects the execution to cost,\n     *                      known by simulating the the execution of this tx locally off-chain.\n     *                      This can be forwarded as part of the requested call such that the\n     *                      receiving contract knows how much gas the whole execution cost and\n     *                      can do something to compensate the exact amount (e.g. as part of a trade).\n     *                      Cannot be more than 10% above the measured gas cost by the end of execution\n     * @return gasUsed      [uint] The gas that was used as part of the execution. Used to know `expectedGas`\n     */\n    function executeHashedReqUnveri(\n        uint id,\n        Request calldata r,\n        bytes memory dataPrefix,\n        bytes memory dataSuffix,\n        uint expectedGas\n    ) external returns (uint gasUsed);\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                        Cancellations                     //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n    \n    /**\n     * @notice      Execute a hashedReq. Calls the `target` with `callData`, then\n     *              charges the user the fee, and gives it to the executor\n     * @param id    [uint] The index of the request in `_hashedReqs`\n     * @param r     [request] The full request struct that fully describes the request.\n     *              Typically known by seeing the `HashedReqAdded` event emitted with `newReq`\n     */\n    function cancelHashedReq(\n        uint id,\n        Request memory r\n    ) external;\n    \n    /**\n     * @notice      Execute a hashedReq. Calls the `target` with `callData`, then\n     *              charges the user the fee, and gives it to the executor\n     * @param id    [uint] The index of the request in `_hashedReqs`\n     * @param r     [request] The full request struct that fully describes the request. Typically\n     *              known by looking up the hash on ipfs\n     * @param dataPrefix    [bytes] The data prepended to the bytes form of `r` before being hashed\n     *                      in ipfs\n     * @param dataSuffix    [bytes] The data appended to the bytes form of `r` before being hashed\n     *                      in ipfs\n     */\n    function cancelHashedReqUnveri(\n        uint id,\n        Request memory r,\n        bytes memory dataPrefix,\n        bytes memory dataSuffix\n    ) external;\n    \n    \n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                          Getters                         //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n    \n    function getAUTOAddr() external view returns (address);\n    \n    function getStakeManager() external view returns (address);\n\n    function getOracle() external view returns (address);\n    \n    function getUserForwarder() external view returns (address);\n    \n    function getGasForwarder() external view returns (address);\n    \n    function getUserGasForwarder() external view returns (address);\n    \n    function getReqCountOf(address addr) external view returns (uint);\n    \n    function getExecCountOf(address addr) external view returns (uint);\n    \n    function getReferalCountOf(address addr) external view returns (uint);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/Address\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/Context\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/IERC1820Registry\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/IERC20\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/IERC777\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/IERC777Recipient\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/IERC777Sender\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/ReentrancyGuard\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// Part: Shared\n\n/**\n* @title    Shared contract\n* @notice   Holds constants and modifiers that are used in multiple contracts\n* @dev      It would be nice if this could be a library, but modifiers can't be exported :(\n* @author   Quantaf1re (James Key)\n*/\nabstract contract Shared {\n    address constant internal _ADDR_0 = address(0);\n    bytes32 constant internal _NULL = \"\";\n    uint constant internal _E_18 = 10**18;\n\n\n    /// @dev    Checks that a uint isn't nonzero/empty\n    modifier nzUint(uint u) {\n        require(u != 0, \"Shared: uint input is empty\");\n        _;\n    }\n\n    /// @dev    Checks that an address isn't nonzero/empty\n    modifier nzAddr(address a) {\n        require(a != _ADDR_0, \"Shared: address input is empty\");\n        _;\n    }\n\n    /// @dev    Checks that a bytes array isn't nonzero/empty\n    modifier nzBytes(bytes calldata b) {\n        require(b.length > 1, \"Shared: bytes input is empty\");\n        _;\n    }\n\n    /// @dev    Checks that a bytes array isn't nonzero/empty\n    modifier nzBytes32(bytes32 b) {\n        require(b != _NULL, \"Shared: bytes32 input is empty\");\n        _;\n    }\n\n    /// @dev    Checks that a uint array isn't nonzero/empty\n    modifier nzUintArr(uint[] calldata arr) {\n        require(arr.length > 0, \"Shared: uint arr input is empty\");\n        _;\n    }\n}\n\n// Part: IOracle\n\ninterface IOracle {\n    // Needs to output the same number for the whole epoch\n    function getRandNum(uint salt) external view returns (uint);\n\n    function getPriceOracle() external view returns (IPriceOracle);\n\n    function getAUTOPerETH() external view returns (uint);\n\n    function getGasPriceFast() external view returns (uint);\n\n    function setPriceOracle(IPriceOracle newPriceOracle) external;\n\n    function defaultPayIsAUTO() external view returns (bool);\n\n    function setDefaultPayIsAUTO(bool newDefaultPayIsAUTO) external;\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/ERC777\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using Address for address;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\n            _defaultOperators[defaultOperators_[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\n        return\n            operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view virtual override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators cannot\n     * call `transferFrom` (unless they have allowance), and accounts with\n     * allowance cannot call `operatorSend` (unless they are operators).\n     *\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n\n        uint256 currentAllowance = _allowances[holder][spender];\n        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");\n        _approve(holder, spender, currentAllowance - amount);\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal virtual {\n        _mint(account, amount, userData, operatorData, true);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If `requireReceptionAck` is set to true, and if a send hook is\n     * registered for `account`, the corresponding function will be called with\n     * `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal virtual {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 value\n    ) internal {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.1/Ownable\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// Part: AUTO\n\n/**\n* @title    AUTO contract\n* @notice   The AUTO utility token which is used to stake in Autonomy and pay for\n*           execution fees with\n* @author   Quantaf1re (James Key)\n*/\ncontract AUTO is ERC777, Ownable {\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address[] memory defaultOperators,\n        address receiver,\n        uint256 mintAmount\n    ) ERC777(name, symbol, defaultOperators) Ownable() {\n        _mint(receiver, mintAmount, \"\", \"\");\n    }\n\n    function mint(\n        address receiver,\n        uint amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) external onlyOwner {\n        _mint(receiver, amount, userData, operatorData);\n    }\n}\n\n// Part: IStakeManager\n\n/**\n* @title    StakeManager\n* @notice   A lightweight Proof of Stake contract that allows\n*           staking of AUTO tokens. Instead of a miner winning\n*           the ability to produce a block, the algorithm selects\n*           a staker for a period of 100 blocks to be the executor.\n*           the executor has the exclusive right to execute requests\n*           in the Registry contract. The Registry checks with StakeManager\n*           who is allowed to execute requests at any given time\n* @author   Quantaf1re (James Key)\n*/\ninterface IStakeManager {\n\n    struct Executor{\n        address addr;\n        uint96 forEpoch;\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                          Getters                         //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n    \n    function getOracle() external view returns (IOracle);\n\n    function getAUTOAddr() external view returns (address);\n\n    function getTotalStaked() external view returns (uint);\n\n    function getStake(address staker) external view returns (uint);\n\n    /**\n     * @notice  Returns the array of stakes. Every element in the array represents\n     *          `STAN_STAKE` amount of AUTO tokens staked for that address. Addresses\n     *          can be in the array arbitrarily many times\n     */\n    function getStakes() external view returns (address[] memory);\n\n    /**\n     * @notice  The length of `_stakes`, i.e. the total staked when multiplied by `STAN_STAKE`\n     */\n    function getStakesLength() external view returns (uint);\n\n    /**\n     * @notice  The same as getStakes except it returns only part of the array - the\n     *          array might grow so large that retrieving it costs more gas than the\n     *          block gas limit and therefore brick the contract. E.g. for an array of\n     *          x = [4, 5, 6, 7], x[1, 2] returns [5], the same as lists in Python\n     * @param startIdx  [uint] The starting index from which to start getting the slice (inclusive)\n     * @param endIdx    [uint] The ending index from which to start getting the slice (exclusive)\n     */\n    function getStakesSlice(uint startIdx, uint endIdx) external view returns (address[] memory);\n\n    /**\n     * @notice  Returns the current epoch. Goes in increments of 100. E.g. the epoch\n     *          for 420 is 400, and 42069 is 42000\n     */\n    function getCurEpoch() external view returns (uint96);\n\n    /**\n     * @notice  Returns the currently stored Executor - which might be old,\n     *          i.e. for a previous epoch\n     */\n    function getExecutor() external view returns (Executor memory);\n\n    /**\n     * @notice  Returns whether `addr` is the current executor for this epoch. If the executor\n     *          is outdated (i.e. for a previous epoch), it'll return false regardless of `addr`\n     * @param addr  [address] The address to check\n     * @return  [bool] Whether or not `addr` is the current executor for this epoch\n     */\n    function isCurExec(address addr) external view returns (bool);\n\n    /**\n     * @notice  Returns what the result of updating the executor would be, but doesn't actually\n     *          make any changes\n     * @return epoch    Returns the relevant variables for determining the new executor if the executor\n     *          can be updated currently. It can only be updated currently if the stored executor\n     *          is for a previous epoch, and there is some stake in the system. If the executor\n     *          can't be updated currently, then everything execpt `epoch` will return 0\n     */\n    function getUpdatedExecRes() external view returns (uint96 epoch, uint randNum, uint idxOfExecutor, address exec);\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                          Staking                         //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    /**\n     * @notice  Updates the executor. Calls `getUpdatedExecRes` to know. Makes the changes\n     *          only if the executor can be updated\n     * @return  Returns the relevant variables for determining the new executor if the executor\n     *          can be updated currently\n     */\n    function updateExecutor() external returns (uint, uint, uint, address);\n\n    /**\n     * @notice  Checks if the stored executor is for the current epoch - if it is,\n     *          then it returns whether `addr` is the current exec or not. If the epoch\n     *          is old, then it updates the executor, then returns whether `addr` is the\n     *          current executor or not. If there's no stake in the system, returns true\n     * @param addr  [address] The address to check\n     * @return  [bool] Returns whether or not `addr` is the current, updated executor\n     */\n    function isUpdatedExec(address addr) external returns (bool);\n\n    /**\n     * @notice  Stake a set amount of AUTO tokens. A set amount of tokens needs to be used\n     *          so that a random number can be used to look up a specific index in the array.\n     *          We want the staker to be chosen proportional to their stake, which requires\n     *          knowing their stake in relation to everyone else. If you could stake any\n     *          amount of AUTO tokens, then the contract would have to store that amount\n     *          along with the staker and, crucially, would require iteration over the\n     *          whole array. E.g. if the random number in this PoS system was 0.2, then\n     *          you could calculate the amount of proportional stake that translates to.\n     *          If the total stakes was 10^6, then whichever staker in the array at token\n     *          position 200,000 would be the winner, but that requires going through every\n     *          piece of staking info in the first part of the array in order to calculate\n     *          the running cumulative and know who happens to have the slot where the\n     *          cumulative stake is 200,000. This has problems when the staking array is\n     *          so large that it costs more than the block gas limit to iterate over, which\n     *          would brick the contract, but also just generally costs alot of gas. Having\n     *          a set amount of AUTO tokens means you already know everything about every\n     *          element in the array therefore don't need to iterate over it.\n     *          Calling this will add the caller to the array. Calling this will first try\n     *          and set the executor so that the caller can't precalculate and affect the outcome\n     *          by deciding the size of `numStakes`\n     * @param numStakes  [uint] The number of `STAN_STAKE` to stake and therefore how many\n     *          slots in the array to add the user to\n     */\n    function stake(uint numStakes) external;\n\n    /**\n     * @notice  Unstake AUTO tokens. Calling this will first try and set the executor so that\n     *          the caller can't precalculate and affect the outcome by deciding the size of\n     *          `numStakes`\n     * @dev     Instead of just deleting the array slot, this takes the last element, copies\n     *          it to the slot being unstaked, and pops off the original copy of the replacement\n     *          from the end of the array, so that there are no gaps left, such that 0x00...00\n     *          can never be chosen as an executor\n     * @param idxs  [uint[]] The indices of the user's slots, in order of which they'll be\n     *              removed, which is not necessariy the current indices. E.g. if the `_staking`\n     *              array is [a, b, c, b], and `idxs` = [1, 3], then i=1 will first get\n     *              replaced by i=3 and look like [a, b, c], then it would try and replace i=3\n     *              by the end of the array...but i=3 no longer exists, so it'll revert. In this\n     *              case, `idxs` would need to be [1, 1], which would result in [a, c]. It's\n     *              recommended to choose idxs in descending order so that you don't have to\n     *              take account of this behaviour - that way you can just use indexes\n     *              as they are already without alterations\n     */\n    function unstake(uint[] calldata idxs) external;\n}\n\n// File: Registry.sol\n\ncontract Registry is IRegistry, Shared, ReentrancyGuard {\n    \n    // Constant public\n    uint public constant GAS_OVERHEAD_AUTO = 16000;\n    uint public constant GAS_OVERHEAD_ETH = 6000;\n    uint public constant BASE_BPS = 10000;\n    uint public constant PAY_AUTO_BPS = 11000;\n    uint public constant PAY_ETH_BPS = 13000;\n\n    // Constant private\n    bytes private constant _EMPTY_BYTES = \"\";\n    \n    AUTO private immutable _AUTO;\n    IStakeManager private immutable _stakeMan;\n    IOracle private immutable _oracle;\n    IForwarder private immutable _userForwarder;\n    IForwarder private immutable _gasForwarder;\n    IForwarder private immutable _userGasForwarder;\n\n    // Used to make sure that `target` can't be something that affects\n    // the Autonomy system itself\n    mapping(address => bool) private _invalidTargets;\n    // This counts the number of times each user has had a request executed\n    mapping(address => uint) private _reqCounts;\n    // This counts the number of times each staker has executed a request\n    mapping(address => uint) private _execCounts;\n    // This counts the number of times each referer has been identified in an\n    // executed tx\n    mapping(address => uint) private _referalCounts;\n    // We need to have 2 separate arrays for adding requests with and without\n    // eth because, when comparing the hash of a request to be executed to the\n    // stored hash, we have no idea what the request had for the eth values\n    // that was originally stored as a hash and therefore would need to store\n    // an extra bool saying where eth was sent with the new request. Instead, \n    // that can be known implicitly by having 2 separate arrays.\n    bytes32[] private _hashedReqs;\n    bytes32[] private _hashedReqsUnveri;\n    \n    \n    // This is defined in IRegistry. Here for convenience\n    // The address vars are 20b, total 60, calldata is 4b + n*32b usually, which\n    // has a factor of 32. uint112 since the current ETH supply of ~115m can fit\n    // into that and it's the highest such that 2 * uint112 + 2 * bool is < 256b\n    // struct Request {\n    //     address payable user;\n    //     address target;\n    //     address payable referer;\n    //     bytes callData;\n    //     uint112 initEthSent;\n    //     uint112 ethForCall;\n    //     bool verifyUser;\n    //     bool insertFeeAmount;\n    //     bool payWithAUTO;\n    //     bool isAlive;\n    // }\n\n    // Easier to parse when using native types rather than structs\n    event HashedReqAdded(\n        uint indexed id,\n        address indexed user,\n        address target,\n        address payable referer,\n        bytes callData,\n        uint112 initEthSent,\n        uint112 ethForCall,\n        bool verifyUser,\n        bool insertFeeAmount,\n        bool payWithAUTO,\n        bool isAlive\n    );\n    event HashedReqUnveriAdded(uint indexed id);\n    event HashedReqExecuted(uint indexed id, bool wasRemoved);\n    event HashedReqUnveriExecuted(uint indexed id, bool wasRemoved);\n    event HashedReqCancelled(uint indexed id);\n    event HashedReqUnveriCancelled(uint indexed id);\n\n\n    constructor(\n        IStakeManager stakeMan,\n        IOracle oracle,\n        IForwarder userForwarder,\n        IForwarder gasForwarder,\n        IForwarder userGasForwarder,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint totalAUTOSupply\n    ) ReentrancyGuard() {\n        // ERC777 token\n        address[] memory defaultOperators = new address[](2);\n        defaultOperators[0] = address(this);\n        defaultOperators[1] = address(stakeMan);\n        AUTO aut = new AUTO(tokenName, tokenSymbol, defaultOperators, msg.sender, totalAUTOSupply);\n\n        _AUTO = aut;\n        _stakeMan = stakeMan;\n        _oracle = oracle;\n        _userForwarder = userForwarder;\n        _gasForwarder = gasForwarder;\n        _userGasForwarder = userGasForwarder;\n        _invalidTargets[address(this)] = true;\n        _invalidTargets[address(userForwarder)] = true;\n        _invalidTargets[address(gasForwarder)] = true;\n        _invalidTargets[address(userGasForwarder)] = true;\n        _invalidTargets[address(aut)] = true;\n        _invalidTargets[0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24] = true;\n        _invalidTargets[address(stakeMan)] = true;\n        _invalidTargets[_ADDR_0] = true;\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                      Hashed Requests                     //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    function newReq(\n        address target,\n        address payable referer,\n        bytes calldata callData,\n        uint112 ethForCall,\n        bool verifyUser,\n        bool insertFeeAmount,\n        bool isAlive\n    ) external payable override targetNotThis(target) returns (uint id) {\n        return _newReq(\n            target,\n            referer,\n            callData,\n            ethForCall,\n            verifyUser,\n            insertFeeAmount,\n            _oracle.defaultPayIsAUTO(),\n            isAlive\n        );\n    }\n\n    function newReqPaySpecific(\n        address target,\n        address payable referer,\n        bytes calldata callData,\n        uint112 ethForCall,\n        bool verifyUser,\n        bool insertFeeAmount,\n        bool payWithAUTO,\n        bool isAlive\n    ) external payable override targetNotThis(target) returns (uint id) {\n        return _newReq(\n            target,\n            referer,\n            callData,\n            ethForCall,\n            verifyUser,\n            insertFeeAmount,\n            payWithAUTO,\n            isAlive\n        );\n    }\n\n    function _newReq(\n        address target,\n        address payable referer,\n        bytes calldata callData,\n        uint112 ethForCall,\n        bool verifyUser,\n        bool insertFeeAmount,\n        bool payWithAUTO,\n        bool isAlive\n    )\n        private\n        validEth(payWithAUTO, ethForCall)\n        returns (uint id)\n    {\n        if (isAlive) {\n            require(msg.value == 0, \"Reg: no ETH while alive\");\n        }\n\n        Request memory r = Request(\n            payable(msg.sender),\n            target,\n            referer,\n            callData,\n            uint112(msg.value),\n            ethForCall,\n            verifyUser,\n            insertFeeAmount,\n            payWithAUTO,\n            isAlive\n        );\n        bytes32 hashedIpfsReq = keccak256(getReqBytes(r));\n\n        id = _hashedReqs.length;\n        emit HashedReqAdded(\n            id,\n            r.user,\n            r.target,\n            r.referer,\n            r.callData,\n            r.initEthSent,\n            r.ethForCall,\n            r.verifyUser,\n            r.insertFeeAmount,\n            r.payWithAUTO,\n            r.isAlive\n        );\n        _hashedReqs.push(hashedIpfsReq);\n    }\n\n    function getHashedReqs() external view override returns (bytes32[] memory) {\n        return _hashedReqs;\n    }\n\n    function getHashedReqsSlice(uint startIdx, uint endIdx) external override view returns (bytes32[] memory) {\n        return _getBytes32Slice(_hashedReqs, startIdx, endIdx);\n    }\n\n    function getHashedReqsLen() external view override returns (uint) {\n        return _hashedReqs.length;\n    }\n    \n    function getHashedReq(uint id) external view override returns (bytes32) {\n        return _hashedReqs[id];\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                Hashed Requests Unverified                //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    function newHashedReqUnveri(bytes32 hashedIpfsReq)\n        external\n        override\n        nzBytes32(hashedIpfsReq)\n        returns (uint id)\n    {\n        id = _hashedReqsUnveri.length;\n        _hashedReqsUnveri.push(hashedIpfsReq);\n        emit HashedReqUnveriAdded(id);\n    }\n    \n    function getHashedReqsUnveri() external view override returns (bytes32[] memory) {\n        return _hashedReqsUnveri;\n    }\n\n    function getHashedReqsUnveriSlice(uint startIdx, uint endIdx) external view override returns (bytes32[] memory) {\n        return _getBytes32Slice(_hashedReqsUnveri, startIdx, endIdx);\n    }\n\n    function getHashedReqsUnveriLen() external view override returns (uint) {\n        return _hashedReqsUnveri.length;\n    }\n    \n    function getHashedReqUnveri(uint id) external view override returns (bytes32) {\n        return _hashedReqsUnveri[id];\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                        Bytes Helpers                     //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    function getReqBytes(Request memory r) public pure override returns (bytes memory) {\n        return abi.encode(r);\n    }\n\n    function getIpfsReqBytes(\n        bytes memory r,\n        bytes memory dataPrefix,\n        bytes memory dataPostfix\n    ) public pure override returns (bytes memory) {\n        return abi.encodePacked(\n            dataPrefix,\n            r,\n            dataPostfix\n        );\n    }\n\n    function getHashedIpfsReq(\n        bytes memory r,\n        bytes memory dataPrefix,\n        bytes memory dataPostfix\n    ) public pure override returns (bytes32) {\n        return sha256(getIpfsReqBytes(r, dataPrefix, dataPostfix));\n    }\n\n    function getReqFromBytes(bytes memory rBytes) public pure override returns (Request memory r) {\n        (r) = abi.decode(rBytes, (Request));\n    }\n\n    function insertToCallData(bytes calldata callData, uint expectedGas, uint startIdx) public pure override returns (bytes memory) {\n        bytes memory cd = callData;\n        bytes memory expectedGasBytes = abi.encode(expectedGas);\n        for (uint i = 0; i < 32; i++) {\n            cd[startIdx+i] = expectedGasBytes[i];\n        }\n\n        return cd;\n    }\n    \n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                         Executions                       //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n\n    /**\n     * @dev validCalldata needs to be before anything that would convert it to memory\n     *      since that is persistent and would prevent validCalldata, that requires\n     *      calldata, from working. Can't do the check in _execute for the same reason.\n     *      Note: targetNotThis and validEth are used in newReq.\n     *      validCalldata is only used here because it causes an unknown\n     *      'InternalCompilerError' when using it with newReq\n     */\n    function executeHashedReq(\n        uint id,\n        Request calldata r,\n        uint expectedGas\n    )\n        external\n        override\n        validExec\n        nonReentrant\n        validCalldata(r)\n        verReq(id, r)\n        returns (uint gasUsed)\n    {\n        uint startGas = gasleft();\n\n        // We are the gods now\n        if (r.isAlive) {\n            emit HashedReqExecuted(id, false);\n        } else {\n            emit HashedReqExecuted(id, true);\n            delete _hashedReqs[id];\n        }\n        _execute(r, expectedGas);\n\n        gasUsed = startGas - gasleft() + (r.payWithAUTO == true ? GAS_OVERHEAD_AUTO : GAS_OVERHEAD_ETH);\n        // Make sure that the expected gas used is within 10% of the actual gas used\n        require(expectedGas * 10 <= gasUsed * 11, \"Reg: expectedGas too high\");\n    }\n\n    function executeHashedReqUnveri(\n        uint id,\n        Request calldata r,\n        bytes memory dataPrefix,\n        bytes memory dataSuffix,\n        uint expectedGas\n    )\n        external\n        override\n        validExec\n        nonReentrant\n        targetNotThis(r.target)\n        verReqIPFS(id, r, dataPrefix, dataSuffix)\n        returns (uint gasUsed)\n    {\n        uint startGas = gasleft();\n        require(\n            r.initEthSent == 0 &&\n            r.ethForCall == 0 &&\n            r.payWithAUTO == true &&\n            r.verifyUser == false,\n            \"Reg: cannot verify. Nice try ;)\"\n        );\n\n        // We are the gods now\n        if (r.isAlive) {\n            emit HashedReqUnveriExecuted(id, false);\n        } else {\n            emit HashedReqUnveriExecuted(id, true);\n            delete _hashedReqsUnveri[id];\n        }\n        _execute(r, expectedGas);\n\n        gasUsed = startGas - gasleft() + (r.payWithAUTO == true ? GAS_OVERHEAD_AUTO : GAS_OVERHEAD_ETH);\n        // Make sure that the expected gas used is within 10% of the actual gas used\n        require(expectedGas * 10 <= gasUsed * 11, \"Reg: expectedGas too high\");\n    }\n\n    function _execute(Request calldata r, uint expectedGas) private {\n        IOracle orac = _oracle;\n        uint ethStartBal = address(this).balance;\n        uint feeTotal;\n        if (r.payWithAUTO) {\n            feeTotal = expectedGas * orac.getGasPriceFast() * orac.getAUTOPerETH() * PAY_AUTO_BPS / (BASE_BPS * _E_18);\n        } else {\n            feeTotal = expectedGas * orac.getGasPriceFast() * PAY_ETH_BPS / BASE_BPS;\n        }\n\n        // Make the call that the user requested\n        bool success;\n        bytes memory returnData;\n        if (r.verifyUser && !r.insertFeeAmount) {\n            (success, returnData) = _userForwarder.forward{value: r.ethForCall}(r.target, r.callData);\n        } else if (!r.verifyUser && r.insertFeeAmount) {\n            (success, returnData) = _gasForwarder.forward{value: r.ethForCall}(\n                r.target,\n                insertToCallData(r.callData, feeTotal, 4)\n            );\n        } else if (r.verifyUser && r.insertFeeAmount) {\n            (success, returnData) = _userGasForwarder.forward{value: r.ethForCall}(\n                r.target,\n                insertToCallData(r.callData, feeTotal, 36)\n            );\n        } else {\n            (success, returnData) = r.target.call{value: r.ethForCall}(r.callData);\n        }\n        // Need this if statement because if the call succeeds, the tx will revert\n        // with an EVM error because it can't decode 0x00. If a tx fails with no error\n        // message, maybe that's a problem? But if it failed without a message then it's\n        // gonna be hard to know what went wrong regardless\n        if (!success) {\n            revert(abi.decode(returnData, (string)));\n        }\n        \n        // Store AUTO rewards\n        // It's cheaper to store the cumulative rewards than it is to send\n        // an AUTO transfer directly since the former changes 1 storage\n        // slot whereas the latter changes 2. The rewards are actually stored\n        // in a different contract that reads the reward storage of this contract\n        // because of the danger of someone using call to call to AUTO and transfer\n        // out tokens. It could be prevented by preventing r.target being set to AUTO,\n        // but it's better to be paranoid and totally separate the contracts.\n        // Need to include these storages in the gas cost that the user pays since\n        // they benefit from part of it and the costs can vary depending on whether\n        // the amounts changed from were 0 or non-0\n        _reqCounts[r.user] += 1;\n        _execCounts[msg.sender] += 1;\n        if (r.referer != _ADDR_0) {\n            _referalCounts[r.referer] += 1;\n        }\n\n        // If ETH was somehow siphoned from this contract during the request,\n        // this will revert because of an `Integer overflow` underflow - a security feature\n        uint ethReceivedDuringRequest = address(this).balance + r.ethForCall - ethStartBal;\n        if (r.payWithAUTO) {\n            // Send the executor their bounty\n            _AUTO.operatorSend(r.user, msg.sender, feeTotal, \"\", \"\");\n        } else {\n            uint ethReceived = r.initEthSent - r.ethForCall + ethReceivedDuringRequest;\n            // Send the executor their bounty\n            require(ethReceived >= feeTotal, \"Reg: not enough eth sent\");\n            payable(msg.sender).transfer(feeTotal);\n\n            // Refund excess to the user\n            uint excess = ethReceived - feeTotal;\n            if (excess > 0) {\n                r.user.transfer(excess);\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                        Cancellations                     //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n    \n    \n    function cancelHashedReq(\n        uint id,\n        Request memory r\n    )\n        external\n        override\n        nonReentrant\n        verReq(id, r)\n    {\n        require(msg.sender == r.user, \"Reg: not the user\");\n        \n        // Cancel the request\n        emit HashedReqCancelled(id);\n        delete _hashedReqs[id];\n        \n        // Send refund\n        if (r.initEthSent > 0) {\n            r.user.transfer(r.initEthSent);\n        }\n    }\n    \n    function cancelHashedReqUnveri(\n        uint id,\n        Request memory r,\n        bytes memory dataPrefix,\n        bytes memory dataSuffix\n    )\n        external\n        override\n        nonReentrant\n        verReqIPFS(id, r, dataPrefix, dataSuffix)\n    {\n        require(msg.sender == r.user, \"Reg: not the user\");\n        \n        // Cancel the request\n        emit HashedReqUnveriCancelled(id);\n        delete _hashedReqsUnveri[id];\n    }\n    \n    \n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                          Getters                         //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n    \n    function getAUTOAddr() external view override returns (address) {\n        return address(_AUTO);\n    }\n    \n    function getStakeManager() external view override returns (address) {\n        return address(_stakeMan);\n    }\n    \n    function getOracle() external view override returns (address) {\n        return address(_oracle);\n    }\n    \n    function getUserForwarder() external view override returns (address) {\n        return address(_userForwarder);\n    }\n    \n    function getGasForwarder() external view override returns (address) {\n        return address(_gasForwarder);\n    }\n    \n    function getUserGasForwarder() external view override returns (address) {\n        return address(_userGasForwarder);\n    }\n\n    function getReqCountOf(address addr) external view override returns (uint) {\n        return _reqCounts[addr];\n    }\n    \n    function getExecCountOf(address addr) external view override returns (uint) {\n        return _execCounts[addr];\n    }\n    \n    function getReferalCountOf(address addr) external view override returns (uint) {\n        return _referalCounts[addr];\n    }\n\n    function _getBytes32Slice(bytes32[] memory arr, uint startIdx, uint endIdx) private pure returns (bytes32[] memory) {\n        bytes32[] memory slice = new bytes32[](endIdx - startIdx);\n        uint sliceIdx = 0;\n        for (uint arrIdx = startIdx; arrIdx < endIdx; arrIdx++) {\n            slice[sliceIdx] = arr[arrIdx];\n            sliceIdx++;\n        }\n\n        return slice;\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    //                                                          //\n    //                          Modifiers                       //\n    //                                                          //\n    //////////////////////////////////////////////////////////////\n\n    modifier targetNotThis(address target) {\n        require(!_invalidTargets[target], \"Reg: nice try ;)\");\n        _;\n    }\n\n    modifier validEth(bool payWithAUTO, uint ethForCall) {\n        if (payWithAUTO) {\n            // When paying with AUTO, there's no reason to send more ETH than will\n            // be used in the future call\n            require(ethForCall == msg.value, \"Reg: ethForCall not msg.value\");\n        } else {\n            // When paying with ETH, ethForCall needs to be lower than msg.value\n            // since some ETH is needed to be left over for paying the fee + bounty\n            require(ethForCall <= msg.value, \"Reg: ethForCall too high\");\n        }\n        _;\n    }\n\n    modifier validCalldata(Request calldata r) {\n        if (r.verifyUser) {\n            require(abi.decode(r.callData[4:36], (address)) == r.user, \"Reg: calldata not verified\");\n        }\n        _;\n    }\n\n    modifier validExec() {\n        require(_stakeMan.isUpdatedExec(msg.sender), \"Reg: not executor or expired\");\n        _;\n    }\n\n    // Verify that a request is the same as the one initially stored. This also\n    // implicitly checks that the request hasn't been deleted as the hash of the\n    // request isn't going to be address(0)\n    modifier verReq(\n        uint id,\n        Request memory r\n    ) {\n        require(\n            keccak256(getReqBytes(r)) == _hashedReqs[id], \n            \"Reg: request not the same\"\n        );\n        _;\n    }\n\n    // Verify that a request is the same as the one initially stored. This also\n    // implicitly checks that the request hasn't been deleted as the hash of the\n    // request isn't going to be address(0)\n    modifier verReqIPFS(\n        uint id,\n        Request memory r,\n        bytes memory dataPrefix,\n        bytes memory dataSuffix\n    ) {\n        require(\n            getHashedIpfsReq(getReqBytes(r), dataPrefix, dataSuffix) == _hashedReqsUnveri[id], \n            \"Reg: unveri request not the same\"\n        );\n        _;\n    }\n    \n    receive() external payable {}\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IStakeManager\",\"name\":\"stakeMan\",\"type\":\"address\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"contract IForwarder\",\"name\":\"userForwarder\",\"type\":\"address\"},{\"internalType\":\"contract IForwarder\",\"name\":\"gasForwarder\",\"type\":\"address\"},{\"internalType\":\"contract IForwarder\",\"name\":\"userGasForwarder\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalAUTOSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"initEthSent\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"name\":\"HashedReqAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"HashedReqCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasRemoved\",\"type\":\"bool\"}],\"name\":\"HashedReqExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"HashedReqUnveriAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"HashedReqUnveriCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasRemoved\",\"type\":\"bool\"}],\"name\":\"HashedReqUnveriExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_OVERHEAD_AUTO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_OVERHEAD_ETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAY_AUTO_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAY_ETH_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"initEthSent\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"internalType\":\"struct IRegistry.Request\",\"name\":\"r\",\"type\":\"tuple\"}],\"name\":\"cancelHashedReq\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"initEthSent\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"internalType\":\"struct IRegistry.Request\",\"name\":\"r\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"dataPrefix\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dataSuffix\",\"type\":\"bytes\"}],\"name\":\"cancelHashedReqUnveri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"initEthSent\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"internalType\":\"struct IRegistry.Request\",\"name\":\"r\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"expectedGas\",\"type\":\"uint256\"}],\"name\":\"executeHashedReq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"initEthSent\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"internalType\":\"struct IRegistry.Request\",\"name\":\"r\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"dataPrefix\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dataSuffix\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expectedGas\",\"type\":\"uint256\"}],\"name\":\"executeHashedReqUnveri\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAUTOAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getExecCountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"r\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dataPrefix\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dataPostfix\",\"type\":\"bytes\"}],\"name\":\"getHashedIpfsReq\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getHashedReq\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getHashedReqUnveri\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHashedReqs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHashedReqsLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIdx\",\"type\":\"uint256\"}],\"name\":\"getHashedReqsSlice\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHashedReqsUnveri\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHashedReqsUnveriLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIdx\",\"type\":\"uint256\"}],\"name\":\"getHashedReqsUnveriSlice\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"r\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dataPrefix\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dataPostfix\",\"type\":\"bytes\"}],\"name\":\"getIpfsReqBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReferalCountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"initEthSent\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"internalType\":\"struct IRegistry.Request\",\"name\":\"r\",\"type\":\"tuple\"}],\"name\":\"getReqBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReqCountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rBytes\",\"type\":\"bytes\"}],\"name\":\"getReqFromBytes\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"initEthSent\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"internalType\":\"struct IRegistry.Request\",\"name\":\"r\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserGasForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expectedGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startIdx\",\"type\":\"uint256\"}],\"name\":\"insertToCallData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashedIpfsReq\",\"type\":\"bytes32\"}],\"name\":\"newHashedReqUnveri\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"name\":\"newReq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint112\",\"name\":\"ethForCall\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"verifyUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"insertFeeAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payWithAUTO\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAlive\",\"type\":\"bool\"}],\"name\":\"newReqPaySpecific\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Registry", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000de946e11a1f06f58ba0429dafaaabe6ec1c7d4980000000000000000000000003831ff695ddf9f792f2202a9e3121f3880711d87000000000000000000000000ce675b50034a2304b01dc5e53787ec77bb7965d4000000000000000000000000e390b2436df1fe909628fa5eb8f53d041d7b2c930000000000000000000000004f54277e6412504eba0b259a9e4c69dc7ee4bb9c000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000033b2e3c9fd0803ce800a45500000000000000000000000000000000000000000000000000000000000000104175746f6e6f6d79204e6574776f726b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044155544f00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}