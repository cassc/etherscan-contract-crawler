{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.7;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(isContract(address(token)), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function limitSupply() external view returns (uint256);\r\n    function availableSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n    address busd = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // live busd\r\n    // address busd = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // testnet busd\r\n    IERC20 token;\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 internal _limitSupply;\r\n\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint8  internal _decimals;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function limitSupply() public override view returns (uint256) {\r\n        return _limitSupply;\r\n    }\r\n    \r\n    function availableSupply() public override view returns (uint256) {\r\n        return _limitSupply.sub(_totalSupply);\r\n    }    \r\n\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override virtual returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public override view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        require(availableSupply() >= amount, \"Supply exceed\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        \r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\nabstract contract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 amount, address token, bytes calldata extraData) external virtual;\r\n}\r\n\r\ncontract Token is ERC20 {\r\n    mapping (address => bool) private _contracts;\r\n\r\n    constructor() {\r\n        _name = \"BUSDHoneyV2\";\r\n        _symbol = \"BUSDHoneyV2\";\r\n        _decimals = 18;\r\n        _limitSupply = 10000000e18;\r\n    }\r\n\r\n    function approveAndCall(address spender, uint256 amount, bytes memory extraData) public returns (bool) {\r\n        require(approve(spender, amount));\r\n\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, amount, address(this), extraData);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public override returns (bool) {\r\n\r\n        if (_contracts[to]) {\r\n            approveAndCall(to, value, new bytes(0));\r\n        } else {\r\n            super.transfer(to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface IInsuranceContract {\r\n\tfunction initiate() external;\r\n\tfunction getBalance() external view returns(uint);\r\n\tfunction getMainContract() external view returns(address);\r\n}\r\n\r\ncontract INSURANCE {\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\taddress private tokenAddr = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // BUSD\r\n\t// address private tokenAddr = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // BUSD testnet\r\n\tIERC20 public token;\r\n\r\n\t//accept funds from MainContract\r\n\treceive() external payable {}\r\n\taddress payable public MAINCONTRACT;\r\n\r\n\tconstructor() {\r\n\t\tMAINCONTRACT = payable(msg.sender);\r\n\t\ttoken = IERC20(tokenAddr);\r\n\t}\r\n\r\n\tfunction initiate() public {\r\n\t\trequire(msg.sender == MAINCONTRACT, \"Forbidden\");\r\n\t\tuint balance = token.balanceOf(address(this));\r\n\t\tif(balance==0) return;\r\n\t\ttoken.safeTransfer(MAINCONTRACT, balance);\r\n\t}\r\n\r\n\tfunction getBalance() public view returns(uint) {\r\n\t\treturn token.balanceOf(address(this));\r\n\t}\r\n\r\n\tfunction getMainContract() public view returns(address) {\r\n\t\treturn MAINCONTRACT;\r\n\t}\r\n\r\n}\r\n\r\ncontract BUSDHoneyV2 is Token {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address payable private ADMIN;\r\n    address payable private DEV;\r\n    \r\n    uint public totalUsers; \r\n    uint public totalBUSDStaked; \r\n    uint public totalTokenStaked;\r\n    \r\n    uint8[] private REF_BONUSES             = [70, 30, 20, 10, 5];\r\n    uint private constant ADMIN_FEE         = 90;\r\n    uint private constant DEV_FEE           = 10;\r\n    uint private constant BUSD_DAILYPROFIT  = 2000;\r\n    uint private constant TOKEN_DAILYPROFIT = 100;\r\n    uint private constant PERCENT_DIVIDER   = 1000;\r\n    uint private constant PRICE_DIVIDER     = 1 ether;\r\n    uint private constant TIME_STEP         = 1 days;\r\n    uint private constant TIME_TO_UNSTAKE   = 7 days;\r\n    uint private constant SELL_LIMIT        = 40000 ether; \r\n\r\n    address payable public\t\t\tINSURANCE_CONTRACT;\r\n\tmapping (uint => uint) public\tINSURANCE_MAXBALANCE;\r\n\tuint constant public\t\t\tINSURANCE_PERCENT\t\t\t\t= 200;\t// insurance fee 20% of claim\r\n\tuint constant public\t\t\tINSURANCE_LOWBALANCE_PERCENT\t= 250;\t// protection kicks in at 25% or lower\r\n    uint public INSURANCE_TRIGGER_BALANCE;\r\n    \r\n    mapping(address => User) private users;\r\n    mapping(uint => uint) private sold; \r\n    \r\n    struct Stake {\r\n        uint checkpoint;\r\n        uint totalStaked; \r\n        uint lastStakeTime;\r\n        uint unClaimedTokens;        \r\n    }\r\n    \r\n    struct User {\r\n        address referrer;\r\n        Stake sM;\r\n        Stake sT;  \r\n\t\tuint256 bonus;\r\n\t\tuint256 totalBonus;\r\n        uint totaReferralBonus;\r\n        uint[5] levels;\r\n    }\r\n    \r\n\tevent InitiateInsurance(uint high, uint current);\r\n\tevent InsuranseFeePaid(uint amount);\r\n\r\n    event NewStake(address indexed user, uint256 amount, uint256 time);\r\n    event NewStakeToken(address indexed user, uint256 amount, uint256 time);\r\n\tevent UnStakeToken(address indexed user, uint256 amount, uint256 time);\r\n\tevent WithdrawRef(address indexed user, uint256 amount, uint256 time);\r\n    event Sell(address indexed account, uint256 tokenAmount, uint256 amount, uint256 time);\r\n    event Claim(address indexed account, uint256 tokenAmount, uint256 time);\r\n    event FeePaid(address indexed user, uint256 totalAmount);\r\n\r\n    uint256 public startDate;\r\n\r\n    receive() external payable {}\r\n\r\n\tconstructor(address payable ceoAddr, address payable devAddr, uint256 start) {\r\n\t\tADMIN = ceoAddr;\r\n\t\tDEV = devAddr;\r\n\t\tif(start > 0){\r\n\t\t\tstartDate = start;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tstartDate = block.timestamp;\r\n\t\t}\r\n\r\n        token = IERC20(busd);\r\n        INSURANCE_CONTRACT = payable(new INSURANCE());\r\n    }  \r\n    \r\n    function stakeBUSD(address referrer,  uint256 _amount) public payable {\r\n        require (block.timestamp > startDate);\r\n        \r\n        token.transferFrom(msg.sender, address(this), _amount);\r\n        \r\n\t\tuint feeAdmin = _amount.mul(ADMIN_FEE).div(PERCENT_DIVIDER);\r\n\t\tuint feeADev =  _amount.mul(DEV_FEE).div(PERCENT_DIVIDER);\r\n        token.transfer(ADMIN, feeAdmin);\r\n        token.transfer(DEV, feeADev);  \r\n        emit FeePaid(msg.sender, feeAdmin.add(feeADev));   \r\n\r\n\t\tUser storage user = users[msg.sender];\r\n\t\t\r\n\t\tif (user.referrer == address(0) && msg.sender != ADMIN) {\r\n\t\t\tif (users[referrer].sM.totalStaked == 0) {\r\n\t\t\t\treferrer = ADMIN;\r\n\t\t\t}\r\n\t\t\tuser.referrer = referrer;\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < REF_BONUSES.length; i++) {\r\n\t\t\t\tif (upline != address(0)) {\r\n\t\t\t\t\tusers[upline].levels[i] = users[upline].levels[i].add(1);\r\n\t\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t\t} else break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (user.referrer != address(0)) {\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < REF_BONUSES.length; i++) {\r\n\t\t\t\tif (upline == address(0)) {\r\n\t\t\t\t    upline = ADMIN;\r\n\t\t\t\t}\r\n\t\t\t\tuint256 amount = _amount.mul(REF_BONUSES[i]).div(PERCENT_DIVIDER);\r\n\t\t\t\tusers[upline].bonus = users[upline].bonus.add(amount);\r\n\t\t\t\tusers[upline].totalBonus = users[upline].totalBonus.add(amount);\r\n\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t}\r\n\t\t} \r\n\r\n        if (user.sM.totalStaked == 0) {\r\n            user.sM.checkpoint = maxVal(block.timestamp, startDate);\r\n            totalUsers++;\r\n        } else {\r\n            updateStakeBUSD_IP(msg.sender);\r\n        }\r\n      \r\n        user.sM.lastStakeTime = block.timestamp;\r\n        user.sM.totalStaked = user.sM.totalStaked.add(_amount);\r\n        totalBUSDStaked = totalBUSDStaked.add(_amount);\r\n\r\n        emit NewStake(msg.sender, _amount, block.timestamp);\r\n    }\r\n    \r\n    function stakeToken(uint tokenAmount) public {\r\n\r\n        User storage user = users[msg.sender];\r\n        require(block.timestamp >= startDate, \"Stake not available yet\");\r\n        require(tokenAmount <= balanceOf(msg.sender), \"Insufficient Token Balance\");\r\n\r\n        if (user.sT.totalStaked == 0) {\r\n            user.sT.checkpoint = block.timestamp;\r\n        } else {\r\n            updateStakeToken_IP(msg.sender);\r\n        }\r\n        \r\n        _transfer(msg.sender, address(this), tokenAmount);\r\n        user.sT.lastStakeTime = block.timestamp;\r\n        user.sT.totalStaked = user.sT.totalStaked.add(tokenAmount);\r\n        totalTokenStaked = totalTokenStaked.add(tokenAmount); \r\n        emit NewStakeToken(msg.sender, tokenAmount, block.timestamp);\r\n    } \r\n    \r\n    function unStakeToken() public {\r\n        User storage user = users[msg.sender];\r\n        require(block.timestamp > user.sT.lastStakeTime.add(TIME_TO_UNSTAKE));\r\n        updateStakeToken_IP(msg.sender);\r\n        uint tokenAmount = user.sT.totalStaked;\r\n        user.sT.totalStaked = 0;\r\n        totalTokenStaked = totalTokenStaked.sub(tokenAmount); \r\n        _transfer(address(this), msg.sender, tokenAmount);\r\n        emit UnStakeToken(msg.sender, tokenAmount, block.timestamp);\r\n    }  \r\n    \r\n    function updateStakeBUSD_IP(address _addr) private {\r\n        User storage user = users[_addr];\r\n        uint256 amount = getStakeBUSD_IP(_addr);\r\n        if(amount > 0) {\r\n            user.sM.unClaimedTokens = user.sM.unClaimedTokens.add(amount);\r\n            user.sM.checkpoint = block.timestamp;\r\n        }\r\n    } \r\n    \r\n    function getStakeBUSD_IP(address _addr) view private returns(uint256 value) {\r\n        User storage user = users[_addr];\r\n        uint256 fr = user.sM.checkpoint;\r\n        if (startDate > block.timestamp) {\r\n          fr = block.timestamp; \r\n        }\r\n        uint256 Tarif = BUSD_DAILYPROFIT;\r\n        uint256 to = block.timestamp;\r\n        if(fr < to) {\r\n            value = user.sM.totalStaked.mul(to - fr).mul(Tarif).div(TIME_STEP).div(PERCENT_DIVIDER);\r\n        } else {\r\n            value = 0;\r\n        }\r\n        return value;\r\n    }  \r\n    \r\n    function updateStakeToken_IP(address _addr) private {\r\n        User storage user = users[_addr];\r\n        uint256 amount = getStakeToken_IP(_addr);\r\n        if(amount > 0) {\r\n            user.sT.unClaimedTokens = user.sT.unClaimedTokens.add(amount);\r\n            user.sT.checkpoint = block.timestamp;\r\n        }\r\n    } \r\n    \r\n    function getStakeToken_IP(address _addr) view private returns(uint256 value) {\r\n        User storage user = users[_addr];\r\n        uint256 fr = user.sT.checkpoint;\r\n        if (startDate > block.timestamp) {\r\n          fr = block.timestamp; \r\n        }\r\n        uint256 Tarif = TOKEN_DAILYPROFIT;\r\n        uint256 to = block.timestamp;\r\n        if(fr < to) {\r\n            value = user.sT.totalStaked.mul(to - fr).mul(Tarif).div(TIME_STEP).div(PERCENT_DIVIDER);\r\n        } else {\r\n            value = 0;\r\n        }\r\n        return value;\r\n    }      \r\n    \r\n    function claimToken_M() public {\r\n        User storage user = users[msg.sender];\r\n       \r\n        updateStakeBUSD_IP(msg.sender);\r\n        uint tokenAmount = user.sM.unClaimedTokens;  \r\n        user.sM.unClaimedTokens = 0;                 \r\n        \r\n        _mint(msg.sender, tokenAmount);\r\n        emit Claim(msg.sender, tokenAmount, block.timestamp);\r\n    }    \r\n    \r\n    function claimToken_T() public {\r\n        User storage user = users[msg.sender];\r\n       \r\n        updateStakeToken_IP(msg.sender);\r\n        uint tokenAmount = user.sT.unClaimedTokens; \r\n        user.sT.unClaimedTokens = 0; \r\n        \r\n        _mint(msg.sender, tokenAmount);\r\n        emit Claim(msg.sender, tokenAmount, block.timestamp);\r\n    }     \r\n    \r\n    function sellToken(uint tokenAmount) public {\r\n        tokenAmount = minVal(tokenAmount, balanceOf(msg.sender));\r\n        require(tokenAmount > 0, \"Token amount can not be 0\");\r\n        \r\n        require(sold[getCurrentDay()].add(tokenAmount) <= SELL_LIMIT, \"Daily Sell Limit exceed\");\r\n        sold[getCurrentDay()] = sold[getCurrentDay()].add(tokenAmount);\r\n        uint BUSDAmount = tokenToBUSD(tokenAmount);\r\n    \r\n        require(getContractBUSDBalance() > BUSDAmount, \"Insufficient Contract Balance\");\r\n        _burn(msg.sender, tokenAmount);\r\n\r\n        //insurance\r\n\t\tuint insuranceAmount = BUSDAmount * INSURANCE_PERCENT / PERCENT_DIVIDER;\r\n\t\ttoken.safeTransfer(INSURANCE_CONTRACT, insuranceAmount);\r\n\t\temit InsuranseFeePaid(insuranceAmount);\r\n\r\n        BUSDAmount -= insuranceAmount;\r\n\r\n        token.transfer(msg.sender, BUSDAmount);\r\n        \r\n        emit Sell(msg.sender, tokenAmount, BUSDAmount, block.timestamp);\r\n\r\n        _insuranceTrigger();\r\n    }  \r\n\r\n    function _insuranceTrigger() internal {\r\n\r\n\t\tuint balance = token.balanceOf(address(this));\r\n\t\tuint todayIdx = block.timestamp/TIME_STEP;\r\n\r\n\t\t//new high today\r\n\t\tif ( INSURANCE_MAXBALANCE[todayIdx] < balance ) {\r\n\t\t\tINSURANCE_MAXBALANCE[todayIdx] = balance;\r\n\t\t}\r\n\r\n\t\t//high of past 7 days\r\n\t\tuint rangeHigh;\r\n\t\tfor( uint i=0; i<7; i++) {\r\n\t\t\tif( INSURANCE_MAXBALANCE[todayIdx-i] > rangeHigh ) {\r\n\t\t\t\trangeHigh = INSURANCE_MAXBALANCE[todayIdx-i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tINSURANCE_TRIGGER_BALANCE = rangeHigh*INSURANCE_LOWBALANCE_PERCENT/PERCENT_DIVIDER;\r\n\r\n\t\t//low balance - initiate Insurance\r\n\t\tif( balance < INSURANCE_TRIGGER_BALANCE ) {\r\n\t\t\temit InitiateInsurance( rangeHigh, balance );\r\n\t\t\tIInsuranceContract(INSURANCE_CONTRACT).initiate();\r\n\t\t}\r\n\t}\r\n\r\n    function getInsuranceInfo() public view returns(uint o_ensBalance, uint o_ensTriggerBalance) {\r\n\r\n\t\tuint insuranceBalance = IInsuranceContract(INSURANCE_CONTRACT).getBalance();\r\n\t\treturn(insuranceBalance, INSURANCE_TRIGGER_BALANCE );\r\n\t}\r\n    \r\n\tfunction withdrawRef() public {\r\n\t\tUser storage user = users[msg.sender];\r\n\t\t\r\n\t\tuint totalAmount = getUserReferralBonus(msg.sender);\r\n\t\trequire(totalAmount > 0, \"User has no dividends\");\r\n        user.bonus = 0;\r\n\t\ttoken.transfer(msg.sender, totalAmount);\r\n        emit WithdrawRef(msg.sender, totalAmount, block.timestamp);\r\n\t}\t    \r\n\r\n    function getUserUnclaimedTokens_M(address _addr) public view returns(uint value) {\r\n        User storage user = users[_addr];\r\n        return getStakeBUSD_IP(_addr).add(user.sM.unClaimedTokens); \r\n    }\r\n    \r\n    function getUserUnclaimedTokens_T(address _addr) public view returns(uint value) {\r\n        User storage user = users[_addr];\r\n        return getStakeToken_IP(_addr).add(user.sT.unClaimedTokens); \r\n    }       \r\n\r\n    function getContractBalance() public view returns(uint) {\r\n\t\tuint insuranceBalance = IInsuranceContract(INSURANCE_CONTRACT).getBalance();\r\n\t\treturn token.balanceOf(address(this)) + insuranceBalance;\r\n\t}\r\n    \r\n\tfunction getContractBUSDBalance() public view returns (uint) {\r\n\t    return token.balanceOf(address(this));\r\n\t}  \r\n\t\r\n\tfunction getContractTokenBalance() public view returns (uint) {\r\n\t\treturn balanceOf(address(this));\r\n\t}  \r\n\t\r\n\tfunction getAPY_M() public pure returns (uint) {\r\n\t\treturn BUSD_DAILYPROFIT.mul(365).div(10);\r\n\t}\r\n\t\r\n\tfunction getAPY_T() public pure returns (uint) {\r\n\t\treturn TOKEN_DAILYPROFIT.mul(365).div(10);\r\n\t}\t\r\n\t\r\n\tfunction getUserBUSDBalance(address _addr) public view returns (uint) {\r\n\t\treturn address(_addr).balance;\r\n\t}\t\r\n\t\r\n\tfunction getUserTokenBalance(address _addr) public view returns (uint) {\r\n\t\treturn balanceOf(_addr);\r\n\t}\r\n\t\r\n\tfunction getUserBUSDStaked(address _addr) public view returns (uint) {\r\n\t\treturn users[_addr].sM.totalStaked;\r\n\t}\t\r\n\t\r\n\tfunction getUserTokenStaked(address _addr) public view returns (uint) {\r\n\t\treturn users[_addr].sT.totalStaked;\r\n\t}\r\n\t\r\n\tfunction getUserTimeToUnstake(address _addr) public view returns (uint) {\r\n\t\treturn  minZero(users[_addr].sT.lastStakeTime.add(TIME_TO_UNSTAKE), block.timestamp);\r\n\t}\t\r\n\t\r\n    function getTokenPrice() public view returns(uint) {\r\n        uint d1 = getContractBalance().mul(PRICE_DIVIDER);\r\n        uint d2 = availableSupply().add(1);\r\n        return d1.div(d2);\r\n    } \r\n\r\n    function BUSDToToken(uint BUSDAmount) public view returns(uint) {\r\n        return BUSDAmount.mul(PRICE_DIVIDER).div(getTokenPrice());\r\n    }\r\n\r\n    function tokenToBUSD(uint tokenAmount) public view returns(uint) {\r\n        return tokenAmount.mul(getTokenPrice()).div(PRICE_DIVIDER);\r\n    } \t\r\n\r\n\tfunction getUserDownlineCount(address userAddress) public view returns(uint, uint, uint, uint, uint) {\r\n\t\treturn (users[userAddress].levels[0], users[userAddress].levels[1], users[userAddress].levels[2], users[userAddress].levels[3], users[userAddress].levels[4]);\r\n\t}  \r\n\t\r\n\tfunction getUserReferralBonus(address userAddress) public view returns(uint) {\r\n\t\treturn users[userAddress].bonus;\r\n\t}\r\n\r\n\tfunction getUserReferralTotalBonus(address userAddress) public view returns(uint) {\r\n\t\treturn users[userAddress].totalBonus;\r\n\t}\r\n\t\r\n\tfunction getUserReferralWithdrawn(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].totalBonus.sub(users[userAddress].bonus);\r\n\t}\t\r\n    \r\n\tfunction getContractLaunchTime() public view returns(uint) {\r\n\t\treturn minZero(startDate, block.timestamp);\r\n\t}\r\n\t\r\n    function getCurrentDay() public view returns (uint) {\r\n        return minZero(block.timestamp, startDate).div(TIME_STEP);\r\n    }\t\r\n    \r\n    function getTokenSoldToday() public view returns (uint) {\r\n        return sold[getCurrentDay()];\r\n    }   \r\n    \r\n    function getTokenAvailableToSell() public view returns (uint) {\r\n       return minZero(SELL_LIMIT, sold[getCurrentDay()]);\r\n    }  \r\n    \r\n    function getTimeToNextDay() public view returns (uint) {\r\n        uint t = minZero(block.timestamp, startDate);\r\n        uint g = getCurrentDay().mul(TIME_STEP);\r\n        return g.add(TIME_STEP).sub(t);\r\n    }     \r\n    \r\n    function minZero(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return a - b; \r\n        } else {\r\n           return 0;    \r\n        }    \r\n    }   \r\n    \r\n    function maxVal(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return a; \r\n        } else {\r\n           return b;    \r\n        }    \r\n    }\r\n    \r\n    function minVal(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return b; \r\n        } else {\r\n           return a;    \r\n        }    \r\n    }    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"ceoAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"devAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"high\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"InitiateInsurance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsuranseFeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"NewStakeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"UnStakeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"WithdrawRef\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"BUSDAmount\",\"type\":\"uint256\"}],\"name\":\"BUSDToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_CONTRACT\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_LOWBALANCE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"INSURANCE_MAXBALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_TRIGGER_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken_M\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken_T\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPY_M\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPY_T\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBUSDBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractLaunchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInsuranceInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"o_ensBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"o_ensTriggerBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeToNextDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenAvailableToSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenSoldToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserBUSDBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserBUSDStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDownlineCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralTotalBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTimeToUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTokenStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserUnclaimedTokens_M\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserUnclaimedTokens_T\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeBUSD\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenToBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBUSDStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unStakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BUSDHoneyV2", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000554472D18830641fF7256B60b4f4E14b0E88D1Ba000000000000000000000000554472D18830641fF7256B60b4f4E14b0E88D1Ba0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://82dc474a287667a9e15bad2a3980074915d0fc29d2dbc0e21651c7d6eff20822"}