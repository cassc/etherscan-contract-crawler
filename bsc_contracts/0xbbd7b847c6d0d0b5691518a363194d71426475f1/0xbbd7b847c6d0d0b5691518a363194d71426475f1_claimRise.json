{"SourceCode": "// Copyright (c) 2022 EverRise Pte Ltd. All rights reserved.\r\n// EverRise licenses this file to you under the MIT license.\r\n/*\r\n Virtual token that allows unclaimed rewards from EverRise Staking NFTs\r\n and its Vote Escrowed (ve) EverRise to display in wallet balances.\r\n                                    ________                              _______   __\r\n                                   /        |                            /       \\ /  |\r\n                                   $$$$$$$$/__     __  ______    ______  $$$$$$$  |$$/   _______   ______  v3.14159265\r\n                                   $$ |__  /  \\   /  |/      \\  /      \\ $$ |__$$ |/  | /       | /      \\\r\n      ______      _____            $$    | $$  \\ /$$//$$$$$$  |/$$$$$$  |$$    $$< $$ |/$$$$$$$/ /$$$$$$  |\r\n_________  /_____ ___(_)______ ___ $$$$$/   $$  /$$/ $$    $$ |$$ |  $$/ $$$$$$$  |$$ |$$      \\ $$    $$ |\r\n_  ___/_  /_  __ `/_  /__  __ `__ \\$$ |_____ $$ $$/  $$$$$$$$/ $$ |      $$ |  $$ |$$ | $$$$$$  |$$$$$$$$/\r\n/ /__ _  / / /_/ /_  / _  / / / / /$$       | $$$/   $$       |$$ |      $$ |  $$ |$$ |/     $$/ $$       |\r\n\\___/ /_/  \\__,_/ /_/  /_/ /_/ /_/ $$$$$$$$/   $/     $$$$$$$/ $$/       $$/   $$/ $$/ $$$$$$$/   $$$$$$$/\r\n\r\nLearn more about EverRise and the EverRise Ecosystem of dApps and\r\nhow our utilities and partners can help protect your investors\r\nand help your project grow: https://www.everrise.com\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.13;\r\n\r\nerror NotZeroAddress();                    // 0x66385fa3\r\nerror CallerNotApproved();                 // 0x4014f1a5\r\nerror InvalidAddress();                    // 0xe6c4247b\r\nerror CallerNotOwner();\r\nerror WalletLocked();                      // 0xd550ed24\r\nerror DoesNotExist();                      // 0xb0ce7591\r\nerror AmountMustBeGreaterThanZero();       // 0x5e85ae73\r\nerror AmountOutOfRange();                  // 0xc64200e9\r\nerror StakeStillLocked();                  // 0x7f6699f6\r\nerror NotStakerAddress();                  // 0x2a310a0c\r\nerror AmountLargerThanAvailable();         // 0xbb296109\r\nerror StakeCanOnlyBeExtended();            // 0x73f7040a\r\nerror ArrayLengthsMismatch();              // 0x3b800a46\r\nerror NotSetup();                          // 0xb09c99c0\r\nerror NotAllowedToCreateRewards();         // 0xfdc42f29\r\nerror NotAllowedToDeliverRewards();        // 0x69a3e246\r\nerror ERC721ReceiverReject();              // 0xfa34343f\r\nerror ERC721ReceiverNotImplemented();      // 0xa89c6c0d\r\nerror NotEnoughToCoverStakeFee();          // 0x627554ed\r\nerror AmountLargerThanAllowance();         // 0x9b144c57\r\nerror AchievementNotClaimed();             // 0x3834dd9c\r\nerror AchievementAlreadyClaimed();         // 0x2d5345f4\r\nerror AmountMustBeAnInteger();             // 0x743aec61\r\nerror BrokenStatusesDiffer();              // 0x097b027d\r\nerror AchievementClaimStatusesDiffer();    // 0x6524e8b0\r\nerror UnlockedStakesMustBeSametimePeriod();// 0x42e227b0\r\nerror CannotMergeLockedAndUnlockedStakes();// 0x9efeef2c\r\nerror StakeUnlocked();                     // 0x6717a455\r\nerror NoRewardsToClaim();                  // 0x73380d99\r\nerror NotTransferrable();                  // 0x54ee5151\r\nerror Overflow();                          // 0x35278d12\r\nerror MergeNotEnabled();                   // 0x\r\n\r\n// File: EverRise-v3/Interfaces/IERC173-Ownable.sol\r\n\r\ninterface IOwnable {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    function owner() external view returns (address);\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n// File: EverRise-v3/Abstract/Context.sol\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n}\r\n\r\n// File: EverRise-v3/Abstract/ERC173-Ownable.sol\r\n\r\ncontract Ownable is IOwnable, Context {\r\n    address public owner;\r\n\r\n    function _onlyOwner() private view {\r\n        if (owner != _msgSender()) revert CallerNotOwner();\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    // Allow contract ownership and access to contract onlyOwner functions\r\n    // to be locked using EverOwn with control gated by community vote.\r\n    //\r\n    // EverRise ($RISE) stakers become voting members of the\r\n    // decentralized autonomous organization (DAO) that controls access\r\n    // to the token contract via the EverRise Ecosystem dApp EverOwn\r\n    function transferOwnership(address newOwner) external virtual onlyOwner {\r\n        if (newOwner == address(0)) revert NotZeroAddress();\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\nstruct ApprovalChecks {\r\n    // Prevent permits being reused (IERC2612)\r\n    uint64 nonce;\r\n    // Allow revoke all spenders/operators approvals in single txn\r\n    uint32 nftCheck;\r\n    uint32 tokenCheck;\r\n    // Allow auto timeout on approvals\r\n    uint16 autoRevokeNftHours;\r\n    uint16 autoRevokeTokenHours;\r\n    // Allow full wallet locking of all transfers\r\n    uint48 unlockTimestamp;\r\n}\r\n\r\nstruct Allowance {\r\n    uint128 tokenAmount;\r\n    uint32 nftCheck;\r\n    uint32 tokenCheck;\r\n    uint48 timestamp;\r\n    uint8 nftApproval;\r\n    uint8 tokenApproval;\r\n}\r\n\r\ninterface IEverRiseWallet {\r\n    event RevokeAllApprovals(address indexed account, bool tokens, bool nfts);\r\n    event SetApprovalAutoTimeout(address indexed account, uint16 tokensHrs, uint16 nftsHrs);\r\n    event LockWallet(address indexed account, address altAccount, uint256 length);\r\n    event LockWalletExtend(address indexed account, uint256 length);\r\n}\r\n\r\n// File: EverRise-v3/Interfaces/IERC20-Token.sol\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    function transferFromWithPermit(address sender, address recipient, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: EverRise-v3/Interfaces/IEverRise.sol\r\n\r\ninterface IEverRise is IERC20Metadata {\r\n    function totalBuyVolume() external view returns (uint256);\r\n    function totalSellVolume() external view returns (uint256);\r\n    function holders() external view returns (uint256);\r\n    function uniswapV2Pair() external view returns (address);\r\n    function transferStake(address fromAddress, address toAddress, uint96 amountToTransfer) external;\r\n    function isWalletLocked(address fromAddress) external view returns (bool);\r\n    function setApprovalForAll(address fromAddress, address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function isExcludedFromFee(address account) external view returns (bool);\r\n\r\n    function approvals(address operator) external view returns (ApprovalChecks memory);\r\n}\r\n\r\n\r\n// File: EverRise-v3/Interfaces/IERC721-Nft.sol\r\n\r\ninterface IERC721 /* is ERC165 */ {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n// File: EverRise-v3/Interfaces/InftEverRise.sol\r\n\r\nstruct StakingDetails {\r\n    uint96 initialTokenAmount;    // Max 79 Bn tokens\r\n    uint96 withdrawnAmount;       // Max 79 Bn tokens\r\n    uint48 depositTime;           // 8 M years\r\n    uint8 numOfMonths;            // Max 256 month period\r\n    uint8 achievementClaimed;\r\n    // 256 bits, 20000 gwei gas\r\n    address stakerAddress;        // 160 bits (96 bits remaining)\r\n    uint32 nftId;                 // Max 4 Bn nfts issued\r\n    uint32 lookupIndex;           // Max 4 Bn active stakes\r\n    uint24 stakerIndex;           // Max 16 M active stakes per wallet\r\n    uint8 isActive;\r\n    // 256 bits, 20000 gwei gas\r\n} // Total 768 bits, 40000 gwei gas\r\n\r\ninterface InftEverRise is IERC721 {\r\n    function voteEscrowedBalance(address account) external view returns (uint256);\r\n    function unclaimedRewardsBalance(address account) external view returns (uint256);\r\n    function totalAmountEscrowed() external view returns (uint256);\r\n    function totalAmountVoteEscrowed() external view returns (uint256);\r\n    function totalRewardsDistributed() external view returns (uint256);\r\n    function totalRewardsUnclaimed() external view returns (uint256);\r\n\r\n    function createRewards(uint256 tAmount) external;\r\n\r\n    function getNftData(uint256 id) external view returns (StakingDetails memory);\r\n    function enterStaking(address fromAddress, uint96 amount, uint8 numOfMonths) external returns (uint32 nftId);\r\n    function leaveStaking(address fromAddress, uint256 id, bool overrideNotClaimed) external returns (uint96 amount);\r\n    function earlyWithdraw(address fromAddress, uint256 id, uint96 amount) external returns (uint32 newNftId, uint96 penaltyAmount);\r\n    function withdraw(address fromAddress, uint256 id, uint96 amount, bool overrideNotClaimed) external returns (uint32 newNftId);\r\n    function bridgeStakeNftOut(address fromAddress, uint256 id) external returns (uint96 amount);\r\n    function bridgeOrAirdropStakeNftIn(address toAddress, uint96 depositAmount, uint8 numOfMonths, uint48 depositTime, uint96 withdrawnAmount, uint96 rewards, bool achievementClaimed) external returns (uint32 nftId);\r\n    function addStaker(address staker, uint256 nftId) external;\r\n    function removeStaker(address staker, uint256 nftId) external;\r\n    function reissueStakeNft(address staker, uint256 oldNftId, uint256 newNftId) external;\r\n    function increaseStake(address staker, uint256 nftId, uint96 amount) external returns (uint32 newNftId, uint96 original, uint8 numOfMonths);\r\n    function splitStake(uint256 id, uint96 amount) external payable returns (uint32 newNftId0, uint32 newNftId1);\r\n    function claimAchievement(address staker, uint256 nftId) external returns (uint32 newNftId);\r\n    function stakeCreateCost() external view returns (uint256);\r\n    function approve(address owner, address _operator, uint256 nftId) external;\r\n}\r\n\r\n// File: EverRise-v3/Abstract/virtualToken.sol\r\n\r\nabstract contract virtualToken is Ownable, IERC20, IERC20Metadata {\r\n    InftEverRise public veEverRise;\r\n\r\n    uint8 public constant decimals = 18;\r\n    string public name;\r\n    string public symbol;\r\n  \r\n    constructor(string memory _name, string memory _symbol ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        veEverRise = InftEverRise(owner);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external returns (bool) {\r\n        \r\n        if (_msgSender() != owner) { \r\n            notTransferrable();\r\n        }\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address, uint256) pure external returns (bool) {\r\n        notTransferrable();\r\n    }\r\n    function allowance(address, address) pure external returns (uint256) {\r\n        return 0;\r\n    }\r\n    function approve(address, uint256) pure external returns (bool) {\r\n        notTransferrable();\r\n    }\r\n    function increaseAllowance(address, uint256) pure external returns (bool) {\r\n        notTransferrable();\r\n    }\r\n    function decreaseAllowance(address, uint256) pure external returns (bool) {\r\n        notTransferrable();\r\n    }\r\n    function transferFromWithPermit(address, address, uint256, uint256, uint8, bytes32, bytes32) pure external returns (bool) {\r\n        notTransferrable();\r\n    }\r\n\r\n    function notTransferrable() pure private {\r\n        revert NotTransferrable();\r\n    }\r\n}\r\n// File: EverRise-v3/claimRISE.sol\r\n\r\n// Copyright (c) 2022 EverRise Pte Ltd. All rights reserved.\r\n// EverRise licenses this file to you under the MIT license.\r\n/*\r\n Virtual token that allows unclaimed rewards from EverRise Staking NFTs\r\n and its Vote Escrowed (ve) EverRise to display in wallet balances.\r\n                                    ________                              _______   __\r\n                                   /        |                            /       \\ /  |\r\n                                   $$$$$$$$/__     __  ______    ______  $$$$$$$  |$$/   _______   ______  v3.14159265\r\n                                   $$ |__  /  \\   /  |/      \\  /      \\ $$ |__$$ |/  | /       | /      \\\r\n      ______      _____            $$    | $$  \\ /$$//$$$$$$  |/$$$$$$  |$$    $$< $$ |/$$$$$$$/ /$$$$$$  |\r\n_________  /_____ ___(_)______ ___ $$$$$/   $$  /$$/ $$    $$ |$$ |  $$/ $$$$$$$  |$$ |$$      \\ $$    $$ |\r\n_  ___/_  /_  __ `/_  /__  __ `__ \\$$ |_____ $$ $$/  $$$$$$$$/ $$ |      $$ |  $$ |$$ | $$$$$$  |$$$$$$$$/\r\n/ /__ _  / / /_/ /_  / _  / / / / /$$       | $$$/   $$       |$$ |      $$ |  $$ |$$ |/     $$/ $$       |\r\n\\___/ /_/  \\__,_/ /_/  /_/ /_/ /_/ $$$$$$$$/   $/     $$$$$$$/ $$/       $$/   $$/ $$/ $$$$$$$/   $$$$$$$/\r\n\r\nLearn more about EverRise and the EverRise Ecosystem of dApps and\r\nhow our utilities and partners can help protect your investors\r\nand help your project grow: https://www.everrise.com\r\n*/\r\n\r\ncontract claimRise is virtualToken(\"EverRise Rewards\", \"claimRISE\") {\r\n    function totalSupply() override external view returns (uint256) {\r\n        return veEverRise.totalRewardsUnclaimed();\r\n    }\r\n\r\n    function balanceOf(address account) override external view returns (uint256) {\r\n        if (account == owner) return 0;\r\n        \r\n        return veEverRise.unclaimedRewardsBalance(account);\r\n    }\r\n}\r\n// File: EverRise-v3/veRISE.sol\r\n\r\n// Copyright (c) 2022 EverRise Pte Ltd. All rights reserved.\r\n// EverRise licenses this file to you under the MIT license.\r\n/*\r\n Virtual token that allows the Vote Escrowed (ve) EverRise weigthed\r\n governance tokens from EverRise Staking NFTs to display in\r\n wallet balances.\r\n \r\n             ________                              _______   __\r\n            /        |                            /       \\ /  |\r\n            $$$$$$$$/__     __  ______    ______  $$$$$$$  |$$/   _______   ______  v3.14159265\r\n            $$ |__  /  \\   /  |/      \\  /      \\ $$ |__$$ |/  | /       | /      \\\r\n            $$    | $$  \\ /$$//$$$$$$  |/$$$$$$  |$$    $$< $$ |/$$$$$$$/ /$$$$$$  |\r\n__   _____  $$$$$/   $$  /$$/ $$    $$ |$$ |  $$/ $$$$$$$  |$$ |$$      \\ $$    $$ |\r\n\\ \\ / / _ \\ $$ |_____ $$ $$/  $$$$$$$$/ $$ |      $$ |  $$ |$$ | $$$$$$  |$$$$$$$$/\r\n \\ V /  __/ $$       | $$$/   $$       |$$ |      $$ |  $$ |$$ |/     $$/ $$       |\r\n  \\_/ \\___| $$$$$$$$/   $/     $$$$$$$/ $$/       $$/   $$/ $$/ $$$$$$$/   $$$$$$$/\r\n\r\nLearn more about EverRise and the EverRise Ecosystem of dApps and\r\nhow our utilities and partners can help protect your investors\r\nand help your project grow: https://www.everrise.com\r\n*/\r\n\r\ncontract veRise is virtualToken(\"Vote-escrowed EverRise\", \"veRISE\") {\r\n    function totalSupply() override external view returns (uint256) {\r\n        return veEverRise.totalAmountVoteEscrowed();\r\n    }\r\n\r\n    function balanceOf(address account) override external view returns (uint256) {\r\n        if (account == owner) return 0;\r\n\r\n        return veEverRise.voteEscrowedBalance(account);\r\n    }\r\n}\r\n\r\n// File: EverRise-v3/Interfaces/IEverRoyaltySplitter.sol\r\n\r\ninterface IEverRoyaltySplitter {\r\n    event RoyaltiesSplit(uint256 value);\r\n    event SplitUpdated(uint256 previous, uint256 current);\r\n    event UniswapV2RouterSet(address indexed previous, address indexed current);\r\n    event EverRiseEcosystemSet(address indexed previous, address indexed current);\r\n    event EverRiseTokenSet(address indexed previous, address indexed current);\r\n    event StableCoinSet(address indexed previous, address indexed current);\r\n\r\n    function distribute() external;\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external view returns(bytes4);\r\n}\r\n\r\ninterface IERC721Metadata /* is ERC721 */ {\r\n    function name() external view returns (string memory _name);\r\n    function symbol() external view returns (string memory _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Enumerable /* is ERC721 */ {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n// File: EverRise-v3/Interfaces/IEverRiseRenderer.sol\r\n\r\ninterface IOpenSeaCollectible {\r\n    function contractURI() external view returns (string memory);\r\n}\r\n\r\ninterface IEverRiseRenderer is IOpenSeaCollectible {\r\n    event SetEverRiseNftStakes(address indexed addressStakes);\r\n    event SetEverRiseRendererGlyph(address indexed addressGlyphs);\r\n    \r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n\r\n    function everRiseNftStakes() external view returns (InftEverRise);\r\n    function setEverRiseNftStakes(address contractAddress) external;\r\n}\r\n\r\n// File: EverRise-v3/Interfaces/IERC165-SupportsInterface.sol\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: EverRise-v3/Abstract/ERC165-SupportsInterface.sol\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: EverRise-v3/Interfaces/IERC2981-Royalty.sol\r\n\r\ninterface IERC2981 is IERC165 {\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (\r\n        address receiver,\r\n        uint256 royaltyAmount\r\n    );\r\n}\r\n\r\n// File: EverRise-v3/nftEverRise.sol\r\n\r\n// Copyright (c) 2022 EverRise Pte Ltd. All rights reserved.\r\n// EverRise licenses this file to you under the MIT license.\r\n/*\r\n EverRise Staking NFTs are Vote Escrowed (ve) EverRise weigthed governance tokens\r\n which generate rewards with a market driven yield curve, based of the\r\n transaction volume of EverRise trades and veEverRise sales.\r\n\r\n On sales of veEverRise Staking NFTs a 10% royalty fee is collected\r\n * 6% for token Buyback from the market, \r\n     with bought back tokens directly distributed as ve-staking rewards\r\n * 4% for Business Development (Development, Sustainability and Marketing)\r\n\r\n                           ________                              _______   __\r\n                          /        |                            /       \\ /  |\r\n                          $$$$$$$$/__     __  ______    ______  $$$$$$$  |$$/   _______   ______  v3.14159265\r\n                          $$ |__  /  \\   /  |/      \\  /      \\ $$ |__$$ |/  | /       | /      \\\r\n                          $$    | $$  \\ /$$//$$$$$$  |/$$$$$$  |$$    $$< $$ |/$$$$$$$/ /$$$$$$  |\r\n _______ _______ _______  $$$$$/   $$  /$$/ $$    $$ |$$ |  $$/ $$$$$$$  |$$ |$$      \\ $$    $$ |\r\n|    |  |    ___|_     _| $$ |_____ $$ $$/  $$$$$$$$/ $$ |      $$ |  $$ |$$ | $$$$$$  |$$$$$$$$/\r\n|       |    ___| |   |   $$       | $$$/   $$       |$$ |      $$ |  $$ |$$ |/     $$/ $$       |\r\n|__|____|___|     |___|   $$$$$$$$/   $/     $$$$$$$/ $$/       $$/   $$/ $$/ $$$$$$$/   $$$$$$$/\r\n\r\nLearn more about EverRise and the EverRise Ecosystem of dApps and\r\nhow our utilities and partners can help protect your investors\r\nand help your project grow: https://www.everrise.com\r\n*/\r\n\r\ncontract EverRiseTokenOwned is Ownable {\r\n    IEverRise public everRiseToken;\r\n\r\n    event EverRiseTokenSet(address indexed tokenAddress);\r\n    \r\n    function _onlyEverRiseToken(address senderAddress) private view {\r\n        if (address(everRiseToken) == address(0)) revert NotSetup();\r\n        if (address(everRiseToken) != senderAddress) revert CallerNotApproved();\r\n    }\r\n\r\n    modifier onlyEverRiseToken() {\r\n        _onlyEverRiseToken(_msgSender());\r\n        _;\r\n    }\r\n}\r\n\r\nstruct IndividualAllowance {\r\n    address operator;\r\n    uint48 timestamp;\r\n    uint32 nftCheck;\r\n}\r\n\r\nabstract contract nftEverRiseConfigurable is EverRiseTokenOwned, InftEverRise, ERC165, IERC2981, IERC721Metadata, IOpenSeaCollectible {\r\n    event AddRewardCreator(address indexed _address);\r\n    event RemoveRewardCreator(address indexed _address);\r\n    event SetAchievementNfts(address indexed _address);\r\n    event RoyaltyFeeUpdated(uint256 newValue);\r\n    event RoyaltyAddressUpdated(address indexed contractAddress);\r\n    event RendererAddressUpdated(address indexed contractAddress);\r\n    event StakeCreateCostUpdated(uint256 newValue);\r\n    event StakingParametersSet(uint256 withdrawPct, uint256 firstHalfPenality, uint256 secondHalfPenality, uint256 maxStakeMonths, bool mergeEnabled);\r\n \r\n    IEverRiseRenderer public renderer;\r\n    IEverRoyaltySplitter public royaltySplitter;\r\n    uint256 public nftRoyaltySplit = 10;\r\n    address public currentAchievementNfts;\r\n    uint8 public maxEarlyWithdrawalPercent = 60;\r\n    uint8 public firstHalfPenality = 25;\r\n    uint8 public secondHalfPenality = 10;\r\n    uint8 public maxStakeMonths = 36;\r\n    uint256 public stakeCreateCost = 1 * 10**18 / (10**2);\r\n    uint256 public mergeEnabled = _FALSE;\r\n\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n    uint256 constant _FALSE = 1;\r\n    uint256 constant _TRUE = 2;\r\n\r\n    mapping (address => bool) internal _canCreateRewards;\r\n\r\n    function setEverRiseToken(address tokenAddress) external onlyOwner {\r\n        if (tokenAddress == address(0)) revert NotZeroAddress();\r\n\r\n        _removeAddressToCreate(address(everRiseToken));\r\n        addAddressToCreate(tokenAddress);\r\n\r\n        everRiseToken = IEverRise(tokenAddress);\r\n\r\n        emit EverRiseTokenSet(tokenAddress);\r\n    }\r\n\r\n    function setStakeCreateCost(uint256 _stakeCreateCost, uint256 numOfDecimals)\r\n        external onlyOwner\r\n    {\r\n        // Catch typos, if decimals are pre-added\r\n        if (_stakeCreateCost > 1_000) revert AmountOutOfRange();\r\n\r\n        stakeCreateCost = _stakeCreateCost * (10**18) / (10**numOfDecimals);\r\n        emit StakeCreateCostUpdated(_stakeCreateCost);\r\n    }\r\n    \r\n    function setAchievementNfts(address contractAddress) external onlyOwner() {\r\n        if (contractAddress == address(0)) revert NotZeroAddress();\r\n\r\n        currentAchievementNfts = contractAddress;\r\n\r\n        emit SetAchievementNfts(contractAddress);\r\n    }\r\n\r\n    function addAddressToCreate(address account) public onlyOwner {\r\n        if (account == address(0)) revert NotZeroAddress();\r\n\r\n        _canCreateRewards[account] = true;\r\n        emit AddRewardCreator(account);\r\n    }\r\n\r\n    function removeAddressToCreate(address account) external onlyOwner {\r\n        if (account == address(0)) revert NotZeroAddress();\r\n\r\n        _removeAddressToCreate(account);\r\n    }\r\n\r\n    function _removeAddressToCreate(address account) private {\r\n        if (account != address(0)){\r\n            _canCreateRewards[account] = false;\r\n            emit RemoveRewardCreator(account);\r\n        }\r\n    }\r\n    \r\n    function setNftRoyaltyFeePercent(uint256 royaltySplitRate) external onlyOwner {\r\n        if (royaltySplitRate > 10) revert AmountOutOfRange();\r\n        nftRoyaltySplit = royaltySplitRate;\r\n\r\n        emit RoyaltyFeeUpdated(royaltySplitRate);\r\n    }\r\n\r\n    function setRoyaltyAddress(address newAddress) external onlyOwner {\r\n        if (newAddress == address(0)) revert NotZeroAddress();\r\n\r\n        royaltySplitter = IEverRoyaltySplitter(newAddress);\r\n        emit RoyaltyAddressUpdated(newAddress);\r\n    }\r\n\r\n    function setRendererAddress(address newAddress) external onlyOwner {\r\n        if (newAddress == address(0)) revert NotZeroAddress();\r\n\r\n        renderer = IEverRiseRenderer(newAddress);\r\n        emit RendererAddressUpdated(newAddress);\r\n    }\r\n\r\n    function setStakingParameters(uint8 _withdrawPercent, uint8 _firstHalfPenality, uint8 _secondHalfPenality, uint8 _maxStakeMonths, bool _mergEnabled)\r\n        external onlyOwner\r\n    {\r\n        if (_maxStakeMonths == 0 || _maxStakeMonths > 120) {\r\n            revert AmountOutOfRange();\r\n        }\r\n\r\n        maxEarlyWithdrawalPercent = _withdrawPercent;\r\n        firstHalfPenality = _firstHalfPenality;\r\n        secondHalfPenality = _secondHalfPenality;\r\n        maxStakeMonths = _maxStakeMonths;\r\n        mergeEnabled = _mergEnabled ? _TRUE : _FALSE;\r\n\r\n        emit StakingParametersSet(_withdrawPercent, _firstHalfPenality, _secondHalfPenality, _maxStakeMonths, _mergEnabled);\r\n    }\r\n}\r\n\r\ncontract nftEverRise is nftEverRiseConfigurable {\r\n    string public constant name = \"EverRise NFT Stakes\";\r\n    string public constant symbol = \"nftRISE\";\r\n\r\n    uint256 public constant month = 30 days;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint8 public constant decimals = 0;\r\n    uint256 private constant totalStakeTokensSupply = 120_000_000 * 10**6 * 10**18;\r\n    uint8 constant _FALSE8 = 1;\r\n    uint8 constant _TRUE8 = 2;\r\n    \r\n    event RewardsWithdrawn(address indexed from, uint256 amount);\r\n    event ExcludedFromRewards(address indexed _address);\r\n    event IncludedToRewards(address indexed _address);\r\n\r\n    mapping (address => bool) private _isExcludedFromReward;\r\n    mapping (address => uint256) private _rOwned;\r\n    mapping (address => uint256) private _tOwned;\r\n    mapping (address => uint256) private _withdrawnRewards;\r\n    mapping (uint256 => IndividualAllowance) private _individualApproval;\r\n\r\n    address[] private _excludedList;\r\n\r\n    uint256 private _rTotal = (MAX - (MAX % totalStakeTokensSupply));\r\n\r\n    StakingDetails[] private _allStakeDetails;\r\n    mapping (address => uint256[]) private _individualStakes;\r\n    mapping (uint256 => uint256) private _stakeById;\r\n    uint256[] private _freeStakes;\r\n    mapping (address => uint256) public voteEscrowedBalance;\r\n    uint256 public totalAmountEscrowed;\r\n    uint256 public totalAmountVoteEscrowed;\r\n    uint256 public totalRewardsDistributed;\r\n    \r\n    uint32 private nextNftId = 1;\r\n    veRise public immutable veRiseToken;\r\n    claimRise public immutable claimRiseToken;\r\n\r\n    constructor() {\r\n        veRiseToken = new veRise();\r\n        claimRiseToken = new claimRise();\r\n\r\n        _rOwned[address(this)] = _rTotal;\r\n        \r\n        excludeFromReward(address(this));\r\n\r\n        _allStakeDetails.push(StakingDetails({\r\n            initialTokenAmount: 0,\r\n            withdrawnAmount: 0,\r\n            depositTime: 0,\r\n            numOfMonths: 1,\r\n            achievementClaimed: 0,\r\n            stakerAddress: address(0),\r\n            nftId: 0,\r\n            lookupIndex: 0,\r\n            stakerIndex: 0,\r\n            isActive: _FALSE8\r\n        }));\r\n    }\r\n \r\n    function _walletLock(address fromAddress) private view {\r\n        if (everRiseToken.isWalletLocked(fromAddress)) revert WalletLocked();\r\n    }\r\n\r\n    modifier walletLock(address fromAddress) {\r\n        _walletLock(fromAddress);\r\n        _;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _allStakeDetails.length - _freeStakes.length - 1;\r\n    }\r\n\r\n    function _onlyRewardCreator(address senderAddress) private view {\r\n        if (!_canCreateRewards[senderAddress]) revert CallerNotApproved();\r\n    }\r\n\r\n    modifier onlyRewardCreator() {\r\n        _onlyRewardCreator(_msgSender());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC165, IERC165) returns (bool) {\r\n        return \r\n            interfaceId == type(IERC2981).interfaceId ||\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function contractURI() external view returns (string memory) {\r\n        return renderer.contractURI();\r\n    }\r\n\r\n    function tokenURI(uint256 nftId) external view returns (string memory) {\r\n        return renderer.tokenURI(nftId);\r\n    }\r\n    \r\n    function createRewards(uint256 amount) external onlyRewardCreator() {\r\n        address sender = _msgSender();\r\n        if (_isExcludedFromReward[sender]) revert NotAllowedToDeliverRewards();\r\n        \r\n        _transferFromExcluded(address(this), sender, amount);\r\n\r\n        totalRewardsDistributed += amount;\r\n        \r\n        uint256 rAmount = amount * _getRate();\r\n        _rOwned[sender] -= rAmount;\r\n        _rTotal -= rAmount;\r\n\r\n        claimRiseToken.transferFrom(address(0), address(this), amount);\r\n    }\r\n\r\n    function voteEscrowedAndRewards(address account) private view returns (uint256) {\r\n        if (account == address(0)) revert NotZeroAddress();\r\n\r\n        if (_isExcludedFromReward[account]) return _tOwned[account];\r\n        return tokenFromRewards(_rOwned[account]);\r\n    }\r\n\r\n    function totalRewardsUnclaimed() external view returns (uint256) {\r\n        return everRiseToken.balanceOf(address(this));\r\n    }\r\n\r\n    function isExcludedFromReward(address account) external view returns (bool) {\r\n        if (account == address(0)) revert NotZeroAddress();\r\n\r\n        return _isExcludedFromReward[account];\r\n    }\r\n    \r\n    function rewardsFromToken(uint256 tAmount) external view returns(uint256) {\r\n        if (tAmount > totalStakeTokensSupply) revert AmountOutOfRange();\r\n\r\n        return tAmount * _getRate();\r\n    }\r\n\r\n    function tokenFromRewards(uint256 rAmount) public view returns(uint256) {\r\n        if (rAmount > _rTotal) revert AmountOutOfRange();\r\n\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount / currentRate;\r\n    }\r\n    \r\n    function excludeFromReward(address account) public onlyOwner() {\r\n        if (account == address(0)) revert NotZeroAddress();\r\n        if (_isExcludedFromReward[account]) revert InvalidAddress();\r\n\r\n        if(_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromRewards(_rOwned[account]);\r\n        }\r\n        _isExcludedFromReward[account] = true;\r\n        _excludedList.push(account);\r\n\r\n        emit ExcludedFromRewards(account);\r\n    }\r\n\r\n    function includeInReward(address account) external onlyOwner() {\r\n        if (account == address(0)) revert NotZeroAddress();\r\n        if (!_isExcludedFromReward[account]) revert InvalidAddress();\r\n          \r\n        uint256 length = _excludedList.length;\r\n        for (uint256 i = 0; i < length;) {\r\n            if (_excludedList[i] == account) {\r\n                _excludedList[i] = _excludedList[_excludedList.length - 1];\r\n                _tOwned[account] = 0;\r\n                _isExcludedFromReward[account] = false;\r\n                _excludedList.pop();\r\n                break;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        emit IncludedToRewards(account);\r\n    }\r\n    \r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bool emitEvent\r\n    ) private {\r\n        if (sender == address(0)) revert NotZeroAddress();\r\n        if (recipient == address(0)) revert NotZeroAddress();\r\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\r\n        // One of the addresses has to be this contract\r\n        if (sender != address(this) && recipient != address(this)) revert InvalidAddress();\r\n\r\n        if (_isExcludedFromReward[sender]) {\r\n            if (!_isExcludedFromReward[recipient]) {\r\n                _transferFromExcluded(sender, recipient, amount);\r\n            } else {\r\n                _transferBothExcluded(sender, recipient, amount);\r\n            }\r\n        } else if (_isExcludedFromReward[recipient]) {\r\n            _transferToExcluded(sender, recipient, amount);\r\n        } else {\r\n            _transferStandard(sender, recipient, amount);\r\n        }\r\n\r\n        if (emitEvent) {\r\n            if (sender == address(this)) {\r\n                veRiseToken.transferFrom(address(0), recipient, amount);\r\n            }\r\n            else if (recipient == address(this)) {\r\n                veRiseToken.transferFrom(sender, address(0), amount);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 rAmount = tAmount * _getRate();\r\n        _rOwned[sender] -= rAmount;\r\n        _rOwned[recipient] += rAmount;\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 rAmount = tAmount * _getRate();\r\n\t    _rOwned[sender] -= rAmount;\r\n        _tOwned[recipient] += tAmount;\r\n        _rOwned[recipient] += rAmount;           \r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 rAmount = tAmount * _getRate();\r\n    \t_tOwned[sender] -= tAmount;\r\n        _rOwned[sender] -= rAmount;\r\n        _rOwned[recipient] += rAmount;   \r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        uint256 rAmount = tAmount * _getRate();\r\n    \t_tOwned[sender] -= tAmount;\r\n        _rOwned[sender] -= rAmount;\r\n        _tOwned[recipient] += tAmount;\r\n        _rOwned[recipient] += rAmount;        \r\n    }\r\n    \r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = totalStakeTokensSupply;      \r\n        uint256 length = _excludedList.length;\r\n\r\n        for (uint256 i = 0; i < length;) {\r\n            if (_rOwned[_excludedList[i]] > rSupply || _tOwned[_excludedList[i]] > tSupply) {\r\n                return (_rTotal, totalStakeTokensSupply);\r\n            }\r\n            rSupply -= _rOwned[_excludedList[i]];\r\n            tSupply -= _tOwned[_excludedList[i]];\r\n            \r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        if (rSupply < (_rTotal / totalStakeTokensSupply)) return (_rTotal, totalStakeTokensSupply);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function getStakeIndex(uint256 nftId) private view returns (uint256 lookupIndex) {\r\n        if (nftId == 0) revert DoesNotExist();\r\n        lookupIndex = _stakeById[nftId];\r\n        if (lookupIndex >= _allStakeDetails.length) revert DoesNotExist();\r\n        if (_allStakeDetails[lookupIndex].isActive != _TRUE8) revert DoesNotExist();\r\n    }\r\n\r\n    function ownerOf(uint256 nftId) public view returns (address) {\r\n        uint256 lookupIndex = getStakeIndex(nftId);\r\n        StakingDetails storage stakeDetails = _allStakeDetails[lookupIndex];\r\n        \r\n        return stakeDetails.stakerAddress;\r\n    }\r\n\r\n    function _getStake(uint256 nftId, address staker) private view returns (uint256 lookupIndex, StakingDetails storage stakeDetails) {\r\n        lookupIndex = getStakeIndex(nftId);\r\n        stakeDetails = _allStakeDetails[lookupIndex];\r\n\r\n        if (stakeDetails.stakerAddress != staker) revert NotStakerAddress();\r\n\r\n        assert(nftId == stakeDetails.nftId);\r\n    }\r\n\r\n    function getStake(uint256 nftId, address staker) external view returns (StakingDetails memory stakeDetails) {\r\n        (, stakeDetails) = _getStake(nftId, staker);\r\n    }\r\n\r\n    function getNftData(uint256 nftId) external view returns (StakingDetails memory) {\r\n        uint256 lookupIndex = getStakeIndex(nftId);\r\n        return _allStakeDetails[lookupIndex];\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _individualStakes[account].length;\r\n    }\r\n    \r\n    function unclaimedRewardsBalance(address account) public view returns (uint256) {\r\n        return voteEscrowedAndRewards(account) - voteEscrowedBalance[account];\r\n    }\r\n\r\n    function getTotalRewards(address account) external view returns (uint256) {\r\n        return unclaimedRewardsBalance(account) + _withdrawnRewards[account];\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint32) {\r\n        uint256[] storage stakes = _individualStakes[_owner];\r\n        if (index > stakes.length) revert AmountOutOfRange();\r\n        uint256 lookupIndex = stakes[index];\r\n        return _allStakeDetails[lookupIndex].nftId;\r\n    }\r\n    \r\n    function enterStaking(address staker, uint96 amount, uint8 numOfMonths)\r\n        external onlyEverRiseToken returns (uint32 nftId) {\r\n        // Stake time period must be in valid range\r\n        if (numOfMonths == 0 || \r\n            numOfMonths > maxStakeMonths || \r\n            (numOfMonths > 12 && (numOfMonths % 12) > 0)\r\n        ) {\r\n            revert AmountOutOfRange();\r\n        }\r\n\r\n        roundingCheck(amount, false);\r\n\r\n        nftId = _createStake(staker, amount, 0, numOfMonths, uint48(block.timestamp), false);\r\n     }\r\n \r\n    // Rewards withdrawal doesn't need token lock check as is adding to locked wallet not removing\r\n    function withdrawRewards() external {\r\n        address staker = _msgSender();\r\n        uint256 rewards = unclaimedRewardsBalance(staker);\r\n\r\n        if (rewards == 0) revert NoRewardsToClaim();\r\n\r\n        // Something to withdraw\r\n        _withdrawnRewards[staker] += rewards;\r\n        // Remove the veTokens for the rewards\r\n        _transfer(staker, address(this), rewards, false);\r\n        // Emit transfer\r\n        claimRiseToken.transferFrom(staker, address(0), rewards);\r\n        // Send RISE rewards\r\n        require(everRiseToken.transfer(staker, rewards));\r\n\r\n        emit RewardsWithdrawn(staker, rewards);\r\n    }\r\n\r\n    function checkNotLocked(uint256 depositTime, uint256 numOfMonths) private view {\r\n        if (depositTime + (numOfMonths * month) > block.timestamp) {\r\n            revert StakeStillLocked();\r\n        }\r\n    }\r\n\r\n    function leaveStaking(address staker, uint256 nftId, bool overrideNotClaimed) external onlyEverRiseToken returns (uint96 amount) {\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, staker);\r\n\r\n        checkNotLocked(stakeDetails.depositTime, stakeDetails.numOfMonths);\r\n\r\n        if (!overrideNotClaimed && stakeDetails.achievementClaimed != _TRUE8) {\r\n            revert AchievementNotClaimed();\r\n        }\r\n        \r\n        amount = _removeStake(staker, nftId, lookupIndex, stakeDetails);\r\n    }\r\n\r\n    function withdraw(address staker, uint256 nftId, uint96 amount, bool overrideNotClaimed) external onlyEverRiseToken returns (uint32 newNftId) {\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, staker);\r\n\r\n        checkNotLocked(stakeDetails.depositTime, stakeDetails.numOfMonths);\r\n\r\n        if (!overrideNotClaimed && stakeDetails.achievementClaimed != _TRUE8) {\r\n            revert AchievementNotClaimed();\r\n        }\r\n\r\n        uint96 remaining = stakeDetails.initialTokenAmount - stakeDetails.withdrawnAmount;\r\n        if (amount > remaining) revert AmountLargerThanAvailable();\r\n        roundingCheck(amount, true);\r\n\r\n        bool reissueNft = false;\r\n        if (amount > 0) {\r\n            decreaseVeAmount(staker, amount, stakeDetails.numOfMonths, true);\r\n            // Out of period, inital now becomes remaining\r\n            remaining -= amount;\r\n            reissueNft = true;\r\n        }\r\n        if (stakeDetails.initialTokenAmount != remaining) {\r\n            // Out of period, zero out the withdrawal amount\r\n            stakeDetails.initialTokenAmount = remaining;\r\n            stakeDetails.withdrawnAmount = 0;\r\n            reissueNft = true;\r\n        }\r\n\r\n        if (reissueNft) {\r\n            if (remaining == 0) {\r\n                _burnStake(staker, nftId, lookupIndex, stakeDetails);\r\n                newNftId = 0;\r\n            } else {\r\n                newNftId = _reissueStakeNftId(nftId, lookupIndex);\r\n                stakeDetails.nftId = newNftId;\r\n            }\r\n        } else {\r\n            // Nothing changed, keep the same nft\r\n            newNftId = uint32(nftId);\r\n        }\r\n    }\r\n\r\n    function claimAchievement(address staker, uint256 nftId) external returns (uint32 newNftId) {\r\n        if (_msgSender() != currentAchievementNfts) revert CallerNotApproved();\r\n\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, staker);\r\n\r\n        checkNotLocked(stakeDetails.depositTime, stakeDetails.numOfMonths);\r\n\r\n        // Can only claim once\r\n        if (stakeDetails.achievementClaimed == _TRUE8) {\r\n            revert AchievementAlreadyClaimed();\r\n        }\r\n\r\n        // Reset broken status if unlocked\r\n        if (stakeDetails.withdrawnAmount > 0) {\r\n            stakeDetails.initialTokenAmount -= stakeDetails.withdrawnAmount;\r\n            stakeDetails.withdrawnAmount = 0;\r\n        }\r\n\r\n        // Mark claimed\r\n        stakeDetails.achievementClaimed = _TRUE8;\r\n        // Get new id\r\n        newNftId = _reissueStakeNftId(nftId, lookupIndex);\r\n        // Set new id\r\n        stakeDetails.nftId = newNftId;\r\n        // Emit burn and mint events\r\n        _reissueStakeNft(staker, nftId, newNftId);\r\n    }\r\n\r\n    function getTime() external view returns (uint256) {\r\n        // Used to workout UI time drift from blockchain\r\n        return block.timestamp;\r\n    }\r\n\r\n    function checkLocked(uint48 depositTime, uint8 numOfMonths) private view {\r\n        if (depositTime + (numOfMonths * month) < block.timestamp) {\r\n            revert StakeUnlocked();\r\n        }\r\n    }\r\n\r\n    function earlyWithdraw(address staker, uint256 nftId, uint96 amount) external onlyEverRiseToken returns (uint32 newNftId, uint96 penaltyAmount) {\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, staker);\r\n        \r\n        checkLocked(stakeDetails.depositTime, stakeDetails.numOfMonths);\r\n\r\n        uint256 remaingEarlyWithdrawal = (stakeDetails.initialTokenAmount * maxEarlyWithdrawalPercent) / 100 - stakeDetails.withdrawnAmount;\r\n\r\n        if (amount > remaingEarlyWithdrawal) {\r\n            revert AmountLargerThanAvailable();\r\n        }\r\n\r\n        roundingCheck(amount, false);\r\n\r\n        decreaseVeAmount(staker, amount, stakeDetails.numOfMonths, true);\r\n        \r\n        penaltyAmount = calculateTax(amount, stakeDetails.depositTime, stakeDetails.numOfMonths); // calculate early penalty tax\r\n\r\n        stakeDetails.withdrawnAmount += uint96(amount); // update the withdrawl amount\r\n\r\n        newNftId = _reissueStakeNftId(nftId, lookupIndex);\r\n        stakeDetails.nftId = newNftId;\r\n    }\r\n\r\n    function increaseStake(address staker, uint256 nftId, uint96 amount)\r\n        external onlyEverRiseToken returns (uint32 newNftId, uint96 original, uint8 numOfMonths)\r\n    {\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, staker);\r\n\r\n        checkLocked(stakeDetails.depositTime, stakeDetails.numOfMonths);\r\n\r\n        roundingCheck(amount, false);\r\n        numOfMonths = stakeDetails.numOfMonths;\r\n\r\n        increaseVeAmount(staker, amount, numOfMonths, true);\r\n        // Get current amount for main contract change event\r\n        original = stakeDetails.initialTokenAmount - stakeDetails.withdrawnAmount;\r\n        // Take amount off the withdrawnAmount, \"repairing\" the stake\r\n        if (amount > stakeDetails.withdrawnAmount) {\r\n            // Take withdrawn off amount\r\n            amount -= stakeDetails.withdrawnAmount;\r\n            // Clear withdrawn\r\n            stakeDetails.withdrawnAmount = 0;\r\n            // Add remaining to initial\r\n            stakeDetails.initialTokenAmount += amount;\r\n        } else {\r\n            // Just reduce amount withdrawn\r\n            stakeDetails.withdrawnAmount -= amount;\r\n        }\r\n\r\n        // Relock\r\n        stakeDetails.depositTime = uint48(block.timestamp);\r\n\r\n        newNftId =  _reissueStakeNftId(nftId, lookupIndex);\r\n        stakeDetails.nftId = newNftId;\r\n        _reissueStakeNft(staker, nftId, newNftId);\r\n    }\r\n    \r\n    function extendStake(uint256 nftId, uint8 numOfMonths) external walletLock(_msgSender()) returns (uint32 newNftId) {\r\n        address staker = _msgSender();\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, staker);\r\n        \r\n        checkLocked(stakeDetails.depositTime, stakeDetails.numOfMonths);\r\n\r\n        if (stakeDetails.numOfMonths >= numOfMonths) revert StakeCanOnlyBeExtended();\r\n\r\n        // Stake time period must be in valid range\r\n        if (numOfMonths > maxStakeMonths || \r\n            (numOfMonths > 12 && (numOfMonths % 12) > 0)\r\n        ) {\r\n            revert AmountOutOfRange();\r\n        }\r\n\r\n        uint8 extraMonths = numOfMonths - stakeDetails.numOfMonths;\r\n        uint96 amount = (stakeDetails.initialTokenAmount - stakeDetails.withdrawnAmount);\r\n        \r\n        increaseVeAmount(staker, amount, extraMonths, true);\r\n        \r\n        stakeDetails.numOfMonths = numOfMonths;\r\n        // Relock\r\n        stakeDetails.depositTime = uint48(block.timestamp);\r\n\r\n        newNftId =  _reissueStakeNftId(nftId, lookupIndex);\r\n        stakeDetails.nftId = newNftId;\r\n        _reissueStakeNft(staker, nftId, newNftId);\r\n    }\r\n\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        if (value > type(uint96).max) revert Overflow();\r\n        return uint96(value);\r\n    }\r\n\r\n    function splitStake(uint256 nftId, uint96 amount) external payable walletLock(_msgSender()) returns (uint32 newNftId0, uint32 newNftId1) {\r\n        address staker = _msgSender();\r\n        \r\n        if (msg.value < stakeCreateCost) revert NotEnoughToCoverStakeFee();\r\n        roundingCheck(amount, false);\r\n\r\n        // Transfer everything, easier than transferring extras later\r\n        payable(address(everRiseToken)).transfer(address(this).balance);\r\n\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, staker);\r\n\r\n        uint256 remainingAmount = stakeDetails.initialTokenAmount - stakeDetails.withdrawnAmount;\r\n\r\n        if (amount >= remainingAmount) revert AmountLargerThanAvailable();\r\n  \r\n        newNftId0 = _reissueStakeNftId(nftId, lookupIndex);\r\n        // Update the existing stake\r\n        uint96 transferredWithdrawnAmount = toUint96(stakeDetails.withdrawnAmount * uint256(amount) / stakeDetails.initialTokenAmount);\r\n\r\n        stakeDetails.initialTokenAmount -= amount;\r\n        stakeDetails.withdrawnAmount -= transferredWithdrawnAmount;\r\n        stakeDetails.nftId = newNftId0;\r\n\r\n        // Create new stake\r\n        newNftId1 = _addSplitStake(\r\n            staker, \r\n            amount, // initialTokenAmount\r\n            transferredWithdrawnAmount, // withdrawnAmount\r\n            stakeDetails.depositTime,        // depositTime\r\n            stakeDetails.numOfMonths,\r\n            stakeDetails.achievementClaimed == _TRUE8 // achievementClaimed\r\n        );\r\n\r\n        _reissueStakeNft(staker, nftId, newNftId0);\r\n        emit Transfer(address(0), staker, newNftId1);\r\n    }\r\n\r\n    function roundingCheck(uint96 amount, bool allowZero) private pure {\r\n        // Round to nearest unit\r\n        uint96 roundedAmount = amount - (amount % uint96(10**18));\r\n\r\n        if (amount != roundedAmount || (!allowZero && amount == 0)) revert AmountMustBeAnInteger();\r\n    }\r\n\r\n    function mergeStakes(uint256 nftId0, uint256 nftId1, bool overrideStatuses)\r\n        external walletLock(_msgSender())\r\n        returns (uint32 newNftId)\r\n    {\r\n        if (mergeEnabled != _TRUE) revert MergeNotEnabled();\r\n        \r\n        address staker = _msgSender();\r\n        (uint256 lookupIndex0, StakingDetails storage stakeDetails0) = _getStake(nftId0, staker);\r\n        (uint256 lookupIndex1, StakingDetails storage stakeDetails1) = _getStake(nftId1, staker);\r\n\r\n        bool unlocked0 = stakeDetails0.depositTime + (stakeDetails0.numOfMonths * month) < block.timestamp;\r\n        bool unlocked1 = stakeDetails1.depositTime + (stakeDetails1.numOfMonths * month) < block.timestamp;\r\n\r\n        if (unlocked0 == unlocked1) {\r\n            if (stakeDetails0.numOfMonths != stakeDetails1.numOfMonths) {\r\n                revert UnlockedStakesMustBeSametimePeriod();\r\n            }\r\n            if (!overrideStatuses && stakeDetails0.achievementClaimed != stakeDetails1.achievementClaimed) {\r\n                revert AchievementClaimStatusesDiffer();\r\n            }\r\n            \r\n            // Reset broken status if unlocked\r\n            if (stakeDetails0.withdrawnAmount > 0) {\r\n                stakeDetails0.initialTokenAmount -= stakeDetails0.withdrawnAmount;\r\n                stakeDetails0.withdrawnAmount = 0;\r\n            }\r\n            if (stakeDetails1.withdrawnAmount > 0) {\r\n                stakeDetails1.initialTokenAmount -= stakeDetails1.withdrawnAmount;\r\n                stakeDetails1.withdrawnAmount = 0;\r\n            }\r\n        } else if (unlocked0 != unlocked1) {\r\n            revert CannotMergeLockedAndUnlockedStakes();\r\n        } else {\r\n            // Both locked\r\n            if (!overrideStatuses && (stakeDetails0.withdrawnAmount > 0) != (stakeDetails1.withdrawnAmount > 0)) {\r\n                revert BrokenStatusesDiffer();\r\n            }\r\n        }\r\n\r\n        uint8 numOfMonths0 = stakeDetails0.numOfMonths;\r\n        if (!unlocked0) {\r\n            uint8 extraMonths = 0;\r\n            uint96 amount = 0;\r\n            // Must both be locked\r\n            uint8 numOfMonths1 = stakeDetails1.numOfMonths;\r\n            if (numOfMonths0 > numOfMonths1) {\r\n                extraMonths = numOfMonths0 - numOfMonths1;\r\n                amount = (stakeDetails1.initialTokenAmount - stakeDetails1.withdrawnAmount);\r\n            } else if (numOfMonths0 < numOfMonths1) {\r\n                extraMonths = numOfMonths1 - numOfMonths0;\r\n                amount = (stakeDetails0.initialTokenAmount - stakeDetails0.withdrawnAmount);\r\n                numOfMonths0 = numOfMonths1;\r\n            }\r\n\r\n            if (extraMonths > 0 && amount > 0) {\r\n                // Give new tokens for time period\r\n                increaseVeAmount(staker, amount, extraMonths, true);\r\n            }\r\n        }\r\n\r\n        stakeDetails0.initialTokenAmount += stakeDetails1.initialTokenAmount;\r\n        stakeDetails0.withdrawnAmount += stakeDetails1.withdrawnAmount;\r\n        if (unlocked0) {\r\n            // For unlocked, use higher of two deposit times\r\n            // Can't \"age\" and nft by merging an older one in\r\n            stakeDetails0.depositTime = stakeDetails0.depositTime > stakeDetails1.depositTime ?\r\n                stakeDetails0.depositTime : stakeDetails1.depositTime;\r\n        } else {\r\n            // Re-lock starting now\r\n            stakeDetails0.depositTime = uint48(block.timestamp);\r\n        }\r\n\r\n        stakeDetails0.numOfMonths = numOfMonths0;\r\n        if (stakeDetails1.achievementClaimed == _TRUE8) {\r\n            stakeDetails0.achievementClaimed = _TRUE8;\r\n        }\r\n        \r\n        // Drop the second stake\r\n        stakeDetails1.isActive = _FALSE8;\r\n        uint24 stakerIndex = stakeDetails1.stakerIndex;\r\n        _removeIndividualStake(staker, stakerIndex);\r\n        // Clear the lookup for second\r\n        _stakeById[nftId1] = 0;\r\n        // Add to available data items\r\n        _freeStakes.push(lookupIndex1);\r\n        // Burn the second stake completely\r\n        emit Transfer(staker, address(0), nftId1);\r\n\r\n        // Renumber first stake\r\n        newNftId = _reissueStakeNftId(nftId0, lookupIndex0);\r\n        stakeDetails0.nftId = newNftId;\r\n        _reissueStakeNft(staker, nftId0, newNftId);\r\n    }\r\n\r\n    function _addSplitStake(\r\n        address staker, \r\n        uint96 initialTokenAmount,\r\n        uint96 withdrawnAmount,\r\n        uint48 depositTime,\r\n        uint8 numOfMonths,\r\n        bool achievementClaimed\r\n    ) private returns (uint32 nftId) {\r\n        uint256[] storage stakes = _individualStakes[staker];\r\n        // Create new stake\r\n        StakingDetails storage splitStakeDetails = _createStakeDetails(\r\n            initialTokenAmount, // initialTokenAmount\r\n            withdrawnAmount, // withdrawnAmount\r\n            depositTime,        // depositTime\r\n            numOfMonths,\r\n            achievementClaimed, // achievementClaimed\r\n            staker,\r\n            uint24(stakes.length) // New staker's stake index\r\n        );\r\n\r\n        // Add new stake to individual's list\r\n        stakes.push(splitStakeDetails.lookupIndex); \r\n        nftId = splitStakeDetails.nftId;\r\n    }\r\n\r\n    function bridgeStakeNftOut(address fromAddress, uint256 nftId) \r\n        external onlyEverRiseToken returns (uint96 amount)\r\n    {\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, fromAddress);\r\n\r\n        return _removeStake(fromAddress, nftId, lookupIndex, stakeDetails);\r\n    }\r\n\r\n    function bridgeOrAirdropStakeNftIn(address toAddress, uint96 depositAmount, uint8 numOfMonths, uint48 depositTime, uint96 withdrawnAmount, uint96 rewards, bool achievementClaimed) \r\n        external onlyEverRiseToken returns (uint32 nftId) {\r\n            \r\n        nftId = _createStake(toAddress, depositAmount, withdrawnAmount, numOfMonths, depositTime, achievementClaimed);\r\n        if (rewards > 0) {\r\n            _transfer(address(this), toAddress, rewards, false);\r\n            // Emit event\r\n            claimRiseToken.transferFrom(address(0), toAddress, rewards);\r\n        }\r\n    }\r\n\r\n    function _createStakeDetails(\r\n        uint96 initialTokenAmount,\r\n        uint96 withdrawnAmount,\r\n        uint48 depositTime,\r\n        uint8 numOfMonths,\r\n        bool achievementClaimed,\r\n        address stakerAddress,\r\n        uint24 stakerIndex\r\n    ) private returns (StakingDetails storage stakeDetails) {\r\n        uint256 index = _freeStakes.length;\r\n        if (index > 0) {\r\n            // Is an existing allocated StakingDetails\r\n            // that we can reuse for cheaper gas\r\n            index = _freeStakes[index - 1];\r\n            _freeStakes.pop();\r\n            stakeDetails = _allStakeDetails[index];\r\n        } else {\r\n            // None free, allocate a new StakingDetails\r\n            index = _allStakeDetails.length;\r\n            stakeDetails = _allStakeDetails.push();\r\n        }\r\n\r\n        // Set stake details\r\n        stakeDetails.initialTokenAmount = initialTokenAmount;\r\n        stakeDetails.withdrawnAmount = withdrawnAmount;\r\n        stakeDetails.depositTime = depositTime;\r\n        stakeDetails.numOfMonths = numOfMonths;\r\n        stakeDetails.achievementClaimed = achievementClaimed ? _TRUE8 : _FALSE8;\r\n\r\n        stakeDetails.stakerAddress = stakerAddress;\r\n        stakeDetails.nftId = nextNftId;\r\n        stakeDetails.lookupIndex = uint32(index);\r\n        stakeDetails.stakerIndex = stakerIndex;\r\n        stakeDetails.isActive = _TRUE8;\r\n\r\n        // Set lookup\r\n        _stakeById[nextNftId] = index;\r\n        // Increase the next nft id\r\n        ++nextNftId;\r\n    }\r\n\r\n    function _transferStake(address fromAddress, address toAddress, uint256 nftId) \r\n        private\r\n    {\r\n        (uint256 lookupIndex, StakingDetails storage stakeDetails) = _getStake(nftId, fromAddress);\r\n        require(stakeDetails.withdrawnAmount == 0, \"Broken, non-transferable\");\r\n\r\n        stakeDetails.stakerAddress = toAddress;\r\n        // Full initial as withdrawn must be zero (above)\r\n        uint96 amountToTransfer = stakeDetails.initialTokenAmount;\r\n\r\n        uint8 numOfMonths = stakeDetails.numOfMonths;\r\n        // Remove veTokens from sender (don't emit ve transfer event)\r\n        decreaseVeAmount(fromAddress, amountToTransfer, numOfMonths, false);\r\n        // Give veTokens to receiver (don't emit ve transfer event)\r\n        increaseVeAmount(toAddress, amountToTransfer, numOfMonths, false);\r\n        // Emit the ve transfer event\r\n        veRiseToken.transferFrom(fromAddress, toAddress, amountToTransfer * numOfMonths);\r\n\r\n        // Remove from previous owners list\r\n        _removeIndividualStake(fromAddress, stakeDetails.stakerIndex);\r\n        // Add to new owners list\r\n        stakeDetails.stakerIndex = uint24(_individualStakes[toAddress].length);\r\n        _individualStakes[toAddress].push(lookupIndex);\r\n\r\n        everRiseToken.transferStake(fromAddress, toAddress, amountToTransfer);\r\n    }\r\n\r\n    function _removeIndividualStake(address staker, uint24 stakerIndex) private {\r\n        uint256[] storage stakes = _individualStakes[staker];\r\n\r\n        uint24 stakerLength = uint24(stakes.length);\r\n\r\n        if (stakerLength >= stakerIndex + 1) {\r\n            // Not last item, overwrite with last item from account stakes\r\n            uint256 lastStakeIndex = stakes[stakerLength - 1];\r\n            _allStakeDetails[lastStakeIndex].stakerIndex = stakerIndex;\r\n            stakes[stakerIndex] = lastStakeIndex;\r\n        }\r\n        // Remove last item\r\n        stakes.pop();\r\n    }\r\n\r\n    function _reissueStakeNftId(uint256 nftId, uint256 stakeIndex) private returns (uint32 newNftId) {\r\n        // Burn the Stake NFT id\r\n        _stakeById[nftId] = 0;\r\n        // Reissue new Stake NFT id\r\n        newNftId = nextNftId;\r\n        _stakeById[newNftId] = stakeIndex;\r\n        // Increase the next nft id\r\n        ++nextNftId;\r\n    }\r\n\r\n    function increaseVeAmount(address staker, uint96 amount, uint8 numOfMonths, bool emitEvent) private {\r\n        // Transfer vote escrowed tokens from contract to staker\r\n        uint256 veTokens = amount * numOfMonths;\r\n        totalAmountEscrowed += amount;\r\n        totalAmountVoteEscrowed += veTokens;\r\n        voteEscrowedBalance[staker] += veTokens; // increase the ve tokens amount\r\n        _transfer(address(this), staker, veTokens, emitEvent);\r\n    }\r\n\r\n    function decreaseVeAmount(address staker, uint96 amount, uint8 numOfMonths, bool emitEvent) private {\r\n        // Transfer vote escrowed tokens back to the contract\r\n        uint256 veTokens = amount * numOfMonths;\r\n        totalAmountEscrowed -= amount;\r\n        totalAmountVoteEscrowed -= veTokens;\r\n        voteEscrowedBalance[staker] -= veTokens; // decrease the ve tokens amount\r\n        _transfer(staker, address(this), veTokens, emitEvent);\r\n    }\r\n\r\n    function _removeStake(address staker, uint256 nftId, uint256 lookupIndex, StakingDetails storage stakeDetails) private returns (uint96 amount) {        \r\n        uint96 remainingAmount = stakeDetails.initialTokenAmount - stakeDetails.withdrawnAmount;\r\n\r\n        decreaseVeAmount(staker, remainingAmount, stakeDetails.numOfMonths, true);\r\n\r\n        _burnStake(staker, nftId, lookupIndex, stakeDetails);\r\n\r\n        return remainingAmount;\r\n    }\r\n\r\n    function _burnStake(address staker, uint256 nftId, uint256 lookupIndex, StakingDetails storage stakeDetails) private {        \r\n        stakeDetails.isActive = _FALSE8;\r\n\r\n        uint24 stakerIndex = stakeDetails.stakerIndex;\r\n        _removeIndividualStake(staker, stakerIndex);\r\n\r\n        // Clear the lookup\r\n        _stakeById[nftId] = 0;\r\n        // Add to available data items\r\n        _freeStakes.push(lookupIndex);\r\n    }\r\n\r\n    function _createStake(address staker, uint96 depositAmount, uint96 withdrawnAmount, uint8 numOfMonths, uint48 depositTime, bool achievementClaimed)\r\n        private returns (uint32 nftId)\r\n    {\r\n        if (withdrawnAmount >= depositAmount) revert AmountOutOfRange();\r\n        uint256[] storage stakes = _individualStakes[staker];\r\n\r\n        // Create new stake\r\n        StakingDetails storage stakeDetails = _createStakeDetails(\r\n            depositAmount,   // initialTokenAmount\r\n            withdrawnAmount, // withdrawnAmount\r\n            depositTime,     // depositTime\r\n            numOfMonths,\r\n            achievementClaimed,           // achievementClaimed\r\n            staker,\r\n            uint24(stakes.length)   // New staker's stake index\r\n        );\r\n\r\n        // Add new stake to individual's list\r\n        stakes.push(stakeDetails.lookupIndex);  \r\n        \r\n        uint96 remaining = depositAmount - withdrawnAmount;\r\n        increaseVeAmount(staker, remaining, numOfMonths, true);\r\n\r\n        // Mint new Stake NFT to staker\r\n        nftId = stakeDetails.nftId;\r\n    }\r\n\r\n    function calculateTax(uint96 amount, uint256 depositTime, uint256 numOfMonths) public view returns (uint96) {\r\n        return calculateTaxAt(amount, depositTime, numOfMonths, block.timestamp);\r\n    }\r\n\r\n    function calculateTaxAt(uint96 amount, uint256 depositTime, uint256 numOfMonths, uint256 timestamp) public view returns (uint96) {\r\n        uint256 lockTime = depositTime + (numOfMonths * month);\r\n        uint96 taxAmount = 0;\r\n\r\n        if (timestamp < depositTime + (numOfMonths * month / 2)) {\r\n            taxAmount = (amount * firstHalfPenality) / 100;\r\n        } else if (timestamp < lockTime) {\r\n            taxAmount = (amount * secondHalfPenality) / 100;\r\n        }\r\n\r\n        return taxAmount;\r\n    }\r\n\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (\r\n        address receiver,\r\n        uint256 royaltyAmount\r\n    ) {\r\n        if (_tokenId == 0) revert AmountMustBeGreaterThanZero();\r\n\r\n        return (address(royaltySplitter), _salePrice / nftRoyaltySplit);\r\n    }\r\n    \r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        if (address(everRiseToken) == address(0)) revert NotSetup();\r\n\r\n        address _owner = _msgSender();\r\n        everRiseToken.setApprovalForAll(_owner, operator, approved);\r\n\r\n        emit ApprovalForAll(_owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view returns (bool) {\r\n        return everRiseToken.isApprovedForAll(account, operator);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external payable walletLock(_msgSender()) {\r\n        address operator = _msgSender();\r\n        _transferFrom(operator, from, to, tokenId);\r\n        _doSafeERC721TransferAcceptanceCheck(operator, from, to, tokenId, data);\r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable walletLock(_msgSender()) {\r\n        address operator = _msgSender();\r\n        _transferFrom(operator, from, to, tokenId);\r\n        _doSafeERC721TransferAcceptanceCheck(operator, from, to, tokenId, new bytes(0));\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId)\r\n        external payable walletLock(_msgSender()) {\r\n        address operator = _msgSender();\r\n        _transferFrom(operator, from, to, tokenId);\r\n    }\r\n    \r\n   function approve(address account, address _operator, uint256 nftId)\r\n        external onlyEverRiseToken {\r\n        _approve(account, _operator, nftId);\r\n    }\r\n\r\n    function approve(address _operator, uint256 nftId) external payable {\r\n        _approve(_msgSender(), _operator, nftId);\r\n    }\r\n\r\n    function _approve(address account, address _operator, uint256 nftId) private {\r\n        if (ownerOf(nftId) != account) revert NotStakerAddress();\r\n\r\n        ApprovalChecks memory approvals = everRiseToken.approvals(account);\r\n\r\n        _individualApproval[nftId] = IndividualAllowance({\r\n            operator: _operator, \r\n            timestamp: approvals.autoRevokeNftHours == 0 ? \r\n                type(uint48).max : // Don't timeout approval\r\n                uint48(block.timestamp) + approvals.autoRevokeNftHours * 1 hours, // Timeout after user chosen period,\r\n            nftCheck: approvals.nftCheck\r\n        });\r\n    }\r\n\r\n    function getApproved(uint256 nftId) external view returns (address) {\r\n        getStakeIndex(nftId); // Reverts on not exist\r\n        \r\n        IndividualAllowance storage _allowance = _individualApproval[nftId];\r\n        ApprovalChecks memory approvals = everRiseToken.approvals(ownerOf(nftId));\r\n\r\n        if (block.timestamp > _allowance.timestamp ||\r\n            approvals.nftCheck != _allowance.nftCheck)\r\n        {\r\n            return address(0);\r\n        }\r\n\r\n        return _allowance.operator;\r\n    }\r\n\r\n    function _isAddressApproved(address operator, uint256 nftId) private view returns (bool) {\r\n        IndividualAllowance storage _allowance = _individualApproval[nftId];\r\n        ApprovalChecks memory approvals = everRiseToken.approvals(ownerOf(nftId));\r\n\r\n        if (_allowance.operator != operator ||\r\n            block.timestamp > _allowance.timestamp ||\r\n            approvals.nftCheck != _allowance.nftCheck)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 nftId\r\n    ) private {\r\n        if (address(everRiseToken) == address(0)) revert NotSetup();\r\n        if (from == address(0)) revert NotZeroAddress();\r\n        if (to == address(0)) revert NotZeroAddress();\r\n        if (operator != from && \r\n            !isApprovedForAll(from, operator) &&\r\n            !_isAddressApproved(from, nftId)\r\n        ) revert AmountLargerThanAllowance();\r\n\r\n        // Clear any individual approvals\r\n        delete _individualApproval[nftId];\r\n        _transferStake(from, to, nftId);\r\n\r\n        // Signal transfer complete\r\n        emit Transfer(from, to, nftId);\r\n    }\r\n\r\n    function addStaker(address staker, uint256 nftId)\r\n        external onlyEverRiseToken \r\n    {\r\n        // Send event for new staking\r\n        emit Transfer(address(0), staker, nftId);\r\n    }\r\n\r\n    function _doSafeERC721TransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes memory data\r\n    ) private view {\r\n        if (isContract(to)) {\r\n            try IERC721TokenReceiver(to).onERC721Received(operator, from, id, data) returns (bytes4 response) {\r\n                if (response != IERC721TokenReceiver.onERC721Received.selector) {\r\n                    revert ERC721ReceiverReject();\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert ERC721ReceiverNotImplemented();\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address account) private view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function removeStaker(address staker, uint256 nftId)\r\n        external onlyEverRiseToken \r\n    {\r\n        // Send event for left staking\r\n        emit Transfer(staker, address(0), nftId);\r\n    }\r\n\r\n    function reissueStakeNft(address staker, uint256 oldNftId, uint256 newNftId)\r\n        external onlyEverRiseToken \r\n    {\r\n        _reissueStakeNft(staker, oldNftId, newNftId);\r\n    }\r\n\r\n    function _reissueStakeNft(address staker, uint256 oldNftId, uint256 newNftId)\r\n        private\r\n    {\r\n        // Burn old Stake NFT\r\n        emit Transfer(staker, address(0), oldNftId);\r\n        // Reissue new Stake NFT\r\n        emit Transfer(address(0), staker, newNftId);\r\n    }\r\n\r\n    // Admin for trapped tokens\r\n\r\n    function transferExternalTokens(address tokenAddress, address toAddress) external onlyOwner {\r\n        if (tokenAddress == address(0)) revert NotZeroAddress();\r\n        if (toAddress == address(0)) revert NotZeroAddress();\r\n        if (IERC20(tokenAddress).balanceOf(address(this)) == 0) revert AmountLargerThanAvailable();\r\n\r\n        require(IERC20(tokenAddress).transfer(toAddress, IERC20(tokenAddress).balanceOf(address(this))));\r\n    }\r\n\r\n    function transferToAddressETH(address payable receipient) external onlyOwner {\r\n        if (receipient == address(0)) revert NotZeroAddress();\r\n\r\n        receipient.transfer(address(this).balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"CallerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotTransferrable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transferFromWithPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veEverRise\",\"outputs\":[{\"internalType\":\"contract InftEverRise\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "claimRise", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f35afae76adc4b92710eb555fc201d0373faf6a7430815869d3d45f9c99a850e"}