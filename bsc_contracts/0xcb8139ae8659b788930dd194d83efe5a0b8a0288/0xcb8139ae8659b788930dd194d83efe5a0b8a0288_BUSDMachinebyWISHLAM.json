{"SourceCode": "/**\r\n UI Visit : https://wishlambo.com/busd/\r\n\r\n Project by WishLambo(WLB)\r\n\r\n 10% Dev Fee for Buy back WishLambo Token\r\n\r\n \u2705\u2705\u2705 List WishLambo ($WLB) Project \u2705\u2705\u2705\r\n\r\n\ud83d\udc8e WishLambo Airdrop BOT ( @WishLamboAirdrop_Bot )\r\n\r\n\ud83d\udc8e WishLambo ($WLB) BEP20 Token ( https://WishLambo.io )\r\n\r\n\ud83d\udc8e MultiPayment Investment Project ( https://WishLambo.Com )\r\n\r\n\ud83d\udc8e #Dapps BNB Investment ( https://wishlambo.com/bnbstake/ ) \r\n\r\n\ud83d\udc8e #Dapps BNB Miner Egg ( https://wishlambo.io/eggbnb/ )\r\n\ud83d\udea7 Next will be updated\r\n\r\n\r\nSocial Media & usefull link\r\n-----------------------------------+\r\nWebsite : https://wishlambo.com/   & https://wishlambo.io/ \r\n\r\nTelegram : https://t.me/Wishlamboofficial\r\nIG : https://www.instagram.com/wishlamboofficial/\r\nMedium : https://medium.com/@wishlamboofficial\r\nTwitter : https://twitter.com/wishlambo\r\n\r\n-----------------------------------+\r\n*/\r\n\r\npragma solidity 0.5.8;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function limitSupply() external view returns (uint256);\r\n    function availableSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n    address busd = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // live busd\r\n    // address busd = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // testnet busd\r\n    IERC20 token;\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 internal _limitSupply;\r\n\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint8 internal _decimals;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function limitSupply() public view returns (uint256) {\r\n        return _limitSupply;\r\n    }\r\n    \r\n    function availableSupply() public view returns (uint256) {\r\n        return _limitSupply.sub(_totalSupply);\r\n    }    \r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        require(availableSupply() >= amount, \"Supply exceed\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        \r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 amount, address token, bytes calldata extraData) external;\r\n}\r\n\r\ncontract Token is ERC20 {\r\n    mapping (address => bool) private _contracts;\r\n\r\n    constructor() public {\r\n        _name = \"BUSDMachine\";\r\n        _symbol = \"BUSDM\";\r\n        _decimals = 18;\r\n        _limitSupply = 1000000e18;\r\n    }\r\n\r\n    function approveAndCall(address spender, uint256 amount, bytes memory extraData) public returns (bool) {\r\n        require(approve(spender, amount));\r\n\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, amount, address(this), extraData);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n\r\n        if (_contracts[to]) {\r\n            approveAndCall(to, value, new bytes(0));\r\n        } else {\r\n            super.transfer(to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BUSDMachinebyWISHLAMBO is Token {\r\n    \r\n    uint private startTime = 1111; \r\n    \r\n    address payable private ADMIN;\r\n    address payable private DEV_1;\r\n    address payable private DEV_2;\r\n    address payable private ADV_1;\r\n    address payable private ADV_2;\r\n    address payable private ADV_3;\r\n    address payable private FIN_1;\r\n    address payable private MAR_1;\r\n    \r\n    uint public totalUsers; \r\n    uint public totalBUSDStaked; \r\n    uint public totalTokenStaked;\r\n    uint public sentAirdrop;\r\n    \r\n    uint public ownerManualAirdrop;\r\n    uint public ownerManualAirdropCheckpoint = startTime;\r\n    \r\n    uint8[] private REF_BONUSES             = [100, 50, 20];\r\n    uint private constant ADV_FEE           = 45;                   // Base 1.5% multipled * 7 = 10.5% total\r\n    uint private constant LIMIT_AIRDROP     = 100000 ether;\r\n    uint private constant MANUAL_AIRDROP    = 50000 ether;    \r\n    uint private constant USER_AIRDROP      = 100 ether; \r\n    uint private constant BUSD_DAILYPROFIT  = 20;\r\n    uint private constant TOKEN_DAILYPROFIT = 40;\r\n    uint private constant PERCENT_DIVIDER   = 1000;\r\n    uint private constant PRICE_DIVIDER     = 1 ether;\r\n    uint private constant TIME_STEP         = 1 days;\r\n    uint private constant TIME_TO_UNSTAKE   = 7 days;\r\n    uint private constant NEXT_AIRDROP      = 7 days;\r\n    uint private constant BON_AIRDROP       = 5;\r\n    uint private constant SELL_LIMIT        = 40000 ether; \r\n    \r\n    mapping(address => User) private users;\r\n    mapping(uint => uint) private sold; \r\n    \r\n    struct Stake {\r\n        uint checkpoint;\r\n        uint totalStaked; \r\n        uint lastStakeTime;\r\n        uint unClaimedTokens;        \r\n    }\r\n    \r\n    struct User {\r\n        address referrer;\r\n        uint lastAirdrop;\r\n        uint countAirdrop;\r\n        uint bonAirdrop;\r\n        Stake sM;\r\n        Stake sT;  \r\n\t\tuint256 bonus;\r\n\t\tuint256 totalBonus;\r\n        uint totaReferralBonus;\r\n        uint[3] levels;\r\n    }\r\n    \r\n    event TokenOperation(address indexed account, string txType, uint tokenAmount, uint trxAmount);\r\n\r\n    constructor() public {\r\n        token = IERC20(busd);\r\n\r\n        ADMIN = msg.sender;\r\n        DEV_1 = msg.sender;                                  // e\r\n        DEV_2 = 0xa5063981966de5790e503e17006707b222560173;  // N\r\n        ADV_1 = 0x56Daad0E9eBa0490CA42685fDaB5bb58BD07B5c8;  // 0         \r\n        ADV_2 = 0xA7fDbD4355623dDfDCf630E37483bdf38689AB6d;  // E        \r\n        ADV_3 = 0x608a72256C70890D9102C5E56f70402E8a791f78;  // o     \r\n        FIN_1 = 0x614dE5d5E42Bdb5253fe1a6817d2b2149D7029f1;  // S   \r\n        MAR_1 = 0x518A3806539206011e9199F45eccf2C1adCc863e;  // DESB      \r\n\r\n        _mint(msg.sender, MANUAL_AIRDROP.div(5));  \r\n    }       \r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == ADMIN, \"Only owner can call this function\");\r\n        _;\r\n    } \r\n    \r\n    function stakeBUSD(address referrer,  uint256 _amount) public payable {\r\n        require (block.timestamp > 1639832400);                // Saturday, December 18, 2021 1:00:00 PM GMT\r\n        \r\n        token.transferFrom(msg.sender, address(this), _amount);     // added\r\n        \r\n\t\tuint fee = _amount.mul(ADV_FEE).div(PERCENT_DIVIDER);   // calculate fees on _amount and not msg.value\r\n        \r\n        token.transfer(DEV_1, fee);\r\n        token.transfer(DEV_2, fee);     \r\n\r\n        token.transfer(ADV_1, fee);\r\n        token.transfer(ADV_2, fee);\r\n        token.transfer(ADV_3, fee);\r\n\r\n        token.transfer(FIN_1, fee);\r\n        token.transfer(MAR_1, fee);\r\n\r\n\t\tUser storage user = users[msg.sender];\r\n\t\t\r\n\t\tif (user.referrer == address(0) && msg.sender != ADMIN) {\r\n\t\t\tif (users[referrer].sM.totalStaked == 0) {\r\n\t\t\t\treferrer = ADMIN;\r\n\t\t\t}\r\n\t\t\tuser.referrer = referrer;\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < REF_BONUSES.length; i++) {\r\n\t\t\t\tif (upline != address(0)) {\r\n\t\t\t\t\tusers[upline].levels[i] = users[upline].levels[i].add(1);\r\n\t\t\t\t\tif (i == 0) {\r\n\t\t\t\t\t    users[upline].bonAirdrop = users[upline].bonAirdrop.add(1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t\t} else break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (user.referrer != address(0)) {\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < REF_BONUSES.length; i++) {\r\n\t\t\t\tif (upline == address(0)) {\r\n\t\t\t\t    upline = ADMIN;\r\n\t\t\t\t}\r\n\t\t\t\tuint256 amount = _amount.mul(REF_BONUSES[i]).div(PERCENT_DIVIDER);\r\n\t\t\t\tusers[upline].bonus = users[upline].bonus.add(amount);\r\n\t\t\t\tusers[upline].totalBonus = users[upline].totalBonus.add(amount);\r\n\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t}\r\n\t\t} \r\n\r\n        if (user.sM.totalStaked == 0) {\r\n            user.sM.checkpoint = maxVal(now, startTime);\r\n            totalUsers++;\r\n        } else {\r\n            updateStakeBUSD_IP(msg.sender);\r\n        }\r\n      \r\n        user.sM.lastStakeTime = now;\r\n        user.sM.totalStaked = user.sM.totalStaked.add(_amount);\r\n        totalBUSDStaked = totalBUSDStaked.add(_amount);\r\n    }\r\n    \r\n    function stakeToken(uint tokenAmount) public {\r\n\r\n        User storage user = users[msg.sender];\r\n        require(now >= startTime, \"Stake not available yet\");\r\n        require(tokenAmount <= balanceOf(msg.sender), \"Insufficient Token Balance\");\r\n\r\n        if (user.sT.totalStaked == 0) {\r\n            user.sT.checkpoint = now;\r\n        } else {\r\n            updateStakeToken_IP(msg.sender);\r\n        }\r\n        \r\n        _transfer(msg.sender, address(this), tokenAmount);\r\n        user.sT.lastStakeTime = now;\r\n        user.sT.totalStaked = user.sT.totalStaked.add(tokenAmount);\r\n        totalTokenStaked = totalTokenStaked.add(tokenAmount); \r\n    } \r\n    \r\n    function unStakeToken() public {\r\n        User storage user = users[msg.sender];\r\n        require(now > user.sT.lastStakeTime.add(TIME_TO_UNSTAKE));\r\n        updateStakeToken_IP(msg.sender);\r\n        uint tokenAmount = user.sT.totalStaked;\r\n        user.sT.totalStaked = 0;\r\n        totalTokenStaked = totalTokenStaked.sub(tokenAmount); \r\n        _transfer(address(this), msg.sender, tokenAmount);\r\n    }  \r\n    \r\n    function updateStakeBUSD_IP(address _addr) private {\r\n        User storage user = users[_addr];\r\n        uint256 amount = getStakeBUSD_IP(_addr);\r\n        if(amount > 0) {\r\n            user.sM.unClaimedTokens = user.sM.unClaimedTokens.add(amount);\r\n            user.sM.checkpoint = now;\r\n        }\r\n    } \r\n    \r\n    function getStakeBUSD_IP(address _addr) view private returns(uint256 value) {\r\n        User storage user = users[_addr];\r\n        uint256 fr = user.sM.checkpoint;\r\n        if (startTime > now) {\r\n          fr = now; \r\n        }\r\n        uint256 Tarif = BUSD_DAILYPROFIT;\r\n        uint256 to = now;\r\n        if(fr < to) {\r\n            value = user.sM.totalStaked.mul(to - fr).mul(Tarif).div(TIME_STEP).div(PERCENT_DIVIDER);\r\n        } else {\r\n            value = 0;\r\n        }\r\n        return value;\r\n    }  \r\n    \r\n    function updateStakeToken_IP(address _addr) private {\r\n        User storage user = users[_addr];\r\n        uint256 amount = getStakeToken_IP(_addr);\r\n        if(amount > 0) {\r\n            user.sT.unClaimedTokens = user.sT.unClaimedTokens.add(amount);\r\n            user.sT.checkpoint = now;\r\n        }\r\n    } \r\n    \r\n    function getStakeToken_IP(address _addr) view private returns(uint256 value) {\r\n        User storage user = users[_addr];\r\n        uint256 fr = user.sT.checkpoint;\r\n        if (startTime > now) {\r\n          fr = now; \r\n        }\r\n        uint256 Tarif = TOKEN_DAILYPROFIT;\r\n        uint256 to = now;\r\n        if(fr < to) {\r\n            value = user.sT.totalStaked.mul(to - fr).mul(Tarif).div(TIME_STEP).div(PERCENT_DIVIDER);\r\n        } else {\r\n            value = 0;\r\n        }\r\n        return value;\r\n    }      \r\n    \r\n    function claimToken_M() public {\r\n        User storage user = users[msg.sender];\r\n       \r\n        updateStakeBUSD_IP(msg.sender);\r\n        uint tokenAmount = user.sM.unClaimedTokens;  \r\n        user.sM.unClaimedTokens = 0;                 \r\n        \r\n        _mint(msg.sender, tokenAmount);\r\n        emit TokenOperation(msg.sender, \"CLAIM\", tokenAmount, 0);\r\n    }    \r\n    \r\n    function claimToken_T() public {\r\n        User storage user = users[msg.sender];\r\n       \r\n        updateStakeToken_IP(msg.sender);\r\n        uint tokenAmount = user.sT.unClaimedTokens; \r\n        user.sT.unClaimedTokens = 0; \r\n        \r\n        _mint(msg.sender, tokenAmount);\r\n        emit TokenOperation(msg.sender, \"CLAIM\", tokenAmount, 0);\r\n    }     \r\n    \r\n    function sellToken(uint tokenAmount) public {\r\n        tokenAmount = minVal(tokenAmount, balanceOf(msg.sender));\r\n        require(tokenAmount > 0, \"Token amount can not be 0\");\r\n        \r\n        require(sold[getCurrentDay()].add(tokenAmount) <= SELL_LIMIT, \"Daily Sell Limit exceed\");\r\n        sold[getCurrentDay()] = sold[getCurrentDay()].add(tokenAmount);\r\n        uint BUSDAmount = tokenToBUSD(tokenAmount);\r\n    \r\n        require(getContractBUSDBalance() > BUSDAmount, \"Insufficient Contract Balance\");\r\n        _burn(msg.sender, tokenAmount);\r\n\r\n       token.transfer(msg.sender, BUSDAmount);\r\n        \r\n        emit TokenOperation(msg.sender, \"SELL\", tokenAmount, BUSDAmount);\r\n    }\r\n    \r\n    function getCurrentUserBonAirdrop(address _addr) public view returns (uint) {\r\n        return users[_addr].bonAirdrop;\r\n    }  \r\n    \r\n    function claimAirdrop() public {\r\n        require(getAvailableAirdrop() >= USER_AIRDROP, \"Airdrop limit exceed\");\r\n        require(users[msg.sender].sM.totalStaked >= getUserAirdropReqInv(msg.sender));\r\n        require(now > users[msg.sender].lastAirdrop.add(NEXT_AIRDROP));\r\n        require(users[msg.sender].bonAirdrop >= BON_AIRDROP);\r\n        users[msg.sender].countAirdrop++;\r\n        users[msg.sender].lastAirdrop = now;\r\n        users[msg.sender].bonAirdrop = 0;\r\n        _mint(msg.sender, USER_AIRDROP);\r\n        sentAirdrop = sentAirdrop.add(USER_AIRDROP);\r\n        emit TokenOperation(msg.sender, \"AIRDROP\", USER_AIRDROP, 0);\r\n    }\r\n    \r\n    function claimAirdropM() public onlyOwner {\r\n        uint amount = 10000 ether;\r\n        ownerManualAirdrop = ownerManualAirdrop.add(amount);\r\n        require(ownerManualAirdrop <= MANUAL_AIRDROP, \"Airdrop limit exceed\");\r\n        require(now >= ownerManualAirdropCheckpoint.add(5 days), \"Time limit error\");\r\n        ownerManualAirdropCheckpoint = now;\r\n        _mint(msg.sender, amount);\r\n        emit TokenOperation(msg.sender, \"AIRDROP\", amount, 0);\r\n    }    \r\n    \r\n\tfunction withdrawRef() public {\r\n\t\tUser storage user = users[msg.sender];\r\n\t\t\r\n\t\tuint totalAmount = getUserReferralBonus(msg.sender);\r\n\t\trequire(totalAmount > 0, \"User has no dividends\");\r\n        user.bonus = 0;\r\n\t\t//msg.sender.transfer(totalAmount);\r\n\t\ttoken.transfer(msg.sender, totalAmount);\r\n\t}\t    \r\n\r\n    function getUserUnclaimedTokens_M(address _addr) public view returns(uint value) {\r\n        User storage user = users[_addr];\r\n        return getStakeBUSD_IP(_addr).add(user.sM.unClaimedTokens); \r\n    }\r\n    \r\n    function getUserUnclaimedTokens_T(address _addr) public view returns(uint value) {\r\n        User storage user = users[_addr];\r\n        return getStakeToken_IP(_addr).add(user.sT.unClaimedTokens); \r\n    }  \r\n    \r\n\tfunction getAvailableAirdrop() public view returns (uint) {\r\n\t\treturn minZero(LIMIT_AIRDROP, sentAirdrop);\r\n\t}   \r\n\t\r\n    function getUserTimeToNextAirdrop(address _addr) public view returns (uint) {\r\n        return minZero(users[_addr].lastAirdrop.add(NEXT_AIRDROP), now);\r\n    } \r\n    \r\n    function getUserBonAirdrop(address _addr) public view returns (uint) {\r\n        return users[_addr].bonAirdrop;\r\n    }\r\n\r\n    function getUserAirdropReqInv(address _addr) public view returns (uint) {\r\n        uint ca = users[_addr].countAirdrop.add(1); \r\n        return ca.mul(100 ether); \r\n    }       \r\n    \r\n    function getUserCountAirdrop(address _addr) public view returns (uint) {\r\n        return users[_addr].countAirdrop;\r\n    }     \r\n    \r\n\tfunction getContractBUSDBalance() public view returns (uint) {\r\n\t    // return address(this).balance;\r\n\t    return token.balanceOf(address(this));\r\n\t}  \r\n\t\r\n\tfunction getContractTokenBalance() public view returns (uint) {\r\n\t\treturn balanceOf(address(this));\r\n\t}  \r\n\t\r\n\tfunction getAPY_M() public pure returns (uint) {\r\n\t\treturn BUSD_DAILYPROFIT.mul(365).div(10);\r\n\t}\r\n\t\r\n\tfunction getAPY_T() public pure returns (uint) {\r\n\t\treturn TOKEN_DAILYPROFIT.mul(365).div(10);\r\n\t}\t\r\n\t\r\n\tfunction getUserBUSDBalance(address _addr) public view returns (uint) {\r\n\t\treturn address(_addr).balance;\r\n\t}\t\r\n\t\r\n\tfunction getUserTokenBalance(address _addr) public view returns (uint) {\r\n\t\treturn balanceOf(_addr);\r\n\t}\r\n\t\r\n\tfunction getUserBUSDStaked(address _addr) public view returns (uint) {\r\n\t\treturn users[_addr].sM.totalStaked;\r\n\t}\t\r\n\t\r\n\tfunction getUserTokenStaked(address _addr) public view returns (uint) {\r\n\t\treturn users[_addr].sT.totalStaked;\r\n\t}\r\n\t\r\n\tfunction getUserTimeToUnstake(address _addr) public view returns (uint) {\r\n\t\treturn  minZero(users[_addr].sT.lastStakeTime.add(TIME_TO_UNSTAKE), now);\r\n\t}\t\r\n\t\r\n    function getTokenPrice() public view returns(uint) {\r\n        uint d1 = getContractBUSDBalance().mul(PRICE_DIVIDER);\r\n        uint d2 = availableSupply().add(1);\r\n        return d1.div(d2);\r\n    } \r\n\r\n    function BUSDToToken(uint BUSDAmount) public view returns(uint) {\r\n        return BUSDAmount.mul(PRICE_DIVIDER).div(getTokenPrice());\r\n    }\r\n\r\n    function tokenToBUSD(uint tokenAmount) public view returns(uint) {\r\n        return tokenAmount.mul(getTokenPrice()).div(PRICE_DIVIDER);\r\n    } \t\r\n\r\n\tfunction getUserDownlineCount(address userAddress) public view returns(uint, uint, uint) {\r\n\t\treturn (users[userAddress].levels[0], users[userAddress].levels[1], users[userAddress].levels[2]);\r\n\t}  \r\n\t\r\n\tfunction getUserReferralBonus(address userAddress) public view returns(uint) {\r\n\t\treturn users[userAddress].bonus;\r\n\t}\r\n\r\n\tfunction getUserReferralTotalBonus(address userAddress) public view returns(uint) {\r\n\t\treturn users[userAddress].totalBonus;\r\n\t}\r\n\t\r\n\tfunction getUserReferralWithdrawn(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].totalBonus.sub(users[userAddress].bonus);\r\n\t}\t\r\n    \r\n\tfunction getContractLaunchTime() public view returns(uint) {\r\n\t\treturn minZero(startTime, block.timestamp);\r\n\t}\r\n\t\r\n    function getCurrentDay() public view returns (uint) {\r\n        return minZero(now, startTime).div(TIME_STEP);\r\n    }\t\r\n    \r\n    function getTokenSoldToday() public view returns (uint) {\r\n        return sold[getCurrentDay()];\r\n    }   \r\n    \r\n    function getTokenAvailableToSell() public view returns (uint) {\r\n       return minZero(SELL_LIMIT, sold[getCurrentDay()]);\r\n    }  \r\n    \r\n    function getTimeToNextDay() public view returns (uint) {\r\n        uint t = minZero(now, startTime);\r\n        uint g = getCurrentDay().mul(TIME_STEP);\r\n        return g.add(TIME_STEP).sub(t);\r\n    }     \r\n    \r\n    function minZero(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return a - b; \r\n        } else {\r\n           return 0;    \r\n        }    \r\n    }   \r\n    \r\n    function maxVal(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return a; \r\n        } else {\r\n           return b;    \r\n        }    \r\n    }\r\n    \r\n    function minVal(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return b; \r\n        } else {\r\n           return a;    \r\n        }    \r\n    }    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTimeToUnstake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"BUSDAmount\",\"type\":\"uint256\"}],\"name\":\"BUSDToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDownlineCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenToBUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAPY_T\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAPY_M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getCurrentUserBonAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralTotalBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unStakeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAirdropM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserAirdropReqInv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAvailableToSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeBUSD\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBUSDBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSoldToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserBUSDBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBUSDStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserUnclaimedTokens_M\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerManualAirdropCheckpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeToNextDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTokenStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserBUSDStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sentAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserCountAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRef\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserBonAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTimeToNextAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractLaunchTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken_M\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserUnclaimedTokens_T\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken_T\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerManualAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"txType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"trxAmount\",\"type\":\"uint256\"}],\"name\":\"TokenOperation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "BUSDMachinebyWISHLAMBO", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://ddb60e6f6a4d80178c50b0cbe0614839caae68d1101a93416c6b3eedb421cab0"}