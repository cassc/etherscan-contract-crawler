{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/who_core/WHOToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\r\\npragma solidity ^0.8.0;\\r\\n// BEP20\\r\\nimport \\\"@sphynxswap/sphynx-swap-lib/contracts/token/BEP20/BEP20.sol\\\";\\r\\n// \u6743\u9650\u5e93\\r\\nimport \\\"solidity_lib/Permission/Permission_abstract.sol\\\";\\r\\n// \u65f6\u95f4\u5e93\\r\\nimport \\\"solidity_lib/Time/time.sol\\\";\\r\\n// Factory\\r\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\r\\n// Pair\\r\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\r\\n// Router\\r\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\n// UniswapV2Library\\r\\nimport \\\"../../library/V2Library/UniswapV2Library.sol\\\";\\r\\n// \u6570\u636e\u5e93\\r\\nimport \\\"../../interface/who_sql/Iwhodb.sol\\\";\\r\\n// \u6570\u636e\u5e93\u7684\u6570\u636e\u7ed3\u6784\u5e93\\r\\nimport \\\"../../library/LWHO.sol\\\";\\r\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\r\\nimport '../../interface/whtc/IWHTC.sol';\\r\\n\\r\\ncontract WHOToken is BEP20, permission{\\r\\n    address daoAddress;\\r\\n    address USDTAddress;\\r\\n    address public routerAddress;\\r\\n    address public uniswapV2Pair;\\r\\n    // address PoundageAddress;\\r\\n    // address returnLiquidtyWHOAddress;\\r\\n    // address returnLiquidtyWHDAddress;\\r\\n    address[3] returnAddress; // 0 \u56de\u6d41WHO\u5730\u5740\uff0c1\u56de\u6d41WHD\u5730\u5740\uff0c2\u624b\u7eed\u8d39\u5730\u5740\\r\\n    address WHTCAddress;\\r\\n    uint public endPoolAmount;\\r\\n    bool isSolidity;\\r\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n    IWhoSql db;\\r\\n    IUniswapV2Router02 router;\\r\\n    // uint swapPoundage; //\u4ea4\u6613\u624b\u7eed\u8d39\\r\\n    // uint returnLiquidityFeeWHO; // \u56de\u6d41WHO\\r\\n    // uint returnLiquidityFeeWHD; // \u56de\u6d41WHD\\r\\n    uint[5] allFee; // 0 \u56de\u6d41WHO\u500d\u7387 1\u56de\u6d41WHD\u500d\u7387 2 \u6253\u9ed1\u6d1e 3 \u94f8\u9020 4 \u4ea4\u6613\u624b\u7eed\u8d39\\r\\n    // uint burnFee; // \u6253\u9ed1\u6d1e\\r\\n    // uint mintCoinFee;  // \u94f8\u9020\\r\\n    bool isTransferDao;\\r\\n    modifier isTrade{\\r\\n        // require(IWhoSql(db.getSql()[2]).getIsTrade() == true&& IWhoSql(db.getSql()[2]).getInitTransWhiteList(msg.sender) == false,\\\"You don't have access.\\\");\\r\\n        require(LWHO.isAccess(IWhoSql(db.getSql()[2]),msg.sender),\\\"You don't have access.\\\");\\r\\n        _;    \\r\\n    }\\r\\n    \\r\\n    constructor(address[] memory pool) BEP20(\\\"WHO\\\",\\\"WHO\\\") {\\r\\n        USDTAddress = pool[4];\\r\\n        routerAddress = pool[5];\\r\\n        router = IUniswapV2Router02(routerAddress);\\r\\n        endPoolAmount = 10 * 10000 * 10 ** decimals();\\r\\n        returnAddress[2] = pool[3];\\r\\n        _mint(address(this), 500 * 10000 * 10 ** decimals());  // 500w\\r\\n\\r\\n        _transfer(address(this),pool[0], 80 * 10000 * 10 ** decimals()); // \u673a\u6784\u77ff\u6c60 80w\\r\\n        _transfer(address(this),pool[1], 10 * 10000 * 10 ** decimals()); // \u6253\u5e95\u6c60 10w\\r\\n        _transfer(address(this),pool[2], 30 * 10000 * 10 ** decimals()); // \u8425\u9500\u6c60 30w\\r\\n        // _mint(pool[0],80 * 10000 * 10 ** decimals());\\r\\n        // _mint(pool[1],10 * 10000 * 10 ** decimals());\\r\\n        // _mint(pool[2],30 * 10000 * 10 ** decimals());\\r\\n        returnAddress[0] = pool[1];\\r\\n        returnAddress[1] = pool[8];\\r\\n        uniswapV2Pair = IUniswapV2Factory(router.factory()).createPair(address(this),USDTAddress);\\r\\n        db = IWhoSql(pool[6]);\\r\\n        setPermissioin(pool[7]);\\r\\n        allFee[4] = 9;\\r\\n        allFee[0] = 3;\\r\\n        allFee[1] = 6;\\r\\n        allFee[2] = 3;\\r\\n        allFee[3] = 3;\\r\\n        WHTCAddress = pool[9];\\r\\n    }\\r\\n    function setWHTCAddress(address _address) public payable isAdmin(msg.sender){\\r\\n        WHTCAddress = _address;\\r\\n    }\\r\\n    // \u8bbe\u7f6e\u624b\u7eed\u8d39\\r\\n    function setSwapPoundage(uint ratio) public payable isAdmin(msg.sender){\\r\\n        allFee[4] = ratio;\\r\\n    }\\r\\n    // \u8bbe\u7f6eWHO\u56de\u6d41\u5730\u5740\\r\\n    function setReturnLiquidityWHOAddress(address _address) public payable isAdmin(msg.sender){\\r\\n        returnAddress[2] = _address;\\r\\n    }\\r\\n    // \u8bbe\u7f6eWHD\u56de\u6d41\u5730\u5740\\r\\n    function setReturnLiquidityWHDAddress(address _address) public payable isAdmin(msg.sender){\\r\\n        returnAddress[1] = _address;\\r\\n    }\\r\\n    // \u8bbe\u7f6e\u56de\u6d41\\r\\n    function setAllFee(uint[5] memory ratio) public payable isAdmin(msg.sender){\\r\\n        allFee = ratio;\\r\\n    }\\r\\n    // function setReturnLiquidityFeeWHD(uint ratio) public payable isAdmin(msg.sender){\\r\\n    //     allFee[1] = ratio;\\r\\n    // }\\r\\n    // // \u8bbe\u7f6e\u9500\u6bc1\\r\\n    // function setBurnFee(uint ratio) public payable isAdmin(msg.sender){\\r\\n    //     allFee[2] = ratio;\\r\\n    // }\\r\\n    // // \u8bbe\u7f6e\u94f8\u9020\u91d1\u989d\\r\\n    // function setMintFee(uint ratio) public payable isAdmin(msg.sender){\\r\\n    //     allFee[3] = ratio;\\r\\n    // }\\r\\n    // \u83b7\u53d6\u5f53\u524d\u5404\u7c7b\u9500\u6bc1\u91d1\u989d\\r\\n    function getFee() public view returns (uint[5] memory ratios){\\r\\n        // ratios[0] = allFee[4];\\r\\n        // ratios[1] = allFee[0];\\r\\n        // ratios[2] = allFee[1];\\r\\n        // ratios[3] = allFee[2];\\r\\n        // ratios[4] = allFee[3];\\r\\n        return allFee;\\r\\n    }\\r\\n    // @dev \u8bbe\u7f6eDao\u5408\u7ea6\u5730\u5740\\r\\n    function setDaoContract(address dao) public payable isAdmin(msg.sender){\\r\\n        daoAddress = dao;\\r\\n        if(isTransferDao == false){\\r\\n            // \u7b97\u529b\u77ff\u6c60\\r\\n            // _mint(daoAddress,380 * 10000 * 10 ** decimals());\\r\\n            _transfer(address(this),daoAddress, 380 * 10000 * 10 ** decimals());\\r\\n            // \u6e05\u7a7a\u6570\u636e\\r\\n            uint Calculate = db.getCalculatePool();\\r\\n            db.setCalculatePool(Calculate,\\\"sub\\\");\\r\\n            // \u6dfb\u52a0\u7b97\u529b\u77ff\u6c60\u8bb0\u5f55\\r\\n            db.setCalculatePool(380 * 10000 * 10 ** decimals(),\\\"add\\\");\\r\\n            db.setTotalMintAmount(500 * 10000 * 10 ** decimals());\\r\\n\\r\\n            isTransferDao = true;            \\r\\n        }\\r\\n    }\\r\\n    // \u5408\u7ea6\u5185\u90e8\u8f6c\u8d26\\r\\n    function _safeTransfer(address token, address to, uint value) private {\\r\\n        globalSend(token,to,value,SELECTOR);\\r\\n    }\\r\\n    // function _safeApprove(address token,address to,uint value) private {\\r\\n    //     (bool success, bytes memory data) = token.call(abi.encodeWithSelector(APPROVESELECTOR, to, value));\\r\\n    //     require(success && (data.length == 0 || abi.decode(data, (bool))), 'WHOToken: approve failed');\\r\\n    // }\\r\\n\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"WHOToken: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    //  @dev \u91cd\u5199transferFrom\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public override virtual returns (bool) {\\r\\n        address spender = msg.sender;\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        fee(from,to,amount);\\r\\n        return true;\\r\\n    }\\r\\n    function fee(address from,address to,uint amount) internal virtual isTrade{\\r\\n        if(isSolidity == false){\\r\\n            if(from == routerAddress|| to == uniswapV2Pair || from == uniswapV2Pair){\\r\\n                _transfer(from, address(this), amount);\\r\\n                // _transfer(address(this), to, amount);\\r\\n                _transfer(address(this),daoAddress, amount / 100 * 5);\\r\\n                IWhoSql(db.getSql()[2]).setOfficeTotal(amount / 100 * 5,\\\"add\\\");\\r\\n                _transfer(address(this),daoAddress, amount / 100 * 3);\\r\\n\\r\\n                // uint _total = db.getLpTotal(\\\"WHO\\\");\\r\\n                // address[] memory users = db.getLpUser();\\r\\n                // if(_total>100000 * 10 **18){\\r\\n                //     uint _newTotal = _total - 100000 * 10 **18;\\r\\n                //     for(uint i = 0;i<users.length;i++){\\r\\n                //         uint lpTotal = db.getUserLpTotal(users[i], \\\"WHO\\\");\\r\\n                //         IWhoSql(db.getSql()[2]).addAddressTypeIncome(users[i],\\\"lp\\\",LWHO.TokenType.WHO,(amount / 100 * 3) * lpTotal/_newTotal);\\r\\n                //         db.setWalletNum(users[i],LWHO.TokenType.WHO,(amount / 100 * 3) * lpTotal/_newTotal,\\\"add\\\");\\r\\n                //     }\\r\\n                // }\\r\\n                IWhoSql(db.getSql()[2]).setLPUserdistributionTotal(amount / 100 * 3,LWHO.TokenType.WHO,\\\"add\\\");\\r\\n                _burn(address(this), amount / 100 * 2);\\r\\n                db.setBurnedTotalAmount(amount / 100 * 2);\\r\\n                _transfer(address(this), returnAddress[2], amount / 100 * 2);\\r\\n                db.addPoolAmount(\\\"WHO\\\",amount / 100 * 2);\\r\\n                _transfer(address(this),daoAddress, amount / 100 * 1);\\r\\n                IWhoSql(db.getSql()[2]).setGeneralPartnerTotal(LWHO.TokenType.WHO,amount / 100 * 1,\\\"add\\\");\\r\\n                // LWHO.partner[] memory part = IWhoSql(db.getSql()[1]).getGeneralPartner();\\r\\n                // (LWHO.partner[] memory npart,uint b)= LWHO.getPart(part);\\r\\n                // // uint b = 0;\\r\\n                // // for(uint a=0;a<part.length;a++){\\r\\n                // //     if(part[a].isExist){\\r\\n                // //         npart[b] = part[a];\\r\\n                // //         b++;\\r\\n                // //     }\\r\\n                // // }\\r\\n                // for(uint c=0;c<npart.length;c++){\\r\\n                //     IWhoSql(db.getSql()[2]).addAddressTypeIncome(npart[c].user,\\\"community\\\",LWHO.TokenType.WHO,(amount/100 * 1)/b);\\r\\n                //     db.setWalletNum(npart[c].user,LWHO.TokenType.WHO,(amount / 100 * 1)/b,\\\"add\\\");\\r\\n                // }\\r\\n                _transfer(address(this), to, amount / 100 * 87);\\r\\n            }else{\\r\\n                _transfer(from, to, amount);\\r\\n            }\\r\\n        }else{\\r\\n            _transfer(from, to, amount);\\r\\n        }\\r\\n    }\\r\\n    function transfer(address to, uint256 amount) public override virtual returns (bool) {\\r\\n        fee(msg.sender,to,amount);\\r\\n        return true;\\r\\n    }\\r\\n    // \u5220\u9664\u6d41\u52a8\u6027 (\u5220\u9664\u5168\u90e8)\\r\\n    function removeLiquidityUser(uint liquidity) public payable isTrade{\\r\\n        isSolidity = true;\\r\\n        IUniswapV2Pair(uniswapV2Pair).transferFrom(msg.sender,address(this),liquidity);\\r\\n        // IUniswapV2Pair(uniswapV2Pair).approve(routerAddress,liquidity);\\r\\n        bytes4 approve = bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        globalSend(uniswapV2Pair,routerAddress,liquidity,approve);\\r\\n        (uint amountA,uint amountB) = router.removeLiquidity(address(this),USDTAddress,liquidity,0,0,address(this),block.timestamp);\\r\\n        if(IWhoSql(db.getSql()[1]).isTradingWhiteList(msg.sender) == false&&IWhoSql(db.getSql()[1]).isOfficeAddress(msg.sender) == false){\\r\\n            _safeTransfer(address(this),returnAddress[2],amountA * allFee[0] / 100); // \u56de\u6d41WHO\\r\\n            _safeTransfer(address(this),returnAddress[1],amountA * allFee[1] / 100); // \u56de\u6d41WHD\\r\\n            _safeTransfer(USDTAddress,returnAddress[2],amountB * allFee[0] / 100); // \u56de\u6d41WHO\\r\\n            _safeTransfer(USDTAddress,returnAddress[1],amountB * allFee[1] / 100); //\u56de\u6d41WHD\\r\\n            _safeTransfer(address(this),msg.sender,amountA * (100 - allFee[4]) / 100); // \u4ea4\u6613\u624b\u7eed\u8d39\\r\\n            _safeTransfer(USDTAddress,msg.sender,amountB * (100 - allFee[4]) / 100);// \u4ea4\u6613\u624b\u7eed\u8d39\\r\\n            db.addrmLpRecord(msg.sender,LWHO.LpUint(block.timestamp,amountA * (100 - allFee[4]) / 100,amountB * (100 - allFee[4]) / 100,\\\"WHO\\\"));\\r\\n        }else{\\r\\n            _safeTransfer(address(this),msg.sender,amountA);\\r\\n            _safeTransfer(USDTAddress,msg.sender,amountB);\\r\\n            db.addrmLpRecord(msg.sender,LWHO.LpUint(block.timestamp,amountA,amountB,\\\"WHO\\\"));\\r\\n        }\\r\\n        isSolidity = false;\\r\\n    }\\r\\n    // @dev \u589e\u52a0\u6d41\u52a8\u6027\u65b9\u6cd5 amountADesired \u5185\u90e8\u65b9\u6cd5 \u4f7f\u7528\u524d\u9700\u8981\u8f6c\u5165\u90e8\u5206 USDT \u5230\u5408\u7ea6\\r\\n    function addLiquidityUser(uint tokenAmount,uint USDTAmount) public payable isTrade{\\r\\n        isSolidity = true;\\r\\n        uint[3] memory YMD = timeStamp.getYMD(block.timestamp);\\r\\n        _transfer(msg.sender,address(this),tokenAmount);\\r\\n        IBEP20(USDTAddress).transferFrom(msg.sender, address(this), USDTAmount);\\r\\n        if(!IWhoSql(db.getSql()[1]).isTradingWhiteList(msg.sender)){\\r\\n            if(!IWhoSql(db.getSql()[1]).isOfficeAddress(msg.sender)){\\r\\n                // _safeTransfer(address(this), PoundageAddress, tokenAmount / 100 * swapPoundage);\\r\\n                // _safeTransfer(USDTAddress,PoundageAddress,USDTAmount / 100 * swapPoundage);\\r\\n                _safeTransfer(address(this), returnAddress[2], tokenAmount / 100 * allFee[0]); // \u56de\u6d41WHO\\r\\n                uint burnAmount = tokenAmount/ 100 * allFee[2];\\r\\n                _burn(address(this),burnAmount); //\u9500\u6bc1\\r\\n                db.setBurnedTotalAmount(burnAmount);\\r\\n                // \u94f8\u9020WHTC\u63a5\u53e3\\r\\n                uint makeAmount = tokenAmount / 100 * allFee[3];\\r\\n                uint LiquidityAmount = tokenAmount / 100 * (100 - allFee[4]); // \u4ea4\u6613\u624b\u7eed\u8d39\\r\\n                IWHTC(WHTCAddress).make(makeAmount, msg.sender);\\r\\n                _burn(address(this),makeAmount);\\r\\n                db.setBurnedTotalAmount(makeAmount);\\r\\n                // \u8f6cU\u5230\u6307\u5b9a\u94b1\u5305\u8fdb\u884c\u6dfb\u52a0\u6d41\u52a8\u6027\\r\\n                _safeTransfer(USDTAddress, returnAddress[2], USDTAmount / 100 * allFee[0]); //\u56de\u6d41WHO\\r\\n                _safeTransfer(USDTAddress, returnAddress[1], USDTAmount / 100 * allFee[1]); // \u56de\u6d41WHD\\r\\n                IBEP20(address(this)).approve(routerAddress,LiquidityAmount);\\r\\n                IBEP20(USDTAddress).approve(routerAddress,USDTAmount);\\r\\n                db.setUserLPStartTime(msg.sender,block.timestamp);\\r\\n                (uint amountA,uint amountB,uint liquidity) = router.addLiquidity(address(this), USDTAddress, LiquidityAmount, USDTAmount / 100 * (100 - allFee[4]), 0, 0, msg.sender, block.timestamp);\\r\\n                if(amountA>0){\\r\\n                    _safeTransfer(address(this), msg.sender, LiquidityAmount - amountA);\\r\\n                }else if(amountB>0){\\r\\n                    _safeTransfer(USDTAddress, msg.sender, USDTAmount / 100 * (100 - allFee[4]) - amountB);\\r\\n                }\\r\\n                delete liquidity;\\r\\n                db.addLpRecord(msg.sender, LWHO.LpUint(block.timestamp,LiquidityAmount,USDTAmount / 100 * (100 - allFee[4]),\\\"WHO\\\"));\\r\\n            }else{\\r\\n                IBEP20(address(this)).approve(routerAddress,tokenAmount);\\r\\n                IBEP20(USDTAddress).approve(routerAddress,USDTAmount);\\r\\n                (uint amountA,uint amountB,uint liquidity) = router.addLiquidity(address(this), USDTAddress, tokenAmount, USDTAmount, 0, 0, msg.sender, block.timestamp);\\r\\n                if(amountA>0){\\r\\n                    _safeTransfer(address(this), msg.sender, tokenAmount - amountA);\\r\\n                }else if(amountB>0){\\r\\n                    _safeTransfer(USDTAddress, msg.sender, USDTAmount - amountB);\\r\\n                }\\r\\n                delete liquidity;\\r\\n                db.addLpRecord(msg.sender, LWHO.LpUint(block.timestamp,tokenAmount,USDTAmount,\\\"WHO\\\"));\\r\\n            }\\r\\n        }else{\\r\\n            IBEP20(address(this)).approve(routerAddress,tokenAmount);\\r\\n            IBEP20(USDTAddress).approve(routerAddress,USDTAmount);\\r\\n            (uint amountA,uint amountB,uint liquidity) = router.addLiquidity(address(this), USDTAddress, tokenAmount, USDTAmount, 0, 0, msg.sender, block.timestamp);\\r\\n            if(amountA>0){\\r\\n                _safeTransfer(address(this), msg.sender, tokenAmount - amountA);\\r\\n            }else if(amountB>0){\\r\\n                _safeTransfer(USDTAddress, msg.sender, USDTAmount - amountB);\\r\\n            }\\r\\n            delete liquidity;\\r\\n            db.addLpRecord(msg.sender, LWHO.LpUint(block.timestamp,tokenAmount,USDTAmount,\\\"WHO\\\"));\\r\\n        }\\r\\n        db.addAddLpUser(msg.sender);\\r\\n        db.addDayLPCount(YMD[0],YMD[1],YMD[2],tokenAmount);\\r\\n        isSolidity = false;\\r\\n    }\\r\\n    function globalSend(address token,address to,uint value,bytes4 sendData) internal {\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(sendData, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'WHOToken: send failed');\\r\\n    }\\r\\n    // @dev \u4ee3\u5e01\u4e0e\u4ee3\u5e01\u4ea4\u6362\\r\\n    function swapTokensForExactTokens(uint amountOut,address[] memory tokens) public isTrade{\\r\\n        isSolidity = true;\\r\\n        string memory tokenName;\\r\\n        string memory toName;\\r\\n        if(tokens[0] == address(this)&&tokens[1] == USDTAddress){\\r\\n            tokenName = \\\"WHO\\\";\\r\\n            toName = \\\"USDT\\\";\\r\\n        }else if(tokens[0] == USDTAddress&&tokens[1] == address(this)){\\r\\n            tokenName = \\\"USDT\\\";\\r\\n            toName = \\\"WHO\\\";\\r\\n        }else{\\r\\n            revert(\\\"This token is not supported\\\");\\r\\n        }\\r\\n        IBEP20(tokens[0]).transferFrom(msg.sender, address(this), amountOut);\\r\\n        uint remain;\\r\\n        if(!IWhoSql(db.getSql()[1]).isTradingWhiteList(msg.sender)&&!IWhoSql(db.getSql()[1]).isOfficeAddress(msg.sender)){\\r\\n            distributionFee(tokens[0],msg.sender,amountOut);\\r\\n            remain = amountOut / 100 * (100 - 13);\\r\\n        }else{\\r\\n            remain = amountOut;\\r\\n        }\\r\\n        IBEP20(tokens[0]).approve(routerAddress, remain);\\r\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(remain,0, tokens,msg.sender, block.timestamp);\\r\\n        db.addExchangeRecord(msg.sender,LWHO.exChangeUint({\\r\\n            createTime:block.timestamp,\\r\\n            amount:amountOut,\\r\\n            tokenName:tokenName,\\r\\n            toName:toName\\r\\n        }));\\r\\n        isSolidity = false;\\r\\n    }\\r\\n    // \u7236\u7ea7\u662f\u5426\u6ee1\u8db3\u6761\u4ef6\\r\\n    function fatherMeet(address _token,address user,uint amount) internal {\\r\\n        uint fatherAmount = balanceOf(user);\\r\\n        (uint112 usdtTotal,uint112 whoTotal,) = IUniswapV2Pair(uniswapV2Pair).getReserves();\\r\\n        uint whoAmount = (usdtTotal * 10 ** decimals())/whoTotal;\\r\\n        uint plgWho = db.getPlgTokenNum(user,\\\"WHO\\\");\\r\\n        uint LpTotal = db.getUserLpTotal(user,\\\"USDT\\\");\\r\\n        if(fatherAmount>=whoAmount * 500){ \\r\\n            if(plgWho>100&&LpTotal>100){\\r\\n                _safeTransfer(_token, user, amount);\\r\\n            }else{\\r\\n                _safeTransfer(_token, daoAddress, amount);\\r\\n                IWhoSql(db.getSql()[2]).setOfficeTotal(amount,\\\"add\\\");\\r\\n            }\\r\\n        }else{\\r\\n            _safeTransfer(_token, daoAddress, amount);\\r\\n            IWhoSql(db.getSql()[2]).setOfficeTotal(amount,\\\"add\\\");\\r\\n        }\\r\\n    }\\r\\n    // \u5206\u914d\u624b\u7eed\u8d39 user \u7528\u6237 amount \u8f6c\u8d26\u603b\u8d39\u7528\\r\\n    function distributionFee(address _token,address user,uint amount) internal {\\r\\n        address[] memory father = IWhoSql(db.getSql()[1]).getFathers(user);\\r\\n        if(father[0]!=address(0)){\\r\\n            for(uint i = 0;i<father.length;i++){\\r\\n                uint _amount = LWHO.fatherMeetFee(amount,i);\\r\\n                if(father[i]!=address(0)){\\r\\n                    if(_amount!=0){\\r\\n                        fatherMeet(_token,father[i],_amount);\\r\\n                    }\\r\\n                }else{\\r\\n                    _safeTransfer(_token,daoAddress,_amount);\\r\\n                }\\r\\n                // if(i>=0&&i<3){\\r\\n                //     fatherMeet(_token,father[i],amount / 100 * 1);\\r\\n                // }else if(i>=3&&i<5){\\r\\n                //     fatherMeet(_token,father[i],amount / 1000 * 5);\\r\\n                // }else if(i>=5&&i<10){\\r\\n                //     fatherMeet(_token,father[i],amount / 1000 * 2);\\r\\n                // }\\r\\n            }\\r\\n        }else{\\r\\n            _safeTransfer(_token, daoAddress, amount / 100 * 5);\\r\\n        }\\r\\n        _safeTransfer(_token, daoAddress, amount / 100 * 3);\\r\\n        // uint _total = db.getLpTotal(\\\"WHO\\\");\\r\\n        // address[] memory users = db.getLpUser();\\r\\n        // if(_total>100000 * 10 **18){\\r\\n        //     uint _newTotal = _total - 100000 * 10 **18;\\r\\n        //     for(uint i = 0;i<users.length;i++){\\r\\n        //         uint lpTotal = db.getUserLpTotal(users[i], \\\"WHO\\\");\\r\\n        //         LWHO.TokenType _tokenType;\\r\\n        //         if(_token == address(this)){\\r\\n        //             _tokenType = LWHO.TokenType.WHO;\\r\\n        //         }else{\\r\\n        //             _tokenType = LWHO.TokenType.USDT;\\r\\n        //         }\\r\\n        //         IWhoSql(db.getSql()[2]).addAddressTypeIncome(users[i],\\\"lp\\\",_tokenType,(amount / 100 * 3) * lpTotal/_newTotal);\\r\\n        //         db.setWalletNum(users[i],_tokenType,(amount / 100 * 3)* lpTotal/_newTotal,\\\"add\\\");\\r\\n        //     }\\r\\n        // }\\r\\n        LWHO.TokenType tType;\\r\\n        if(_token == address(this)){\\r\\n            tType = LWHO.TokenType.WHO;\\r\\n        }else{\\r\\n            tType = LWHO.TokenType.USDT;\\r\\n        }\\r\\n        IWhoSql(db.getSql()[2]).setLPUserdistributionTotal(amount / 100 * 3,tType,\\\"add\\\");\\r\\n        if(_token == address(this)){\\r\\n            _burn(address(this), amount / 100 * 2); //\\r\\n            db.setBurnedTotalAmount(amount / 100 * 2);\\r\\n        }else{\\r\\n            _safeTransfer(_token, daoAddress, amount / 100 * 2);\\r\\n        }\\r\\n        _safeTransfer(_token,returnAddress[2],amount / 100 * 2);\\r\\n        // _transfer(address(this), returnAddress[0], amount / 100 * 2);\\r\\n        db.addPoolAmount(\\\"WHO\\\",amount / 100 * 2);\\r\\n        // _transfer(address(this),daoAddress, amount / 100 * 1);\\r\\n        _safeTransfer(_token,daoAddress,amount / 100 * 1);\\r\\n        if(_token == address(this)){\\r\\n            IWhoSql(db.getSql()[2]).setGeneralPartnerTotal(LWHO.TokenType.WHO,amount / 100 * 1,\\\"add\\\");\\r\\n        }else{\\r\\n            IWhoSql(db.getSql()[2]).setGeneralPartnerTotal(LWHO.TokenType.USDT,amount / 100 * 1,\\\"add\\\");\\r\\n        }\\r\\n        // LWHO.partner[] memory part = IWhoSql(db.getSql()[1]).getGeneralPartner();\\r\\n        // (LWHO.partner[] memory npart,uint b) = LWHO.getPart(part);\\r\\n        // // LWHO.partner[] memory npart = new LWHO.partner[](part.length);\\r\\n        // // uint b = 0;\\r\\n        // // for(uint a=0;a<part.length;a++){\\r\\n        // //     if(part[a].isExist){\\r\\n        // //         npart[b] = part[a];\\r\\n        // //         b++;\\r\\n        // //     }\\r\\n        // // }\\r\\n        // for(uint c=0;c<npart.length;c++){\\r\\n        //     LWHO.TokenType _typeToken;\\r\\n        //     if(_token == address(this)){\\r\\n        //         // db.addSupernumeraryIncome(\\\"WHO\\\",npart[c].user,(amount / 100 * 1)/b);\\r\\n        //         _typeToken = LWHO.TokenType.WHO;\\r\\n        //     }else{\\r\\n        //         // db.addSupernumeraryIncome(\\\"USDT\\\",npart[c].user,(amount / 100 * 1)/b);\\r\\n        //         // IWhoSql(db.getSql()[2]).addAddressTypeIncome(npart[c].user,\\\"community\\\",LWHO.TokenType.USDT,(amount/100 * 1)/b);\\r\\n        //         // db.setWalletNum(npart[c].user,LWHO.TokenType.USDT,(amount/100 * 1)/b,\\\"add\\\");\\r\\n        //         _typeToken = LWHO.TokenType.USDT;\\r\\n        //     }\\r\\n        //     IWhoSql(db.getSql()[2]).addAddressTypeIncome(npart[c].user,\\\"community\\\",_typeToken,(amount/100 * 1)/b);\\r\\n        //     db.setWalletNum(npart[c].user,_typeToken,(amount/100 * 1)/b,\\\"add\\\");\\r\\n        // }\\r\\n    }\\r\\n    // \u63d0U\u63a5\u53e3(\u6dfb\u52a0\u6d41\u52a8\u6027\u4f1a\u7559\u4e0b\u90e8\u5206U\uff0c\u8fd9\u90e8\u5206U\u7528\u4e8e\u4eba\u5de5\u56de\u6d41\u5e95\u6c60\u7528)\\r\\n    function withdrawalUSDT(uint amount) public payable isAdmin(msg.sender){\\r\\n        _safeTransfer(USDTAddress,daoAddress,amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@sphynxswap/sphynx-swap-lib/contracts/token/BEP20/BEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.4.0;\\r\\n\\r\\nimport '../../access/Ownable.sol';\\r\\n// import '../../GSN/Context.sol';\\r\\nimport './IBEP20.sol';\\r\\nimport '../../math/SafeMath.sol';\\r\\nimport '../../utils/Address.sol';\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IBEP20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {BEP20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-BEP20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of BEP20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IBEP20-approve}.\\r\\n */\\r\\ncontract BEP20 is IBEP20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\r\\n     * a default value of 18.\\r\\n     *\\r\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\r\\n     *\\r\\n     * All three of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_){\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _decimals = 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the bep token owner.\\r\\n     */\\r\\n    function getOwner() external override view returns (address) {\\r\\n        return owner();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token name.\\r\\n     */\\r\\n    function name() public override view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token decimals.\\r\\n     */\\r\\n    function decimals() public override view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token symbol.\\r\\n     */\\r\\n    function symbol() public override view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public override view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public override view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public override virtual returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public override view returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {BEP20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {BEP20};\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for `sender`'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public override virtual returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            msg.sender,\\r\\n            _allowances[sender][msg.sender].sub(amount, 'BEP20: transfer amount exceeds allowance')\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {BEP20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {BEP20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n        _approve(\\r\\n            msg.sender,\\r\\n            spender,\\r\\n            _allowances[msg.sender][spender].sub(subtractedValue, 'BEP20: decreased allowance below zero')\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `msg.sender` must be the token owner\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `msg.sender`, decreasing the total supply.\\r\\n     *\\r\\n     */\\r\\n    function burn(uint256 amount) public returns (bool) {\\r\\n        _burn(msg.sender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), 'BEP20: transfer from the zero address');\\r\\n        require(recipient != address(0), 'BEP20: transfer to the zero address');\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, 'BEP20: transfer amount exceeds balance');\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal {\\r\\n        require(account != address(0), 'BEP20: mint to the zero address');\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal {\\r\\n        require(account != address(0), 'BEP20: burn from the zero address');\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, 'BEP20: burn amount exceeds balance');\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        require(owner != address(0), 'BEP20: approve from the zero address');\\r\\n        require(spender != address(0), 'BEP20: approve to the zero address');\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\r\\n     * from the caller's allowance.\\r\\n     *\\r\\n     * See {_burn} and {_approve}.\\r\\n     */\\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _burn(account, amount);\\r\\n        _approve(\\r\\n            account,\\r\\n            msg.sender,\\r\\n            _allowances[account][msg.sender].sub(amount, 'BEP20: burn amount exceeds allowance')\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"solidity_lib/Permission/Permission_abstract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport './Permission_interface.sol';\\r\\nabstract contract permission{\\r\\n    IPermission public Perm;\\r\\n    address permissionAddress;\\r\\n    // \u5408\u7ea6\u662f\u5426\u4e3a\u6240\u6709\u8005\\r\\n    modifier _owner{\\r\\n        Perm._Owner();\\r\\n        _;\\r\\n    }\\r\\n    // \u4fe1\u606f\u8c03\u7528\u8005\u662f\u5426\u4e3a\u6240\u6709\u8005\\r\\n    modifier isOwner(address user){\\r\\n        Perm._IsOwner(user);\\r\\n        _;\\r\\n    }\\r\\n    // \u5408\u7ea6\u662f\u5426\u4e3a\u7ba1\u7406\u5458\\r\\n    modifier _admin() {\\r\\n        Perm._Admin();\\r\\n        _;\\r\\n    }\\r\\n    // \u4fe1\u606f\u8c03\u7528\u8005\u662f\u5426\u4e3a\u7ba1\u7406\u5458\\r\\n    modifier isAdmin(address user){\\r\\n        Perm._IsAdmin(user);\\r\\n        _;\\r\\n    }\\r\\n    // \u5408\u7ea6\u662f\u5426\u4e3a\u5c01\u7981\u5bf9\u8c61\\r\\n    modifier _ban(){\\r\\n        Perm._Ban();\\r\\n        _;\\r\\n    }\\r\\n    // \u4fe1\u606f\u8c03\u7528\u8005\u662f\u5426\u4e3a\u5c01\u7981\u5bf9\u8c61\\r\\n    modifier isBan(address user){\\r\\n        Perm._IsBan(user);\\r\\n        _;\\r\\n    }\\r\\n    // \u5408\u7ea6\u662f\u5426\u4e3a\u6570\u636e\u5e93\u64cd\u63a7\u8005\\r\\n    modifier _sql(){\\r\\n        Perm._Sql();\\r\\n        _;\\r\\n    }\\r\\n    // \u4fe1\u606f\u8c03\u7528\u8005\u662f\u5426\u4e3a\u6570\u636e\u5e93\u64cd\u63a7\u8005\\r\\n    modifier isSql(address user){\\r\\n        Perm._IsSql(user);\\r\\n        _;\\r\\n    }\\r\\n    function setPermissioin(address _address) internal {\\r\\n        Perm = IPermission(_address);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solidity_lib/Time/time.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n/* \\r\\n    \u65f6\u95f4\u5e93\uff1a\\r\\n    \u73b0\u6709\u65b9\u6cd5\uff1a\\r\\n    formatHms(uint timestamp) \\r\\n    \u8fd4\u56de\u503c\uff1a\\r\\n    uint[] 0\uff1a\u65f6 1\uff1a\u5206 2\uff1a\u79d2\\r\\n */\\r\\npragma solidity ^0.8.0;\\r\\nlibrary timeStamp {    \\r\\n    // \u6c42\u4e00\u5929\u5185\u7684\u65f6\u5206\u79d2\\r\\n    function formatTime(uint timestamp) internal pure returns (uint[3] memory time){\\r\\n        timestamp = ((timestamp % (1 days * 365)) % (1 days * 30)) % 1 days;\\r\\n        uint H = timestamp / 3600;\\r\\n        timestamp = timestamp % 3600;\\r\\n        uint m = timestamp / 60;\\r\\n        timestamp = timestamp % 60;\\r\\n        uint s = timestamp;\\r\\n        // \u589e\u52a0\u65f6\u533a\\r\\n        H = H + 8; \\r\\n        if(H>=24){\\r\\n            H = H - 24;\\r\\n        }\\r\\n        time[0] = H;\\r\\n        time[1] = m;\\r\\n        time[2] = s;\\r\\n    }\\r\\n    // \u9ed8\u8ba40\u65f6\u533a\\r\\n    function getYMD(uint timestamp) internal pure returns(uint[3] memory time){\\r\\n        return getYMD(timestamp,0);\\r\\n    }\\r\\n    // \u6c42\u5e74\u6708\u65e5\\r\\n    function getYMD(uint timestamp,uint timeZone) internal pure returns(uint[3] memory time){\\r\\n        timestamp = timestamp + timeZone * 1 hours; // UTC\u65f6\u533a\\r\\n        // \u6da6\u5e74\\r\\n        uint8[12] memory leapYear = [31,29,31,30,31,30,31,31,30,31,30,31];\\r\\n        // \u5e73\u5e74\\r\\n        uint8[12] memory noleapYear = [31,28,31,30,31,30,31,31,30,31,30,31];\\r\\n        uint totalDay = timestamp / 1 days;\\r\\n        uint Year = 1970 + (totalDay / 365);\\r\\n        bool isLeap;\\r\\n        if(Year % 4 == 0&&Year%100!=0){\\r\\n            isLeap = true;\\r\\n        }else if(Year % 400 != 0&&Year%100 == 0){\\r\\n            isLeap = false;\\r\\n        }else if(Year % 400 == 0){\\r\\n            isLeap = true;\\r\\n        }else{\\r\\n            isLeap = false;\\r\\n        }\\r\\n        uint Month;\\r\\n        uint Day;\\r\\n        uint tDay;\\r\\n        bool isDay;\\r\\n        if(isLeap){\\r\\n            tDay = totalDay - ((Year-1970) * 366);\\r\\n            for(uint i = 0;i<12;i++){\\r\\n                if(tDay > leapYear[i]){\\r\\n                    tDay -= leapYear[i];\\r\\n                }else{\\r\\n                    if(!isDay){\\r\\n                        isDay = true;\\r\\n                        Day = tDay;\\r\\n                        Month = i + 1;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if(Day<=12){\\r\\n                time[2] = leapYear[Month-1] - (12 - Day);\\r\\n            }else{\\r\\n                time[2] = Day - 12;\\r\\n            }\\r\\n        }else{\\r\\n            tDay = totalDay - ((Year-1970) * 365);\\r\\n            for(uint i=0;i<12;i++){\\r\\n                if(tDay > noleapYear[i]){\\r\\n                    tDay -= noleapYear[i];\\r\\n                }else{\\r\\n                    if(!isDay){\\r\\n                        isDay = true;\\r\\n                        Day = tDay;\\r\\n                        Month = i + 1;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if(Day<12){\\r\\n                time[2] = noleapYear[Month-1] - (11 - Day);\\r\\n                Month = Month - 1;\\r\\n            }else if(Day == 12){\\r\\n                time[2] = noleapYear[Month-1];\\r\\n            }else{\\r\\n                time[2] = Day - 12;\\r\\n            }\\r\\n        }\\r\\n        time[0] = Year;\\r\\n        time[1] = Month;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"library/V2Library/UniswapV2Library.sol\": {\r\n      \"content\": \"/**\\r\\n\u7531\u4e8e\u539f\u751f\u7684uniswap\u4e2dpairFor\u65b9\u6cd5\u5bf9\u4e8esolidity0.8.0\u4ee5\u4e0a\u7684\u7248\u672c\u4e0d\u517c\u5bb9 \u6545\u5355\u72ecnachul/ai\u4f5c\u4e3alibrary\\r\\n */\\r\\n// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity >=0.5.0;\\r\\nimport \\\"@sphynxswap/sphynx-swap-lib/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\r\\n\\r\\nlibrary UniswapV2Library {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\r\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\r\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\r\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\r\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\r\\n    }\\r\\n\\r\\n    // fetches and sorts the reserves for a pair\\r\\n    function getReserves(address tokenA, address tokenB,address pair) internal view returns (uint reserveA, uint reserveB) {\\r\\n        (address token0,) = sortTokens(tokenA, tokenB);\\r\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();\\r\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n    }\\r\\n\\r\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\r\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\r\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\r\\n        amountB = amountA.mul(reserveB) / reserveA;\\r\\n    }\\r\\n\\r\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\r\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\r\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\r\\n        uint amountInWithFee = amountIn.mul(997);\\r\\n        uint numerator = amountInWithFee.mul(reserveOut);\\r\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\r\\n        amountOut = numerator / denominator;\\r\\n    }\\r\\n\\r\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\r\\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\r\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\r\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\r\\n        amountIn = (numerator / denominator).add(1);\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountOut calculations on any number of pairs\\r\\n    function getAmountsOut(uint amountIn, address[] memory path,address pair) internal view returns (uint[] memory amounts) {\\r\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[0] = amountIn;\\r\\n        for (uint i; i < path.length - 1; i++) {\\r\\n            (uint reserveIn, uint reserveOut) = getReserves(path[i], path[i + 1],pair);\\r\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountIn calculations on any number of pairs\\r\\n    function getAmountsIn(uint amountOut, address[] memory path,address pair) internal view returns (uint[] memory amounts) {\\r\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[amounts.length - 1] = amountOut;\\r\\n        for (uint i = path.length - 1; i > 0; i--) {\\r\\n            (uint reserveIn, uint reserveOut) = getReserves(path[i - 1], path[i],pair);\\r\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"interface/who_sql/Iwhodb.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"../../library/LWHO.sol\\\";\\r\\ninterface IWhoSql{\\r\\n    function setSql(address _sql) external payable;\\r\\n    function getSql() external view returns (address[] memory);\\r\\n    function addAcconBounsUintToRecords(address accon, LWHO.BounsRecordUint memory bounsUint) external payable ;\\r\\n    function getAcconBounsRecords(address accon) external view returns(LWHO.BounsRecordUint[] memory) ;\\r\\n    function setWalletNum(address accon, LWHO.TokenType tType, uint amount, string memory smb) external ;\\r\\n    function getWalletNum(address accon, LWHO.TokenType tType) external view returns(uint);\\r\\n    function setTotalMintAmount(uint fixedAmount) external ;\\r\\n    function setBurnedTotalAmount(uint amount) external;\\r\\n    function setCurrencyAmount(uint amount) external;\\r\\n    function setPledgeTotalProfit(uint amount) external;\\r\\n    function setRefferTotalBonus(uint amount) external;\\r\\n    function getMarketStatistics() external view returns (LWHO.MarketStatistics memory) ;\\r\\n    function setPledgeLookPool(LWHO.PledgePoolBasicInfo memory plgPoolBasicInfo) external payable ;\\r\\n    function setPledgeNum(uint id,uint num,string memory _type) external payable;\\r\\n    function getPledgeNum(uint id) external view returns (uint num);\\r\\n    function getOnePledgeLockPool(LWHO.PoolType pType) external view returns(LWHO.PledgeLockPool memory plgLkP) ;\\r\\n    function setOnePledgeLockPool(LWHO.PoolType pType, LWHO.PledgePoolBasicInfo memory _poolInfo,LWHO.PoolStatisticsInfo memory _poolStsInfo) external payable ;\\r\\n    function setOnePledgeLockPoolLocked(LWHO.PoolType pType,LWHO.PledgeUint memory pUint) external;\\r\\n    function setSamePoolAlocRatio(uint value) external;\\r\\n    function setDiffPoolAlocRatio(uint value) external ;\\r\\n    function addPledgeUintToLockPool(LWHO.PledgeUint memory plgUint, LWHO.PoolType pType) external payable ;\\r\\n    function addPledgeAccount(address account) external ;\\r\\n    function isPledgeUser(address user) external view returns (bool);\\r\\n    function removePledgeAccount(address account) external ;\\r\\n    function getAcconts() external view returns(address[] memory) ;\\r\\n    function setAccountStaticProfit(address account,uint amount) external payable ;\\r\\n    function getAccountStaticProfit(address account) external view returns(uint) ;\\r\\n    function setAccountDymsProfit(address account,uint amount) external payable ;\\r\\n    function getAccountDymsProfit(address account) external view returns(uint) ;\\r\\n    function getPledgeUints(LWHO.PoolType pType) external view returns(LWHO.PledgeUint[] memory) ;\\r\\n    function getAcconPlgPoolWhoTotal(address accon,LWHO.PoolType pType) external view returns (uint amount) ;\\r\\n    function setAcconPlgPoolWhoTotal(address accon, LWHO.PoolType pType, uint amount, string memory smb) external ;\\r\\n    function setAcconPledgeUintRecords(address accon,  LWHO.PoolType pType, LWHO.PledgeUint memory plgUint) external payable ;\\r\\n    function getAcconPledgeUintRecords(address accon, LWHO.PoolType pType) external view returns (LWHO.PledgeUint[] memory plgUints);\\r\\n    function setAllPoolStatistic(LWHO.AllPoolStatistics memory _allPoolSts) external payable ;\\r\\n    function getAllPoolStatistic() external view returns(LWHO.AllPoolStatistics memory );\\r\\n    function setdWithdrawUintRecord(address accon, LWHO.WithdrawUint memory wdUint) external payable ;\\r\\n    function getWithdrawUintRecords(address accon) external view returns(LWHO.WithdrawUint[] memory records);\\r\\n    function addExchangeRecord(address user, LWHO.exChangeUint memory _exRecord) external payable;\\r\\n    function getExchangeRecord(address user) external view returns ( LWHO.exChangeUint[] memory _exRecord);\\r\\n    function addrmLpRecord(address user,LWHO.LpUint memory _lpRecord) external payable;\\r\\n    function addLpRecord(address user, LWHO.LpUint memory _lpRecord) external payable;\\r\\n    function addAddLpUser(address user) external payable;\\r\\n    function getLpUser() external view returns (address[] memory user);\\r\\n    function getLprmRecord(address user) external view returns (LWHO.LpUint[] memory _lpRecord);\\r\\n    function getLpRecord(address user) external view returns (LWHO.LpUint[] memory _lpRecord);\\r\\n    function getLpTotal(string memory _type) external view returns (uint);\\r\\n    function setuserLpTotal(address user,string memory _type,uint amount) external payable ;\\r\\n    function clearUserLpTotal(address user,string memory _type) external payable ;\\r\\n    function getUserLpTotal(address user,string memory _type) external view returns (uint);\\r\\n    function addPlgTokenNum(address user,string memory _type,uint num) external payable;\\r\\n    function getPlgTokenNum(address user,string memory _type) external view returns (uint num);\\r\\n    function addPoolAmount(string memory _type,uint amount) external payable;\\r\\n    function reducePoolAmount(string memory _type,uint amount) external payable;\\r\\n    function getPoolAmount(string memory _type) external view returns (uint);\\r\\n    function addSupernumeraryIncome(string memory _type,address user,uint amount) external payable;\\r\\n    function getSupernumeraryIncome(string memory _type,address user) external view returns (uint amount);\\r\\n    function setCalculatePool(uint amount,string memory _type) external payable ;\\r\\n    function getCalculatePool() external view returns (uint amount);\\r\\n    function setUserLPStartTime(address user,uint time) external payable;\\r\\n    function timeStatus(uint timestamp) external view returns(LWHO.timeUint memory _time);\\r\\n    function getUserLPStartTime(address user) external view returns (LWHO.timeUint[] memory time);\\r\\n    function changeUserCalculatePool(address user,uint amount,string memory _type) external payable ;\\r\\n    function getUserCalculatePool(address user) external view returns (uint amount);\\r\\n    function addDayLPCount(uint Year,uint Month,uint Day,uint amount) external payable;\\r\\n    function reduceDayLPCount(uint Year,uint Month,uint Day,uint amount) external payable;\\r\\n    function getDayLPCount(uint Year,uint Month,uint Day) external view returns (uint amount);\\r\\n    function setReferrers(address[] memory mys,address[] memory fathers) external payable;\\r\\n    function setReferrer(address my,address father) external payable;\\r\\n    function getFather(address user) external view returns(address father);\\r\\n    function getSon(address user) external view returns(address[] memory son);\\r\\n    function getFathers(address user) external view returns(address[] memory father);\\r\\n    function setTradingWhiteList(address user) external payable;\\r\\n    function deleteTradingWhiteList(address user) external payable;\\r\\n    function isTradingWhiteList(address user) external view returns (bool isTrading);\\r\\n    function setSeniorPartner(address user) external payable;\\r\\n    function deleteSeniorPartner(address user) external payable;\\r\\n    function getSeniorPartner() external view returns (LWHO.partner[] memory _senior);\\r\\n    function setGeneralPartner(address user) external payable;\\r\\n    function deleteGeneralPartner(address user) external payable;\\r\\n    function getGeneralPartner() external view returns (LWHO.partner[] memory _general);\\r\\n    function setOfficeAddress(address user) external payable;\\r\\n    function reduceOfficeAddress(address user) external payable;\\r\\n    function isOfficeAddress(address user) external view returns (bool isOffice);\\r\\n    function setAcconOnePoolDymsProfit(address account, LWHO.PoolType pType, uint amount) external payable ;\\r\\n    function getAcconOnePoolDymsProfit(address account, LWHO.PoolType pType) external payable returns(uint);\\r\\n    function setHasBuy(address account) external payable;\\r\\n    function getHasBuy(address accon) external view returns(bool);\\r\\n    function setIsDistribution(uint[3] memory date, uint id, bool b) external ;\\r\\n    function getIsDistribution(uint[3] memory date, uint id) external view returns(bool b);\\r\\n    function setIsTrade(bool _isTrade) external;\\r\\n    function getIsTrade() external view returns(bool);\\r\\n    function setInitTransWhiteList(address User) external payable;\\r\\n    function deleteInitTransWhiteList(address User) external payable;\\r\\n    function getInitTransWhiteList(address User) external view returns (bool);\\r\\n    function addAddressTypeIncome(address user,string memory _type,LWHO.TokenType tType,uint amount) external payable;\\r\\n    function getAddressTypeIncome(address user,string memory _type) external view returns (uint[2] memory);\\r\\n    function getUserTypeRecords(address user,string memory _type) external view returns(LWHO.typeIncomeUint[] memory _TypeIncomeRecords);\\r\\n    function setMigrateCurrentLockTotal(LWHO.PoolType pType, uint amount) external payable;\\r\\n    function getMigrateCurrentLockTotal(LWHO.PoolType pType) external view returns(uint);\\r\\n    function setMigrateTimeRecord(LWHO.PoolType pType, uint time) external payable;\\r\\n    function getMigrateTimeRecord(LWHO.PoolType pType) external view returns(uint); \\r\\n    function deleteOnePlgUints(LWHO.PoolType pType,uint index) external;\\r\\n    function setGeneralPartnerTotal(LWHO.TokenType tType,uint amount,string memory smb) external;\\r\\n    function getGeneralPartnerTotal(LWHO.TokenType tType) external view returns(uint);\\r\\n    function setOfficeTotal(uint amount,string memory smb) external;\\r\\n    function getOfficeTotal() external view returns(uint);\\r\\n    function setLPUserdistributionTotal(uint amount,LWHO.TokenType tType,string memory smb) external payable;\\r\\n    function getLPUserdistributionTotal(LWHO.TokenType tType) external view returns (uint);\\r\\n    function addUserLiquidity(address user,uint liquidity) external payable ;\\r\\n    function getUserLiquidity(address user) external view returns (uint liquidity);\\r\\n}\"\r\n    },\r\n    \"library/LWHO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: no-license\\r\\npragma solidity ^0.8.0;\\r\\nimport 'solidity_lib/Time/time.sol'; // \u65f6\u95f4\u5e93\\r\\nimport '../interface/who_sql/Iwhodb.sol'; //WHODB interface\\r\\nlibrary LWHO {\\r\\n    // \u679a\u4e3e\u7c7b\u578b\\r\\n    enum PoolType {lockOne, lockTwo, migrateOne, migrateTwo, all}\\r\\n    enum UintStatus {In, Out} \\r\\n    enum ValueType {Amount, Ratio}\\r\\n    enum poolStatus {Active, Inactive}\\r\\n    enum TokenType{USDT,WHO}\\r\\n\\r\\n    //\u8c03\u53c2\u7ed3\u6784\u4f53\\r\\n\\r\\n    // \u94b1\u5305\u7ed3\u6784\u4f53(\u5f85\u5b8c\u5584)\\r\\n    struct WhoUserWallet {\\r\\n        TokenType tType;\\r\\n    }\\r\\n\\r\\n\\r\\n    // \u5206\u7ea2\u5355\u5143\\r\\n    struct BounsRecordUint {\\r\\n        uint256 time;\\r\\n        uint256 number;\\r\\n        TokenType tType;\\r\\n    }\\r\\n\\r\\n\\r\\n    // \u63d0\u73b0\u5355\u5143\\r\\n    struct WithdrawUint{\\r\\n        uint256 number; // \u63d0\u73b0\u6570\u91cf\\r\\n        uint256 time; // \u63d0\u73b0\u65f6\u95f4\\r\\n        address account; // \u63d0\u73b0\u7528\u6237\\r\\n        TokenType tType; // token \u7c7b\u578b USDT & WHO\\r\\n        // UintStatus wStatus; // \u63d0\u73b0\u72b6\u6001\\r\\n    }\\r\\n\\r\\n    // \u8d28\u62bc\u5355\u5143\\r\\n    struct PledgeUint{\\r\\n        PoolType pType; // \u8d28\u62bc\u6c60\u7c7b\u578b\\r\\n        address account; // \u8d28\u62bc\u7684\u7528\u6237\\r\\n        uint256 id; // \u8d28\u62bc\u6570\u91cf\\r\\n        uint256 startTime; // \u5f00\u59cb\u8d28\u62bc\u65f6\u95f4\\r\\n        uint256 endTime; // \u7ed3\u675f\u8d28\u62bc\u65f6\u95f4\\r\\n        TokenType tType; // \u5e01\u79cd\u7c7b\u578b\\r\\n        // UintStatus pStatus; // \u8d28\u62bc\u72b6\u6001\\r\\n        \\r\\n    }\\r\\n\\r\\n    //\u8d28\u62bc\u77ff\u6c60\u57fa\u672c\u5c5e\u6027\\r\\n    struct PledgePoolBasicInfo {\\r\\n        uint256 createTime; // \u77ff\u6c60\u521b\u5efa\u65f6\u95f4\\r\\n        uint256 pledgeCycle; // \u56fa\u5b9a\u8d28\u62bc\u5468\u671f - 30 \u5929 90 \u5929\\r\\n        uint256 samePoolAlocRatio; // \u4ea7\u91cf\u5360\u6bd4 35% ~ 65% -- \u53ef\u8c03\u53c2\\r\\n        uint256 diffPoolAlocRatio; // \u4ea7\u91cf\u5360\u6bd4 70% ~ 30% -- \u53ef\u8c03\u53c2\\r\\n        uint256 endTime; // \u77ff\u6c60\u65f6\u95f4\\r\\n        PoolType pType; // \u77ff\u6c60\u7684\u7c7b\u578b\\r\\n        // PoolStatus \\r\\n        // uint256 dailyProduction; // \u65e5\u4ea7\u91cf - \u8ba1\u7b97\u5c5e\u6027\\r\\n        // TokenType tType;  // \u5e01\u79cd\u7c7b\u578b\\r\\n        // uint256 minVaildPledgeAmount; // \u6700\u5c0f\u6709\u6548\u8d28\u62bc\u91cf\\r\\n        // uint256 maxVaildPledgeAmount; // \u6700\u5927\u6709\u6548\u8d28\u62bc\u91cf\\r\\n    }\\r\\n    \\r\\n    struct PoolStatisticsInfo {\\r\\n        uint256 currentLockedTotal; // \u5f53\u524d\u9501\u4ed3\u603b\u989d\\r\\n        uint256 dailyOutflow; // \u65e5\u6d41\u5165\\r\\n        uint256 dailyInflow; // \u65e5\u6d41\u51fa \\r\\n        uint256 netIoflow; //\u51c0\u6d41\u51fa\u5165\\r\\n        uint256 historyLockedTotal; //\u5386\u53f2\u9501\u4ed3\u603b\u989d, \u5305\u62ec\u5f53\u9762\u8d28\u62bc\u4e2d\u7684\\r\\n        // uint256 currentAccounts; // \u5f53\u524d\u77ff\u6c60\u4e2d\u9501\u4ed3\u4e2d\u7684\u8d26\u53f7\u4e2a\u6570\\r\\n        // uint256 currentVailedPledgeTimes; //\u5f53\u524d\u6709\u6548\u7684\u8d28\u62bc\u6b21\u6570 \\r\\n        // uint256 historyReleasedTotalBalances; //\u5386\u53f2\u91ca\u653e\u603b\u989d\\r\\n        // uint256 historyPledgeTimes; // \u5386\u53f2\u8d28\u62bc\u603b\u6b21\u6570\\r\\n        // uint256 historyAccounts; // \u5386\u53f2\u7528\u6237\u603b\u4e2a\u6570\\r\\n    }\\r\\n    \\r\\n    // \u8d28\u62bc\u9501\u4ed3\u6c60\\r\\n    struct PledgeLockPool {\\r\\n        PledgePoolBasicInfo poolInfo; // \u77ff\u6c60\u7684\u57fa\u672c\u4fe1\u606f\\r\\n        PledgeUint[] lockedPlgUints; // \u8d28\u62bc\u5355\u5143\\r\\n        PoolStatisticsInfo poolStsInfo; // \u7edf\u8ba1\u4fe1\u606f\\r\\n    }\\r\\n\\r\\n    //\u6240\u6709\u77ff\u6c60\u7684\u7edf\u8ba1\u6570\u636e\\r\\n    struct AllPoolStatistics {\\r\\n        uint256 currentLockedTotal;\\r\\n        uint256 dailyOutflow; \\r\\n        uint256 dailyInflow;\\r\\n        uint256 netIoflow;\\r\\n    }\\r\\n    \\r\\n    // \u5e02\u573a\u7edf\u8ba1\u6570\u636e\\r\\n    struct MarketStatistics {\\r\\n        uint256 TotalMintAmount; // \u603b\u4ea7\u91cf\\r\\n        uint256 nonMintAmount; // \u5f85\u4ea7\u51fa\\r\\n        uint256 pledgeTotalProfitAmount; // \u8d28\u62bc\u603b\u6536\u76ca\\r\\n        uint256 refferTotalBonusAmount; // \u63a8\u8350\u5206\u7ea2\u91cf\\r\\n        uint256 currnetCurrencyAmount; // \u5f53\u524d\u6d41\u901a\u603b\u91cf\\r\\n        uint256 burnedTotalAmount; //\u5f53\u524d\u9500\u6bc1\u7684\u603b\u6570\u91cf\\r\\n    }\\r\\n\\r\\n    // \u5151\u6362\u8bb0\u5f55\u7ed3\u6784\u4f53\\r\\n    struct exChangeUint{\\r\\n        uint createTime; // \u521b\u5efa\u65f6\u95f4\\r\\n        uint amount; // \u5151\u6362\u7684\u91d1\u989d(tokenName)\\r\\n        string tokenName; // \u62ff\u4ec0\u4e48\u5151\u6362\\r\\n        string toName; // \u5151\u6362\u6210\u7684\u4ee3\u5e01\\r\\n    }\\r\\n    \\r\\n    struct partner{\\r\\n        address user;\\r\\n        bool isExist;\\r\\n    }\\r\\n\\r\\n    // LP\u8bb0\u5f55\u7ed3\u6784\u4f53\\r\\n    struct LpUint{\\r\\n        uint blockTime; // \u6dfb\u52a0\u6d41\u52a8\u6027\u65f6\u95f4\\r\\n        uint tokenAmount; // \u6dfb\u52a0/\u79fb\u9664\u7684\u4ee3\u5e01\u91d1\u989d\\r\\n        uint usdtAmount; // \u6dfb\u52a0/\u79fb\u9664\u7684usdt\u91d1\u989d\\r\\n        string tokenName; // \u4ee3\u5e01\u540d\u79f0\\r\\n    }\\r\\n    // \u65f6\u95f4\u7ed3\u6784\u4f53\\r\\n    struct timeUint{\\r\\n        uint time; // \u65f6\u95f4\\r\\n        bool isTomorrow; // \u662f\u5426\u4e3a\u660e\u5929\\r\\n        bool isAfterTomorrow; // \u662f\u5426\u4e3a\u540e\u5929\\r\\n    }\\r\\n    // \u7c7b\u578b\u8bb0\u5f55\u7ed3\u6784\u4f53\\r\\n    struct typeIncomeUint {\\r\\n        address user; // \u5206\u914d\u7684\u7528\u6237\\r\\n        string _type; // \u5206\u914d\u7c7b\u578b\\r\\n        uint amount; // \u5206\u914d\u91d1\u989d\\r\\n        LWHO.TokenType tType; // \u4ee3\u5e01\u7c7b\u578b\\r\\n        uint createTime; // \u5206\u914d\u65f6\u95f4\\r\\n    }\\r\\n     // \u9759\u6001\u6536\u76ca\u8bc4\u7ea7\u8868\\r\\n    function getDailyProfitLevel(uint netTurnover, uint _dailyPlgBaseOutputAmount) internal pure returns(ValueType t, uint value) {\\r\\n        if (netTurnover < 2000 * 10 ** 18) {\\r\\n            return (ValueType.Amount, _dailyPlgBaseOutputAmount * 10 ** 18);\\r\\n        }\\r\\n\\r\\n        if (2000 * 10 ** 18 <= netTurnover && netTurnover < 10000 * 10 ** 18) {\\r\\n            return (ValueType.Ratio, 10);\\r\\n        }\\r\\n\\r\\n        if (10000 * 10 ** 18 <= netTurnover && netTurnover < 20000 * 10 ** 18) {\\r\\n            return (ValueType.Ratio, 12);\\r\\n        }\\r\\n\\r\\n        if (20000 * 10 ** 18 <= netTurnover && netTurnover < 30000 * 10 ** 18) {\\r\\n            return (ValueType.Ratio, 15);\\r\\n        }\\r\\n        \\r\\n        if (netTurnover >= 30000 * 10 ** 18) {\\r\\n            return (ValueType.Ratio, 20);\\r\\n        }\\r\\n    }\\r\\n\\r\\n      // \u63a8\u8350\u5173\u7cfb\u5360\u6bd4\\r\\n    function getPledgeDividendRatio(uint i) internal pure returns(uint _level) {\\r\\n        uint level = i + 1; \\r\\n        if(level >=1 && level < 2) {\\r\\n            return 30;\\r\\n        }\\r\\n\\r\\n        if(level >=2 && level < 3) {\\r\\n            return 20;\\r\\n        }\\r\\n\\r\\n        if(level >=3 && level < 6) {\\r\\n            return 10;\\r\\n        }\\r\\n\\r\\n        if(level >=6 && level < 14) {\\r\\n            return 5;\\r\\n        }\\r\\n        \\r\\n        if(level >= 14) {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isBeforeDayDuringTime(uint256 plgTimestamp,string memory _type, uint blockTime) internal pure returns(bool) {\\r\\n        uint[3] memory curDate = timeStamp.getYMD(blockTime);\\r\\n        uint cY = curDate[0];\\r\\n        uint cM = curDate[1];\\r\\n        uint cD = curDate[2];\\r\\n\\r\\n        uint[3] memory plgDate = timeStamp.getYMD(plgTimestamp);\\r\\n        uint pY = plgDate[0];\\r\\n        uint pM = plgDate[1];\\r\\n        uint pD = plgDate[2];\\r\\n        // startTime\\r\\n        //  cD < pD cD \u662f\u5f53\u524d\u5929\u6570 pD\u662f\u8d28\u62bc\u7ed3\u675f\u65f6\u95f4(\u8d28\u62bc\u672a\u5230\u671f) cD\u662f\u5927\u4e8epD-1\u5929 \u5373\u662f \u6628\u5929 \\r\\n        if(keccak256(abi.encodePacked(_type)) == keccak256(abi.encodePacked(\\\"last\\\"))){\\r\\n            if (cY == pY && cM == pM && cD < pD && cD >= pD - 1) { \\r\\n                return true;\\r\\n            }else{\\r\\n                return false; \\r\\n            }\\r\\n        // endTime\\r\\n        // \u5230\u671f\u540e\u91ca\u653e(\u5f53\u524d\u65f6\u95f4\u5927\u4e8e\u5230\u671f\u65f6\u95f4)\\r\\n        }else if(keccak256(abi.encodePacked(_type)) == keccak256(abi.encodePacked(\\\"next\\\"))){\\r\\n            if (cY == pY && cM == pM && cD > pD && cD >= pD + 1) { \\r\\n                return true;\\r\\n            }else{\\r\\n                return false; \\r\\n            }\\r\\n        }else if(keccak256(abi.encodePacked(_type)) == keccak256(abi.encodePacked(\\\"nextMin\\\"))){\\r\\n            if(blockTime- 1 hours >= plgTimestamp){\\r\\n                return true;\\r\\n            }else{\\r\\n                return false;\\r\\n            }\\r\\n        }else if(keccak256(abi.encodePacked(_type)) == keccak256(abi.encodePacked(\\\"lastMin\\\"))){\\r\\n            if(blockTime+1 hours <= plgTimestamp){\\r\\n                return true;\\r\\n            }else{\\r\\n                return false;\\r\\n            }\\r\\n        }else{\\r\\n            revert(\\\"Time: error Type\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function isAddPlgVaildTime(uint plgStartTime, uint plgEndTime, uint currentTime) internal pure returns(bool) {\\r\\n        if(currentTime >= plgStartTime&& currentTime <= plgEndTime) {\\r\\n            return true;\\r\\n        }else {\\r\\n            return false;\\r\\n        }\\r\\n       \\r\\n    }\\r\\n    \\r\\n    function isLockPoolReleaseVaildTime(uint plgEndTime, uint currentTime,bool precision) internal pure returns(bool) {\\r\\n        if(precision){\\r\\n            if(currentTime >= plgEndTime + 1 * 1 days&&currentTime <= plgEndTime + 2 * 1 days){\\r\\n                return true;\\r\\n            }else{\\r\\n                return false;\\r\\n            }\\r\\n        }else{\\r\\n            if(currentTime >= plgEndTime + 1 * 1 days) {\\r\\n                return true;\\r\\n            } else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isMigPoolReleaseVaildTime(uint plgEndTime, uint currentTime,uint count) internal pure returns(bool) {\\r\\n        if(currentTime >= plgEndTime + 1 * 1 days&&currentTime<=plgEndTime+count * 1 * 1 days) {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    //\u707c\u70e7\u5224\u65ad\\r\\n    function burnLimitFee(uint acconAmount, uint fatherAmount) internal pure returns(uint realAmountFee) {\\r\\n        if(acconAmount > fatherAmount) {\\r\\n            return fatherAmount;\\r\\n        } else {\\r\\n            return acconAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // \u7c7b\u578b\u8fc7\u6ee4\\r\\n    function updateTypeFilter(PoolType pType) internal pure returns(PoolType a, PoolType b, PoolType c, PoolType d) {\\r\\n        if(pType == PoolType.all) {\\r\\n            return (PoolType.lockOne, PoolType.lockTwo, PoolType.migrateOne, PoolType.migrateTwo);\\r\\n        }\\r\\n\\r\\n        if(pType == PoolType.lockOne) {\\r\\n            return (pType, PoolType.lockTwo, PoolType.migrateOne, PoolType.lockOne);\\r\\n        }\\r\\n\\r\\n        if(pType == PoolType.lockTwo) {\\r\\n            return (pType, PoolType.lockOne, PoolType.migrateOne, PoolType.lockTwo);\\r\\n        }\\r\\n\\r\\n        if(pType == PoolType.migrateOne) {\\r\\n            return (pType, PoolType.lockOne, PoolType.lockTwo, PoolType.migrateOne);\\r\\n        }\\r\\n\\r\\n        if(pType == PoolType.migrateTwo) {\\r\\n            return (pType, PoolType.lockOne, PoolType.lockTwo, PoolType.migrateTwo);\\r\\n        }\\r\\n    }\\r\\n    function getPoolDailyOutputAmount(uint a,uint b,uint c) internal pure returns(uint){\\r\\n        return a * b * c / 100 / 100;\\r\\n    }\\r\\n    function getDailyProfitPool(uint a,uint b,uint c) internal pure returns (uint){\\r\\n        if(a == 0|| b == 0||c==0){\\r\\n            return 0;\\r\\n        }else{\\r\\n            return a * b / c; \\r\\n        }\\r\\n    }\\r\\n    function getValueTypeMint(ValueType vType,uint netIoflow,uint value) internal pure returns (uint){\\r\\n        if (vType == ValueType.Amount) { \\r\\n            return value;\\r\\n        }else if (vType == ValueType.Ratio) {\\r\\n            return netIoflow * value / 100;\\r\\n        }else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    function updateStatisticsData(AllPoolStatistics memory allPoolSts,PledgeLockPool[4] memory allPledge) internal pure returns(AllPoolStatistics memory _allPoolSts){\\r\\n        allPoolSts.currentLockedTotal = allPledge[0].poolStsInfo.currentLockedTotal +\\r\\n        allPledge[1].poolStsInfo.currentLockedTotal +\\r\\n        allPledge[2].poolStsInfo.currentLockedTotal +\\r\\n        allPledge[3].poolStsInfo.currentLockedTotal;\\r\\n        allPoolSts.dailyInflow = allPledge[0].poolStsInfo.dailyInflow +\\r\\n        allPledge[1].poolStsInfo.dailyInflow +\\r\\n        allPledge[2].poolStsInfo.dailyInflow +\\r\\n        allPledge[3].poolStsInfo.dailyInflow;\\r\\n        allPoolSts.dailyOutflow = allPledge[0].poolStsInfo.dailyOutflow +\\r\\n        allPledge[1].poolStsInfo.dailyOutflow +\\r\\n        allPledge[2].poolStsInfo.dailyOutflow +\\r\\n        allPledge[3].poolStsInfo.dailyOutflow;\\r\\n        if(allPoolSts.dailyInflow >= allPoolSts.dailyOutflow) {\\r\\n            allPoolSts.netIoflow =  allPoolSts.dailyInflow - allPoolSts.dailyOutflow;\\r\\n        }\\r\\n        if(allPoolSts.dailyInflow < allPoolSts.dailyOutflow) {\\r\\n            allPoolSts.netIoflow = allPoolSts.dailyOutflow - allPoolSts.dailyInflow ;\\r\\n        }\\r\\n        _allPoolSts = allPoolSts;\\r\\n        return _allPoolSts;\\r\\n    }\\r\\n    function initPools(uint migratePoolOpenDays,uint blockTime) internal pure returns (PledgePoolBasicInfo[4] memory _allPool) {\\r\\n        PledgePoolBasicInfo[4] memory allPool;\\r\\n        PledgePoolBasicInfo memory lockedOnePoolInfo;\\r\\n        lockedOnePoolInfo.createTime = blockTime;\\r\\n        lockedOnePoolInfo.endTime = blockTime + 10000 * 365 days;\\r\\n        lockedOnePoolInfo.pledgeCycle = 30; // days\\r\\n        lockedOnePoolInfo.samePoolAlocRatio = 35; // \\r\\n        lockedOnePoolInfo.diffPoolAlocRatio = 70;\\r\\n        lockedOnePoolInfo.pType = PoolType.lockOne;\\r\\n        PledgePoolBasicInfo memory lockedTwoPoolInfo;\\r\\n        lockedTwoPoolInfo.createTime = blockTime;\\r\\n        lockedTwoPoolInfo.endTime = blockTime + 10000 * 365 days;\\r\\n        lockedTwoPoolInfo.pledgeCycle = 90; // days\\r\\n        lockedTwoPoolInfo.samePoolAlocRatio = 65;\\r\\n        lockedTwoPoolInfo.diffPoolAlocRatio = 70;\\r\\n        lockedTwoPoolInfo.pType = PoolType.lockTwo;\\r\\n        PledgePoolBasicInfo memory migrateOnePoolInfo;\\r\\n        migrateOnePoolInfo.createTime = blockTime;\\r\\n        migrateOnePoolInfo.endTime = blockTime + migratePoolOpenDays * 1 days; //\u8fc7\u671f\u65f6\u95f4\\r\\n        migrateOnePoolInfo.pledgeCycle = 90;\\r\\n        migrateOnePoolInfo.samePoolAlocRatio = 35;\\r\\n        migrateOnePoolInfo.diffPoolAlocRatio = 30;\\r\\n        migrateOnePoolInfo.pType = PoolType.migrateOne;\\r\\n        PledgePoolBasicInfo memory migrateTwoPoolInfo;\\r\\n        migrateTwoPoolInfo.createTime = blockTime; //\u8fc7\u671f\u65f6\u95f4\\r\\n        migrateTwoPoolInfo.endTime = blockTime + migratePoolOpenDays * 1 days; //\u8fc7\u671f\u65f6\u95f4\\r\\n        migrateTwoPoolInfo.pledgeCycle = 180;\\r\\n        migrateTwoPoolInfo.samePoolAlocRatio = 65;\\r\\n        migrateTwoPoolInfo.diffPoolAlocRatio = 30;\\r\\n        migrateTwoPoolInfo.pType = PoolType.migrateTwo;\\r\\n        allPool[0] = lockedOnePoolInfo;\\r\\n        allPool[1] = lockedTwoPoolInfo;\\r\\n        allPool[2] = migrateOnePoolInfo;\\r\\n        allPool[3] = migrateTwoPoolInfo;\\r\\n        return allPool;\\r\\n    }\\r\\n    function getNumber(PoolType _pType,uint number,string memory smb) internal pure returns (uint){\\r\\n        if(_pType == PoolType.migrateOne&&keccak256(abi.encodePacked(smb))==keccak256(abi.encodePacked(\\\"sub\\\"))){\\r\\n            return number * 5 / 1000;\\r\\n        }else if(_pType == PoolType.migrateTwo&&keccak256(abi.encodePacked(smb))==keccak256(abi.encodePacked(\\\"sub\\\"))){\\r\\n            return number * 1 / 100;\\r\\n        }else{\\r\\n            return number;\\r\\n        }\\r\\n    }\\r\\n    function getPlgUints(PoolType _pType,uint id,uint startTime,uint cycle,address account) internal pure returns (PledgeUint memory){\\r\\n        PledgeUint memory plgUint;\\r\\n        plgUint.pType = _pType;\\r\\n        plgUint.id = id;\\r\\n        plgUint.startTime = startTime;\\r\\n        plgUint.endTime = startTime+cycle * 1 days;\\r\\n        plgUint.tType = TokenType.WHO;\\r\\n        plgUint.account = account;\\r\\n        return plgUint;\\r\\n    }\\r\\n    function getId(IWhoSql _sql,uint id) internal view returns (uint){\\r\\n        return _sql.getPledgeNum(id);\\r\\n    }\\r\\n    function getPart(partner[] memory _part) internal pure returns (partner[] memory,uint){\\r\\n        partner[] memory npart = new partner[](_part.length);\\r\\n        uint b = 0;\\r\\n        for(uint a = 0;a<_part.length;a++){\\r\\n            if(_part[a].isExist){\\r\\n                npart[b] = _part[a];\\r\\n                b++;\\r\\n            }\\r\\n        }\\r\\n        return (npart,b);\\r\\n    }\\r\\n    function fatherMeetFee(uint amount,uint len) internal pure returns (uint){\\r\\n        if(len>=0&&len<3){\\r\\n            return amount / 100 * 1;\\r\\n        }else if(len>=3&&len<5){\\r\\n            return amount / 1000 * 5;\\r\\n        }else if(len>=5&& len<10){\\r\\n            return amount / 1000 * 2;\\r\\n        }else{\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isAccess(IWhoSql db,address User) internal view returns (bool){\\r\\n        if(db.getIsTrade() == true&&db.getInitTransWhiteList(User) == false){\\r\\n            return false;\\r\\n        }else{\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    function returnAddress(address Who,address Usdt,TokenType tType) internal pure returns(address){\\r\\n        if(tType == TokenType.WHO){\\r\\n            return Who;\\r\\n        }else if(tType == TokenType.USDT){\\r\\n            return Usdt;\\r\\n        }else{\\r\\n            revert(\\\"Token Type Error\\\");\\r\\n        }\\r\\n    }\\r\\n    function poolStsInfoSub(uint count,uint number,PoolStatisticsInfo memory theStatic) internal pure returns (PoolStatisticsInfo memory _static){\\r\\n        if(count == 0){\\r\\n            theStatic.currentLockedTotal -= number;\\r\\n            theStatic.dailyOutflow += number;\\r\\n            return theStatic;\\r\\n        }else{\\r\\n            theStatic.currentLockedTotal -= (number * count / 100);\\r\\n            theStatic.dailyOutflow += (number * count / 100);\\r\\n            return theStatic;\\r\\n        }\\r\\n    }\\r\\n    // function setStsZero(PledgeLockPool memory theStatic) public pure returns(PledgeLockPool memory _static){\\r\\n    //    theStatic.poolStsInfo.historyLockedTotal = 0;\\r\\n    //    theStatic.poolStsInfo.currentLockedTotal = 0;\\r\\n    //    theStatic.poolStsInfo.dailyInflow = 0;\\r\\n    //    theStatic.poolStsInfo.dailyOutflow = 0; \\r\\n    //    return theStatic;\\r\\n    // }\\r\\n    function PoolTypeDistribueEndTime(PoolType _pType,uint blockTime) internal pure returns (uint){\\r\\n        if(_pType == PoolType.migrateOne){\\r\\n            return blockTime + 200 * 1 days;\\r\\n        }else if(_pType == PoolType.migrateTwo){\\r\\n            return blockTime + 100 * 1 days;\\r\\n        }else{\\r\\n            return blockTime;\\r\\n        }\\r\\n    }\\r\\n    function isDailyInflow(uint blockTime,uint startTime) internal pure returns (bool){\\r\\n        if(blockTime <= startTime + 1 * 1 days&&blockTime>=startTime||blockTime == startTime){\\r\\n            return true;\\r\\n        }else{\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"interface/whtc/IWHTC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\ninterface IWHTC {\\r\\n    function make(uint amount,address user) external returns (bool);\\r\\n    function burn(uint amount,address user) external returns (bool);\\r\\n    function approve(address allow,uint amount) external payable returns (bool);\\r\\n    function balanceOf(address user) external view returns (uint);\\r\\n}\"\r\n    },\r\n    \"@sphynxswap/sphynx-swap-lib/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity >=0.4.0;\\r\\n\\r\\n// import '../GSN/Context.sol';\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        address msgSender = msg.sender;\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, 'Ownable: caller is not the owner');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@sphynxswap/sphynx-swap-lib/contracts/token/BEP20/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity >=0.4.0;\\r\\n\\r\\ninterface IBEP20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token decimals.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the bep token owner.\\r\\n     */\\r\\n    function getOwner() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address _owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@sphynxswap/sphynx-swap-lib/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.4.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, 'SafeMath: addition overflow');\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, 'SafeMath: subtraction overflow');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, 'SafeMath: multiplication overflow');\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, 'SafeMath: division by zero');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, 'SafeMath: modulo by zero');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x < y ? x : y;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint256 x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@sphynxswap/sphynx-swap-lib/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256('')`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            codehash := extcodehash(account)\\r\\n        }\\r\\n        return (codehash != accountHash && codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, 'Address: insufficient balance');\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{value: amount}('');\\r\\n        require(success, 'Address: unable to send value, recipient may have reverted');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, 'Address: low-level call failed');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 weiValue,\\r\\n        string memory errorMessage\\r\\n    ) private returns (bytes memory) {\\r\\n        require(isContract(target), 'Address: call to non-contract');\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"solidity_lib/Permission/Permission_interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPermission {\\r\\n    struct bannerType{\\r\\n        string _type;\\r\\n        address banner;\\r\\n        uint startTime;\\r\\n        uint endTime;\\r\\n        bool isBan;\\r\\n    }\\r\\n    function setOwner(address _owner) external payable;\\r\\n    function getOwner() external view returns (address _owner);\\r\\n    function setAdmin(address _admin) external payable;\\r\\n    function removeAdmin(address _admin) external payable;\\r\\n    function setBanner(address _banner) external payable;\\r\\n    function removeBanner(address _banner) external payable;\\r\\n    function setTempBanner(address _banner,uint _startTime,uint _endTime) external payable;\\r\\n    function removeTempBanner(address _banner) external payable;\\r\\n    function getBanner() external view returns (bannerType[] memory banners);\\r\\n    function setSql(address dataBaser) external payable;\\r\\n    function rmSql(address dataBaser) external payable;\\r\\n    function _Owner() external view;\\r\\n    function _Ban() external view;\\r\\n    function _Admin() external view;\\r\\n    function _Sql() external view;\\r\\n    function _IsOwner(address _user) external view;\\r\\n    function _IsBan(address _user) external view;\\r\\n    function _IsAdmin(address _user) external view;\\r\\n    function _IsSql(address _user) external view;\\r\\n}\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pool\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Perm\",\"outputs\":[{\"internalType\":\"contract IPermission\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDTAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"ratios\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"ratio\",\"type\":\"uint256[5]\"}],\"name\":\"setAllFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"setDaoContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setReturnLiquidityWHDAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setReturnLiquidityWHOAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"setSwapPoundage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setWHTCAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawalUSDT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "WHOToken", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "0", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000013b33039fb888c7011815c4509d7d0e33124b573000000000000000000000000f9f7feddb694ac8163831ff68f068581354748a2000000000000000000000000828a5d926c052d705fe482a16f4610b0d0678d470000000000000000000000007d13f33a90aba3e3f2cfae4d0cf7ea0ce0c2895d00000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000000b979e07f3bd4fe812dd7a0929f842c610a7a09d000000000000000000000000e4b538f7beb1ef14770449e672407d87f71f891e0000000000000000000000000895e2c2075ba466ad47d4e234255788d2d45ae3000000000000000000000000f5fd78f184b0ad3bc787ffce7e67e2a57d96cd37", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}