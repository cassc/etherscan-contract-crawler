{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 8899\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/BdexRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport './interfaces/IBdexFactory.sol';\\nimport './interfaces/IBdexFormula.sol';\\nimport './interfaces/IBdexPair.sol';\\nimport './libraries/TransferHelper.sol';\\n\\nimport './interfaces/IBdexRouter.sol';\\nimport './libraries/SafeMath.sol';\\nimport './interfaces/IWETH.sol';\\nimport './interfaces/IBPool.sol';\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\\\";\\ncontract BdexRouter is IBdexRouter,Initializable {\\n    using SafeMath for uint;\\n    address public override factory;\\n    address public override formula;\\n    address public override WETH;\\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\\n        _;\\n    }\\n    function initialize (address _factory, address _WETH) public initializer{\\n        factory = _factory;\\n        formula = IBdexFactory(_factory).formula();\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH);\\n        // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    // **** ADD LIQUIDITY ****\\n    function _addLiquidity(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin\\n    ) internal virtual returns (uint amountA, uint amountB) {\\n        (uint reserveA, uint reserveB) = IBdexFormula(formula).getReserves(pair, tokenA, tokenB);\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint amountBOptimal = IBdexFormula(formula).quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal <= amountBDesired) {\\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint amountAOptimal = IBdexFormula(formula).quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal <= amountADesired);\\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    function _addLiquidityToken(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin\\n    ) internal returns (uint amountA, uint amountB) {\\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n    }\\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) public virtual override returns (uint liquidity) {\\n        address pair = IBdexFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\\n        liquidity = IBdexPair(pair).mint(to);\\n    }\\n    function addLiquidity(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\\n        (amountA,  amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n        liquidity = IBdexPair(pair).mint(to);\\n    }\\n\\n    function _addLiquidityETH(\\n        address pair,\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to\\n    ) internal returns (uint amountToken, uint amountETH, uint liquidity) {\\n        (amountToken, amountETH) = _addLiquidity(\\n            pair,\\n            token,\\n            WETH,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n        transferETHTo(amountETH, pair);\\n        liquidity = IBdexPair(pair).mint(to);\\n        // refund dust eth, if any\\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) public virtual override payable returns (uint liquidity) {\\n        address pair = IBdexFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\\n        (,,liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\\n    }\\n    function addLiquidityETH(\\n        address pair,\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\\n    }\\n\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(address tokenIn, uint[] memory amounts, address[] memory path, address _to) internal virtual {\\n        address input = tokenIn;\\n        for (uint i = 0; i < path.length; i++) {\\n            IBdexPair pairV2 = IBdexPair(path[i]);\\n            address token0 = pairV2.token0();\\n            uint amountOut = amounts[i + 1];\\n            (uint amount0Out, uint amount1Out, address output) = input == token0 ? (uint(0), amountOut, pairV2.token1()) : (amountOut, uint(0), token0);\\n            address to = i < path.length - 1 ? path[i + 1] : _to;\\n            pairV2.swap(\\n                amount0Out, amount1Out, to, new bytes(0)\\n            );\\n            emit Exchange(address(pairV2), amountOut, output);\\n            input = output;\\n        }\\n    }\\n\\n    function swapExactTokensForTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint[] memory amounts) {\\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\\n\\n        TransferHelper.safeTransferFrom(\\n            tokenIn, msg.sender, path[0], amounts[0]\\n        );\\n        _swap(tokenIn, amounts, path, to);\\n    }\\n\\n    function swapTokensForExactTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\\n\\n        TransferHelper.safeTransferFrom(\\n            tokenIn, msg.sender, path[0], amounts[0]\\n        );\\n        _swap(tokenIn, amounts, path, to);\\n    }\\n\\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\\n\\n        transferETHTo(amounts[0], path[0]);\\n        _swap(WETH, amounts, path, to);\\n    }\\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\\n\\n        TransferHelper.safeTransferFrom(\\n            tokenIn, msg.sender, path[0], amounts[0]\\n        );\\n        _swap(tokenIn, amounts, path, address(this));\\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\\n    }\\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\\n\\n        TransferHelper.safeTransferFrom(\\n            tokenIn, msg.sender, path[0], amounts[0]\\n        );\\n        _swap(tokenIn, amounts, path, address(this));\\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\\n    }\\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\\n\\n        transferETHTo(amounts[0], path[0]);\\n        _swap(WETH, amounts, path, to);\\n        // refund dust eth, if any\\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    // **** SWAP (supporting fee-on-transfer tokens) ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swapSupportingFeeOnTransferTokens(address tokenIn, address[] memory path, address _to) internal virtual {\\n        address input = tokenIn;\\n        for (uint i; i < path.length; i++) {\\n            IBdexPair pair = IBdexPair(path[i]);\\n\\n            uint amountInput;\\n            uint amountOutput;\\n            address currentOutput;\\n            {\\n                (address output, uint reserveInput, uint reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IBdexFormula(formula).getFactoryReserveAndWeights(factory, address(pair), input);\\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\\n                amountOutput = IBdexFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\\n                currentOutput = output;\\n            }\\n            (uint amount0Out, uint amount1Out) = input == pair.token0() ? (uint(0), amountOutput) : (amountOutput, uint(0));\\n            address to = i < path.length - 1 ? path[i + 1] : _to;\\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n            emit Exchange(address(pair), amountOutput, currentOutput);\\n            input = currentOutput;\\n        }\\n    }\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) {\\n        TransferHelper.safeTransferFrom(\\n            tokenIn, msg.sender, path[0], amountIn\\n        );\\n        uint balanceBefore = IERC20(tokenOut).balanceOf(to);\\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\\n        require(\\n            IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n            'Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n        );\\n    }\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        address tokenOut,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n    {\\n//            require(path[0] == WETH, 'Router: INVALID_PATH');\\n        uint amountIn = msg.value;\\n        transferETHTo(amountIn, path[0]);\\n        uint balanceBefore = IERC20(tokenOut).balanceOf(to);\\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\\n        require(\\n            IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n            'Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n        );\\n    }\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        address tokenIn,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n    {\\n        TransferHelper.safeTransferFrom(\\n            tokenIn, msg.sender, path[0], amountIn\\n        );\\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\\n        require(amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        transferAll(ETH_ADDRESS, to, amountOut);\\n    }\\n    function multihopBatchSwapExactIn(\\n        Swap[][] memory swapSequences,\\n        address tokenIn,\\n        address tokenOut,\\n        uint totalAmountIn,\\n        uint minTotalAmountOut,\\n        uint deadline\\n    ) public payable override virtual ensure(deadline) returns (uint totalAmountOut) {\\n        transferFromAll(tokenIn, totalAmountIn);\\n        uint balanceBefore;\\n        if (!isETH(tokenOut)) {\\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\\n        }\\n\\n        for (uint i = 0; i < swapSequences.length; i++) {\\n            uint tokenAmountOut;\\n            for (uint k = 0; k < swapSequences[i].length; k++) {\\n                Swap memory swap = swapSequences[i][k];\\n                if (k > 0) {\\n                    // Makes sure that on the second swap the output of the first was used\\n                    // so there is not intermediate token leftover\\n                    swap.swapAmount = tokenAmountOut;\\n                }\\n                tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\\n            }\\n\\n            // This takes the amountOut of the last swap\\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\\n        }\\n\\n        transferAll(tokenOut, msg.sender, totalAmountOut);\\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\\n\\n        if (isETH(tokenOut)) {\\n            require(totalAmountOut >= minTotalAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n        } else {\\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, '<minTotalAmountOut');\\n        }\\n    }\\n\\n    function multihopBatchSwapExactOut(\\n        Swap[][] memory swapSequences,\\n        address tokenIn,\\n        address tokenOut,\\n        uint maxTotalAmountIn,\\n        uint deadline\\n    ) public payable override virtual ensure(deadline) returns (uint totalAmountIn) {\\n        transferFromAll(tokenIn, maxTotalAmountIn);\\n\\n        for (uint i = 0; i < swapSequences.length; i++) {\\n            uint tokenAmountInFirstSwap;\\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\\n            if (swapSequences[i].length == 1) {\\n                Swap memory swap = swapSequences[i][0];\\n                tokenAmountInFirstSwap = _swapSingleMixOut(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount, swap.maxPrice);\\n\\n            } else {\\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\\n                // of token C. But first we need to buy B with A so we can then buy C with B\\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\\n                uint intermediateTokenAmount;\\n                // This would be token B as described above\\n                Swap memory secondSwap = swapSequences[i][1];\\n                {\\n                    address[] memory paths = new address[](1);\\n                    paths[0] = secondSwap.pool;\\n                    uint[] memory amounts = IBdexFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\\n                    intermediateTokenAmount = amounts[0];\\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, 'Router: EXCESSIVE_INPUT_AMOUNT');\\n                }\\n\\n                //// Buy intermediateTokenAmount of token B with A in the first pool\\n                Swap memory firstSwap = swapSequences[i][0];\\n                tokenAmountInFirstSwap = _swapSingleMixOut(firstSwap.tokenIn, firstSwap.tokenOut, firstSwap.pool, intermediateTokenAmount, firstSwap.limitReturnAmount, firstSwap.maxPrice);\\n\\n                //// Buy the final amount of token C desired\\n                _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\\n            }\\n\\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\\n        }\\n\\n        require(totalAmountIn <= maxTotalAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\\n    }\\n\\n    function transferFromAll(address token, uint amount) internal returns (bool) {\\n        if (isETH(token)) {\\n            IWETH(WETH).deposit{value : msg.value}();\\n        } else {\\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\\n        }\\n        return true;\\n    }\\n\\n    function getBalance(address token) internal view returns (uint) {\\n        if (isETH(token)) {\\n            return IWETH(WETH).balanceOf(address(this));\\n        } else {\\n            return IERC20(token).balanceOf(address(this));\\n        }\\n    }\\n\\n    function _swapSingleMixOut(address tokenIn, address tokenOut, address pool, uint swapAmount, uint limitReturnAmount, uint maxPrice) internal returns (uint tokenAmountIn) {\\n        address[] memory paths = new address[](1);\\n        paths[0] = pool;\\n        uint[] memory amounts = IBdexFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\\n        tokenAmountIn = amounts[0];\\n        require(tokenAmountIn <= limitReturnAmount, 'Router: EXCESSIVE_INPUT_AMOUNT');\\n        _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\\n    }\\n\\n    function _swapSingle(address tokenIn, address pair, uint targetSwapAmount, uint targetOutAmount) internal {\\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\\n        IBdexPair pairV2 = IBdexPair(pair);\\n        address token0 = pairV2.token0();\\n\\n        (uint amount0Out, uint amount1Out, address output) = tokenIn == token0 ? (uint(0), targetOutAmount, pairV2.token1()) : (targetOutAmount, uint(0), token0);\\n        pairV2.swap(amount0Out, amount1Out, address(this), new bytes(0));\\n\\n        emit Exchange(pair, targetOutAmount, output);\\n    }\\n\\n    function _swapSingleSupportFeeOnTransferTokens(address tokenIn, address tokenOut, address pool, uint swapAmount, uint limitReturnAmount) internal returns(uint tokenAmountOut) {\\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\\n\\n        uint amountOutput;\\n        {\\n            (, uint reserveInput, uint reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) = IBdexFormula(formula).getFactoryReserveAndWeights(factory, pool, tokenIn);\\n            uint amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\\n            amountOutput = IBdexFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\\n        }\\n        uint balanceBefore = IERC20(tokenOut).balanceOf(address(this));\\n        (uint amount0Out, uint amount1Out) = tokenIn == IBdexPair(pool).token0() ? (uint(0), amountOutput) : (amountOutput, uint(0));\\n        IBdexPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\\n        emit Exchange(pool, amountOutput, tokenOut);\\n\\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\\n        require(tokenAmountOut >= limitReturnAmount,'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n    }\\n\\n    function _validateAmountOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path\\n    ) internal view returns (uint[] memory amounts) {\\n        amounts = IBdexFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n    }\\n\\n    function _validateAmountIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path\\n    ) internal view returns (uint[] memory amounts) {\\n        amounts = IBdexFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\\n        require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\\n    }\\n\\n    function transferETHTo(uint amount, address to) internal {\\n        IWETH(WETH).deposit{value: amount}();\\n        assert(IWETH(WETH).transfer(to, amount));\\n    }\\n\\n    function transferAll(address token, address to, uint amount) internal returns (bool) {\\n        if (amount == 0) {\\n            return true;\\n        }\\n\\n        if (isETH(token)) {\\n            IWETH(WETH).withdraw(amount);\\n            TransferHelper.safeTransferETH(to, amount);\\n        } else {\\n            TransferHelper.safeTransfer(token, to, amount);\\n        }\\n        return true;\\n    }\\n\\n    function isETH(address token) internal pure returns (bool) {\\n        return (token == ETH_ADDRESS);\\n    }\\n// **** REMOVE LIQUIDITY ****\\n    function _removeLiquidity(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to\\n    ) internal  returns (uint amountA, uint amountB) {\\n        require(IBdexFactory(factory).isPair(pair), \\\"Router: Invalid pair\\\");\\n        IBdexPair(pair).transferFrom(msg.sender, pair, liquidity);\\n        // send liquidity to pair\\n        (uint amount0, uint amount1) = IBdexPair(pair).burn(to);\\n        (address token0,) = IBdexFormula(formula).sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\\n    }\\n    function removeLiquidity(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\\n    }\\n\\n    function removeLiquidityETH(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\\n        (amountToken, amountETH) = _removeLiquidity(\\n            pair,\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this)\\n        );\\n        TransferHelper.safeTransfer(token, to, amountToken);\\n        transferAll(ETH_ADDRESS, to, amountETH);\\n    }\\n\\n    function removeLiquidityWithPermit(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB) {\\n        {\\n            uint value = approveMax ? uint(- 1) : liquidity;\\n            IBdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        }\\n        (amountA, amountB) = _removeLiquidity(pair, tokenA, tokenB, liquidity, amountAMin, amountBMin, to);\\n    }\\n\\n    function removeLiquidityETHWithPermit(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external virtual override returns (uint amountToken, uint amountETH) {\\n        uint value = approveMax ? uint(- 1) : liquidity;\\n        IBdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountToken, amountETH) = removeLiquidityETH(pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline);\\n    }\\n\\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\\n        (, amountETH) = removeLiquidity(\\n            pair,\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\\n        transferAll(ETH_ADDRESS, to, amountETH);\\n    }\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external virtual override returns (uint amountETH) {\\n        uint value = approveMax ? uint(- 1) : liquidity;\\n        IBdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n            pair, token, liquidity, amountTokenMin, amountETHMin, to, deadline\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IBPool is IERC20 {\\n    function version() external view returns(uint);\\n    function swapExactAmountIn(address, uint, address, uint, uint) external returns (uint, uint);\\n\\n    function swapExactAmountOut(address, uint, address, uint, uint) external returns (uint, uint);\\n\\n    function calcInGivenOut(uint, uint, uint, uint, uint, uint) external pure returns (uint);\\n\\n    function calcOutGivenIn(uint, uint, uint, uint, uint, uint) external pure returns (uint);\\n\\n    function getDenormalizedWeight(address) external view returns (uint);\\n\\n    function swapFee() external view returns (uint);\\n\\n    function setSwapFee(uint _swapFee) external;\\n\\n    function bind(address token, uint balance, uint denorm) external;\\n\\n    function rebind(address token, uint balance, uint denorm) external;\\n\\n    function finalize(\\n        uint _swapFee,\\n        uint _initPoolSupply,\\n        address[] calldata _bindTokens,\\n        uint[] calldata _bindDenorms\\n    ) external;\\n\\n    function setPublicSwap(bool _publicSwap) external;\\n    function setController(address _controller) external;\\n    function setExchangeProxy(address _exchangeProxy) external;\\n    function getFinalTokens() external view returns (address[] memory tokens);\\n\\n\\n    function getTotalDenormalizedWeight() external view returns (uint);\\n\\n    function getBalance(address token) external view returns (uint);\\n\\n\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\\n    function joinPoolFor(address account, uint rewardAmountOut, uint[] calldata maxAmountsIn) external;\\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn) external returns (uint tokenAmountIn);\\n\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut) external returns (uint tokenAmountOut);\\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn) external returns (uint poolAmountIn);\\n    function joinswapExternAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        uint minPoolAmountOut\\n    ) external returns (uint poolAmountOut);\\n    function finalizeRewardFundInfo(address _rewardFund, uint _unstakingFrozenTime) external;\\n    function addRewardPool(IERC20 _rewardToken, uint256 _startBlock, uint256 _endRewardBlock, uint256 _rewardPerBlock,\\n        uint256 _lockRewardPercent, uint256 _startVestingBlock, uint256 _endVestingBlock) external;\\n    function isBound(address t) external view returns (bool);\\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint spotPrice);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBdexFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\ninterface IBdexFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint);\\n    function feeTo() external view returns (address);\\n    function formula() external view returns (address);\\n    function protocolFee() external view returns (uint);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function isPair(address) external view returns (bool);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB, uint32 tokenWeightA, uint32 swapFee) external returns (address pair);\\n    function getWeightsAndSwapFee(address pair) external view returns (uint32 tokenWeight0, uint32 tokenWeight1, uint32 swapFee);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setProtocolFee(uint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBdexFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity >=0.5.16;\\n\\n/*\\n    Bancor Formula interface\\n*/\\ninterface IBdexFormula {\\n\\n    function getReserveAndWeights(address pair, address tokenA) external view returns (\\n        address tokenB,\\n        uint reserveA,\\n        uint reserveB,\\n        uint32 tokenWeightA,\\n        uint32 tokenWeightB,\\n        uint32 swapFee\\n    );\\n\\n    function getFactoryReserveAndWeights(address factory, address pair, address tokenA) external view returns (\\n        address tokenB,\\n        uint reserveA,\\n        uint reserveB,\\n        uint32 tokenWeightA,\\n        uint32 tokenWeightB,\\n        uint32 swapFee\\n    );\\n\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn, uint reserveOut,\\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\\n        uint32 swapFee\\n    ) external view returns (uint amountIn);\\n\\n    function getPairAmountIn(address pair, address tokenIn, uint amountOut) external view returns (uint amountIn);\\n\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn, uint reserveOut,\\n        uint32 tokenWeightIn, uint32 tokenWeightOut,\\n        uint32 swapFee\\n    ) external view returns (uint amountOut);\\n\\n    function getPairAmountOut(address pair, address tokenIn, uint amountIn) external view returns (uint amountOut);\\n\\n    function getAmountsIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getFactoryAmountsIn(\\n        address factory,\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getAmountsOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getFactoryAmountsOut(\\n        address factory,\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function ensureConstantValue(uint reserve0, uint reserve1, uint balance0Adjusted, uint balance1Adjusted, uint32 tokenWeight0) external view returns (bool);\\n    function getReserves(address pair, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB);\\n    function getOtherToken(address pair, address tokenA) external view returns (address tokenB);\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\\n    function mintLiquidityFee(\\n        uint totalLiquidity,\\n        uint112 reserve0,\\n        uint112  reserve1,\\n        uint32 tokenWeight0,\\n        uint32 tokenWeight1,\\n        uint112  collectedFee0,\\n        uint112 collectedFee1) external view returns (uint amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBdexPair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\ninterface IBdexPair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n\\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\\n    function getSwapFee() external view returns (uint32);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address, uint32, uint32) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBdexRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IBdexRouter {\\n    event Exchange(\\n        address pair,\\n        uint amountOut,\\n        address output\\n    );\\n    struct Swap {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint swapAmount; // tokenInAmount / tokenOutAmount\\n        uint limitReturnAmount; // minAmountOut / maxAmountIn\\n        uint maxPrice;\\n    }\\n    function factory() external view returns (address);\\n    function formula() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function addLiquidity(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address pair,\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n\\n    function swapExactTokensForTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(address tokenOut, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(address tokenIn, uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(address tokenIn, uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(address tokenOut, uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        address tokenOut,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        address tokenIn,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n\\n    function multihopBatchSwapExactIn(\\n        Swap[][] memory swapSequences,\\n        address tokenIn,\\n        address tokenOut,\\n        uint totalAmountIn,\\n        uint minTotalAmountOut,\\n        uint deadline\\n    )\\n    external payable returns (uint totalAmountOut);\\n    function multihopBatchSwapExactOut(\\n        Swap[][] memory swapSequences,\\n        address tokenIn,\\n        address tokenOut,\\n        uint maxTotalAmountIn,\\n        uint deadline\\n    ) external payable returns (uint totalAmountIn);\\n\\n    function createPair( address tokenA, address tokenB,uint amountA,uint amountB, uint32 tokenWeightA, uint32 swapFee, address to) external returns (uint liquidity);\\n    function createPairETH( address token, uint amountToken, uint32 tokenWeight, uint32 swapFee, address to) external payable returns (uint liquidity);\\n\\n    function removeLiquidity(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETH(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address pair,\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address pair,\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n    function div(uint a, uint b) internal pure returns (uint c) {\\n        require(b > 0, 'ds-math-division-by-zero');\\n        c = a / b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.5.16;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenWeightA\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"swapFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"swapFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"createPairETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"formula\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct IBdexRouter.Swap[][]\",\"name\":\"swapSequences\",\"type\":\"tuple[][]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"multihopBatchSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct IBdexRouter.Swap[][]\",\"name\":\"swapSequences\",\"type\":\"tuple[][]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"multihopBatchSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETHSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BdexRouter", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "8899", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}