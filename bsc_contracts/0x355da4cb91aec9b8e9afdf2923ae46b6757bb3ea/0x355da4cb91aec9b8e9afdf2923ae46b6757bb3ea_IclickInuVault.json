{"SourceCode": "/**\r\n * SPDX-License-Identifier: Unlicensed\r\n **/\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\n\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier isHuman() {\r\n        require(tx.origin == msg.sender, \"sorry humans only\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract IclickInuVault is ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    IERC20 internal immutable _usdToken;\r\n    IERC20 private token;\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    IclickInuVault public immutable oldVault;\r\n\r\n    struct User {\r\n        uint _id;\r\n        uint8 _plan;\r\n        uint _deposits; // Token Deposited in USDT value\r\n        uint _earnings; // Available\r\n        uint _commissions; // Total commission earned\r\n        uint _withdrawn; // paid out\r\n        uint expires; // last activation timestamp\r\n        uint lastUpdate;\r\n    }\r\n\r\n    // Program Settings\r\n    uint internal constant DIVIDER = 10000;\r\n    uint[] internal ACTIVPLANS = [\r\n        50 ether,\r\n        100 ether,\r\n        250 ether,\r\n        500 ether,\r\n        2000 ether,\r\n        5000 ether\r\n    ];\r\n\r\n    uint[] internal PROFITCAP = [120, 122, 125, 130, 132, 135]; // Max %earnings per pack\r\n    uint internal immutable LISTINGPRICE = 0.000080 ether;\r\n    uint internal constant DEVFEES = 300; // 3% charge for ops\r\n    // Global Records\r\n    uint public lastUserid;\r\n    uint public totalActivation; // total token spent\r\n    uint public totalUSDTVolume; // total token spent in USDT value\r\n    uint public totalDeposits; // total token deposited\r\n    uint public totalDepositsVlm; // total token deposited in USDT value\r\n    uint public totalUSDTCredited; // total USDT created to users\r\n    uint public totalWithdrawn; // total withdrawn in usdt\r\n\r\n    // Operations\r\n    address private constant systemOps = 0x536682fA000E22D4B41cb4E44Fb094CA18db20B1;\r\n    address private constant activationw = 0x69eaf4Ec5431c4EA6913e3Dea5DB3cD49cA00f9c;\r\n\r\n    mapping(address => User) public users;\r\n\r\n    constructor() {\r\n        _usdToken = IERC20(address(0x55d398326f99059fF775485246999027B3197955)); // testnet 0xC6Efc0f7AF6e0B3e413d8FdD339FAf4d9a6e2D8F 0xaB1a4d4f1D656d2450692D237fdD6C7f9146e814 // mainnet 0x55d398326f99059fF775485246999027B3197955\r\n        token = IERC20(address(0xc8C06a58E4ad7c01b9bb5Af6C76a7a1CfEBd0319)); // testnet 0x80247A78b06bac28B2086D0eb0012feCD0442B66 // mainnet 0xc8C06a58E4ad7c01b9bb5Af6C76a7a1CfEBd0319\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); // testnet 0xD99D1c33F9fC3444f8101754aBC46c52416550D1 // mainnet 0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n        uniswapV2Router = _uniswapV2Router;\r\n        oldVault = IclickInuVault(0x4Bb8328fAC1e193165771cad9DCB4b3003e9C7d4);\r\n    }\r\n\r\n    function registerMember(address _user) private {\r\n        lastUserid++;\r\n        users[_user]._id = lastUserid;\r\n    }\r\n\r\n    function getPack(uint _amount) private view returns (uint8 _packId) {\r\n        _packId = 1;\r\n        _amount = _amount * 115 / 100;\r\n        if (_amount >= ACTIVPLANS[0] && _amount < ACTIVPLANS[1]) {\r\n            _packId = 1;\r\n        } else if (_amount >= ACTIVPLANS[1] && _amount < ACTIVPLANS[2]) {\r\n            _packId = 2;\r\n        }\r\n        if (_amount >= ACTIVPLANS[2] && _amount < ACTIVPLANS[3]) {\r\n            _packId = 3;\r\n        }\r\n        if (_amount >= ACTIVPLANS[3] && _amount < ACTIVPLANS[4]) {\r\n            _packId = 4;\r\n        }\r\n        if (_amount >= ACTIVPLANS[4] && _amount < ACTIVPLANS[5]) {\r\n            _packId = 5;\r\n        } else if (_amount >= ACTIVPLANS[5]) {\r\n            _packId = 6;\r\n        }\r\n    }\r\n\r\n    function activatePack(uint _amount) public {\r\n        require(!address(msg.sender).isContract(), \"NotAllowed\");\r\n        User storage _user = users[msg.sender];\r\n\r\n        if (_user._id == 0) {\r\n            registerMember(msg.sender);\r\n        }\r\n\r\n        require(\r\n            token.transferFrom(msg.sender, activationw, _amount),\r\n            \"TransferFailed\"\r\n        );\r\n\r\n        // get TOKEN value in USDT\r\n        uint _tokenUSDTValue = _getTokenRate(_amount, address(token), address(_usdToken));\r\n\r\n        require(_tokenUSDTValue >= 45 ether, \"$50min\");\r\n\r\n        uint8 _packId = getPack(_tokenUSDTValue);\r\n\r\n        require(_user.expires <= block.timestamp, \"DoubleActivation\");\r\n\r\n        _user._plan = _packId;\r\n        _user.expires = block.timestamp + 30 days;\r\n        _user.lastUpdate = block.timestamp;\r\n\r\n        totalActivation += _amount;\r\n        totalUSDTVolume += _tokenUSDTValue;\r\n    }\r\n\r\n    function withdrawUSDT() public {\r\n        require(!address(msg.sender).isContract(), \"NotAllowed\");\r\n        // require(address(msg.sender) == address(systemOps), \"NotAllowed\");\r\n        User storage user_ = users[msg.sender];\r\n        require(\r\n            user_._id != 0 && user_._earnings > 0,\r\n            \"NoBalance\"\r\n        );\r\n        uint _amount = user_._earnings;\r\n        uint256 _contractBalance = _usdToken.balanceOf(address(this));\r\n        require(_contractBalance >= _amount, \"NoLiquidity\");\r\n        user_._earnings = 0;\r\n        user_._withdrawn += _amount;\r\n        uint _fees = (_amount * DEVFEES) / DIVIDER;\r\n        uint _toSend = _amount - _fees;\r\n\r\n        _usdToken.safeTransfer(msg.sender, _toSend);\r\n        _usdToken.safeTransfer(systemOps, _fees);\r\n\r\n        totalWithdrawn += _amount;\r\n    }\r\n\r\n    function depositFunds(uint _amount) public {\r\n        require(!address(msg.sender).isContract(), \"NotAllowed\");\r\n        User storage _user = users[msg.sender];\r\n\r\n        if (_user._id == 0) {\r\n            registerMember(msg.sender);\r\n        }\r\n\r\n        // get TOKEN value in USDT\r\n        uint _tokenUSDTValue = _getTokenRate(_amount, address(token), address(_usdToken));\r\n        \r\n        require(_tokenUSDTValue >= 5 ether, \"rq$10\");\r\n\r\n        require(\r\n            token.transferFrom(msg.sender, activationw, _amount),\r\n            \"TransferFailed\"\r\n        );\r\n        _user._deposits += _tokenUSDTValue;\r\n        // notify new deposit\r\n        totalDeposits += _amount;\r\n        totalDepositsVlm += _tokenUSDTValue;\r\n    }\r\n\r\n    function updateClicks(address _user, uint _amount, uint _commission, uint _dbE) public {\r\n        require(address(msg.sender) == address(systemOps), \"NotAllowed\");\r\n        User storage user_ = users[_user];\r\n        require(\r\n            user_._id != 0 &&\r\n                user_.expires >= block.timestamp &&\r\n                user_.lastUpdate + 1 hours <= block.timestamp,\r\n            \"inValid\"\r\n        );\r\n        user_._earnings += _amount;\r\n        user_._commissions = _commission;\r\n        user_.lastUpdate = block.timestamp;\r\n        totalUSDTCredited += _amount;\r\n\r\n        uint _totalClaimed = user_._earnings + user_._withdrawn;\r\n        if(_totalClaimed > _dbE){\r\n            uint _diff = _totalClaimed - _dbE;\r\n            if(user_._earnings > _diff){\r\n                user_._earnings -= _diff;\r\n            }\r\n            else{\r\n                user_._earnings = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTokenAmount(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint _amountIn\r\n    ) private view returns (uint[] memory amounts) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = _tokenA;\r\n        path[1] = _tokenB;\r\n        amounts = uniswapV2Router.getAmountsOut(_amountIn, path);\r\n        return amounts;\r\n    }\r\n\r\n    function _getTokenRate(\r\n        uint256 _amount,\r\n        address _base,\r\n        address _secondary\r\n    ) private view returns (uint256 _tokens) {\r\n        uint[] memory _estimates = getTokenAmount(\r\n            address(_base),\r\n            address(_secondary),\r\n            _amount\r\n        );\r\n        return _estimates[1];\r\n    }\r\n\r\n    function getIclickInuRate() public view returns(uint _value){\r\n        _value = _getTokenRate(1 ether, address(token), address(_usdToken)); // fecth from panackageswap [0.0000002454815253887044]\r\n    }\r\n\r\n    function moveOldUsers(address _oUser, uint _actualBal) public {\r\n        require(address(msg.sender) == address(systemOps), \"NotAllowed\");\r\n        \r\n        require(users[_oUser]._id == 0, 'Duplicate');\r\n\r\n        (uint _id, uint8 _plan, uint _deposits, uint _earnings, uint _commissions, \r\n        uint _withdrawn, uint _expires, ) = oldVault.users(_oUser);\r\n        User storage _user = users[_oUser];\r\n\r\n        _user._id = _id;\r\n        _user._plan = _plan;\r\n        _user._deposits = _deposits; // Token Deposited in USDT value\r\n        _user._earnings = _earnings; // Available\r\n        _user._commissions = _commissions; // Total commission earned\r\n        _user._withdrawn = _withdrawn; // paid out\r\n        _user.expires = _expires; // last activation timestamp\r\n        _user.lastUpdate = block.timestamp;\r\n\r\n        lastUserid++;\r\n        uint _getSettlement = _earnings + _withdrawn;\r\n        \r\n        if(_getSettlement > _actualBal){\r\n            uint _diff = _getSettlement - _actualBal;\r\n            if(_earnings > _diff){\r\n                uint _updt = _earnings - _diff;\r\n                _user._earnings = _updt;\r\n            }\r\n            else{\r\n                _user._earnings = 0;\r\n            }\r\n        }\r\n        totalUSDTCredited += _earnings + _withdrawn;\r\n        totalWithdrawn += _withdrawn;\r\n        // lastUserid = oldVault.lastUserid();\r\n        // totalActivation = oldVault.totalActivation(); // total token spent\r\n        // totalUSDTVolume = oldVault.totalUSDTVolume(); // total token spent in USDT value\r\n        // totalDeposits = oldVault.totalDeposits(); // total token deposited\r\n        // totalDepositsVlm = oldVault.totalDepositsVlm(); // total token deposited in USDT value\r\n        // totalUSDTCredited = oldVault.totalUSDTCredited(); // total USDT created to users\r\n        // totalWithdrawn = oldVault.totalWithdrawn(); // total withdrawn in usdt\r\n        // _movedUsers = true;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"activatePack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIclickInuRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_actualBal\",\"type\":\"uint256\"}],\"name\":\"moveOldUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldVault\",\"outputs\":[{\"internalType\":\"contract IclickInuVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalActivation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDepositsVlm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUSDTCredited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUSDTVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dbE\",\"type\":\"uint256\"}],\"name\":\"updateClicks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commissions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IclickInuVault", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ece48c3dfbf826c7a4dc6987d724fe728d152dc50cf4ff5a786266cc6f610df3"}