{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/_erc/ERC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IERC.sol\\\";\\r\\n\\r\\nabstract contract ERC is IERC20_ {\\r\\n    string  internal  _symbol;\\r\\n    uint8   internal  _decimals;\\r\\n    uint256 internal  _url;\\r\\n    uint256 internal  _ver;                             /// version\\r\\n    address internal  _owner;                           /// superuser\\r\\n    address internal  _minter;                          /// optional minter contract\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Permit {\\r\\n        uint128 allowance;\\r\\n        uint128 limit;\\r\\n    }\\r\\n    uint256 internal  _totalSupply;\\r\\n    mapping(address => mapping(address => Permit))  internal _permits;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        uint256 max,                                    /// maximum tokens to mint, 0 as unlimited\\r\\n        uint160 owner,\\r\\n        uint256 version\\r\\n    ) {\\r\\n        unchecked {\\r\\n            address me = address(this);\\r\\n            uint128 mintable = (max == 0) ? Num.MAX128 : uint128(max);\\r\\n            _permits[me][_owner = address(owner)].limit =\\r\\n            _permits[Num._0][me].limit = mintable;      /// mintability\\r\\n            _ver = version;\\r\\n            _symbol = symbol_;\\r\\n            _decimals = decimals_;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    modifier ByMint() {\\r\\n        require(msg.sender == _minter,\\\"()\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function name() external view virtual override returns(string memory) {\\r\\n        uint256 url = _url;\\r\\n        return (url == 0) ? _symbol : _toString(url);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function symbol() public view virtual override returns(string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function decimals() external view virtual override returns(uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _permitted(address permitter, address permittee, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if((permitter == Num._0)                    /// this is exclusively for permission to config this contract\\r\\n             &&(permittee == _owner))                   /// and for contract owner only! (unconfiguratable after giving up ownership)\\r\\n                return true;\\r\\n            Permit memory permit = _permits[permitter][permittee];\\r\\n            if(permit.limit >= Num.MAX128)              /// permission between users enable futher uses of defi/game-fi\\r\\n                return true;\\r\\n            if(permit.limit < n)\\r\\n                return false;\\r\\n            permit.limit -= n;\\r\\n            _permits[permitter][permittee] = permit;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission can be issued exclusively by the permitter itself\\r\\n    function _issuePermit(address permitter, address permittee, uint256 amount) internal virtual returns(bool) {\\r\\n        uint256 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if((n == 0)||(permittee == permitter))\\r\\n                return false;\\r\\n            Permit memory p = _permits[permitter][permittee];\\r\\n            if(p.limit < Num.MAX128) {\\r\\n                n += p.limit;                           /// be careful to avoid overflow\\r\\n                p.limit = (n < Num.MAX128) ? uint128(n) : Num.MAX128;\\r\\n                _permits[permitter][permittee] = p;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission can be cancelled only by its holder!\\r\\n    function _cancelPermit(address permitter, address permittee, address payer, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if(permittee == permitter)\\r\\n                return false;\\r\\n            Permit memory p = _permits[permitter][permittee];\\r\\n            if(p.limit == 0)\\r\\n                return false;\\r\\n            if((n == 0)||(n >= p.limit))                /// cancel all of remaining permits\\r\\n                n = p.limit;\\r\\n            bool toAllowance = (payer == permitter);\\r\\n            if(toAllowance) {\\r\\n                amount = uint256(n)+p.allowance;        /// convert permission into allowance\\r\\n                p.allowance = (amount < Num.MAX128) ? uint128(amount) : Num.MAX128;\\r\\n            }\\r\\n            else {\\r\\n                Permit memory pay = _permits[payer][permitter];\\r\\n                if(pay.limit == 0)\\r\\n                    return false;\\r\\n                if(n > pay.limit) n = pay.limit;        /// cannot pass permits over payer's limit\\r\\n                if(pay.limit < Num.MAX128) {\\r\\n                    pay.limit -= n;                     /// (payer->permitter) permission reduced\\r\\n                    _permits[payer][permitter] = pay;\\r\\n                }\\r\\n                if(payer != permittee) {\\r\\n                    pay = _permits[payer][permittee];\\r\\n                    amount = uint256(n)+pay.limit;      /// pass permission to payer, or eliminate debt loop\\r\\n                    pay.limit = (amount < Num.MAX128) ? uint128(amount) : Num.MAX128;\\r\\n                    _permits[payer][permittee] = pay;\\r\\n                }\\r\\n            }\\r\\n            if(p.limit < Num.MAX128) p.limit -= n;      /// permission (permitter->permittee) cancelled\\r\\n            else if(!toAllowance)\\r\\n                return true;\\r\\n            _permits[permitter][permittee] = p;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission check (for owner) to config this contract\\r\\n    function _config(uint256 permission, uint256 value) internal virtual returns(bool) {\\r\\n        require(_permitted(Num._0,msg.sender,permission),\\\"!\\\");\\r\\n        return value >= 0;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _toString(uint256 u) internal view virtual returns(string memory) {\\r\\n        unchecked {\\r\\n            uint b;\\r\\n            for(; b < 256; b += 8)\\r\\n                if((0xFF&(u>>b)) == 0)\\r\\n                    break;\\r\\n            if(b == 0) return \\\"\\\";\\r\\n            bytes memory z = new bytes(b>>3);\\r\\n            for(uint i = 0; i < b; i += 8)\\r\\n                z[i>>3] = bytes1(uint8(u>>i));\\r\\n            u = _url;\\r\\n            return string(z);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./ERC.sol\\\";\\r\\n\\r\\ncontract ERC20 is ERC, IERC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Account {\\r\\n        uint128 balance;                                /// account balance in weis, or the mapped lower 128b of escaped access\\r\\n        uint32  context;                                /// account context, or the mapped higher 32b of escaped access\\r\\n        uint96  escaped;\\r\\n    }\\r\\n    mapping(address => Account)                     internal _accounts;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        uint256 max,                                    /// maximum tokens to mint, 0 as unlimited\\r\\n        uint160 owner,\\r\\n        uint256 version\\r\\n    ) ERC(symbol_,decimals_,max,owner,version) {\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function totalSupply() external view virtual override returns(uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function balanceOf(address account) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            uint160 cmd;\\r\\n            address minter = _minter;\\r\\n            if(account == Num._0)                       /// burned tokens\\r\\n                return _accounts[Num._0].balance;\\r\\n            if(minter.code.length > 0) {                /// extended implementation in 'minter' contract\\r\\n                (v,cmd) = IESC20(minter).Insight(msg.sender,account,Num.NULL);\\r\\n                if(cmd == 0) return v;\\r\\n            }\\r\\n            (v,cmd) = _insight(account,Num.NULL);\\r\\n            if(cmd == 0) return v;                      /// escaped addresses are handled as following\\r\\n            if(cmd == Num.VERSION   ) return _ver;\\r\\n            if(cmd == Num.OWNER     ) return uint160(_owner);\\r\\n            if(cmd == Num.DELEGATE  ) return uint160(_minter);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function allowance(address owner, address spender) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            if(spender == Num._0) v = _permits[owner][msg.sender].limit;\\r\\n            else if(owner == Num._0) v = _permits[msg.sender][spender].limit;\\r\\n            else {\\r\\n                uint160 cmd;\\r\\n                address minter = _minter;\\r\\n                if(minter.code.length > 0) {            /// extended implementation in 'minter' contract\\r\\n                    (v,cmd) = IESC20(minter).Insight(msg.sender,owner,spender);\\r\\n                    if(cmd == 0) return v;\\r\\n                }\\r\\n                (v,cmd) = _insight(owner,spender);\\r\\n                if(cmd == 0) return v;                  /// escaped addresses are handled as following\\r\\n                if(cmd == Num.BALANCE) return _accounts[spender].balance;\\r\\n                if(cmd == Num.ESCAPED) return _accounts[spender].escaped;\\r\\n                return 0;\\r\\n            }\\r\\n            return (v == Num.MAX128) ? Num.MAX256 : v;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function approve(address spender, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,spender,Num.NULL,amount))\\r\\n                    return true;\\r\\n            _permits[msg.sender][spender].allowance = uint128(amount);\\r\\n            emit Approval(msg.sender,spender,amount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transfer(address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            if(amount == 0)                             /// transfer owner when called by owner and 'amount'== 0\\r\\n                if(_transferOwner(msg.sender,to))\\r\\n                    return true;\\r\\n            if(to < Num.MAP_)                           /// burn tokens if 'to'== 0x0~0xF\\r\\n                return _burn(msg.sender,amount);\\r\\n            address minter = _minter;\\r\\n            if(minter == msg.sender)                    /// mintable by 'minter' contract only\\r\\n                return _mint(to,amount);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,Num.NULL,to,amount))\\r\\n                    return true;\\r\\n            uint160 cmd = _transfer(Num.NULL,to,amount);\\r\\n            if(cmd == 0) return true;                   /// escaped addresses are handled as following\\r\\n            if(cmd == Num.URL) return _config(cmd,_url = amount);\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transferFrom(address from, address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(cmd == Num._900)                         /// for extenal to verify/spend permission between users\\r\\n                return _permitted((msg.sender == minter) ? Num._0 : msg.sender,to,amount);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,from,to,amount))\\r\\n                    return true;\\r\\n            if(_transfer(from,to,amount) == 0)\\r\\n                return true;                            /// escaped addresses are handled as following\\r\\n            if(cmd == Num.DEBT) return _issuePermit(msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTOFF) return _cancelPermit(to,msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTPASS) return _cancelPermit(to,msg.sender,address(uint160(amount)),uint128(amount>>160));\\r\\n            if(cmd == Num.DELEGATE) return _config(cmd,uint160(_minter = to));\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _insight(address from, address to) internal virtual view returns(uint256,uint160) {\\r\\n        unchecked {\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(Num._Escaped(from))                      /// escaped address handling, overridable in sub class if necessary\\r\\n                return (0,cmd);\\r\\n            if(to == Num.NULL)                          /// called by 'balanceOf()'\\r\\n                return (_accounts[from].balance,0);\\r\\n            uint128 a = _permits[from][to].allowance;   /// called by 'allowance()'\\r\\n            uint256 v = (a == Num.MAX128) ? Num.MAX256 : a;\\r\\n            return (v,0);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transferOwner(address from, address to) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            if(Num._Escaped(to)||(from == to))\\r\\n                return false;\\r\\n            require(from == _owner,\\\"!\\\");                /// only owner can transfer his ownership\\r\\n            if((_owner = to) == Num._0)                 /// transfer owner\\r\\n                emit Transfer(from,to,0);               /// the ownership is permanently given up when 'to'== 0x0\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// possibly overrided by sub class\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual returns(uint160) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            bool directpay = (from == Num.NULL);        /// if called by 'transfer()'\\r\\n            address map = directpay ? to : from;\\r\\n            if(Num._Escaped(map))                       /// escaped address handling, overridable in sub class if necessary\\r\\n                return uint160(map);\\r\\n            if(directpay) from = msg.sender;\\r\\n            if((from == to)||(to == Num._0)||(n == 0))\\r\\n                return 0;\\r\\n            if(msg.sender != from)                        /// check/spend allowance if necessary\\r\\n                _spend(from,n);\\r\\n            Account memory a = _accounts[from];\\r\\n            require(a.balance >= n,\\\"$\\\");                /// revert if insufficient fund of 'from'\\r\\n            a.balance -= n;\\r\\n            _accounts[from] = a;\\r\\n            _accounts[to].balance += n;\\r\\n            if((from != Num._0)                         /// event in _mint()\\r\\n               &&(to != Num._0))                        /// event in _burn()\\r\\n                emit Transfer(from,to,n);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// spend allowance in transferFrom()\\r\\n    function _spend(address from, uint128 n) internal virtual {\\r\\n        unchecked {\\r\\n            Permit memory permit = _permits[from][msg.sender];\\r\\n            if(permit.allowance >= Num.MAX128)          /// infinte allowance\\r\\n                return;\\r\\n            if(permit.allowance >= n)                   /// bingo\\r\\n                permit.allowance -= n;\\r\\n            else {                                      /// uncommon path: permit.limit is introduced for further defi uses\\r\\n                if(permit.limit < Num.MAX128) {         /// and is exclusively issued by owner\\r\\n                    n -= permit.allowance;\\r\\n                    require(permit.limit >= n,\\\"*\\\");\\r\\n                    permit.limit -= n;\\r\\n                } else if(permit.allowance == 0)        /// gas saving\\r\\n                    return;\\r\\n                permit.allowance = 0;\\r\\n            }\\r\\n            _permits[from][msg.sender] = permit;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _burn(address from, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            Account memory a = _accounts[from];\\r\\n            require(a.balance >= n,\\\"$\\\");\\r\\n            _totalSupply -= n;\\r\\n            a.balance -= n;\\r\\n            _accounts[from] = a;\\r\\n            _accounts[Num._0].balance += n;\\r\\n            emit Transfer(from,Num._0,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// possibly overrided by sub class\\r\\n    function _mint(address to, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            Permit memory reserve = _permits[Num._0][address(this)];\\r\\n            if(reserve.limit < Num.MAX128) {            /// default implementation to constrain minting limit\\r\\n                if(reserve.limit < n)\\r\\n                    n = reserve.limit;\\r\\n                reserve.limit -= n;\\r\\n                _permits[Num._0][address(this)] = reserve;\\r\\n            }\\r\\n            _totalSupply += n;\\r\\n            _accounts[to].balance += n;\\r\\n            emit Transfer(Num._0,to,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/IERC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\n/// import \\\"hardhat/console.sol\\\";\\r\\n\\r\\ninterface IERC20_ {\\r\\n    /////////////////////////////////////////////////////// interface of the ERC20 standard as defined in the EIP\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\ninterface IERC20 is IERC20_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC20Received(address from, address to, uint256 amount, uint256 data) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface IERC721Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\r\\n}\\r\\ninterface IERC165 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\ninterface IERC721Enumerable_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function totalSupply() external view returns(uint256);\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns(uint256);\\r\\n    function tokenByIndex(uint256 index) external view returns(uint256);\\r\\n}\\r\\ninterface IERC721Metadata_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function name() external view returns(string memory);\\r\\n/// function symbol() external view returns(string memory);\\r\\n    function tokenURI(uint256 tokenId) external view returns(string memory);\\r\\n}\\r\\ninterface IERC721_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function balanceOf(address owner) external view returns(uint256 balance);\\r\\n    function ownerOf(uint256 tokenId) external view returns(address);\\r\\n    function getApproved(uint256 tokenId) external view returns(address);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns(bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n/// function approve(address to, uint256 tokenId) external;\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n}\\r\\ninterface IESC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Insight(address caller, address from, address to) external view returns(uint256,uint160);\\r\\n    function Escape(address caller, address from, address to, uint256 amount) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface ISwap {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Swap(\\r\\n        address payer,                                  /// shall =caller if 'token' != USSSD\\r\\n                                                        /// or, caller must own a debt of payer and owe to this contract\\r\\n        uint256 amount,                                 /// amount of 'token' to sell\\r\\n        address token,                                  /// IERC20 token to sell\\r\\n        address tokenToReceive,                         /// IERC20 token to receive\\r\\n        uint256 minToReceive,                           /// minimum amount of 'tokenToReceive' to swap\\r\\n        address recipient                               /// target wallet\\r\\n    ) external returns(uint256);                        /// actual tokens received\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Estimate(uint256 amount, address token, address tokenToReceive) external view returns(uint256);\\r\\n}\\r\\n\\r\\n///////////////////////////////////////////////////////////\\r\\ninterface IDaoAgency {\\r\\n    function ApplyDao(address agent) external returns (address);\\r\\n}\\r\\n\\r\\nlibrary Num {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant MAX256      = type(uint256).max;\\r\\n    uint256 public constant MAX160      = type(uint160).max;\\r\\n    uint128 public constant MAX128      = type(uint128).max;\\r\\n    uint64  public constant MAX64       = type(uint64 ).max;\\r\\n    uint32  public constant MAX32       = type(uint32 ).max;\\r\\n    uint256 public constant GWEI        = 10**9;\\r\\n    uint256 public constant TWEI        = 10**12;\\r\\n    uint256 public constant _0_000001   = 10**12;\\r\\n    uint256 public constant _0_00001    = 10**13;\\r\\n    uint256 public constant _0_0001     = 10**14;\\r\\n    uint256 public constant _0_001      = 10**15;\\r\\n    uint256 public constant _0_01       = 10**16;\\r\\n    uint256 public constant _0_1        = 10**17;\\r\\n    uint256 public constant _1          = 10**18;\\r\\n    uint256 public constant _10         = 10**19;\\r\\n    uint256 public constant _100        = 10**20;\\r\\n    uint256 public constant _1000       = 10**21;\\r\\n    uint256 public constant _10000      = 10**22;\\r\\n    uint256 public constant _100000     = 10**23;\\r\\n    uint256 public constant _1000000    = 10**24;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant CENT        = 10**16;\\r\\n    uint256 public constant DIME        = 10**17;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    address public constant _0          = address(0);\\r\\n    address public constant MAP_        = address(0x10);\\r\\n    address public constant _MAP        = address(0xFFFFFFFFFF);\\r\\n    address public constant ESC         = address(0xFFFFFFFFFFFFFFFF);\\r\\n    address public constant NULL        = address(type(uint160).max);\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Mapped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= _MAP);\\r\\n    }\\r\\n    function _Mapped(address a, address b) internal pure returns(bool) {\\r\\n        return _Mapped((a != NULL) ? a : b);\\r\\n    }\\r\\n    function _Escaped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= ESC);\\r\\n    }\\r\\n    function _Escaped(address a, address b) internal pure returns(bool) {\\r\\n        return _Escaped((a != NULL) ? a : b);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant _900        =  0x900;\\r\\n    uint160 public constant URL         =  0x192;\\r\\n    uint160 public constant GAS         =  0x9a5;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant SN          =   0x50;\\r\\n    uint160 public constant VERSION     =   0x51;\\r\\n    uint160 public constant VER2        =   0x52;\\r\\n    uint160 public constant ACCOUNT     =   0xAC;\\r\\n    uint160 public constant BLK         =   0xB1;\\r\\n    uint160 public constant HASH        =   0xB5;\\r\\n    uint160 public constant BALANCE     =   0xBA;\\r\\n    uint160 public constant ESCAPE      =   0xE5;\\r\\n    uint160 public constant ESCAPED     =   0xED;\\r\\n    uint160 public constant CTX         =   0xFC;\\r\\n    uint160 public constant STATUS      =   0xFF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant USD         = 0xadd0;\\r\\n    uint160 public constant USD1        = 0xadd1;\\r\\n    uint160 public constant USD2        = 0xadd2;\\r\\n    uint160 public constant TOKEN       = 0xadd8;\\r\\n    uint160 public constant USD_        = 0xadd9;\\r\\n    uint160 public constant NFT         = 0xaddA;\\r\\n    uint160 public constant BIND        = 0xaddB;\\r\\n    uint160 public constant SWAP        = 0xaddC;\\r\\n    uint160 public constant DAO         = 0xaddD;\\r\\n    uint160 public constant OWNER       = 0xaddE;\\r\\n    uint160 public constant DELEGATE    = 0xaddF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant DEBT        = 0xDeb0;\\r\\n    uint160 public constant DEBTOFF     = 0xDeb1;\\r\\n    uint160 public constant DEBTPASS    = 0xDeb2;\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/nft/NFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"../ERC20.sol\\\";\\r\\nimport \\\"./NFTIndex.sol\\\";\\r\\n\\r\\ncontract NFT is ERC, IERC165, IERC721Enumerable_, IERC721Metadata_, IERC721_ {\\r\\n    NFTIndex internal _index;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        uint256 build,\\r\\n        address publisher\\r\\n    ) ERC(symbol_,0,0,uint160(build),uint160(publisher)) {\\r\\n    }\\r\\n\\r\\n    /// IERC165\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function supportsInterface(bytes4 interfaceId) override external view virtual returns(bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n    /// IERC721Enumerable\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) override external view virtual returns(uint256) {\\r\\n        return _index.tokenOfOwnerByIndex(owner,index);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function tokenByIndex(uint256 index) override external view virtual returns(uint256) {\\r\\n        return _index.tokenByIndex(index);\\r\\n    }\\r\\n    /// IERC721Metadata_\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function tokenURI(uint256 tokenId) override external view virtual returns(string memory) {\\r\\n        return _index.tokenURI(tokenId,_url);\\r\\n    }\\r\\n    /// IERC721_\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function ownerOf(uint256 tokenId) override external view virtual returns(address) {\\r\\n        return _index.ownerOf(tokenId).a;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function getApproved(uint256 tokenId) override external view virtual returns(address) {\\r\\n        return _index.operatorOf(tokenId).a;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function isApprovedForAll(address owner, address operator) override public view virtual returns(bool) {\\r\\n        return (operator == owner)||(_permits[owner][operator].allowance >= Num.MAX128);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function setApprovalForAll(address operator, bool approved) override external virtual {\\r\\n        unchecked {\\r\\n            Permit memory permit = _permits[msg.sender][operator];\\r\\n            bool max = (permit.allowance == Num.MAX128);\\r\\n            if(max == approved)\\r\\n                return;\\r\\n            permit.allowance = approved ? Num.MAX128 : 0;\\r\\n            _permits[msg.sender][operator] = permit;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) override external virtual {\\r\\n        _index.safeTransferFrom(msg.sender,from,to,tokenId,\\\"\\\",isApprovedForAll(from,msg.sender));\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) override external virtual {\\r\\n        _index.safeTransferFrom(msg.sender,from,to,tokenId,data,isApprovedForAll(from,msg.sender));\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function totalSupply() external view virtual override returns(uint256) {\\r\\n        return (address(_index) == Num._0) ? _totalSupply : _index.totalSupply();\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function balanceOf(address account) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            uint160 cmd;\\r\\n            address minter = _minter;\\r\\n            if(account == Num._0)                       /// burned tokens\\r\\n                return _index.balanceOf(Num._0);\\r\\n            if(minter.code.length > 0) {                /// extended implementation in 'minter' contract\\r\\n                (v,cmd) = IESC20(minter).Insight(msg.sender,account,Num.NULL);\\r\\n                if(cmd == 0) return v;\\r\\n            }\\r\\n            (v,cmd) = _insight(account,Num.NULL);\\r\\n            if(cmd == 0) return v;                      /// escaped addresses are handled as following\\r\\n            if(cmd == Num.VERSION   ) return _ver;\\r\\n            if(cmd == Num.OWNER     ) return uint160(_owner);\\r\\n            if(cmd == Num.DELEGATE  ) return uint160(_minter);\\r\\n            if(cmd == Num.ESCAPE    ) return uint160(address(_index));\\r\\n            if(cmd == Num.SWAP      ) return uint160(_index.Nft());\\r\\n            if(cmd == Num.VER2      ) return _index.Version();\\r\\n            if(cmd == Num.BALANCE   ) return _index.Minted();\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function allowance(address owner, address spender) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            if(spender == Num._0) v = _permits[owner][msg.sender].limit;\\r\\n            else if(owner == Num._0) v = _permits[msg.sender][spender].limit;\\r\\n            else {\\r\\n                uint160 cmd;\\r\\n                address minter = _minter;\\r\\n                if(minter.code.length > 0) {            /// extended implementation in 'minter' contract\\r\\n                    (v,cmd) = IESC20(minter).Insight(msg.sender,owner,spender);\\r\\n                    if(cmd == 0) return v;\\r\\n                }\\r\\n                (v,cmd) = _insight(owner,spender);\\r\\n                if(cmd == 0) return v;                  /// escaped addresses are handled as following\\r\\n                if(cmd == Num.OWNER     ) return uint160(_index.ownerOf(uint160(spender)).a);\\r\\n                if(cmd == Num.DELEGATE  ) return uint160(_index.operatorOf(uint160(spender)).a);\\r\\n                if(cmd == Num.BIND      ) return _index.ownerOf(uint160(spender)).idx;\\r\\n                if(cmd == Num.SN        ) return _index.operatorOf(uint160(spender)).idx;\\r\\n                return 0;\\r\\n            }\\r\\n            return (v == Num.MAX128) ? Num.MAX256 : v;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function approve(address operator, uint256 tokenId) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,operator,Num.NULL,tokenId))\\r\\n                    return true;\\r\\n            address owner = _index.approve(operator,tokenId);\\r\\n            require((owner != operator)&&isApprovedForAll(owner,msg.sender),\\\"*\\\");\\r\\n            emit Approval(owner,operator,tokenId);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transfer(address to, uint256 idx) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            if(idx == 0)                                /// transfer owner when called by owner and 'idx'== 0\\r\\n                if(_transferOwner(msg.sender,to))\\r\\n                    return true;\\r\\n            uint256 amount = idx;\\r\\n            address minter = _minter;\\r\\n            if(minter == msg.sender)                    /// mintable by minter contract only\\r\\n                return _mint(to,amount);\\r\\n            uint256 tokenId;\\r\\n            if(!Num._Escaped(to)) {\\r\\n                tokenId = _index.tokenOfOwnerByIndex(msg.sender,idx-1);\\r\\n                require(tokenId > 0,\\\"!\\\");\\r\\n            }\\r\\n            if(to == Num._0)                            /// burn tokens if 'to'== 0x0\\r\\n                return _burn(msg.sender,tokenId);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,Num.NULL,to,amount))\\r\\n                    return true;\\r\\n            uint160 cmd = _transfer(Num.NULL,to,tokenId);\\r\\n            if(cmd == 0) return true;                   /// escaped addresses are handled as following\\r\\n            if(cmd == Num.URL) return _config(cmd,_url = amount);\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            uint256 amount = tokenId;\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(cmd == Num._900)                         /// for extenal to verify/spend permission between users\\r\\n                return _permitted((msg.sender == minter) ? Num._0 : msg.sender,to,amount);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,from,to,tokenId))\\r\\n                    return true;\\r\\n            if(_transfer(from,to,tokenId) == 0)\\r\\n                return true;                            /// escaped addresses are handled as following\\r\\n            if(cmd == Num.DEBT) return _issuePermit(msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTOFF) return _cancelPermit(to,msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTPASS) return _cancelPermit(to,msg.sender,address(uint160(amount)),uint128(amount>>160));\\r\\n            if(cmd == Num.DELEGATE) return _config(cmd,uint160(_minter = to));\\r\\n            if(cmd == Num.ESCAPE) return _config(cmd,uint160(address(_index = NFTIndex(to))));\\r\\n            if(cmd == Num.HASH) {                       /// modify NFT meta data\\r\\n                uint160 i = uint160(to);\\r\\n                uint64 id = uint64(i);\\r\\n                if((i >>= 64) <= 0xFF)                  /// meta[1~255] require contract owner to modify\\r\\n                    _config(1,0);\\r\\n                _index.SetMeta(msg.sender,id,i,amount); /// meta[256..] can be modified only by its owner\\r\\n            }\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _insight(address from, address to) internal virtual view returns(uint256,uint160) {\\r\\n        unchecked {\\r\\n            if(Num._Escaped(from)) {                    /// escaped address\\r\\n                uint160 cmd = uint160(from);\\r\\n                uint160 sub = cmd>>40;\\r\\n                if(sub == 0)\\r\\n                    return (0,cmd);\\r\\n                uint40 tokenId = uint40(cmd);\\r\\n                if(to == Num.NULL) {                    /// called by 'balanceOf()', return token id by global index\\r\\n                    return (_index.tokenByIndex(tokenId),0);\\r\\n                } else {                                /// called by 'allowance()'\\r\\n                    uint256 i = uint160(to);            /// return NFT token meta\\r\\n                    return (_index.Meta(tokenId,i),0);\\r\\n                }\\r\\n            }\\r\\n            if(to == Num.NULL)                          /// called by 'balanceOf()' for normal user address\\r\\n                return (_index.balanceOf(from),0);      /// return number of NFT tokens held by user\\r\\n            if(to <= Num.ESC)                           /// called by 'allowance()', return token id by owner's index\\r\\n                return (_index.tokenOfOwnerByIndex(from,uint160(to)),0);\\r\\n            uint128 a = _permits[from][to].allowance;\\r\\n            uint256 v = (a == Num.MAX128) ? Num.MAX256 : a;\\r\\n            return (v,0);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _spend(address owner) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            Permit memory permit = _permits[owner][msg.sender];\\r\\n            if(permit.allowance >= Num.MAX128)          /// approved by 'setApprovalForAll()'\\r\\n                return true;\\r\\n            if(permit.allowance > 0)\\r\\n                permit.allowance --;\\r\\n            else if(permit.limit >= Num.MAX128)\\r\\n                return true;\\r\\n            else {\\r\\n                if(permit.limit == 0)\\r\\n                    return false;\\r\\n                permit.limit --;\\r\\n            }\\r\\n            _permits[owner][msg.sender] = permit;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transferOwner(address from, address to) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            if(Num._Escaped(to)||(from == to))\\r\\n                return false;\\r\\n            require(from == _owner,\\\"!\\\");                /// only owner can transfer his ownership\\r\\n            if((_owner = to) == Num._0)                 /// transfer owner\\r\\n                emit Transfer(from,to,0);               /// the ownership is permanently given up when 'to'== 0x0\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual returns(uint160) {\\r\\n        unchecked {\\r\\n            bool directpay = (from == Num.NULL);\\r\\n            address map = directpay ? to : from;\\r\\n            if(Num._Escaped(map))                       /// escaped address\\r\\n                return uint160(map);\\r\\n            if(directpay) from = msg.sender;\\r\\n            if((tokenId == 0)||(to == Num._0)||(from == to))\\r\\n                return 0;\\r\\n            bool approved = isApprovedForAll(from,to);\\r\\n            if(!approved) approved = _spend(from);\\r\\n            if(_index.transfer(msg.sender,from,to,tokenId,approved)) {\\r\\n                address minter = _minter;\\r\\n                if(minter.code.length > 0)              /// ask 'minter' to do post-transfer handling if applicable\\r\\n                    require(IESC20(minter).Escape(address(Num.SWAP),from,to,tokenId),'.');\\r\\n                emit Transfer(from,to,tokenId);\\r\\n            }\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _burn(address from, uint256 tokenId) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            if(!_index.burn(from,tokenId,false))\\r\\n                return false;\\r\\n            address minter = _minter;\\r\\n            if(minter.code.length > 0)                  /// ask 'minter' to do post-transfer handling if applicable\\r\\n                require(IESC20(minter).Escape(address(Num.SWAP),from,Num._0,tokenId),'.');\\r\\n            emit Transfer(from,Num._0,tokenId);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _mint(address to, uint256 amount) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            amount = _index.mint(to,amount);\\r\\n            if(amount == 0)\\r\\n                return false;\\r\\n            emit Transfer(Num._0,to,amount);\\r\\n            address minter = _minter;\\r\\n            if(minter.code.length > 0)                  /// ask 'minter' to do post-transfer handling if applicable\\r\\n                for(uint256 id = _index.Minted(); amount > 0; amount --)\\r\\n                    IESC20(minter).Escape(address(Num.SWAP),Num._0,to,id --);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _toString(uint256 u) override internal view virtual returns(string memory) {\\r\\n        return _index.toString(u,256);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/nft/NFTIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"../IERC.sol\\\";\\r\\n\\r\\ncontract NFTIndex {\\r\\n    uint256 internal  _ver;                             /// version\\r\\n    address internal  _nft;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Owner {\\r\\n        address a;\\r\\n        uint64  idx;\\r\\n    }\\r\\n    struct Operator {\\r\\n        address a;\\r\\n        uint64  idx;\\r\\n    }\\r\\n    uint64  internal _n;\\r\\n    uint64  internal _maxId;\\r\\n    mapping(uint64  => uint64)                          internal _totalIds;\\r\\n    mapping(uint224 => uint64)                          internal _ownedIds;\\r\\n    mapping(uint64  => Owner)                           internal _owners;\\r\\n    mapping(uint64  => Operator)                        internal _operators;\\r\\n    mapping(address => uint64)                          internal _balances;\\r\\n    mapping(uint96  => uint256)                         internal _meta;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        address nft,\\r\\n        uint256 version\\r\\n    ) {\\r\\n        unchecked {\\r\\n            _nft = nft;\\r\\n            _ver = version;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    modifier ByNft() {\\r\\n        require(msg.sender == _nft,\\\"()\\\");\\r\\n        _;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Nft() external view virtual returns(address) {\\r\\n        return _nft;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Version() external view virtual returns(uint256) {\\r\\n        return _ver;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Minted() external view virtual returns(uint256) {\\r\\n        return _maxId;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Meta(uint256 tokenId, uint256 i) external view virtual returns(uint256) {\\r\\n        return _meta[uint64(tokenId)|uint96(i<<64)];\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function SetMeta(address operator, uint256 tokenId, uint256 i, uint256 v) ByNft external virtual returns(bool) {\\r\\n        uint64 id = uint64(tokenId);\\r\\n        unchecked {\\r\\n            require((id <= _maxId)&&\\r\\n                    ((i <= 0xFF)\\r\\n                    ||(operator == _owners[id].a)\\r\\n                    ||(operator == _operators[id].a)),\\\"*\\\");\\r\\n            _meta[id|uint96(i<<64)] = v;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function totalSupply() external view virtual returns(uint256) {\\r\\n        return _n;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function balanceOf(address account) external view returns(uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view virtual returns(uint256) {\\r\\n        uint224 idx = uint64(index);\\r\\n        unchecked {\\r\\n            idx <<= 160;\\r\\n            return _ownedIds[idx|uint160(owner)];\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function tokenByIndex(uint256 index) external view virtual returns(uint256) {\\r\\n        return _totalIds[uint64(index)];\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function tokenURI(uint256 tokenId, uint256 url) external view virtual returns(string memory) {\\r\\n        unchecked {\\r\\n            tokenId = toDecimal(tokenId);\\r\\n            return catToString(url,tokenId);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function ownerOf(uint256 tokenId) external view virtual returns(Owner memory) {\\r\\n        return _owners[uint64(tokenId)];\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function operatorOf(uint256 tokenId) external view virtual returns(Operator memory) {\\r\\n        return _operators[uint64(tokenId)];\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function approve(address to, uint256 tokenId) ByNft external virtual returns(address) {\\r\\n        uint64 id = uint64(tokenId);\\r\\n        unchecked {\\r\\n            _operators[id].a = to;\\r\\n            return _owners[id].a;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function safeTransferFrom(address operator, address from, address to, uint256 tokenId, bytes calldata data, bool approved)\\r\\n                ByNft external virtual returns(bool) {\\r\\n        unchecked {\\r\\n            require(tokenId <= _maxId,\\\"#\\\");\\r\\n            if(_transfer(operator,from,to,uint64(tokenId),approved))\\r\\n                return false;\\r\\n            if(to.code.length == 0)\\r\\n                return true;\\r\\n            try IERC721Receiver(to).onERC721Received(operator,from,tokenId,data) returns(bytes4 retval) {\\r\\n                return retval == IERC721Receiver.onERC721Received.selector;\\r\\n            } catch (bytes memory reason) {\\r\\n                require(reason.length < 0,\\\"=\\\");\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function burn(address operator, uint256 tokenId, bool approved) ByNft external virtual returns(bool) {\\r\\n        uint64 id = uint64(tokenId);\\r\\n        unchecked {\\r\\n            require((id <= _maxId)&&\\r\\n                _transfer(operator,Num._0,Num._0,id,approved),\\\"#\\\");\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function mint(address to, uint256 amount) ByNft external virtual returns(uint256) {\\r\\n        uint64 n = uint64(amount);\\r\\n        unchecked {\\r\\n            uint64 id = _maxId;\\r\\n            uint64 i = Num.MAX64-id;\\r\\n            if(n > i) n = i;\\r\\n            if(n == 0)\\r\\n                return 0;\\r\\n            _maxId = id+n;\\r\\n            Owner memory owner;\\r\\n            Operator memory op;\\r\\n            owner.idx = _balances[Num._0];\\r\\n            _balances[Num._0] = owner.idx+n;\\r\\n            for(i = 0; i < n; i ++) {\\r\\n                op.idx = id ++;\\r\\n                uint224 idx = owner.idx ++;\\r\\n                idx <<= 160;\\r\\n                _operators[id] = op;\\r\\n                _owners[id] = owner;\\r\\n                _ownedIds[idx] = id;\\r\\n                _totalIds[op.idx] = id;\\r\\n                uint b = id&0xFF;\\r\\n                uint256 hash = uint256(blockhash(block.number-1));\\r\\n                _meta[id|(0x1<<64)] = (hash<<b)|(hash>>(256-b));\\r\\n            }\\r\\n            if(to != Num._0) {\\r\\n                id = _maxId;\\r\\n                for(i = 0; i < n; i ++)\\r\\n                    _transfer(Num._0,Num._0,to,id --,true);\\r\\n            }\\r\\n            return n;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transfer(address operator, address from, address to, uint256 tokenId, bool approved) ByNft external virtual returns(bool) {\\r\\n        require(tokenId <= _maxId,\\\"#\\\");\\r\\n        return _transfer(operator,from,to,uint64(tokenId),approved);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transfer(address operator, address from, address to, uint64 id, bool approved) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            Owner memory owner = _owners[id];\\r\\n            if(to == owner.a)\\r\\n                return false;\\r\\n            Operator memory op = _operators[id];\\r\\n            if(from == Num._0) from = owner.a;\\r\\n            require((from == owner.a)&&\\r\\n                    (approved\\r\\n                    ||(operator == op.a)\\r\\n                    ||(operator == owner.a))\\r\\n                    &&_transferCheck(owner.a,to,id),\\r\\n                        \\\"!\\\");\\r\\n            uint224 idx = owner.idx;\\r\\n            idx <<= 160;\\r\\n            idx |= uint160(from);\\r\\n            uint64 last = uint64(-- _balances[from]);\\r\\n            if(owner.idx >= last)                       /// last in owner's list\\r\\n                _ownedIds[idx] = 0;\\r\\n            else {\\r\\n                uint224 toe = last;\\r\\n                toe <<= 160;\\r\\n                toe |= uint160(from);\\r\\n                _owners[_ownedIds[idx] = _ownedIds[toe]].idx = owner.idx;\\r\\n                _ownedIds[toe] = 0;                     /// swap trailing nft to where to be transferred out\\r\\n            }\\r\\n            idx = owner.idx = _balances[owner.a = to] ++;\\r\\n            idx <<= 160;                                /// one more for recipient\\r\\n            idx |= uint160(to);\\r\\n            _ownedIds[idx] = id;                        /// push transferred nft to the end of recipient's list\\r\\n            _owners[id] = owner;                        /// nft transferred\\r\\n            last = uint64(_n);                          /// next to the end of valid list\\r\\n            bool swap;\\r\\n            if(from == Num._0) {                        /// mint a new one\\r\\n                swap = (op.idx > last);                 /// swap to the trailing slot\\r\\n                _n = last+1;\\r\\n            }\\r\\n            else if(to == Num._0) {                     /// burn this one\\r\\n                swap = (op.idx < -- last);              /// swap to the next slot after valid list\\r\\n                _n = last;\\r\\n            }\\r\\n            bool modified = (op.a != Num._0);\\r\\n            op.a = Num._0;                              /// clear operator after transfer\\r\\n            if(swap) {\\r\\n                _totalIds[op.idx] = _totalIds[last];\\r\\n                _totalIds[op.idx = last] = id;\\r\\n                modified = true;\\r\\n            }\\r\\n            if(modified)                                /// update only when necessary\\r\\n                _operators[id] = op;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// to be overrided if applicable\\r\\n    function _transferCheck(address from, address to, uint64 id) internal virtual returns(bool) {\\r\\n        return (id >= 0)||(from == to);\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function toString(uint256 u, uint bits) public pure returns(string memory) {\\r\\n        unchecked {\\r\\n            uint b;\\r\\n            for(; b < bits; b += 8)\\r\\n                if((0xFF&(u>>b)) == 0)\\r\\n                    break;\\r\\n            if(b == 0) return \\\"\\\";\\r\\n            bytes memory z = new bytes(b>>3);\\r\\n            for(uint i = 0; i < b; i += 8)\\r\\n                z[i>>3] = bytes1(uint8(u>>i));\\r\\n            return string(z);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function fromString(string memory s, uint bits) public pure returns(uint256) {\\r\\n        unchecked {\\r\\n            bytes memory z = bytes(s);\\r\\n            uint b = z.length<<3;\\r\\n            if(b > bits)\\r\\n                b = bits;\\r\\n            uint256 u;\\r\\n            for(uint i = 0; i < b; i += 8)\\r\\n                u |= uint256(uint8(z[i>>3]))<<i;\\r\\n            return u;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function catToString(uint256 pfx, uint256 sfx) public pure returns(string memory) {\\r\\n        unchecked {\\r\\n            uint b0;\\r\\n            for(b0 = 0; b0 < 256; b0 += 8)\\r\\n                if((pfx>>b0) == 0)\\r\\n                    break;\\r\\n            uint b1;\\r\\n            for(b1 = 0; b1 < 256; b1 += 8)\\r\\n                if((sfx>>b1) == 0)\\r\\n                    break;\\r\\n            uint len = b0+b1;\\r\\n            bytes memory z = new bytes(len);\\r\\n            uint i;\\r\\n            for(; i < b0; pfx >>= 8)\\r\\n                z[i ++] = bytes1(uint8(pfx));\\r\\n            for(; i < len; sfx >>= 8)\\r\\n                z[i ++] = bytes1(uint8(sfx));\\r\\n            return string(z);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function toDecimal(uint u) public pure returns(uint256) {\\r\\n        unchecked {\\r\\n            uint d;\\r\\n            for(uint v; u > 0; u = v) {\\r\\n                v = u/10;\\r\\n                uint r = u-v*10;\\r\\n                d <<= 8;\\r\\n                d |= r+0x30;\\r\\n            }\\r\\n            return d;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"build\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"publisher\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFT", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000600000000000000000000000001e092827737257ccffaf783cb4b792d1f240fa370000000000000000000000000c31865a16c4f15dbdacb5bc2996f86de5caf6b700000000000000000000000000000000000000000000000000000000000000054d464e6674000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://aa8a7d6c7d7ab73432d032649c63a4c952d4d5619e554d43e29dfb90bdba364c"}