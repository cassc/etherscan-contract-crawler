{"SourceCode": "pragma solidity 0.7.6;     \r\n\r\n// SPDX-License-Identifier: UNLICENSED \r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract FSilver  {\r\n     function getColor()\r\n        external pure\r\n        returns (bytes32) {\r\n            return bytes32(\"BRONZE\");\r\n        }\r\n}\r\n\r\n\r\ncontract FConst is FSilver, ReentrancyGuard {\r\n    uint public constant BASE              = 10**18;\r\n\r\n    uint public constant MIN_BOUND_TOKENS  = 2;\r\n    uint public constant MAX_BOUND_TOKENS  = 2;\r\n\r\n    uint public constant MIN_FEE           = 2000000000000000; \r\n    uint public constant MAX_FEE           = 2000000000000000; // FREE BUYS and sells pay 0.2% to liquidity providers\r\n    uint public constant EXIT_FEE          = BASE / 100; // Covers tx fee\r\n    uint public constant DEFAULT_RESERVES_RATIO = 0;\r\n\r\n    uint public constant MIN_WEIGHT        = BASE;\r\n    uint public constant MAX_WEIGHT        = BASE * 50;\r\n    uint public constant MAX_TOTAL_WEIGHT  = BASE * 50;\r\n    uint public constant MIN_BALANCE       = BASE / 10**12;\r\n\r\n    uint public constant INIT_POOL_SUPPLY  = BASE * 100;\r\n    \r\n    uint public  SM = 10;\r\n    address public FEGstake = 0x4c9BC793716e8dC05d1F48D8cA8f84318Ec3043C;\r\n\r\n    uint public constant MIN_BPOW_BASE     = 1 wei;\r\n    uint public constant MAX_BPOW_BASE     = (2 * BASE) - 1 wei;\r\n    uint public constant BPOW_PRECISION    = BASE / 10**10;\r\n\r\n    uint public constant MAX_IN_RATIO      = BASE / 2;\r\n    uint public constant MAX_OUT_RATIO     = (BASE / 3) + 1 wei;\r\n    uint public MAX_SELL_RATIO             = BASE / SM;\r\n}\r\n\r\n\r\ncontract FNum is ReentrancyGuard, FConst {\r\n\r\n    function btoi(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return a / BASE;\r\n    }\r\n\r\n    function bfloor(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return btoi(a) * BASE;\r\n    }\r\n\r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint c1 = c0 + (BASE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BASE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * BASE;\r\n        require(a == 0 || c0 / a == BASE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    function bpowi(uint a, uint n)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint z = n % 2 != 0 ? a : BASE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    function bpow(uint base, uint exp)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint whole  = bfloor(exp);\r\n        uint remain = bsub(exp, whole);\r\n\r\n        uint wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(uint base, uint exp, uint precision)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint a     = exp;\r\n        (uint x, bool xneg)  = bsubSign(base, BASE);\r\n        uint term = BASE;\r\n        uint sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        for (uint i = 1; term >= precision; i++) {\r\n            uint bigK = i * BASE;\r\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BASE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\ncontract FMath is FSilver, FConst, FNum {\r\n    \r\n        function calcSpotPrice(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint spotPrice)\r\n    {\r\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint ratio = bdiv(numer, denom);\r\n        uint scale = bdiv(BASE, bsub(BASE, swapFee));\r\n        return  (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n\r\n    function calcOutGivenIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut, uint tokenInFee)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint adjustedIn = bsub(BASE, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint foo = bpow(y, weightRatio);\r\n        uint bar = bsub(BASE, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        tokenInFee = bsub(tokenAmountIn, adjustedIn);\r\n        return (tokenAmountOut, tokenInFee);\r\n    }\r\n\r\n\r\n    function calcInGivenOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountIn, uint tokenInFee)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint y = bdiv(tokenBalanceOut, diff);\r\n        uint foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, BASE);\r\n        foo = bmul(tokenBalanceIn, foo);\r\n        tokenAmountIn = bsub(BASE, swapFee);\r\n        tokenAmountIn = bdiv(foo, tokenAmountIn);\r\n        tokenInFee = bdiv(foo, BASE);\r\n        tokenInFee = bsub(tokenAmountIn, tokenInFee);\r\n        return (tokenAmountIn, tokenInFee);\r\n    }\r\n\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee,\r\n        uint reservesRatio\r\n    )\r\n        public pure\r\n        returns (uint poolAmountOut, uint reserves)\r\n    {\r\n\r\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n         uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\r\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BASE, zaz));\r\n\r\n        reserves = calcReserves(tokenAmountIn, tokenAmountInAfterFee, reservesRatio);\r\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\r\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\r\n\r\n \r\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\r\n        return (poolAmountOut, reserves);\r\n    }\r\n\r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n\r\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BASE, EXIT_FEE));\r\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\r\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n\r\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BASE, normalizedWeight));\r\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\r\n        uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\r\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BASE, zaz));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountOut,\r\n        uint swapFee,\r\n        uint reservesRatio\r\n    )\r\n        public pure\r\n        returns (uint poolAmountIn, uint reserves)\r\n    {\r\n\r\n\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        uint zar = bmul(bsub(BASE, normalizedWeight), swapFee);\r\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BASE, zar));\r\n        reserves = calcReserves(tokenAmountOutBeforeSwapFee, tokenAmountOut, reservesRatio);\r\n\r\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\r\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\r\n\r\n\r\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\r\n\r\n\r\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BASE, EXIT_FEE));\r\n        return (poolAmountIn, reserves);\r\n    }\r\n\r\n    function calcReserves(uint amountWithFee, uint amountWithoutFee, uint reservesRatio)\r\n        internal pure\r\n        returns (uint reserves)\r\n    {\r\n        require(amountWithFee >= amountWithoutFee, \"ERR_MATH_APPROX\");\r\n        require(reservesRatio <= BASE, \"ERR_INVALID_RESERVE\");\r\n        uint swapFeeAndReserves = bsub(amountWithFee, amountWithoutFee);\r\n        reserves = bmul(swapFeeAndReserves, reservesRatio);\r\n        require(swapFeeAndReserves >= reserves, \"ERR_MATH_APPROX\");\r\n    }\r\n\r\n    function calcReservesFromFee(uint fee, uint reservesRatio)\r\n        internal pure\r\n        returns (uint reserves)\r\n    {\r\n        require(reservesRatio <= BASE, \"ERR_INVALID_RESERVE\");\r\n        reserves = bmul(fee, reservesRatio);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address whom) external view returns (uint);\r\n    function allowance(address src, address dst) external view returns (uint);\r\n\r\n    function approve(address dst, uint amt) external returns (bool);\r\n    function transfer(address dst, uint amt) external returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint amt\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface wrap {\r\n    function deposit(uint256 _amount) external;\r\n    function withdraw(uint amt) external;\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ncontract FTokenBase is ReentrancyGuard, FNum {\r\n\r\n    mapping(address => uint)                   internal _balance;\r\n    mapping(address => mapping(address=>uint)) internal _allowance;\r\n    uint internal _totalSupply;\r\n\r\n    event Approval(address indexed src, address indexed dst, uint amt);\r\n    event Transfer(address indexed src, address indexed dst, uint amt);\r\n\r\n    function _mint(uint amt) internal {\r\n        _balance[address(this)] = badd(_balance[address(this)], amt);\r\n        _totalSupply = badd(_totalSupply, amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint amt) internal {\r\n        require(_balance[address(this)] >= amt);\r\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\r\n        _totalSupply = bsub(_totalSupply, amt);\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n\r\n    function _move(address src, address dst, uint amt) internal {\r\n        require(_balance[src] >= amt);\r\n        _balance[src] = bsub(_balance[src], amt);\r\n        _balance[dst] = badd(_balance[dst], amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n\r\n    function _pull(address from, uint amt) internal {\r\n        _move(from, address(this), amt);\r\n    }\r\n}\r\n\r\ncontract FToken is ReentrancyGuard, FTokenBase {\r\n\r\n    string  private _name     = \"FEGexV2\";\r\n    string  private _symbol   = \"FEGfUSDT\";\r\n    uint8   private _decimals = 18;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address src, address dst) external view returns (uint) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external view returns (uint) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\r\n        uint oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint amt) external returns (bool) {\r\n        FEGexV2 ulock;\r\n        bool getlock = ulock.getUserLock(msg.sender);\r\n        \r\n        require(getlock == true, 'Liquidity is locked, you cannot remove liquidity until after lock time.');\r\n        \r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\r\n        require(msg.sender == src || amt <= _allowance[src][msg.sender]);\r\n        FEGexV2 ulock;\r\n        bool getlock = ulock.getUserLock(msg.sender);\r\n        \r\n        require(getlock == true, 'Transfer is Locked ');\r\n        \r\n        \r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\r\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract FEGexV2 is FSilver, ReentrancyGuard, FToken, FMath {\r\n\r\n    struct Record {\r\n        bool bound;   // is token bound to pool\r\n        uint denorm;  // denormalized weight will always be even\r\n        uint index;\r\n        uint balance;\r\n    }\r\n    \r\n    struct userLock {\r\n        bool setLock; // true = locked, false = unlocked\r\n        uint unlockTime;\r\n    }\r\n    \r\n    function getUserLock(address usr) public view returns(bool lock){\r\n        return _userlock[usr].setLock;\r\n    }\r\n    \r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountIn,\r\n        uint256         tokenAmountOut\r\n);\r\n\r\n    event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256         tokenAmountIn,\r\n        uint256         reservesAmount\r\n);\r\n\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountOut,\r\n        uint256         reservesAmount\r\n    );\r\n\r\n    event LOG_CLAIM_RESERVES(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountOut\r\n    );\r\n\r\n    event LOG_ADD_RESERVES(\r\n        address indexed token,\r\n        uint256         reservesAmount\r\n    );\r\n\r\n    event LOG_CALL(\r\n        bytes4  indexed sig,\r\n        address indexed caller,\r\n        bytes           data\r\n    ) anonymous;\r\n\r\n    modifier _logs_() {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex);\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    } \r\n\r\n    modifier _viewlock_() {\r\n        require(!_mutex);\r\n        _;\r\n    }\r\n\r\n    bool private _mutex;\r\n\r\n    wrap wrapp;\r\n    address private _factory = 0x1Eb421973d639C3422904c65Cccc2972b37a17e8;    \r\n    address private _controller = 0x4c9BC793716e8dC05d1F48D8cA8f84318Ec3043C; \r\n    address private _poolOwner;\r\n    address public Wrap = 0xEf11aB854b475Bd0c5Db37f6bFFAB443219d656d;\r\n    address public usdt = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public Token = 0xacFC95585D80Ab62f67A14C566C1b7a49Fe91167;\r\n    address public pairRewardPool = 0x94D4Ac11689C6EbbA91cDC1430fc7dfa9a858753;\r\n    address public burn = 0x000000000000000000000000000000000000dEaD;\r\n    uint public FSS = 25; // FEGstake Share\r\n    uint public PSS = 20; // pairRewardPool Share\r\n    uint public RPF = 998; //Smart Rising Price Floor Setting\r\n    uint public SHR = 995; //p2p fee Token\r\n    uint public SHR1 = 997; //p2p fee Wrap\r\n    uint private _swapFee;\r\n    address[] private _tokens;\r\n    uint256 public _totalSupply1;\r\n    uint256 public _totalSupply2;\r\n    bool public live = false;\r\n    mapping(address=>Record) private  _records;\r\n    mapping(address=>userLock) public  _userlock;\r\n    mapping(address=>userLock) public  _unlockTime;\r\n    mapping(address=>bool) public whiteListContract;\r\n    mapping(address => uint256) private _balances1;\r\n    mapping(address => uint256) private _balances2;\r\n    \r\n    uint private _totalWeight;\r\n\r\n    constructor() {\r\n        wrapp = wrap(Wrap);\r\n        _poolOwner = msg.sender;\r\n        //pairRewardPool = msg.sender;\r\n        _swapFee = MIN_FEE;\r\n    }\r\n    \r\n    receive() external payable {\r\n    }\r\n\r\n    function userBalanceInternal(address _addr) public view returns (uint256 token, uint256 fwrap) {\r\n        return (_balances1[_addr], _balances2[_addr]);\r\n    } \r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        \r\n        if(IsWhiteListContract(account)) {  return false; }\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    \r\n    function addWhiteListContract(address _addy, bool boolean) public {\r\n        require(msg.sender == _controller);\r\n        require(_addy != address(0), \"setting 0 address;;\");\r\n        \r\n        whiteListContract[_addy] = boolean;\r\n    }\r\n    \r\n    function IsWhiteListContract(address _addy) public view returns(bool){\r\n        require(_addy != address(0), \"setting 0 address;;\");\r\n        \r\n        return whiteListContract[_addy];\r\n    }\r\n    \r\n    modifier noContract() {\r\n        require(isContract(msg.sender) == false, 'Unapproved contracts are not allowed to interact with the swap');\r\n        _;\r\n    }\r\n    \r\n    function setMaxSellRatio(uint256 _amount) public {\r\n        require(msg.sender == _poolOwner, \"You do not have permission\");\r\n        require (_amount > 0, \"cannot turn off\");\r\n        require (_amount <= 100, \"cannot set under 1%\");\r\n        SM = _amount;\r\n    }\r\n    \r\n    function setStakePool(address _addy) public {\r\n        require(msg.sender == _controller);\r\n    FEGstake = _addy;\r\n    }\r\n    \r\n    function setPairRewardPool(address _addy) public {\r\n        require(msg.sender == _controller);\r\n    pairRewardPool = _addy;\r\n    }\r\n    \r\n    function setupWrap() public {\r\n        IERC20(address(usdt)).approve(address(Wrap), 100000000000000000e18);        \r\n    }  \r\n    \r\n    function isBound(address t)\r\n        external view\r\n        returns (bool)\r\n    {\r\n        return _records[t].bound;\r\n    }\r\n\r\n    function getFinalTokens()\r\n        external view\r\n        _viewlock_\r\n        returns (address[] memory tokens)\r\n    {\r\n        \r\n        return _tokens;\r\n    }\r\n\r\n    function getDenormalizedWeight(address token)\r\n        external view\r\n        _viewlock_\r\n    {\r\n\r\n        require(_records[token].bound);\r\n    }\r\n\r\n    function getTotalDenormalizedWeight()\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n        return _totalWeight;\r\n    }\r\n\r\n    function getNormalizedWeight(address token)\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound);\r\n        return _totalWeight;\r\n    }\r\n\r\n    function getBalance(address token)\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound);\r\n        return _records[token].balance;\r\n    }\r\n\r\n    function getSwapFee()\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n        return _swapFee;\r\n    }\r\n\r\n    function getController()\r\n        external view\r\n        _viewlock_\r\n        returns (address)\r\n    {\r\n        return _controller;\r\n    }\r\n\r\n    function setController(address manager)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(msg.sender == _controller);\r\n        _controller = manager;\r\n    }\r\n\r\n    function deploySwap (uint256 amtoftoken, uint256 amtofwrap)\r\n        external\r\n        {\r\n        require(msg.sender == _poolOwner);\r\n        require(live == false);\r\n        address tokenIn = Token;\r\n        address tokenIn1 = Wrap;\r\n        \r\n        _records[Token] = Record({\r\n            bound: true,\r\n            denorm: BASE * 25,\r\n            index: _tokens.length,\r\n            balance: (amtoftoken * 98/100)\r\n            \r\n        });\r\n        \r\n        _records[Wrap] = Record({\r\n            bound: true,\r\n            denorm: BASE * 25,\r\n            index: _tokens.length,\r\n            balance: (amtofwrap * 99/100)\r\n        });\r\n        live = true;\r\n        _tokens.push(Token);\r\n        _tokens.push(Wrap);\r\n        _pullUnderlying(tokenIn, msg.sender, amtoftoken);\r\n        _pullUnderlying(tokenIn1, msg.sender, amtofwrap);\r\n        _mint(INIT_POOL_SUPPLY);\r\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY); \r\n        address user = msg.sender;\r\n        userLock storage ulock = _userlock[user];\r\n        userLock storage time = _unlockTime[user];\r\n        ulock.setLock = true;\r\n        time.unlockTime = block.timestamp + 365 days ; \r\n        setupWrap();\r\n    }\r\n   \r\n    function saveLostTokens(address token, uint amount)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(msg.sender == _controller);\r\n        require(!_records[token].bound);\r\n\r\n        uint bal = IERC20(token).balanceOf(address(this));\r\n        require(amount <= bal);\r\n\r\n        _pushUnderlying(token, msg.sender, amount);\r\n    }\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut)\r\n        external view\r\n        _viewlock_\r\n        returns (uint spotPrice)\r\n    {\r\n        \r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n        return calcSpotPrice(inRecord.balance, BASE * 25, outRecord.balance, BASE * 25, _swapFee);}\r\n        \r\n\r\n    function depositToken(uint256 amt)  external noContract nonReentrant {\r\n        address tokenIn = Token;\r\n        _pullUnderlying(tokenIn, msg.sender, amt);\r\n        \r\n       \r\n        uint256 finalAmount = amt * 98/100;\r\n        _totalSupply1 = _totalSupply1 + finalAmount;\r\n        _balances1[msg.sender] = _balances1[msg.sender] + finalAmount;\r\n    }\r\n    \r\n    function depositWrap(uint256 amt)  external noContract nonReentrant {\r\n        address tokenIn = Wrap;\r\n        _pullUnderlying(tokenIn, msg.sender, amt);\r\n        \r\n       \r\n        uint256 finalAmount = amt * 99/100;\r\n        _totalSupply2  = _totalSupply2 + finalAmount;\r\n        _balances2[msg.sender] = _balances2[msg.sender] + finalAmount;\r\n    }\r\n    \r\n    function withdrawToken(uint256 amt) external noContract nonReentrant {\r\n        address tokenIn = Token;\r\n        require(_balances1[msg.sender] >= amt, \"Not enough token\");\r\n        \r\n        _totalSupply1 = _totalSupply1 - amt;\r\n        _balances1[msg.sender] = _balances1[msg.sender] - amt;\r\n        \r\n        _pushUnderlying(tokenIn, msg.sender, amt);\r\n        \r\n    }\r\n    \r\n    function withdrawWrap(uint256 amt) external noContract nonReentrant{\r\n        address tokenIn = Wrap;\r\n        require(_balances2[msg.sender] >= amt, \"Not enough Wrap\");\r\n        \r\n        _totalSupply2 = _totalSupply2 - amt;\r\n        _balances2[msg.sender] = _balances2[msg.sender] - amt;\r\n        \r\n        _pushUnderlying(tokenIn, msg.sender, amt);\r\n    }\r\n\r\n    function addBothLiquidity(uint poolAmountOut, uint[] calldata maxAmountsIn)\r\n    noContract nonReentrant\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        \r\n\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = bdiv(poolAmountOut, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountIn = bmul(ratio, bal);\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn, 0);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n            _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\r\n            _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        \r\n    }\r\n   \r\n    function removeBothLiquidity(uint poolAmountIn, uint[] calldata minAmountsOut)\r\n    noContract nonReentrant\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        \r\n        userLock storage ulock = _userlock[msg.sender];\r\n        \r\n        if(ulock.setLock == true) {\r\n            require(ulock.unlockTime <= block.timestamp, \"Liquidity is locked, you cannot remove liquidity until after lock time.\");\r\n        }\r\n\r\n        uint poolTotal = totalSupply();\r\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\r\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(_factory, exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n        \r\n        \r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountOut = bmul(ratio, bal);\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut, 0);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n            _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\r\n            _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function BUYSmart(\r\n        uint tokenAmountIn,\r\n        uint minAmountOut\r\n    ) noContract nonReentrant\r\n        external \r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountOut, uint spotPriceAfter)\r\n    {\r\n        \r\n        address tokenIn = Wrap;\r\n        address tokenOut = Token;\r\n        require(_balances2[msg.sender] >= tokenAmountIn, \"Not enough Wrap, deposit more\");\r\n        \r\n        \r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n        uint spotPriceBefore = calcSpotPrice(\r\n                                    inRecord.balance ,\r\n                                    BASE * 25,\r\n                                    outRecord.balance,\r\n                                    BASE * 25,\r\n                                    _swapFee * 0\r\n                                );\r\n                                \r\n        uint tokenInFee;\r\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            tokenAmountIn * 99/100,\r\n                                            _swapFee * 0\r\n                                        );\r\n                                        \r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");                     \r\n        _balances2[msg.sender] = _balances2[msg.sender] - tokenAmountIn;\r\n        _balances1[msg.sender] = _balances1[msg.sender] + tokenAmountOut;\r\n        _totalSupply2 = _totalSupply2 - tokenAmountIn;\r\n        _totalSupply1 = _totalSupply1 + tokenAmountOut;\r\n        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\r\n        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\r\n        \r\n        spotPriceAfter = calcSpotPrice(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            _swapFee * 0\r\n                            );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n    \r\n    function BUY(\r\n        address to,\r\n        uint256 tokenAmountIn,\r\n        uint minAmountOut\r\n    ) noContract nonReentrant\r\n        external \r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountOut, uint spotPriceAfter)\r\n    {\r\n        \r\n        address tokenIn = Wrap;\r\n        address tokenOut = Token;\r\n        \r\n        \r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        uint spotPriceBefore = calcSpotPrice(\r\n                                    inRecord.balance ,\r\n                                    BASE * 25,\r\n                                    outRecord.balance,\r\n                                    BASE * 25,\r\n                                    _swapFee * 0\r\n                                );\r\n\r\n        uint tokenInFee;\r\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            tokenAmountIn * 99/100,\r\n                                            _swapFee * 0\r\n                                        );\r\n                                        \r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n        _pullUnderlying(usdt, msg.sender, tokenAmountIn);\r\n        wrap(Wrap).deposit(tokenAmountIn);\r\n        _pushUnderlying(tokenOut, to, tokenAmountOut);\r\n        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\r\n        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\r\n        \r\n        spotPriceAfter = calcSpotPrice(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            _swapFee * 0\r\n                            );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        \r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn * 99/100, tokenAmountOut * 98/100);\r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n\r\n    function SELL(\r\n    address to,\r\n        uint tokenAmountIn,\r\n        uint minAmountOut\r\n    ) noContract nonReentrant \r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountOut, uint spotPriceAfter)\r\n    {\r\n        \r\n        address tokenIn = Token;\r\n        address tokenOut = Wrap;\r\n        address too = to;\r\n        uint tai = tokenAmountIn;\r\n        uint tao = tokenAmountOut;\r\n        \r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tai <= bmul(inRecord.balance, MAX_SELL_RATIO), \"ERR_SELL_RATIO\");\r\n                                               \r\n        uint tokenInFee;\r\n        (tao, tokenInFee) = calcOutGivenIn(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            tai * 98/100,\r\n                                            _swapFee\r\n                                        );\r\n        require(tao >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        \r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tai * 98/100, tao * 99/100);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tai);\r\n        uint256 toka = bmul(tao, bdiv(RPF, 1000));\r\n        uint256 tokAmountI  = bmul(tao, bdiv(FSS, 10000));\r\n        uint256 tokAmountI2 =  bmul(tao, bdiv(PSS, 10000));\r\n        uint256 tokAmountI1 = bsub(toka, badd(tokAmountI, tokAmountI2));\r\n        uint256 out1 = tokAmountI1;\r\n        wrap(Wrap).withdraw(out1); \r\n        _pushUnderlying(usdt, too, (out1 * 99/100));\r\n        _pushUnderlying1(tokenOut, tokAmountI);\r\n        _balances2[pairRewardPool] = _balances2[pairRewardPool] + tokAmountI2;\r\n        _totalSupply2 = _totalSupply2 + tokAmountI2;\r\n        uint spotPriceBefore = calcSpotPrice(\r\n                                    inRecord.balance,\r\n                                    BASE * 25,\r\n                                    outRecord.balance,\r\n                                    BASE * 25,\r\n                                    _swapFee\r\n                                );\r\n        require(spotPriceBefore <= bdiv(tai, tao), \"ERR_MATH_APPROX\");                        \r\n        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\r\n        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\r\n        \r\n        spotPriceAfter = calcSpotPrice(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            _swapFee\r\n                            );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        \r\n        \r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n    \r\n     function SELLSmart(\r\n        uint tokenAmountIn,\r\n        uint minAmountOut\r\n    ) noContract nonReentrant\r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountOut, uint spotPriceAfter)\r\n    {\r\n        \r\n        address tokenIn = Token;\r\n        address tokenOut = Wrap;\r\n        \r\n        require(_balances1[msg.sender] >= tokenAmountIn, \"Not enough Token\");\r\n        \r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_SELL_RATIO), \"ERR_SELL_RATIO\");\r\n\r\n        uint spotPriceBefore = calcSpotPrice(\r\n                                    inRecord.balance,\r\n                                    BASE * 25,\r\n                                    outRecord.balance,\r\n                                    BASE * 25,\r\n                                    _swapFee\r\n                                );\r\n\r\n        uint tokenInFee;\r\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            tokenAmountIn * 98/100,\r\n                                            _swapFee\r\n                                        );\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n        uint256 toka = bmul(tokenAmountOut, bdiv(RPF, 1000));\r\n        uint256 tokAmountI  = bmul(tokenAmountOut, bdiv(FSS, 10000));\r\n        uint256 tokAmountI2 =  bmul(tokenAmountOut, bdiv(PSS, 10000));\r\n        uint256 tokAmountI1 = bsub(toka, badd(tokAmountI, tokAmountI2));\r\n        uint256 tok2 = badd(tokAmountI1, tokAmountI2);\r\n        _balances1[msg.sender] = _balances1[msg.sender] - tokenAmountIn;\r\n        _balances2[msg.sender] = _balances2[msg.sender] + tokAmountI1;\r\n        _totalSupply2 = _totalSupply2 + tok2;\r\n        _totalSupply1 = _totalSupply1 - tokenAmountIn;\r\n        _pushUnderlying1(tokenOut, tokAmountI);\r\n        _balances2[pairRewardPool] = _balances2[pairRewardPool] + tokAmountI2;\r\n        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\r\n        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\r\n                          \r\n        spotPriceAfter = calcSpotPrice(\r\n                                            inRecord.balance,\r\n                                            BASE * 25,\r\n                                            outRecord.balance,\r\n                                            BASE * 25,\r\n                                            _swapFee\r\n                            );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        \r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n    \r\n    function setFSS(uint _FSS ) external {\r\n        require(msg.sender == _controller);\r\n        require(_FSS <= 100, \" Cannot set over 1%\");\r\n        require(_FSS > 0, \" Cannot set to 0\");\r\n        FSS = _FSS;\r\n    }\r\n    \r\n    function setPSS(uint _PSS ) external {\r\n        require(msg.sender == _poolOwner);\r\n         require(_PSS <= 100, \" Cannot set over 1%\"); \r\n         require(_PSS > 0, \" Cannot set to 0\");\r\n        PSS = _PSS;\r\n    }\r\n\r\n    function setRPF(uint _RPF ) external {\r\n        require(msg.sender == _poolOwner);\r\n         require(_RPF <= 200, \" Cannot set over 20%\"); \r\n         require(_RPF > 0, \" Cannot set to 0\");\r\n        RPF = _RPF;\r\n    }\r\n    \r\n    function setSHR(uint _SHR, uint _SHR1 ) external {\r\n        require(msg.sender == _controller);\r\n         require(_SHR <= 200 && _SHR1 <=200, \" Cannot set over 20%\"); \r\n         require(_SHR > 0 && _SHR1 > 0, \" Cannot set to 0\"); \r\n        SHR = _SHR;\r\n        SHR1 = _SHR1;\r\n    }\r\n    \r\n    function setLockLiquidity() external { //\r\n        address user = msg.sender;\r\n        userLock storage ulock = _userlock[user];\r\n        userLock storage time = _unlockTime[user];\r\n        ulock.setLock = true;\r\n        time.unlockTime = block.timestamp + 365 days ; \r\n        }\r\n    \r\n    function releaseLiquidity() external { // Allows removal of liquidity after the lock period is over\r\n        address user = msg.sender;\r\n        userLock storage ulock = _userlock[user];\r\n        userLock storage time = _unlockTime[user];\r\n        require (block.timestamp >= time.unlockTime, \"Liquidity is locked, you cannot remove liquidity until after lock time.\");\r\n        ulock.setLock = false; \r\n    }\r\n    \r\n    function emergencyLockOverride(address user, bool _bool, uint _time) external {\r\n        require(msg.sender == _controller);\r\n        userLock storage ulock = _userlock[user];\r\n        userLock storage time = _unlockTime[user];\r\n        ulock.setLock = _bool;\r\n        time.unlockTime = _time;\r\n    }\r\n\r\n    function _pullUnderlying(address erc20, address from, uint amount)\r\n        internal\r\n    {   \r\n        require(amount > 0, \"Cannot deposit nothing\");\r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n        \r\n    }\r\n\r\n    function _pushUnderlying(address erc20, address to, uint amount)\r\n        internal\r\n    {   \r\n        require(amount > 0, \"Cannot withdraw nothing\");\r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n    \r\n    function _pushUnderlying1(address erc20, uint amount)\r\n        internal\r\n    {\r\n        bool xfer = IERC20(erc20).transfer(FEGstake, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint amount)\r\n        internal\r\n    {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint amount)\r\n        internal\r\n    {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint amount)\r\n        internal\r\n    {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint amount)\r\n        internal\r\n    {\r\n        _burn(amount);\r\n    }\r\n\r\n    function PayWrap(address payee, uint amount)\r\n        external noContract nonReentrant \r\n        \r\n    {   \r\n        require(_balances2[msg.sender] >= amount, \"Not enough token\");\r\n        uint256 amt = amount * SHR1/1000;\r\n        uint256 amt1 = amount - amt;\r\n        _balances2[msg.sender] = _balances2[msg.sender] - amount;\r\n        _balances2[payee] = _balances2[payee] + amt;\r\n        _balances2[_factory] = _balances2[_factory] + amt1;\r\n    }\r\n    \r\n    function PayToken(address payee, uint amount)\r\n        external noContract nonReentrant \r\n        \r\n    {\r\n        require(_balances1[msg.sender] >= amount, \"Not enough token\");\r\n        uint256 amt = amount * SHR/1000;\r\n        uint256 amt1 = amount - amt;\r\n        _balances1[msg.sender] = _balances1[msg.sender] - amount;\r\n        _balances1[payee] = _balances1[payee] + amt;\r\n        _pushUnderlying(Token, burn, amt1);\r\n        _totalSupply1 = _totalSupply1 - amt1;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservesAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_ADD_RESERVES\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_CLAIM_RESERVES\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservesAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservesAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"BUY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"BUYSmart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_RESERVES_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEGstake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FSS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"IsWhiteListContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SELL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PSS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RPF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"SELL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"SELLSmart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHR1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wrap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_unlockTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"setLock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"setLock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"addBothLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"boolean\",\"type\":\"bool\"}],\"name\":\"addWhiteListContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservesRatio\",\"type\":\"uint256\"}],\"name\":\"calcPoolInGivenSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservesRatio\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amtoftoken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amtofwrap\",\"type\":\"uint256\"}],\"name\":\"deploySwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"depositWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"emergencyLockOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"getUserLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairRewardPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"removeBothLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"saveLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_FSS\",\"type\":\"uint256\"}],\"name\":\"setFSS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setLockLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaxSellRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_PSS\",\"type\":\"uint256\"}],\"name\":\"setPSS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"setPairRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_RPF\",\"type\":\"uint256\"}],\"name\":\"setRPF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_SHR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_SHR1\",\"type\":\"uint256\"}],\"name\":\"setSHR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"setStakePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setupWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userBalanceInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fwrap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteListContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FEGexV2", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5996d323b087466f9c0e38930c1cd019c91a7747f5a1492056bdddf3ad54d4c1"}