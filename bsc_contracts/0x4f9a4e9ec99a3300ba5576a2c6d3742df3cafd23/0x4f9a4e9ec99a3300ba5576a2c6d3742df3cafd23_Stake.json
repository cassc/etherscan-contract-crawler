{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/src/contracts811/Stake.sol\": {\r\n      \"content\": \"pragma solidity 0.8.11;\\ninterface IBEP20 { \\n\\tfunction totalSupply() external view returns (uint256);\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\tfunction transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);\\n\\tfunction mint(address account, uint256 amount) external returns (bool);\\n\\tfunction burn(address account, uint256 amount) external returns (bool);\\n\\tfunction addOperator(address minter) external returns (bool);\\n\\tfunction removeOperator(address minter) external returns (bool);\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\tevent Approval( address indexed owner, address indexed spender, uint256 value );\\n}\\nlibrary SafeBEP20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n    function safeApprove(IBEP20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeBEP20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\\n        // uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeBEP20: decreased allowance below zero\\\");\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n    function callOptionalReturn(IBEP20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeBEP20: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeBEP20: low-level call failed\\\");\\n        if (returndata.length > 0) { \\n            require(abi.decode(returndata, (bool)), \\\"SafeBEP20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        return c;\\n    }\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n} \\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) { return msg.sender;}\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this;\\n        return msg.data;\\n    }\\n}\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IERC165).interfaceId; }\\n}\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n    mapping(bytes32 => RoleData) private _roles;\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool){\\n        return\\n            interfaceId == type(IAccessControl).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n    function hasRole(bytes32 role, address account) public view override returns (bool) { return _roles[role].members[account]; }\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) { return _roles[role].adminRole; }\\n    function grantRole(bytes32 role, address account) public virtual override { \\n        require( hasRole(getRoleAdmin(role), _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n        _grantRole(role, account);\\n    }\\n    function revokeRole(bytes32 role, address account) public virtual override {\\n        require( hasRole(getRoleAdmin(role), _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n        _revokeRole(role, account);\\n    }\\n    function renounceRole(bytes32 role, address account) public virtual override\\n    {\\n        require( account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\" );\\n        _revokeRole(role, account);\\n    }\\n    function _setupRole(bytes32 role, address account) internal virtual { _grantRole(role, account); }\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\ninterface Reward { \\n\\tfunction transferToken(IBEP20 _token, address _to, uint256 _amount) external;\\n}\\ncontract Stake is AccessControl {\\n    using SafeMath for uint;\\n    using SafeBEP20 for IBEP20;\\n    IBEP20 public HE;\\n    Reward public RE;\\n    bytes32 public constant CREATOR_ADMIN = keccak256(\\\"CREATOR_ADMIN\\\");\\n    struct UserInfo {  \\n        uint256 amount;     // How many HE tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        uint256 pendingDebt;\\n    }\\n    mapping(uint256 => mapping(address => bool)) public boolAddWallet;\\n    mapping(uint256 => mapping(address => address)) public addressStake;\\n    uint256 public timeLockWithdraw = 259200;\\n    uint256 public timeLockClaim = 259200;\\n    uint256 public bonusEndBlock;\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IBEP20 heToken;           // Address of HE token contract.\\n        uint256 allocPoint;       // How many allocation points assigned to this pool. HE to distribute per block.\\n        uint256 lastRewardBlock;  // Last block number that HE distribution occurs.\\n        uint256 accHePerShare; // Accumulated HE per share, times 1e18. See below.\\n        uint256 balancePool;\\n    }\\n    struct WithdrawInfo {\\n        uint256 amount;\\n        uint256 blockTime;\\n        uint256 withdrawTime;\\n        uint256 status;\\n    }\\n     struct ClaimInfo {\\n        uint256 amount;\\n        uint256 blockTime;\\n        uint256 claimTime;\\n        uint256 status;\\n    }\\n    uint256 public HePerBlock;\\n    uint256 public constant BONUS_MULTIPLIER = 1;\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes HE tokens.\\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\\n    mapping (uint256 => mapping (address => WithdrawInfo[])) public withdrawInfo;\\n    mapping (uint256 => mapping (address => ClaimInfo[])) public claimInfo;\\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n    // The block number when LUCKY mining starts.\\n    uint256 public startBlock;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount, uint256 blockTime);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, uint256 blockTime);\\n    event Claim(address indexed user, uint256 indexed pid, uint256 reward, uint256 blockTime);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, uint256 blockTime);\\n    event ReInvestment(address indexed user, uint256 indexed pid, uint256 reInvestment, uint256 blockTime);\\n    event AddWallet(address indexed user, uint256 indexed pid, address Walletreceive, uint256 blockTime);\\n    constructor(\\n        address minter,\\n        address _HE,\\n        uint256 _hePerBlock,\\n        uint256 _startBlock,\\n        uint256 _bonusEndBlock,\\n        address _reward\\n    ) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(CREATOR_ADMIN, minter);\\n        HE = IBEP20(_HE);\\n        HePerBlock = _hePerBlock;\\n        startBlock = _startBlock;\\n        bonusEndBlock = _bonusEndBlock;  \\n        RE = Reward(_reward);\\n    }\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    function changeTimeLockWithdraw(uint256 _timeLock) external {\\n        require(hasRole(DEFAULT_ADMIN_ROLE, address(msg.sender)), \\\"Caller is not a owner\\\");\\n        timeLockWithdraw = _timeLock;\\n    }\\n    function changeTimeLockClaim(uint256 _timeLock) external {\\n        require(hasRole(DEFAULT_ADMIN_ROLE, address(msg.sender)), \\\"Caller is not a owner\\\");\\n        timeLockClaim = _timeLock;\\n    }\\n    function changeHePerBlock(uint256 _hePerBlock) external {\\n        require(hasRole(DEFAULT_ADMIN_ROLE, address(msg.sender)), \\\"Caller is not a owner\\\");\\n        massUpdatePools();\\n        HePerBlock = _hePerBlock;\\n    }\\n    function getWithdrawByAddress(uint256 _pid, address _address) public view returns (WithdrawInfo[]  memory) {\\n        return withdrawInfo[_pid][_address];\\n    }\\n    function getClaimByAddress(uint256 _pid, address _address) public view returns (ClaimInfo[]  memory) {\\n        return claimInfo[_pid][_address];\\n    }\\n    function add(uint256 _allocPoint, IBEP20 _heToken, bool _withUpdate) external {\\n        require(hasRole(DEFAULT_ADMIN_ROLE, address(msg.sender)), \\\"Caller is not a owner\\\");\\n        require(block.number > startBlock, 'has not started yet');\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        poolInfo.push(PoolInfo({\\n            heToken: _heToken,\\n            allocPoint: _allocPoint,\\n            lastRewardBlock: lastRewardBlock,\\n            accHePerShare: 0,\\n            balancePool: 0\\n        }));\\n    }\\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external {\\n        require(hasRole(DEFAULT_ADMIN_ROLE, address(msg.sender)), \\\"Caller is not a owner\\\");\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n    }\\n    function addViewWallet(uint256 _pid, address _receive) external {\\n        require(!boolAddWallet[_pid][_receive], \\\"Wallet has been added\\\");\\n        addressStake[_pid][address(_receive)] = msg.sender;\\n        boolAddWallet[_pid][_receive] = true;\\n        emit AddWallet(msg.sender, _pid, address(_receive), block.timestamp);\\n    }\\n    function getViewWallet(uint256 _pid, address _receive) public view returns (uint256){\\n        address staker = addressStake[_pid][_receive];\\n        UserInfo storage user = userInfo[_pid][staker];\\n        uint256 amount = user.amount;\\n        return amount;\\n    }\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\\n        if (_to <= bonusEndBlock) {\\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\\n        } else if (_from >= bonusEndBlock) {\\n            return _to.sub(_from);\\n        } else {\\n            return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\\n                _to.sub(bonusEndBlock)\\n            );\\n        }\\n    }\\n    // reward prediction at specific block\\n    function getRewardPerBlock(uint blockNumber) public view returns (uint256) {\\n        if (blockNumber >= startBlock){\\n            return HePerBlock;\\n        } else {\\n            return 0;\\n        }\\n    }\\n    // View function to see pending Lucky on frontend.\\n    function pendingToken(uint256 _pid, address _user) public view returns (uint256) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accHePerShare = pool.accHePerShare;\\n        uint256 lpSupply = pool.balancePool;\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n            uint256 rewardThisBlock = getRewardPerBlock(block.number);\\n            uint256 heReward = multiplier.mul(rewardThisBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n            accHePerShare = accHePerShare.add(heReward.mul(1e18).div(lpSupply));\\n        }\\n        uint256 rewardHe = user.amount.mul(accHePerShare).div(1e18).sub(user.rewardDebt).add(user.pendingDebt);\\n        return rewardHe;\\n    }\\n    // Update reward vairables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return; \\n        }\\n        uint256 lpSupply = pool.balancePool;\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 rewardThisBlock = getRewardPerBlock(block.number);\\n        uint256 heReward = multiplier.mul(rewardThisBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n        pool.accHePerShare = pool.accHePerShare.add(heReward.mul(1e18).div(lpSupply));\\n        pool.lastRewardBlock = block.number;\\n    }\\n    // Deposit HE tokens to MasterChef for HE allocation.\\n    function deposit(uint256 _pid, uint256 _amount) external {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 pending = user.amount.mul(pool.accHePerShare).div(1e18).sub(user.rewardDebt);\\n            if(pending > 0){\\n                user.pendingDebt = user.pendingDebt.add(pending);\\n            }\\n        } \\n        if(_amount > 0){\\n            pool.heToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\n            pool.balancePool = pool.balancePool.add(_amount);\\n            user.amount = user.amount.add(_amount);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accHePerShare).div(1e18);\\n        emit Deposit(msg.sender, _pid, _amount, block.timestamp);\\n    }\\n\\n    // Withdraw HE tokens.\\n    function pendingWithdraw(uint256 _pid, uint256 _amount) external {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        updatePool(_pid);\\n        uint256 pending = user.amount.mul(pool.accHePerShare).div(1e18).sub(user.rewardDebt);\\n        user.amount = user.amount.sub(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accHePerShare).div(1e18);\\n        pool.balancePool = pool.balancePool.sub(_amount);\\n        withdrawInfo[_pid][msg.sender].push(WithdrawInfo(_amount, block.timestamp, block.timestamp, 0)); \\n        user.pendingDebt = user.pendingDebt.add(pending);\\n    }\\n\\n    function withdraw(uint256 _pid, uint256 _id) external {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        uint256 status = withdrawInfo[_pid][msg.sender][_id].status;\\n        uint256 amount = withdrawInfo[_pid][msg.sender][_id].amount;\\n        uint256 timeWithdraw = withdrawInfo[_pid][msg.sender][_id].blockTime;\\n        require(status == 0, 'You have withdrawn');\\n        require((block.timestamp - timeWithdraw) > timeLockWithdraw, 'you are still in lock');\\n        withdrawInfo[_pid][msg.sender][_id].status = 1;\\n        withdrawInfo[_pid][msg.sender][_id].withdrawTime = block.timestamp;\\n        pool.heToken.safeTransfer(address(msg.sender), amount);\\n        emit Withdraw(msg.sender, _pid, amount, block.timestamp);\\n    }\\n    function pendingClaim(uint256 _pid, uint256 _amount) external {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        updatePool(_pid);\\n        uint256 pending = user.amount.mul(pool.accHePerShare).div(1e18).sub(user.rewardDebt);\\n        user.rewardDebt = user.amount.mul(pool.accHePerShare).div(1e18);\\n        require(user.pendingDebt.add(pending) >= _amount, \\\"Claim: not good\\\");\\n        user.pendingDebt = user.pendingDebt.add(pending).sub(_amount);\\n        claimInfo[_pid][msg.sender].push(ClaimInfo(_amount, block.timestamp, block.timestamp, 0)); \\n    }\\n    function claim(uint256 _pid, uint256 _id) external {\\n        uint256 status = claimInfo[_pid][msg.sender][_id].status;\\n        uint256 amount = claimInfo[_pid][msg.sender][_id].amount;\\n        uint256 timeWithdraw = claimInfo[_pid][msg.sender][_id].blockTime;\\n        require(status == 0, 'You have withdrawn');\\n        require((block.timestamp - timeWithdraw) > timeLockClaim, 'you are still in lock');\\n        claimInfo[_pid][msg.sender][_id].status = 1;\\n        claimInfo[_pid][msg.sender][_id].claimTime = block.timestamp;\\n        RE.transferToken(HE,address(msg.sender), amount);\\n        emit Claim(msg.sender, _pid, amount, block.timestamp);\\n    }\\n    function reInvestment(uint256 _pid, uint256 _amount) external {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(pool.heToken == HE, \\\"Token does not support restake\\\");\\n        updatePool(_pid);\\n        uint256 pending = user.amount.mul(pool.accHePerShare).div(1e18).sub(user.rewardDebt);\\n        require(user.pendingDebt.add(pending) >= _amount, \\\"Claim: not good\\\");\\n        user.pendingDebt = user.pendingDebt.add(pending).sub(_amount);\\n        pool.balancePool = pool.balancePool.add(_amount);\\n        user.amount = user.amount.add(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accHePerShare).div(1e18);\\n        RE.transferToken(HE,address(this), _amount);\\n        emit ReInvestment(msg.sender, _pid, _amount, block.timestamp);\\n    }\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) external {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        withdrawInfo[_pid][msg.sender].push(WithdrawInfo(user.amount, block.timestamp, block.timestamp, 0));\\n        pool.balancePool = pool.balancePool.sub(user.amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount, block.timestamp);\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_HE\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_hePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_reward\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Walletreceive\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"AddWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"ReInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CREATOR_ADMIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HE\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RE\",\"outputs\":[{\"internalType\":\"contract Reward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBEP20\",\"name\":\"_heToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receive\",\"type\":\"address\"}],\"name\":\"addViewWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressStake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boolAddWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hePerBlock\",\"type\":\"uint256\"}],\"name\":\"changeHePerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeLock\",\"type\":\"uint256\"}],\"name\":\"changeTimeLockClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeLock\",\"type\":\"uint256\"}],\"name\":\"changeTimeLockWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getClaimByAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"internalType\":\"struct Stake.ClaimInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getRewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receive\",\"type\":\"address\"}],\"name\":\"getViewWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getWithdrawByAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"internalType\":\"struct Stake.WithdrawInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pendingClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pendingWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"heToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accHePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"reInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLockClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLockWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Stake", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d998ea274c1edcce9ee97182a112735441f21dbe00000000000000000000000020d39a5130f799b95b55a930e5b7ebc589ea9ed8000000000000000000000000000000000000000000000000100fefe83d7474000000000000000000000000000000000000000000000000000000000000e602d00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000775363d3352b057f1610601ea001b07affcff9f8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}