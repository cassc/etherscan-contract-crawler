{"SourceCode": "{\"Auth.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nabstract contract Auth {\\n    address internal owner;\\n    mapping (address =\\u003e bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be contract owner\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\"); _;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be authorized\\n     */\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\"); _;\\n    }\\n\\n    /**\\n     * Authorize address. Owner only\\n     */\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    /**\\n     * Remove address\\u0027 authorization. Owner only\\n     */\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    /**\\n     * Check if address is owner\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    /**\\n     * Return address\\u0027 authorization status\\n     */\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    /**\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\n     */\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\"},\"HibikiStaking.sol\":{\"content\":\"/**\\n * Hibiki staking\\n * Stake your $HIBIKI\\n *\\n * https://t.me/hibikifinance\\n * https://hibiki.finance\\n * \\n */\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./Auth.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\n\\ncontract HibikiStaking is Auth {\\n\\n    struct Stake {\\n        uint256 amount;\\n        uint256 totalExcluded;\\n        uint256 totalRealised;\\n    }\\n\\n    address public stakingToken;\\n    address public rewardToken;\\n\\n    uint256 public totalRealised;\\n    uint256 public totalStaked;\\n\\n    mapping (address =\\u003e Stake) public stakes;\\n\\n\\tevent Realised(address account, uint amount);\\n    event Staked(address account, uint amount);\\n    event Unstaked(address account, uint amount);\\n\\n    constructor (address _stakingToken, address _rewardToken) Auth(msg.sender) {\\n        stakingToken = _stakingToken;\\n        rewardToken = _rewardToken;\\n    }\\n\\n    uint256 _accuracyFactor = 10 ** 36;\\n    uint256 _rewardsPerLP;\\n    uint256 _lastContractBalance;\\n\\n    function getTotalRewards() external view  returns (uint256) {\\n        return totalRealised + IBEP20(rewardToken).balanceOf(address(this));\\n    }\\n\\n    function getCumulativeRewardsPerLP() external view returns (uint256) {\\n        return _rewardsPerLP;\\n    }\\n\\n    function getLastContractBalance() external view returns (uint256) {\\n        return _lastContractBalance;\\n    }\\n\\n    function getAccuracyFactor() external view returns (uint256) {\\n        return _accuracyFactor;\\n    }\\n\\n    function getStake(address account) public view returns (uint256) {\\n        return stakes[account].amount;\\n    }\\n\\n    function getRealisedEarnings(address staker) external view returns (uint256) {\\n        return stakes[staker].totalRealised; // realised gains plus outstanding earnings\\n    }\\n\\n    function getUnrealisedEarnings(address staker) external view returns (uint256) {\\n        if(stakes[staker].amount == 0){ return 0; }\\n\\n        uint256 stakerTotalRewards = stakes[staker].amount * getCurrentRewardsPerLP() / _accuracyFactor;\\n        uint256 stakerTotalExcluded = stakes[staker].totalExcluded;\\n\\n        if (stakerTotalRewards \\u003c= stakerTotalExcluded) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n        return stakerTotalRewards - stakerTotalExcluded;\\n    }\\n\\n    function getCumulativeRewards(uint256 amount) public view returns (uint256) {\\n        return amount * _rewardsPerLP / _accuracyFactor;\\n    }\\n\\n    function stake(uint amount) external {\\n        require(amount \\u003e 0);\\n\\n        IBEP20(stakingToken).transferFrom(msg.sender, address(this), amount);\\n\\n        _stake(msg.sender, amount);\\n    }\\n\\n    function stakeFor(address staker, uint256 amount) external {\\n        require(amount \\u003e 0);\\n\\n        IBEP20(stakingToken).transferFrom(msg.sender, address(this), amount);\\n\\n        _stake(staker, amount);\\n    }\\n\\n    function stakeAll() external {\\n        uint256 amount = IBEP20(stakingToken).balanceOf(msg.sender);\\n        require(amount \\u003e 0);\\n\\n        IBEP20(stakingToken).transferFrom(msg.sender, address(this), amount);\\n\\n        _stake(msg.sender, amount);\\n    }\\n\\n    function unstake(uint amount) external {\\n        require(amount \\u003e 0);\\n\\n        _unstake(msg.sender, amount);\\n    }\\n\\n    function unstakeAll() external {\\n        uint256 amount = getStake(msg.sender);\\n        require(amount \\u003e 0);\\n\\n        _unstake(msg.sender, amount);\\n    }\\n\\n    function realise() external {\\n        _realise(msg.sender);\\n    }\\n\\n    function _realise(address staker) internal {\\n        _updateRewards();\\n\\n        uint amount = earnt(staker);\\n\\n        if (getStake(staker) == 0 || amount == 0) {\\n            return;\\n        }\\n\\n        stakes[staker].totalRealised += amount;\\n        stakes[staker].totalExcluded += amount;\\n        totalRealised += amount;\\n\\n        IBEP20(rewardToken).transfer(staker, amount);\\n\\n        _updateRewards();\\n\\n        emit Realised(staker, amount);\\n    }\\n\\n    function earnt(address staker) internal view returns (uint256) {\\n        if(stakes[staker].amount == 0){ return 0; }\\n\\n        uint256 stakerTotalRewards = getCumulativeRewards(stakes[staker].amount);\\n        uint256 stakerTotalExcluded = stakes[staker].totalExcluded;\\n\\n        if(stakerTotalRewards \\u003c= stakerTotalExcluded){ return 0; }\\n\\n        return stakerTotalRewards - stakerTotalExcluded;\\n    }\\n\\n    function _stake(address staker, uint256 amount) internal {\\n        require(amount \\u003e 0);\\n\\n        _realise(staker);\\n\\n        // add to current address\\u0027 stake\\n        stakes[staker].amount += amount;\\n        stakes[staker].totalExcluded = getCumulativeRewards(stakes[staker].amount);\\n        totalStaked += amount;\\n\\n        emit Staked(staker, amount);\\n    }\\n\\n    function _unstake(address staker, uint256 amount) internal {\\n        require(stakes[staker].amount \\u003e= amount, \\\"Insufficient Stake\\\");\\n\\n        _realise(staker); // realise staking gains\\n\\n        // remove stake\\n        stakes[staker].amount -= amount;\\n        stakes[staker].totalExcluded = getCumulativeRewards(stakes[staker].amount);\\n        totalStaked -= amount;\\n\\n        IBEP20(stakingToken).transfer(staker, amount);\\n\\n        emit Unstaked(staker, amount);\\n    }\\n\\n    function _updateRewards() internal  {\\n        uint tokenBalance = IBEP20(rewardToken).balanceOf(address(this));\\n\\n        if (tokenBalance \\u003e _lastContractBalance \\u0026\\u0026 totalStaked != 0) {\\n            uint256 newRewards = tokenBalance - _lastContractBalance;\\n            uint256 additionalAmountPerLP = newRewards * _accuracyFactor / totalStaked;\\n            _rewardsPerLP += additionalAmountPerLP;\\n        }\\n\\n        if (totalStaked \\u003e 0) {\\n\\t\\t\\t_lastContractBalance = tokenBalance;\\n\\t\\t}\\n    }\\n\\n    function getCurrentRewardsPerLP() public view returns (uint256 currentRewardsPerLP) {\\n        uint tokenBalance = IBEP20(rewardToken).balanceOf(address(this));\\n        if(tokenBalance \\u003e _lastContractBalance \\u0026\\u0026 totalStaked != 0){\\n            uint256 newRewards = tokenBalance - _lastContractBalance;\\n            uint256 additionalAmountPerLP = newRewards* _accuracyFactor / totalStaked;\\n            currentRewardsPerLP = _rewardsPerLP + additionalAmountPerLP;\\n        }\\n    }\\n\\n    function setAccuracyFactor(uint256 newFactor) external authorized {\\n        _rewardsPerLP = _rewardsPerLP * newFactor / _accuracyFactor;\\n        _accuracyFactor = newFactor;\\n    }\\n\\n    function emergencyUnstakeAll() external {\\n        require(stakes[msg.sender].amount \\u003e 0, \\\"No Stake\\\");\\n\\n        IBEP20(stakingToken).transfer(msg.sender, stakes[msg.sender].amount);\\n        totalStaked -= stakes[msg.sender].amount;\\n        stakes[msg.sender].amount = 0;\\n    }\\n\\n    function migrateStakingToken(address newToken) external authorized {\\n        IBEP20(newToken).transferFrom(msg.sender, address(this), totalStaked);\\n        assert(IBEP20(newToken).balanceOf(address(this)) == totalStaked);\\n\\n        IBEP20(stakingToken).transfer(msg.sender, totalStaked);\\n\\n        stakingToken = newToken;\\n    }\\n}\\n\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IBEP20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n  * @dev Returns the token name.\\n  */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view returns (address);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Realised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccuracyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getCumulativeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCumulativeRewardsPerLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRewardsPerLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentRewardsPerLP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getRealisedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUnrealisedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"migrateStakingToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"realise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFactor\",\"type\":\"uint256\"}],\"name\":\"setAccuracyFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRealised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HibikiStaking", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000054ad5d602dbe5e89fd35b0d44314cc5ee10d77e6000000000000000000000000a532cfaa916c465a094daf29fea07a13e41e5b36", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a117b52774a7bf0c7c04169d105be3cf6c27aac4b0eee3bb6792a95e0bcbf3f2"}