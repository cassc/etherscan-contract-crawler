{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/SafeERC20.sol\\\";\\n\\nimport \\\"./interfaces/IOwnable.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IERC20Metadata.sol\\\";\\nimport \\\"./interfaces/IBOHM.sol\\\";\\nimport \\\"./interfaces/IsBOHM.sol\\\";\\nimport \\\"./interfaces/IBondingCalculator.sol\\\";\\nimport \\\"./interfaces/ITreasury.sol\\\";\\n\\nimport \\\"./types/OlympusAccessControlled.sol\\\";\\n\\ncontract OlympusTreasury is OlympusAccessControlled, ITreasury {\\n    /* ========== DEPENDENCIES ========== */\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Deposit(address indexed token, uint256 amount, uint256 value);\\n    event Withdrawal(address indexed token, uint256 amount, uint256 value);\\n    event CreateDebt(address indexed debtor, address indexed token, uint256 amount, uint256 value);\\n    event RepayDebt(address indexed debtor, address indexed token, uint256 amount, uint256 value);\\n    event Managed(address indexed token, uint256 amount);\\n    event ReservesAudited(uint256 indexed totalReserves);\\n    event Minted(address indexed caller, address indexed recipient, uint256 amount);\\n    event PermissionQueued(STATUS indexed status, address queued);\\n    event Permissioned(address addr, STATUS indexed status, bool result);\\n\\n    /* ========== DATA STRUCTURES ========== */\\n\\n    enum STATUS {\\n        RESERVEDEPOSITOR,\\n        RESERVESPENDER,\\n        RESERVETOKEN,\\n        RESERVEMANAGER,\\n        LIQUIDITYDEPOSITOR,\\n        LIQUIDITYTOKEN,\\n        LIQUIDITYMANAGER,\\n        RESERVEDEBTOR,\\n        REWARDMANAGER,\\n        SBOHM,\\n        BOHMDEBTOR\\n    }\\n\\n    struct Queue {\\n        STATUS managing;\\n        address toPermit;\\n        address calculator;\\n        uint256 timelockEnd;\\n        bool nullify;\\n        bool executed;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IBOHM public immutable BOHM;\\n    IsBOHM public sBOHM;\\n\\n    mapping(STATUS => address[]) public registry;\\n    mapping(STATUS => mapping(address => bool)) public permissions;\\n    mapping(address => address) public bondCalculator;\\n\\n    mapping(address => uint256) public debtLimit;\\n\\n    uint256 public totalReserves;\\n    uint256 public totalDebt;\\n    uint256 public bohmDebt;\\n\\n    Queue[] public permissionQueue;\\n    uint256 public immutable blocksNeededForQueue;\\n\\n    bool public timelockEnabled;\\n    bool public initialized;\\n\\n    uint256 public onChainGovernanceTimelock;\\n\\n    string internal notAccepted = \\\"Treasury: not accepted\\\";\\n    string internal notApproved = \\\"Treasury: not approved\\\";\\n    string internal invalidToken = \\\"Treasury: invalid token\\\";\\n    string internal insufficientReserves = \\\"Treasury: insufficient reserves\\\";\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address _bohm,\\n        uint256 _timelock,\\n        address _authority\\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\\n        require(_bohm != address(0), \\\"Zero address: BOHM\\\");\\n        BOHM = IBOHM(_bohm);\\n\\n        timelockEnabled = false;\\n        initialized = false;\\n        blocksNeededForQueue = _timelock;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice allow approved address to deposit an asset for BOHM\\n     * @param _amount uint256\\n     * @param _token address\\n     * @param _profit uint256\\n     * @return send_ uint256\\n     */\\n    function deposit(uint256 _amount, address _token, uint256 _profit) external override returns (uint256 send_) {\\n        if (permissions[STATUS.RESERVETOKEN][_token]) {\\n            require(permissions[STATUS.RESERVEDEPOSITOR][msg.sender], notApproved);\\n        } else if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\\n            require(permissions[STATUS.LIQUIDITYDEPOSITOR][msg.sender], notApproved);\\n        } else {\\n            revert(invalidToken);\\n        }\\n\\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        uint256 value = tokenValue(_token, _amount);\\n        // mint BOHM needed and store amount of rewards for distribution\\n        send_ = value.sub(_profit);\\n        BOHM.mint(msg.sender, send_);\\n\\n        totalReserves = totalReserves.add(value);\\n\\n        emit Deposit(_token, _amount, value);\\n    }\\n\\n    /**\\n     * @notice allow approved address to burn BOHM for reserves\\n     * @param _amount uint256\\n     * @param _token address\\n     */\\n    function withdraw(uint256 _amount, address _token) external override {\\n        require(permissions[STATUS.RESERVETOKEN][_token], notAccepted); // Only reserves can be used for redemptions\\n        require(permissions[STATUS.RESERVESPENDER][msg.sender], notApproved);\\n\\n        uint256 value = tokenValue(_token, _amount);\\n        BOHM.burnFrom(msg.sender, value);\\n\\n        totalReserves = totalReserves.sub(value);\\n\\n        IERC20(_token).safeTransfer(msg.sender, _amount);\\n\\n        emit Withdrawal(_token, _amount, value);\\n    }\\n\\n    /**\\n     * @notice allow approved address to withdraw assets\\n     * @param _token address\\n     * @param _amount uint256\\n     */\\n    function manage(address _token, uint256 _amount) external override {\\n        if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\\n            require(permissions[STATUS.LIQUIDITYMANAGER][msg.sender], notApproved);\\n        } else {\\n            require(permissions[STATUS.RESERVEMANAGER][msg.sender], notApproved);\\n        }\\n        if (permissions[STATUS.RESERVETOKEN][_token] || permissions[STATUS.LIQUIDITYTOKEN][_token]) {\\n            uint256 value = tokenValue(_token, _amount);\\n            require(value <= excessReserves(), insufficientReserves);\\n            totalReserves = totalReserves.sub(value);\\n        }\\n        IERC20(_token).safeTransfer(msg.sender, _amount);\\n        emit Managed(_token, _amount);\\n    }\\n\\n    /**\\n     * @notice mint new BOHM using excess reserves\\n     * @param _recipient address\\n     * @param _amount uint256\\n     */\\n    function mint(address _recipient, uint256 _amount) external override {\\n        require(permissions[STATUS.REWARDMANAGER][msg.sender], notApproved);\\n        require(_amount <= excessReserves(), insufficientReserves);\\n        BOHM.mint(_recipient, _amount);\\n        emit Minted(msg.sender, _recipient, _amount);\\n    }\\n\\n    /**\\n     * DEBT: The debt functions allow approved addresses to borrow treasury assets\\n     * or BOHM from the treasury, using sBOHM as collateral. This might allow an\\n     * sBOHM holder to provide BOHM liquidity without taking on the opportunity cost\\n     * of unstaking, or alter their backing without imposing risk onto the treasury.\\n     * Many of these use cases are yet to be defined, but they appear promising.\\n     * However, we urge the community to think critically and move slowly upon\\n     * proposals to acquire these permissions.\\n     */\\n\\n    /**\\n     * @notice allow approved address to borrow reserves\\n     * @param _amount uint256\\n     * @param _token address\\n     */\\n    function incurDebt(uint256 _amount, address _token) external override {\\n        uint256 value;\\n        if (_token == address(BOHM)) {\\n            require(permissions[STATUS.BOHMDEBTOR][msg.sender], notApproved);\\n            value = _amount;\\n        } else {\\n            require(permissions[STATUS.RESERVEDEBTOR][msg.sender], notApproved);\\n            require(permissions[STATUS.RESERVETOKEN][_token], notAccepted);\\n            value = tokenValue(_token, _amount);\\n        }\\n        require(value != 0, invalidToken);\\n\\n        sBOHM.changeDebt(value, msg.sender, true);\\n        require(sBOHM.debtBalances(msg.sender) <= debtLimit[msg.sender], \\\"Treasury: exceeds limit\\\");\\n        totalDebt = totalDebt.add(value);\\n\\n        if (_token == address(BOHM)) {\\n            BOHM.mint(msg.sender, value);\\n            bohmDebt = bohmDebt.add(value);\\n        } else {\\n            totalReserves = totalReserves.sub(value);\\n            IERC20(_token).safeTransfer(msg.sender, _amount);\\n        }\\n        emit CreateDebt(msg.sender, _token, _amount, value);\\n    }\\n\\n    /**\\n     * @notice allow approved address to repay borrowed reserves with reserves\\n     * @param _amount uint256\\n     * @param _token address\\n     */\\n    function repayDebtWithReserve(uint256 _amount, address _token) external override {\\n        require(permissions[STATUS.RESERVEDEBTOR][msg.sender], notApproved);\\n        require(permissions[STATUS.RESERVETOKEN][_token], notAccepted);\\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\\n        uint256 value = tokenValue(_token, _amount);\\n        sBOHM.changeDebt(value, msg.sender, false);\\n        totalDebt = totalDebt.sub(value);\\n        totalReserves = totalReserves.add(value);\\n        emit RepayDebt(msg.sender, _token, _amount, value);\\n    }\\n\\n    /**\\n     * @notice allow approved address to repay borrowed reserves with BOHM\\n     * @param _amount uint256\\n     */\\n    function repayDebtWithBOHM(uint256 _amount) external {\\n        require(\\n            permissions[STATUS.RESERVEDEBTOR][msg.sender] || permissions[STATUS.BOHMDEBTOR][msg.sender],\\n            notApproved\\n        );\\n        BOHM.burnFrom(msg.sender, _amount);\\n        sBOHM.changeDebt(_amount, msg.sender, false);\\n        totalDebt = totalDebt.sub(_amount);\\n        bohmDebt = bohmDebt.sub(_amount);\\n        emit RepayDebt(msg.sender, address(BOHM), _amount, _amount);\\n    }\\n\\n    /* ========== MANAGERIAL FUNCTIONS ========== */\\n\\n    /**\\n     * @notice takes inventory of all tracked assets\\n     * @notice always consolidate to recognized reserves before audit\\n     */\\n    function auditReserves() external onlyGovernor {\\n        uint256 reserves;\\n        address[] memory reserveToken = registry[STATUS.RESERVETOKEN];\\n        for (uint256 i = 0; i < reserveToken.length; i++) {\\n            if (permissions[STATUS.RESERVETOKEN][reserveToken[i]]) {\\n                reserves = reserves.add(tokenValue(reserveToken[i], IERC20(reserveToken[i]).balanceOf(address(this))));\\n            }\\n        }\\n        address[] memory liquidityToken = registry[STATUS.LIQUIDITYTOKEN];\\n        for (uint256 i = 0; i < liquidityToken.length; i++) {\\n            if (permissions[STATUS.LIQUIDITYTOKEN][liquidityToken[i]]) {\\n                reserves = reserves.add(\\n                    tokenValue(liquidityToken[i], IERC20(liquidityToken[i]).balanceOf(address(this)))\\n                );\\n            }\\n        }\\n        totalReserves = reserves;\\n        emit ReservesAudited(reserves);\\n    }\\n\\n    /**\\n     * @notice set max debt for address\\n     * @param _address address\\n     * @param _limit uint256\\n     */\\n    function setDebtLimit(address _address, uint256 _limit) external onlyGovernor {\\n        debtLimit[_address] = _limit;\\n    }\\n\\n    /**\\n     * @notice enable permission from queue\\n     * @param _status STATUS\\n     * @param _address address\\n     * @param _calculator address\\n     */\\n    function enable(STATUS _status, address _address, address _calculator) external onlyGovernor {\\n        require(timelockEnabled == false, \\\"Use queueTimelock\\\");\\n        if (_status == STATUS.SBOHM) {\\n            sBOHM = IsBOHM(_address);\\n        } else {\\n            permissions[_status][_address] = true;\\n\\n            if (_status == STATUS.LIQUIDITYTOKEN) {\\n                bondCalculator[_address] = _calculator;\\n            }\\n\\n            (bool registered, ) = indexInRegistry(_address, _status);\\n            if (!registered) {\\n                registry[_status].push(_address);\\n\\n                if (_status == STATUS.LIQUIDITYTOKEN || _status == STATUS.RESERVETOKEN) {\\n                    (bool reg, uint256 index) = indexInRegistry(_address, _status);\\n                    if (reg) {\\n                        delete registry[_status][index];\\n                    }\\n                }\\n            }\\n        }\\n        emit Permissioned(_address, _status, true);\\n    }\\n\\n    /**\\n     *  @notice disable permission from address\\n     *  @param _status STATUS\\n     *  @param _toDisable address\\n     */\\n    function disable(STATUS _status, address _toDisable) external {\\n        require(msg.sender == authority.governor() || msg.sender == authority.guardian(), \\\"Only governor or guardian\\\");\\n        permissions[_status][_toDisable] = false;\\n        emit Permissioned(_toDisable, _status, false);\\n    }\\n\\n    /**\\n     * @notice check if registry contains address\\n     * @return (bool, uint256)\\n     */\\n    function indexInRegistry(address _address, STATUS _status) public view returns (bool, uint256) {\\n        address[] memory entries = registry[_status];\\n        for (uint256 i = 0; i < entries.length; i++) {\\n            if (_address == entries[i]) {\\n                return (true, i);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /* ========== TIMELOCKED FUNCTIONS ========== */\\n\\n    // functions are used prior to enabling on-chain governance\\n\\n    /**\\n     * @notice queue address to receive permission\\n     * @param _status STATUS\\n     * @param _address address\\n     * @param _calculator address\\n     */\\n    function queueTimelock(STATUS _status, address _address, address _calculator) external onlyGovernor {\\n        require(_address != address(0));\\n        require(timelockEnabled == true, \\\"Timelock is disabled, use enable\\\");\\n\\n        uint256 timelock = block.number.add(blocksNeededForQueue);\\n        if (_status == STATUS.RESERVEMANAGER || _status == STATUS.LIQUIDITYMANAGER) {\\n            timelock = block.number.add(blocksNeededForQueue.mul(2));\\n        }\\n        permissionQueue.push(\\n            Queue({\\n                managing: _status,\\n                toPermit: _address,\\n                calculator: _calculator,\\n                timelockEnd: timelock,\\n                nullify: false,\\n                executed: false\\n            })\\n        );\\n        emit PermissionQueued(_status, _address);\\n    }\\n\\n    /**\\n     *  @notice enable queued permission\\n     *  @param _index uint256\\n     */\\n    function execute(uint256 _index) external {\\n        require(timelockEnabled == true, \\\"Timelock is disabled, use enable\\\");\\n\\n        Queue memory info = permissionQueue[_index];\\n\\n        require(!info.nullify, \\\"Action has been nullified\\\");\\n        require(!info.executed, \\\"Action has already been executed\\\");\\n        require(block.number >= info.timelockEnd, \\\"Timelock not complete\\\");\\n\\n        if (info.managing == STATUS.SBOHM) {\\n            // 9\\n            sBOHM = IsBOHM(info.toPermit);\\n        } else {\\n            permissions[info.managing][info.toPermit] = true;\\n\\n            if (info.managing == STATUS.LIQUIDITYTOKEN) {\\n                bondCalculator[info.toPermit] = info.calculator;\\n            }\\n            (bool registered, ) = indexInRegistry(info.toPermit, info.managing);\\n            if (!registered) {\\n                registry[info.managing].push(info.toPermit);\\n\\n                if (info.managing == STATUS.LIQUIDITYTOKEN) {\\n                    (bool reg, uint256 index) = indexInRegistry(info.toPermit, STATUS.RESERVETOKEN);\\n                    if (reg) {\\n                        delete registry[STATUS.RESERVETOKEN][index];\\n                    }\\n                } else if (info.managing == STATUS.RESERVETOKEN) {\\n                    (bool reg, uint256 index) = indexInRegistry(info.toPermit, STATUS.LIQUIDITYTOKEN);\\n                    if (reg) {\\n                        delete registry[STATUS.LIQUIDITYTOKEN][index];\\n                    }\\n                }\\n            }\\n        }\\n        permissionQueue[_index].executed = true;\\n        emit Permissioned(info.toPermit, info.managing, true);\\n    }\\n\\n    /**\\n     * @notice cancel timelocked action\\n     * @param _index uint256\\n     */\\n    function nullify(uint256 _index) external onlyGovernor {\\n        permissionQueue[_index].nullify = true;\\n    }\\n\\n    /**\\n     * @notice disables timelocked functions\\n     */\\n    function disableTimelock() external onlyGovernor {\\n        require(timelockEnabled == true, \\\"timelock already disabled\\\");\\n        if (onChainGovernanceTimelock != 0 && onChainGovernanceTimelock <= block.number) {\\n            timelockEnabled = false;\\n        } else {\\n            onChainGovernanceTimelock = block.number.add(blocksNeededForQueue.mul(7)); // 7-day timelock\\n        }\\n    }\\n\\n    /**\\n     * @notice enables timelocks after initilization\\n     */\\n    function initialize() external onlyGovernor {\\n        require(initialized == false, \\\"Already initialized\\\");\\n        timelockEnabled = true;\\n        initialized = true;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice returns excess reserves not backing tokens\\n     * @return uint\\n     */\\n    function excessReserves() public view override returns (uint256) {\\n        return totalReserves.sub(BOHM.totalSupply().sub(totalDebt));\\n    }\\n\\n    /**\\n     * @notice returns BOHM valuation of asset\\n     * @param _token address\\n     * @param _amount uint256\\n     * @return value_ uint256\\n     */\\n    function tokenValue(address _token, uint256 _amount) public view override returns (uint256 value_) {\\n        value_ = _amount.mul(10 ** IERC20Metadata(address(BOHM)).decimals()).div(\\n            10 ** IERC20Metadata(_token).decimals()\\n        );\\n\\n        if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\\n            value_ = IBondingCalculator(bondCalculator[_token]).valuation(_token, _amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice returns supply metric that cannot be manipulated by debt\\n     * @dev use this any time you need to query supply\\n     * @return uint256\\n     */\\n    function baseSupply() external view override returns (uint256) {\\n        return BOHM.totalSupply() - bohmDebt;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBOHM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IBOHM is IERC20 {\\n    function mint(address account_, uint256 amount_) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account_, uint256 amount_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondingCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IBondingCalculator {\\n    function markdown(address _LP) external view returns (uint256);\\n\\n    function valuation(address pair_, uint256 amount_) external view returns (uint256 _value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n\\n    function renounceManagement() external;\\n\\n    function pushManagement(address newOwner_) external;\\n\\n    function pullManagement() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IsBOHM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IsBOHM is IERC20 {\\n    function rebase(uint256 bohmProfit_, uint256 epoch_) external returns (uint256);\\n\\n    function circulatingSupply() external view returns (uint256);\\n\\n    function gonsForBalance(uint256 amount) external view returns (uint256);\\n\\n    function balanceForGons(uint256 gons) external view returns (uint256);\\n\\n    function index() external view returns (uint256);\\n\\n    function toG(uint256 amount) external view returns (uint256);\\n\\n    function fromG(uint256 amount) external view returns (uint256);\\n\\n    function changeDebt(uint256 amount, address debtor, bool add) external;\\n\\n    function debtBalances(address _address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        assert(a == b * c + (a % b)); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    // Only used in the  BondingCalculator.sol\\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\\n        if (a > 3) {\\n            c = a;\\n            uint256 b = add(div(a, 2), 1);\\n            while (b < c) {\\n                c = b;\\n                b = div(add(div(a, b), b), 2);\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nabstract contract OlympusAccessControlled {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\\n\\n    string UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyGovernor() {\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyGuardian() {\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyPolicy() {\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bohm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CreateDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Managed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"queued\",\"type\":\"address\"}],\"name\":\"PermissionQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"Permissioned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RepayDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesAudited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOHM\",\"outputs\":[{\"internalType\":\"contract IBOHM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auditReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksNeededForQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bohmDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bondCalculator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_profit\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"send_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"_status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_toDisable\",\"type\":\"address\"}],\"name\":\"disable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"_status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_calculator\",\"type\":\"address\"}],\"name\":\"enable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excessReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"incurDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"indexInRegistry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"manage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"nullify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onChainGovernanceTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"permissionQueue\",\"outputs\":[{\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"managing\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"toPermit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"calculator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelockEnd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"nullify\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permissions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"_status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_calculator\",\"type\":\"address\"}],\"name\":\"queueTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum OlympusTreasury.STATUS\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repayDebtWithBOHM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"repayDebtWithReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sBOHM\",\"outputs\":[{\"internalType\":\"contract IsBOHM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setDebtLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokenValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OlympusTreasury", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000ae6edd5151cfd8fb1a2bf8de29cc4b2d7f5b4a4f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000026f0d4bf62306d36d67647d85dad4967f4bd7257", "EVMVersion": "istanbul", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}