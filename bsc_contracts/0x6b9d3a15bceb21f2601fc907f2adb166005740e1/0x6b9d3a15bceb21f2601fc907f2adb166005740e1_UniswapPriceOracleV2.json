{"SourceCode": "pragma solidity 0.6.10;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface CErc20 {\r\n    function underlying() external view returns (address);\r\n}\r\n\r\ncontract UniswapConfig {\r\n    enum PriceSource {\r\n        FIXED_ETH,     // 0: implies the fixedPrice is a constant multiple of the ETH price (which varies), not support now\r\n        FIXED_USD,     // 1: implies the fixedPrice is a constant multiple of the USD price (which is 1)\r\n        REPORTER_BNB,  // 2: get price by dex swap  TOKEN/BNB\r\n        REPORTER_USD   // 3: get price by dex swap  TOKEN/BUSD\r\n    }\r\n\r\n    /// @dev Describe how the USD price should be determined for an asset.\r\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\r\n    struct TokenConfig {\r\n        address gToken;\r\n        address underlying;\r\n        bytes32 symbolHash;\r\n        uint256 baseUnit;\r\n        PriceSource priceSource;\r\n        uint256 fixedPrice;\r\n        address uniswapMarket;\r\n        bool isPrice1FromUniswap; // if (isPrice1FromUniswap) {return cumulativePrice1;} else {return cumulativePrice0;}\r\n    }\r\n\r\n    /// internal version\r\n    uint public constant version = 202104052326;\r\n\r\n    /// @notice The max number of tokens this contract is hardcoded to support\r\n    /// @dev Do not change this variable without updating all the fields throughout the contract.\r\n    uint public constant maxTokens = 20;\r\n\r\n    /// @notice The number of tokens this contract actually supports\r\n    uint public immutable numTokens;\r\n\r\n    address internal immutable gToken00;\r\n    address internal immutable gToken01;\r\n    address internal immutable gToken02;\r\n    address internal immutable gToken03;\r\n    address internal immutable gToken04;\r\n    address internal immutable gToken05;\r\n    address internal immutable gToken06;\r\n    address internal immutable gToken07;\r\n    address internal immutable gToken08;\r\n    address internal immutable gToken09;\r\n    address internal immutable gToken10;\r\n    address internal immutable gToken11;\r\n    address internal immutable gToken12;\r\n    address internal immutable gToken13;\r\n    address internal immutable gToken14;\r\n    address internal immutable gToken15;\r\n    address internal immutable gToken16;\r\n    address internal immutable gToken17;\r\n    address internal immutable gToken18;\r\n    address internal immutable gToken19;\r\n\r\n\r\n    address internal immutable underlying00;\r\n    address internal immutable underlying01;\r\n    address internal immutable underlying02;\r\n    address internal immutable underlying03;\r\n    address internal immutable underlying04;\r\n    address internal immutable underlying05;\r\n    address internal immutable underlying06;\r\n    address internal immutable underlying07;\r\n    address internal immutable underlying08;\r\n    address internal immutable underlying09;\r\n    address internal immutable underlying10;\r\n    address internal immutable underlying11;\r\n    address internal immutable underlying12;\r\n    address internal immutable underlying13;\r\n    address internal immutable underlying14;\r\n    address internal immutable underlying15;\r\n    address internal immutable underlying16;\r\n    address internal immutable underlying17;\r\n    address internal immutable underlying18;\r\n    address internal immutable underlying19;\r\n\r\n\r\n    bytes32 internal immutable symbolHash00;\r\n    bytes32 internal immutable symbolHash01;\r\n    bytes32 internal immutable symbolHash02;\r\n    bytes32 internal immutable symbolHash03;\r\n    bytes32 internal immutable symbolHash04;\r\n    bytes32 internal immutable symbolHash05;\r\n    bytes32 internal immutable symbolHash06;\r\n    bytes32 internal immutable symbolHash07;\r\n    bytes32 internal immutable symbolHash08;\r\n    bytes32 internal immutable symbolHash09;\r\n    bytes32 internal immutable symbolHash10;\r\n    bytes32 internal immutable symbolHash11;\r\n    bytes32 internal immutable symbolHash12;\r\n    bytes32 internal immutable symbolHash13;\r\n    bytes32 internal immutable symbolHash14;\r\n    bytes32 internal immutable symbolHash15;\r\n    bytes32 internal immutable symbolHash16;\r\n    bytes32 internal immutable symbolHash17;\r\n    bytes32 internal immutable symbolHash18;\r\n    bytes32 internal immutable symbolHash19;\r\n\r\n    uint256 internal immutable baseUnit00;\r\n    uint256 internal immutable baseUnit01;\r\n    uint256 internal immutable baseUnit02;\r\n    uint256 internal immutable baseUnit03;\r\n    uint256 internal immutable baseUnit04;\r\n    uint256 internal immutable baseUnit05;\r\n    uint256 internal immutable baseUnit06;\r\n    uint256 internal immutable baseUnit07;\r\n    uint256 internal immutable baseUnit08;\r\n    uint256 internal immutable baseUnit09;\r\n    uint256 internal immutable baseUnit10;\r\n    uint256 internal immutable baseUnit11;\r\n    uint256 internal immutable baseUnit12;\r\n    uint256 internal immutable baseUnit13;\r\n    uint256 internal immutable baseUnit14;\r\n    uint256 internal immutable baseUnit15;\r\n    uint256 internal immutable baseUnit16;\r\n    uint256 internal immutable baseUnit17;\r\n    uint256 internal immutable baseUnit18;\r\n    uint256 internal immutable baseUnit19;\r\n\r\n    PriceSource internal immutable priceSource00;\r\n    PriceSource internal immutable priceSource01;\r\n    PriceSource internal immutable priceSource02;\r\n    PriceSource internal immutable priceSource03;\r\n    PriceSource internal immutable priceSource04;\r\n    PriceSource internal immutable priceSource05;\r\n    PriceSource internal immutable priceSource06;\r\n    PriceSource internal immutable priceSource07;\r\n    PriceSource internal immutable priceSource08;\r\n    PriceSource internal immutable priceSource09;\r\n    PriceSource internal immutable priceSource10;\r\n    PriceSource internal immutable priceSource11;\r\n    PriceSource internal immutable priceSource12;\r\n    PriceSource internal immutable priceSource13;\r\n    PriceSource internal immutable priceSource14;\r\n    PriceSource internal immutable priceSource15;\r\n    PriceSource internal immutable priceSource16;\r\n    PriceSource internal immutable priceSource17;\r\n    PriceSource internal immutable priceSource18;\r\n    PriceSource internal immutable priceSource19;\r\n\r\n    uint256 internal immutable fixedPrice00;\r\n    uint256 internal immutable fixedPrice01;\r\n    uint256 internal immutable fixedPrice02;\r\n    uint256 internal immutable fixedPrice03;\r\n    uint256 internal immutable fixedPrice04;\r\n    uint256 internal immutable fixedPrice05;\r\n    uint256 internal immutable fixedPrice06;\r\n    uint256 internal immutable fixedPrice07;\r\n    uint256 internal immutable fixedPrice08;\r\n    uint256 internal immutable fixedPrice09;\r\n    uint256 internal immutable fixedPrice10;\r\n    uint256 internal immutable fixedPrice11;\r\n    uint256 internal immutable fixedPrice12;\r\n    uint256 internal immutable fixedPrice13;\r\n    uint256 internal immutable fixedPrice14;\r\n    uint256 internal immutable fixedPrice15;\r\n    uint256 internal immutable fixedPrice16;\r\n    uint256 internal immutable fixedPrice17;\r\n    uint256 internal immutable fixedPrice18;\r\n    uint256 internal immutable fixedPrice19;\r\n\r\n    address internal immutable uniswapMarket00;\r\n    address internal immutable uniswapMarket01;\r\n    address internal immutable uniswapMarket02;\r\n    address internal immutable uniswapMarket03;\r\n    address internal immutable uniswapMarket04;\r\n    address internal immutable uniswapMarket05;\r\n    address internal immutable uniswapMarket06;\r\n    address internal immutable uniswapMarket07;\r\n    address internal immutable uniswapMarket08;\r\n    address internal immutable uniswapMarket09;\r\n    address internal immutable uniswapMarket10;\r\n    address internal immutable uniswapMarket11;\r\n    address internal immutable uniswapMarket12;\r\n    address internal immutable uniswapMarket13;\r\n    address internal immutable uniswapMarket14;\r\n    address internal immutable uniswapMarket15;\r\n    address internal immutable uniswapMarket16;\r\n    address internal immutable uniswapMarket17;\r\n    address internal immutable uniswapMarket18;\r\n    address internal immutable uniswapMarket19;\r\n\r\n    bool internal immutable isPrice1FromUniswap00;\r\n    bool internal immutable isPrice1FromUniswap01;\r\n    bool internal immutable isPrice1FromUniswap02;\r\n    bool internal immutable isPrice1FromUniswap03;\r\n    bool internal immutable isPrice1FromUniswap04;\r\n    bool internal immutable isPrice1FromUniswap05;\r\n    bool internal immutable isPrice1FromUniswap06;\r\n    bool internal immutable isPrice1FromUniswap07;\r\n    bool internal immutable isPrice1FromUniswap08;\r\n    bool internal immutable isPrice1FromUniswap09;\r\n    bool internal immutable isPrice1FromUniswap10;\r\n    bool internal immutable isPrice1FromUniswap11;\r\n    bool internal immutable isPrice1FromUniswap12;\r\n    bool internal immutable isPrice1FromUniswap13;\r\n    bool internal immutable isPrice1FromUniswap14;\r\n    bool internal immutable isPrice1FromUniswap15;\r\n    bool internal immutable isPrice1FromUniswap16;\r\n    bool internal immutable isPrice1FromUniswap17;\r\n    bool internal immutable isPrice1FromUniswap18;\r\n    bool internal immutable isPrice1FromUniswap19;\r\n\r\n    constructor(address[] memory gTokens_, address[] memory underlyings_,\r\n        bytes32[] memory symbolHashs_, uint256[] memory baseUints_,\r\n        PriceSource[] memory priceSources_, uint256[] memory fixedPrices_, address[] memory uniswapMarkets_, bool[] memory isPrice1FromUniswapArray_) public {\r\n\r\n        require(gTokens_.length <= maxTokens, \"too many gToken\");\r\n        TokenConfig[] memory configs = new TokenConfig[](maxTokens);\r\n        for (uint i = 0; i < gTokens_.length; i++) {\r\n            TokenConfig memory config = TokenConfig({\r\n            gToken : gTokens_[i],\r\n            underlying : underlyings_[i],\r\n            symbolHash : symbolHashs_[i],\r\n            baseUnit : baseUints_[i],\r\n            priceSource: priceSources_[i],\r\n            fixedPrice: fixedPrices_[i],\r\n            uniswapMarket : uniswapMarkets_[i],\r\n            isPrice1FromUniswap : isPrice1FromUniswapArray_[i]\r\n            });\r\n            configs[i] = config;\r\n        }\r\n\r\n        require(configs.length <= maxTokens, \"too many configs\");\r\n        numTokens = configs.length;\r\n\r\n        gToken00 = get(configs, 0).gToken;\r\n        gToken01 = get(configs, 1).gToken;\r\n        gToken02 = get(configs, 2).gToken;\r\n        gToken03 = get(configs, 3).gToken;\r\n        gToken04 = get(configs, 4).gToken;\r\n        gToken05 = get(configs, 5).gToken;\r\n        gToken06 = get(configs, 6).gToken;\r\n        gToken07 = get(configs, 7).gToken;\r\n        gToken08 = get(configs, 8).gToken;\r\n        gToken09 = get(configs, 9).gToken;\r\n        gToken10 = get(configs, 10).gToken;\r\n        gToken11 = get(configs, 11).gToken;\r\n        gToken12 = get(configs, 12).gToken;\r\n        gToken13 = get(configs, 13).gToken;\r\n        gToken14 = get(configs, 14).gToken;\r\n        gToken15 = get(configs, 15).gToken;\r\n        gToken16 = get(configs, 16).gToken;\r\n        gToken17 = get(configs, 17).gToken;\r\n        gToken18 = get(configs, 18).gToken;\r\n        gToken19 = get(configs, 19).gToken;\r\n\r\n        underlying00 = get(configs, 0).underlying;\r\n        underlying01 = get(configs, 1).underlying;\r\n        underlying02 = get(configs, 2).underlying;\r\n        underlying03 = get(configs, 3).underlying;\r\n        underlying04 = get(configs, 4).underlying;\r\n        underlying05 = get(configs, 5).underlying;\r\n        underlying06 = get(configs, 6).underlying;\r\n        underlying07 = get(configs, 7).underlying;\r\n        underlying08 = get(configs, 8).underlying;\r\n        underlying09 = get(configs, 9).underlying;\r\n        underlying10 = get(configs, 10).underlying;\r\n        underlying11 = get(configs, 11).underlying;\r\n        underlying12 = get(configs, 12).underlying;\r\n        underlying13 = get(configs, 13).underlying;\r\n        underlying14 = get(configs, 14).underlying;\r\n        underlying15 = get(configs, 15).underlying;\r\n        underlying16 = get(configs, 16).underlying;\r\n        underlying17 = get(configs, 17).underlying;\r\n        underlying18 = get(configs, 18).underlying;\r\n        underlying19 = get(configs, 19).underlying;\r\n\r\n        symbolHash00 = get(configs, 0).symbolHash;\r\n        symbolHash01 = get(configs, 1).symbolHash;\r\n        symbolHash02 = get(configs, 2).symbolHash;\r\n        symbolHash03 = get(configs, 3).symbolHash;\r\n        symbolHash04 = get(configs, 4).symbolHash;\r\n        symbolHash05 = get(configs, 5).symbolHash;\r\n        symbolHash06 = get(configs, 6).symbolHash;\r\n        symbolHash07 = get(configs, 7).symbolHash;\r\n        symbolHash08 = get(configs, 8).symbolHash;\r\n        symbolHash09 = get(configs, 9).symbolHash;\r\n        symbolHash10 = get(configs, 10).symbolHash;\r\n        symbolHash11 = get(configs, 11).symbolHash;\r\n        symbolHash12 = get(configs, 12).symbolHash;\r\n        symbolHash13 = get(configs, 13).symbolHash;\r\n        symbolHash14 = get(configs, 14).symbolHash;\r\n        symbolHash15 = get(configs, 15).symbolHash;\r\n        symbolHash16 = get(configs, 16).symbolHash;\r\n        symbolHash17 = get(configs, 17).symbolHash;\r\n        symbolHash18 = get(configs, 18).symbolHash;\r\n        symbolHash19 = get(configs, 19).symbolHash;\r\n\r\n        baseUnit00 = get(configs, 0).baseUnit;\r\n        baseUnit01 = get(configs, 1).baseUnit;\r\n        baseUnit02 = get(configs, 2).baseUnit;\r\n        baseUnit03 = get(configs, 3).baseUnit;\r\n        baseUnit04 = get(configs, 4).baseUnit;\r\n        baseUnit05 = get(configs, 5).baseUnit;\r\n        baseUnit06 = get(configs, 6).baseUnit;\r\n        baseUnit07 = get(configs, 7).baseUnit;\r\n        baseUnit08 = get(configs, 8).baseUnit;\r\n        baseUnit09 = get(configs, 9).baseUnit;\r\n        baseUnit10 = get(configs, 10).baseUnit;\r\n        baseUnit11 = get(configs, 11).baseUnit;\r\n        baseUnit12 = get(configs, 12).baseUnit;\r\n        baseUnit13 = get(configs, 13).baseUnit;\r\n        baseUnit14 = get(configs, 14).baseUnit;\r\n        baseUnit15 = get(configs, 15).baseUnit;\r\n        baseUnit16 = get(configs, 16).baseUnit;\r\n        baseUnit17 = get(configs, 17).baseUnit;\r\n        baseUnit18 = get(configs, 18).baseUnit;\r\n        baseUnit19 = get(configs, 19).baseUnit;\r\n\r\n        priceSource00 = get(configs, 0).priceSource;\r\n        priceSource01 = get(configs, 1).priceSource;\r\n        priceSource02 = get(configs, 2).priceSource;\r\n        priceSource03 = get(configs, 3).priceSource;\r\n        priceSource04 = get(configs, 4).priceSource;\r\n        priceSource05 = get(configs, 5).priceSource;\r\n        priceSource06 = get(configs, 6).priceSource;\r\n        priceSource07 = get(configs, 7).priceSource;\r\n        priceSource08 = get(configs, 8).priceSource;\r\n        priceSource09 = get(configs, 9).priceSource;\r\n        priceSource10 = get(configs, 10).priceSource;\r\n        priceSource11 = get(configs, 11).priceSource;\r\n        priceSource12 = get(configs, 12).priceSource;\r\n        priceSource13 = get(configs, 13).priceSource;\r\n        priceSource14 = get(configs, 14).priceSource;\r\n        priceSource15 = get(configs, 15).priceSource;\r\n        priceSource16 = get(configs, 16).priceSource;\r\n        priceSource17 = get(configs, 17).priceSource;\r\n        priceSource18 = get(configs, 18).priceSource;\r\n        priceSource19 = get(configs, 19).priceSource;\r\n\r\n        fixedPrice00 = get(configs, 0).fixedPrice;\r\n        fixedPrice01 = get(configs, 1).fixedPrice;\r\n        fixedPrice02 = get(configs, 2).fixedPrice;\r\n        fixedPrice03 = get(configs, 3).fixedPrice;\r\n        fixedPrice04 = get(configs, 4).fixedPrice;\r\n        fixedPrice05 = get(configs, 5).fixedPrice;\r\n        fixedPrice06 = get(configs, 6).fixedPrice;\r\n        fixedPrice07 = get(configs, 7).fixedPrice;\r\n        fixedPrice08 = get(configs, 8).fixedPrice;\r\n        fixedPrice09 = get(configs, 9).fixedPrice;\r\n        fixedPrice10 = get(configs, 10).fixedPrice;\r\n        fixedPrice11 = get(configs, 11).fixedPrice;\r\n        fixedPrice12 = get(configs, 12).fixedPrice;\r\n        fixedPrice13 = get(configs, 13).fixedPrice;\r\n        fixedPrice14 = get(configs, 14).fixedPrice;\r\n        fixedPrice15 = get(configs, 15).fixedPrice;\r\n        fixedPrice16 = get(configs, 16).fixedPrice;\r\n        fixedPrice17 = get(configs, 17).fixedPrice;\r\n        fixedPrice18 = get(configs, 18).fixedPrice;\r\n        fixedPrice19 = get(configs, 19).fixedPrice;\r\n\r\n        uniswapMarket00 = get(configs, 0).uniswapMarket;\r\n        uniswapMarket01 = get(configs, 1).uniswapMarket;\r\n        uniswapMarket02 = get(configs, 2).uniswapMarket;\r\n        uniswapMarket03 = get(configs, 3).uniswapMarket;\r\n        uniswapMarket04 = get(configs, 4).uniswapMarket;\r\n        uniswapMarket05 = get(configs, 5).uniswapMarket;\r\n        uniswapMarket06 = get(configs, 6).uniswapMarket;\r\n        uniswapMarket07 = get(configs, 7).uniswapMarket;\r\n        uniswapMarket08 = get(configs, 8).uniswapMarket;\r\n        uniswapMarket09 = get(configs, 9).uniswapMarket;\r\n        uniswapMarket10 = get(configs, 10).uniswapMarket;\r\n        uniswapMarket11 = get(configs, 11).uniswapMarket;\r\n        uniswapMarket12 = get(configs, 12).uniswapMarket;\r\n        uniswapMarket13 = get(configs, 13).uniswapMarket;\r\n        uniswapMarket14 = get(configs, 14).uniswapMarket;\r\n        uniswapMarket15 = get(configs, 15).uniswapMarket;\r\n        uniswapMarket16 = get(configs, 16).uniswapMarket;\r\n        uniswapMarket17 = get(configs, 17).uniswapMarket;\r\n        uniswapMarket18 = get(configs, 18).uniswapMarket;\r\n        uniswapMarket19 = get(configs, 19).uniswapMarket;\r\n\r\n        isPrice1FromUniswap00 = get(configs, 0).isPrice1FromUniswap;\r\n        isPrice1FromUniswap01 = get(configs, 1).isPrice1FromUniswap;\r\n        isPrice1FromUniswap02 = get(configs, 2).isPrice1FromUniswap;\r\n        isPrice1FromUniswap03 = get(configs, 3).isPrice1FromUniswap;\r\n        isPrice1FromUniswap04 = get(configs, 4).isPrice1FromUniswap;\r\n        isPrice1FromUniswap05 = get(configs, 5).isPrice1FromUniswap;\r\n        isPrice1FromUniswap06 = get(configs, 6).isPrice1FromUniswap;\r\n        isPrice1FromUniswap07 = get(configs, 7).isPrice1FromUniswap;\r\n        isPrice1FromUniswap08 = get(configs, 8).isPrice1FromUniswap;\r\n        isPrice1FromUniswap09 = get(configs, 9).isPrice1FromUniswap;\r\n        isPrice1FromUniswap10 = get(configs, 10).isPrice1FromUniswap;\r\n        isPrice1FromUniswap11 = get(configs, 11).isPrice1FromUniswap;\r\n        isPrice1FromUniswap12 = get(configs, 12).isPrice1FromUniswap;\r\n        isPrice1FromUniswap13 = get(configs, 13).isPrice1FromUniswap;\r\n        isPrice1FromUniswap14 = get(configs, 14).isPrice1FromUniswap;\r\n        isPrice1FromUniswap15 = get(configs, 15).isPrice1FromUniswap;\r\n        isPrice1FromUniswap16 = get(configs, 16).isPrice1FromUniswap;\r\n        isPrice1FromUniswap17 = get(configs, 17).isPrice1FromUniswap;\r\n        isPrice1FromUniswap18 = get(configs, 18).isPrice1FromUniswap;\r\n        isPrice1FromUniswap19 = get(configs, 19).isPrice1FromUniswap;\r\n    }\r\n\r\n    function get(TokenConfig[] memory configs, uint i) internal pure returns (TokenConfig memory) {\r\n        if (i < configs.length)\r\n            return configs[i];\r\n        return TokenConfig({\r\n        gToken : address(0),\r\n        underlying : address(0),\r\n        symbolHash : bytes32(0),\r\n        baseUnit : uint256(0),\r\n        priceSource: PriceSource(0),\r\n        fixedPrice: uint256(0),\r\n        uniswapMarket : address(0),\r\n        isPrice1FromUniswap : false\r\n        });\r\n    }\r\n\r\n    function getCTokenIndex(address gToken) internal view returns (uint) {\r\n        if (gToken == gToken00) return 0;\r\n        if (gToken == gToken01) return 1;\r\n        if (gToken == gToken02) return 2;\r\n        if (gToken == gToken03) return 3;\r\n        if (gToken == gToken04) return 4;\r\n        if (gToken == gToken05) return 5;\r\n        if (gToken == gToken06) return 6;\r\n        if (gToken == gToken07) return 7;\r\n        if (gToken == gToken08) return 8;\r\n        if (gToken == gToken09) return 9;\r\n        if (gToken == gToken10) return 10;\r\n        if (gToken == gToken11) return 11;\r\n        if (gToken == gToken12) return 12;\r\n        if (gToken == gToken13) return 13;\r\n        if (gToken == gToken14) return 14;\r\n        if (gToken == gToken15) return 15;\r\n        if (gToken == gToken16) return 16;\r\n        if (gToken == gToken17) return 17;\r\n        if (gToken == gToken18) return 18;\r\n        if (gToken == gToken19) return 19;\r\n\r\n        return uint(- 1);\r\n    }\r\n\r\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\r\n        if (underlying == underlying00) return 0;\r\n        if (underlying == underlying01) return 1;\r\n        if (underlying == underlying02) return 2;\r\n        if (underlying == underlying03) return 3;\r\n        if (underlying == underlying04) return 4;\r\n        if (underlying == underlying05) return 5;\r\n        if (underlying == underlying06) return 6;\r\n        if (underlying == underlying07) return 7;\r\n        if (underlying == underlying08) return 8;\r\n        if (underlying == underlying09) return 9;\r\n        if (underlying == underlying10) return 10;\r\n        if (underlying == underlying11) return 11;\r\n        if (underlying == underlying12) return 12;\r\n        if (underlying == underlying13) return 13;\r\n        if (underlying == underlying14) return 14;\r\n        if (underlying == underlying15) return 15;\r\n        if (underlying == underlying16) return 16;\r\n        if (underlying == underlying17) return 17;\r\n        if (underlying == underlying18) return 18;\r\n        if (underlying == underlying19) return 19;\r\n\r\n        return uint(- 1);\r\n    }\r\n\r\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\r\n        if (symbolHash == symbolHash00) return 0;\r\n        if (symbolHash == symbolHash01) return 1;\r\n        if (symbolHash == symbolHash02) return 2;\r\n        if (symbolHash == symbolHash03) return 3;\r\n        if (symbolHash == symbolHash04) return 4;\r\n        if (symbolHash == symbolHash05) return 5;\r\n        if (symbolHash == symbolHash06) return 6;\r\n        if (symbolHash == symbolHash07) return 7;\r\n        if (symbolHash == symbolHash08) return 8;\r\n        if (symbolHash == symbolHash09) return 9;\r\n        if (symbolHash == symbolHash10) return 10;\r\n        if (symbolHash == symbolHash11) return 11;\r\n        if (symbolHash == symbolHash12) return 12;\r\n        if (symbolHash == symbolHash13) return 13;\r\n        if (symbolHash == symbolHash14) return 14;\r\n        if (symbolHash == symbolHash15) return 15;\r\n        if (symbolHash == symbolHash16) return 16;\r\n        if (symbolHash == symbolHash17) return 17;\r\n        if (symbolHash == symbolHash18) return 18;\r\n        if (symbolHash == symbolHash19) return 19;\r\n\r\n        return uint(- 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the i-th config, according to the order they were passed in originally\r\n     * @param i The index of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\r\n        require(i < numTokens, \"token config not found\");\r\n\r\n        if (i == 0) return TokenConfig({gToken: gToken00, underlying: underlying00, symbolHash: symbolHash00, baseUnit: baseUnit00, priceSource: priceSource00, fixedPrice: fixedPrice00, uniswapMarket: uniswapMarket00, isPrice1FromUniswap: isPrice1FromUniswap00});\r\n        if (i == 1) return TokenConfig({gToken: gToken01, underlying: underlying01, symbolHash: symbolHash01, baseUnit: baseUnit01, priceSource: priceSource01, fixedPrice: fixedPrice01, uniswapMarket: uniswapMarket01, isPrice1FromUniswap: isPrice1FromUniswap01});\r\n        if (i == 2) return TokenConfig({gToken: gToken02, underlying: underlying02, symbolHash: symbolHash02, baseUnit: baseUnit02, priceSource: priceSource02, fixedPrice: fixedPrice02, uniswapMarket: uniswapMarket02, isPrice1FromUniswap: isPrice1FromUniswap02});\r\n        if (i == 3) return TokenConfig({gToken: gToken03, underlying: underlying03, symbolHash: symbolHash03, baseUnit: baseUnit03, priceSource: priceSource03, fixedPrice: fixedPrice03, uniswapMarket: uniswapMarket03, isPrice1FromUniswap: isPrice1FromUniswap03});\r\n        if (i == 4) return TokenConfig({gToken: gToken04, underlying: underlying04, symbolHash: symbolHash04, baseUnit: baseUnit04, priceSource: priceSource04, fixedPrice: fixedPrice04, uniswapMarket: uniswapMarket04, isPrice1FromUniswap: isPrice1FromUniswap04});\r\n        if (i == 5) return TokenConfig({gToken: gToken05, underlying: underlying05, symbolHash: symbolHash05, baseUnit: baseUnit05, priceSource: priceSource05, fixedPrice: fixedPrice05, uniswapMarket: uniswapMarket05, isPrice1FromUniswap: isPrice1FromUniswap05});\r\n        if (i == 6) return TokenConfig({gToken: gToken06, underlying: underlying06, symbolHash: symbolHash06, baseUnit: baseUnit06, priceSource: priceSource06, fixedPrice: fixedPrice06, uniswapMarket: uniswapMarket06, isPrice1FromUniswap: isPrice1FromUniswap06});\r\n        if (i == 7) return TokenConfig({gToken: gToken07, underlying: underlying07, symbolHash: symbolHash07, baseUnit: baseUnit07, priceSource: priceSource07, fixedPrice: fixedPrice07, uniswapMarket: uniswapMarket07, isPrice1FromUniswap: isPrice1FromUniswap07});\r\n        if (i == 8) return TokenConfig({gToken: gToken08, underlying: underlying08, symbolHash: symbolHash08, baseUnit: baseUnit08, priceSource: priceSource08, fixedPrice: fixedPrice08, uniswapMarket: uniswapMarket08, isPrice1FromUniswap: isPrice1FromUniswap08});\r\n        if (i == 9) return TokenConfig({gToken: gToken09, underlying: underlying09, symbolHash: symbolHash09, baseUnit: baseUnit09, priceSource: priceSource09, fixedPrice: fixedPrice09, uniswapMarket: uniswapMarket09, isPrice1FromUniswap: isPrice1FromUniswap09});\r\n\r\n        if (i == 10) return TokenConfig({gToken: gToken10, underlying: underlying10, symbolHash: symbolHash10, baseUnit: baseUnit10, priceSource: priceSource10, fixedPrice: fixedPrice10, uniswapMarket: uniswapMarket10, isPrice1FromUniswap: isPrice1FromUniswap10});\r\n        if (i == 11) return TokenConfig({gToken: gToken11, underlying: underlying11, symbolHash: symbolHash11, baseUnit: baseUnit11, priceSource: priceSource11, fixedPrice: fixedPrice11, uniswapMarket: uniswapMarket11, isPrice1FromUniswap: isPrice1FromUniswap11});\r\n        if (i == 12) return TokenConfig({gToken: gToken12, underlying: underlying12, symbolHash: symbolHash12, baseUnit: baseUnit12, priceSource: priceSource12, fixedPrice: fixedPrice12, uniswapMarket: uniswapMarket12, isPrice1FromUniswap: isPrice1FromUniswap12});\r\n        if (i == 13) return TokenConfig({gToken: gToken13, underlying: underlying13, symbolHash: symbolHash13, baseUnit: baseUnit13, priceSource: priceSource13, fixedPrice: fixedPrice13, uniswapMarket: uniswapMarket13, isPrice1FromUniswap: isPrice1FromUniswap13});\r\n        if (i == 14) return TokenConfig({gToken: gToken14, underlying: underlying14, symbolHash: symbolHash14, baseUnit: baseUnit14, priceSource: priceSource14, fixedPrice: fixedPrice14, uniswapMarket: uniswapMarket14, isPrice1FromUniswap: isPrice1FromUniswap14});\r\n        if (i == 15) return TokenConfig({gToken: gToken15, underlying: underlying15, symbolHash: symbolHash15, baseUnit: baseUnit15, priceSource: priceSource15, fixedPrice: fixedPrice15, uniswapMarket: uniswapMarket15, isPrice1FromUniswap: isPrice1FromUniswap15});\r\n        if (i == 16) return TokenConfig({gToken: gToken16, underlying: underlying16, symbolHash: symbolHash16, baseUnit: baseUnit16, priceSource: priceSource16, fixedPrice: fixedPrice16, uniswapMarket: uniswapMarket16, isPrice1FromUniswap: isPrice1FromUniswap16});\r\n        if (i == 17) return TokenConfig({gToken: gToken17, underlying: underlying17, symbolHash: symbolHash17, baseUnit: baseUnit17, priceSource: priceSource17, fixedPrice: fixedPrice17, uniswapMarket: uniswapMarket17, isPrice1FromUniswap: isPrice1FromUniswap17});\r\n        if (i == 18) return TokenConfig({gToken: gToken18, underlying: underlying18, symbolHash: symbolHash18, baseUnit: baseUnit18, priceSource: priceSource18, fixedPrice: fixedPrice18, uniswapMarket: uniswapMarket18, isPrice1FromUniswap: isPrice1FromUniswap18});\r\n        if (i == 19) return TokenConfig({gToken: gToken19, underlying: underlying19, symbolHash: symbolHash19, baseUnit: baseUnit19, priceSource: priceSource19, fixedPrice: fixedPrice19, uniswapMarket: uniswapMarket19, isPrice1FromUniswap: isPrice1FromUniswap19});\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for symbol\r\n     * @param symbol The symbol of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\r\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for the symbolHash\r\n     * @param symbolHash The keccack256 of the symbol of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\r\n        uint index = getSymbolHashIndex(symbolHash);\r\n        if (index != uint(- 1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        revert(\"token config not found\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for the gToken\r\n     * @dev If a config for the gToken is not found, falls back to searching for the underlying.\r\n     * @param gToken The address of the gToken of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigByCToken(address gToken) public view returns (TokenConfig memory) {\r\n        uint index = getCTokenIndex(gToken);\r\n        if (index != uint(- 1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        return getTokenConfigByUnderlying(CErc20(gToken).underlying());\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for an underlying asset\r\n     * @param underlying The address of the underlying asset of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\r\n        uint index = getUnderlyingIndex(underlying);\r\n        if (index != uint(- 1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        revert(\"token config not found\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << 112) / denominator);\r\n    }\r\n\r\n    // decode a uq112x112 into a uint with 18 decimals of precision\r\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\r\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\r\n        // instead, get close to:\r\n        //  (x * 1e18) >> 112\r\n        // without risk of overflowing, e.g.:\r\n        //  (x) / 2 ** (112 - lg(1e18))\r\n        return uint(self._x) / 5192296858534827;\r\n    }\r\n}\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n}\r\n\r\n\r\n    struct Observation {\r\n        uint timestamp;\r\n        uint acc;\r\n    }\r\n\r\ncontract UniswapPriceOracleV2 is UniswapConfig {\r\n    using FixedPoint for *;\r\n\r\n    /// @notice The number of wei in 1 ETH\r\n    uint public constant ethBaseUnit = 1e18;\r\n\r\n    /// @notice The number of wei in 1 BNB\r\n    uint public constant bnbBaseUnit = 1e18;\r\n\r\n    uint public constant busdBaseUnit = 1e18;\r\n\r\n    /// @notice A common scaling factor to maintain precision\r\n    uint public constant expScale = 1e18;\r\n\r\n\r\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\r\n    uint public immutable anchorPeriod;\r\n\r\n    /// @notice Official prices by symbol hash\r\n    mapping(bytes32 => uint) public prices;\r\n\r\n    /// @notice The old observation for each symbolHash\r\n    mapping(bytes32 => Observation) public oldObservations;\r\n\r\n    /// @notice The new observation for each symbolHash\r\n    mapping(bytes32 => Observation) public newObservations;\r\n\r\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\r\n    event PriceGuarded(string symbol, uint reporter, uint anchor);\r\n\r\n    /// @notice The event emitted when the stored price is updated\r\n    event PriceUpdated(string symbol, uint price);\r\n\r\n    /// @notice The event emitted when anchor price is updated\r\n    event AnchorPriceUpdated(string symbol, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\r\n\r\n    /// @notice The event emitted when the uniswap window changes\r\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\r\n\r\n    bytes32 constant bnbHash = keccak256(abi.encodePacked(\"BNB\"));\r\n\r\n    constructor(uint anchorPeriod_,\r\n        address[] memory gTokens_, address[] memory underlyings_,\r\n        bytes32[] memory symbolHashs_, uint256[] memory baseUints_,\r\n        PriceSource[] memory priceSources_, uint256[] memory fixedPrices_,\r\n        address[] memory uniswapMarkets_, bool[] memory isPrice1FromUniswapArray_)\r\n    UniswapConfig(gTokens_, underlyings_, symbolHashs_, baseUints_, priceSources_, fixedPrices_, uniswapMarkets_,\r\n        isPrice1FromUniswapArray_) public {\r\n\r\n        anchorPeriod = anchorPeriod_;\r\n\r\n        for (uint i = 0; i < gTokens_.length; i++) {\r\n            TokenConfig memory config = TokenConfig({ gToken : gTokens_[i], underlying : underlyings_[i],\r\n            symbolHash : symbolHashs_[i], baseUnit : baseUints_[i],\r\n            priceSource: priceSources_[i], fixedPrice: fixedPrices_[i],\r\n            uniswapMarket : uniswapMarkets_[i], isPrice1FromUniswap : isPrice1FromUniswapArray_[i] });\r\n            require(config.baseUnit > 0, \"baseUnit must be greater than zero\");\r\n            address uniswapMarket = config.uniswapMarket;\r\n\r\n            require(config.priceSource == PriceSource.FIXED_USD || config.priceSource == PriceSource.REPORTER_USD\r\n                || config.priceSource == PriceSource.REPORTER_BNB,  \"unsupported PriceSource type\");\r\n\r\n            if (config.priceSource == PriceSource.REPORTER_BNB || config.priceSource == PriceSource.REPORTER_USD) {\r\n                require(uniswapMarket != address(0), \"reported prices must have an anchor\");\r\n                bytes32 symbolHash = config.symbolHash;\r\n                uint cumulativePrice = currentCumulativePrice(config);\r\n                oldObservations[symbolHash].timestamp = block.timestamp;\r\n                newObservations[symbolHash].timestamp = block.timestamp;\r\n                oldObservations[symbolHash].acc = cumulativePrice;\r\n                newObservations[symbolHash].acc = cumulativePrice;\r\n                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\r\n            } else {\r\n                require(uniswapMarket == address(0), \"only reported prices utilize an anchor\");\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the official price for a symbol\r\n     * @param symbol The symbol to fetch the price of\r\n     * @return Price denominated in USD, with 6 decimals\r\n     */\r\n    function price(string calldata symbol) external view returns (uint) {\r\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\r\n        return priceInternal(config);\r\n    }\r\n\r\n    function priceInternal(TokenConfig memory config) internal view returns (uint) {\r\n        if (config.priceSource == PriceSource.REPORTER_BNB || config.priceSource == PriceSource.REPORTER_USD) return prices[config.symbolHash];\r\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying price of a gToken\r\n     * @dev Implements the PriceOracle interface for Compound v2.\r\n     * @param gToken The gToken address for price retrieval\r\n     * @return Price denominated in USD, with 18 decimals, for the given gToken address\r\n     */\r\n    function getUnderlyingPrice(address gToken) external view returns (uint) {\r\n        TokenConfig memory config = getTokenConfigByCToken(gToken);\r\n        // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\r\n        // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\r\n        return mul(1e30, priceInternal(config)) / config.baseUnit;\r\n    }\r\n\r\n\r\n    function refresh(string[] calldata symbols) external {\r\n        uint bnbPrice = fetchBnbPrice();\r\n\r\n        // Try to update the view storage\r\n        for (uint i = 0; i < symbols.length; i++) {\r\n            postPriceInternal(symbols[i], bnbPrice);\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    function postPriceInternal(string memory symbol, uint bnbPrice) internal {\r\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\r\n\r\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\r\n        uint anchorPrice;\r\n        if (symbolHash == bnbHash) {\r\n            anchorPrice = bnbPrice;\r\n        } else if (config.priceSource == PriceSource.REPORTER_BNB){\r\n            anchorPrice = fetchAnchorPriceBnb(symbol, config, bnbPrice);\r\n        }\r\n        else if(config.priceSource == PriceSource.REPORTER_USD) {\r\n            anchorPrice = fetchAnchorPriceUSD(symbol, config);\r\n        }\r\n        else{\r\n            revert(\"wrong config.priceSource\");\r\n        }\r\n\r\n\r\n        prices[symbolHash] = anchorPrice;\r\n        emit PriceUpdated(symbol, anchorPrice);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Fetches the current token/eth price accumulator from uniswap.\r\n     */\r\n    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\r\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\r\n        if (config.isPrice1FromUniswap) {\r\n            return cumulativePrice1;\r\n        } else {\r\n            return cumulativePrice0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches the current bnb/usd price from dex swap, with 6 decimals of precision.\r\n     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\r\n     */\r\n    function fetchBnbPrice() internal returns (uint) {\r\n        return fetchAnchorPriceUSD(\"BNB\", getTokenConfigBySymbolHash(bnbHash));\r\n    }\r\n\r\n    /**\r\n     *  price as usd = token/bnb price  * bnb price\r\n     *\r\n     * @dev Fetches the current token usd price from dex swap, with 6 decimals of precision.\r\n     * @param bnbPrice  : with 6 decimals of precision\r\n     */\r\n    function fetchAnchorPriceBnb(string memory symbol, TokenConfig memory config, uint bnbPrice) internal virtual returns (uint) {\r\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\r\n\r\n        // This should be impossible, but better safe than sorry\r\n        require(block.timestamp > oldTimestamp, \"now must come after before\");\r\n        uint timeElapsed = block.timestamp - oldTimestamp;\r\n\r\n        // Calculate uniswap time-weighted average price\r\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\r\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\r\n        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, bnbPrice);\r\n\r\n        uint anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / bnbBaseUnit / expScale;\r\n\r\n        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\r\n\r\n        return anchorPrice;\r\n    }\r\n\r\n    /**\r\n * @dev Fetches the current token/usd stable coin  price from dex swap, with 6 decimals of precision.\r\n */\r\n    function fetchAnchorPriceUSD(string memory symbol, TokenConfig memory config) internal virtual returns (uint) {\r\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\r\n\r\n        // This should be impossible, but better safe than sorry\r\n        require(block.timestamp > oldTimestamp, \"now must come after before\");\r\n        uint timeElapsed = block.timestamp - oldTimestamp;\r\n\r\n        // Calculate uniswap time-weighted average price\r\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\r\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\r\n        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, config.baseUnit);\r\n        uint anchorPrice = mul(unscaledPriceMantissa , 1e6) / busdBaseUnit / expScale;\r\n\r\n        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\r\n\r\n        return anchorPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Get time-weighted average prices for a token at the current timestamp.\r\n     *  Update new and old observations of lagging window if period elapsed.\r\n     */\r\n    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\r\n        bytes32 symbolHash = config.symbolHash;\r\n        uint cumulativePrice = currentCumulativePrice(config);\r\n\r\n        Observation memory newObservation = newObservations[symbolHash];\r\n\r\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\r\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\r\n        if (timeElapsed >= anchorPeriod) {\r\n            oldObservations[symbolHash].timestamp = newObservation.timestamp;\r\n            oldObservations[symbolHash].acc = newObservation.acc;\r\n\r\n            newObservations[symbolHash].timestamp = block.timestamp;\r\n            newObservations[symbolHash].acc = cumulativePrice;\r\n            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\r\n        }\r\n        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Recovers the source address which signed a message\r\n     * @dev Comparing to a claimed address would add nothing,\r\n     *  as the caller could simply perform the recover and claim that address.\r\n     * @param message The data that was presumably signed\r\n     * @param signature The fingerprint of the data + private key\r\n     * @return The source address which signed the message, presumably\r\n     */\r\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /// @dev Overflow proof multiplication\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) return 0;\r\n        uint c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n\r\n    // get market price from dex\r\n    function getMarketPrice(string calldata symbol) external view returns (uint) {\r\n        \r\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\r\n        uint marketPrice = 0;\r\n        if(config.priceSource == PriceSource.FIXED_USD){ // Fixed price\r\n            marketPrice = config.fixedPrice;\r\n        }else if(config.priceSource == PriceSource.REPORTER_BNB){ \r\n            // For BNB, it is divided into two steps, first calculate the pair of BNB, \r\n            // and then convert it into USD, and USD decimal is 6 bits\r\n            uint bnbPrice = fetchBnbMarketPrice();\r\n            marketPrice = fetchMarketBnbPrice(config, bnbPrice);\r\n        }else if(config.priceSource == PriceSource.REPORTER_USD){ // For BUSD\r\n            marketPrice = fetchMarketPriceUSD(config);\r\n        }\r\n        return marketPrice;\r\n    }\r\n\r\n    // fetch bnb market price \r\n    function fetchMarketBnbPrice(TokenConfig memory config, uint bnbPrice) internal view virtual returns (uint) {\r\n        uint marketPrice = 0;\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(config.uniswapMarket).getReserves();\r\n        if(config.isPrice1FromUniswap){ \r\n            if(reserve1 != 0){\r\n                // price = (reserve0 / bnbBaseUnit) / (reserve1 / config.baseUnit) * bnbPrice; \r\n                // reserve0 is BNB, reserve1 is gtoken  // Multiply before divide bigNumber\r\n                marketPrice = mul(mul(reserve0, config.baseUnit), bnbPrice) / bnbBaseUnit / reserve1;\r\n            }\r\n        }else{\r\n            if(reserve0 != 0){\r\n                // price = (reserve1 / bnbBaseUnit) / (reserve0 / config.baseUnit) * bnbPrice; \r\n                // reserve1 is BNB, reserve0 is gtoken\r\n                marketPrice = mul(mul(reserve1, config.baseUnit), bnbPrice) / bnbBaseUnit / reserve0;\r\n            }\r\n        }\r\n        return marketPrice;\r\n    }\r\n\r\n    function fetchMarketPriceUSD(TokenConfig memory config) internal view virtual returns (uint) {\r\n        uint marketPrice = 0;\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(config.uniswapMarket).getReserves();\r\n        if(config.isPrice1FromUniswap){ \r\n            if(reserve1 != 0){\r\n                // price = (reserve0 / busdBaseUnit) / (reserve1 / config.baseUnit) * 1e6; \r\n                // price = reserve0 * config.baseUnit * 1e6 / busdBaseUnit / reserve1;\r\n                // reserve0 is BUSD, reserve1 is underlying Token\r\n                marketPrice = mul(mul(reserve0, config.baseUnit), 1e6) / busdBaseUnit / reserve1; \r\n            }\r\n        }else{\r\n            if(reserve0 != 0){\r\n                // price = (reserve1 / busdBaseUnit) / (reserve0 / config.baseUnit) * 1e6; \r\n                // price = reserve1 * config.baseUnit * 1e6 / busdBaseUnit / reserve0;\r\n                // reserve1 is BUSD, reserve0 is underlying Token\r\n                marketPrice = mul(mul(reserve1, config.baseUnit), 1e6) / busdBaseUnit / reserve0; \r\n            }\r\n        }\r\n        return marketPrice;\r\n    }\r\n\r\n    function fetchBnbMarketPrice() internal view returns (uint) {\r\n        return fetchMarketPriceUSD(getTokenConfigBySymbolHash(bnbHash));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anchorPeriod_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"gTokens_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"underlyings_\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"symbolHashs_\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"baseUints_\",\"type\":\"uint256[]\"},{\"internalType\":\"enum UniswapConfig.PriceSource[]\",\"name\":\"priceSources_\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fixedPrices_\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"uniswapMarkets_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"isPrice1FromUniswapArray_\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"}],\"name\":\"AnchorPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reporter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchor\",\"type\":\"uint256\"}],\"name\":\"PriceGuarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"UniswapWindowUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"anchorPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbBaseUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdBaseUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBaseUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getMarketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getTokenConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPrice1FromUniswap\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"}],\"name\":\"getTokenConfigByCToken\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPrice1FromUniswap\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getTokenConfigBySymbol\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPrice1FromUniswap\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"}],\"name\":\"getTokenConfigBySymbolHash\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPrice1FromUniswap\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getTokenConfigByUnderlying\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPrice1FromUniswap\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"newObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oldObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"symbols\",\"type\":\"string[]\"}],\"name\":\"refresh\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"source\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapPriceOracleV2", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000003e0000000000000000000000000000000000000000000000000000000000000054000000000000000000000000000000000000000000000000000000000000006a0000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009600000000000000000000000000000000000000000000000000000000000000ac0000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000c0e63cbb7f1aef16d0b9baf303df0e0308fe6626000000000000000000000000a5d2745a080af56b0bd1dd8ce27e15841f34a46c0000000000000000000000007dc9cc4abc0c10a2d2fae3d97ed418a1456642c00000000000000000000000005ad06e8c752596774538199dd146defc50f32c900000000000000000000000004c106b63c82698091582fa50a151c7d606b467070000000000000000000000004d05d0fa149b9035bc80c9969a5d4afea6980cb800000000000000000000000096fb4f383070dd7462768da4418195aad876a9e6000000000000000000000000182af4e1fbecad68837b46e9836458dc917995300000000000000000000000001c784f6751d1f82b659d49b175bae5c26a593cf70000000000000000000000006a816a9277bf08e6f59facc975f264bc2efb4c9b000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000007130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c0000000000000000000000001af3f329e8be154074d8769d1ffa4ee058b1dbc300000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d0000000000000000000000002a0006cd078c3be1c92b3a4b8b666e3e389589c80000000000000000000000000d8ce2a99bb6e3b7db580ed848240e4a0f9ae153000000000000000000000000ba2ae424d960c26247dd6c32edc70b295c744c43000000000000000000000000000000000000000000000000000000000000000aaaaebeba3810b1e6b70781f14b2d72c1cb89c0b2b320c43bb67ff79f562f5ff43ed03c38e59dc60c7b69c2a4bf68f9214acd953252b5a90e8f5f59583e9bc3ae54c512ac779647672b8d02e2fe2dc10f79bbf19f719d887221696215fd24e9f1a8f4e2415d2cbdfc918e4c626eb18bd2b69c91e0b198be3316062051fea51997a5e92f3efb6826155f1f728e162af9d7cda33a574a1153b58f03ea01cc37e5688b1a1d9c2b109e527c9134b25b1a1833b16b6594f92daa9f6d9b7a6024bce9d0d6aca1be9729c13d677335161321649cccae6a591554772516700f986f942eaa5381398629e7bd2521ba3559f1fc3805c0bd7609055441a8085859482fecaf77b697ea338743f6810f3e9604d53efbab1f95fa79ad4f69819c7c4a43510ffe499a3f52b1b31ae58da40209f38379e78c3a0756495a0f585d0b3c84a9e9718f9d000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000005f5e100000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000070d8929d04b60af4fb9b58713ebcf18765ade4220000000000000000000000001b96b92314c44b159149f7e0303511fb2fc4774f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000007561eee90e24f3b348e1087a005f78b4c8453524000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000796114764d6363c14fef8ea36887e8112e5354b0000000000000000000000000caabda10a3ac99fc15f5b636aa18e6b4fd8db16d000000000000000000000000ac109c8025f272414fd9e2faa805a583708a017f000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8ba379c2176e3c29e3eb52c223fe39f58cd9f70bcb1b2889e2c1d20e899fa427"}