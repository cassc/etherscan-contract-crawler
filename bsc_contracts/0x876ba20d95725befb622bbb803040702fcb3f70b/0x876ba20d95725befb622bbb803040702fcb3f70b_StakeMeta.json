{"SourceCode": "{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline \\u003e= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner\\u0027s nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user\\u0027s balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 =\\u003e address) internal _ownerOf;\\n\\n    mapping(address =\\u003e uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 =\\u003e address) public getApproved;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender\\u0027s balance is impossible because we check for\\n        // ownership above and the recipient\\u0027s balance can\\u0027t realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler\\u0027s built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"},\"Stake.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\nabstract contract SideContract {\\n    function stakeMeta(address user_address, uint256 plan, uint256 dnmAmount, uint256 uvmAmount, uint256 land_id, uint256 stake_id) virtual public;\\n    function depositStake(address user_address, uint256 stake_id) virtual public;\\n    function transferToken(address stake_addr) virtual public;\\n}\\n\\ncontract StakeMeta is Owned{\\n\\n    using SafeMath for uint256;\\n\\n    SideContract    private SC;\\n    bool            private SC_EXISTS = false;\\n\\n    ERC20   public UVM_TOKEN;\\n    ERC20   public DNM_TOKEN;\\n    ERC721  public LAND_TOKEN;\\n\\n    uint256 public constant TIME_STEP = 1 days;\\n    uint256 public constant REWARD_DECAY_FACTOR = 20;\\n    uint256 public constant REWARD_DECAY_PERIOD = 365 days;\\n    uint256 public constant STAKE_MAX_DNM = 28 ether;\\n    uint256 public constant STAKE_MIN_DNM = 1 ether;\\n    uint256 public constant STAKE_MAX_UVM = 6000 ether;\\n\\n    uint256 public LAUNCH_TIME;\\n    uint256 public TOTAL_UVM_STAKED;\\n    uint256 public TOTAL_DNM_STAKED;\\n    uint256 public TOTAL_LAND_STAKED;\\n    uint256 public TOTAL_REWARD;\\n    uint256 public UVM_POOL_BALANCE = 0;\\n    uint256 public STAKE_LIST_ID = 0;\\n    uint256 public USER_LIST_ID = 0;\\n    bool    public CONTACT_FINALIZED = false;\\n\\n    struct Plan {\\n        uint256 uvmPerUvm;\\n        uint256 uvmPerDnm;\\n    }\\n\\n    struct StakePlan {\\n        uint256 userId;\\n        bool exists;\\n        uint8 plan;\\n        uint256 uvm;\\n        uint256 dnm;\\n        uint256 land;\\n        uint256 reward;\\n        uint256 start;\\n        uint256 finish;\\n    }\\n\\n    struct User {\\n        uint256 id;\\n        bool exists;\\n        uint256[] stakePlanIds;\\n        uint256 totalReward;\\n    }\\n\\n    mapping(address =\\u003e User) internal users;\\n    mapping(uint256 =\\u003e address) public userList;\\n    mapping(uint16 =\\u003e Plan) public plans;\\n    mapping(uint256 =\\u003e StakePlan) public stakeList;\\n\\n    constructor(address uvm_token, address dnm_token, address land_token) Owned(msg.sender){\\n        LAUNCH_TIME = block.timestamp;\\n\\n        UVM_TOKEN   = ERC20(uvm_token);\\n        DNM_TOKEN   = ERC20(dnm_token);\\n        LAND_TOKEN  = ERC721(land_token);\\n\\n        plans[1] = Plan({\\n            uvmPerUvm : 3010,    // 0.00301\\n            uvmPerDnm : 1505000  // 1.505\\n        });\\n\\n        plans[2] = Plan({\\n            uvmPerUvm : 1505,    // 0.001505\\n            uvmPerDnm : 752500   // 0.7525 \\n        });\\n\\n        plans[3] = Plan({\\n            uvmPerUvm : 750,    // 0.00075\\n            uvmPerDnm : 375000  // 0.375 \\n        });\\n\\n        plans[4] = Plan({\\n            uvmPerUvm : 290,    // 0.00029\\n            uvmPerDnm : 145000  // 0.145 \\n        });\\n\\n        plans[5] = Plan({\\n            uvmPerUvm : 140,    // 0.000140\\n            uvmPerDnm : 70000   // 0.07\\n        });\\n    }\\n\\n    function stake(uint256 dnmAmount, uint256 land_id) public {\\n        require(dnmAmount \\u003c= STAKE_MAX_DNM \\u0026\\u0026 dnmAmount \\u003e= STAKE_MIN_DNM, \\u0027DNM amount is not in correct range\\u0027);\\n        \\n        uint8 plan = getPlanByTokenId(land_id);\\n        require(plan \\u003c 6 \\u0026\\u0026 plan \\u003e 0, \\\"Invalid plan\\\");\\n\\n        uint256 uvmAmount = calDnmUvmRatio(dnmAmount);\\n        require(DNM_TOKEN.balanceOf(msg.sender) \\u003e= dnmAmount, \\u0027DNM balance is not enough\\u0027);\\n        require(UVM_TOKEN.balanceOf(msg.sender) \\u003e= uvmAmount, \\u0027UVM balance is not enough\\u0027);\\n        require(LAND_TOKEN.ownerOf(land_id) == msg.sender, \\u0027You are not owner of land\\u0027);\\n\\n        bool d_transfer = DNM_TOKEN.transferFrom(msg.sender, address(this), dnmAmount);\\n        require(d_transfer == true, \\u0027Internal Error On DNM Transfer\\u0027);\\n        TOTAL_DNM_STAKED = TOTAL_DNM_STAKED.add(dnmAmount);\\n\\n        bool u_transfer = UVM_TOKEN.transferFrom(msg.sender, address(this), uvmAmount);\\n        require(u_transfer == true, \\u0027Internal Error On Uvm Transfer\\u0027);\\n        TOTAL_UVM_STAKED = TOTAL_UVM_STAKED.add(uvmAmount);\\n\\n        LAND_TOKEN.transferFrom(msg.sender, address(this), land_id);\\n        TOTAL_LAND_STAKED = TOTAL_LAND_STAKED.add(1);\\n\\n\\n        User memory user = users[msg.sender];\\n\\n        if(user.exists == false){\\n\\n            USER_LIST_ID++;\\n\\n            user = User({\\n                id : USER_LIST_ID,\\n                exists : true,\\n                stakePlanIds : new uint256[](0),\\n                totalReward : 0\\n            });\\n            \\n            userList[USER_LIST_ID] = msg.sender;\\n            emit NewUser(msg.sender, USER_LIST_ID);\\n        }\\n\\n        StakePlan memory sp = StakePlan({\\n            userId : user.id,\\n            exists : true,\\n            plan : plan,\\n            uvm : uvmAmount,\\n            dnm : dnmAmount,\\n            land : land_id,\\n            reward : 0,\\n            start : block.timestamp,\\n            finish : 0\\n        });\\n\\n        STAKE_LIST_ID++;\\n        stakeList[STAKE_LIST_ID] = sp;    \\n        users[msg.sender] = user;\\n        users[msg.sender].stakePlanIds.push(STAKE_LIST_ID);\\n\\n        if(SC_EXISTS == true){\\n            SC.stakeMeta(msg.sender, plan, dnmAmount, uvmAmount, land_id, STAKE_LIST_ID);\\n        }\\n        \\n        emit NewStake(\\n            user.id,\\n            plan,\\n            dnmAmount,\\n            uvmAmount, \\n            land_id,\\n            STAKE_LIST_ID\\n        );\\n    }\\n\\n    function withdrawStake(uint256 stake_id, bool withraw_reward) public {\\n\\n        User storage user = users[msg.sender];\\n        StakePlan memory sp = stakeList[stake_id];\\n\\n        require(user.exists == true, \\u0027user is not exists\\u0027);\\n        require(sp.exists == true, \\u0027stake is not exists\\u0027);\\n        require(sp.finish == 0, \\u0027stake is not active\\u0027);\\n        require(sp.userId == user.id, \\u0027you can only withraw your reward\\u0027);\\n\\n        uint256 min_time = 21 * TIME_STEP;\\n\\n        require((block.timestamp - sp.start) \\u003e= min_time, \\\"Min Stake withdrawal time is 21 Days!\\\");\\n\\n        // finish stake and save\\n        sp.finish = block.timestamp;\\n        stakeList[stake_id] = sp;\\n\\n        // send user token from stake\\n        UVM_TOKEN.transfer(msg.sender, sp.uvm);\\n        TOTAL_UVM_STAKED = TOTAL_UVM_STAKED.sub(sp.uvm);\\n        \\n        DNM_TOKEN.transfer(msg.sender, sp.dnm);\\n        TOTAL_DNM_STAKED = TOTAL_DNM_STAKED.sub(sp.dnm);\\n\\n        LAND_TOKEN.transferFrom(address(this), msg.sender, sp.land);\\n        TOTAL_LAND_STAKED = TOTAL_LAND_STAKED.sub(1);\\n\\n        // check if withdraw reward and call function\\n        if(withraw_reward == true){\\n            withdrawReward(stake_id);\\n        }\\n\\n        if(SC_EXISTS == true){\\n            SC.depositStake(msg.sender, stake_id);\\n        }\\n\\n        // emit events\\n        emit WithdrawUserStake(stake_id);\\n\\n    }\\n\\n    function withdrawReward(uint256 stake_id) public returns(bool){\\n\\n        User storage user = users[msg.sender];\\n        StakePlan memory sp = stakeList[stake_id];\\n\\n        require(user.exists == true, \\u0027user is not exists\\u0027);\\n        require(sp.exists == true, \\u0027stake is not exists\\u0027);\\n        require(sp.userId == user.id, \\u0027you can only withraw your reward\\u0027);\\n\\n        uint256 min_time = 21 * TIME_STEP;\\n\\n        require((block.timestamp - sp.start) \\u003e= min_time, \\\"Min Reward withdrawal time is 21 Days!\\\");\\n\\n\\n        uint256 totalReward = calculateRewardForStake(stake_id);\\n\\n        uint256 totalAmount = (totalReward - sp.reward);\\n\\n        sp.reward = totalReward;\\n\\n        if(totalAmount \\u003e 0){\\n        \\n            stakeList[stake_id] = sp;\\n\\n            require(UVM_POOL_BALANCE \\u003e= totalAmount, \\u0027Pool is empty\\u0027);\\n\\n            transferReward(msg.sender, totalAmount);\\n\\n            emit Withdraw(msg.sender, totalAmount);\\n\\n            return true;\\n\\n        }\\n\\n        return false;\\n    }\\n\\n    function getContractUVMBalance() public view returns (uint256) {\\n        return UVM_TOKEN.balanceOf(address(this));\\n    }\\n\\n    function getContractDNMBalance() public view returns (uint256) {\\n        return DNM_TOKEN.balanceOf(address(this));\\n    }\\n\\n    function getUser(address user_address) public view returns (uint256, bool, uint256){\\n        return (users[user_address].id, users[user_address].exists, users[user_address].totalReward);\\n    }\\n\\n    function getUserStakeIds(address user_address) public view returns (uint256[] memory){\\n        return users[user_address].stakePlanIds;\\n    }\\n\\n    function getUserStake(address user_address) public view returns (StakePlan[] memory){\\n\\n        uint256 spLength = users[user_address].stakePlanIds.length;\\n\\n         StakePlan[] memory StakePlanArray = new StakePlan[](spLength);\\n\\n        for(uint256 i=0; i\\u003cspLength; i++){\\n            StakePlanArray[i] = stakeList[users[user_address].stakePlanIds[i]];\\n        }\\n\\n        return StakePlanArray;\\n    }\\n\\n    function getAllStake(address userAddress) public view returns (StakePlan[] memory){\\n        StakePlan[] memory StakePlanArray = new StakePlan[](STAKE_LIST_ID);\\n\\n        for(uint256 i=1; i\\u003c=STAKE_LIST_ID; i++){\\n            StakePlanArray[(i-1)] = stakeList[i];\\n        }\\n\\n        return StakePlanArray;\\n    }\\n\\n    function getActiveStake(address userAddress) public view returns (StakePlan[] memory){\\n\\n        StakePlan[] memory StakePlanArray = new StakePlan[](TOTAL_LAND_STAKED);\\n\\n        uint256 _i = 0;\\n        for(uint256 i=1; i\\u003c=STAKE_LIST_ID; i++){\\n            if(stakeList[i].finish == 0){\\n                StakePlanArray[_i] = stakeList[i];\\n                _i = _i + 1;\\n            }\\n        }\\n\\n        return StakePlanArray;\\n\\n    }\\n\\n    function getFinishedStake(address user_address) public view returns (StakePlan[] memory){\\n\\n        uint256 count = (STAKE_LIST_ID - TOTAL_LAND_STAKED);\\n        StakePlan[] memory StakePlanArray = new StakePlan[](count);\\n\\n        uint256 _i = 0;\\n        for(uint256 i=1; i\\u003c=count; i++){\\n            if(stakeList[i].finish \\u003e 0){\\n                StakePlanArray[_i] = stakeList[i];\\n                _i = _i + 1;\\n            }\\n        }\\n\\n        return StakePlanArray;\\n\\n    }\\n\\n    function calDnmUvmRatio(uint256 dnm) public view returns(uint256){\\n        return STAKE_MAX_UVM.mul(dnm).div(STAKE_MAX_DNM);\\n    }\\n\\n    function calculateRewardForStake(uint256 stake_id) public view returns (uint256){\\n        \\n        require(stakeList[stake_id].exists == true, \\u0027stake is not exists\\u0027);\\n        StakePlan memory sp = stakeList[stake_id];\\n        if (sp.finish \\u003e 0)\\n            return calculateReward(sp.plan, sp.dnm, sp.uvm, sp.start, sp.finish);\\n        else\\n            return calculateReward(sp.plan, sp.dnm, sp.uvm, sp.start, block.timestamp);\\n\\n    }\\n\\n    function calculateReward(uint16 plan_type, uint256 dnm_amount, uint256 uvm_amount, uint256 start, uint256 end) public view returns (uint256){\\n\\n        require(plan_type \\u003c 6 \\u0026\\u0026 plan_type \\u003e 0, \\\"Invalid plan\\\");\\n        require(dnm_amount \\u003e 0, \\\"Invalid dnm amount\\\");\\n        require(uvm_amount \\u003e 0, \\\"Invalid uvm amount\\\");\\n        require(start \\u003c= end, \\\"Invalid start and end\\\");\\n\\n        uint256 elapsedStep = (end - start) / TIME_STEP;\\n\\n        uint256 totalReward = 0;\\n\\n        for(uint256 i=1; i\\u003c=elapsedStep; i++){\\n            uint256 _factory = (((start + ((i-1) * TIME_STEP)) - LAUNCH_TIME)) / REWARD_DECAY_PERIOD;\\n            uint256 ruvm = plans[plan_type].uvmPerUvm * uvm_amount / 1000000;\\n            uint256 rdnm = plans[plan_type].uvmPerDnm * dnm_amount / 1000000;\\n\\n            for(uint256 j=0; j\\u003c_factory; j++){\\n                ruvm = (ruvm * (100 - REWARD_DECAY_FACTOR)) / 100;\\n                rdnm = (rdnm * (100 - REWARD_DECAY_FACTOR)) / 100;\\n            }\\n\\n            totalReward = totalReward.add(ruvm);\\n            totalReward = totalReward.add(rdnm);\\n        }\\n\\n        return totalReward;\\n\\n    }\\n\\n    function getPlanByTokenId(uint256 land_id) public view returns(uint8){\\n        if(land_id \\u003e= 1 \\u0026\\u0026 land_id \\u003c= 8000){\\n            return 1;\\n        }else if(land_id \\u003e= 8001 \\u0026\\u0026 land_id \\u003c= 15000){\\n            return 2;\\n        }else if(land_id \\u003e= 15001 \\u0026\\u0026 land_id \\u003c= 20000){\\n            return 3;\\n        }else if(land_id \\u003e= 20001 \\u0026\\u0026 land_id \\u003c= 23000){\\n            return 4;\\n        }else if(land_id \\u003e= 23001 \\u0026\\u0026 land_id \\u003c= 25000){\\n            return 5;\\n        }else{\\n            return 0;\\n        }\\n    }\\n\\n    function addTokenToPool(uint256 amount) public {\\n        require(UVM_TOKEN.balanceOf(msg.sender) \\u003e= amount, \\u0027UVM balance is not enough\\u0027);\\n        bool u_transfer = UVM_TOKEN.transferFrom(msg.sender, address(this), amount);\\n        require(u_transfer == true, \\u0027Internal Error On Uvm Transfer\\u0027);\\n        UVM_POOL_BALANCE = UVM_POOL_BALANCE.add(amount);\\n        emit AddTokenToPool(msg.sender, amount);\\n    }\\n\\n    function transferReward(address user_address, uint256 amount) private {\\n        UVM_TOKEN.transfer(user_address, amount);\\n        UVM_POOL_BALANCE = UVM_POOL_BALANCE.sub(amount);\\n        TOTAL_REWARD = TOTAL_REWARD.add(amount);\\n        emit TransferReward(user_address, amount);\\n    }\\n\\n    function transferRewardFromSideContract(uint256 amount, address user_address) public {\\n        require(msg.sender == address(SC), \\u0027only side contract\\u0027);\\n        transferReward(user_address, amount);\\n    }\\n\\n    function addSideContract(address sc_address) public onlyOwner{\\n        require(CONTACT_FINALIZED == false, \\u0027contract finalized\\u0027);\\n        SC = SideContract(sc_address);\\n        SC_EXISTS = true;\\n        emit AddSideContract(sc_address);\\n    }\\n\\n    function removeSideContract() public onlyOwner{\\n        require(CONTACT_FINALIZED == false, \\u0027contract finalized\\u0027);\\n        SC_EXISTS = false;\\n        emit RemoveSideContract(false);\\n    }\\n\\n    function finalizeContract() public onlyOwner{\\n        CONTACT_FINALIZED = true;\\n        emit FinalizeContract(block.timestamp);\\n    }\\n\\n    \\n    event NewUser(address indexed user_address, uint256 user_id);\\n    event NewStake(uint256 user_id, uint8 plan, uint256 dnmAmount, uint256 uvm_amount, uint256 land_id, uint256 stake_id);\\n    event WithdrawUserStake(uint256 stake_id);\\n    event Withdraw(address indexed user, uint256 amount);\\n    event TransferReward(address indexed to, uint256 amount);\\n    event AddTokenToPool(address indexed user, uint256 amount);\\n    event AddSideContract(address indexed sc_address);\\n    event RemoveSideContract(bool status);\\n    event FinalizeContract(uint256 time);\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uvm_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dnm_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"land_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sc_address\",\"type\":\"address\"}],\"name\":\"AddSideContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddTokenToPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"FinalizeContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"user_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dnmAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uvm_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"land_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake_id\",\"type\":\"uint256\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"user_id\",\"type\":\"uint256\"}],\"name\":\"NewUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"RemoveSideContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake_id\",\"type\":\"uint256\"}],\"name\":\"WithdrawUserStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTACT_FINALIZED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DNM_TOKEN\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAND_TOKEN\",\"outputs\":[{\"internalType\":\"contract ERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAUNCH_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_DECAY_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_DECAY_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_LIST_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_MAX_DNM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_MAX_UVM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_MIN_DNM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_DNM_STAKED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_LAND_STAKED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_UVM_STAKED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USER_LIST_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UVM_POOL_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UVM_TOKEN\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sc_address\",\"type\":\"address\"}],\"name\":\"addSideContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addTokenToPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dnm\",\"type\":\"uint256\"}],\"name\":\"calDnmUvmRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"plan_type\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"dnm_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uvm_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stake_id\",\"type\":\"uint256\"}],\"name\":\"calculateRewardForStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getActiveStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"uvm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dnm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"land\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeMeta.StakePlan[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getAllStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"uvm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dnm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"land\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeMeta.StakePlan[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractDNMBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractUVMBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"}],\"name\":\"getFinishedStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"uvm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dnm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"land\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeMeta.StakePlan[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"land_id\",\"type\":\"uint256\"}],\"name\":\"getPlanByTokenId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"}],\"name\":\"getUserStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"uvm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dnm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"land\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeMeta.StakePlan[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"}],\"name\":\"getUserStakeIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"plans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uvmPerUvm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uvmPerDnm\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeSideContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dnmAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"land_id\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"uvm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dnm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"land\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"}],\"name\":\"transferRewardFromSideContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stake_id\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stake_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withraw_reward\",\"type\":\"bool\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeMeta", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a58aad37fa608a2a78a24954c35590c40a51a7b0000000000000000000000000e2ee021a370ce5a5bc776a87578ded7951da18ea000000000000000000000000d0c01a5d6c2b540ddfa296ed6072cdc43de68eb4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://03b15471e366825bff034eb45531b32fe92b733865a463015f95ac5c91e3254c"}