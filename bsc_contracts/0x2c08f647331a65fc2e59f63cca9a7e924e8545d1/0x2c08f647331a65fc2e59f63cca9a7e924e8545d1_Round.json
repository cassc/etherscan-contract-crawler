{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\r\\n */\\r\\ninterface IAccessControlUpgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(\\r\\n        bytes32 indexed role,\\r\\n        bytes32 indexed previousAdminRole,\\r\\n        bytes32 indexed newAdminRole\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {AccessControl-_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(\\r\\n        bytes32 indexed role,\\r\\n        address indexed account,\\r\\n        address indexed sender\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(\\r\\n        bytes32 indexed role,\\r\\n        address indexed account,\\r\\n        address indexed sender\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IEventEmitter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/utils/LUtil.sol\\\";\\r\\n\\r\\ninterface IEventEmitter {\\r\\n    function grantEventCallerRole(address eventCaller) external;\\r\\n\\r\\n    function emitCalculateRandomNumber(address roundAddress, uint256 number)\\r\\n        external;\\r\\n\\r\\n    function emitSetTicket(\\r\\n        address roundAddress,\\r\\n        address owner,\\r\\n        uint256 ticketKey,\\r\\n        uint8[] calldata ticket\\r\\n    ) external;\\r\\n\\r\\n    function emitCalculateWinningTickets(\\r\\n        address roundAddress,\\r\\n        uint256 page,\\r\\n        uint256 ticketKey,\\r\\n        address ticketOwner,\\r\\n        uint8[] calldata ticket\\r\\n    ) external;\\r\\n\\r\\n    function emitPayWinners(\\r\\n        address roundAddress,\\r\\n        uint256 page,\\r\\n        uint256 ticketKey,\\r\\n        LUtil.WinnerCategory category,\\r\\n        address ticketOwner,\\r\\n        uint256 winningAmount,\\r\\n        uint256 ticketsCount\\r\\n    ) external;\\r\\n\\r\\n    function emitChangeRoundStatus(\\r\\n        address roundAddress,\\r\\n        LUtil.RoundStatus status\\r\\n    ) external;\\r\\n\\r\\n    function emitWithdraw(\\r\\n        address roundAddress,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function emitDistribution(\\r\\n        address roundAddress,\\r\\n        address receiver,\\r\\n        LUtil.Distribution distribution,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IGame.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/utils/LUtil.sol\\\";\\r\\n\\r\\ninterface IGame {\\r\\n    function getStatus() external view returns (LUtil.GameStatus);\\r\\n\\r\\n    function getCurrentRoundNumber() external view returns (uint256);\\r\\n\\r\\n    function getCurrentRoundAddress() external view returns (address);\\r\\n\\r\\n    function getRounds(\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage,\\r\\n        bool isReversed\\r\\n    ) external view returns (address[] memory);\\r\\n\\r\\n    function getRoundsFromIndex(\\r\\n        uint256 index,\\r\\n        uint16 resultsPerPage,\\r\\n        bool isReversed\\r\\n    ) external view returns (address[] memory);\\r\\n\\r\\n    function isRoundExist(address roundAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (bool, uint256);\\r\\n\\r\\n    function approvePay(LUtil.Wallets wallet, uint256 amount) external;\\r\\n\\r\\n    function resetJackpot() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILottery.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IGame.sol\\\";\\r\\nimport \\\"./IPrizePool.sol\\\";\\r\\n\\r\\ninterface ILottery is IGame, IPrizePool {\\r\\n    function getTicketPrice() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPlatform.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/utils/LUtil.sol\\\";\\r\\n\\r\\ninterface IPlatform {\\r\\n    function getStatus() external view returns (LUtil.PlatformStatus);\\r\\n\\r\\n    function getTokenAddress(address gameAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function getBonusTokenAddress(address gameAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function getGameConfig(address _gameAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            bool,\\r\\n            bool,\\r\\n            bool,\\r\\n            bool\\r\\n        );\\r\\n\\r\\n    function getRoundDeployerAddress() external view returns (address);\\r\\n\\r\\n    function getReferralSystemAddress() external view returns (address);\\r\\n\\r\\n    function getPlatformOwnerAddress() external view returns (address);\\r\\n\\r\\n    function getBuybackTreasuryAddress() external view returns (address);\\r\\n\\r\\n    function getRevenueTreasuryAddress() external view returns (address);\\r\\n\\r\\n    function getBuybackReceiverAddress() external view returns (address);\\r\\n\\r\\n    function getRouterAddress() external view returns (address);\\r\\n\\r\\n    function getEventEmitterAddress() external view returns (address);\\r\\n\\r\\n    function getLinkTokenAddress() external view returns (address);\\r\\n\\r\\n    function getVRFWrapperAddress() external view returns (address);\\r\\n\\r\\n    function getCallbackGasLimit() external view returns (uint32);\\r\\n\\r\\n    function getLinkFee() external view returns (uint256);\\r\\n\\r\\n    function getGames(\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage,\\r\\n        bool isReversed\\r\\n    ) external view returns (address[] memory);\\r\\n\\r\\n    function isGameExist(address game) external view returns (bool);\\r\\n\\r\\n    function isRoundExist(address roundAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            bool,\\r\\n            uint256,\\r\\n            address\\r\\n        );\\r\\n\\r\\n    function setTokenAddress(address gameAddress, address tokenAddress)\\r\\n        external;\\r\\n\\r\\n    function setBonusTokenAddress(\\r\\n        address gameAddress,\\r\\n        address bonusTokenAddress\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPlatformAdmin.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\ninterface IPlatformAdmin {\\r\\n    function getPlatformAddress() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPrizePool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/utils/LUtil.sol\\\";\\r\\nimport \\\"./IPlatformAdmin.sol\\\";\\r\\n\\r\\ninterface IPrizePool is IPlatformAdmin {\\r\\n    function getJackpotRequireMin() external view returns (uint256);\\r\\n\\r\\n    function getWalletAddress(LUtil.Wallets walletIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IReferral.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\ninterface IReferral {\\r\\n    function isExist(address referral) external view returns (bool);\\r\\n\\r\\n    function getReferrer(address referral) external view returns (address);\\r\\n\\r\\n    function updateUserPoints(\\r\\n        address roundAddress,\\r\\n        address user,\\r\\n        uint256 ticketsCount\\r\\n    ) external;\\r\\n\\r\\n    function setReferrer(address referral, address referrer) external;\\r\\n\\r\\n    function startProcessing(address roundAddress) external;\\r\\n\\r\\n    function setRefunded(address roundAddress) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRound.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/utils/LUtil.sol\\\";\\r\\n\\r\\ninterface IRound {\\r\\n    function getStatus() external view returns (LUtil.RoundStatus);\\r\\n\\r\\n    function getRoundPoolAmount() external view returns (uint256);\\r\\n\\r\\n    function getRevenueAmount() external view returns (uint256);\\r\\n\\r\\n    function getPrizePoolBalances()\\r\\n        external\\r\\n        view\\r\\n        returns (LUtil.PrizeWallet[] memory);\\r\\n\\r\\n    function setTicket(uint8[] calldata ticket, address owner) external;\\r\\n\\r\\n    function startProcessing() external payable;\\r\\n\\r\\n    // function getRandomNumber() external payable;\\r\\n\\r\\n    function fundBalance(LUtil.PrizeWallet[] calldata balances) external;\\r\\n\\r\\n    function payPage(LUtil.WinnerCategory category, uint256 page) external;\\r\\n\\r\\n    function suspend() external;\\r\\n\\r\\n    function resume() external;\\r\\n\\r\\n    function refund() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IWallet.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../libs/utils/LUtil.sol\\\";\\r\\n\\r\\ninterface IWallet {\\r\\n    function balance() external view returns (uint256);\\r\\n\\r\\n    function approve(address approver, uint256 amount) external;\\r\\n\\r\\n    function transferTo(address recipient, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/swap-core/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address payable);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (uint256 amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/swap-core/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/token/IERC20Bonus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20Bonus {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transferToOwner(address from, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function transferFromOwner(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20MetadataBonus is IERC20Bonus {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/token/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/token/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface LinkTokenInterface {\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 remaining);\\r\\n\\r\\n    function approve(address spender, uint256 value)\\r\\n        external\\r\\n        returns (bool success);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    function decimals() external view returns (uint8 decimalPlaces);\\r\\n\\r\\n    function decreaseApproval(address spender, uint256 addedValue)\\r\\n        external\\r\\n        returns (bool success);\\r\\n\\r\\n    function increaseApproval(address spender, uint256 subtractedValue)\\r\\n        external;\\r\\n\\r\\n    function name() external view returns (string memory tokenName);\\r\\n\\r\\n    function symbol() external view returns (string memory tokenSymbol);\\r\\n\\r\\n    function totalSupply() external view returns (uint256 totalTokensIssued);\\r\\n\\r\\n    function transfer(address to, uint256 value)\\r\\n        external\\r\\n        returns (bool success);\\r\\n\\r\\n    function transferAndCall(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool success);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/VRFV2WrapperInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface VRFV2WrapperInterface {\\r\\n    /**\\r\\n     * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\\r\\n     * be relied option within the same transaction that the request was made.\\r\\n     */\\r\\n    function lastRequestId() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\\r\\n     * @notice block.\\r\\n     *\\r\\n     * @dev This function relies on the transaction gas price which is not automatically set during\\r\\n     * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\\r\\n     *\\r\\n     * @param _callbackGasLimit is the gas limit used to estimate the price.\\r\\n     */\\r\\n    function calculateRequestPrice(uint32 _callbackGasLimit)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\\r\\n     *\\r\\n     * @dev This is a convenience function that can be called in simulation to better understand\\r\\n     * @dev pricing.\\r\\n     *\\r\\n     * @param _callbackGasLimit is the gas limit used to estimate the price.\\r\\n     * @param _requestGasPriceWei is the gas price in wei used for the estimation.\\r\\n     */\\r\\n    function estimateRequestPrice(\\r\\n        uint32 _callbackGasLimit,\\r\\n        uint256 _requestGasPriceWei\\r\\n    ) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/lottery/LLottery.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../../interfaces/IRound.sol\\\";\\r\\nimport \\\"../../interfaces/IGame.sol\\\";\\r\\n\\r\\nlibrary LLottery {\\r\\n    function getTicketLength() public pure returns (uint8) {\\r\\n        return 0x6;\\r\\n    }\\r\\n\\r\\n    function getMinNumber() public pure returns (uint8) {\\r\\n        return 0x1;\\r\\n    }\\r\\n\\r\\n    function getMaxNumber() public pure returns (uint8) {\\r\\n        return 0x2d;\\r\\n    }\\r\\n\\r\\n    function validateTickets(uint8[][] calldata numbersArray) external {\\r\\n        IRound round = IRound(IGame(address(this)).getCurrentRoundAddress());\\r\\n        for (uint256 index = 0; index < numbersArray.length; index++) {\\r\\n            require(\\r\\n                numbersArray[index].length == getTicketLength(),\\r\\n                \\\"LLottery: invalid ticket length\\\"\\r\\n            );\\r\\n\\r\\n            for (\\r\\n                uint256 numIndex = 0;\\r\\n                numIndex < getTicketLength();\\r\\n                numIndex++\\r\\n            ) {\\r\\n                require(\\r\\n                    numbersArray[index][numIndex] > getMinNumber() - 1 &&\\r\\n                        numbersArray[index][numIndex] < getMaxNumber() + 1,\\r\\n                    \\\"LLottery: invalid numbers range\\\"\\r\\n                );\\r\\n                for (\\r\\n                    uint256 idx = numIndex + 1;\\r\\n                    idx < getTicketLength();\\r\\n                    idx++\\r\\n                ) {\\r\\n                    require(\\r\\n                        numbersArray[index][numIndex] !=\\r\\n                            numbersArray[index][idx],\\r\\n                        \\\"LLottery: dublicated number error\\\"\\r\\n                    );\\r\\n                }\\r\\n            }\\r\\n\\r\\n            round.setTicket(numbersArray[index], msg.sender);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/lottery/pool/LPrizePool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../../../interfaces/token/IERC20Metadata.sol\\\";\\r\\nimport \\\"../../../interfaces/token/IERC20Bonus.sol\\\";\\r\\nimport \\\"../../../interfaces/IWallet.sol\\\";\\r\\nimport \\\"../../../interfaces/IPlatform.sol\\\";\\r\\nimport \\\"../../../interfaces/IReferral.sol\\\";\\r\\nimport \\\"../../utils/LUtil.sol\\\";\\r\\nimport \\\"../../../utils/structs/EnumerableSetUpgradeable.sol\\\";\\r\\nimport \\\"../../../interfaces/swap-core/IUniswapV2Router02.sol\\\";\\r\\nimport \\\"../../token/SafeERC20.sol\\\";\\r\\nimport \\\"../../../interfaces/IEventEmitter.sol\\\";\\r\\nimport \\\"../../../interfaces/ILottery.sol\\\";\\r\\n\\r\\nlibrary LPrizePool {\\r\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\r\\n    using SafeERC20 for IERC20Metadata;\\r\\n\\r\\n    function getPoolsCount() public pure returns (uint8) {\\r\\n        return 0x6;\\r\\n    }\\r\\n\\r\\n    function getCommonPrizePoolPercent() public pure returns (uint16) {\\r\\n        return 0xC350; // 50000 - 50%\\r\\n    }\\r\\n\\r\\n    function getReferrerPurposePercent() public pure returns (uint16) {\\r\\n        return 0x1388; // 5000 - 5%\\r\\n    }\\r\\n\\r\\n    function getRevenuePurposePercent() public pure returns (uint16) {\\r\\n        return 0x4FD3; // 20435 - 20,435 %\\r\\n    }\\r\\n\\r\\n    function getPlatformPurposePercent() public pure returns (uint16) {\\r\\n        return 0x4C6D; // 19565 - 19,565%\\r\\n    }\\r\\n\\r\\n    function getULXBuybackPercent() public pure returns (uint16) {\\r\\n        return 0x1388; // 5000 - 5%\\r\\n    }\\r\\n\\r\\n    function getBurnPurposePercent() public pure returns (uint16) {\\r\\n        return 0x1388; // 5000 - 5%\\r\\n    }\\r\\n\\r\\n    function getBonusPurposePercent() public pure returns (uint16) {\\r\\n        return 0x0; // 0 - 0%\\r\\n    }\\r\\n\\r\\n    function getJackpotPercent() public pure returns (uint16) {\\r\\n        return 0x5014; // 20500 - 20,50 %\\r\\n    }\\r\\n\\r\\n    function getCategoryTwoPercent() public pure returns (uint16) {\\r\\n        return 0x3C8C; // 15500 - 15,50 %\\r\\n    }\\r\\n\\r\\n    function getCategoryThreePercent() public pure returns (uint16) {\\r\\n        return 0x251C; // 9500 - 9,50%\\r\\n    }\\r\\n\\r\\n    function getCategoryFourPercent() public pure returns (uint16) {\\r\\n        return 0x34BC; // 13500 - 13,50%\\r\\n    }\\r\\n\\r\\n    function getCategoryFivePercent() public pure returns (uint16) {\\r\\n        return 0x7918; // 31000 - 31%\\r\\n    }\\r\\n\\r\\n    function getBoosterPercent() public pure returns (uint16) {\\r\\n        return 0x2710; // 10000 - 10%\\r\\n    }\\r\\n\\r\\n    function getBoosterFundLimit() public pure returns (uint256) {\\r\\n        return 0x2DC6C0; // 3 kk USDT 0x2DC6C0 * 10 ^ 6 && 90 kk ULX 0x55D4A80 * 10 ^ 18\\r\\n    }\\r\\n\\r\\n    function getJackpotMinimumAmount() public pure returns (uint256) {\\r\\n        return 0xF4240; // 1 kk USDT 0xF4240 * 10 ^ 6 && 30 kk ULX 0x1C9C380 * 10 ^ 18\\r\\n    }\\r\\n\\r\\n    //The function to distribute funds from prize pool to categories\\r\\n    bytes4 private constant SELECTOR =\\r\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\r\\n\\r\\n    function _getToken(address tokenAddress)\\r\\n        private\\r\\n        pure\\r\\n        returns (IERC20Metadata token)\\r\\n    {\\r\\n        token = IERC20Metadata(tokenAddress);\\r\\n    }\\r\\n\\r\\n    function _getTokenBalanceOf(address tokenAddress, address account)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 balance)\\r\\n    {\\r\\n        balance = _getToken(tokenAddress).balanceOf(account);\\r\\n    }\\r\\n\\r\\n    function _getGameConfig(IPlatform platform, address gameAddress)\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            bool isBonusAvailable,\\r\\n            bool isBurnAvailable,\\r\\n            bool isBuybackAvailable,\\r\\n            bool isRevenueAvailable\\r\\n        )\\r\\n    {\\r\\n        (\\r\\n            isBonusAvailable,\\r\\n            isBurnAvailable,\\r\\n            isBuybackAvailable,\\r\\n            isRevenueAvailable\\r\\n        ) = platform.getGameConfig(gameAddress);\\r\\n    }\\r\\n\\r\\n    function _emitDistribution(\\r\\n        IPlatform platform,\\r\\n        address gameAddress,\\r\\n        address receiver,\\r\\n        LUtil.Distribution distribution,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        IEventEmitter(platform.getEventEmitterAddress()).emitDistribution(\\r\\n            ILottery(gameAddress).getCurrentRoundAddress(),\\r\\n            receiver,\\r\\n            distribution,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address tokenAddress,\\r\\n        address approveAddress,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        _getToken(tokenAddress).approve(approveAddress, amount);\\r\\n    }\\r\\n\\r\\n    function _safeTransfer(\\r\\n        address tokenAddress,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        IPlatform platform,\\r\\n        address gameAddress,\\r\\n        LUtil.Distribution distribution\\r\\n    ) private {\\r\\n        _getToken(tokenAddress).safeTransfer(to, amount);\\r\\n        _emitDistribution(platform, gameAddress, to, distribution, amount);\\r\\n    }\\r\\n\\r\\n    function _swapWETH(\\r\\n        address wethAddress,\\r\\n        address treasuryAddress,\\r\\n        address routerAddress,\\r\\n        uint256 amount,\\r\\n        IPlatform platform,\\r\\n        address gameAddress,\\r\\n        address tokenAddress\\r\\n    ) private {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = tokenAddress;\\r\\n        path[1] = wethAddress;\\r\\n        uint256[] memory amountsOut = IUniswapV2Router02(routerAddress)\\r\\n            .getAmountsOut(amount, path);\\r\\n        if (amountsOut[amountsOut.length - 1] > 0) {\\r\\n            uint256 amountOutMin = amountsOut[amountsOut.length - 1] -\\r\\n                (amountsOut[amountsOut.length - 1] * 0xa) /\\r\\n                0x64;\\r\\n            _approve(tokenAddress, routerAddress, amount);\\r\\n            IUniswapV2Router02(routerAddress).swapExactTokensForETH(\\r\\n                amount,\\r\\n                amountOutMin,\\r\\n                path,\\r\\n                treasuryAddress,\\r\\n                block.timestamp + 30\\r\\n            );\\r\\n            _emitDistribution(\\r\\n                platform,\\r\\n                gameAddress,\\r\\n                treasuryAddress,\\r\\n                LUtil.Distribution.BUYBACK,\\r\\n                amount\\r\\n            );\\r\\n            _approve(tokenAddress, routerAddress, 0);\\r\\n        } else {\\r\\n            _safeTransfer(\\r\\n                tokenAddress,\\r\\n                treasuryAddress,\\r\\n                amount,\\r\\n                platform,\\r\\n                gameAddress,\\r\\n                LUtil.Distribution.BUYBACK\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _distributePlartformPercent(\\r\\n        IPlatform platform,\\r\\n        address gameAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 amount,\\r\\n        address buyer\\r\\n    ) private returns (uint256 platformPercent, uint256 roundPrize) {\\r\\n        (bool isBonusAvailable, , , bool isRevenueAvailable) = _getGameConfig(\\r\\n            platform,\\r\\n            gameAddress\\r\\n        );\\r\\n\\r\\n        platformPercent = getPlatformPurposePercent();\\r\\n        if (isBonusAvailable) {\\r\\n            IERC20Bonus bonusToken = IERC20Bonus(\\r\\n                platform.getBonusTokenAddress(gameAddress)\\r\\n            );\\r\\n            bonusToken.transferFromOwner(\\r\\n                buyer,\\r\\n                (amount * getBonusPurposePercent()) / 0x186A0\\r\\n            );\\r\\n        }\\r\\n\\r\\n        roundPrize = (amount * getCommonPrizePoolPercent()) / 0x186A0;\\r\\n        {\\r\\n            IReferral referralSystem = IReferral(\\r\\n                platform.getReferralSystemAddress()\\r\\n            );\\r\\n            address referrer = referralSystem.getReferrer(buyer);\\r\\n\\r\\n            if (referrer == address(0)) {\\r\\n                platformPercent += getReferrerPurposePercent();\\r\\n            } else {\\r\\n                _safeTransfer(\\r\\n                    tokenAddress,\\r\\n                    referrer,\\r\\n                    (amount * getReferrerPurposePercent()) / 0x186A0,\\r\\n                    platform,\\r\\n                    gameAddress,\\r\\n                    LUtil.Distribution.REFERRER\\r\\n                );\\r\\n            }\\r\\n            address revenueReceiver = isRevenueAvailable\\r\\n                ? address(referralSystem)\\r\\n                : platform.getRevenueTreasuryAddress();\\r\\n            _safeTransfer(\\r\\n                tokenAddress,\\r\\n                revenueReceiver,\\r\\n                (amount * getRevenuePurposePercent()) / 0x186A0,\\r\\n                platform,\\r\\n                gameAddress,\\r\\n                LUtil.Distribution.REVENUE\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _distribute(\\r\\n        EnumerableSetUpgradeable.AddressSet storage wallets,\\r\\n        IPlatform platform,\\r\\n        address gameAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 platformPercent,\\r\\n        uint256 amount,\\r\\n        uint256 roundPrize\\r\\n    ) private {\\r\\n        (, bool isBurnAvailable, bool isBuybackAvailable, ) = _getGameConfig(\\r\\n            platform,\\r\\n            gameAddress\\r\\n        );\\r\\n\\r\\n        IUniswapV2Router02 router = IUniswapV2Router02(\\r\\n            platform.getRouterAddress()\\r\\n        );\\r\\n        _safeTransfer(\\r\\n            tokenAddress,\\r\\n            platform.getPlatformOwnerAddress(),\\r\\n            (amount * platformPercent) / 0x186A0,\\r\\n            platform,\\r\\n            gameAddress,\\r\\n            LUtil.Distribution.PLATFORM\\r\\n        );\\r\\n\\r\\n        if (isBurnAvailable) {\\r\\n            _safeTransfer(\\r\\n                tokenAddress,\\r\\n                platform.getBuybackTreasuryAddress(),\\r\\n                (amount * getBurnPurposePercent()) / 0x186A0,\\r\\n                platform,\\r\\n                gameAddress,\\r\\n                LUtil.Distribution.BURN\\r\\n            );\\r\\n        } else if (isBuybackAvailable) {\\r\\n            _swapWETH(\\r\\n                router.WETH(),\\r\\n                platform.getBuybackTreasuryAddress(),\\r\\n                address(router),\\r\\n                (amount * getULXBuybackPercent()) / 0x186A0,\\r\\n                platform,\\r\\n                gameAddress,\\r\\n                tokenAddress\\r\\n            );\\r\\n        } else {\\r\\n            _safeTransfer(\\r\\n                tokenAddress,\\r\\n                platform.getBuybackReceiverAddress(),\\r\\n                (amount * getULXBuybackPercent()) / 0x186A0,\\r\\n                platform,\\r\\n                gameAddress,\\r\\n                LUtil.Distribution.BUYBACK_RECEIVER\\r\\n            );\\r\\n        }\\r\\n\\r\\n        _safeTransfer(\\r\\n            tokenAddress,\\r\\n            wallets.at(uint256(LUtil.Wallets.CATEGORY2_WALLET)),\\r\\n            (roundPrize * getCategoryTwoPercent()) / 0x186A0,\\r\\n            platform,\\r\\n            gameAddress,\\r\\n            LUtil.Distribution.CATEGORY2_WALLET\\r\\n        );\\r\\n        _safeTransfer(\\r\\n            tokenAddress,\\r\\n            wallets.at(uint256(LUtil.Wallets.CATEGORY3_WALLET)),\\r\\n            (roundPrize * getCategoryThreePercent()) / 0x186A0,\\r\\n            platform,\\r\\n            gameAddress,\\r\\n            LUtil.Distribution.CATEGORY3_WALLET\\r\\n        );\\r\\n        _safeTransfer(\\r\\n            tokenAddress,\\r\\n            wallets.at(uint256(LUtil.Wallets.CATEGORY4_WALLET)),\\r\\n            (roundPrize * getCategoryFourPercent()) / 0x186A0,\\r\\n            platform,\\r\\n            gameAddress,\\r\\n            LUtil.Distribution.CATEGORY4_WALLET\\r\\n        );\\r\\n        _safeTransfer(\\r\\n            tokenAddress,\\r\\n            wallets.at(uint256(LUtil.Wallets.CATEGORY5_WALLET)),\\r\\n            (roundPrize * getCategoryFivePercent()) / 0x186A0,\\r\\n            platform,\\r\\n            gameAddress,\\r\\n            LUtil.Distribution.CATEGORY5_WALLET\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _distributeJackpot(\\r\\n        EnumerableSetUpgradeable.AddressSet storage wallets,\\r\\n        IPlatform platform,\\r\\n        address gameAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 roundPrize,\\r\\n        uint256 jackpotRequireMin\\r\\n    ) private returns (uint256) {\\r\\n        uint256 boosterFundLimit = getBoosterFundLimit() *\\r\\n            10**_getToken(tokenAddress).decimals();\\r\\n\\r\\n        uint256 jackpotAmount = (roundPrize * getJackpotPercent()) / 0x186A0;\\r\\n        if (\\r\\n            _getTokenBalanceOf(\\r\\n                tokenAddress,\\r\\n                wallets.at(uint256(LUtil.Wallets.BOOSTER_WALLET))\\r\\n            ) > boosterFundLimit\\r\\n        ) {\\r\\n            jackpotAmount += (roundPrize * getBoosterPercent()) / 0x186A0;\\r\\n        } else {\\r\\n            if (\\r\\n                _getTokenBalanceOf(\\r\\n                    tokenAddress,\\r\\n                    wallets.at(uint256(LUtil.Wallets.JACKPOT_WALLET))\\r\\n                ) < jackpotRequireMin\\r\\n            ) {\\r\\n                uint256 amount_ = (roundPrize * (getBoosterPercent() / 0x2)) /\\r\\n                    0x186A0;\\r\\n                jackpotAmount += amount_;\\r\\n                jackpotRequireMin += amount_;\\r\\n                _safeTransfer(\\r\\n                    tokenAddress,\\r\\n                    wallets.at(uint256(LUtil.Wallets.BOOSTER_WALLET)),\\r\\n                    amount_,\\r\\n                    platform,\\r\\n                    gameAddress,\\r\\n                    LUtil.Distribution.BOOSTER_WALLET\\r\\n                );\\r\\n            } else {\\r\\n                _safeTransfer(\\r\\n                    tokenAddress,\\r\\n                    wallets.at(uint256(LUtil.Wallets.BOOSTER_WALLET)),\\r\\n                    (roundPrize * getBoosterPercent()) / 0x186A0,\\r\\n                    platform,\\r\\n                    gameAddress,\\r\\n                    LUtil.Distribution.BOOSTER_WALLET\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _safeTransfer(\\r\\n            tokenAddress,\\r\\n            wallets.at(uint256(LUtil.Wallets.JACKPOT_WALLET)),\\r\\n            jackpotAmount,\\r\\n            platform,\\r\\n            gameAddress,\\r\\n            LUtil.Distribution.JACKPOT_WALLET\\r\\n        );\\r\\n        return jackpotRequireMin;\\r\\n    }\\r\\n\\r\\n    function distribute(\\r\\n        EnumerableSetUpgradeable.AddressSet storage wallets,\\r\\n        address platformAddress,\\r\\n        address gameAddress,\\r\\n        address buyer,\\r\\n        uint256 amount,\\r\\n        uint256 jackpotRequireMin\\r\\n    ) external returns (uint256) {\\r\\n        require(amount > 0, \\\"PRIZEPOOL: Amount must be more than 0\\\");\\r\\n        address tokenAddress = IPlatform(platformAddress).getTokenAddress(\\r\\n            gameAddress\\r\\n        );\\r\\n\\r\\n        (\\r\\n            uint256 platformPercent,\\r\\n            uint256 roundPrize\\r\\n        ) = _distributePlartformPercent(\\r\\n                IPlatform(platformAddress),\\r\\n                gameAddress,\\r\\n                tokenAddress,\\r\\n                amount,\\r\\n                buyer\\r\\n            );\\r\\n\\r\\n        _distribute(\\r\\n            wallets,\\r\\n            IPlatform(platformAddress),\\r\\n            gameAddress,\\r\\n            tokenAddress,\\r\\n            platformPercent,\\r\\n            amount,\\r\\n            roundPrize\\r\\n        );\\r\\n\\r\\n        return\\r\\n            _distributeJackpot(\\r\\n                wallets,\\r\\n                IPlatform(platformAddress),\\r\\n                gameAddress,\\r\\n                tokenAddress,\\r\\n                roundPrize,\\r\\n                jackpotRequireMin\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        EnumerableSetUpgradeable.AddressSet storage wallets,\\r\\n        LUtil.Wallets wallet,\\r\\n        address roundAddress,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        IWallet(wallets.at(uint256(wallet))).approve(roundAddress, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/lottery/round/LRound.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../../../interfaces/token/IERC20.sol\\\";\\r\\nimport \\\"../../../interfaces/ILottery.sol\\\";\\r\\nimport \\\"../../../utils/structs/EnumerableSet.sol\\\";\\r\\nimport \\\"../../utils/LUtil.sol\\\";\\r\\nimport \\\"../../utils/array/LArray.sol\\\";\\r\\nimport \\\"../../lottery/LLottery.sol\\\";\\r\\nimport \\\"../../lottery/pool/LPrizePool.sol\\\";\\r\\nimport \\\"../../../Wallet.sol\\\";\\r\\nimport \\\"../../token/SafeERC20.sol\\\";\\r\\nimport \\\"../../../interfaces/IEventEmitter.sol\\\";\\r\\n\\r\\nlibrary LRound {\\r\\n    struct TicketStorage {\\r\\n        mapping(uint256 => address) _ticketOwners;\\r\\n        mapping(uint256 => uint8[]) _ticketNumbers;\\r\\n        mapping(uint8 => uint256[]) _ticketsPool;\\r\\n        mapping(uint256 => bool) _ticketProcessed;\\r\\n        mapping(uint256 => bool) _ticketPayed;\\r\\n        mapping(address => uint256[]) _ownerTickets;\\r\\n        uint256 _ticketsCount;\\r\\n        uint256 _processedPages;\\r\\n    }\\r\\n\\r\\n    using EnumerableSet for EnumerableSet.UintSet;\\r\\n    using LRound for LUtil.PrizeWallet[];\\r\\n\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    function getPoolLength() public pure returns (uint8) {\\r\\n        return 0x6;\\r\\n    }\\r\\n\\r\\n    function getTicketsPerProcessing() public pure returns (uint16) {\\r\\n        return 0x3E8;\\r\\n    }\\r\\n\\r\\n    function getTicketsPerPay() public pure returns (uint16) {\\r\\n        return 0x3E8;\\r\\n    }\\r\\n\\r\\n    function isOpen(LUtil.RoundStatus status) public pure {\\r\\n        require(status == LUtil.RoundStatus.OPEN, \\\"ROUND: status not opened\\\");\\r\\n    }\\r\\n\\r\\n    function isProcessing(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            status == LUtil.RoundStatus.PROCESSING,\\r\\n            \\\"ROUND: status not in processing\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isPaying(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            status == LUtil.RoundStatus.PAYING,\\r\\n            \\\"ROUND: status not in paying\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isPayed(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            status == LUtil.RoundStatus.PAYED,\\r\\n            \\\"ROUND: status not in payed\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isRefund(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            status == LUtil.RoundStatus.REFUND,\\r\\n            \\\"ROUND: status not in refund\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isCalculatedWinners(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            status == LUtil.RoundStatus.CALCULATED_WINNERS,\\r\\n            \\\"ROUND: status not in calculating winners\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isFundedOrPaying(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            (status == LUtil.RoundStatus.FUNDED) ||\\r\\n                (status == LUtil.RoundStatus.PAYING),\\r\\n            \\\"ROUND: status not in funded or paying\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function ifHasWinningNumbers(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            status >= LUtil.RoundStatus.PROCESSING,\\r\\n            \\\"ROUND: does not have winning numbers - round opened or refunded or generating\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function ifFunded(LUtil.RoundStatus status) public pure {\\r\\n        require(\\r\\n            status >= LUtil.RoundStatus.FUNDED,\\r\\n            \\\"ROUND: not funded - round opened or refunded or generating or processing or calculated winners\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isClosed(LUtil.RoundStatus status) public pure {\\r\\n        require(status == LUtil.RoundStatus.CLOSED, \\\"ROUND: not payed\\\");\\r\\n    }\\r\\n\\r\\n    function _getLottery(address lotteryAddress)\\r\\n        private\\r\\n        pure\\r\\n        returns (ILottery lottery)\\r\\n    {\\r\\n        lottery = ILottery(lotteryAddress);\\r\\n    }\\r\\n\\r\\n    function _getPagesByLimit(uint256 size, uint16 resultsPerPage)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256 pages)\\r\\n    {\\r\\n        pages = LArray.getPagesByLimit(size, resultsPerPage);\\r\\n    }\\r\\n\\r\\n    function _getPositions(\\r\\n        uint256 size,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        )\\r\\n    {\\r\\n        (startIndex, stopIndex, elementsCount) = LArray.getPositions(\\r\\n            size,\\r\\n            page,\\r\\n            resultsPerPage\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _getPlatform(address lotteryAddress)\\r\\n        private\\r\\n        view\\r\\n        returns (IPlatform platform)\\r\\n    {\\r\\n        platform = IPlatform(_getLottery(lotteryAddress).getPlatformAddress());\\r\\n    }\\r\\n\\r\\n    function _getToken(address lotteryAddress)\\r\\n        private\\r\\n        view\\r\\n        returns (IERC20 token)\\r\\n    {\\r\\n        token = IERC20(\\r\\n            _getPlatform(lotteryAddress).getTokenAddress(lotteryAddress)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _getWalletAddress(address lotteryAddress, LUtil.Wallets wallet)\\r\\n        private\\r\\n        view\\r\\n        returns (address walletAddress)\\r\\n    {\\r\\n        walletAddress = _getLottery(lotteryAddress).getWalletAddress(wallet);\\r\\n    }\\r\\n\\r\\n    function _roundExists(address lotteryAddress, address roundAddress)\\r\\n        private\\r\\n        view\\r\\n    {\\r\\n        (bool isExist, ) = _getLottery(lotteryAddress).isRoundExist(\\r\\n            roundAddress\\r\\n        );\\r\\n        require(isExist, \\\"round does not exist\\\");\\r\\n    }\\r\\n\\r\\n    function _createTicketObject(\\r\\n        TicketStorage storage tickets,\\r\\n        uint256 index,\\r\\n        bool isInitial,\\r\\n        LUtil.WinnerCategory category,\\r\\n        address ticketOwner\\r\\n    ) private view returns (LUtil.TicketObject memory ticket) {\\r\\n        uint256 ticketKey;\\r\\n        if (isInitial) {\\r\\n            ticketKey = index + 1;\\r\\n        } else if (!isInitial && ticketOwner != address(0)) {\\r\\n            ticketKey = tickets._ownerTickets[ticketOwner][index];\\r\\n        } else {\\r\\n            ticketKey = tickets._ticketsPool[uint8(category) + 1][index];\\r\\n        }\\r\\n        address owner = ticketOwner != address(0)\\r\\n            ? ticketOwner\\r\\n            : tickets._ticketOwners[ticketKey];\\r\\n\\r\\n        ticket = LUtil.TicketObject(\\r\\n            ticketKey,\\r\\n            owner,\\r\\n            tickets._ticketNumbers[ticketKey],\\r\\n            true\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _createTicketObjects(\\r\\n        TicketStorage storage tickets,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage,\\r\\n        bool isInitial,\\r\\n        LUtil.WinnerCategory category,\\r\\n        address ticketOwner\\r\\n    ) private view returns (LUtil.TicketObject[] memory _tickets) {\\r\\n        uint256 size;\\r\\n        if (isInitial && ticketOwner == address(0)) {\\r\\n            size = tickets._ticketsCount;\\r\\n        } else if (!isInitial && ticketOwner != address(0)) {\\r\\n            size = tickets._ownerTickets[ticketOwner].length;\\r\\n        } else {\\r\\n            size = tickets._ticketsPool[uint8(category) + 1].length;\\r\\n        }\\r\\n\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = _getPositions(size, page, resultsPerPage);\\r\\n\\r\\n        _tickets = new LUtil.TicketObject[](elementsCount);\\r\\n\\r\\n        if (elementsCount == 0) return _tickets;\\r\\n\\r\\n        uint256 index_ = 0;\\r\\n        for (uint256 index = startIndex; index < stopIndex + 1; index++) {\\r\\n            _tickets[index_] = _createTicketObject(\\r\\n                tickets,\\r\\n                index,\\r\\n                isInitial,\\r\\n                category,\\r\\n                ticketOwner\\r\\n            );\\r\\n            index_++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _isPayedCategory(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.WinnerCategory category\\r\\n    ) private view returns (bool) {\\r\\n        uint8 _category = uint8(category) + 1;\\r\\n        require(\\r\\n            tickets._ticketsPool[_category].length > 0,\\r\\n            \\\"winners pool empty\\\"\\r\\n        );\\r\\n        uint256 pages = _getPagesByLimit(\\r\\n            tickets._ticketsPool[_category].length,\\r\\n            getTicketsPerPay()\\r\\n        );\\r\\n\\r\\n        for (uint256 page = 1; page < pages + 1; page++) {\\r\\n            if (\\r\\n                !tickets._ticketPayed[\\r\\n                    tickets._ticketsPool[_category][\\r\\n                        getTicketsPerPay() * (page - 1)\\r\\n                    ]\\r\\n                ]\\r\\n            ) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _isProcessed(TicketStorage storage tickets)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        if (tickets._ticketsCount == 0) return true;\\r\\n        return\\r\\n            tickets._processedPages ==\\r\\n            _getPagesByLimit(tickets._ticketsCount, getTicketsPerProcessing());\\r\\n    }\\r\\n\\r\\n    function _addAmount(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.WinnerPay[] memory ticketsOwners,\\r\\n        uint256 index,\\r\\n        LUtil.WinnerCategory category,\\r\\n        uint256 amount\\r\\n    ) private view {\\r\\n        bool isExist;\\r\\n        uint256 i = 0;\\r\\n        {\\r\\n            while (i < ticketsOwners.length && ticketsOwners[i].isValid) {\\r\\n                if (\\r\\n                    ticketsOwners[i].recipient ==\\r\\n                    tickets._ticketOwners[\\r\\n                        tickets._ticketsPool[uint8(category) + 1][index]\\r\\n                    ]\\r\\n                ) {\\r\\n                    ticketsOwners[i].ticketsCount++;\\r\\n                    ticketsOwners[i].amount +=\\r\\n                        amount /\\r\\n                        tickets._ticketsPool[uint8(category) + 1].length;\\r\\n                    isExist = true;\\r\\n                }\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!isExist) {\\r\\n            ticketsOwners[i] = LUtil.WinnerPay(\\r\\n                tickets._ticketOwners[\\r\\n                    tickets._ticketsPool[uint8(category) + 1][index]\\r\\n                ],\\r\\n                amount / tickets._ticketsPool[uint8(category) + 1].length,\\r\\n                1,\\r\\n                true\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _generateWinners(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.PrizeWallet storage wallet,\\r\\n        LUtil.WinnerCategory category,\\r\\n        uint256 page\\r\\n    ) private returns (LUtil.WinnerPay[] memory) {\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = _getPositions(\\r\\n                tickets._ticketsPool[uint8(category) + 1].length,\\r\\n                page,\\r\\n                getTicketsPerPay()\\r\\n            );\\r\\n        LUtil.WinnerPay[] memory ticketsOwners = new LUtil.WinnerPay[](\\r\\n            elementsCount\\r\\n        );\\r\\n        if (elementsCount == 0) {\\r\\n            return ticketsOwners;\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            !tickets._ticketPayed[\\r\\n                tickets._ticketsPool[uint8(category) + 1][startIndex]\\r\\n            ],\\r\\n            \\\"page already payed\\\"\\r\\n        );\\r\\n        tickets._ticketPayed[\\r\\n            tickets._ticketsPool[uint8(category) + 1][startIndex]\\r\\n        ] = true;\\r\\n\\r\\n        for (uint256 index = startIndex; index < stopIndex + 1; index++) {\\r\\n            _addAmount(tickets, ticketsOwners, index, category, wallet.amount);\\r\\n        }\\r\\n\\r\\n        return ticketsOwners;\\r\\n    }\\r\\n\\r\\n    function _safeTransferFrom(\\r\\n        address lotteryAddress,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        _getToken(lotteryAddress).safeTransferFrom(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function _safeTransferFromToBooster(\\r\\n        address lotteryAddress,\\r\\n        LUtil.Wallets wallet,\\r\\n        uint256 poolAmount,\\r\\n        uint256 percent\\r\\n    ) private {\\r\\n        _safeTransferFrom(\\r\\n            lotteryAddress,\\r\\n            _getWalletAddress(lotteryAddress, wallet),\\r\\n            _getWalletAddress(lotteryAddress, LUtil.Wallets.BOOSTER_WALLET),\\r\\n            (poolAmount * percent) / 0x186A0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _lotteryApprovePay(\\r\\n        ILottery lottery,\\r\\n        LUtil.Wallets wallet,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        lottery.approvePay(wallet, amount);\\r\\n    }\\r\\n\\r\\n    function _approveWinnersPay(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.PrizeWallet[] storage wallets,\\r\\n        ILottery lottery,\\r\\n        LUtil.Wallets wallet,\\r\\n        LUtil.WinnerCategory winnerCategory\\r\\n    ) private {\\r\\n        if (tickets._ticketsPool[uint8(winnerCategory) + 1].length > 0) {\\r\\n            if (winnerCategory == LUtil.WinnerCategory.JACKPOT) {\\r\\n                lottery.resetJackpot();\\r\\n                if (\\r\\n                    _getToken(address(lottery)).balanceOf(\\r\\n                        wallets[uint256(wallet)].wallet\\r\\n                    ) < wallets[uint256(wallet)].amount\\r\\n                )\\r\\n                    _lotteryApprovePay(\\r\\n                        lottery,\\r\\n                        LUtil.Wallets.BOOSTER_WALLET,\\r\\n                        wallets[0].amount\\r\\n                    );\\r\\n            }\\r\\n            _lotteryApprovePay(\\r\\n                lottery,\\r\\n                wallet,\\r\\n                wallets[uint256(wallet)].amount\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _emitCalculateWinningTickets(\\r\\n        TicketStorage storage tickets,\\r\\n        address eventEmitterAddress,\\r\\n        address roundAddress,\\r\\n        uint256 page,\\r\\n        uint256 ticketKey\\r\\n    ) private {\\r\\n        IEventEmitter(eventEmitterAddress).emitCalculateWinningTickets(\\r\\n            roundAddress,\\r\\n            page,\\r\\n            ticketKey,\\r\\n            tickets._ticketOwners[ticketKey],\\r\\n            tickets._ticketNumbers[ticketKey]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isPayedPages(TicketStorage storage tickets)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        LUtil.WinnerCategory[5] memory categories;\\r\\n        categories = [\\r\\n            LUtil.WinnerCategory.JACKPOT,\\r\\n            LUtil.WinnerCategory.CATEGORY2,\\r\\n            LUtil.WinnerCategory.CATEGORY3,\\r\\n            LUtil.WinnerCategory.CATEGORY4,\\r\\n            LUtil.WinnerCategory.CATEGORY5\\r\\n        ];\\r\\n        for (uint256 i = 0; i < categories.length; i++) {\\r\\n            LUtil.WinnerCategory category = categories[i];\\r\\n            if (\\r\\n                getCategoryTicketsCount(tickets, category) != 0 &&\\r\\n                !_isPayedCategory(tickets, category)\\r\\n            ) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getUserTicketsCount(TicketStorage storage tickets, address owner)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return tickets._ownerTickets[owner].length;\\r\\n    }\\r\\n\\r\\n    function getTicketsCount(TicketStorage storage tickets)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return tickets._ticketsCount;\\r\\n    }\\r\\n\\r\\n    function getCategoryTicketsCount(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.WinnerCategory category\\r\\n    ) public view returns (uint256) {\\r\\n        return tickets._ticketsPool[uint8(category) + 1].length;\\r\\n    }\\r\\n\\r\\n    function getPaginatedTickets(\\r\\n        TicketStorage storage tickets,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) public view returns (LUtil.TicketObject[] memory) {\\r\\n        return\\r\\n            _createTicketObjects(\\r\\n                tickets,\\r\\n                page,\\r\\n                resultsPerPage,\\r\\n                true,\\r\\n                LUtil.WinnerCategory.CATEGORY5,\\r\\n                address(0)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getPaginatedUserTickets(\\r\\n        TicketStorage storage tickets,\\r\\n        address owner,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (LUtil.TicketObject[] memory _tickets) {\\r\\n        return\\r\\n            _createTicketObjects(\\r\\n                tickets,\\r\\n                page,\\r\\n                resultsPerPage,\\r\\n                false,\\r\\n                LUtil.WinnerCategory.CATEGORY5,\\r\\n                owner\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getPaginatedWinners(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.WinnerCategory category,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) public view returns (LUtil.TicketObject[] memory) {\\r\\n        return\\r\\n            _createTicketObjects(\\r\\n                tickets,\\r\\n                page,\\r\\n                resultsPerPage,\\r\\n                false,\\r\\n                category,\\r\\n                address(0)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getTicketsCountPerCategory(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.WinnerCategory category\\r\\n    ) public view returns (uint256) {\\r\\n        return tickets._ticketsPool[uint8(category) + 1].length;\\r\\n    }\\r\\n\\r\\n    function calculateTicketAmount(\\r\\n        LUtil.PrizeWallet[] storage balances,\\r\\n        LUtil.WinnerCategory category,\\r\\n        uint256 ticketCount\\r\\n    ) public view returns (uint256) {\\r\\n        if (ticketCount == 0) ticketCount++;\\r\\n        return balances[uint8(category)].amount / ticketCount;\\r\\n    }\\r\\n\\r\\n    function checkPagePayed(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.WinnerCategory category,\\r\\n        uint256 page\\r\\n    ) public view returns (bool) {\\r\\n        (uint256 startIndex, , ) = _getPositions(\\r\\n            tickets._ticketsPool[uint8(category) + 1].length,\\r\\n            page,\\r\\n            getTicketsPerPay()\\r\\n        );\\r\\n        return\\r\\n            tickets._ticketPayed[\\r\\n                tickets._ticketsPool[uint8(category) + 1][startIndex]\\r\\n            ];\\r\\n    }\\r\\n\\r\\n    function emitChangeStatusEvent(\\r\\n        TicketStorage storage tickets,\\r\\n        address lotteryAddress,\\r\\n        address roundAddress,\\r\\n        address eventEmitterAddress,\\r\\n        LUtil.RoundStatus status\\r\\n    ) public {\\r\\n        _roundExists(lotteryAddress, roundAddress);\\r\\n        IEventEmitter(eventEmitterAddress).emitChangeRoundStatus(\\r\\n            roundAddress,\\r\\n            status\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function emitWithdrawEvent(\\r\\n        TicketStorage storage tickets,\\r\\n        address lotteryAddress,\\r\\n        address roundAddress,\\r\\n        address eventEmitterAddress,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public {\\r\\n        _roundExists(lotteryAddress, roundAddress);\\r\\n        IEventEmitter(eventEmitterAddress).emitWithdraw(\\r\\n            roundAddress,\\r\\n            to,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setTicket(\\r\\n        TicketStorage storage tickets,\\r\\n        uint8[] memory ticket,\\r\\n        address owner,\\r\\n        address roundAddress,\\r\\n        address eventEmitterAddress\\r\\n    ) public {\\r\\n        tickets._ticketsCount++;\\r\\n\\r\\n        for (uint256 index = 0; index < LLottery.getTicketLength(); index++) {\\r\\n            tickets._ticketNumbers[tickets._ticketsCount].push(ticket[index]);\\r\\n        }\\r\\n\\r\\n        tickets._ticketOwners[tickets._ticketsCount] = owner;\\r\\n        tickets._ownerTickets[owner].push(tickets._ticketsCount);\\r\\n        IEventEmitter(eventEmitterAddress).emitSetTicket(\\r\\n            roundAddress,\\r\\n            owner,\\r\\n            tickets._ticketsCount,\\r\\n            tickets._ticketNumbers[tickets._ticketsCount]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function calculateWinnersGroupsPage(\\r\\n        TicketStorage storage tickets,\\r\\n        uint256 page,\\r\\n        EnumerableSet.UintSet storage numbers,\\r\\n        address roundAddress,\\r\\n        address eventEmitterAddress\\r\\n    ) public returns (bool) {\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = _getPositions(\\r\\n                tickets._ticketsCount,\\r\\n                page,\\r\\n                getTicketsPerProcessing()\\r\\n            );\\r\\n        if (elementsCount == 0) {\\r\\n            return _isProcessed(tickets);\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            !tickets._ticketProcessed[startIndex + 1],\\r\\n            \\\"page already processed\\\"\\r\\n        );\\r\\n        tickets._ticketProcessed[startIndex + 1] = true;\\r\\n        tickets._processedPages++;\\r\\n\\r\\n        for (uint256 index = startIndex; index < stopIndex + 1; index++) {\\r\\n            uint256 numIndex = 0;\\r\\n            uint8 coincidenceCount = 0;\\r\\n            uint256 ticketKey = index + 1;\\r\\n\\r\\n            while (numIndex < LLottery.getTicketLength()) {\\r\\n                if (\\r\\n                    numbers.contains(\\r\\n                        tickets._ticketNumbers[ticketKey][numIndex]\\r\\n                    )\\r\\n                ) {\\r\\n                    coincidenceCount++;\\r\\n                }\\r\\n                numIndex++;\\r\\n            }\\r\\n\\r\\n            if (coincidenceCount > 1) {\\r\\n                tickets\\r\\n                    ._ticketsPool[\\r\\n                        LLottery.getTicketLength() + 1 - coincidenceCount\\r\\n                    ]\\r\\n                    .push(ticketKey);\\r\\n                _emitCalculateWinningTickets(\\r\\n                    tickets,\\r\\n                    eventEmitterAddress,\\r\\n                    roundAddress,\\r\\n                    page,\\r\\n                    ticketKey\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return _isProcessed(tickets);\\r\\n    }\\r\\n\\r\\n    function payPage(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.PrizeWallet[] storage wallets,\\r\\n        LUtil.WinnerCategory category,\\r\\n        uint256 page,\\r\\n        address lotteryAddress,\\r\\n        address roundAddress,\\r\\n        address eventEmitterAddress\\r\\n    ) public {\\r\\n        (, , uint256 elementsCount) = _getPositions(\\r\\n            tickets._ticketsPool[uint8(category) + 1].length,\\r\\n            page,\\r\\n            getTicketsPerPay()\\r\\n        );\\r\\n\\r\\n        LUtil.WinnerPay[] memory ticketsOwners = _generateWinners(\\r\\n            tickets,\\r\\n            wallets[uint8(category)],\\r\\n            category,\\r\\n            page\\r\\n        );\\r\\n        uint256 index = 0;\\r\\n\\r\\n        while (index < elementsCount && ticketsOwners[index].isValid) {\\r\\n            if (\\r\\n                _getToken(lotteryAddress).balanceOf(\\r\\n                    wallets[uint8(category)].wallet\\r\\n                ) < ticketsOwners[index].amount\\r\\n            ) {\\r\\n                _lotteryApprovePay(\\r\\n                    _getLottery(lotteryAddress),\\r\\n                    LUtil.Wallets.BOOSTER_WALLET,\\r\\n                    ticketsOwners[index].amount\\r\\n                );\\r\\n                _safeTransferFrom(\\r\\n                    lotteryAddress,\\r\\n                    wallets[uint256(LUtil.Wallets.BOOSTER_WALLET)].wallet,\\r\\n                    ticketsOwners[index].recipient,\\r\\n                    ticketsOwners[index].amount\\r\\n                );\\r\\n            } else {\\r\\n                _safeTransferFrom(\\r\\n                    lotteryAddress,\\r\\n                    wallets[uint8(category)].wallet,\\r\\n                    ticketsOwners[index].recipient,\\r\\n                    ticketsOwners[index].amount\\r\\n                );\\r\\n            }\\r\\n            uint256 ticketKey = tickets._ticketsPool[uint8(category) + 1][\\r\\n                index\\r\\n            ];\\r\\n            IEventEmitter(eventEmitterAddress).emitPayWinners(\\r\\n                roundAddress,\\r\\n                page,\\r\\n                ticketKey,\\r\\n                category,\\r\\n                ticketsOwners[index].recipient,\\r\\n                ticketsOwners[index].amount,\\r\\n                ticketsOwners[index].ticketsCount\\r\\n            );\\r\\n            index++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateRandomNumbers(\\r\\n        EnumerableSet.UintSet storage set,\\r\\n        uint256 salt,\\r\\n        address roundAddress,\\r\\n        address eventEmitterAddress\\r\\n    ) public {\\r\\n        uint256 randNonce;\\r\\n        while (set.length() < LLottery.getTicketLength()) {\\r\\n            uint256 randomNumber = (uint256(\\r\\n                keccak256(abi.encodePacked(salt, randNonce))\\r\\n            ) % LLottery.getMaxNumber()) + 1;\\r\\n            set.add(randomNumber);\\r\\n            randNonce++;\\r\\n            IEventEmitter(eventEmitterAddress).emitCalculateRandomNumber(\\r\\n                roundAddress,\\r\\n                randomNumber\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function transferToBooster(\\r\\n        LUtil.PrizeWallet[] storage wallets,\\r\\n        address lotteryAddress,\\r\\n        uint256 roundAmount\\r\\n    ) public {\\r\\n        uint256 poolAmount = (roundAmount *\\r\\n            LPrizePool.getCommonPrizePoolPercent()) / 0x186A0;\\r\\n\\r\\n        uint256 jackpotPercent = LPrizePool.getJackpotPercent();\\r\\n        if (\\r\\n            _getToken(lotteryAddress).balanceOf(\\r\\n                _getWalletAddress(lotteryAddress, LUtil.Wallets.JACKPOT_WALLET)\\r\\n            ) < _getLottery(lotteryAddress).getJackpotRequireMin()\\r\\n        ) {\\r\\n            jackpotPercent += (LPrizePool.getBoosterPercent() / 0x2);\\r\\n        }\\r\\n\\r\\n        _safeTransferFromToBooster(\\r\\n            lotteryAddress,\\r\\n            LUtil.Wallets.JACKPOT_WALLET,\\r\\n            poolAmount,\\r\\n            jackpotPercent\\r\\n        );\\r\\n        _safeTransferFromToBooster(\\r\\n            lotteryAddress,\\r\\n            LUtil.Wallets.CATEGORY2_WALLET,\\r\\n            poolAmount,\\r\\n            LPrizePool.getCategoryTwoPercent()\\r\\n        );\\r\\n        _safeTransferFromToBooster(\\r\\n            lotteryAddress,\\r\\n            LUtil.Wallets.CATEGORY3_WALLET,\\r\\n            poolAmount,\\r\\n            LPrizePool.getCategoryThreePercent()\\r\\n        );\\r\\n        _safeTransferFromToBooster(\\r\\n            lotteryAddress,\\r\\n            LUtil.Wallets.CATEGORY4_WALLET,\\r\\n            poolAmount,\\r\\n            LPrizePool.getCategoryFourPercent()\\r\\n        );\\r\\n        _safeTransferFromToBooster(\\r\\n            lotteryAddress,\\r\\n            LUtil.Wallets.CATEGORY5_WALLET,\\r\\n            poolAmount,\\r\\n            LPrizePool.getCategoryFivePercent()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function approveWinnersPay(\\r\\n        TicketStorage storage tickets,\\r\\n        LUtil.PrizeWallet[] storage wallets,\\r\\n        address lotteryAddress\\r\\n    ) public {\\r\\n        _approveWinnersPay(\\r\\n            tickets,\\r\\n            wallets,\\r\\n            _getLottery(lotteryAddress),\\r\\n            LUtil.Wallets.JACKPOT_WALLET,\\r\\n            LUtil.WinnerCategory.JACKPOT\\r\\n        );\\r\\n        _approveWinnersPay(\\r\\n            tickets,\\r\\n            wallets,\\r\\n            _getLottery(lotteryAddress),\\r\\n            LUtil.Wallets.CATEGORY2_WALLET,\\r\\n            LUtil.WinnerCategory.CATEGORY2\\r\\n        );\\r\\n        _approveWinnersPay(\\r\\n            tickets,\\r\\n            wallets,\\r\\n            _getLottery(lotteryAddress),\\r\\n            LUtil.Wallets.CATEGORY3_WALLET,\\r\\n            LUtil.WinnerCategory.CATEGORY3\\r\\n        );\\r\\n        _approveWinnersPay(\\r\\n            tickets,\\r\\n            wallets,\\r\\n            _getLottery(lotteryAddress),\\r\\n            LUtil.Wallets.CATEGORY4_WALLET,\\r\\n            LUtil.WinnerCategory.CATEGORY4\\r\\n        );\\r\\n        _approveWinnersPay(\\r\\n            tickets,\\r\\n            wallets,\\r\\n            _getLottery(lotteryAddress),\\r\\n            LUtil.Wallets.CATEGORY5_WALLET,\\r\\n            LUtil.WinnerCategory.CATEGORY5\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/platform/LPlatform.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../../libs/utils/LUtil.sol\\\";\\r\\nimport \\\"../../interfaces/IGame.sol\\\";\\r\\nimport \\\"../../libs/referral/LReferral.sol\\\";\\r\\nimport \\\"../../utils/structs/EnumerableSetUpgradeable.sol\\\";\\r\\n\\r\\nlibrary LPlatform {\\r\\n    bytes32 public constant ownerRole =\\r\\n        0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\r\\n    bytes32 public constant adminRole =\\r\\n        0xf23ec0bb4210edd5cba85afd05127efcd2fc6a781bfed49188da1081670b22d8;\\r\\n\\r\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\r\\n\\r\\n    function isGamesClosed(EnumerableSetUpgradeable.AddressSet storage games)\\r\\n        public\\r\\n        view\\r\\n        returns (bool isClosed)\\r\\n    {\\r\\n        isClosed = true;\\r\\n\\r\\n        for (uint256 index = 0; index < games.length(); index++) {\\r\\n            IGame game = IGame(games.at(index));\\r\\n            if (game.getStatus() != LUtil.GameStatus.CLOSED) {\\r\\n                isClosed = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isRoundExist(\\r\\n        EnumerableSetUpgradeable.AddressSet storage games,\\r\\n        address roundAddress\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            bool isRoundExist_,\\r\\n            uint256 roundIndex,\\r\\n            address gameAddress\\r\\n        )\\r\\n    {\\r\\n        require(roundAddress != address(0), \\\"LPLATFORM: round address is zero\\\");\\r\\n        for (uint256 index = 0; index < games.length(); index++) {\\r\\n            IGame game = IGame(games.at(index));\\r\\n            (isRoundExist_, roundIndex) = game.isRoundExist(roundAddress);\\r\\n\\r\\n            if (isRoundExist_) {\\r\\n                gameAddress = games.at(index);\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/referral/LReferral.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../../interfaces/IPlatform.sol\\\";\\r\\nimport \\\"../../interfaces/IGame.sol\\\";\\r\\n\\r\\nlibrary LReferral {\\r\\n    uint256 public constant category4Points = 25;\\r\\n    uint256 public constant category5Points = 5;\\r\\n\\r\\n    enum ReferralCategories {\\r\\n        FIRST,\\r\\n        SECOND,\\r\\n        THIRD,\\r\\n        FOURTH,\\r\\n        FIFTH\\r\\n    }\\r\\n    enum ReferralRoundStatus {\\r\\n        EMPTY,\\r\\n        PROCESSING,\\r\\n        PAYING,\\r\\n        CLOSED,\\r\\n        REFUNDED\\r\\n    }\\r\\n\\r\\n    function getProcessingRoundsCount() public pure returns (uint8) {\\r\\n        return 0xe;\\r\\n    }\\r\\n\\r\\n    function getCategoriesCount() public pure returns (uint8) {\\r\\n        return 0x5;\\r\\n    }\\r\\n\\r\\n    function getPayLimit() public pure returns (uint16) {\\r\\n        return 0x3E8;\\r\\n    }\\r\\n\\r\\n    function getCalculateUserLimit() public pure returns (uint16) {\\r\\n        return 0x3E8;\\r\\n    }\\r\\n\\r\\n    function getCategoryRequirePoints(ReferralCategories refCategory)\\r\\n        public\\r\\n        pure\\r\\n        returns (uint16 count)\\r\\n    {\\r\\n        return getCategoryUintRequirePoints(uint8(refCategory));\\r\\n    }\\r\\n\\r\\n    function getCategoryUintRequirePoints(uint8 refCategory)\\r\\n        public\\r\\n        pure\\r\\n        returns (uint16 count)\\r\\n    {\\r\\n        if (refCategory == uint8(ReferralCategories.FIRST)) return 0x3e8;\\r\\n        if (refCategory == uint8(ReferralCategories.SECOND)) return 0x1f4;\\r\\n        if (refCategory == uint8(ReferralCategories.THIRD)) return 0x64;\\r\\n        if (refCategory == uint8(ReferralCategories.FOURTH)) return 0x19;\\r\\n        if (refCategory == uint8(ReferralCategories.FIFTH)) return 0x5;\\r\\n    }\\r\\n\\r\\n    function isExistInCategories(\\r\\n        address user,\\r\\n        uint256 points,\\r\\n        uint256 upAmount\\r\\n    ) public pure returns (bool) {\\r\\n        if (user == address(0)) return false;\\r\\n        if (\\r\\n            points < getCategoryRequirePoints(ReferralCategories.FIFTH) &&\\r\\n            points + upAmount >\\r\\n            getCategoryRequirePoints(ReferralCategories.FIFTH) - 1\\r\\n        ) return true;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function isExistInCategories(address user, uint256 points)\\r\\n        public\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        if (user == address(0)) return false;\\r\\n        if (points > getCategoryRequirePoints(ReferralCategories.FIFTH) - 1)\\r\\n            return true;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function getCategoriesCountArray() public pure returns (uint256[] memory) {\\r\\n        uint256[] memory catCounts = new uint256[](getCategoriesCount());\\r\\n\\r\\n        catCounts[0] = getCategoryRequirePoints(ReferralCategories.FIRST);\\r\\n        catCounts[1] = getCategoryRequirePoints(ReferralCategories.SECOND);\\r\\n        catCounts[2] = getCategoryRequirePoints(ReferralCategories.THIRD);\\r\\n        catCounts[3] = getCategoryRequirePoints(ReferralCategories.FOURTH);\\r\\n        catCounts[4] = getCategoryRequirePoints(ReferralCategories.FIFTH);\\r\\n\\r\\n        return catCounts;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/token/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../interfaces/token/IERC20.sol\\\";\\r\\nimport \\\"../../utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\r\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                oldAllowance + value\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(\\r\\n                oldAllowance >= value,\\r\\n                \\\"SafeERC20: decreased allowance below zero\\\"\\r\\n            );\\r\\n            _callOptionalReturn(\\r\\n                token,\\r\\n                abi.encodeWithSelector(\\r\\n                    token.approve.selector,\\r\\n                    spender,\\r\\n                    oldAllowance - value\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\r\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\r\\n     */\\r\\n    function forceApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        bytes memory approvalCall = abi.encodeWithSelector(\\r\\n            token.approve.selector,\\r\\n            spender,\\r\\n            value\\r\\n        );\\r\\n\\r\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\r\\n            _callOptionalReturn(\\r\\n                token,\\r\\n                abi.encodeWithSelector(token.approve.selector, spender, 0)\\r\\n            );\\r\\n            _callOptionalReturn(token, approvalCall);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(\\r\\n            data,\\r\\n            \\\"SafeERC20: low-level call failed\\\"\\r\\n        );\\r\\n        require(\\r\\n            returndata.length == 0 || abi.decode(returndata, (bool)),\\r\\n            \\\"SafeERC20: ERC20 operation did not succeed\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     *\\r\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\r\\n     */\\r\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data)\\r\\n        private\\r\\n        returns (bool)\\r\\n    {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\r\\n        // and not revert is the subcall reverts.\\r\\n\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        return\\r\\n            success &&\\r\\n            (returndata.length == 0 || abi.decode(returndata, (bool))) &&\\r\\n            Address.isContract(address(token));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/utils/array/LArray.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../../../utils/structs/EnumerableSetUpgradeable.sol\\\";\\r\\n\\r\\nlibrary LArray {\\r\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\r\\n\\r\\n    modifier nonZeroResultsPage(uint256 number) {\\r\\n        require(number > 0, \\\"LArray: results per page cant be 0\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getPaginatedArray(\\r\\n        address[] storage array,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (address[] memory cuttedArray) {\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = getPositions(array.length, page, resultsPerPage);\\r\\n        cuttedArray = new address[](elementsCount);\\r\\n\\r\\n        uint256 iterator;\\r\\n        for (uint256 index = startIndex; index < stopIndex + 1; index++) {\\r\\n            cuttedArray[iterator] = array[index];\\r\\n            iterator++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPaginatedArrayReversed(\\r\\n        address[] storage array,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (address[] memory cuttedArray) {\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = getPositionsReversed(array.length, page, resultsPerPage);\\r\\n        cuttedArray = new address[](elementsCount);\\r\\n\\r\\n        uint256 iterator;\\r\\n        uint256 index = startIndex;\\r\\n        while (index >= stopIndex) {\\r\\n            cuttedArray[iterator] = array[index];\\r\\n            iterator++;\\r\\n\\r\\n            if (index == stopIndex) {\\r\\n                break;\\r\\n            }\\r\\n            index--;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPaginatedArray(\\r\\n        uint256[] storage array,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (uint256[] memory cuttedArray) {\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = getPositions(array.length, page, resultsPerPage);\\r\\n        cuttedArray = new uint256[](elementsCount);\\r\\n\\r\\n        uint256 iterator;\\r\\n        for (uint256 index = startIndex; index < stopIndex + 1; index++) {\\r\\n            cuttedArray[iterator] = array[index];\\r\\n            iterator++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPaginatedArray(\\r\\n        EnumerableSetUpgradeable.AddressSet storage set,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (address[] memory cuttedArray) {\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = getPositions(set.length(), page, resultsPerPage);\\r\\n        cuttedArray = new address[](elementsCount);\\r\\n\\r\\n        uint256 iterator;\\r\\n        for (uint256 index = startIndex; index < stopIndex + 1; index++) {\\r\\n            cuttedArray[iterator] = set.at(index);\\r\\n            iterator++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPaginatedArrayReversed(\\r\\n        EnumerableSetUpgradeable.AddressSet storage set,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (address[] memory cuttedArray) {\\r\\n        (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = getPositionsReversed(set.length(), page, resultsPerPage);\\r\\n        cuttedArray = new address[](elementsCount);\\r\\n\\r\\n        uint256 iterator;\\r\\n        uint256 index = startIndex;\\r\\n        while (index >= stopIndex && iterator < elementsCount) {\\r\\n            cuttedArray[iterator] = set.at(index);\\r\\n            iterator++;\\r\\n\\r\\n            if (index == stopIndex) {\\r\\n                break;\\r\\n            }\\r\\n            index--;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPaginatedArrayFromIndex(\\r\\n        EnumerableSetUpgradeable.AddressSet storage set,\\r\\n        uint256 index,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (address[] memory cuttedArray) {\\r\\n        (uint256 stopIndex, uint256 elementsCount) = getPositionsFromIndex(\\r\\n            set.length(),\\r\\n            index,\\r\\n            resultsPerPage\\r\\n        );\\r\\n        cuttedArray = new address[](elementsCount);\\r\\n\\r\\n        uint256 iterator;\\r\\n        for (; index < stopIndex + 1; index++) {\\r\\n            cuttedArray[iterator] = set.at(index);\\r\\n            iterator++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPaginatedArrayFromIndexReversed(\\r\\n        EnumerableSetUpgradeable.AddressSet storage set,\\r\\n        uint256 index,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (address[] memory) {\\r\\n        (\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        ) = getPositionsFromIndexReversed(set.length(), index, resultsPerPage);\\r\\n        address[] memory cuttedArray = new address[](elementsCount);\\r\\n\\r\\n        uint256 iterator;\\r\\n        while (index >= stopIndex && iterator < elementsCount) {\\r\\n            cuttedArray[iterator] = set.at(index);\\r\\n            iterator++;\\r\\n\\r\\n            if (index == stopIndex) {\\r\\n                break;\\r\\n            }\\r\\n            index--;\\r\\n        }\\r\\n\\r\\n        return cuttedArray;\\r\\n    }\\r\\n\\r\\n    function isExistOnPage(\\r\\n        EnumerableSetUpgradeable.AddressSet storage set,\\r\\n        address element,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (bool isExist) {\\r\\n        (uint256 startIndex, uint256 stopIndex, ) = getPositions(\\r\\n            set.length(),\\r\\n            page,\\r\\n            resultsPerPage\\r\\n        );\\r\\n\\r\\n        if (set.contains(element)) {\\r\\n            uint256 index = set.getIndex(element);\\r\\n            if (index > 0 && index - 1 >= startIndex && index - 1 <= stopIndex)\\r\\n                isExist = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isExistOnPage(\\r\\n        address[] storage array,\\r\\n        address element,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (bool isExist) {\\r\\n        (uint256 startIndex, uint256 stopIndex, ) = getPositions(\\r\\n            array.length,\\r\\n            page,\\r\\n            resultsPerPage\\r\\n        );\\r\\n\\r\\n        for (uint256 index = startIndex; index <= stopIndex; index++) {\\r\\n            if (array[index] == element) {\\r\\n                isExist = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPositions(\\r\\n        uint256 size,\\r\\n        uint256 page,\\r\\n        uint16 resultPerPage\\r\\n    )\\r\\n        public\\r\\n        pure\\r\\n        nonZeroResultsPage(resultPerPage)\\r\\n        returns (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        )\\r\\n    {\\r\\n        require(page > 0, \\\"LArray: Invalid page\\\");\\r\\n        uint256 lastIndex = resultPerPage * page - 1;\\r\\n\\r\\n        startIndex = resultPerPage * (page - 1);\\r\\n        if (size > 0) stopIndex = lastIndex > size - 1 ? size - 1 : lastIndex;\\r\\n        else stopIndex = size;\\r\\n        if (size <= resultPerPage) elementsCount = size;\\r\\n        else\\r\\n            elementsCount = lastIndex > size - 1\\r\\n                ? lastIndex - (lastIndex - size) - (resultPerPage * (page - 1))\\r\\n                : resultPerPage;\\r\\n    }\\r\\n\\r\\n    function getPositionsFromIndex(\\r\\n        uint256 size,\\r\\n        uint256 index,\\r\\n        uint16 resultPerPage\\r\\n    )\\r\\n        public\\r\\n        pure\\r\\n        nonZeroResultsPage(resultPerPage)\\r\\n        returns (uint256 stopIndex, uint256 elementsCount)\\r\\n    {\\r\\n        require(index >= 0 && index < size, \\\"LArray: Invalid index\\\");\\r\\n        uint256 lastIndex = resultPerPage + index - 1;\\r\\n\\r\\n        stopIndex = lastIndex > size - 1 ? size - 1 : lastIndex;\\r\\n        if (size <= resultPerPage) elementsCount = size;\\r\\n        else\\r\\n            elementsCount = lastIndex > size - 1\\r\\n                ? lastIndex - (lastIndex - size) - index\\r\\n                : resultPerPage;\\r\\n    }\\r\\n\\r\\n    function getPositionsReversed(\\r\\n        uint256 size,\\r\\n        uint256 page,\\r\\n        uint16 resultPerPage\\r\\n    )\\r\\n        public\\r\\n        pure\\r\\n        nonZeroResultsPage(resultPerPage)\\r\\n        returns (\\r\\n            uint256 startIndex,\\r\\n            uint256 stopIndex,\\r\\n            uint256 elementsCount\\r\\n        )\\r\\n    {\\r\\n        require(page > 0, \\\"LArray: Invalid page\\\");\\r\\n        startIndex = size > 0 ? size - ((page - 1) * resultPerPage) - 1 : 0;\\r\\n        stopIndex = startIndex + 1 > resultPerPage\\r\\n            ? (startIndex + 1) - resultPerPage\\r\\n            : 0;\\r\\n\\r\\n        elementsCount = startIndex >= resultPerPage\\r\\n            ? resultPerPage\\r\\n            : startIndex + 1;\\r\\n        if (size < 1) elementsCount = 0;\\r\\n    }\\r\\n\\r\\n    function getPositionsFromIndexReversed(\\r\\n        uint256 size,\\r\\n        uint256 index,\\r\\n        uint16 resultPerPage\\r\\n    )\\r\\n        public\\r\\n        pure\\r\\n        nonZeroResultsPage(resultPerPage)\\r\\n        returns (uint256 stopIndex, uint256 elementsCount)\\r\\n    {\\r\\n        require(index >= 0 && index < size, \\\"LArray: Invalid index\\\");\\r\\n        uint256 startIndex;\\r\\n        startIndex = index;\\r\\n        stopIndex = startIndex + 1 > resultPerPage\\r\\n            ? (startIndex + 1) - resultPerPage\\r\\n            : 0;\\r\\n\\r\\n        elementsCount = startIndex >= resultPerPage\\r\\n            ? resultPerPage\\r\\n            : startIndex + 1;\\r\\n        if (size < 1) elementsCount = 0;\\r\\n    }\\r\\n\\r\\n    function getPagesByLimit(uint256 size, uint16 limit)\\r\\n        public\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (size < limit) return 1;\\r\\n        if (size % limit == 0) return size / limit;\\r\\n        return size / limit + 1;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/utils/LUtil.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nlibrary LUtil {\\r\\n    enum PlatformStatus {\\r\\n        OPENED,\\r\\n        RUNNING,\\r\\n        CLOSING,\\r\\n        CLOSED\\r\\n    }\\r\\n    enum GameStatus {\\r\\n        OPENED,\\r\\n        RUNNING,\\r\\n        CLOSING,\\r\\n        CLOSED\\r\\n    }\\r\\n    enum RoundStatus {\\r\\n        OPEN,\\r\\n        REFUND,\\r\\n        GENERATING,\\r\\n        PROCESSING,\\r\\n        CALCULATED_WINNERS,\\r\\n        FUNDED,\\r\\n        PAYING,\\r\\n        PAYED,\\r\\n        CLOSED\\r\\n    }\\r\\n    enum WinnerCategory {\\r\\n        JACKPOT,\\r\\n        CATEGORY2,\\r\\n        CATEGORY3,\\r\\n        CATEGORY4,\\r\\n        CATEGORY5\\r\\n    }\\r\\n    enum Wallets {\\r\\n        JACKPOT_WALLET,\\r\\n        CATEGORY2_WALLET,\\r\\n        CATEGORY3_WALLET,\\r\\n        CATEGORY4_WALLET,\\r\\n        CATEGORY5_WALLET,\\r\\n        BOOSTER_WALLET\\r\\n    }\\r\\n    enum Distribution {\\r\\n        REFERRER,\\r\\n        REVENUE,\\r\\n        PLATFORM,\\r\\n        BURN,\\r\\n        BUYBACK,\\r\\n        BUYBACK_RECEIVER,\\r\\n        CATEGORY2_WALLET,\\r\\n        CATEGORY3_WALLET,\\r\\n        CATEGORY4_WALLET,\\r\\n        CATEGORY5_WALLET,\\r\\n        BOOSTER_WALLET,\\r\\n        JACKPOT_WALLET\\r\\n    }\\r\\n\\r\\n    struct PrizeWallet {\\r\\n        string key;\\r\\n        address wallet;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    struct WinnerPay {\\r\\n        address recipient;\\r\\n        uint256 amount;\\r\\n        uint256 ticketsCount;\\r\\n        bool isValid;\\r\\n    }\\r\\n\\r\\n    /// All the needed info around a ticket\\r\\n    struct TicketObject {\\r\\n        uint256 key;\\r\\n        address owner;\\r\\n        uint8[] numbers;\\r\\n        bool isValid;\\r\\n    }\\r\\n\\r\\n    struct DistributionFlags {\\r\\n        bool isBonusAvailable;\\r\\n        bool isBurnAvailable;\\r\\n        bool isBuybackAvailable;\\r\\n        bool isRevenueAvailable;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Round.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./interfaces/IRound.sol\\\";\\r\\nimport \\\"./interfaces/ILottery.sol\\\";\\r\\nimport \\\"./interfaces/IPlatform.sol\\\";\\r\\nimport \\\"./libs/utils/LUtil.sol\\\";\\r\\nimport \\\"./libs/lottery/LLottery.sol\\\";\\r\\nimport \\\"./libs/lottery/round/LRound.sol\\\";\\r\\nimport \\\"./libs/lottery/pool/LPrizePool.sol\\\";\\r\\nimport \\\"./libs/platform/LPlatform.sol\\\";\\r\\nimport \\\"./libs/token/SafeERC20.sol\\\";\\r\\nimport \\\"./utils/structs/EnumerableSet.sol\\\";\\r\\nimport \\\"./security/Pausable.sol\\\";\\r\\nimport \\\"./access/Ownable.sol\\\";\\r\\nimport \\\"./interfaces/access/IAccessControlUpgradeable.sol\\\";\\r\\nimport \\\"./VRFV2WrapperConsumerBase.sol\\\";\\r\\n\\r\\ncontract Round is IRound, VRFV2WrapperConsumerBase, Pausable, Ownable {\\r\\n    uint16 private constant _REQUEST_CONFIRMATIONS = 3;\\r\\n    uint32 private constant _WORDS_NUMBER = 1;\\r\\n\\r\\n    uint256 private _randomResult;\\r\\n    uint256 private _roundPoolAmount;\\r\\n\\r\\n    EnumerableSet.UintSet private _winningNumbers;\\r\\n\\r\\n    LUtil.RoundStatus private _status;\\r\\n    LUtil.PrizeWallet[] private _balances;\\r\\n    LRound.TicketStorage private _ticketStorage;\\r\\n\\r\\n    mapping(address => bool) private _withdrawedUser;\\r\\n\\r\\n    using LRound for LUtil.PrizeWallet[];\\r\\n    using LRound for LRound.TicketStorage;\\r\\n    using LRound for LUtil.RoundStatus;\\r\\n    using EnumerableSet for EnumerableSet.UintSet;\\r\\n    using LRound for EnumerableSet.UintSet;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    event CalculateWinningTickets(\\r\\n        address indexed roundAddress,\\r\\n        uint256 page,\\r\\n        uint256 indexed ticketKey,\\r\\n        address indexed ticketOwner,\\r\\n        uint8[] ticket\\r\\n    );\\r\\n    event PayWinners(\\r\\n        address indexed roundAddress,\\r\\n        uint256 page,\\r\\n        uint256 ticketKey,\\r\\n        LUtil.WinnerCategory indexed category,\\r\\n        address indexed ticketOwner,\\r\\n        uint256 winningAmount,\\r\\n        uint256 ticketsCount\\r\\n    );\\r\\n    event ChangeRoundStatus(\\r\\n        address indexed roundAddress,\\r\\n        LUtil.RoundStatus indexed status\\r\\n    );\\r\\n    event Withdraw(\\r\\n        address indexed roundAddress,\\r\\n        address indexed to,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    modifier onlyRole(bytes32 role) {\\r\\n        require(\\r\\n            IAccessControlUpgradeable(address(_getPlatform())).hasRole(\\r\\n                role,\\r\\n                _msgSender()\\r\\n            ),\\r\\n            \\\"ROUND: permissions denied for msg.sender\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    constructor(address linkTokenAddress, address vrfV2Wrapper)\\r\\n        VRFV2WrapperConsumerBase(\\r\\n            linkTokenAddress, // LINK Token\\r\\n            vrfV2Wrapper // VRF Coordinator\\r\\n        )\\r\\n    {}\\r\\n\\r\\n    function _getEventEmitterAddress()\\r\\n        private\\r\\n        view\\r\\n        returns (address eventEmitterAddress)\\r\\n    {\\r\\n        eventEmitterAddress = _getPlatform().getEventEmitterAddress();\\r\\n    }\\r\\n\\r\\n    function _getLottery() private view returns (ILottery lottery) {\\r\\n        lottery = ILottery(owner());\\r\\n    }\\r\\n\\r\\n    function _getPlatform() private view returns (IPlatform platform) {\\r\\n        platform = IPlatform(_getLottery().getPlatformAddress());\\r\\n    }\\r\\n\\r\\n    function _getToken() private view returns (IERC20 token) {\\r\\n        token = IERC20(_getPlatform().getTokenAddress(owner()));\\r\\n    }\\r\\n\\r\\n    function _getRoundPoolAmount()\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 roundPoolAmount)\\r\\n    {\\r\\n        roundPoolAmount =\\r\\n            _getLottery().getTicketPrice() *\\r\\n            _ticketStorage.getTicketsCount();\\r\\n    }\\r\\n\\r\\n    function _emitChangeStatusEvent() private {\\r\\n        _ticketStorage.emitChangeStatusEvent(\\r\\n            owner(),\\r\\n            address(this),\\r\\n            _getEventEmitterAddress(),\\r\\n            _status\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _lotteryApprovePay(LUtil.Wallets wallet, uint256 amount) private {\\r\\n        _getLottery().approvePay(wallet, amount / 0x186A0);\\r\\n    }\\r\\n\\r\\n    function _statusIfOpened() private view {\\r\\n        _status.isOpen();\\r\\n    }\\r\\n\\r\\n    function _statusIfFunded() private view {\\r\\n        _status.ifFunded();\\r\\n    }\\r\\n\\r\\n    function getTicketsCount() public view returns (uint256) {\\r\\n        return _ticketStorage.getTicketsCount();\\r\\n    }\\r\\n\\r\\n    function getUserTicketsCount() external view returns (uint256) {\\r\\n        return _ticketStorage.getUserTicketsCount(_msgSender());\\r\\n    }\\r\\n\\r\\n    function getUserTickets(uint256 page, uint16 resultsPerPage)\\r\\n        external\\r\\n        view\\r\\n        returns (LUtil.TicketObject[] memory)\\r\\n    {\\r\\n        return\\r\\n            _ticketStorage.getPaginatedUserTickets(\\r\\n                _msgSender(),\\r\\n                page,\\r\\n                resultsPerPage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getCategoryTicketsCount(LUtil.WinnerCategory category)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _ticketStorage.getCategoryTicketsCount(category);\\r\\n    }\\r\\n\\r\\n    function getProcessingLimit() public pure returns (uint256) {\\r\\n        return LRound.getTicketsPerProcessing();\\r\\n    }\\r\\n\\r\\n    function getPayLimit() public pure returns (uint256) {\\r\\n        return LRound.getTicketsPerPay();\\r\\n    }\\r\\n\\r\\n    function getStatus() public view override returns (LUtil.RoundStatus) {\\r\\n        return _status;\\r\\n    }\\r\\n\\r\\n    function getCategoryAmount(LUtil.WinnerCategory category)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        _statusIfFunded();\\r\\n        return _balances[uint8(category)].amount;\\r\\n    }\\r\\n\\r\\n    function getCategoryAmountPerTicket(LUtil.WinnerCategory category)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        _statusIfFunded();\\r\\n        return\\r\\n            _balances.calculateTicketAmount(\\r\\n                category,\\r\\n                _ticketStorage._ticketsPool[uint8(category) + 1].length\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function getRoundPoolAmount() external view override returns (uint256) {\\r\\n        return _roundPoolAmount;\\r\\n    }\\r\\n\\r\\n    function getWinners(\\r\\n        LUtil.WinnerCategory category,\\r\\n        uint256 page,\\r\\n        uint16 resultsPerPage\\r\\n    ) external view returns (LUtil.TicketObject[] memory) {\\r\\n        return\\r\\n            _ticketStorage.getPaginatedWinners(category, page, resultsPerPage);\\r\\n    }\\r\\n\\r\\n    function getTickets(uint256 page, uint16 resultsPerPage)\\r\\n        external\\r\\n        view\\r\\n        returns (LUtil.TicketObject[] memory)\\r\\n    {\\r\\n        return _ticketStorage.getPaginatedTickets(page, resultsPerPage);\\r\\n    }\\r\\n\\r\\n    function getRevenueAmount() external view returns (uint256) {\\r\\n        return\\r\\n            (_roundPoolAmount * LPrizePool.getRevenuePurposePercent()) /\\r\\n            0x186A0;\\r\\n    }\\r\\n\\r\\n    function getWinningNumbers() external view returns (uint256[] memory) {\\r\\n        _status.ifHasWinningNumbers();\\r\\n        return _winningNumbers.values();\\r\\n    }\\r\\n\\r\\n    function getPrizePoolBalances()\\r\\n        external\\r\\n        view\\r\\n        returns (LUtil.PrizeWallet[] memory)\\r\\n    {\\r\\n        _statusIfFunded();\\r\\n        return _balances;\\r\\n    }\\r\\n\\r\\n    function isUserWithdrawed(address user) public view returns (bool) {\\r\\n        return _withdrawedUser[user];\\r\\n    }\\r\\n\\r\\n    function getRandomResult() public view returns (uint256) {\\r\\n        return _randomResult;\\r\\n    }\\r\\n\\r\\n    function withdraw() external {\\r\\n        _status.isRefund();\\r\\n        uint256 userTickets = _ticketStorage.getUserTicketsCount(_msgSender());\\r\\n        require(!isUserWithdrawed(_msgSender()), \\\"ROUND: already withdrawed\\\");\\r\\n        require(userTickets > 0, \\\"ROUND: empty tickets\\\");\\r\\n\\r\\n        _withdrawedUser[_msgSender()] = true;\\r\\n        uint256 withdrawableAmount = (_roundPoolAmount * userTickets) /\\r\\n            _ticketStorage.getTicketsCount();\\r\\n\\r\\n        _getToken().safeTransferFrom(\\r\\n            _getLottery().getWalletAddress(LUtil.Wallets.BOOSTER_WALLET),\\r\\n            _msgSender(),\\r\\n            withdrawableAmount\\r\\n        );\\r\\n\\r\\n        _ticketStorage.emitWithdrawEvent(\\r\\n            owner(),\\r\\n            address(this),\\r\\n            _getEventEmitterAddress(),\\r\\n            _msgSender(),\\r\\n            withdrawableAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setTicket(uint8[] calldata ticket, address ticketOwner)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        _statusIfOpened();\\r\\n\\r\\n        _ticketStorage.setTicket(\\r\\n            ticket,\\r\\n            ticketOwner,\\r\\n            address(this),\\r\\n            _getEventEmitterAddress()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function startProcessing() external payable override onlyOwner {\\r\\n        _statusIfOpened();\\r\\n        _status = LUtil.RoundStatus.GENERATING;\\r\\n\\r\\n        _roundPoolAmount = _getRoundPoolAmount();\\r\\n\\r\\n        _getRandomNumber();\\r\\n        // _setWinningNumbers();\\r\\n        _emitChangeStatusEvent();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev after calculating categories we approving amount of pools to pay\\r\\n     */\\r\\n    function calculateWinnersGroupsPage(uint256 page)\\r\\n        external\\r\\n        onlyRole(LPlatform.adminRole)\\r\\n    {\\r\\n        _status.isProcessing();\\r\\n\\r\\n        bool isProcessed = _ticketStorage.calculateWinnersGroupsPage(\\r\\n            page,\\r\\n            _winningNumbers,\\r\\n            address(this),\\r\\n            _getEventEmitterAddress()\\r\\n        );\\r\\n        if (isProcessed) {\\r\\n            _status = LUtil.RoundStatus.CALCULATED_WINNERS;\\r\\n            _emitChangeStatusEvent();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function fundBalance(LUtil.PrizeWallet[] calldata balances)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        _status.isCalculatedWinners();\\r\\n\\r\\n        for (uint256 index = 0; index < balances.length; index++) {\\r\\n            _balances.push(balances[index]);\\r\\n        }\\r\\n        _ticketStorage.approveWinnersPay(_balances, owner());\\r\\n        _status = LUtil.RoundStatus.FUNDED;\\r\\n\\r\\n        _emitChangeStatusEvent();\\r\\n    }\\r\\n\\r\\n    function payPage(LUtil.WinnerCategory category, uint256 page)\\r\\n        external\\r\\n        override\\r\\n        onlyRole(LPlatform.adminRole)\\r\\n    {\\r\\n        _status.isFundedOrPaying();\\r\\n\\r\\n        _status = LUtil.RoundStatus.PAYING;\\r\\n        _ticketStorage.payPage(\\r\\n            _balances,\\r\\n            category,\\r\\n            page,\\r\\n            owner(),\\r\\n            address(this),\\r\\n            _getEventEmitterAddress()\\r\\n        );\\r\\n\\r\\n        if (_ticketStorage.isPayedPages()) {\\r\\n            _status = LUtil.RoundStatus.PAYED;\\r\\n            _resetPay();\\r\\n            _emitChangeStatusEvent();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function closeRound() external onlyRole(LPlatform.adminRole) {\\r\\n        _status.isPayed();\\r\\n\\r\\n        _status = LUtil.RoundStatus.CLOSED;\\r\\n\\r\\n        _emitChangeStatusEvent();\\r\\n    }\\r\\n\\r\\n    function suspend() external override onlyOwner {\\r\\n        _pause();\\r\\n\\r\\n        uint256 jackpotWalletAmount = _getRoundPoolAmount() *\\r\\n            LPrizePool.getJackpotPercent();\\r\\n        if (\\r\\n            _getToken().balanceOf(\\r\\n                _getLottery().getWalletAddress(LUtil.Wallets.JACKPOT_WALLET)\\r\\n            ) < _getLottery().getJackpotRequireMin()\\r\\n        ) {\\r\\n            jackpotWalletAmount +=\\r\\n                _getRoundPoolAmount() *\\r\\n                (LPrizePool.getBoosterPercent() / 0x2);\\r\\n        }\\r\\n\\r\\n        _lotteryApprovePay(LUtil.Wallets.JACKPOT_WALLET, jackpotWalletAmount);\\r\\n        _lotteryApprovePay(\\r\\n            LUtil.Wallets.CATEGORY2_WALLET,\\r\\n            _getRoundPoolAmount() * LPrizePool.getCategoryTwoPercent()\\r\\n        );\\r\\n        _lotteryApprovePay(\\r\\n            LUtil.Wallets.CATEGORY3_WALLET,\\r\\n            _getRoundPoolAmount() * LPrizePool.getCategoryThreePercent()\\r\\n        );\\r\\n        _lotteryApprovePay(\\r\\n            LUtil.Wallets.CATEGORY4_WALLET,\\r\\n            _getRoundPoolAmount() * LPrizePool.getCategoryFourPercent()\\r\\n        );\\r\\n        _lotteryApprovePay(\\r\\n            LUtil.Wallets.CATEGORY5_WALLET,\\r\\n            _getRoundPoolAmount() * LPrizePool.getCategoryFivePercent()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function resume() external override onlyOwner {\\r\\n        _statusIfOpened();\\r\\n        _unpause();\\r\\n        _resetPay();\\r\\n    }\\r\\n\\r\\n    function refund()\\r\\n        external\\r\\n        override\\r\\n        onlyRole(LPlatform.adminRole)\\r\\n        whenPaused\\r\\n    {\\r\\n        _statusIfOpened();\\r\\n        _status = LUtil.RoundStatus.REFUND;\\r\\n\\r\\n        _roundPoolAmount = _getRoundPoolAmount();\\r\\n        _getLottery().approvePay(\\r\\n            LUtil.Wallets.BOOSTER_WALLET,\\r\\n            _roundPoolAmount\\r\\n        );\\r\\n        _balances.transferToBooster(owner(), _roundPoolAmount);\\r\\n\\r\\n        _emitChangeStatusEvent();\\r\\n    }\\r\\n\\r\\n    // function _setWinningNumbers() private {\\r\\n    //     _winningNumbers.add(2);\\r\\n    //     _winningNumbers.add(5);\\r\\n    //     _winningNumbers.add(8);\\r\\n    //     _winningNumbers.add(9);\\r\\n    //     _winningNumbers.add(25);\\r\\n    //     _winningNumbers.add(44);\\r\\n    //     _status = LUtil.RoundStatus.PROCESSING;\\r\\n    //     _emitChangeStatusEvent();\\r\\n    // }\\r\\n\\r\\n    function _resetPay() private {\\r\\n        ILottery lottery = _getLottery();\\r\\n        lottery.approvePay(LUtil.Wallets.JACKPOT_WALLET, 0);\\r\\n        lottery.approvePay(LUtil.Wallets.CATEGORY2_WALLET, 0);\\r\\n        lottery.approvePay(LUtil.Wallets.CATEGORY3_WALLET, 0);\\r\\n        lottery.approvePay(LUtil.Wallets.CATEGORY4_WALLET, 0);\\r\\n        lottery.approvePay(LUtil.Wallets.CATEGORY5_WALLET, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Callback function used by VRF Coordinator V2\\r\\n     */\\r\\n    function fulfillRandomWords(\\r\\n        uint256 _requestId,\\r\\n        uint256[] memory _randomWords\\r\\n    ) internal override {\\r\\n        _randomResult = _randomWords[_WORDS_NUMBER - 1];\\r\\n        _winningNumbers.calculateRandomNumbers(\\r\\n            _randomResult,\\r\\n            address(this),\\r\\n            _getEventEmitterAddress()\\r\\n        );\\r\\n        _status = LUtil.RoundStatus.PROCESSING;\\r\\n        _emitChangeStatusEvent();\\r\\n    }\\r\\n\\r\\n    function _getRandomNumber() private returns (uint256 requestId) {\\r\\n        requestId = requestRandomness(\\r\\n            _getPlatform().getCallbackGasLimit(),\\r\\n            _REQUEST_CONFIRMATIONS,\\r\\n            _WORDS_NUMBER\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable is Context {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     *\\r\\n     * Furthermore, `isContract` will also return true if the target contract within\\r\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\r\\n     * which only has an effect at the end of a transaction.\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance >= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data)\\r\\n        internal\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                0,\\r\\n                \\\"Address: low-level call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance >= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\r\\n            data\\r\\n        );\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return\\r\\n            functionStaticCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level static call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data)\\r\\n        internal\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return\\r\\n            functionDelegateCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level delegate call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return\\r\\n            verifyCallResultFromTarget(\\r\\n                target,\\r\\n                success,\\r\\n                returndata,\\r\\n                errorMessage\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage)\\r\\n        private\\r\\n        pure\\r\\n    {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Library for managing\\r\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\r\\n * types.\\r\\n *\\r\\n * Sets have the following properties:\\r\\n *\\r\\n * - Elements are added, removed, and checked for existence in constant time\\r\\n * (O(1)).\\r\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\r\\n *\\r\\n * ```\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\r\\n *\\r\\n *     // Declare a set state variable\\r\\n *     EnumerableSet.AddressSet private mySet;\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\r\\n * and `uint256` (`UintSet`) are supported.\\r\\n */\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping(bytes32 => uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) {\\r\\n            // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            if (lastIndex != toDeleteIndex) {\\r\\n                bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n                // Move the last value to the index where the value to delete is\\r\\n                set._values[toDeleteIndex] = lastvalue;\\r\\n                // Update the index for the moved value\\r\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\r\\n            }\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function _at(Set storage set, uint256 index)\\r\\n        private\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\r\\n        return set._values;\\r\\n    }\\r\\n\\r\\n    function _getIndex(Set storage set, bytes32 value)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return set._indexes[value];\\r\\n    }\\r\\n\\r\\n    // Bytes32Set\\r\\n\\r\\n    struct Bytes32Set {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _add(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(Bytes32Set storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return _at(set._inner, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(Bytes32Set storage set)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes32[] memory)\\r\\n    {\\r\\n        return _values(set._inner);\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(AddressSet storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(AddressSet storage set)\\r\\n        internal\\r\\n        view\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        address[] memory result;\\r\\n\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getIndex(AddressSet storage set, address value)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getIndex(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(UintSet storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(UintSet storage set)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        uint256[] memory result;\\r\\n\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Library for managing\\r\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\r\\n * types.\\r\\n *\\r\\n * Sets have the following properties:\\r\\n *\\r\\n * - Elements are added, removed, and checked for existence in constant time\\r\\n * (O(1)).\\r\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\r\\n *\\r\\n * ```\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\r\\n *\\r\\n *     // Declare a set state variable\\r\\n *     EnumerableSet.AddressSet private mySet;\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\r\\n * and `uint256` (`UintSet`) are supported.\\r\\n */\\r\\nlibrary EnumerableSetUpgradeable {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping(bytes32 => uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) {\\r\\n            // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            if (lastIndex != toDeleteIndex) {\\r\\n                bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n                // Move the last value to the index where the value to delete is\\r\\n                set._values[toDeleteIndex] = lastvalue;\\r\\n                // Update the index for the moved value\\r\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\r\\n            }\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function _at(Set storage set, uint256 index)\\r\\n        private\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\r\\n        return set._values;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev custom function to get element index\\r\\n     */\\r\\n    function _getIndex(Set storage set, bytes32 value)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return set._indexes[value];\\r\\n    }\\r\\n\\r\\n    // Bytes32Set\\r\\n\\r\\n    struct Bytes32Set {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _add(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(Bytes32Set storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return _at(set._inner, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(Bytes32Set storage set)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes32[] memory)\\r\\n    {\\r\\n        return _values(set._inner);\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(AddressSet storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(AddressSet storage set)\\r\\n        internal\\r\\n        view\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        address[] memory result;\\r\\n\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getIndex(AddressSet storage set, address value)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getIndex(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(UintSet storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(UintSet storage set)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        uint256[] memory result;\\r\\n\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/VRFV2WrapperConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/token/LinkTokenInterface.sol\\\";\\r\\nimport \\\"./interfaces/VRFV2WrapperInterface.sol\\\";\\r\\n\\r\\n/** *******************************************************************************\\r\\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\\r\\n * ********************************************************************************\\r\\n * @dev PURPOSE\\r\\n *\\r\\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\\r\\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\\r\\n * @dev paying up front rather than at fulfillment.\\r\\n *\\r\\n * @dev Since the price is determined using the gas price of the request transaction rather than\\r\\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\\r\\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\\r\\n * *****************************************************************************\\r\\n * @dev USAGE\\r\\n *\\r\\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\\r\\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\\r\\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\\r\\n * @dev paying for the request based on the current pricing.\\r\\n *\\r\\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\\r\\n * @dev fulfillment with the randomness result.\\r\\n */\\r\\nabstract contract VRFV2WrapperConsumerBase {\\r\\n    // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\\r\\n    LinkTokenInterface internal immutable LINK;\\r\\n    // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\\r\\n    VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\\r\\n\\r\\n    /**\\r\\n     * @param _link is the address of LinkToken\\r\\n     * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\\r\\n     */\\r\\n    constructor(address _link, address _vrfV2Wrapper) {\\r\\n        LINK = LinkTokenInterface(_link);\\r\\n        VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Requests randomness from the VRF V2 wrapper.\\r\\n     *\\r\\n     * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\\r\\n     *        fulfillRandomWords function.\\r\\n     * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\\r\\n     *        request. A higher number of confirmations increases security by reducing the likelihood\\r\\n     *        that a chain re-org changes a published randomness outcome.\\r\\n     * @param _numWords is the number of random words to request.\\r\\n     *\\r\\n     * @return requestId is the VRF V2 request ID of the newly created randomness request.\\r\\n     */\\r\\n    // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\r\\n    function requestRandomness(\\r\\n        uint32 _callbackGasLimit,\\r\\n        uint16 _requestConfirmations,\\r\\n        uint32 _numWords\\r\\n    ) internal returns (uint256 requestId) {\\r\\n        LINK.transferAndCall(\\r\\n            address(VRF_V2_WRAPPER),\\r\\n            VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\\r\\n            abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\\r\\n        );\\r\\n        return VRF_V2_WRAPPER.lastRequestId();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\\r\\n     * @notice implement it.\\r\\n     *\\r\\n     * @param _requestId is the VRF V2 request ID.\\r\\n     * @param _randomWords is the randomness result.\\r\\n     */\\r\\n    // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\r\\n    function fulfillRandomWords(\\r\\n        uint256 _requestId,\\r\\n        uint256[] memory _randomWords\\r\\n    ) internal virtual;\\r\\n\\r\\n    function rawFulfillRandomWords(\\r\\n        uint256 _requestId,\\r\\n        uint256[] memory _randomWords\\r\\n    ) external {\\r\\n        // solhint-disable-next-line custom-errors\\r\\n        require(\\r\\n            msg.sender == address(VRF_V2_WRAPPER),\\r\\n            \\\"only VRF V2 wrapper can fulfill\\\"\\r\\n        );\\r\\n        fulfillRandomWords(_requestId, _randomWords);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Wallet.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity >0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./interfaces/IWallet.sol\\\";\\r\\nimport \\\"./interfaces/IPlatform.sol\\\";\\r\\nimport \\\"./interfaces/ILottery.sol\\\";\\r\\nimport \\\"./interfaces/token/IERC20.sol\\\";\\r\\nimport \\\"./libs/utils/LUtil.sol\\\";\\r\\nimport \\\"./access/Ownable.sol\\\";\\r\\n\\r\\nabstract contract Wallet is IWallet, Ownable {\\r\\n    bytes4 private constant SELECTOR =\\r\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\r\\n\\r\\n    function _safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        (bool success, bytes memory data) = token.call(\\r\\n            abi.encodeWithSelector(SELECTOR, to, value)\\r\\n        );\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\\"TRANSFER_FAILED\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function balance() public view override returns (uint256) {\\r\\n        return IERC20(_getTokenAddress()).balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function transferTo(address recipient, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        _safeTransfer(_getTokenAddress(), recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _getTokenAddress() internal view returns (address) {\\r\\n        address tokenAddress = IPlatform(ILottery(owner()).getPlatformAddress())\\r\\n            .getTokenAddress(owner());\\r\\n        require(tokenAddress != address(0), \\\"Wallet: Invalid token address\\\");\\r\\n        return tokenAddress;\\r\\n    }\\r\\n\\r\\n    function approve(address approver, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        IERC20(_getTokenAddress()).approve(approver, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BoosterWallet is Wallet {\\r\\n    function topUpJackpot(address jackpot, uint256 amount) external onlyOwner {\\r\\n        require(amount > 0, \\\"Amount must be more than 0\\\");\\r\\n        _safeTransfer(_getTokenAddress(), jackpot, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract GameWallet is Wallet {}\\r\\n\\r\\ncontract JackpotWallet is Wallet {}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libs/lottery/pool/LPrizePool.sol\": {\r\n        \"LPrizePool\": \"0x6c5d3adc2600fce86e4566e6ff0a87db47825546\"\r\n      },\r\n      \"contracts/libs/lottery/round/LRound.sol\": {\r\n        \"LRound\": \"0xb1c24acd36be3971a8f7f4f599ff9e097a87cbc1\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vrfV2Wrapper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"roundAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ticketKey\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ticketOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"ticket\",\"type\":\"uint8[]\"}],\"name\":\"CalculateWinningTickets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"roundAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum LUtil.RoundStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"ChangeRoundStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"roundAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketKey\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum LUtil.WinnerCategory\",\"name\":\"category\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ticketOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketsCount\",\"type\":\"uint256\"}],\"name\":\"PayWinners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"roundAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"calculateWinnersGroupsPage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LUtil.PrizeWallet[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"name\":\"fundBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum LUtil.WinnerCategory\",\"name\":\"category\",\"type\":\"uint8\"}],\"name\":\"getCategoryAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum LUtil.WinnerCategory\",\"name\":\"category\",\"type\":\"uint8\"}],\"name\":\"getCategoryAmountPerTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum LUtil.WinnerCategory\",\"name\":\"category\",\"type\":\"uint8\"}],\"name\":\"getCategoryTicketsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPayLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrizePoolBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LUtil.PrizeWallet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProcessingLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRandomResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRevenueAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoundPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"enum LUtil.RoundStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"resultsPerPage\",\"type\":\"uint16\"}],\"name\":\"getTickets\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"numbers\",\"type\":\"uint8[]\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"internalType\":\"struct LUtil.TicketObject[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTicketsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"resultsPerPage\",\"type\":\"uint16\"}],\"name\":\"getUserTickets\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"numbers\",\"type\":\"uint8[]\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"internalType\":\"struct LUtil.TicketObject[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserTicketsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum LUtil.WinnerCategory\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"resultsPerPage\",\"type\":\"uint16\"}],\"name\":\"getWinners\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"numbers\",\"type\":\"uint8[]\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"internalType\":\"struct LUtil.TicketObject[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWinningNumbers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserWithdrawed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum LUtil.WinnerCategory\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"payPage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"ticket\",\"type\":\"uint8[]\"},{\"internalType\":\"address\",\"name\":\"ticketOwner\",\"type\":\"address\"}],\"name\":\"setTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startProcessing\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"suspend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Round", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000404460c6a5ede2d891e8297795264fde62adbb75000000000000000000000000721dfbc5cfe53d32ab00a9bdfa605d3b8e1f3f42", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}