{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.1; \r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ncontract payments {\r\n\r\n    using SafeMath for uint256;\r\n    mapping(string => uint256) percent;\r\n    mapping(address => bool) private admins;\r\n    address public contractOwner = msg.sender; \r\n    mapping(bytes32 => address) public receipts;\r\n    mapping(bytes32 => uint256) public amounts;\r\n    mapping(address => uint256) public balanceOf; \r\n    mapping(string => address) public delegate;\r\n    mapping(string => bytes32) public IDrissHashes;\r\n\r\n    constructor() {\r\n        delegate[\"IDriss\"] = contractOwner;\r\n        percent[\"IDriss\"] = 100;\r\n    }\r\n\r\n    event PaymentDone(address indexed payer, uint256 amount, bytes32 paymentId_hash, string indexed IDrissHash, uint256 date);\r\n    event AdminAdded(address indexed admin);\r\n    event AdminDeleted(address indexed admin);\r\n    event DelegateAdded(string delegateHandle, address indexed delegateAddress);\r\n    event DelegateDeleted(string delegateHandle, address indexed delegateAddress);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function addAdmin(address adminAddress) external {\r\n        require(msg.sender == contractOwner, \"Only contractOwner can add admins.\");\r\n        admins[adminAddress] = true;\r\n        emit AdminAdded(adminAddress);\r\n    }\r\n\r\n    function deleteAdmin(address adminAddress) external {\r\n        require(msg.sender == contractOwner, \"Only contractOwner can delete admins.\");\r\n        admins[adminAddress] = false;\r\n        emit AdminDeleted(adminAddress);\r\n    }\r\n\r\n    function addDelegateException(address delegateAddress, string memory delegateHandle, uint256 percentage) external {\r\n        require(msg.sender == contractOwner, \"Only contractOwner can add special delegate partner.\");\r\n        require(delegate[delegateHandle] == address(0), \"Delegate handle exists.\");\r\n        require(delegateAddress != address(0), \"Ownable: delegateAddress is the zero address.\");\r\n        delegate[delegateHandle] = delegateAddress;\r\n        percent[delegateHandle] = percentage;\r\n        emit DelegateAdded(delegateHandle, delegateAddress);\r\n    }\r\n\r\n    // Anyone can create a delegate link for anyone\r\n    function addDelegate(address delegateAddress, string memory delegateHandle) external {\r\n        require(delegate[delegateHandle] == address(0), \"Delegate handle exists.\");\r\n        require(delegateAddress != address(0), \"Ownable: delegateAddress is the zero address.\");\r\n        delegate[delegateHandle] = delegateAddress;\r\n        percent[delegateHandle] = 20;\r\n        emit DelegateAdded(delegateHandle, delegateAddress);\r\n    }\r\n\r\n    // Delete the delegation link if needed.\r\n    function deleteDelegate(string memory delegateHandle) external {\r\n        require(msg.sender == delegate[delegateHandle], \"Only delegate can delete delegation link.\");\r\n        address deletedDelegate = delegate[delegateHandle];\r\n        delete delegate[delegateHandle];\r\n        delete percent[delegateHandle];\r\n        emit DelegateDeleted(delegateHandle, deletedDelegate);\r\n    }\r\n\r\n    // Payment function distributing the payment into two balances.\r\n    function payNative(bytes32 paymentId_hash, string memory IDrissHash, string memory delegateHandle) external payable {\r\n        require(receipts[paymentId_hash] == address(0), \"Already paid this receipt.\");\r\n        receipts[paymentId_hash] = msg.sender;\r\n        amounts[paymentId_hash] = msg.value;\r\n        IDrissHashes[IDrissHash] = paymentId_hash;\r\n        if (delegate[delegateHandle] != address(0)) {\r\n            balanceOf[contractOwner] += msg.value.sub((msg.value.mul(percent[delegateHandle])).div(100));\r\n            balanceOf[delegate[delegateHandle]] += (msg.value.mul(percent[delegateHandle])).div(100);\r\n        } else {\r\n            balanceOf[contractOwner] += msg.value;\r\n        }\r\n        emit PaymentDone(receipts[paymentId_hash], amounts[paymentId_hash], paymentId_hash, IDrissHash, block.timestamp);\r\n    }\r\n\r\n    // Anyone can withraw funds to any participating delegate\r\n    function withdraw(uint256 amount, string memory delegateHandle) external returns (bytes memory) {\r\n        require(amount <= balanceOf[delegate[delegateHandle]]);\r\n        balanceOf[delegate[delegateHandle]] -= amount;\r\n        (bool sent, bytes memory data) = delegate[delegateHandle].call{value: amount, gas: 40000}(\"\");\r\n        require(sent, \"Failed to  withdraw\");\r\n        return data;\r\n    }\r\n\r\n    // commit payment hash creation\r\n    function hashReceipt(string memory receiptId, address paymAddr) public pure returns (bytes32) {\r\n        require(paymAddr != address(0), \"Payment address cannot be null address.\");\r\n        return keccak256(abi.encode(receiptId, paymAddr));\r\n    }\r\n\r\n    // reveal payment hash\r\n    function verifyReceipt(string memory receiptId, address paymAddr) public view returns (bool) {\r\n        require(paymAddr != address(0), \"Payment address cannot be null address.\");\r\n        require(receipts[hashReceipt(receiptId, paymAddr)] == paymAddr);\r\n        return true;\r\n    }\r\n\r\n    // Transfer contract ownership\r\n    function transferContractOwnership(address newOwner) public payable {\r\n        require(msg.sender == contractOwner, \"Only contractOwner can change ownership of contract.\");\r\n        require(newOwner != address(0), \"Ownable: new contractOwner is the zero address.\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    // Helper function\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = contractOwner;\r\n        // transfer balance of old owner to new owner\r\n        uint256 ownerAmount = balanceOf[oldOwner];\r\n        // delete balance of old owner\r\n        balanceOf[oldOwner] = 0;\r\n        contractOwner = newOwner;\r\n        // set new owner\r\n        delegate[\"IDriss\"] = newOwner;\r\n        // set balance of new owner\r\n        balanceOf[newOwner] = ownerAmount;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"delegateHandle\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateAddress\",\"type\":\"address\"}],\"name\":\"DelegateAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"delegateHandle\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateAddress\",\"type\":\"address\"}],\"name\":\"DelegateDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"paymentId_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"IDrissHash\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"PaymentDone\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"IDrissHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegateAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"delegateHandle\",\"type\":\"string\"}],\"name\":\"addDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegateAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"delegateHandle\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"addDelegateException\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"amounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"delegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"deleteAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"delegateHandle\",\"type\":\"string\"}],\"name\":\"deleteDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"receiptId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"paymAddr\",\"type\":\"address\"}],\"name\":\"hashReceipt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId_hash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"IDrissHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"delegateHandle\",\"type\":\"string\"}],\"name\":\"payNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"receipts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferContractOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"receiptId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"paymAddr\",\"type\":\"address\"}],\"name\":\"verifyReceipt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"delegateHandle\",\"type\":\"string\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "payments", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5a372bf14748525310b69d4d3fda3fb9f16733b263ac75315a3508d0328d60fc"}