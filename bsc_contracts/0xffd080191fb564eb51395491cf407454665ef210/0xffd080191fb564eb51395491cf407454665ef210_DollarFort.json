{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract DollarFort {\r\n    IERC20 public _usdtToken;\r\n    uint256 minInvestment = sqn(100);\r\n    address _system;\r\n    uint256[] public rewards = [3000, 9000, 27000, 81000, 243000, 729000];\r\n    uint256 rewardPercentage = 10; // 10% of the achieved business volume\r\n    uint256 roiIterations = 365; // for 1 year until 180% for non working & 3x for working ids\r\n    uint256 roiPercentage = 5; // 0.5% daily\r\n    uint256 directLevelOpenedPerReferral = 1;\r\n    uint256 generationLevelOpenedPerReferral = 3;\r\n    uint256[] directIncomePercentages = [15, 5, 5, 5, 5, 5, 5, 5, 5, 5]; // 1.5% for 1st level & 0.5% for 2nd to 10th level\r\n\r\n    // Level 1 to 10 = 3%; Level 11 to 20 = 6%; Level 21 to 30 = 9%;\r\n    uint256[] generationIncomePercentages = [\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        30,\r\n        60,\r\n        60,\r\n        60,\r\n        60,\r\n        60,\r\n        60,\r\n        60,\r\n        60,\r\n        60,\r\n        60,\r\n        90,\r\n        90,\r\n        90,\r\n        90,\r\n        90,\r\n        90,\r\n        90,\r\n        90,\r\n        90,\r\n        90\r\n    ];\r\n\r\n    address[] public usersList;\r\n    address tenPercentOfInvestmentAddress;\r\n    address sixPercentOfWithdrawalAddress;\r\n\r\n    enum ZeroPinMode {\r\n        NONE,\r\n        RETOPUP_REQUIRED,\r\n        FULL\r\n    }\r\n\r\n    event UserRegistered(\r\n        address indexed user,\r\n        address indexed sponsor,\r\n        uint256 investment,\r\n        uint256 timestamp\r\n    );\r\n\r\n    struct IncomeTransaction {\r\n        address relatedUser;\r\n        uint256 relatedInvestmentId;\r\n        string class;\r\n        uint256 amount;\r\n        string description;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct UserInvestment {\r\n        uint256 id;\r\n        uint256 amount;\r\n        uint256 iterationsLeft;\r\n        uint256 timestamp;\r\n        uint256 endedTimestamp;\r\n        bool hasEnded;\r\n        bool isZeroPin;\r\n    }\r\n\r\n    struct UserWithdrawal {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct AchievedReward {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct User {\r\n        address addr;\r\n        address sponsor;\r\n        uint256 rewardCarryForwardAmount;\r\n        uint256 balance;\r\n        uint registrationTimestamp;\r\n        address[] referrals;\r\n        uint256 directLevelsOpened;\r\n        uint256 generationLevelsOpened;\r\n        bool isActive;\r\n        ZeroPinMode zeroPinType;\r\n    }\r\n\r\n    struct AdminTransactions {\r\n        address user;\r\n        uint256 amount;\r\n        string desc;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    AdminTransactions[] public adminTransactions;\r\n\r\n    uint256 _investmentIndex = 1;\r\n\r\n    mapping(address => User) public users;\r\n    mapping(address => IncomeTransaction[]) public incomeTransactions;\r\n    mapping(address => UserInvestment[]) public userInvestments;\r\n    mapping(address => UserWithdrawal[]) public userWithdrawals;\r\n    mapping(address => AchievedReward[]) public achievedRewards;\r\n\r\n    constructor(\r\n        address usdtAddress,\r\n        address _tenPercentOfInvestmentAddress,\r\n        address _sixPercentOfWithdrawalAddress\r\n    ) {\r\n        _system = msg.sender;\r\n        _usdtToken = IERC20(usdtAddress);\r\n        tenPercentOfInvestmentAddress = _tenPercentOfInvestmentAddress;\r\n        sixPercentOfWithdrawalAddress = _sixPercentOfWithdrawalAddress;\r\n\r\n        uint256 _systemInvestment = sqn(1000);\r\n        users[_system] = User({\r\n            addr: _system,\r\n            sponsor: address(0),\r\n            rewardCarryForwardAmount: 0,\r\n            balance: 0,\r\n            referrals: new address[](0),\r\n            registrationTimestamp: block.timestamp,\r\n            directLevelsOpened: 10,\r\n            generationLevelsOpened: 30,\r\n            isActive: true,\r\n            zeroPinType: ZeroPinMode.FULL\r\n        });\r\n        usersList.push(_system);\r\n        userInvestments[_system].push(\r\n            UserInvestment({\r\n                id: _investmentIndex++,\r\n                amount: _systemInvestment,\r\n                timestamp: block.timestamp,\r\n                endedTimestamp: 0,\r\n                iterationsLeft: roiIterations,\r\n                hasEnded: false,\r\n                isZeroPin: true\r\n            })\r\n        );\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender == _system, \"Only system can call this function\");\r\n        _;\r\n    }\r\n\r\n    function sqn(uint256 _n) public pure returns (uint256) {\r\n        return _n * 10 ** 18;\r\n    }\r\n\r\n    function nqs(uint256 _n) public pure returns (uint256) {\r\n        return _n / 10 ** 18;\r\n    }\r\n\r\n    function _getAdminTransactions()\r\n        public\r\n        view\r\n        onlySystem\r\n        returns (AdminTransactions[] memory)\r\n    {\r\n        return adminTransactions;\r\n    }\r\n\r\n    function _getUsersDetails(\r\n        address _addr\r\n    ) external view returns (User memory) {\r\n        return users[_addr];\r\n    }\r\n\r\n    function _getUsersList() external view returns (address[] memory) {\r\n        return usersList;\r\n    }\r\n\r\n    function _getUserIncomeTransactions(\r\n        address _address\r\n    ) external view returns (IncomeTransaction[] memory) {\r\n        return incomeTransactions[_address];\r\n    }\r\n\r\n    function _getUserInvestments(\r\n        address _address\r\n    ) external view returns (UserInvestment[] memory) {\r\n        return userInvestments[_address];\r\n    }\r\n\r\n    function _getUserWithdrawals(\r\n        address _address\r\n    ) external view returns (UserWithdrawal[] memory) {\r\n        return userWithdrawals[_address];\r\n    }\r\n\r\n    function _getAchievedRewards(\r\n        address _address\r\n    ) external view returns (AchievedReward[] memory) {\r\n        return achievedRewards[_address];\r\n    }\r\n\r\n    function _getUserReferralCount(\r\n        address _address\r\n    ) external view returns (uint256) {\r\n        uint256 _count = 0;\r\n        User memory _user = users[_address];\r\n\r\n        for (uint256 i = 0; i < _user.referrals.length; i++) {\r\n            if (users[_user.referrals[i]].zeroPinType == ZeroPinMode.NONE) {\r\n                _count++;\r\n            }\r\n        }\r\n\r\n        return _count;\r\n    }\r\n\r\n    function userExists(address _address) public view returns (bool) {\r\n        return users[_address].addr != address(0);\r\n    }\r\n\r\n    function _getUserOldestInvestmentWhichHasNotEnded(\r\n        address _addr\r\n    ) public view returns (UserInvestment memory) {\r\n        UserInvestment[] memory investments = userInvestments[_addr];\r\n        UserInvestment memory _oldestInvestment;\r\n        for (uint256 i = 0; i < investments.length; i++) {\r\n            if (investments[i].hasEnded) {\r\n                continue;\r\n            }\r\n\r\n            if (_oldestInvestment.timestamp == 0) {\r\n                _oldestInvestment = investments[i];\r\n            } else {\r\n                if (investments[i].timestamp < _oldestInvestment.timestamp) {\r\n                    _oldestInvestment = investments[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        return _oldestInvestment;\r\n    }\r\n\r\n    function _getUserTotalActiveInvestmentAmount(\r\n        address _addr\r\n    ) public view returns (uint256) {\r\n        UserInvestment[] memory investments = userInvestments[_addr];\r\n        uint256 _totalActiveInvestmentAmount = 0;\r\n        for (uint256 i = 0; i < investments.length; i++) {\r\n            if (investments[i].hasEnded || investments[i].isZeroPin) {\r\n                continue;\r\n            }\r\n\r\n            _totalActiveInvestmentAmount += investments[i].amount;\r\n        }\r\n\r\n        return _totalActiveInvestmentAmount;\r\n    }\r\n\r\n    function _getUserActiveInvestments(\r\n        address _addr\r\n    ) public view returns (UserInvestment[] memory) {\r\n        UserInvestment[] memory investments = userInvestments[_addr];\r\n        UserInvestment[] memory _activeInvestments = new UserInvestment[](\r\n            investments.length\r\n        );\r\n        uint256 _index = 0;\r\n\r\n        for (uint256 i = 0; i < investments.length; i++) {\r\n            if (investments[i].hasEnded) {\r\n                continue;\r\n            }\r\n\r\n            _activeInvestments[_index] = investments[i];\r\n            _index++;\r\n        }\r\n\r\n        return _activeInvestments;\r\n    }\r\n\r\n    function hasAchievedMaxIncome(User memory user) public view returns (bool) {\r\n        uint256 maxRoiPercentage = user.referrals.length == 0 ? 1825 : 3000;\r\n        uint256 _totalInvestment = _getUserTotalActiveInvestmentAmount(\r\n            user.addr\r\n        );\r\n        uint256 _maxIncome = (_totalInvestment * maxRoiPercentage) / 1000;\r\n\r\n        if (user.zeroPinType == ZeroPinMode.RETOPUP_REQUIRED) {\r\n            _maxIncome = 300 * 10 ** 18;\r\n        }\r\n\r\n        if (user.zeroPinType == ZeroPinMode.FULL) {\r\n            _maxIncome = 10000000000000 * 10 ** 18;\r\n        }\r\n\r\n        uint256 _totalIncome = 0;\r\n\r\n        UserInvestment\r\n            memory oldestActiveInvestment = _getUserOldestInvestmentWhichHasNotEnded(\r\n                user.addr\r\n            );\r\n\r\n        for (uint256 i = 0; i < incomeTransactions[user.addr].length; i++) {\r\n            if (\r\n                incomeTransactions[user.addr][i].timestamp <\r\n                oldestActiveInvestment.timestamp\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            _totalIncome += incomeTransactions[user.addr][i].amount;\r\n        }\r\n\r\n        return _totalIncome >= _maxIncome;\r\n    }\r\n\r\n    function disableUsersWhoNeedRetopup() public onlySystem {\r\n        for (uint256 i = 0; i < usersList.length; i++) {\r\n            User storage _user = users[usersList[i]];\r\n\r\n            if (_user.zeroPinType == ZeroPinMode.FULL) {\r\n                continue;\r\n            }\r\n\r\n            if (_user.isActive && (hasAchievedMaxIncome(_user))) {\r\n                _user.isActive = false;\r\n\r\n                for (\r\n                    uint256 j = 0;\r\n                    j < userInvestments[_user.addr].length;\r\n                    j++\r\n                ) {\r\n                    if (userInvestments[_user.addr][j].hasEnded) {\r\n                        continue;\r\n                    }\r\n\r\n                    userInvestments[_user.addr][j].hasEnded = true;\r\n                    userInvestments[_user.addr][j].endedTimestamp = block\r\n                        .timestamp;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getUserLatestActiveInvestment(\r\n        address _addr\r\n    ) public view returns (UserInvestment memory) {\r\n        UserInvestment[] memory investments = userInvestments[_addr];\r\n\r\n        return investments[investments.length - 1];\r\n    }\r\n\r\n    function userHasBeenRegisteredForLessThan24Hours(\r\n        address _addr,\r\n        uint256 _predefined\r\n    ) public view returns (bool) {\r\n        if (_predefined == 0) {\r\n            return\r\n                block.timestamp -\r\n                    _getUserLatestActiveInvestment(_addr).timestamp <\r\n                86400;\r\n        } else if (_predefined == 1) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function distributeDividend(uint256 _predefined) external onlySystem {\r\n        // remember, each user first, then their upline generation\r\n        for (uint256 i = 0; i < usersList.length; i++) {\r\n            User storage _user = users[usersList[i]];\r\n\r\n            if (\r\n                !_user.isActive ||\r\n                userHasBeenRegisteredForLessThan24Hours(_user.addr, _predefined)\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            for (uint256 j = 0; j < userInvestments[_user.addr].length; j++) {\r\n                if (\r\n                    userInvestments[_user.addr][j].hasEnded ||\r\n                    userInvestments[_user.addr][j].iterationsLeft == 0\r\n                ) {\r\n                    continue;\r\n                }\r\n\r\n                uint256 _dividendX = ((userInvestments[_user.addr][j].amount *\r\n                    (roiPercentage)) / 1000);\r\n\r\n                uint256 _dividendForThisInvestment = 0;\r\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\r\n                    _user.addr\r\n                ) * (_user.referrals.length > 0 ? 3000 : 1825)) / 1000;\r\n\r\n                if (_user.zeroPinType == ZeroPinMode.RETOPUP_REQUIRED) {\r\n                    _maxIncome = 300 * 10 ** 18;\r\n                }\r\n\r\n                if (_user.zeroPinType == ZeroPinMode.FULL) {\r\n                    _maxIncome = 10000000000000 * 10 ** 18;\r\n                }\r\n\r\n                if (_dividendX > (_maxIncome - _user.balance)) {\r\n                    _dividendForThisInvestment = _maxIncome - _user.balance;\r\n                } else {\r\n                    _dividendForThisInvestment = _dividendX;\r\n                }\r\n\r\n                if (!userInvestments[_user.addr][j].isZeroPin) {\r\n                    userInvestments[_user.addr][j].iterationsLeft -= 1;\r\n                    userInvestments[_user.addr][j].hasEnded =\r\n                        userInvestments[_user.addr][j].iterationsLeft == 0;\r\n\r\n                    if (userInvestments[_user.addr][j].hasEnded) {\r\n                        userInvestments[_user.addr][j].endedTimestamp = block\r\n                            .timestamp;\r\n                    }\r\n\r\n                    incomeTransactions[usersList[i]].push(\r\n                        IncomeTransaction({\r\n                            relatedUser: address(0),\r\n                            relatedInvestmentId: userInvestments[_user.addr][j]\r\n                                .id,\r\n                            class: \"self_roi\",\r\n                            amount: _dividendForThisInvestment,\r\n                            description: \"Daily Dividend\",\r\n                            timestamp: block.timestamp\r\n                        })\r\n                    );\r\n\r\n                    _user.balance += _dividendForThisInvestment;\r\n\r\n                    distributeGenerationIncome(\r\n                        usersList[i],\r\n                        userInvestments[_user.addr][j].id,\r\n                        _dividendForThisInvestment,\r\n                        _predefined\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function distributeGenerationIncome(\r\n        address _currentUser,\r\n        uint256 _investmentId,\r\n        uint256 _dividend,\r\n        uint256 _predefined\r\n    ) internal onlySystem {\r\n        address _sponsorAddress = users[_currentUser].sponsor;\r\n        for (uint256 i = 0; i < generationIncomePercentages.length; i++) {\r\n            User storage _sponsorUser = users[_sponsorAddress];\r\n\r\n            if (\r\n                _sponsorUser.generationLevelsOpened > i &&\r\n                _sponsorUser.isActive &&\r\n                !userHasBeenRegisteredForLessThan24Hours(\r\n                    _sponsorUser.addr,\r\n                    _predefined\r\n                )\r\n            ) {\r\n                // if (_sponsorUser.zeroPinType == ZeroPinMode.RETOPUP_REQUIRED) {\r\n                //     _sponsorAddress = users[_sponsorAddress].sponsor;\r\n                //     continue;\r\n                // }\r\n\r\n                uint256 _generationIncomeX = (_dividend *\r\n                    generationIncomePercentages[i]) / 1000;\r\n\r\n                uint256 _generationIncome = 0;\r\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\r\n                    _sponsorUser.addr\r\n                ) * (_sponsorUser.referrals.length > 0 ? 3000 : 1825)) / 1000;\r\n\r\n                if (_sponsorUser.zeroPinType == ZeroPinMode.RETOPUP_REQUIRED) {\r\n                    _maxIncome = 300 * 10 ** 18;\r\n                }\r\n\r\n                if (_sponsorUser.zeroPinType == ZeroPinMode.FULL) {\r\n                    _maxIncome = 10000000000000 * 10 ** 18;\r\n                }\r\n\r\n                if (_generationIncomeX > (_maxIncome - _sponsorUser.balance)) {\r\n                    _generationIncome = _maxIncome - _sponsorUser.balance;\r\n                } else {\r\n                    _generationIncome = _generationIncomeX;\r\n                }\r\n\r\n                _sponsorUser.balance += _generationIncome;\r\n                incomeTransactions[_sponsorUser.addr].push(\r\n                    IncomeTransaction({\r\n                        relatedInvestmentId: _investmentId,\r\n                        class: \"generation_roi\",\r\n                        relatedUser: _currentUser,\r\n                        amount: _generationIncome,\r\n                        description: \"Generation Income\",\r\n                        timestamp: block.timestamp\r\n                    })\r\n                );\r\n            }\r\n\r\n            _sponsorAddress = users[_sponsorAddress].sponsor;\r\n\r\n            if (_sponsorAddress == address(0)) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getUserTotalBusiness(\r\n        address _address\r\n    ) public view returns (uint256) {\r\n        uint256 _business = 0;\r\n        address[] memory stack = new address[](\r\n            users[_address].referrals.length\r\n        );\r\n        uint256 stackSize = users[_address].referrals.length;\r\n\r\n        for (uint256 i = 0; i < stackSize; i++) {\r\n            if (i < stackSize) {\r\n                stack[i] = users[_address].referrals[i];\r\n            }\r\n        }\r\n\r\n        while (stackSize > 0) {\r\n            address currentAddress = stack[stackSize - 1];\r\n            stackSize--;\r\n\r\n            User memory _referral = users[currentAddress];\r\n            _business += _getUserTotalActiveInvestmentAmount(_referral.addr);\r\n\r\n            for (uint256 i = 0; i < _referral.referrals.length; i++) {\r\n                if (stackSize < stack.length) {\r\n                    stack[stackSize] = _referral.referrals[i];\r\n                    stackSize++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return _business;\r\n    }\r\n\r\n    function _getLegBusiness(address _address) public view returns (uint256) {\r\n        User memory user = users[_address];\r\n\r\n        uint256 _business = _getUserTotalBusiness(_address);\r\n\r\n        return _business + _getUserTotalActiveInvestmentAmount(user.addr);\r\n    }\r\n\r\n    function checkForReward(address _user) public onlySystem {\r\n        User storage _currentUser = users[_user];\r\n\r\n        if (!_currentUser.isActive) {\r\n            return;\r\n        }\r\n\r\n        for (uint256 i = 0; i < rewards.length; i++) {\r\n            uint256 rewardAmount = sqn(rewards[i]);\r\n            bool hasAchievedReward = false;\r\n\r\n            for (uint256 j = 0; j < achievedRewards[_user].length; j++) {\r\n                if (achievedRewards[_user][j].amount == rewardAmount) {\r\n                    hasAchievedReward = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (hasAchievedReward) {\r\n                continue;\r\n            }\r\n\r\n            uint256 _maxBusinessFromEachLeg = (30 * rewardAmount) / 100;\r\n            uint256 _totalBusiness = 0;\r\n            uint256 _totalPendingBusiness = 0;\r\n\r\n            for (uint256 j = 0; j < _currentUser.referrals.length; j++) {\r\n                User memory _referral = users[_currentUser.referrals[j]];\r\n                uint256 _referralBusiness = _getLegBusiness(_referral.addr);\r\n                if (_referralBusiness > _maxBusinessFromEachLeg) {\r\n                    _totalBusiness += _maxBusinessFromEachLeg;\r\n                    uint256 _pendingBusiness = _referralBusiness -\r\n                        _maxBusinessFromEachLeg;\r\n                    _totalPendingBusiness += _pendingBusiness > 0\r\n                        ? _pendingBusiness\r\n                        : 0;\r\n                } else {\r\n                    _totalBusiness += _referralBusiness;\r\n                }\r\n            }\r\n\r\n            uint256 _usedRewardCarryForwardAmount = 0;\r\n\r\n            if (_totalBusiness < rewardAmount) {\r\n                _usedRewardCarryForwardAmount = rewardAmount - _totalBusiness;\r\n\r\n                if (\r\n                    _currentUser.rewardCarryForwardAmount >=\r\n                    _usedRewardCarryForwardAmount\r\n                ) {\r\n                    _currentUser\r\n                        .rewardCarryForwardAmount -= _usedRewardCarryForwardAmount;\r\n                    _totalBusiness += _usedRewardCarryForwardAmount;\r\n                }\r\n            }\r\n\r\n            if (_totalBusiness >= rewardAmount) {\r\n                achievedRewards[_user].push(\r\n                    AchievedReward({\r\n                        amount: rewardAmount,\r\n                        timestamp: block.timestamp\r\n                    })\r\n                );\r\n\r\n                uint256 _reward = rewardAmount * (rewardPercentage / 100);\r\n\r\n                _currentUser.rewardCarryForwardAmount += _totalPendingBusiness;\r\n\r\n                adminTransactions.push(\r\n                    AdminTransactions({\r\n                        user: _user,\r\n                        amount: nqs(_reward),\r\n                        desc: \"Reward\",\r\n                        timestamp: block.timestamp\r\n                    })\r\n                );\r\n                _usdtToken.transfer(_currentUser.addr, (_reward));\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        // _amount = _amount / 10**18;\r\n        User storage _user = users[msg.sender];\r\n\r\n        require(_user.isActive, \"User is inactive\");\r\n        require(_amount > 0, \"Invalid amount\");\r\n        require(_amount >= sqn(12), \"Min withdrawal limit is $12\");\r\n        require(_amount <= sqn(600), \"Max withdrawal limit is $600\");\r\n        require(_amount <= users[msg.sender].balance, \"Insufficient balance\");\r\n\r\n        uint256 withdrawalAmountInLast24Hours = 0;\r\n\r\n        if (userWithdrawals[_user.addr].length > 0) {\r\n            for (uint256 i = 0; i < userWithdrawals[msg.sender].length; i++) {\r\n                if (\r\n                    userWithdrawals[msg.sender][i].timestamp >=\r\n                    block.timestamp - 86400\r\n                ) {\r\n                    withdrawalAmountInLast24Hours += userWithdrawals[\r\n                        msg.sender\r\n                    ][i].amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        require(\r\n            withdrawalAmountInLast24Hours + _amount <= sqn(600),\r\n            \"Max withdrawal limit is $600 in 24 hrs\"\r\n        );\r\n\r\n        uint256 _deduction = (_amount * 6) / 100;\r\n        uint256 _finalAmount = _amount - _deduction;\r\n\r\n        userWithdrawals[_user.addr].push(\r\n            UserWithdrawal({amount: _amount, timestamp: block.timestamp})\r\n        );\r\n\r\n        _user.balance -= _amount;\r\n\r\n        // transfer 6% to admin\r\n\r\n        _usdtToken.transfer(_user.addr, (_finalAmount));\r\n        _usdtToken.transfer(sixPercentOfWithdrawalAddress, (_deduction));\r\n\r\n        adminTransactions.push(\r\n            AdminTransactions({\r\n                user: _user.addr,\r\n                amount: nqs(_finalAmount),\r\n                desc: \"Withdrawal\",\r\n                timestamp: block.timestamp\r\n            })\r\n        );\r\n\r\n        adminTransactions.push(\r\n            AdminTransactions({\r\n                user: _user.addr,\r\n                amount: nqs(_deduction),\r\n                desc: \"Withdrawal Deduction\",\r\n                timestamp: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function retopup(uint256 _investment) external {\r\n        address _userAddress = msg.sender;\r\n        require(userExists(_userAddress), \"User does not exist\");\r\n        require(_investment >= minInvestment, \"Invalid investment amount\");\r\n\r\n        require(\r\n            _usdtToken.transferFrom(msg.sender, address(this), (_investment)),\r\n            \"Transfer failed\"\r\n        );\r\n\r\n        User storage _user = users[msg.sender];\r\n\r\n        userInvestments[_userAddress].push(\r\n            UserInvestment({\r\n                id: _investmentIndex++,\r\n                iterationsLeft: roiIterations,\r\n                amount: _investment,\r\n                endedTimestamp: 0,\r\n                timestamp: block.timestamp,\r\n                hasEnded: false,\r\n                isZeroPin: false\r\n            })\r\n        );\r\n        _user.isActive = true;\r\n\r\n        address _sponsorAddress = _user.sponsor;\r\n\r\n        for (uint256 i = 0; i < directIncomePercentages.length; i++) {\r\n            User storage _currentSponsorUser = users[_sponsorAddress];\r\n            uint256 _directIncomeX = (_investment *\r\n                directIncomePercentages[i]) / 1000;\r\n\r\n            if (\r\n                _currentSponsorUser.directLevelsOpened > i &&\r\n                _currentSponsorUser.isActive\r\n            ) {\r\n                uint256 _directIncome = 0;\r\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\r\n                    _currentSponsorUser.addr\r\n                ) * (_currentSponsorUser.referrals.length > 0 ? 3000 : 1825)) /\r\n                    1000;\r\n\r\n                if (\r\n                    _currentSponsorUser.zeroPinType ==\r\n                    ZeroPinMode.RETOPUP_REQUIRED\r\n                ) {\r\n                    _maxIncome = 300 * 10 ** 18;\r\n                }\r\n\r\n                if (_currentSponsorUser.zeroPinType == ZeroPinMode.FULL) {\r\n                    _maxIncome = 10000000000000 * 10 ** 18;\r\n                }\r\n\r\n                if (\r\n                    _directIncomeX > (_maxIncome - _currentSponsorUser.balance)\r\n                ) {\r\n                    _directIncome = _maxIncome - _currentSponsorUser.balance;\r\n                } else {\r\n                    _directIncome = _directIncomeX;\r\n                }\r\n                _currentSponsorUser.balance += _directIncome;\r\n                incomeTransactions[_currentSponsorUser.addr].push(\r\n                    IncomeTransaction({\r\n                        relatedInvestmentId: 0,\r\n                        class: \"direct_income\",\r\n                        relatedUser: msg.sender,\r\n                        amount: _directIncome,\r\n                        description: \"Direct Income\",\r\n                        timestamp: block.timestamp\r\n                    })\r\n                );\r\n            }\r\n\r\n            _sponsorAddress = _currentSponsorUser.sponsor;\r\n\r\n            if (_sponsorAddress == address(0)) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 adminAmount = ((10 * (_investment)) / 100);\r\n        _usdtToken.transfer(tenPercentOfInvestmentAddress, adminAmount);\r\n\r\n        adminTransactions.push(\r\n            AdminTransactions({\r\n                user: _user.addr,\r\n                amount: adminAmount,\r\n                desc: \"Reward\",\r\n                timestamp: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function upgrade(uint256 _investment) external {\r\n        address _userAddress = msg.sender;\r\n        require(userExists(_userAddress), \"User does not exist\");\r\n        require(users[_userAddress].isActive, \"User is inactive\");\r\n        require(_investment >= minInvestment, \"Invalid investment amount\");\r\n\r\n        require(\r\n            _usdtToken.transferFrom(msg.sender, address(this), (_investment)),\r\n            \"Transfer failed\"\r\n        );\r\n\r\n        User storage _user = users[msg.sender];\r\n\r\n        userInvestments[_userAddress].push(\r\n            UserInvestment({\r\n                id: _investmentIndex++,\r\n                iterationsLeft: roiIterations,\r\n                amount: _investment,\r\n                endedTimestamp: 0,\r\n                timestamp: block.timestamp,\r\n                hasEnded: false,\r\n                isZeroPin: false\r\n            })\r\n        );\r\n\r\n        address _sponsorAddress = _user.sponsor;\r\n\r\n        for (uint256 i = 0; i < directIncomePercentages.length; i++) {\r\n            User storage _currentSponsorUser = users[_sponsorAddress];\r\n            uint256 _directIncomeX = (_investment *\r\n                directIncomePercentages[i]) / 1000;\r\n\r\n            if (\r\n                _currentSponsorUser.directLevelsOpened > i &&\r\n                _currentSponsorUser.isActive\r\n            ) {\r\n                uint256 _directIncome = 0;\r\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\r\n                    _currentSponsorUser.addr\r\n                ) * (_currentSponsorUser.referrals.length > 0 ? 3000 : 1825)) /\r\n                    1000;\r\n\r\n                if (\r\n                    _currentSponsorUser.zeroPinType ==\r\n                    ZeroPinMode.RETOPUP_REQUIRED\r\n                ) {\r\n                    _maxIncome = 300 * 10 ** 18;\r\n                }\r\n\r\n                if (_currentSponsorUser.zeroPinType == ZeroPinMode.FULL) {\r\n                    _maxIncome = 10000000000000 * 10 ** 18;\r\n                }\r\n\r\n                if (\r\n                    _directIncomeX > (_maxIncome - _currentSponsorUser.balance)\r\n                ) {\r\n                    _directIncome = _maxIncome - _currentSponsorUser.balance;\r\n                } else {\r\n                    _directIncome = _directIncomeX;\r\n                }\r\n                _currentSponsorUser.balance += _directIncome;\r\n                incomeTransactions[_currentSponsorUser.addr].push(\r\n                    IncomeTransaction({\r\n                        relatedInvestmentId: 0,\r\n                        class: \"direct_income\",\r\n                        relatedUser: msg.sender,\r\n                        amount: _directIncome,\r\n                        description: \"Direct Income\",\r\n                        timestamp: block.timestamp\r\n                    })\r\n                );\r\n            }\r\n\r\n            _sponsorAddress = _currentSponsorUser.sponsor;\r\n\r\n            if (_sponsorAddress == address(0)) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 adminAmount = ((10 * (_investment)) / 100);\r\n        _usdtToken.transfer(tenPercentOfInvestmentAddress, adminAmount);\r\n\r\n        adminTransactions.push(\r\n            AdminTransactions({\r\n                user: _user.addr,\r\n                amount: adminAmount,\r\n                desc: \"Upgrade\",\r\n                timestamp: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function registerUser(address _sponsor, uint256 _investment) external {\r\n        require(_sponsor != address(0), \"Invalid sponsor address\");\r\n        require(_investment >= minInvestment, \"Invalid investment amount\");\r\n        require(!userExists(msg.sender), \"User Already Exists\");\r\n        require(msg.sender != _sponsor, \"Same sponsor and user address\");\r\n\r\n        require(\r\n            _usdtToken.transferFrom(msg.sender, address(this), (_investment)),\r\n            \"Transfer failed\"\r\n        );\r\n\r\n        users[msg.sender] = User({\r\n            addr: msg.sender,\r\n            sponsor: _sponsor,\r\n            rewardCarryForwardAmount: 0,\r\n            balance: 0,\r\n            registrationTimestamp: block.timestamp,\r\n            referrals: new address[](0),\r\n            directLevelsOpened: 0,\r\n            generationLevelsOpened: 0,\r\n            isActive: true,\r\n            zeroPinType: ZeroPinMode.NONE\r\n        });\r\n\r\n        usersList.push(msg.sender);\r\n\r\n        userInvestments[msg.sender].push(\r\n            UserInvestment({\r\n                id: _investmentIndex++,\r\n                amount: _investment,\r\n                endedTimestamp: 0,\r\n                hasEnded: false,\r\n                timestamp: block.timestamp,\r\n                iterationsLeft: roiIterations,\r\n                isZeroPin: false\r\n            })\r\n        );\r\n\r\n        address _sponsorAddress = _sponsor;\r\n        User storage _sponsorUser = users[_sponsorAddress];\r\n        _sponsorUser.referrals.push(msg.sender);\r\n        _sponsorUser.directLevelsOpened += directLevelOpenedPerReferral;\r\n        _sponsorUser.generationLevelsOpened += generationLevelOpenedPerReferral;\r\n\r\n        for (uint256 i = 0; i < directIncomePercentages.length; i++) {\r\n            User storage _currentSponsorUser = users[_sponsorAddress];\r\n            uint256 _directIncomeX = (_investment *\r\n                directIncomePercentages[i]) / 1000;\r\n\r\n            if (\r\n                _currentSponsorUser.directLevelsOpened > i &&\r\n                _currentSponsorUser.isActive\r\n            ) {\r\n                uint256 _directIncome = 0;\r\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\r\n                    _currentSponsorUser.addr\r\n                ) * (_currentSponsorUser.referrals.length > 0 ? 3000 : 1825)) /\r\n                    1000;\r\n\r\n                if (\r\n                    _currentSponsorUser.zeroPinType ==\r\n                    ZeroPinMode.RETOPUP_REQUIRED\r\n                ) {\r\n                    _maxIncome = 300 * 10 ** 18;\r\n                }\r\n\r\n                if (_currentSponsorUser.zeroPinType == ZeroPinMode.FULL) {\r\n                    _maxIncome = 10000000000000 * 10 ** 18;\r\n                }\r\n\r\n                if (\r\n                    _directIncomeX > (_maxIncome - _currentSponsorUser.balance)\r\n                ) {\r\n                    _directIncome = _maxIncome - _currentSponsorUser.balance;\r\n                } else {\r\n                    _directIncome = _directIncomeX;\r\n                }\r\n\r\n                _currentSponsorUser.balance += _directIncome;\r\n                incomeTransactions[_currentSponsorUser.addr].push(\r\n                    IncomeTransaction({\r\n                        relatedInvestmentId: 0,\r\n                        class: \"direct_income\",\r\n                        relatedUser: msg.sender,\r\n                        amount: _directIncome,\r\n                        description: \"Direct Income\",\r\n                        timestamp: block.timestamp\r\n                    })\r\n                );\r\n            }\r\n\r\n            _sponsorAddress = _currentSponsorUser.sponsor;\r\n\r\n            if (_sponsorAddress == address(0)) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 _finalUSDTToAdmin = ((10 * (_investment)) / 100);\r\n        _usdtToken.transfer(tenPercentOfInvestmentAddress, _finalUSDTToAdmin);\r\n\r\n        adminTransactions.push(\r\n            AdminTransactions({\r\n                user: msg.sender,\r\n                amount: _finalUSDTToAdmin,\r\n                desc: \"Registration\",\r\n                timestamp: block.timestamp\r\n            })\r\n        );\r\n\r\n        emit UserRegistered(msg.sender, _sponsor, _investment, block.timestamp);\r\n    }\r\n\r\n    function registerZeroPinUser(\r\n        address _addr,\r\n        address _sponsor,\r\n        uint256 _investment,\r\n        ZeroPinMode _type\r\n    ) external onlySystem {\r\n        require(!userExists(_addr), \"User Already Exists\");\r\n        require(_addr != _sponsor, \"Same sponsor and user address\");\r\n        require(_investment >= minInvestment, \"Invalid investment amount\");\r\n\r\n        users[_addr] = User({\r\n            addr: _addr,\r\n            sponsor: _sponsor,\r\n            rewardCarryForwardAmount: 0,\r\n            balance: 0,\r\n            registrationTimestamp: block.timestamp,\r\n            referrals: new address[](0),\r\n            directLevelsOpened: _type == ZeroPinMode.FULL ? 10 : 0,\r\n            generationLevelsOpened: _type == ZeroPinMode.FULL ? 30 : 0,\r\n            isActive: true,\r\n            zeroPinType: _type\r\n        });\r\n\r\n        usersList.push(_addr);\r\n\r\n        userInvestments[_addr].push(\r\n            UserInvestment({\r\n                id: _investmentIndex++,\r\n                amount: _investment,\r\n                endedTimestamp: 0,\r\n                hasEnded: false,\r\n                timestamp: block.timestamp,\r\n                iterationsLeft: roiIterations,\r\n                isZeroPin: true\r\n            })\r\n        );\r\n\r\n        address _sponsorAddress = _sponsor;\r\n        User storage _sponsorUser = users[_sponsorAddress];\r\n        _sponsorUser.referrals.push(_addr);\r\n        _sponsorUser.directLevelsOpened += directLevelOpenedPerReferral;\r\n        _sponsorUser.generationLevelsOpened += generationLevelOpenedPerReferral;\r\n\r\n        emit UserRegistered(_addr, _sponsor, _investment, block.timestamp);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tenPercentOfInvestmentAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sixPercentOfWithdrawalAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getAchievedRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.AchievedReward[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getAdminTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.AdminTransactions[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getLegBusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserActiveInvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserIncomeTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"relatedUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relatedInvestmentId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.IncomeTransaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserInvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserLatestActiveInvestment\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserOldestInvestmentWhichHasNotEnded\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserReferralCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserTotalActiveInvestmentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserTotalBusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserWithdrawals\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.UserWithdrawal[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUsersDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"zeroPinType\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFort.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getUsersList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"achievedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adminTransactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkForReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableUsersWhoNeedRetopup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_predefined\",\"type\":\"uint256\"}],\"name\":\"distributeDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"zeroPinType\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFort.User\",\"name\":\"user\",\"type\":\"tuple\"}],\"name\":\"hasAchievedMaxIncome\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"incomeTransactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"relatedUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relatedInvestmentId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"nqs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"registerZeroPinUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"}],\"name\":\"retopup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"sqn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"userExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_predefined\",\"type\":\"uint256\"}],\"name\":\"userHasBeenRegisteredForLessThan24Hours\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInvestments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"zeroPinType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usersList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DollarFort", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000006b6b83cea7088734cfe8265ef90a48c956848d26000000000000000000000000ea9761466a71c320adc665e32ed244b2edbb9c29", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b7be6d7da7795035232ce2820ef7203b7af5293a600a9e081418d60a6f67ac56"}