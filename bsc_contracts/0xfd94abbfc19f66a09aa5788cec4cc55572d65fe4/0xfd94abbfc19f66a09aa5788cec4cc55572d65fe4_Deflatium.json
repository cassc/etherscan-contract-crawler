{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/_erc/ERC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IERC.sol\\\";\\r\\n\\r\\nabstract contract ERC is IERC20_ {\\r\\n    string  internal  _symbol;\\r\\n    uint8   internal  _decimals;\\r\\n    uint256 internal  _url;\\r\\n    uint256 internal  _ver;                             /// version\\r\\n    address internal  _owner;                           /// superuser\\r\\n    address internal  _minter;                          /// optional minter contract\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Permit {\\r\\n        uint128 allowance;\\r\\n        uint128 limit;\\r\\n    }\\r\\n    uint256 internal  _totalSupply;\\r\\n    mapping(address => mapping(address => Permit))  internal _permits;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        uint256 max,                                    /// maximum tokens to mint, 0 as unlimited\\r\\n        uint160 owner,\\r\\n        uint256 version\\r\\n    ) {\\r\\n        unchecked {\\r\\n            address me = address(this);\\r\\n            uint128 mintable = (max == 0) ? Num.MAX128 : uint128(max);\\r\\n            _permits[me][_owner = address(owner)].limit =\\r\\n            _permits[Num._0][me].limit = mintable;      /// mintability\\r\\n            _ver = version;\\r\\n            _symbol = symbol_;\\r\\n            _decimals = decimals_;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    modifier ByMint() {\\r\\n        require(msg.sender == _minter,\\\"()\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function name() external view virtual override returns(string memory) {\\r\\n        uint256 url = _url;\\r\\n        return (url == 0) ? _symbol : _toString(url);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function symbol() public view virtual override returns(string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function decimals() external view virtual override returns(uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _permitted(address permitter, address permittee, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if((permitter == Num._0)                    /// this is exclusively for permission to config this contract\\r\\n             &&(permittee == _owner))                   /// and for contract owner only! (unconfiguratable after giving up ownership)\\r\\n                return true;\\r\\n            Permit memory permit = _permits[permitter][permittee];\\r\\n            if(permit.limit >= Num.MAX128)              /// permission between users enable futher uses of defi/game-fi\\r\\n                return true;\\r\\n            if(permit.limit < n)\\r\\n                return false;\\r\\n            permit.limit -= n;\\r\\n            _permits[permitter][permittee] = permit;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission can be issued exclusively by the permitter itself\\r\\n    function _issuePermit(address permitter, address permittee, uint256 amount) internal virtual returns(bool) {\\r\\n        uint256 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if((n == 0)||(permittee == permitter))\\r\\n                return false;\\r\\n            Permit memory p = _permits[permitter][permittee];\\r\\n            if(p.limit < Num.MAX128) {\\r\\n                n += p.limit;                           /// be careful to avoid overflow\\r\\n                p.limit = (n < Num.MAX128) ? uint128(n) : Num.MAX128;\\r\\n                _permits[permitter][permittee] = p;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission can be cancelled only by its holder!\\r\\n    function _cancelPermit(address permitter, address permittee, address payer, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            if(permittee == permitter)\\r\\n                return false;\\r\\n            Permit memory p = _permits[permitter][permittee];\\r\\n            if(p.limit == 0)\\r\\n                return false;\\r\\n            if((n == 0)||(n >= p.limit))                /// cancel all of remaining permits\\r\\n                n = p.limit;\\r\\n            bool toAllowance = (payer == permitter);\\r\\n            if(toAllowance) {\\r\\n                amount = uint256(n)+p.allowance;        /// convert permission into allowance\\r\\n                p.allowance = (amount < Num.MAX128) ? uint128(amount) : Num.MAX128;\\r\\n            }\\r\\n            else {\\r\\n                Permit memory pay = _permits[payer][permitter];\\r\\n                if(pay.limit == 0)\\r\\n                    return false;\\r\\n                if(n > pay.limit) n = pay.limit;        /// cannot pass permits over payer's limit\\r\\n                if(pay.limit < Num.MAX128) {\\r\\n                    pay.limit -= n;                     /// (payer->permitter) permission reduced\\r\\n                    _permits[payer][permitter] = pay;\\r\\n                }\\r\\n                if(payer != permittee) {\\r\\n                    pay = _permits[payer][permittee];\\r\\n                    amount = uint256(n)+pay.limit;      /// pass permission to payer, or eliminate debt loop\\r\\n                    pay.limit = (amount < Num.MAX128) ? uint128(amount) : Num.MAX128;\\r\\n                    _permits[payer][permittee] = pay;\\r\\n                }\\r\\n            }\\r\\n            if(p.limit < Num.MAX128) p.limit -= n;      /// permission (permitter->permittee) cancelled\\r\\n            else if(!toAllowance)\\r\\n                return true;\\r\\n            _permits[permitter][permittee] = p;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// permission check (for owner) to config this contract\\r\\n    function _config(uint256 permission, uint256 value) internal virtual returns(bool) {\\r\\n        require(_permitted(Num._0,msg.sender,permission),\\\"!\\\");\\r\\n        return value >= 0;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _toString(uint256 u) internal view virtual returns(string memory) {\\r\\n        unchecked {\\r\\n            uint b;\\r\\n            for(; b < 256; b += 8)\\r\\n                if((0xFF&(u>>b)) == 0)\\r\\n                    break;\\r\\n            if(b == 0) return \\\"\\\";\\r\\n            bytes memory z = new bytes(b>>3);\\r\\n            for(uint i = 0; i < b; i += 8)\\r\\n                z[i>>3] = bytes1(uint8(u>>i));\\r\\n            u = _url;\\r\\n            return string(z);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./ERC.sol\\\";\\r\\n\\r\\ncontract ERC20 is ERC, IERC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Account {\\r\\n        uint128 balance;                                /// account balance in weis, or the mapped lower 128b of escaped access\\r\\n        uint32  context;                                /// account context, or the mapped higher 32b of escaped access\\r\\n        uint96  escaped;\\r\\n    }\\r\\n    mapping(address => Account)                     internal _accounts;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        uint256 max,                                    /// maximum tokens to mint, 0 as unlimited\\r\\n        uint160 owner,\\r\\n        uint256 version\\r\\n    ) ERC(symbol_,decimals_,max,owner,version) {\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function totalSupply() external view virtual override returns(uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function balanceOf(address account) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            uint160 cmd;\\r\\n            address minter = _minter;\\r\\n            if(account == Num._0)                       /// burned tokens\\r\\n                return _accounts[Num._0].balance;\\r\\n            if(minter.code.length > 0) {                /// extended implementation in 'minter' contract\\r\\n                (v,cmd) = IESC20(minter).Insight(msg.sender,account,Num.NULL);\\r\\n                if(cmd == 0) return v;\\r\\n            }\\r\\n            (v,cmd) = _insight(account,Num.NULL);\\r\\n            if(cmd == 0) return v;                      /// escaped addresses are handled as following\\r\\n            if(cmd == Num.VERSION   ) return _ver;\\r\\n            if(cmd == Num.OWNER     ) return uint160(_owner);\\r\\n            if(cmd == Num.DELEGATE  ) return uint160(_minter);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function allowance(address owner, address spender) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            if(spender == Num._0) v = _permits[owner][msg.sender].limit;\\r\\n            else if(owner == Num._0) v = _permits[msg.sender][spender].limit;\\r\\n            else {\\r\\n                uint160 cmd;\\r\\n                address minter = _minter;\\r\\n                if(minter.code.length > 0) {            /// extended implementation in 'minter' contract\\r\\n                    (v,cmd) = IESC20(minter).Insight(msg.sender,owner,spender);\\r\\n                    if(cmd == 0) return v;\\r\\n                }\\r\\n                (v,cmd) = _insight(owner,spender);\\r\\n                if(cmd == 0) return v;                  /// escaped addresses are handled as following\\r\\n                if(cmd == Num.BALANCE) return _accounts[spender].balance;\\r\\n                if(cmd == Num.ESCAPED) return _accounts[spender].escaped;\\r\\n                return 0;\\r\\n            }\\r\\n            return (v == Num.MAX128) ? Num.MAX256 : v;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function approve(address spender, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,spender,Num.NULL,amount))\\r\\n                    return true;\\r\\n            _permits[msg.sender][spender].allowance = uint128(amount);\\r\\n            emit Approval(msg.sender,spender,amount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transfer(address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            if(amount == 0)                             /// transfer owner when called by owner and 'amount'== 0\\r\\n                if(_transferOwner(msg.sender,to))\\r\\n                    return true;\\r\\n            if(to < Num.MAP_)                           /// burn tokens if 'to'== 0x0~0xF\\r\\n                return _burn(msg.sender,amount);\\r\\n            address minter = _minter;\\r\\n            if(minter == msg.sender)                    /// mintable by 'minter' contract only\\r\\n                return _mint(to,amount);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,Num.NULL,to,amount))\\r\\n                    return true;\\r\\n            uint160 cmd = _transfer(Num.NULL,to,amount);\\r\\n            if(cmd == 0) return true;                   /// escaped addresses are handled as following\\r\\n            if(cmd == Num.URL) return _config(cmd,_url = amount);\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transferFrom(address from, address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(cmd == Num._900)                         /// for extenal to verify/spend permission between users\\r\\n                return _permitted((msg.sender == minter) ? Num._0 : msg.sender,to,amount);\\r\\n            if(minter.code.length > 0)                  /// extended implementation in 'minter' contract\\r\\n                if(IESC20(minter).Escape(msg.sender,from,to,amount))\\r\\n                    return true;\\r\\n            if(_transfer(from,to,amount) == 0)\\r\\n                return true;                            /// escaped addresses are handled as following\\r\\n            if(cmd == Num.DEBT) return _issuePermit(msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTOFF) return _cancelPermit(to,msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTPASS) return _cancelPermit(to,msg.sender,address(uint160(amount)),uint128(amount>>160));\\r\\n            if(cmd == Num.DELEGATE) return _config(cmd,uint160(_minter = to));\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _insight(address from, address to) internal virtual view returns(uint256,uint160) {\\r\\n        unchecked {\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(Num._Escaped(from))                      /// escaped address handling, overridable in sub class if necessary\\r\\n                return (0,cmd);\\r\\n            if(to == Num.NULL)                          /// called by 'balanceOf()'\\r\\n                return (_accounts[from].balance,0);\\r\\n            uint128 a = _permits[from][to].allowance;   /// called by 'allowance()'\\r\\n            uint256 v = (a == Num.MAX128) ? Num.MAX256 : a;\\r\\n            return (v,0);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transferOwner(address from, address to) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            if(Num._Escaped(to)||(from == to))\\r\\n                return false;\\r\\n            require(from == _owner,\\\"!\\\");                /// only owner can transfer his ownership\\r\\n            if((_owner = to) == Num._0)                 /// transfer owner\\r\\n                emit Transfer(from,to,0);               /// the ownership is permanently given up when 'to'== 0x0\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// possibly overrided by sub class\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual returns(uint160) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            bool directpay = (from == Num.NULL);        /// if called by 'transfer()'\\r\\n            address map = directpay ? to : from;\\r\\n            if(Num._Escaped(map))                       /// escaped address handling, overridable in sub class if necessary\\r\\n                return uint160(map);\\r\\n            if(directpay) from = msg.sender;\\r\\n            if((from == to)||(to == Num._0)||(n == 0))\\r\\n                return 0;\\r\\n            if(msg.sender != from)                        /// check/spend allowance if necessary\\r\\n                _spend(from,n);\\r\\n            Account memory a = _accounts[from];\\r\\n            require(a.balance >= n,\\\"$\\\");                /// revert if insufficient fund of 'from'\\r\\n            a.balance -= n;\\r\\n            _accounts[from] = a;\\r\\n            _accounts[to].balance += n;\\r\\n            if((from != Num._0)                         /// event in _mint()\\r\\n               &&(to != Num._0))                        /// event in _burn()\\r\\n                emit Transfer(from,to,n);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// spend allowance in transferFrom()\\r\\n    function _spend(address from, uint128 n) internal virtual {\\r\\n        unchecked {\\r\\n            Permit memory permit = _permits[from][msg.sender];\\r\\n            if(permit.allowance >= Num.MAX128)          /// infinte allowance\\r\\n                return;\\r\\n            if(permit.allowance >= n)                   /// bingo\\r\\n                permit.allowance -= n;\\r\\n            else {                                      /// uncommon path: permit.limit is introduced for further defi uses\\r\\n                if(permit.limit < Num.MAX128) {         /// and is exclusively issued by owner\\r\\n                    n -= permit.allowance;\\r\\n                    require(permit.limit >= n,\\\"*\\\");\\r\\n                    permit.limit -= n;\\r\\n                } else if(permit.allowance == 0)        /// gas saving\\r\\n                    return;\\r\\n                permit.allowance = 0;\\r\\n            }\\r\\n            _permits[from][msg.sender] = permit;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _burn(address from, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            Account memory a = _accounts[from];\\r\\n            require(a.balance >= n,\\\"$\\\");\\r\\n            _totalSupply -= n;\\r\\n            a.balance -= n;\\r\\n            _accounts[from] = a;\\r\\n            _accounts[Num._0].balance += n;\\r\\n            emit Transfer(from,Num._0,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// possibly overrided by sub class\\r\\n    function _mint(address to, uint256 amount) internal virtual returns(bool) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            Permit memory reserve = _permits[Num._0][address(this)];\\r\\n            if(reserve.limit < Num.MAX128) {            /// default implementation to constrain minting limit\\r\\n                if(reserve.limit < n)\\r\\n                    n = reserve.limit;\\r\\n                reserve.limit -= n;\\r\\n                _permits[Num._0][address(this)] = reserve;\\r\\n            }\\r\\n            _totalSupply += n;\\r\\n            _accounts[to].balance += n;\\r\\n            emit Transfer(Num._0,to,n);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/fi/Deflatium.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"../ERC20.sol\\\";\\r\\nimport \\\"./IDeflate.sol\\\";\\r\\n\\r\\n/////////////////////////////////////////////////////////// IUniswapV2Router01\\r\\ninterface ISwapRouter {\\r\\n    function factoryV2() external pure returns (address);\\r\\n}\\r\\n/////////////////////////////////////////////////////////// IUniswapV2Factory\\r\\ninterface ISwapFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n/////////////////////////////////////////////////////////// IUniswapV2Pair\\r\\ninterface ISwapPair {\\r\\n    function sync() external;\\r\\n}\\r\\n\\r\\nlibrary _Deflatium {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant DEFLATE     =   0xFD00;\\r\\n    uint160 public constant BUY         =   0xFD01;\\r\\n    uint160 public constant SELL        =   0xFD02;\\r\\n    uint160 public constant BURN        =   0xFD0b;\\r\\n    uint160 public constant MARKET      =   0xFDff;\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\ncontract Deflatium is ERC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    struct Dex {\\r\\n        address lp;                                     /// LP token of UniSwap/PancakeSwap\\r\\n        uint16  deflateDaily;                           /// 32768 = 50%: per collecting by _minter\\r\\n        uint16  deflatePerBuy;                          /// 32768 = 50%: per buy\\r\\n        uint16  deflatePerSell;                         /// 32768 = 50%: per sell\\r\\n        uint8   burnPerDeflate;                         /// 128   = 50%: burn/deflation\\r\\n        uint8   daysToMarket;                           /// non-nft-holders can buy this token after market is opened\\r\\n    }\\r\\n    Dex     internal  _dex;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        string memory symbol_,\\r\\n        address router,                                 /// UniSwap/PancakeSwap\\r\\n        address usd,                                    /// USDT/USDC\\r\\n        uint256 total,                                  /// no more than 40M\\r\\n        uint8 daysToMarket,                             /// day count to open market\\r\\n        uint256 build,\\r\\n        address publisher\\r\\n    ) ERC20(symbol_,18,0,uint160(build),uint160(publisher)) {\\r\\n        unchecked {\\r\\n            Dex memory dex;\\r\\n            if(router.code.length > 0)\\r\\n                dex.lp = ISwapFactory(ISwapRouter(router).factoryV2()).createPair(address(this),usd);\\r\\n            dex.deflateDaily    = uint16(uint(15)*0x10000/1000);    /// DEX pool defaltes 1.5% per day\\r\\n            dex.deflatePerBuy   = uint16(uint( 3)*0x10000/100);     /// every buy  defaltes 3%\\r\\n            dex.deflatePerSell  = uint16(uint( 3)*0x10000/100);     /// every sell defaltes 3%\\r\\n            dex.burnPerDeflate  = uint8 (uint(256)/3);  /// burn 1/3 of total deflation\\r\\n            dex.daysToMarket    = daysToMarket;\\r\\n            _dex = dex;\\r\\n            _accounts[msg.sender].balance = uint128(_totalSupply = total*Num._1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function balanceOf(address account) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            if(account == Num._0)                       /// burned tokens\\r\\n                return _accounts[Num._0].balance;\\r\\n            uint256 v;\\r\\n            uint160 cmd;\\r\\n            address minter = _minter;\\r\\n            if(account > Num.ESC) {                     /// normal addresses\\r\\n                Account memory a = _accounts[account];\\r\\n                if(account == _dex.lp)                  /// 'lp.escaped' temporally holds the tokens to be burned or transferred to NFT\\r\\n                    return a.balance-a.escaped;\\r\\n                if(account == minter)                   \\r\\n                    return a.balance;\\r\\n                if(a.escaped > 0) {                     /// NFT holders\\r\\n                    uint40 nftId = uint40(a.escaped);   /// plus tokens (staked and yield) in NFT\\r\\n                    v = IDeflater(minter).Balance(nftId,true);\\r\\n                }\\r\\n                return v+a.balance;\\r\\n            }\\r\\n            (v,cmd) = _insight(account,Num.NULL);\\r\\n            if(cmd == 0) return v;                      /// escaped addresses are handled as following\\r\\n            if(cmd == Num.VERSION       ) return _ver;\\r\\n            if(cmd == Num.OWNER         ) return uint160(_owner);\\r\\n            if(cmd == Num.DELEGATE      ) return uint160(minter);\\r\\n            if(cmd == Num.BIND          ) return uint160(_dex.lp);\\r\\n            if(cmd == Num.ESCAPE        ) return IDeflater(minter).Balance(0,true); /// total staked tokens for NFT contract\\r\\n            if(cmd == _Deflatium.MARKET ) return _dex.daysToMarket*Num._1;\\r\\n            uint256 per;\\r\\n            if(cmd == _Deflatium.DEFLATE) per = _dex.deflateDaily;   else\\r\\n            if(cmd == _Deflatium.BUY    ) per = _dex.deflatePerBuy;  else\\r\\n            if(cmd == _Deflatium.SELL   ) per = _dex.deflatePerSell; else\\r\\n            if(cmd == _Deflatium.BURN   ) per = uint(_dex.burnPerDeflate)<<8; else\\r\\n                return 0;\\r\\n            return (per*Num._100)>>16;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function allowance(address owner, address spender) external view virtual override returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 v;\\r\\n            if(spender == Num._0) v = _permits[owner][msg.sender].limit;\\r\\n            else if(owner == Num._0) v = _permits[msg.sender][spender].limit;\\r\\n            else if(owner > Num.ESC) v = _permits[owner][spender].allowance;\\r\\n            else {\\r\\n                uint160 cmd;\\r\\n                address minter = _minter;\\r\\n                (v,cmd) = _insight(owner,spender);\\r\\n                if(cmd == 0) return v;                  /// escaped addresses are handled as following\\r\\n                if(cmd == Num.ESCAPED) return _accounts[spender].escaped;\\r\\n                if(cmd == Num.BALANCE) {\\r\\n                    Account memory a = _accounts[spender];\\r\\n                    if((a.escaped > 0)&&(spender > Num.ESC)&&(spender != minter)) {\\r\\n                        uint40 nftId = uint40(a.escaped);\\r\\n                        v = IDeflater(minter).Balance(nftId,false);\\r\\n                    }\\r\\n                    return v+a.balance;\\r\\n                }\\r\\n                return 0;\\r\\n            }\\r\\n            return (v == Num.MAX128) ? Num.MAX256 : v;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function approve(address spender, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            address minter = _minter;\\r\\n            if(msg.sender == minter) {\\r\\n                Account memory a = _accounts[spender];\\r\\n                uint128 leftover = uint128(amount>>128);\\r\\n                uint40 nftId = uint40(amount);          /// update NFT id held by user\\r\\n                if(leftover > 0) {                      /// return fund temporally held in minter contract (staked or leftover)\\r\\n                    _accounts[minter].balance -= leftover;\\r\\n                    a.balance += leftover;\\r\\n                }\\r\\n                a.escaped = nftId;\\r\\n                _accounts[spender] = a;\\r\\n                return true;\\r\\n            }\\r\\n            _permits[msg.sender][spender].allowance = uint128(amount);\\r\\n            emit Approval(msg.sender,spender,amount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transfer(address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            if(amount == 0)                             /// transfer owner when called by owner and 'amount'== 0\\r\\n                if(_transferOwner(msg.sender,to))\\r\\n                    return true;\\r\\n            if(to < Num.MAP_)                           /// burn tokens if 'to'== 0x0~0xF\\r\\n                return _burn(msg.sender,amount);\\r\\n            uint160 cmd = _transfer(Num.NULL,to,amount);\\r\\n            if(cmd == 0) return true;                   /// escaped addresses are handled as following\\r\\n            uint16 per = uint16((amount<<16)/Num._100);\\r\\n            if(cmd == Num.URL           ) _url = amount; else\\r\\n            if(cmd == _Deflatium.MARKET ) _dex.daysToMarket   = uint8(amount/Num._1); else\\r\\n            if(cmd == _Deflatium.BURN   ) _dex.burnPerDeflate = uint8 (per>>8); else\\r\\n            if(cmd == _Deflatium.BUY    ) _dex.deflatePerBuy  = per; else\\r\\n            if(cmd == _Deflatium.SELL   ) _dex.deflatePerSell = per; else\\r\\n            if(cmd == _Deflatium.DEFLATE) _dex.deflateDaily   = per; else\\r\\n                return false;\\r\\n            return _config(cmd,0);                      /// require ownership to config (as above)\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function transferFrom(address from, address to, uint256 amount) external virtual override returns(bool) {\\r\\n        unchecked {\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(cmd == Num._900)                         /// for extenal to verify/consume permission between users\\r\\n                return _permitted((msg.sender == _minter) ? Num._0 : msg.sender,to,amount);\\r\\n            if(_transfer(from,to,amount) == 0)\\r\\n                return true;                            /// escaped addresses are handled as following\\r\\n            if(cmd == Num.DEBT) return _issuePermit(msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTOFF) return _cancelPermit(to,msg.sender,to,amount);\\r\\n            if(cmd == Num.DEBTPASS) return _cancelPermit(to,msg.sender,address(uint160(amount)),uint128(amount>>160));\\r\\n            if(cmd == Num.DELEGATE) return _config(cmd,uint160(_minter = to));\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _insight(address from, address to) override internal virtual view returns(uint256,uint160) {\\r\\n        return (0,uint160(to = from));\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _transfer(address from, address to, uint256 amount) override internal virtual returns(uint160) {\\r\\n        uint128 n = uint128(amount);\\r\\n        unchecked {\\r\\n            bool directpay = (from == Num.NULL);\\r\\n            address map = directpay ? to : from;\\r\\n            if(Num._Escaped(map))                       /// mapped address (not normal user)\\r\\n                return uint160(map);\\r\\n            if(directpay) from = msg.sender;\\r\\n            if(to == Num._0)\\r\\n                return 0;\\r\\n            if(msg.sender != from)\\r\\n                _spend(from,n);                         /// check/spend allowance\\r\\n            Dex memory dex = _dex;\\r\\n            address minter = _minter;\\r\\n            if(to == minter) {                          /// special cases to handle\\r\\n                if(msg.sender == minter) return _Deflating(dex,minter,n > 0);\\r\\n                if(from != dex.lp) return _Stake(from,minter,n);\\r\\n            }\\r\\n            Account memory a = _accounts[from];\\r\\n            uint128 balance = (from == dex.lp) ? a.balance-a.escaped : a.balance;\\r\\n            if(balance < n) {\\r\\n                uint64 nftId = uint64(a.escaped);\\r\\n                if((nftId > 0)                          /// NFT holder\\r\\n                 &&(from > Num.ESC)                     /// from normal address\\r\\n                 &&(from != minter)                     /// excpet minter/lp\\r\\n                 &&(from != dex.lp))                    /// reallocate tokens (if any) from NFT\\r\\n                    if(IDeflater(minter).Collect(from,nftId))\\r\\n                        balance = (a = _accounts[from]).balance;\\r\\n                require(balance >= n,\\\"$\\\");\\r\\n            }\\r\\n            Account memory b = _accounts[to];\\r\\n            if(to == dex.lp) {\\r\\n                require(dex.daysToMarket == 0,\\\"*\\\");     /// not sellable before market is opened\\r\\n                if(n < (b.balance-b.escaped)) {\\r\\n                    uint96 deflated = uint96((n*dex.deflatePerSell)>>16);\\r\\n                    b.escaped += deflated;              /// deflation per sell, held in 'lp.escaped' temporally to save gas\\r\\n                }\\r\\n            }\\r\\n            else if(from == dex.lp) {\\r\\n                if(to != minter) {\\r\\n                    require(dex.daysToMarket == 0,\\\"*\\\"); /// only NFT holder can buy limited amount of tokens before market is opened\\r\\n                    uint96 deflated = uint96((n*dex.deflatePerBuy)>>16);\\r\\n                    a.escaped += deflated;              /// deflation per buy, held in 'lp.escaped' temporally to save gas\\r\\n                    n -= deflated;\\r\\n                }\\r\\n            }\\r\\n            a.balance -= n;\\r\\n            b.balance += n;\\r\\n            _accounts[to] = b;\\r\\n            _accounts[from] = a;\\r\\n            if((from != Num._0)                         /// event in _mint()\\r\\n               &&(to != Num._0))                        /// event in _burn()\\r\\n                emit Transfer(from,to,n);\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _mint(address to, uint256 amount) override internal virtual returns(bool) {\\r\\n        require((amount = uint160(to)) < 0,\\\"\\\");         /// shall NOT be called! this is not a mintable token!\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _Deflating(Dex memory dex, address minter, bool mint) internal virtual returns(uint160) {\\r\\n        unchecked {                                     /// NFT contract calls 'transfer(NFT contract, 1)' to collect daily deflation\\r\\n            Account memory a = _accounts[dex.lp];\\r\\n            uint256 deflate = ((a.balance-a.escaped)*dex.deflateDaily)>>16;\\r\\n            uint128 burn = uint128(mint ? (deflate*dex.burnPerDeflate)>>8 : deflate);\\r\\n            _burn(dex.lp,burn);\\r\\n            if((a.escaped > 0)&&(minter.code.length > 0)) {\\r\\n                address bank = IDeflater(minter).Commit(a.escaped);\\r\\n                _accounts[bank].balance += a.escaped;   /// claim temporally collected trading deflation\\r\\n            }\\r\\n            a.balance -= uint128(deflate+a.escaped);\\r\\n            a.escaped = 0;\\r\\n            _accounts[dex.lp] = a;\\r\\n            ISwapPair(dex.lp).sync();\\r\\n            if(mint) {\\r\\n                a = _accounts[minter];\\r\\n                a.escaped = uint96(deflate-burn);       /// today' yield\\r\\n                a.balance += a.escaped;                 /// transfer rest of deflation to NFT contract\\r\\n                _accounts[minter] = a;\\r\\n            }\\r\\n            if(dex.daysToMarket > 0) {\\r\\n                dex.daysToMarket --;                    /// count down\\r\\n                _dex = dex;\\r\\n            }\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// NFT holder may call 'transfer(NFT contract, amount)' to stake\\r\\n    function _Stake(address user, address minter, uint256 amount) internal virtual returns(uint160) {\\r\\n        uint32 cents = uint32(amount/Num._0_01);\\r\\n        unchecked {\\r\\n            Account memory a = _accounts[user];\\r\\n            require(a.escaped > 0,\\\"%\\\");                 /// only NFT holder can stake\\r\\n            uint128 leftover = IDeflater(minter).Stake(user,uint40(a.escaped),cents,a.balance);\\r\\n            if(leftover == 0)                           /// fully staked within NFT, no more leftover\\r\\n                return 0;\\r\\n            a.balance -= leftover;                      /// transfer leftover to NFT contract\\r\\n            _accounts[minter].balance += leftover;\\r\\n            _accounts[user] = a;\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/fi/IDeflate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nlibrary _Deflate {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant TAX         =   0xDF00;\\r\\n    uint160 public constant CTX         =   0xDF01;\\r\\n    uint160 public constant DEV         =   0xDF02;\\r\\n    uint160 public constant FACTORY     =   0xDF03;\\r\\n    uint160 public constant MINT        =   0xDF04;\\r\\n    uint160 public constant MEMBER      =   0xDF05;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant PROMOTE     =   0xDF10;\\r\\n    uint160 public constant GROWTH      =   0xDF11;\\r\\n    uint160 public constant CAP         =   0xDF12;\\r\\n    uint160 public constant MIN         =   0xDF13;\\r\\n    uint160 public constant Y2TAX       =   0xDF14;\\r\\n    uint160 public constant U2TAX       =   0xDF15;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant CLOCK       =   0xFF00;\\r\\n    uint160 public constant CLOCKED     =   0xFF01;\\r\\n    uint160 public constant UNSTAKE     =   0xFF02;\\r\\n    uint160 public constant RESTAKE     =   0xFF03;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant HP          =   0xFF10;\\r\\n    uint160 public constant PRICE       =   0xFF11;\\r\\n    uint160 public constant LEFT        =   0xFF12;\\r\\n    uint160 public constant PRIVILEDGE  =   0xFF13;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant MINT2BURN   =   0xFF20;\\r\\n    uint160 public constant REFERRER    =   0xFF21;\\r\\n    uint160 public constant EN2BURN     =   0xFF22;\\r\\n    uint160 public constant ENHANCE     =   0xFF23;\\r\\n    uint160 public constant TOGAS       =   0xFF24;\\r\\n    uint160 public constant MAXBUY      =   0xFF25;\\r\\n    uint160 public constant MINGAS      =   0xFF26;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant NFT         =   0xFF30;\\r\\n    uint160 public constant YIELD       =   0xFF31;\\r\\n    uint160 public constant COMMISSION  =   0xFF32;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant VER         =   0xFFf0;\\r\\n    uint160 public constant VER2        =   0xFDf0;\\r\\n    uint160 public constant MARKET      =   0xFDff;\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\n\\r\\ninterface IDeflatee {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Config(uint160 cmd, uint256 amount) external returns(bool);\\r\\n    function MintNft(uint64 referrer, uint64 id, uint32 hp, uint32 paid, uint32 quota) external;\\r\\n    function Enhance(uint64 nftId, uint32 cents) external returns(bool);\\r\\n    function Buyable(address token, uint64 nftId, uint32 cents) external returns(bool);\\r\\n    function Stake(address user, uint64 nftId, uint32 cents, uint128 balance) external returns(uint128);\\r\\n    function Unstake(uint64 nftId, uint256 percent) external returns(bool);\\r\\n    function Restaking(uint64 nftId, uint256 amount) external returns(bool);\\r\\n    function Collect(address user, uint64 nftId) external returns(bool);\\r\\n    function Clock(uint n, bool onDay) external returns(uint256);\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Insight(uint160 cmd, address to) external view returns(uint256,uint160);\\r\\n}\\r\\n\\r\\ninterface IDeflater {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Balance(uint64 nftId, bool staked) external view returns(uint128);\\r\\n    function Collect(address user, uint64 nftId) external returns(bool);\\r\\n    function Stake(address user, uint64 nftId, uint32 cents, uint128 balance) external returns(uint128);\\r\\n    function Commit(uint128 amount) external returns(address);\\r\\n}\\r\\n\\r\\ninterface IDeflaterCallback {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Collected(address user, uint256 amount) external returns(uint32);\\r\\n    function Taxed(uint32 cents, uint subject) external returns(bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/IERC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\n/// import \\\"hardhat/console.sol\\\";\\r\\n\\r\\ninterface IERC20_ {\\r\\n    /////////////////////////////////////////////////////// interface of the ERC20 standard as defined in the EIP\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\ninterface IERC20 is IERC20_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC20Received(address from, address to, uint256 amount, uint256 data) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface IERC721Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\r\\n}\\r\\ninterface IERC165 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\ninterface IERC721Enumerable_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function totalSupply() external view returns(uint256);\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns(uint256);\\r\\n    function tokenByIndex(uint256 index) external view returns(uint256);\\r\\n}\\r\\ninterface IERC721Metadata_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function name() external view returns(string memory);\\r\\n/// function symbol() external view returns(string memory);\\r\\n    function tokenURI(uint256 tokenId) external view returns(string memory);\\r\\n}\\r\\ninterface IERC721_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function balanceOf(address owner) external view returns(uint256 balance);\\r\\n    function ownerOf(uint256 tokenId) external view returns(address);\\r\\n    function getApproved(uint256 tokenId) external view returns(address);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns(bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n/// function approve(address to, uint256 tokenId) external;\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n}\\r\\ninterface IESC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Insight(address caller, address from, address to) external view returns(uint256,uint160);\\r\\n    function Escape(address caller, address from, address to, uint256 amount) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface ISwap {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Swap(\\r\\n        address payer,                                  /// shall =caller if 'token' != USSSD\\r\\n                                                        /// or, caller must own a debt of payer and owe to this contract\\r\\n        uint256 amount,                                 /// amount of 'token' to sell\\r\\n        address token,                                  /// IERC20 token to sell\\r\\n        address tokenToReceive,                         /// IERC20 token to receive\\r\\n        uint256 minToReceive,                           /// minimum amount of 'tokenToReceive' to swap\\r\\n        address recipient                               /// target wallet\\r\\n    ) external returns(uint256);                        /// actual tokens received\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Estimate(uint256 amount, address token, address tokenToReceive) external view returns(uint256);\\r\\n}\\r\\n\\r\\n///////////////////////////////////////////////////////////\\r\\ninterface IDaoAgency {\\r\\n    function ApplyDao(address agent) external returns (address);\\r\\n}\\r\\n\\r\\nlibrary Num {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant MAX256      = type(uint256).max;\\r\\n    uint256 public constant MAX160      = type(uint160).max;\\r\\n    uint128 public constant MAX128      = type(uint128).max;\\r\\n    uint64  public constant MAX64       = type(uint64 ).max;\\r\\n    uint32  public constant MAX32       = type(uint32 ).max;\\r\\n    uint256 public constant GWEI        = 10**9;\\r\\n    uint256 public constant TWEI        = 10**12;\\r\\n    uint256 public constant _0_000001   = 10**12;\\r\\n    uint256 public constant _0_00001    = 10**13;\\r\\n    uint256 public constant _0_0001     = 10**14;\\r\\n    uint256 public constant _0_001      = 10**15;\\r\\n    uint256 public constant _0_01       = 10**16;\\r\\n    uint256 public constant _0_1        = 10**17;\\r\\n    uint256 public constant _1          = 10**18;\\r\\n    uint256 public constant _10         = 10**19;\\r\\n    uint256 public constant _100        = 10**20;\\r\\n    uint256 public constant _1000       = 10**21;\\r\\n    uint256 public constant _10000      = 10**22;\\r\\n    uint256 public constant _100000     = 10**23;\\r\\n    uint256 public constant _1000000    = 10**24;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant CENT        = 10**16;\\r\\n    uint256 public constant DIME        = 10**17;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    address public constant _0          = address(0);\\r\\n    address public constant MAP_        = address(0x10);\\r\\n    address public constant _MAP        = address(0xFFFFFFFFFF);\\r\\n    address public constant ESC         = address(0xFFFFFFFFFFFFFFFF);\\r\\n    address public constant NULL        = address(type(uint160).max);\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Mapped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= _MAP);\\r\\n    }\\r\\n    function _Mapped(address a, address b) internal pure returns(bool) {\\r\\n        return _Mapped((a != NULL) ? a : b);\\r\\n    }\\r\\n    function _Escaped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= ESC);\\r\\n    }\\r\\n    function _Escaped(address a, address b) internal pure returns(bool) {\\r\\n        return _Escaped((a != NULL) ? a : b);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant _900        =  0x900;\\r\\n    uint160 public constant URL         =  0x192;\\r\\n    uint160 public constant GAS         =  0x9a5;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant SN          =   0x50;\\r\\n    uint160 public constant VERSION     =   0x51;\\r\\n    uint160 public constant VER2        =   0x52;\\r\\n    uint160 public constant ACCOUNT     =   0xAC;\\r\\n    uint160 public constant BLK         =   0xB1;\\r\\n    uint160 public constant HASH        =   0xB5;\\r\\n    uint160 public constant BALANCE     =   0xBA;\\r\\n    uint160 public constant ESCAPE      =   0xE5;\\r\\n    uint160 public constant ESCAPED     =   0xED;\\r\\n    uint160 public constant CTX         =   0xFC;\\r\\n    uint160 public constant STATUS      =   0xFF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant USD         = 0xadd0;\\r\\n    uint160 public constant USD1        = 0xadd1;\\r\\n    uint160 public constant USD2        = 0xadd2;\\r\\n    uint160 public constant TOKEN       = 0xadd8;\\r\\n    uint160 public constant USD_        = 0xadd9;\\r\\n    uint160 public constant NFT         = 0xaddA;\\r\\n    uint160 public constant BIND        = 0xaddB;\\r\\n    uint160 public constant SWAP        = 0xaddC;\\r\\n    uint160 public constant DAO         = 0xaddD;\\r\\n    uint160 public constant OWNER       = 0xaddE;\\r\\n    uint160 public constant DELEGATE    = 0xaddF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant DEBT        = 0xDeb0;\\r\\n    uint160 public constant DEBTOFF     = 0xDeb1;\\r\\n    uint160 public constant DEBTPASS    = 0xDeb2;\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"daysToMarket\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"build\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"publisher\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Deflatium", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e000000000000000000000000013f4ea83d0bd40e75c8222255bc855a974568dd400000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000000000000000000000000000000000000098968000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e092827737257ccffaf783cb4b792d1f240fa370000000000000000000000000c31865a16c4f15dbdacb5bc2996f86de5caf6b700000000000000000000000000000000000000000000000000000000000000034d46540000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://41fc0cc911ef7bc9de435513e226eb4ebcbcf1679d0a03850d87f2a11b2982f9"}