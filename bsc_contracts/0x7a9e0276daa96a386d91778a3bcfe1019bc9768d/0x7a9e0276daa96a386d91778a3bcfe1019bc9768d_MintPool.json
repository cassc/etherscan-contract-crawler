{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface INFT {\r\n    function addTokenReward(uint256 rewardAmount) external;\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n\r\ninterface ISwapPair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n}\r\n\r\ninterface IToken {\r\n    function giveMintReward() external;\r\n\r\n    function addUserLPAmount(address account, uint256 lpAmount) external;\r\n}\r\n\r\nabstract contract AbsLPPool is Ownable {\r\n    struct UserInfo {\r\n        bool isActive;\r\n        uint256 amount;\r\n        uint256 rewardMintDebt;\r\n        uint256 calMintReward;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint256 totalAmount;\r\n        uint256 accMintPerShare;\r\n        uint256 accMintReward;\r\n        uint256 mintPerSec;\r\n        uint256 lastMintTime;\r\n        uint256 totalMintReward;\r\n    }\r\n\r\n    struct UserLPInfo {\r\n        uint256 lockAmount;\r\n        uint256 calAmount;\r\n        uint256 claimedAmount;\r\n        uint256 lastReleaseTime;\r\n        //\r\n        uint256 releaseInitAmount;\r\n        //\r\n        uint256 releaseDuration;\r\n        uint256 speedUpTime;\r\n    }\r\n\r\n    PoolInfo private poolInfo;\r\n    mapping(address => UserInfo) private userInfo;\r\n    mapping(address => UserLPInfo) private _userLPInfo;\r\n\r\n    ISwapRouter private immutable _swapRouter;\r\n    address private immutable _usdt;\r\n    uint256 private _minAmount;\r\n    address private immutable _mintRewardToken;\r\n    address public immutable _lp;\r\n    INFT public _nft;\r\n\r\n    mapping(address => address) public _invitor;\r\n    mapping(address => address[]) public _binder;\r\n    mapping(uint256 => uint256) public _inviteFee;\r\n    uint256 private constant _inviteLen = 5;\r\n    address private _defaultInvitor;\r\n\r\n    mapping(address => uint256) private _inviteAmount;\r\n    mapping(address => uint256) private _teamAmount;\r\n    mapping(address => uint256) private _teamNum;\r\n\r\n    bool public _pauseSell;\r\n    uint256 public _sellSelfRate = 5000;\r\n    uint256 public _sellJoinRate = 4000;\r\n    uint256 public _sellNFTRate = 500;\r\n    address public _sellLPReceiver;\r\n    mapping(address => uint256) private _sellJoinAmount;\r\n    address public _fundAddress;\r\n\r\n    function setPauseSell(bool p) external onlyWhiteList {\r\n        _pauseSell = p;\r\n    }\r\n\r\n    function setSellSelfRate(uint256 r) external onlyWhiteList {\r\n        _sellSelfRate = r;\r\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"T1w\");\r\n    }\r\n\r\n    function setSellJoinRate(uint256 r) external onlyWhiteList {\r\n        _sellJoinRate = r;\r\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"T1w\");\r\n    }\r\n\r\n    function setSellNFTRate(uint256 r) external onlyWhiteList {\r\n        _sellNFTRate = r;\r\n        require(_sellSelfRate + _sellJoinRate + _sellNFTRate <= 10000, \"T1w\");\r\n    }\r\n\r\n    function setSellLPReceiver(address a) external onlyWhiteList {\r\n        _sellLPReceiver = a;\r\n    }\r\n\r\n    function setFundAddress(address a) external onlyWhiteList {\r\n        _fundAddress = a;\r\n    }\r\n\r\n    //\r\n    function sell(uint256 tokenAmount) public {\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n\r\n        _bindInvitor(account, _defaultInvitor);\r\n\r\n        require(!_pauseSell, \"PS\");\r\n        _takeToken(_mintRewardToken, account, address(this), tokenAmount);\r\n\r\n        address usdt = _usdt;\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 usdtBalanceBefore = USDT.balanceOf(address(this));\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = _mintRewardToken;\r\n        path[1] = usdt;\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 usdtAmount = USDT.balanceOf(address(this)) - usdtBalanceBefore;\r\n        uint256 selfUsdt = (usdtAmount * _sellSelfRate) / 10000;\r\n        _giveToken(usdt, account, selfUsdt);\r\n\r\n        uint256 sellJoinUsdt = (usdtAmount * _sellJoinRate) / 10000;\r\n        addLP(account, sellJoinUsdt, 0, false);\r\n\r\n        _updatePool();\r\n        uint256 sellJoinAmount = (sellJoinUsdt * _lastAmountRate) / _divFactor;\r\n        _addUserAmount(account, sellJoinAmount, false);\r\n        _sellJoinAmount[account] += sellJoinAmount;\r\n\r\n        uint256 nftUsdt = (usdtAmount * _sellNFTRate) / 10000;\r\n        _giveToken(usdt, address(_nft), nftUsdt);\r\n        _nft.addTokenReward(nftUsdt);\r\n\r\n        uint256 fundUsdt = usdtAmount - selfUsdt - sellJoinUsdt - nftUsdt;\r\n        _giveToken(usdt, _fundAddress, fundUsdt);\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    bool private _pauseJoin = true;\r\n    uint256 public _lastDailyUpTime;\r\n    uint256 public _lastAmountRate = 10000;\r\n    uint256 public _amountDailyUp = 10100;\r\n    uint256 private constant _divFactor = 10000;\r\n    uint256 private constant _dailyDuration = 1 days;\r\n\r\n    uint256 public _lpReleaseDuration = 183 days;\r\n    //\r\n    uint256 private _speedUpCost;\r\n    uint256 public _speedUpDuration = 30 days;\r\n    address public _speedUpReceiver =\r\n        address(0x000000000000000000000000000000000000dEaD);\r\n    uint256 private _speedUpMaxTime = 3;\r\n\r\n    function setSpeedUpMaxTime(uint256 mt) external onlyWhiteList {\r\n        _speedUpMaxTime = mt;\r\n    }\r\n\r\n    function setSpeedUpCost(uint256 c) external onlyWhiteList {\r\n        _speedUpCost = c;\r\n    }\r\n\r\n    function setSpeedUpDuration(uint256 d) external onlyWhiteList {\r\n        _speedUpDuration = d;\r\n    }\r\n\r\n    function setSeedUpReceiver(address a) external onlyWhiteList {\r\n        _speedUpReceiver = a;\r\n    }\r\n\r\n    function setLPReleaseDuration(uint256 d) external onlyWhiteList {\r\n        require(d > 0, \"gt0\");\r\n        _lpReleaseDuration = d;\r\n    }\r\n\r\n    function setAmountDailyUp(uint256 r) external onlyWhiteList {\r\n        _amountDailyUp = r;\r\n    }\r\n\r\n    function setLastDailyUpTime(uint256 t) external onlyWhiteList {\r\n        _lastDailyUpTime = t;\r\n    }\r\n\r\n    function setLastAmountRate(uint256 r) external onlyWhiteList {\r\n        _lastAmountRate = r;\r\n    }\r\n\r\n    function _updateDailyUpRate() public {\r\n        uint256 lastDailyUpTime = _lastDailyUpTime;\r\n        if (0 == lastDailyUpTime) {\r\n            return;\r\n        }\r\n        uint256 dailyDuration = _dailyDuration;\r\n        uint256 nowTime = block.timestamp;\r\n        if (nowTime < lastDailyUpTime + dailyDuration) {\r\n            return;\r\n        }\r\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\r\n        _lastDailyUpTime = lastDailyUpTime + ds * dailyDuration;\r\n\r\n        uint256 lastAmountRate = _lastAmountRate;\r\n        uint256 amountDailyUp = _amountDailyUp;\r\n        for (uint256 i; i < ds; ++i) {\r\n            lastAmountRate = (lastAmountRate * amountDailyUp) / _divFactor;\r\n        }\r\n        _lastAmountRate = lastAmountRate;\r\n    }\r\n\r\n    function getDailyRate() private view returns (uint256) {\r\n        uint256 lastAmountRate = _lastAmountRate;\r\n        uint256 lastDailyUpTime = _lastDailyUpTime;\r\n        if (0 == lastDailyUpTime) {\r\n            return lastAmountRate;\r\n        }\r\n        uint256 dailyDuration = _dailyDuration;\r\n        uint256 nowTime = block.timestamp;\r\n        if (nowTime < lastDailyUpTime + dailyDuration) {\r\n            return lastAmountRate;\r\n        }\r\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\r\n\r\n        uint256 amountDailyUp = _amountDailyUp;\r\n        for (uint256 i; i < ds; ++i) {\r\n            lastAmountRate = (lastAmountRate * amountDailyUp) / _divFactor;\r\n        }\r\n        return lastAmountRate;\r\n    }\r\n\r\n    function open() external onlyWhiteList {\r\n        if (0 == _lastDailyUpTime) {\r\n            _lastDailyUpTime = block.timestamp;\r\n        }\r\n        _pauseJoin = false;\r\n    }\r\n\r\n    function close() external onlyWhiteList {\r\n        _pauseJoin = true;\r\n    }\r\n\r\n    constructor(\r\n        address SwapRouter,\r\n        address USDT,\r\n        address MintRewardToken,\r\n        address NFT,\r\n        address DefaultInvitor,\r\n        address FundAddress\r\n    ) {\r\n        _swapRouter = ISwapRouter(SwapRouter);\r\n        _usdt = USDT;\r\n        _minAmount = 100 * 10**IERC20(USDT).decimals();\r\n        _nft = INFT(NFT);\r\n        _mintRewardToken = MintRewardToken;\r\n        _lp = ISwapFactory(_swapRouter.factory()).getPair(\r\n            USDT,\r\n            MintRewardToken\r\n        );\r\n        poolInfo.lastMintTime = block.timestamp;\r\n        _defaultInvitor = DefaultInvitor;\r\n        userInfo[DefaultInvitor].isActive = true;\r\n        _inviteFee[0] = 1000;\r\n        _inviteFee[1] = 800;\r\n        _inviteFee[2] = 600;\r\n        _inviteFee[3] = 500;\r\n        _inviteFee[4] = 400;\r\n        _speedUpCost = 300 * 10**IERC20(_usdt).decimals();\r\n\r\n        safeApprove(USDT, SwapRouter, ~uint256(0));\r\n        safeApprove(MintRewardToken, SwapRouter, ~uint256(0));\r\n\r\n        _sellLPReceiver = FundAddress;\r\n        _fundAddress = FundAddress;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    uint256 private _totalUsdt;\r\n\r\n    //\r\n    function deposit(\r\n        uint256 amount,\r\n        uint256 minTokenAmount,\r\n        address invitor\r\n    ) external {\r\n        require(!_pauseJoin, \"pause\");\r\n\r\n        require(amount >= _minAmount, \"m\");\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n\r\n        _totalUsdt += amount;\r\n\r\n        _bindInvitor(account, invitor);\r\n\r\n        _takeToken(_usdt, account, address(this), amount);\r\n\r\n        addLP(account, amount, minTokenAmount, true);\r\n\r\n        _updatePool();\r\n        _addUserAmount(account, (amount * _lastAmountRate) / _divFactor, true);\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    //\r\n    function addLP(\r\n        address account,\r\n        uint256 usdtAmount,\r\n        uint256 minTokenAmount,\r\n        bool lockLP\r\n    ) private {\r\n        address token = _mintRewardToken;\r\n        IERC20 Token = IERC20(token);\r\n        uint256 tokenBalanceBefore = Token.balanceOf(address(this));\r\n\r\n        address usdt = _usdt;\r\n        address[] memory path = new address[](2);\r\n        path[0] = usdt;\r\n        path[1] = token;\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            usdtAmount / 2,\r\n            minTokenAmount,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 tokenAmount = Token.balanceOf(address(this)) -\r\n            tokenBalanceBefore;\r\n\r\n        address lpReceiver = lockLP ? address(this) : _sellLPReceiver;\r\n        (, , uint256 liquidity) = _swapRouter.addLiquidity(\r\n            usdt,\r\n            token,\r\n            usdtAmount / 2,\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            lpReceiver,\r\n            block.timestamp\r\n        );\r\n        //\r\n        if (lockLP) {\r\n            _addLockLP(account, liquidity);\r\n        } else {\r\n            IToken(_mintRewardToken).addUserLPAmount(lpReceiver, liquidity);\r\n        }\r\n    }\r\n\r\n    //\r\n    function _addLockLP(address account, uint256 liquidity) private {\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        uint256 nowTime = block.timestamp;\r\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\r\n            uint256 releaseAmount = (userLPInfo.releaseInitAmount *\r\n                (nowTime - lastReleaseTime)) / userLPInfo.releaseDuration;\r\n            uint256 maxAmount = userLPInfo.lockAmount -\r\n                userLPInfo.calAmount -\r\n                userLPInfo.claimedAmount;\r\n            if (releaseAmount > maxAmount) {\r\n                releaseAmount = maxAmount;\r\n            }\r\n            userLPInfo.calAmount += releaseAmount;\r\n        }\r\n        uint256 remainAmount = userLPInfo.lockAmount -\r\n            userLPInfo.calAmount -\r\n            userLPInfo.claimedAmount;\r\n        userLPInfo.lockAmount += liquidity;\r\n        userLPInfo.releaseInitAmount = remainAmount + liquidity;\r\n        userLPInfo.releaseDuration = _lpReleaseDuration;\r\n\r\n        if (nowTime > lastReleaseTime) {\r\n            userLPInfo.lastReleaseTime = nowTime;\r\n        }\r\n    }\r\n\r\n    //\r\n    function claimLP() public {\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        uint256 nowTime = block.timestamp;\r\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\r\n            uint256 releaseAmount = (userLPInfo.releaseInitAmount *\r\n                (nowTime - lastReleaseTime)) / userLPInfo.releaseDuration;\r\n            uint256 maxAmount = userLPInfo.lockAmount -\r\n                userLPInfo.calAmount -\r\n                userLPInfo.claimedAmount;\r\n            if (releaseAmount > maxAmount) {\r\n                releaseAmount = maxAmount;\r\n            }\r\n            userLPInfo.calAmount += releaseAmount;\r\n        }\r\n\r\n        uint256 calAmount = userLPInfo.calAmount;\r\n        if (calAmount > 0) {\r\n            _giveToken(_lp, account, calAmount);\r\n            userLPInfo.calAmount = 0;\r\n            userLPInfo.claimedAmount += calAmount;\r\n            IToken(_mintRewardToken).addUserLPAmount(account, calAmount);\r\n        }\r\n\r\n        if (nowTime > lastReleaseTime) {\r\n            userLPInfo.lastReleaseTime = nowTime;\r\n        }\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    //\r\n    function speedUpLP(uint256 maxTokenAmount) public {\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        uint256 lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        uint256 nowTime = block.timestamp;\r\n        if (lastReleaseTime > 0 && nowTime > lastReleaseTime) {\r\n            uint256 releaseAmount = (userLPInfo.releaseInitAmount *\r\n                (nowTime - lastReleaseTime)) / userLPInfo.releaseDuration;\r\n            uint256 maxAmount = userLPInfo.lockAmount -\r\n                userLPInfo.calAmount -\r\n                userLPInfo.claimedAmount;\r\n            if (releaseAmount > maxAmount) {\r\n                releaseAmount = maxAmount;\r\n            }\r\n            userLPInfo.calAmount += releaseAmount;\r\n        }\r\n\r\n        if (nowTime > lastReleaseTime) {\r\n            userLPInfo.lastReleaseTime = nowTime;\r\n        }\r\n\r\n        require(userLPInfo.speedUpTime < _speedUpMaxTime, \"MT\");\r\n        userLPInfo.speedUpTime++;\r\n        uint256 tokenAmount = getSpeedUpTokenAmount();\r\n        require(tokenAmount <= maxTokenAmount, \"MA\");\r\n        _takeToken(_mintRewardToken, account, _speedUpReceiver, tokenAmount);\r\n\r\n        //\r\n        uint256 remainAmount = userLPInfo.lockAmount -\r\n            userLPInfo.calAmount -\r\n            userLPInfo.claimedAmount;\r\n        uint256 remainDuration = (remainAmount * userLPInfo.releaseDuration) /\r\n            userLPInfo.releaseInitAmount;\r\n\r\n        //\r\n        userLPInfo.releaseInitAmount = remainAmount;\r\n        uint256 speedUpDuration = _speedUpDuration;\r\n        require(remainDuration > speedUpDuration, \"RltS\");\r\n        userLPInfo.releaseDuration = remainDuration - speedUpDuration;\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    function getSpeedUpTokenAmount()\r\n        private\r\n        view\r\n        returns (uint256 tokenAmount)\r\n    {\r\n        (uint256 rUsdt, uint256 rToken) = _getReserves();\r\n        tokenAmount = (_speedUpCost * rToken) / rUsdt;\r\n    }\r\n\r\n    function _getReserves()\r\n        public\r\n        view\r\n        returns (uint256 rUsdt, uint256 rToken)\r\n    {\r\n        ISwapPair pair = ISwapPair(_lp);\r\n        (uint256 r0, uint256 r1, ) = pair.getReserves();\r\n\r\n        if (_usdt < _mintRewardToken) {\r\n            rUsdt = r0;\r\n            rToken = r1;\r\n        } else {\r\n            rUsdt = r1;\r\n            rToken = r0;\r\n        }\r\n    }\r\n\r\n    function getJoinTokenAmountOut(uint256 usdtAmount)\r\n        public\r\n        view\r\n        returns (uint256 tokenAmount)\r\n    {\r\n        address[] memory path = new address[](2);\r\n        path[0] = _usdt;\r\n        path[1] = _mintRewardToken;\r\n        uint256[] memory amounts = _swapRouter.getAmountsOut(\r\n            usdtAmount / 2,\r\n            path\r\n        );\r\n        tokenAmount = amounts[1];\r\n    }\r\n\r\n    function getSellUsdtOut(uint256 tokenAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 usdtAmount,\r\n            uint256 selfUsdt,\r\n            uint256 mintAmount\r\n        )\r\n    {\r\n        address[] memory path = new address[](2);\r\n        path[0] = _mintRewardToken;\r\n        path[1] = _usdt;\r\n        uint256[] memory amounts = _swapRouter.getAmountsOut(tokenAmount, path);\r\n        usdtAmount = amounts[1];\r\n        selfUsdt = (usdtAmount * _sellSelfRate) / 10000;\r\n        mintAmount = (usdtAmount * _sellJoinRate) / 10000;\r\n        mintAmount = (mintAmount * getDailyRate()) / 10000;\r\n    }\r\n\r\n    //\r\n    function _addUserAmount(\r\n        address account,\r\n        uint256 amount,\r\n        bool calInvite\r\n    ) private {\r\n        UserInfo storage user = userInfo[account];\r\n        _calReward(user, false);\r\n\r\n        uint256 userAmount = user.amount;\r\n        userAmount += amount;\r\n        user.amount = userAmount;\r\n\r\n        uint256 poolTotalAmount = poolInfo.totalAmount;\r\n        poolTotalAmount += amount;\r\n\r\n        uint256 poolAccMintPerShare = poolInfo.accMintPerShare;\r\n        user.rewardMintDebt = (userAmount * poolAccMintPerShare) / 1e18;\r\n\r\n        if (calInvite) {\r\n            uint256 len = _inviteLen;\r\n            UserInfo storage invitorInfo;\r\n            address current = account;\r\n            address invitor;\r\n            uint256 invitorTotalAmount;\r\n            for (uint256 i; i < len; ++i) {\r\n                invitor = _invitor[current];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n                invitorInfo = userInfo[invitor];\r\n                _calReward(invitorInfo, false);\r\n                uint256 inviteAmount = (amount * _inviteFee[i]) / 10000;\r\n                _inviteAmount[invitor] += inviteAmount;\r\n                _teamAmount[invitor] += amount;\r\n\r\n                invitorTotalAmount = invitorInfo.amount;\r\n                invitorTotalAmount += inviteAmount;\r\n                invitorInfo.amount = invitorTotalAmount;\r\n                invitorInfo.rewardMintDebt =\r\n                    (invitorTotalAmount * poolAccMintPerShare) /\r\n                    1e18;\r\n\r\n                poolTotalAmount += inviteAmount;\r\n                current = invitor;\r\n            }\r\n        }\r\n        poolInfo.totalAmount = poolTotalAmount;\r\n    }\r\n\r\n    //\r\n    function addUserAmount(\r\n        address account,\r\n        uint256 amount,\r\n        bool calInvite\r\n    ) public {\r\n        require(_inProject[msg.sender], \"rq project\");\r\n        _bindInvitor(account, _defaultInvitor);\r\n        _updatePool();\r\n        _addUserAmount(account, amount, calInvite);\r\n    }\r\n\r\n    //\r\n    function addMintAmount(address account, uint256 amount)\r\n        external\r\n        onlyWhiteList\r\n    {\r\n        _bindInvitor(account, _defaultInvitor);\r\n        _updatePool();\r\n        _addUserAmount(account, amount, false);\r\n    }\r\n\r\n    //\r\n    function claim() public {\r\n        address account = msg.sender;\r\n        UserInfo storage user = userInfo[account];\r\n        _calReward(user, true);\r\n        uint256 pendingMint = user.calMintReward;\r\n        if (pendingMint > 0) {\r\n            _giveToken(_mintRewardToken, account, pendingMint);\r\n            user.calMintReward = 0;\r\n        }\r\n\r\n        IToken(_mintRewardToken).giveMintReward();\r\n    }\r\n\r\n    //\r\n    function _updatePool() private {\r\n        _updateDailyUpRate();\r\n        PoolInfo storage pool = poolInfo;\r\n        uint256 blockTime = block.timestamp;\r\n        uint256 lastRewardTime = pool.lastMintTime;\r\n        if (blockTime <= lastRewardTime) {\r\n            return;\r\n        }\r\n        pool.lastMintTime = blockTime;\r\n\r\n        uint256 accReward = pool.accMintReward;\r\n        uint256 totalReward = pool.totalMintReward;\r\n        if (accReward >= totalReward) {\r\n            return;\r\n        }\r\n\r\n        uint256 totalAmount = pool.totalAmount;\r\n        uint256 rewardPerSec = pool.mintPerSec;\r\n        if (0 < totalAmount && 0 < rewardPerSec) {\r\n            uint256 reward = rewardPerSec * (blockTime - lastRewardTime);\r\n            uint256 remainReward = totalReward - accReward;\r\n            if (reward > remainReward) {\r\n                reward = remainReward;\r\n            }\r\n            pool.accMintPerShare += (reward * 1e18) / totalAmount;\r\n            pool.accMintReward += reward;\r\n        }\r\n    }\r\n\r\n    //\r\n    function _calReward(UserInfo storage user, bool updatePool) private {\r\n        if (updatePool) {\r\n            _updatePool();\r\n        }\r\n        if (user.amount > 0) {\r\n            uint256 accMintReward = (user.amount * poolInfo.accMintPerShare) /\r\n                1e18;\r\n            uint256 pendingMintAmount = accMintReward - user.rewardMintDebt;\r\n            if (pendingMintAmount > 0) {\r\n                user.rewardMintDebt = accMintReward;\r\n                user.calMintReward += pendingMintAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getPendingMintReward(address account)\r\n        public\r\n        view\r\n        returns (uint256 reward)\r\n    {\r\n        reward = 0;\r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[account];\r\n        if (user.amount > 0) {\r\n            uint256 poolPendingReward;\r\n            uint256 blockTime = block.timestamp;\r\n            uint256 lastRewardTime = pool.lastMintTime;\r\n            if (blockTime > lastRewardTime) {\r\n                poolPendingReward =\r\n                    pool.mintPerSec *\r\n                    (blockTime - lastRewardTime);\r\n                uint256 totalReward = pool.totalMintReward;\r\n                uint256 accReward = pool.accMintReward;\r\n                uint256 remainReward;\r\n                if (totalReward > accReward) {\r\n                    remainReward = totalReward - accReward;\r\n                }\r\n                if (poolPendingReward > remainReward) {\r\n                    poolPendingReward = remainReward;\r\n                }\r\n            }\r\n            reward =\r\n                (user.amount *\r\n                    (pool.accMintPerShare +\r\n                        (poolPendingReward * 1e18) /\r\n                        pool.totalAmount)) /\r\n                1e18 -\r\n                user.rewardMintDebt;\r\n        }\r\n    }\r\n\r\n    function viewPoolInfo()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalAmount,\r\n            uint256 accMintPerShare,\r\n            uint256 accMintReward,\r\n            uint256 mintPerSec,\r\n            uint256 lastMintTime,\r\n            uint256 totalMintReward\r\n        )\r\n    {\r\n        totalAmount = poolInfo.totalAmount;\r\n        accMintPerShare = poolInfo.accMintPerShare;\r\n        accMintReward = poolInfo.accMintReward;\r\n        mintPerSec = poolInfo.mintPerSec;\r\n        lastMintTime = poolInfo.lastMintTime;\r\n        totalMintReward = poolInfo.totalMintReward;\r\n    }\r\n\r\n    function viewUserInfo(address account)\r\n        public\r\n        view\r\n        returns (\r\n            bool isActive,\r\n            uint256 amount,\r\n            uint256 calMintReward,\r\n            uint256 rewardMintDebt\r\n        )\r\n    {\r\n        UserInfo storage user = userInfo[account];\r\n        isActive = user.isActive;\r\n        amount = user.amount;\r\n        calMintReward = user.calMintReward;\r\n        rewardMintDebt = user.rewardMintDebt;\r\n    }\r\n\r\n    function getUserLPInfo(address account)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 lockAmount,\r\n            uint256 calAmount,\r\n            uint256 claimedAmount,\r\n            uint256 lastReleaseTime,\r\n            uint256 releaseInitAmount,\r\n            uint256 releaseDuration,\r\n            uint256 speedUpTime,\r\n            uint256 tokenBalance,\r\n            uint256 tokenAllowance\r\n        )\r\n    {\r\n        UserLPInfo storage userLPInfo = _userLPInfo[account];\r\n        lockAmount = userLPInfo.lockAmount;\r\n        calAmount = userLPInfo.calAmount;\r\n        claimedAmount = userLPInfo.claimedAmount;\r\n        releaseInitAmount = userLPInfo.releaseInitAmount;\r\n        releaseDuration = userLPInfo.releaseDuration;\r\n        speedUpTime = userLPInfo.speedUpTime;\r\n        lastReleaseTime = userLPInfo.lastReleaseTime;\r\n        tokenBalance = IERC20(_mintRewardToken).balanceOf(account);\r\n        tokenAllowance = IERC20(_mintRewardToken).allowance(\r\n            account,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    function getUserInfo(address account)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 usdtBalance,\r\n            uint256 usdtAllowance,\r\n            uint256 pendingMintReward,\r\n            uint256 inviteAmount,\r\n            uint256 sellJoinAmount,\r\n            uint256 teamNum,\r\n            uint256 teamAmount\r\n        )\r\n    {\r\n        UserInfo storage user = userInfo[account];\r\n        amount = user.amount;\r\n        usdtBalance = IERC20(_usdt).balanceOf(account);\r\n        usdtAllowance = IERC20(_usdt).allowance(account, address(this));\r\n        pendingMintReward = getPendingMintReward(account) + user.calMintReward;\r\n        inviteAmount = _inviteAmount[account];\r\n        sellJoinAmount = _sellJoinAmount[account];\r\n        teamNum = _teamNum[account];\r\n        teamAmount = _teamAmount[account];\r\n    }\r\n\r\n    function getBaseInfo()\r\n        external\r\n        view\r\n        returns (\r\n            address usdt,\r\n            uint256 usdtDecimals,\r\n            address mintRewardToken,\r\n            uint256 mintRewardTokenDecimals,\r\n            uint256 totalUsdt,\r\n            uint256 totalAmount,\r\n            uint256 lastDailyReward,\r\n            uint256 dailyAmountRate,\r\n            uint256 minAmount,\r\n            address defaultInvitor,\r\n            bool pauseJoin\r\n        )\r\n    {\r\n        usdt = _usdt;\r\n        usdtDecimals = IERC20(usdt).decimals();\r\n        mintRewardToken = _mintRewardToken;\r\n        mintRewardTokenDecimals = IERC20(mintRewardToken).decimals();\r\n        totalUsdt = _totalUsdt;\r\n        totalAmount = poolInfo.totalAmount;\r\n        lastDailyReward = _lastDailyReward;\r\n        dailyAmountRate = getDailyRate();\r\n        minAmount = _minAmount;\r\n        defaultInvitor = _defaultInvitor;\r\n        pauseJoin = _pauseJoin;\r\n    }\r\n\r\n    function getLPInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLP,\r\n            uint256 lockLP,\r\n            uint256 speedUpMaxTime,\r\n            uint256 speedCostUsdt,\r\n            uint256 speedCostToken\r\n        )\r\n    {\r\n        totalLP = IERC20(_lp).totalSupply();\r\n        lockLP = IERC20(_lp).balanceOf(address(this));\r\n        speedUpMaxTime = _speedUpMaxTime;\r\n        speedCostUsdt = _speedUpCost;\r\n        speedCostToken = getSpeedUpTokenAmount();\r\n    }\r\n\r\n    function getBinderLength(address account) public view returns (uint256) {\r\n        return _binder[account].length;\r\n    }\r\n\r\n    //\r\n    function setMintPerSec(uint256 mintPerSec) external onlyWhiteList {\r\n        _updatePool();\r\n        poolInfo.mintPerSec = mintPerSec;\r\n    }\r\n\r\n    uint256 private _lastDailyReward;\r\n\r\n    //\r\n    function addTotalMintReward(uint256 reward) external {\r\n        require(_inProject[msg.sender], \"rq project\");\r\n        _updatePool();\r\n        poolInfo.totalMintReward += reward;\r\n        poolInfo.mintPerSec = reward / _dailyDuration;\r\n        _lastDailyReward = reward;\r\n    }\r\n\r\n    //\r\n    function setInviteFee(uint256 i, uint256 fee) external onlyWhiteList {\r\n        _inviteFee[i] = fee;\r\n    }\r\n\r\n    function claimBalance(address to, uint256 amount) external onlyWhiteList {\r\n        safeTransferETH(to, amount);\r\n    }\r\n\r\n    function claimToken(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) external onlyWhiteList {\r\n        _giveToken(token, to, amount);\r\n    }\r\n\r\n    function setDefaultInvitor(address adr) external onlyWhiteList {\r\n        _defaultInvitor = adr;\r\n        userInfo[adr].isActive = true;\r\n    }\r\n\r\n    mapping(address => bool) public _inProject;\r\n\r\n    function setInProject(address adr, bool enable) external onlyWhiteList {\r\n        _inProject[adr] = enable;\r\n    }\r\n\r\n    function bindInvitor(address account, address invitor) public {\r\n        address caller = msg.sender;\r\n        require(_inProject[caller], \"NA\");\r\n        _bindInvitor(account, invitor);\r\n    }\r\n\r\n    function _bindInvitor(address account, address invitor) private {\r\n        UserInfo storage user = userInfo[account];\r\n        if (!user.isActive) {\r\n            require(address(0) != invitor, \"invitor 0\");\r\n            require(userInfo[invitor].isActive, \"invitor !Active\");\r\n            _invitor[account] = invitor;\r\n            _binder[invitor].push(account);\r\n            for (uint256 i; i < _inviteLen; ) {\r\n                _teamNum[invitor] += 1;\r\n                invitor = _invitor[invitor];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n            user.isActive = true;\r\n        }\r\n    }\r\n\r\n    function getBinderList(\r\n        address account,\r\n        uint256 start,\r\n        uint256 length\r\n    ) external view returns (uint256 returnCount, address[] memory binders) {\r\n        address[] storage _binders = _binder[account];\r\n        uint256 recordLen = _binders.length;\r\n        if (0 == length) {\r\n            length = recordLen;\r\n        }\r\n        returnCount = length;\r\n        binders = new address[](length);\r\n        uint256 index = 0;\r\n        for (uint256 i = start; i < start + length; i++) {\r\n            if (i >= recordLen) {\r\n                return (index, binders);\r\n            }\r\n            binders[index] = _binders[i];\r\n            index++;\r\n        }\r\n    }\r\n\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"AF\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TF\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"ETF\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TFF\"\r\n        );\r\n    }\r\n\r\n    function _giveToken(\r\n        address tokenAddress,\r\n        address account,\r\n        uint256 amount\r\n    ) private {\r\n        if (0 == amount) {\r\n            return;\r\n        }\r\n        IERC20 token = IERC20(tokenAddress);\r\n        require(token.balanceOf(address(this)) >= amount, \"PTNE\");\r\n        safeTransfer(tokenAddress, account, amount);\r\n    }\r\n\r\n    function _takeToken(\r\n        address tokenAddress,\r\n        address from,\r\n        address to,\r\n        uint256 tokenNum\r\n    ) private {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        require(token.balanceOf(address(from)) >= tokenNum, \"TNE\");\r\n        safeTransferFrom(tokenAddress, from, to, tokenNum);\r\n    }\r\n\r\n    modifier onlyWhiteList() {\r\n        address msgSender = msg.sender;\r\n        require(msgSender == _fundAddress || msgSender == _owner, \"nw\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MintPool is AbsLPPool {\r\n    constructor()\r\n        AbsLPPool(\r\n            //SwapRouter\r\n            address(0x10ED43C718714eb63d5aA57B78B54704E256024E),\r\n            //USDT\r\n            address(0x72e58C8111bf76C94B088d818E9094a923132107),\r\n            //BOS\r\n            address(0xFa1E3b8454939B84A026B7da12Ca7E5d17c990ed),\r\n            //NFT\r\n            address(0x7539aFb1554f75437cC53D9c6d0577F233FF1fDF),\r\n            //DefaultInvitor\r\n            address(0x2602FcA32D5C5402807179D48afD32d906E11fBf),\r\n            //Fund\r\n            address(0x2602FcA32D5C5402807179D48afD32d906E11fBf)\r\n        )\r\n    {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_amountDailyUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_binder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_inviteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_invitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAmountRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastDailyUpTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lpReleaseDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nft\",\"outputs\":[{\"internalType\":\"contract INFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pauseSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellJoinRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellLPReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellNFTRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellSelfRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_speedUpDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_speedUpReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_updateDailyUpRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addMintAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"addTotalMintReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"calInvite\",\"type\":\"bool\"}],\"name\":\"addUserAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"}],\"name\":\"bindInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdtDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"mintRewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintRewardTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDailyReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyAmountRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"defaultInvitor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"pauseJoin\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBinderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getBinderList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnCount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"binders\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"getJoinTokenAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedUpMaxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedCostUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedCostToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingMintReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getSellUsdtOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellJoinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserLPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastReleaseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseInitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speedUpTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAllowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setAmountDailyUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setDefaultInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setInProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setInviteFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"setLPReleaseDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setLastAmountRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"setLastDailyUpTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPerSec\",\"type\":\"uint256\"}],\"name\":\"setMintPerSec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"p\",\"type\":\"bool\"}],\"name\":\"setPauseSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setSeedUpReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setSellJoinRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setSellLPReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setSellNFTRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setSellSelfRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"name\":\"setSpeedUpCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"setSpeedUpDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mt\",\"type\":\"uint256\"}],\"name\":\"setSpeedUpMaxTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTokenAmount\",\"type\":\"uint256\"}],\"name\":\"speedUpLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPerSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastMintTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMintReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"viewUserInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardMintDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MintPool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2a13ad464f9f33cc70462fe5a6463acb3280e1ebeca485965723dc00f540582f"}