{"SourceCode": "# @version ^0.2.11\r\n# @dev Implementation of multi-layers space and time rebasing BEP-20 token standard.\r\n# @dev copyright kader@enreach.io and kashaf@enreach.io\r\n# reference https://github.com/binance-chain/BEPs/blob/master/BEP20.md\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nevent ReceivedEther:\r\n    sender: indexed(address)\r\n    value: uint256\r\n\r\nevent OwnershipTransferred:\r\n    previousOwner: indexed(address)\r\n    newOwner: indexed(address)\r\n\r\n# EIP-20 compliant name symbol and decimals\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\n\r\n# additional decimals used for calculations\r\nscale: public(uint256)\r\n\r\n# exponent\r\nexpanse: public(int128)\r\nextent: public(uint256)\r\nextent_max: public(uint256)\r\n\r\n# temporal timer\r\ninitpulse: public(uint256)\r\nnextpulse: public(uint256)\r\n\r\nstruct Account:\r\n    amount: uint256\r\n    lode: uint256\r\n    expanse: int128\r\n\r\n\r\nstruct Lode:\r\n    total: uint256\r\n    total_e: uint256\r\n    expanse: int128\r\n    tax_id: uint256\r\n    itaxfree: bool\r\n    etaxfree: bool\r\n   \r\nNUM_OF_TEMPORAL_LODES: constant(uint256) = 25\r\nSTAKING_LODE: constant(uint256) = NUM_OF_TEMPORAL_LODES  # 25\r\nFROZEN_LODE: constant(uint256) = STAKING_LODE + 1 #26\r\nRESERVE_LODE: constant(uint256) = FROZEN_LODE + 1 #27\r\nSAFE_LODE: constant(uint256) = RESERVE_LODE + 1 #28\r\nRESERVED1_LODE: constant(uint256) = SAFE_LODE + 1 #29\r\nNUM_OF_LODES: constant(uint256) = 32 \r\nNUM_OF_TAX_POLICIES: constant(uint256) = 8\r\n\r\n\r\nowner: address\r\ncurrentLode: public(uint256)\r\ntransferLocked: public(bool)\r\ntaxOn: public(bool)\r\ntemporal_tax_num: public(uint256)\r\ntemporal_tax_num2: public(uint256)\r\ntemporal_tax_den: public(uint256)\r\ntax_numerators: public(uint256[NUM_OF_LODES][NUM_OF_TAX_POLICIES])\r\ntax_numeratorsum: public(uint256[NUM_OF_TAX_POLICIES])\r\ntax_denominator: public(uint256[NUM_OF_TAX_POLICIES])\r\ntax_toflush: public(uint256[NUM_OF_TAX_POLICIES])\r\ntax_airdrop_num: public(uint256)\r\ntax_airdrop_den: public(uint256)\r\nlodes: Lode[NUM_OF_LODES]\r\n\r\naccounts: HashMap[address, Account]\r\nallowances: HashMap[address, HashMap[address, uint256]]\r\nprivileged: HashMap[address, bool]\r\narbtrust: HashMap[address, bool]\r\n\r\n\r\n@internal\r\ndef _deallocate0(_debtor: address) -> uint256:\r\n    \"\"\"\r\n    @dev deallocate all funds from a wallet\r\n    @param _debtor The address to deallocate all the funds from.\r\n    @return An uint256 specifying the amount of scaled tokens remaining\r\n    \"\"\"\r\n    debtor: Account = self.accounts[_debtor]\r\n    slode: Lode = self.lodes[debtor.lode]\r\n    amount_e: uint256 = debtor.amount\r\n    if amount_e == 0:\r\n        self.accounts[_debtor] = empty(Account)\r\n        return 0\r\n    if debtor.expanse != slode.expanse:\r\n        amount_e = shift(debtor.amount, debtor.expanse - slode.expanse)\r\n    amount_s: uint256 = amount_e * slode.total / slode.total_e\r\n    self.accounts[_debtor] = empty(Account)\r\n    self.lodes[debtor.lode].total -= amount_s\r\n    self.lodes[debtor.lode].total_e -= amount_e\r\n    return amount_s\r\n\r\n@internal\r\ndef _deallocate(_debtor: address, _amount_s: uint256):\r\n    \"\"\"\r\n    @dev deallocate funds from a wallet\r\n    @param _debtor The address to deallocate the funds from.\r\n    @param _amount_s scaled amount of funds.\r\n    \"\"\"\r\n    debtor: Account = self.accounts[_debtor]\r\n    slode: Lode = self.lodes[debtor.lode]\r\n    if debtor.expanse != slode.expanse:\r\n        self.accounts[_debtor].amount = shift(debtor.amount, debtor.expanse - slode.expanse)\r\n        self.accounts[_debtor].expanse = slode.expanse\r\n    amount_e: uint256 = _amount_s * slode.total_e / slode.total\r\n    self.accounts[_debtor].amount -= amount_e\r\n    if self.accounts[_debtor].amount < self.scale:\r\n        amount_e += self.accounts[_debtor].amount\r\n        self.accounts[_debtor].amount = 0\r\n        amount_s: uint256 = amount_e * slode.total / slode.total_e\r\n        self.lodes[debtor.lode].total -= amount_s\r\n    else:\r\n        self.lodes[debtor.lode].total -= _amount_s\r\n    self.lodes[debtor.lode].total_e -= amount_e\r\n    if self.accounts[_debtor].amount == 0:\r\n        self.accounts[_debtor] = empty(Account)\r\n\r\n\r\n@internal\r\ndef _allocate(_creditor: address, _amount_s: uint256):\r\n    \"\"\"\r\n    @dev deallocate funds from a wallet and from a lode\r\n    @param _creditor The address to allocate the funds to.\r\n    @param _amount_s The address to allocate the scaled funds to.\r\n    \"\"\"\r\n    creditor: Account = self.accounts[_creditor]\r\n    if (creditor.amount ==0) and (creditor.lode ==0):\r\n        if _creditor.is_contract:\r\n            creditor.lode = FROZEN_LODE\r\n            self.accounts[_creditor].lode = FROZEN_LODE\r\n        else:\r\n            creditor.lode = self.currentLode\r\n            self.accounts[_creditor].lode = self.currentLode\r\n    dlode: Lode = self.lodes[creditor.lode]\r\n    if creditor.amount != 0:\r\n        self.accounts[_creditor].amount = shift(creditor.amount, creditor.expanse - dlode.expanse)\r\n    self.accounts[_creditor].expanse = dlode.expanse\r\n    if dlode.total_e == 0:\r\n        self.lodes[creditor.lode].total_e += _amount_s\r\n        self.accounts[_creditor].amount += _amount_s\r\n    else:\r\n        amount_e: uint256 = _amount_s * dlode.total_e / dlode.total\r\n        self.lodes[creditor.lode].total_e += amount_e\r\n        self.accounts[_creditor].amount += amount_e\r\n    self.lodes[creditor.lode].total += _amount_s\r\n\r\n\r\n\r\n@external\r\ndef setLode(_wallet:address, _lode:uint256):\r\n    \"\"\"\r\n    @dev set the lode of a wallet\r\n    @param _wallet The address of the wallet\r\n    @param _lode The lode to which to allocate the wallet\r\n    \"\"\"\r\n    if (msg.sender == self.owner):\r\n        assert (_lode < NUM_OF_LODES) #, \"Out of bounds lode\"\r\n    elif (self.privileged[msg.sender] == True):\r\n        assert _lode < NUM_OF_TEMPORAL_LODES #, \"Out of bounds lode or access to priviledged lode\"\r\n    else:\r\n        raise \"Unauthorized\"\r\n    amount: uint256 = self._deallocate0(_wallet)\r\n    self.accounts[_wallet].lode = _lode\r\n    self._allocate(_wallet, amount)\r\n\r\n@external\r\ndef setTaxStatus(_status: bool):\r\n    \"\"\"\r\n    @dev tax Status (On->True or Off)\r\n    @param _status status of tax\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    self.taxOn = _status\r\n\r\n@external\r\ndef setTax(_tax_id:uint256, _tax_numerators:uint256[NUM_OF_LODES], _tax_denominator:uint256):\r\n    \"\"\"\r\n    @dev set the taxes of a tax_id\r\n    @param _tax_id the tax id \r\n    @param _tax_numerators Tax numerator per lode\r\n    @param _tax_denominator Tax denominator\r\n    \"\"\"\r\n    assert (msg.sender == self.owner)\r\n    self.tax_numerators[_tax_id] = _tax_numerators\r\n    self.tax_denominator[_tax_id] = _tax_denominator\r\n    sum:uint256 = 0\r\n    for i in range(NUM_OF_LODES):\r\n        sum += _tax_numerators[i]\r\n    self.tax_numeratorsum[_tax_id] = sum\r\n        \r\n\r\n\r\n@external\r\ndef setLodeTaxId(_lode:uint256, _tax_id:uint256):\r\n    \"\"\"\r\n    @dev set the tax_id of a lode\r\n    @param _lode the lode number\r\n    @param _tax_id Tax id\r\n    \"\"\"\r\n    assert (msg.sender == self.owner)\r\n    self.lodes[_lode].tax_id = _tax_id\r\n\r\n@external\r\ndef setPrivileged(_wallet: address, _status: bool):\r\n    \"\"\"\r\n    @dev change Privileged status of wallet\r\n    @param _wallet The address of the wallet\r\n    @param _status Which status to set to the wallet\r\n    \"\"\"\r\n    assert (msg.sender == self.owner)\r\n    self.privileged[_wallet] = _status\r\n\r\n@external\r\ndef setArbTrusted(_wallet: address, _status: bool):\r\n    \"\"\"\r\n    @dev change ArbTrust status of wallet\r\n    @param _wallet The address of the wallet\r\n    @param _status Which status to set to the wallet\r\n    \"\"\"\r\n    assert (msg.sender == self.owner)\r\n    self.arbtrust[_wallet] = _status\r\n\r\n@view\r\n@external\r\ndef isPrivileged(_wallet: address) -> bool:\r\n    \"\"\"\r\n    @dev check Privileged status of wallet\r\n    @param _wallet The address of the wallet\r\n    @return A bool specifiying if the wallet is priviledged\r\n    \"\"\"\r\n    return self.privileged[_wallet]\r\n\r\n@view\r\n@external\r\ndef getLode(_wallet:address) -> uint256:\r\n    \"\"\"\r\n    @dev get account lode\r\n    @param _wallet The address of the wallet\r\n    @return An uint256 specifying the lode of the wallet\r\n    \"\"\"\r\n    assert (msg.sender == self.owner) or self.privileged[msg.sender]\r\n    return self.accounts[_wallet].lode\r\n\r\n\r\n@view\r\n@internal\r\ndef getBalance(_wallet : address) -> uint256:\r\n    \"\"\"\r\n    @dev get balance of wallet\r\n    @param _wallet The address of the wallet\r\n    @return An uint256 specifying the scaled balance of the wallet\r\n    \"\"\"\r\n    account: Account = self.accounts[_wallet]\r\n    lode: Lode = self.lodes[account.lode]\r\n    if lode.total_e == 0:\r\n        return 0\r\n    else:\r\n        return shift(account.amount, account.expanse - lode.expanse) * lode.total / lode.total_e\r\n\r\n@view\r\n@external\r\ndef balanceLode(_wallet : address) -> (uint256, uint256, uint256, int128, int128):\r\n    \"\"\"\r\n    @dev get detailed balance of a wallet\r\n    @param _wallet the wallet\r\n    @return internal balance of wallet, lode scaled balance, lode internal balance, account and lode expanse\r\n    \"\"\"\r\n    assert (msg.sender == self.owner) or self.privileged[msg.sender] or (_wallet == msg.sender)\r\n    account: Account = self.accounts[_wallet]\r\n    lode: Lode = self.lodes[account.lode]\r\n    return (account.amount, lode.total, lode.total_e, account.expanse, lode.expanse)\r\n\r\n@view\r\n@external\r\ndef lodeBalance(_lode: uint256) ->  (uint256, uint256, int128):\r\n    \"\"\"\r\n    @dev get balance of a lode\r\n    @param _lode lode number\r\n    @return lode scaled balance, lode internal balance and lode expanse\r\n    \"\"\"\r\n    assert (msg.sender == self.owner) or self.privileged[msg.sender]\r\n    lode: Lode = self.lodes[_lode]\r\n    return (lode.total, lode.total_e, lode.expanse)\r\n\r\n\r\n@external\r\ndef setLodeTaxFree(_lode: uint256, _itaxfree: bool, _etaxfree: bool):\r\n    \"\"\"\r\n    @dev set lode tax excemptions rules\r\n    @param _lode lode number\r\n    @param _itaxfree is tax free on credit\r\n    @param _etaxfree is tax free on debit\r\n    \"\"\"\r\n    assert (msg.sender == self.owner)\r\n    self.lodes[_lode].itaxfree = _itaxfree\r\n    self.lodes[_lode].etaxfree = _etaxfree\r\n\r\n@view\r\n@external\r\ndef getLodeTaxFree(_lode: uint256) -> (bool, bool, uint256):\r\n    \"\"\"\r\n    @dev get lode tax rules\r\n    @param _lode lode number\r\n    @return _itaxfree, _etaxfree and tax_id\r\n    \"\"\"\r\n    assert (msg.sender == self.owner) or self.privileged[msg.sender]\r\n    return (self.lodes[_lode].itaxfree, self.lodes[_lode].etaxfree, self.lodes[_lode].tax_id)\r\n\r\n\r\n@external\r\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256, _supply: uint256, _transferLocked: bool,\r\n    _tax_nums: uint256[NUM_OF_LODES], _tax_denom: uint256):\r\n    self.owner = msg.sender\r\n    self.tax_numerators[0] = _tax_nums\r\n    for i in range(NUM_OF_LODES):\r\n        self.tax_numeratorsum[0] += _tax_nums[i]\r\n    self.tax_denominator[0] = _tax_denom\r\n    self.tax_airdrop_num = 1\r\n    self.tax_airdrop_den = 20\r\n    self.temporal_tax_num = 10000\r\n    self.temporal_tax_num2 = 2664\r\n    self.temporal_tax_den = 30000\r\n    self.transferLocked = _transferLocked\r\n    self.taxOn = not _transferLocked\r\n    self.scale = 10 ** _decimals\r\n    init_supply: uint256 = _supply * 10 ** _decimals\r\n    self.extent = init_supply * self.scale\r\n    self.extent_max =  init_supply * self.scale * self.scale\r\n    a_supply: uint256 = init_supply * self.scale\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = _decimals\r\n    self.accounts[msg.sender].amount = a_supply\r\n    self.lodes[self.accounts[msg.sender].lode] = Lode({total: a_supply, total_e: a_supply, expanse: 0, itaxfree:False, etaxfree:False, tax_id:0})\r\n    self.lodes[STAKING_LODE] = Lode({total: 0, total_e: 0, expanse: 0, itaxfree: True, etaxfree: True, tax_id:0})    \r\n    self.lodes[RESERVE_LODE] = Lode({total: 0, total_e: 0, expanse: 0, itaxfree: True, etaxfree: False, tax_id:0})    \r\n    self.lodes[RESERVED1_LODE] = Lode({total: 0, total_e: 0, expanse: 0, itaxfree: True, etaxfree: True, tax_id:0})    \r\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n    log OwnershipTransferred(ZERO_ADDRESS, msg.sender)\r\n\r\n\r\n@view\r\n@external\r\ndef getOwner() -> address:\r\n    \"\"\"\r\n    @dev Returns the bep20 token owner which is necessary for binding with bep2 token.\r\n    @return address of owner\r\n    \"\"\"\r\n    return self.owner\r\n\r\n@view\r\n@external\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @dev Total number of tokens in existence. EIP-20 function totalSupply()\r\n    @return total supply\r\n    \"\"\"\r\n    sum:uint256 = 0\r\n    for i in range(NUM_OF_LODES):\r\n        sum += self.lodes[i].total\r\n    return sum / self.scale\r\n\r\n@view\r\n@external\r\ndef balanceOf(_wallet : address) -> uint256:\r\n    \"\"\"\r\n    @dev Total number of tokens in existence. EIP-20 function balanceOf(address _owner)\r\n    @return balance\r\n    \"\"\"\r\n    return self.getBalance(_wallet) / self.scale\r\n\r\n@view\r\n@external\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    \"\"\"\r\n    @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n         EIP-20 function allowance(address _owner, address _spender)\r\n    @param _owner The address which owns the funds.\r\n    @param _spender The address which will spend the funds.\r\n    @return An uint256 specifying the amount of tokens still available for the spender.\r\n    \"\"\"\r\n    return self.allowances[_owner][_spender]\r\n\r\n@external\r\ndef setTemporalTax(_num: uint256, _num2: uint256, _den: uint256):\r\n    \"\"\"\r\n    @dev modify the temporal tax\r\n    @param _num tax numerator\r\n    @param _num2 tax arb\r\n    @param _den tax denominator\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert _den != 0\r\n    self.temporal_tax_num = _num\r\n    self.temporal_tax_num2 = _num2\r\n    self.temporal_tax_den = _den\r\n\r\n@internal\r\ndef temporalTax() -> bool:\r\n    \"\"\"\r\n    @dev This function trigger a temporal tax event if required.\r\n    @return True if tax event happened, False otherwise\r\n    \"\"\"\r\n    if (self.initpulse != 0):\r\n        self.currentLode = ((self.nextpulse - self.initpulse) / 86400) % NUM_OF_TEMPORAL_LODES\r\n        if (block.timestamp > self.nextpulse):\r\n            tax: uint256 = self.lodes[self.currentLode].total * self.temporal_tax_num / self.temporal_tax_den\r\n            self.lodes[self.currentLode].total -= tax\r\n            self.lodes[RESERVE_LODE].total += tax\r\n            self.nextpulse += 86400\r\n            if self.currentLode == 0:\r\n                if (self.temporal_tax_den - self.temporal_tax_num) != 0:\r\n                    self.extent = self.extent * self.temporal_tax_den / (self.temporal_tax_den - self.temporal_tax_num)\r\n                    if self.extent  > self.extent_max:\r\n                        self.extent /= 2\r\n                        self.expanse += 1\r\n            if self.lodes[self.currentLode].expanse != self.expanse:\r\n                self.lodes[self.currentLode].total_e = shift(self.lodes[self.currentLode].total_e,\r\n                    self.lodes[self.currentLode].expanse - self.expanse)\r\n                self.lodes[self.currentLode].expanse = self.expanse\r\n            return True\r\n    return False\r\n\r\n@external\r\ndef changeTaxAirDrop(_num: uint256, _den:uint256):\r\n    assert (msg.sender == self.owner)\r\n    assert (_den != 0)\r\n    self.tax_airdrop_num = _num\r\n    self.tax_airdrop_den = _den\r\n\r\n@external\r\n@view\r\ndef simTaxAirDrop() -> uint256:\r\n    sum:uint256 = 0\r\n    for tax_id in range(NUM_OF_TAX_POLICIES):\r\n        tax:uint256 = self.tax_toflush[tax_id]\r\n        if tax != 0:\r\n            sum += tax * self.tax_airdrop_num / self.tax_airdrop_den\r\n    return sum/self.scale\r\n\r\n@internal\r\ndef distributeTax(_to:address):\r\n    airdrop:uint256 = 0\r\n    for tax_id in range(NUM_OF_TAX_POLICIES):\r\n        tax:uint256 = self.tax_toflush[tax_id]\r\n        if tax != 0:\r\n            airdrop0:uint256 = tax * self.tax_airdrop_num / self.tax_airdrop_den\r\n            airdrop += airdrop0\r\n            tax -= airdrop0\r\n            tax_num:uint256 = self.tax_numeratorsum[tax_id]\r\n            for i in range(NUM_OF_LODES):\r\n                self.lodes[i].total +=  tax * self.tax_numerators[tax_id][i] / tax_num\r\n        self.tax_toflush[tax_id] = 0\r\n    if airdrop != 0:\r\n        self._allocate(_to, airdrop)\r\n    self.temporalTax()\r\n\r\n            \r\n@external\r\ndef triggerDistributeTax():\r\n    self.distributeTax(msg.sender)\r\n\r\n@external\r\ndef triggerTemporalTax() -> bool:\r\n    \"\"\"\r\n    @dev This function trigger a temporal tax event if required.\r\n    @return True if tax event happened, False otherwise\r\n    \"\"\"\r\n    return self.temporalTax()\r\n\r\n@view\r\n@external\r\ndef transferedAfterTax(_debtor: address, _creditor: address, _value: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev evaluate amount sent during Transfer \r\n    @param _debtor The address to transfer from.\r\n    @param _creditor The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    @return amount remaining to be transferred\r\n    \"\"\"\r\n    amount: uint256 = _value * self.scale\r\n    d_lode: uint256 = self.accounts[_debtor].lode\r\n    c_lode: uint256 = self.accounts[_creditor].lode\r\n    tax_id: uint256 = self.lodes[d_lode].tax_id\r\n    if (not self.lodes[d_lode].etaxfree) and (not self.lodes[c_lode].itaxfree) and self.taxOn:\r\n        tax: uint256 = amount * self.tax_numeratorsum[tax_id] / self.tax_denominator[tax_id]\r\n        amount -= tax\r\n    if self.arbtrust[_debtor] and self.arbtrust[_creditor]:\r\n        tax:uint256 = amount * self.temporal_tax_num2 / self.temporal_tax_den\r\n        amount -= tax\r\n    return amount / self.scale\r\n\r\n\r\n@internal\r\ndef _transfer(_debtor: address, _creditor: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Transfer token for a specified address\r\n    @param _debtor The address to transfer from.\r\n    @param _creditor The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    #if (block.timestamp > self.nextpulse) and (self.initpulse != 0):\r\n    #    self.temporalTax()\r\n    amount: uint256 = _value * self.scale\r\n    d_lode: uint256 = self.accounts[_debtor].lode\r\n    c_lode: uint256 = self.accounts[_creditor].lode\r\n    tax_id: uint256 = self.lodes[d_lode].tax_id\r\n    self._deallocate(_debtor, amount)\r\n    if (not self.lodes[d_lode].etaxfree) and (not self.lodes[c_lode].itaxfree) and self.taxOn:\r\n        tax: uint256 = amount * self.tax_numeratorsum[tax_id] / self.tax_denominator[tax_id]\r\n        amount -= tax\r\n        self.tax_toflush[tax_id] += tax\r\n    if self.arbtrust[_debtor] and self.arbtrust[_creditor]:\r\n        tax:uint256 = amount * self.temporal_tax_num2 / self.temporal_tax_den\r\n        amount -= tax\r\n        self.lodes[RESERVED1_LODE].total += tax\r\n    if (self.initpulse != 0):\r\n        if (self.currentLode != d_lode) and (d_lode < NUM_OF_TEMPORAL_LODES):\r\n            amount0: uint256 = self._deallocate0(_debtor)\r\n            if amount0 != 0:\r\n                self.accounts[_debtor].lode = self.currentLode\r\n                self._allocate(_debtor, amount0)\r\n    self._allocate(_creditor, amount)\r\n\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer token for a specified address. EIP-20 function transfer(address _to, uint256 _value) \r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    assert (self.transferLocked == False) or self.privileged[msg.sender] or (msg.sender == self.owner), \"You are not allowed to make transfer\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    log Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @dev Transfer tokens from one address to another. EIP function transferFrom(address _from, address _to, uint256 _value) \r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n    \"\"\"\r\n    assert (self.transferLocked == False) or self.privileged[msg.sender] or self.privileged[_from] or (msg.sender == self.owner), \"You are not allowed to make transfer\"\r\n    self._transfer(_from, _to, _value)\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@internal\r\ndef _approve(_owner: address, _spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Approve the passed address to spend the specified amount of tokens on behalf of _owner.\r\n    @param _owner The address which will provide the funds.\r\n    @param _spender The address which will spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    \"\"\"\r\n    self.allowances[_owner][_spender] = _value\r\n    log Approval(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n         Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n         and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n         race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n         EIP-20 function approve(address _spender, uint256 _value)\r\n    \r\n    @param _spender The address which will spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    \"\"\"\r\n    self._approve(msg.sender, _spender,_value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender : address, _addedValue : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    This is an alternative to {approve} that can be used as a mitigation \r\n    for problems described in {IERC20-approve}.\r\n    Emits an {Approval} event indicating the updated allowance.\r\n    - `spender` cannot be the zero address.\r\n\r\n    @param _spender The address which will spend the funds.\r\n    @param _addedValue The amount of additional tokens to be spent.\r\n    \"\"\"\r\n    self._approve(msg.sender, _spender, self.allowances[msg.sender][_spender] + _addedValue)\r\n    return True\r\n\r\n@external\r\ndef decreaseAllowance(_spender : address, _subtractedValue : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    This is an alternative to {approve} that can be used as a mitigation \r\n    for problems described in {IERC20-approve}.\r\n    Emits an {Approval} event indicating the updated allowance.\r\n    - `spender` cannot be the zero address.\r\n    - `spender` must have allowance for the caller of at least __subtractedValue\r\n    @param _spender The address which will spend the funds.\r\n    @param _subtractedValue The amount of tokens to be Decreased from allowance.\r\n    \"\"\"\r\n    self._approve(msg.sender, _spender, self.allowances[msg.sender][_spender] - _subtractedValue)\r\n    return True\r\n\r\n@external\r\ndef startPulse():\r\n    \"\"\"\r\n    @dev start temporalTax Pulse\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    assert self.initpulse == 0\r\n    self.taxOn = True\r\n    self.initpulse = block.timestamp / 86400 * 86400\r\n    self.nextpulse = self.initpulse + 86400 * NUM_OF_TEMPORAL_LODES\r\n\r\n\r\n@external\r\ndef lockTransfer(_status: bool):\r\n    \"\"\"\r\n    @dev lock or unlock transfer\r\n    @param _status status of normal transfer\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    self.transferLocked = _status\r\n    \r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    \"\"\"\r\n    @dev Process ether received by default function\r\n    \"\"\"\r\n    log ReceivedEther(msg.sender, msg.value)\r\n\r\n\r\n@external\r\ndef withdrawEth(_amount: uint256):\r\n    \"\"\"\r\n    @dev Withdraw ether from smart contract\r\n    @param _amount number of wei \r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    send(self.owner, _amount)\r\n\r\n@internal\r\ndef _consume(_debtor: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Consume token of a specified address\r\n    @param _debtor The address to transfer from.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    amount: uint256 = _value * self.scale\r\n    dtotal: uint256 = 0\r\n    tax_id: uint256 = self.lodes[self.accounts[_debtor].lode].tax_id\r\n    self._deallocate(_debtor, amount)\r\n    for i in range(NUM_OF_LODES):\r\n        dtotal += self.tax_denominator[tax_id]\r\n    if dtotal ==0:\r\n        self.lodes[STAKING_LODE].total += amount\r\n    else:\r\n        for i in range(NUM_OF_LODES):\r\n            self.lodes[i].total += amount * self.tax_numerators[tax_id][i] / dtotal\r\n\r\n\r\n@external\r\ndef consume(_value: uint256):\r\n    \"\"\"\r\n    @dev Consume token of sender\r\n    @param _value The amount to be consumed.\r\n    \"\"\"\r\n    self._consume(msg.sender, _value)\r\n    \r\n@external\r\ndef consumeFrom(_wallet: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Consume token of sender\r\n    @param _wallet the wallet to \r\n    @param _value The amount to be consumed\r\n    \"\"\"\r\n    assert (msg.sender == self.owner)\r\n    assert self.accounts[_wallet].lode == FROZEN_LODE\r\n    self._consume(_wallet, _value)\r\n\r\n@internal\r\ndef _burn(_to: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Internal function that burns an amount of the token of a given\r\n         account.\r\n    @param _to The account whose tokens will be burned.\r\n    @param _value The amount that will be burned.\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS\r\n    self._deallocate(_to, _value * self.scale)\r\n    log Transfer(_to, ZERO_ADDRESS, _value)\r\n\r\n\r\n@external\r\ndef burn(_value: uint256):\r\n    \"\"\"\r\n    @dev Burn an amount of the token of msg.sender.\r\n    @param _value The amount that will be burned.\r\n    \"\"\"\r\n    self._burn(msg.sender, _value)\r\n\r\n\r\n@external\r\ndef burnFrom(_to: address, _value: uint256):\r\n    \"\"\"\r\n    @dev Burn an amount of the token from a given account.\r\n    @param _to The account whose tokens will be burned.\r\n    @param _value The amount that will be burned.\r\n    \"\"\"\r\n    self.allowances[_to][msg.sender] -= _value\r\n    self._burn(_to, _value)\r\n\r\n@external\r\ndef transferOwnership(_owner: address):\r\n    assert msg.sender == self.owner\r\n    assert _owner != ZERO_ADDRESS\r\n    log OwnershipTransferred(self.owner, _owner)\r\n    self.owner = _owner\r\n    \r\n\r\n@external\r\ndef xtransfer(_token: address, _creditor : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Relay ERC-20 transfer request \r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    return ERC20(_token).transfer(_creditor, _value)\r\n\r\n\r\n@external\r\ndef xapprove(_token: address, _spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Relay ERC-20 approve request \r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n    return ERC20(_token).approve(_spender, _value)", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ReceivedEther\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"previousOwner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"newOwner\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setLode\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_lode\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":466596},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setTaxStatus\",\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":36365},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setTax\",\"inputs\":[{\"name\":\"_tax_id\",\"type\":\"uint256\"},{\"name\":\"_tax_numerators\",\"type\":\"uint256[32]\"},{\"name\":\"_tax_denominator\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":1202964},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setLodeTaxId\",\"inputs\":[{\"name\":\"_lode\",\"type\":\"uint256\"},{\"name\":\"_tax_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":36512},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setPrivileged\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":36670},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setArbTrusted\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":36700},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isPrivileged\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1573},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getLode\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3527},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceLode\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"int128\"},{\"name\":\"\",\"type\":\"int128\"}],\"gas\":11531},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lodeBalance\",\"inputs\":[{\"name\":\"_lode\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"int128\"}],\"gas\":8379},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setLodeTaxFree\",\"inputs\":[{\"name\":\"_lode\",\"type\":\"uint256\"},{\"name\":\"_itaxfree\",\"type\":\"bool\"},{\"name\":\"_etaxfree\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":72118},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getLodeTaxFree\",\"inputs\":[{\"name\":\"_lode\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5858},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_transferLocked\",\"type\":\"bool\"},{\"name\":\"_tax_nums\",\"type\":\"uint256[32]\"},{\"name\":\"_tax_denom\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getOwner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1538},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":42055},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":11576},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2058},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setTemporalTax\",\"inputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_num2\",\"type\":\"uint256\"},{\"name\":\"_den\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":106830},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"changeTaxAirDrop\",\"inputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_den\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":71851},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"simTaxAirDrop\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":27240},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"triggerDistributeTax\",\"inputs\":[],\"outputs\":[],\"gas\":10978015},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"triggerTemporalTax\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":348617},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"transferedAfterTax\",\"inputs\":[{\"name\":\"_debtor\",\"type\":\"address\"},{\"name\":\"_creditor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":15379},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1988022},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2025300},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":39832},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":41061},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":41085},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"startPulse\",\"inputs\":[],\"outputs\":[],\"gas\":109209},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"lockTransfer\",\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":37175},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdrawEth\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":37705},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"consume\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":1795660},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"consumeFrom\",\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":1797774},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":552847},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burnFrom\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":589198},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferOwnership\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39770},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"xtransfer\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_creditor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3541},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"xapprove\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3571},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":8690},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":7743},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2348},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"scale\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"expanse\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":2408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"extent\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"extent_max\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initpulse\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nextpulse\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2528},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"currentLode\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"transferLocked\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2588},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"taxOn\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"temporal_tax_num\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2648},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"temporal_tax_num2\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2678},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"temporal_tax_den\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2708},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tax_numerators\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2956},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tax_numeratorsum\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2877},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tax_denominator\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2907},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tax_toflush\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2937},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tax_airdrop_num\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2858},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tax_airdrop_den\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2888}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.11", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000004c00000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000000000000a456e726561636844414f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044e52434800000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}