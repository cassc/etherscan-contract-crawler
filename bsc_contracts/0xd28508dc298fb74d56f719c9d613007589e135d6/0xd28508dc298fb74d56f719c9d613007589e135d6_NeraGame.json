{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC1155Sort.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {RBTreeUint64} from \\\"./RBTreeUint64.sol\\\";\\nimport {IMetaDescriptor} from \\\"./IMetaDescriptor.sol\\\";\\nimport {RefNFTHelper} from \\\"./RefNFTHelper.sol\\\";\\n\\n/// @dev ERC1155 with holders list\\nabstract contract ERC1155Sort {\\n    using RBTreeUint64 for RBTreeUint64.Tree;\\n    using RefNFTHelper for RefNFTHelper.State;\\n\\n    error NotAuthorized();\\n    error LackOfBalance();\\n    error UnsafeRecipient();\\n    error LengthMismatch();\\n\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 amount);\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    IMetaDescriptor internal _metaDescriptor;\\n    RefNFTHelper.State internal _refNft;\\n    mapping(uint256 => RBTreeUint64.Tree) private _balances;\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    function name() external view returns (string memory) {\\n        return _metaDescriptor.getTokenName();\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return _metaDescriptor.getTokenSymbol();\\n    }\\n\\n    function uri(uint256 id) external view returns (string memory) {\\n        return _metaDescriptor.getTokenURI(id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function _transferById(uint64 fromRefId, uint64 toRefId, uint256 id, uint256 amount) internal {\\n        // if (_balances[id].val(fromRefId) < amount) revert LackOfBalance();\\n        _balances[id].sub(fromRefId, amount);\\n        _balances[id].add(toRefId, amount);\\n    }\\n\\n    function _transferMultiById(uint64[] memory fromRefIds, uint64 toRefId, uint256 id, uint256 amount) internal {\\n        uint256 balance;\\n        for (uint256 i; i < fromRefIds.length;) {\\n            balance = _balances[id].val(fromRefIds[i]);\\n            if (amount <= balance) {\\n                _transferById(fromRefIds[i], toRefId, id, amount);\\n                amount = 0;\\n                break;\\n            } else {\\n                _transferById(fromRefIds[i], toRefId, id, balance);\\n                unchecked {\\n                    amount -= balance;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (amount > 0) revert LackOfBalance();\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external {\\n        if (to == address(0)) revert UnsafeRecipient();\\n        if (msg.sender != from && !isApprovedForAll[from][msg.sender]) revert NotAuthorized();\\n\\n        uint64[] memory fromRefIds = _refNft.tokensOf(from);\\n        if (fromRefIds.length == 0) revert LackOfBalance();\\n        (uint64 toRefId,,) = _refNft.register(to, fromRefIds[0]);\\n\\n        _transferMultiById(fromRefIds, toRefId, id, amount);\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n        _checkSafe(from, to, id, amount, data);\\n    }\\n\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external {\\n        if (to == address(0)) revert UnsafeRecipient();\\n        if (ids.length != amounts.length) revert LengthMismatch();\\n        if (msg.sender != from && !isApprovedForAll[from][msg.sender]) revert NotAuthorized();\\n\\n        uint64[] memory fromRefIds = _refNft.tokensOf(from);\\n        if (fromRefIds.length == 0) revert LackOfBalance();\\n        (uint64 toRefId,,) = _refNft.register(to, fromRefIds[0]);\\n        for (uint256 i = 0; i < ids.length;) {\\n            _transferMultiById(fromRefIds, toRefId, ids[i], amounts[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n        if (\\n            to.code.length != 0\\n                && ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) != ERC1155TokenReceiver.onERC1155BatchReceived.selector\\n        ) revert UnsafeRecipient();\\n    }\\n\\n    function balanceOfRefId(uint64 ownerId, uint256 id) public view returns (uint256) {\\n        return _balances[id].val(ownerId);\\n    }\\n\\n    function balanceOf(address owner, uint256 id) public view returns (uint256 balance) {\\n        uint64[] memory ownerIds = _refNft.tokensOf(owner);\\n        for (uint256 i; i < ownerIds.length;) {\\n            balance += balanceOfRefId(ownerIds[i], id);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory balances) {\\n        if (owners.length != ids.length) revert LengthMismatch();\\n\\n        balances = new uint256[](owners.length);\\n        unchecked {\\n            for (uint256 i; i < owners.length; ++i) {\\n                balances[i] = balanceOf(owners[i], ids[i]);\\n            }\\n        }\\n    }\\n\\n    function ownerIdsTop(uint256 id, uint256 count) public view returns (uint64[] memory ownerIds, uint256[] memory balances) {\\n        ownerIds = new uint64[](count);\\n        balances = new uint256[](count);\\n        uint64 ownerId = _balances[id].first();\\n        uint256 i;\\n        for (i; i < count;) {\\n            if (ownerId == 0) {\\n                break;\\n            }\\n            ownerIds[i] = ownerId;\\n            balances[i] = _balances[id].val(ownerId);\\n            ownerId = _balances[id].next(ownerId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // shrink array\\n        if (i < count) {\\n            uint256 trim = count - i;\\n            assembly {\\n                mstore(ownerIds, sub(mload(ownerIds), trim))\\n                mstore(balances, sub(mload(balances), trim))\\n            }\\n        }\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view virtual returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            || interfaceId == 0xd9b67a26 // ERC165 Interface ID for ERC1155\\n            || interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    function _mintRefId(uint64 toRefId, uint256 id, uint256 amount) internal {\\n        // get and check toRefId existense\\n        address to = _refNft.ownerOf(toRefId);\\n        _balances[id].add(toRefId, amount);\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n        _checkSafe(address(0), to, id, amount, \\\"\\\");\\n    }\\n\\n    function _checkSafe(address from, address to, uint256 id, uint256 amount, bytes memory data) internal {\\n        if (\\n            to.code.length != 0\\n                && ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) != ERC1155TokenReceiver.onERC1155Received.selector\\n        ) revert UnsafeRecipient();\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GameCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\nimport {Utils} from \\\"./Utils.sol\\\";\\n/// @dev Game Queue logic\\n\\nlibrary GameCore {\\n    uint64 public constant ENTER_HOPS = 3;\\n    uint64 public constant MAX_HOPS = ENTER_HOPS * 3;\\n\\n    error BadValue();\\n    error MaxEntersReached();\\n\\n    struct GameQueue {\\n        uint64[] userIds;\\n        mapping(uint64 => uint64) idxs;\\n    }\\n\\n    struct UserGameState {\\n        uint64 enters;\\n        uint64 hops;\\n        uint96 rewardTotal;\\n        uint96 refRewardTotal;\\n        uint96 missedRefRewardTotal;\\n        uint96 gamePrizeTotal;\\n    }\\n\\n    struct GameState {\\n        uint64 enters;\\n        uint96 rewardTotal;\\n        uint96 refRewardTotal;\\n        uint96 missedRefRewardTotal;\\n        uint96 gamePrizeTotal;\\n    }\\n\\n    struct GameTop {\\n        uint96 fund;\\n        uint64 enters;\\n    }\\n\\n    struct Game {\\n        uint96 price;\\n        GameState state;\\n        GameTop top;\\n        uint64[] queue;\\n        mapping(uint64 => uint256) idxs;\\n        mapping(uint64 => UserGameState) users;\\n    }\\n\\n    /// @return uint64 completet game hops\\n    /// @return uint64 max game hops\\n    /// @return uint96 gotten game reward\\n    /// @return uint96 max game reward\\n    function userProgress(Game storage self, uint64 userId, uint8 rewardPcnt) external view returns (uint64, uint64, uint96, uint96) {\\n        uint64 curEnters = self.users[userId].enters;\\n        if (curEnters == 0) {\\n            return (0, 0, 0, 0);\\n        }\\n        uint64 totalMaxHops = curEnters * MAX_HOPS;\\n        uint64 totalHops = totalMaxHops - self.users[userId].hops;\\n        uint96 reward = Utils._pcnt(self.price, rewardPcnt);\\n        return (totalHops, totalMaxHops, reward * uint96(totalHops), reward * uint96(totalMaxHops));\\n    }\\n\\n\\n    function enterQueue(Game storage self, uint64 userId, uint96 value, uint8 rewardPcnt)\\n        external\\n        returns (uint64[] memory upIds, uint96 reward, uint64 enters)\\n    {\\n        if (value != self.price) revert BadValue();\\n        if (self.users[userId].hops > MAX_HOPS) revert MaxEntersReached();\\n\\n        uint256 len = self.queue.length;\\n        upIds = new uint64[](ENTER_HOPS);\\n\\n        if (len > 0) {\\n            uint256[] memory idxs = new uint256[](ENTER_HOPS);\\n            uint256 salt = Utils._random(userId);\\n            unchecked {\\n                reward = Utils._pcnt(value, rewardPcnt); //reward per 1 hop , 25%\\n            }\\n            for (uint256 i; i < ENTER_HOPS;) {\\n                if (len > 2 && i > 0) {\\n                    bool ok = true;\\n                    uint256 k;\\n                    uint256 j;\\n                    do {\\n                        idxs[i] = salt % len;\\n                        for (j = 0; j < i;) {\\n                            if (idxs[i] == idxs[j]) {\\n                                ok = false;\\n                                salt >>= 1;\\n                                break;\\n                            }\\n                            unchecked {\\n                                ++j;\\n                            }\\n                        }\\n                        unchecked {\\n                            ++k;\\n                        }\\n                    } while (!ok && k < 7);\\n                } else {\\n                    idxs[i] = len > 1 ? (salt % len) : 0;\\n                }\\n                upIds[i] = self.queue[idxs[i]];\\n\\n                if (self.users[upIds[i]].hops == 1) {\\n                    // if item's remain hops=1 - the cuurent hop is the last one, so del item from queue\\n                    len--;\\n                    delete self.idxs[upIds[i]];\\n                    if (len != idxs[i]) {\\n                        uint64 lastUserId = self.queue[len];\\n                        self.queue[idxs[i]] = lastUserId;\\n                        self.idxs[lastUserId] = idxs[i] + 1;\\n                    }\\n                    self.queue.pop();\\n                }\\n                self.users[upIds[i]].hops -= 1;\\n                self.users[upIds[i]].rewardTotal += reward;\\n                unchecked {\\n                    salt >>= 1;\\n                    ++i;\\n                }\\n            }\\n        } // else its 1st enter, so reward = 0\\n        //inc total game enters & reward\\n        self.state.enters++;\\n        self.state.rewardTotal += reward * ENTER_HOPS;\\n\\n        //update queue\\n        if (self.idxs[userId] == 0) {\\n            self.queue.push(userId);\\n            self.idxs[userId] = self.queue.length;\\n        }\\n\\n        // inc total user game enters & remain hops\\n        enters = self.users[userId].enters + 1;\\n        self.users[userId].enters = enters;\\n        self.users[userId].hops += MAX_HOPS;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IMetaDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title Interface defining INFTDescriptor to generate ERC721/ERC1155 token meta data\\n */\\ninterface IMetaDescriptor {\\n    function getTokenURI(uint256 tokenId) external view returns (string memory);\\n    function getTokenName() external view returns (string memory);\\n    function getTokenSymbol() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IReferralNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IReferralNFT {\\n    function ownerOf(uint64 id) external view returns (address);\\n    function balanceOf(address owner) external view returns (uint64);\\n    function tokensOf(address owner) external view returns (uint64[] memory);\\n    function upIdOf(uint64 id) external view returns (uint64);\\n    function register(address owner, uint64 refId) external returns (uint64 id, bool isNew, bool isUpExists);\\n    function pay(uint64 refId) external payable;\\n    function tokenOfByIndex(address owner, uint64 index) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RBTreeUint64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n/// @dev Red Black Tree implementation\\n///      based on https://github.com/perpdex/BokkyPooBahsRedBlackTreeLibrary\\nlibrary RBTreeUint64 {\\n    struct Node {\\n        bool red;\\n        uint64 parent;\\n        uint64 left;\\n        uint64 right;\\n        uint256 value;\\n    }\\n\\n    struct Tree {\\n        uint64 root;\\n        mapping(uint64 => Node) nodes;\\n    }\\n\\n    uint64 internal constant EMPTY = 0;\\n\\n    function first(Tree storage self) internal view returns (uint64 _key) {\\n        _key = self.root;\\n        if (_key != EMPTY) {\\n            while (self.nodes[_key].left != EMPTY) {\\n                _key = self.nodes[_key].left;\\n            }\\n        }\\n    }\\n\\n    function last(Tree storage self) internal view returns (uint64 _key) {\\n        _key = self.root;\\n        if (_key != EMPTY) {\\n            while (self.nodes[_key].right != EMPTY) {\\n                _key = self.nodes[_key].right;\\n            }\\n        }\\n    }\\n\\n    function next(Tree storage self, uint64 target) internal view returns (uint64 cursor) {\\n        require(target != EMPTY);\\n        if (self.nodes[target].right != EMPTY) {\\n            cursor = _treeMinimum(self, self.nodes[target].right);\\n        } else {\\n            cursor = self.nodes[target].parent;\\n            while (cursor != EMPTY && target == self.nodes[cursor].right) {\\n                target = cursor;\\n                cursor = self.nodes[cursor].parent;\\n            }\\n        }\\n    }\\n\\n    function prev(Tree storage self, uint64 target) internal view returns (uint64 cursor) {\\n        require(target != EMPTY);\\n        if (self.nodes[target].left != EMPTY) {\\n            cursor = _treeMaximum(self, self.nodes[target].left);\\n        } else {\\n            cursor = self.nodes[target].parent;\\n            while (cursor != EMPTY && target == self.nodes[cursor].left) {\\n                target = cursor;\\n                cursor = self.nodes[cursor].parent;\\n            }\\n        }\\n    }\\n\\n    function exists(Tree storage self, uint64 key) internal view returns (bool) {\\n        return (key != EMPTY) && ((key == self.root) || (self.nodes[key].parent != EMPTY));\\n    }\\n\\n    function val(Tree storage self, uint64 key) internal view returns (uint256) {\\n        if (exists(self, key)) return self.nodes[key].value;\\n        return 0;\\n    }\\n\\n    function add(\\n        Tree storage self,\\n        uint64 key,\\n        uint256 value\\n    ) internal {\\n        require(key != EMPTY);\\n        if (exists(self, key)) {\\n            value = self.nodes[key].value + value;\\n            _remove(self, key);\\n        }\\n        if (value > 0) {\\n            _insert(self, key, value);\\n        }\\n    }\\n\\n    function sub(\\n        Tree storage self,\\n        uint64 key,\\n        uint256 value\\n    ) internal {\\n        require(key != EMPTY);\\n        require(exists(self, key));\\n        value = self.nodes[key].value - value;\\n        _remove(self, key);\\n        if (value > 0) {\\n            _insert(self, key, value);\\n        }\\n    }\\n\\n    function _insert(\\n        Tree storage self,\\n        uint64 key,\\n        uint256 value\\n    ) private {\\n        uint64 cursor = EMPTY;\\n        uint64 probe = self.root;\\n        while (probe != EMPTY) {\\n            cursor = probe;\\n            // DESC\\n            if (value > self.nodes[probe].value) {\\n                probe = self.nodes[probe].left;\\n            } else {\\n                probe = self.nodes[probe].right;\\n            }\\n        }\\n        self.nodes[key] = Node({parent: cursor, left: EMPTY, right: EMPTY, red: true, value: value});\\n        if (cursor == EMPTY) {\\n            self.root = key;\\n        } else if (value > self.nodes[cursor].value) {\\n            self.nodes[cursor].left = key;\\n        } else {\\n            self.nodes[cursor].right = key;\\n        }\\n        _insertFixup(self, key);\\n    }\\n\\n    function _remove(Tree storage self, uint64 key) private {\\n        uint64 probe;\\n        uint64 cursor;\\n        if (self.nodes[key].left == EMPTY || self.nodes[key].right == EMPTY) {\\n            cursor = key;\\n        } else {\\n            cursor = self.nodes[key].right;\\n            while (self.nodes[cursor].left != EMPTY) {\\n                cursor = self.nodes[cursor].left;\\n            }\\n        }\\n        if (self.nodes[cursor].left != EMPTY) {\\n            probe = self.nodes[cursor].left;\\n        } else {\\n            probe = self.nodes[cursor].right;\\n        }\\n        uint64 yParent = self.nodes[cursor].parent;\\n        self.nodes[probe].parent = yParent;\\n        if (yParent != EMPTY) {\\n            if (cursor == self.nodes[yParent].left) {\\n                self.nodes[yParent].left = probe;\\n            } else {\\n                self.nodes[yParent].right = probe;\\n            }\\n        } else {\\n            self.root = probe;\\n        }\\n        bool doFixup = !self.nodes[cursor].red;\\n        if (cursor != key) {\\n            _replaceParent(self, cursor, key);\\n            self.nodes[cursor].left = self.nodes[key].left;\\n            self.nodes[self.nodes[cursor].left].parent = cursor;\\n            self.nodes[cursor].right = self.nodes[key].right;\\n            self.nodes[self.nodes[cursor].right].parent = cursor;\\n            self.nodes[cursor].value = self.nodes[key].value;\\n            self.nodes[cursor].red = self.nodes[key].red;\\n            (cursor, key) = (key, cursor);\\n        }\\n        if (doFixup) {\\n            _removeFixup(self, probe);\\n        }\\n        delete self.nodes[cursor];\\n    }\\n\\n    function _treeMinimum(Tree storage self, uint64 key) private view returns (uint64) {\\n        while (self.nodes[key].left != EMPTY) {\\n            key = self.nodes[key].left;\\n        }\\n        return key;\\n    }\\n\\n    function _treeMaximum(Tree storage self, uint64 key) private view returns (uint64) {\\n        while (self.nodes[key].right != EMPTY) {\\n            key = self.nodes[key].right;\\n        }\\n        return key;\\n    }\\n\\n    function _rotateLeft(Tree storage self, uint64 key) private {\\n        uint64 cursor = self.nodes[key].right;\\n        uint64 keyParent = self.nodes[key].parent;\\n        uint64 cursorLeft = self.nodes[cursor].left;\\n        self.nodes[key].right = cursorLeft;\\n        if (cursorLeft != EMPTY) {\\n            self.nodes[cursorLeft].parent = key;\\n        }\\n        self.nodes[cursor].parent = keyParent;\\n        if (keyParent == EMPTY) {\\n            self.root = cursor;\\n        } else if (key == self.nodes[keyParent].left) {\\n            self.nodes[keyParent].left = cursor;\\n        } else {\\n            self.nodes[keyParent].right = cursor;\\n        }\\n        self.nodes[cursor].left = key;\\n        self.nodes[key].parent = cursor;\\n    }\\n\\n    function _rotateRight(Tree storage self, uint64 key) private {\\n        uint64 cursor = self.nodes[key].left;\\n        uint64 keyParent = self.nodes[key].parent;\\n        uint64 cursorRight = self.nodes[cursor].right;\\n        self.nodes[key].left = cursorRight;\\n        if (cursorRight != EMPTY) {\\n            self.nodes[cursorRight].parent = key;\\n        }\\n        self.nodes[cursor].parent = keyParent;\\n        if (keyParent == EMPTY) {\\n            self.root = cursor;\\n        } else if (key == self.nodes[keyParent].right) {\\n            self.nodes[keyParent].right = cursor;\\n        } else {\\n            self.nodes[keyParent].left = cursor;\\n        }\\n        self.nodes[cursor].right = key;\\n        self.nodes[key].parent = cursor;\\n    }\\n\\n    function _insertFixup(Tree storage self, uint64 key) private {\\n        uint64 cursor;\\n        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\\n            uint64 keyParent = self.nodes[key].parent;\\n            if (keyParent == self.nodes[self.nodes[keyParent].parent].left) {\\n                cursor = self.nodes[self.nodes[keyParent].parent].right;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    key = self.nodes[keyParent].parent;\\n                } else {\\n                    if (key == self.nodes[keyParent].right) {\\n                        key = keyParent;\\n                        _rotateLeft(self, key);\\n                    }\\n                    keyParent = self.nodes[key].parent;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    _rotateRight(self, self.nodes[keyParent].parent);\\n                }\\n            } else {\\n                cursor = self.nodes[self.nodes[keyParent].parent].left;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    key = self.nodes[keyParent].parent;\\n                } else {\\n                    if (key == self.nodes[keyParent].left) {\\n                        key = keyParent;\\n                        _rotateRight(self, key);\\n                    }\\n                    keyParent = self.nodes[key].parent;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[keyParent].parent].red = true;\\n                    _rotateLeft(self, self.nodes[keyParent].parent);\\n                }\\n            }\\n        }\\n        self.nodes[self.root].red = false;\\n    }\\n\\n    function _replaceParent(\\n        Tree storage self,\\n        uint64 a,\\n        uint64 b\\n    ) private {\\n        uint64 bParent = self.nodes[b].parent;\\n        self.nodes[a].parent = bParent;\\n        if (bParent == EMPTY) {\\n            self.root = a;\\n        } else {\\n            if (b == self.nodes[bParent].left) {\\n                self.nodes[bParent].left = a;\\n            } else {\\n                self.nodes[bParent].right = a;\\n            }\\n        }\\n    }\\n\\n    function _removeFixup(Tree storage self, uint64 key) private {\\n        uint64 cursor;\\n        while (key != self.root && !self.nodes[key].red) {\\n            uint64 keyParent = self.nodes[key].parent;\\n            if (key == self.nodes[keyParent].left) {\\n                cursor = self.nodes[keyParent].right;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[keyParent].red = true;\\n                    _rotateLeft(self, keyParent);\\n                    cursor = self.nodes[keyParent].right;\\n                }\\n                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\\n                    self.nodes[cursor].red = true;\\n                    key = keyParent;\\n                } else {\\n                    if (!self.nodes[self.nodes[cursor].right].red) {\\n                        self.nodes[self.nodes[cursor].left].red = false;\\n                        self.nodes[cursor].red = true;\\n                        _rotateRight(self, cursor);\\n                        cursor = self.nodes[keyParent].right;\\n                    }\\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[cursor].right].red = false;\\n                    _rotateLeft(self, keyParent);\\n                    key = self.root;\\n                }\\n            } else {\\n                cursor = self.nodes[keyParent].left;\\n                if (self.nodes[cursor].red) {\\n                    self.nodes[cursor].red = false;\\n                    self.nodes[keyParent].red = true;\\n                    _rotateRight(self, keyParent);\\n                    cursor = self.nodes[keyParent].left;\\n                }\\n                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\\n                    self.nodes[cursor].red = true;\\n                    key = keyParent;\\n                } else {\\n                    if (!self.nodes[self.nodes[cursor].left].red) {\\n                        self.nodes[self.nodes[cursor].right].red = false;\\n                        self.nodes[cursor].red = true;\\n                        _rotateLeft(self, cursor);\\n                        cursor = self.nodes[keyParent].left;\\n                    }\\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\\n                    self.nodes[keyParent].red = false;\\n                    self.nodes[self.nodes[cursor].left].red = false;\\n                    _rotateRight(self, keyParent);\\n                    key = self.root;\\n                }\\n            }\\n        }\\n        self.nodes[key].red = false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RefNFTHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {IReferralNFT} from \\\"./IReferralNFT.sol\\\";\\n\\nlibrary RefNFTHelper {\\n    struct State {\\n        IReferralNFT referralNft;\\n    }\\n\\n    function set(State storage self, address referralNft) internal {\\n        self.referralNft = IReferralNFT(referralNft);\\n    }\\n\\n    function idOf(State storage self, address owner) internal view returns (uint64) {\\n        if (self.referralNft.balanceOf(owner) == 0) return 0;\\n        return self.referralNft.tokenOfByIndex(owner, 0);\\n    }\\n\\n    function tokensOf(State storage self, address owner) internal view returns (uint64[] memory) {\\n        return self.referralNft.tokensOf(owner);\\n    }\\n\\n    function upIdOf(State storage self, uint64 id) internal view returns (uint64) {\\n        return self.referralNft.upIdOf(id);\\n    }\\n\\n    function pay(State storage self, uint64 id, uint256 value) internal {\\n        self.referralNft.pay{value: value}(id);\\n    }\\n\\n    function ownerOf(State storage self, uint64 id) internal view returns (address) {\\n        return self.referralNft.ownerOf(id);\\n    }\\n\\n    //uint64 id, bool isNew\\n    function register(State storage self, address owner, uint64 upId) internal returns (uint64, bool, bool) {\\n        return self.referralNft.register(owner, upId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nlibrary Utils {\\n    error SenderNotEOA();\\n    error TxFail();\\n\\n    function _checkEOA() internal view {\\n        if (msg.sender != tx.origin) revert SenderNotEOA();\\n    }\\n\\n    function _tx(address wallet, uint256 value) internal {\\n        if (value > 0) {\\n            (bool ok,) = payable(wallet).call{value: value}(\\\"\\\");\\n            if (!ok) revert TxFail();\\n        }\\n    }\\n\\n    function _random(uint256 seed) internal view returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(seed, msg.sender, gasleft(), block.coinbase, block.difficulty, block.gaslimit, block.timestamp)));\\n    }\\n\\n    function _pcnt(uint96 value, uint96 pcnt) internal pure returns (uint96) {\\n        return (value / 100) * pcnt;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NeraGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {ERC1155Sort} from \\\"./lib/ERC1155Sort.sol\\\";\\nimport {RefNFTHelper} from \\\"./lib/RefNFTHelper.sol\\\";\\nimport {IMetaDescriptor} from \\\"./lib/IMetaDescriptor.sol\\\";\\nimport {GameCore} from \\\"./lib/GameCore.sol\\\";\\nimport {Utils} from \\\"./lib/Utils.sol\\\";\\n\\ncontract NeraGame is ReentrancyGuard, ERC1155Sort {\\n    using GameCore for GameCore.Game;\\n    using RefNFTHelper for RefNFTHelper.State;\\n\\n    uint8 public constant MEGA_TOKEN_ID = 255;\\n    uint8 public constant TOTAL_GAMES = 6;\\n    uint8 public constant REF_LEVELS = 5;\\n\\n    error BadValue();\\n    error BadGameId();\\n    error GameStartConflict();\\n    error MaxEntersReached();\\n    error RaffleNotReady();\\n    error TopListEmpty();\\n    error AlreadyRegistered();\\n\\n    event Enter(uint64 indexed userId, uint8 indexed gameId, uint64 level);\\n    event Reward(uint64 indexed userId, uint8 indexed gameId, uint96 reward, uint64 fromId);\\n    event ReferralReward(uint64 indexed userId, uint8 indexed gameId, uint96 reward, uint64 refId, uint8 refLevel);\\n    event MissedReferralReward(uint64 indexed userId, uint8 indexed gameId, uint96 reward, uint64 refId, uint8 refLevel);\\n    event GamePrizeFund(uint8 indexed gameId, uint96 amount);\\n    event GamePrizeRaffle(uint64 indexed userId, uint8 indexed gameId, uint96 amount);\\n    event GamePrizeRaffled(uint8 indexed gameId, uint96 amount);\\n    event GamePrizeReady(uint8 indexed gameId, uint96 amount);\\n    event FomoRaffle(uint64 indexed userId, uint96 amount);\\n    event FomoUpdate(uint64 indexed userId, uint64 raffleAt, uint96 amount);\\n\\n    struct UserState {\\n        uint96 rewardTotal;\\n        uint96 refRewardTotal;\\n        uint96 missedRefRewardTotal;\\n        uint96 gamePrizeTotal;\\n        uint96 fomoTotal;\\n    }\\n\\n    struct Fomo {\\n        uint96 fund;\\n        uint64 raffleAt;\\n        uint64 userId;\\n        uint96 fomoTotal;\\n    }\\n\\n    struct GameParams {\\n        uint64 startTime;\\n        uint64 registerRemainCount;\\n    }\\n\\n    uint64 public immutable TOP_LIST_COUNT; // = 10;\\n    uint64 public immutable GAME_PRIZE_ENTERS; // = 100;\\n    uint64 public immutable MEGA_PRIZE_ENTERS; // = 20;\\n    uint64 private immutable _START_TIME_PERIOD; // = 1 days;\\n    uint64 private immutable _START_TIME_OFFSET; // = 90 hours;\\n    address private immutable SYS_WALLET;\\n    uint96 public immutable REG_PRICE;\\n\\n    uint8 private constant _rewardPcnt = 25; //1/3 of 75%\\n    uint8 private constant _gamePrizePcnt = 2;\\n    uint8 private constant _megaPrizePcnt = 2;\\n    uint8 private constant _fomoPcnt = 5;\\n\\n    GameParams private _gameParams;\\n\\n    mapping(uint64 => UserState) private _users;\\n    mapping(uint8 => GameCore.Game) private _games;\\n    Fomo private _fomo;\\n\\n    constructor(\\n        address wallet,\\n        uint64 regMinCount,\\n        uint96 regPrice,\\n        uint96[] memory prices,\\n        address referralNft,\\n        address metaDescriptor,\\n        uint64[] memory gameParams\\n    ) {\\n        require(wallet != address(0) && metaDescriptor != address(0) && referralNft != address(0) && prices.length == TOTAL_GAMES);\\n        SYS_WALLET = wallet;\\n\\n        _gameParams.registerRemainCount = regMinCount;\\n        if (regMinCount == 0) {\\n            _gameParams.startTime = uint64(block.timestamp);\\n        }\\n        REG_PRICE = regPrice;\\n        _START_TIME_PERIOD = gameParams[0];\\n        _START_TIME_OFFSET = gameParams[1];\\n        TOP_LIST_COUNT = gameParams[2];\\n        GAME_PRIZE_ENTERS = gameParams[3];\\n        MEGA_PRIZE_ENTERS = gameParams[4];\\n\\n        for (uint8 i; i < TOTAL_GAMES;) {\\n            unchecked {\\n                _games[i + 1].price = prices[i];\\n                ++i;\\n            }\\n        }\\n\\n        _metaDescriptor = IMetaDescriptor(metaDescriptor);\\n        _refNft.set(referralNft);\\n    }\\n\\n    fallback() external {\\n        revert();\\n    }\\n\\n    receive() external payable {\\n        uint256 value = msg.value;\\n        uint8 gameId;\\n        for (uint8 i = 1; i <= TOTAL_GAMES;) {\\n            if (value == _games[i].price) {\\n                gameId = i;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        enter(gameId, 0);\\n    }\\n\\n    function getUserId(address addr) public view returns (uint64) {\\n        return _refNft.idOf(addr);\\n    }\\n\\n    function getUser(uint64 userId) external view returns (UserState memory) {\\n        return _users[userId];\\n    }\\n\\n    function getUserGame(uint8 gameId, uint64 userId) external view returns (GameCore.UserGameState memory) {\\n        return _games[gameId].users[userId];\\n    }\\n\\n    function getUserGameProgress(uint8 gameId, uint64 userId)\\n        external\\n        view\\n        returns (uint64 gameHops, uint64 maxGameHops, uint96 gameReward, uint96 maxGameReward)\\n    {\\n        return _games[gameId].userProgress(userId, _rewardPcnt);\\n    }\\n\\n    function getGame(uint8 gameId)\\n        external\\n        view\\n        returns (uint96 price, uint64 enters, uint96 rewardTotal, uint96 refRewardTotal, uint96 missedRefRewardTotal, uint96 gamePrizeTotal)\\n    {\\n        GameCore.GameState memory s = _games[gameId].state;\\n        return (_games[gameId].price, s.enters, s.rewardTotal, s.refRewardTotal, s.missedRefRewardTotal, s.gamePrizeTotal);\\n    }\\n\\n    function getRegStatus() external view returns (uint96 regPrice, uint64 regRemainCount) {\\n        return (REG_PRICE, _gameParams.registerRemainCount);\\n    }\\n\\n    function getStartStatus() public view returns (uint64 _startTime, bool _isStarted) {\\n        uint64 startTime = _gameParams.startTime;\\n        return (startTime, startTime > 0 && block.timestamp >= startTime);\\n    }\\n\\n    function getGameTop(uint8 gameId) external view returns (uint96 prizeFund, uint64 curEnters, uint64 minEnters, bool isReady) {\\n        return _getGameTop(gameId, GAME_PRIZE_ENTERS);\\n    }\\n\\n    function getMegaTop() external view returns (uint96 prizeFund, uint64 curEnters, uint64 minEnters, bool isReady) {\\n        return _getGameTop(MEGA_TOKEN_ID, MEGA_PRIZE_ENTERS);\\n    }\\n\\n    function getGameTopList(uint8 gameId) public view returns (uint64[] memory userIds, uint256[] memory balances) {\\n        return ownerIdsTop(gameId, TOP_LIST_COUNT);\\n    }\\n\\n    function getMegaTopList() public view returns (uint64[] memory userIds, uint256[] memory balances) {\\n        return ownerIdsTop(MEGA_TOKEN_ID, TOP_LIST_COUNT);\\n    }\\n\\n    function getProvisionGamePrize(uint8 gameId, uint64 userId) external view returns (uint96 prizeAmount) {\\n        (uint64[] memory ids, uint256[] memory balances) = getGameTopList(gameId);\\n        return _getProvisionPrize(userId, _games[gameId].top.fund, ids, balances);\\n    }\\n\\n    function getProvisionMegaPrize(uint64 userId) external view returns (uint96 prizeAmount) {\\n        (uint64[] memory ids, uint256[] memory balances) = getMegaTopList();\\n        return _getProvisionPrize(userId, _games[MEGA_TOKEN_ID].top.fund, ids, balances);\\n    }\\n\\n    function getFomo() external view returns (uint96 prizeFund, uint64 userId, uint64 raffleAt, uint96 fomoTotal, uint64 timeRemain, bool isReady) {\\n        Fomo memory fomo = _fomo;\\n        if (fomo.raffleAt == 0) {\\n            return (0, 0, 0, fomo.fomoTotal, 0, false);\\n        }\\n        uint64 curTime = uint64(block.timestamp);\\n        isReady = curTime >= fomo.raffleAt;\\n        unchecked {\\n            return (fomo.fund, fomo.userId, fomo.raffleAt, fomo.fomoTotal, isReady ? 0 : fomo.raffleAt - curTime, isReady);\\n        }\\n    }\\n\\n    function getRewardPercents()\\n        external\\n        pure\\n        returns (uint8 rewardPcnt, uint8 gamePrizePcnt, uint8 megaPrizePcnt, uint8 fomoPcnt, uint8[REF_LEVELS] memory refRewardPcnts)\\n    {\\n        return (_rewardPcnt, _gamePrizePcnt, _megaPrizePcnt, _fomoPcnt, _refRewardPcnts());\\n    }\\n\\n    function getfomoDelays() external pure returns (uint16[TOTAL_GAMES] memory fomoDelays) {\\n        return _fomoDelays();\\n    }\\n\\n    /// @return id user's 1st ref nft id\\n    function register(uint64 refId) external payable nonReentrant returns (uint64 id) {\\n        Utils._checkEOA();\\n        _checkGameStart(false);\\n        address addr = msg.sender;\\n        uint256 value = msg.value;\\n\\n        if (value != REG_PRICE) revert BadValue();\\n\\n        bool isNew;\\n        (id, isNew,) = _refNft.register(addr, refId);\\n        if (!isNew) revert AlreadyRegistered();\\n\\n        Utils._tx(SYS_WALLET, value);\\n        GameParams memory gp = _gameParams;\\n        if (gp.registerRemainCount > 0) {\\n            unchecked {\\n                gp.registerRemainCount--;\\n            }\\n            if (gp.registerRemainCount == 0) {\\n                gp.startTime = uint64((block.timestamp / _START_TIME_PERIOD) * _START_TIME_PERIOD + _START_TIME_OFFSET);\\n            }\\n            _gameParams = gp;\\n        }\\n    }\\n\\n    function enter(uint8 gameId, uint64 refId) public payable nonReentrant {\\n        Utils._checkEOA();\\n        _checkGame(gameId);\\n        _checkGameStart(true);\\n\\n        uint96 value = uint96(msg.value);\\n        address addr = msg.sender;\\n        (uint64 userId,,) = _refNft.register(addr, refId);\\n\\n        uint96 freeValue = value;\\n\\n        // reward\\n        freeValue -= _processEnter(gameId, value, userId);\\n        _mintRefId(userId, gameId, 1);\\n\\n        // refReward\\n        freeValue -= _processRefReward(gameId, value, userId);\\n        freeValue -= _updGameTop(gameId, value, _gamePrizePcnt, 1, GAME_PRIZE_ENTERS);\\n\\n        bool isMegaMint = _checkMegaMint(gameId, userId);\\n        freeValue -= _updGameTop(MEGA_TOKEN_ID, value, _megaPrizePcnt, (isMegaMint ? 1 : 0), MEGA_PRIZE_ENTERS);\\n\\n        if (isMegaMint) {\\n            _games[MEGA_TOKEN_ID].users[userId].enters++;\\n            _games[MEGA_TOKEN_ID].state.enters++;\\n            _mintRefId(userId, MEGA_TOKEN_ID, 1);\\n        }\\n\\n        freeValue -= _processFomo(gameId, userId, freeValue);\\n        Utils._tx(SYS_WALLET, freeValue);\\n    }\\n\\n    function _updGameTop(uint8 gameId, uint96 value, uint8 fundPcnt, uint64 enters, uint64 minEnters) internal returns (uint96 fundDelta) {\\n        GameCore.GameTop memory top = _games[gameId].top;\\n        top.enters += enters;\\n\\n        fundDelta = Utils._pcnt(value, fundPcnt);\\n        top.fund += fundDelta;\\n\\n        _games[gameId].top = top;\\n\\n        emit GamePrizeFund(gameId, top.fund);\\n        if (top.enters >= minEnters) {\\n            emit GamePrizeReady(gameId, top.fund);\\n        }\\n    }\\n\\n    function gamePrizeRaffle(uint8 gameId) external nonReentrant {\\n        _checkGame(gameId);\\n        _checkGameStart(true);\\n        GameCore.GameTop memory top = _games[gameId].top;\\n        if (top.enters < GAME_PRIZE_ENTERS) revert RaffleNotReady();\\n        _games[gameId].top.fund = _distributeTopPrize(top.fund, gameId);\\n        _games[gameId].top.enters = 0;\\n    }\\n\\n    function megaPrizeRaffle() external nonReentrant {\\n        _checkGameStart(true);\\n        GameCore.GameTop memory top = _games[MEGA_TOKEN_ID].top;\\n        if (top.enters < MEGA_PRIZE_ENTERS) revert RaffleNotReady();\\n        _games[MEGA_TOKEN_ID].top.fund = _distributeTopPrize(top.fund, MEGA_TOKEN_ID);\\n        _games[MEGA_TOKEN_ID].top.enters = 0;\\n    }\\n\\n    function fomoRaffle() external nonReentrant {\\n        _checkGameStart(true);\\n        Fomo memory fomo = _fomo;\\n        if (fomo.raffleAt == 0 || fomo.fund == 0 || block.timestamp < fomo.raffleAt) revert RaffleNotReady();\\n        // Utils._tx(_users[fomo.userId].addr, fomo.fund);\\n        _txRefId(fomo.userId, fomo.fund);\\n        emit FomoRaffle(fomo.userId, fomo.fund);\\n        _users[fomo.userId].fomoTotal += fomo.fund;\\n        fomo.fomoTotal += fomo.fund;\\n        fomo.fund = 0;\\n        fomo.raffleAt = 0;\\n        fomo.userId = 0;\\n        _fomo = fomo;\\n    }\\n\\n    /// @return uint96 fund\\n    /// @return uint64 curEnters\\n    /// @return uint64 minEnters\\n    /// @return bool isReady\\n    function _getGameTop(uint8 gameId, uint64 minEnters) internal view returns (uint96, uint64, uint64, bool) {\\n        GameCore.GameTop memory top = _games[gameId].top;\\n        return (top.fund, top.enters, minEnters, top.enters >= minEnters);\\n    }\\n\\n    function _getProvisionPrize(uint64 id, uint96 fund, uint64[] memory ids, uint256[] memory balances) internal pure returns (uint96) {\\n        bool found = false;\\n        uint256 bal;\\n        uint256 sum;\\n\\n        for (uint256 i; i < ids.length;) {\\n            sum += balances[i];\\n            if (id == ids[i]) {\\n                found = true;\\n                bal = balances[i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return found ? (fund * uint96(bal)) / uint96(sum) : 0;\\n    }\\n\\n    function _distributeTopPrize(uint96 fund, uint8 gameId) internal returns (uint96) {\\n        (uint64[] memory ownerIds, uint256[] memory balances) = ownerIdsTop(gameId, TOP_LIST_COUNT);\\n        if (ownerIds.length == 0) revert TopListEmpty();\\n\\n        uint64 sum;\\n        for (uint256 i; i < balances.length;) {\\n            sum += uint64(balances[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint96 reward;\\n        uint96 prizeSum;\\n        for (uint256 i; i < balances.length;) {\\n            reward = (fund * uint96(uint64(balances[i]))) / uint96(sum);\\n            if (reward > 0) {\\n                _txRefId(ownerIds[i], reward);\\n                emit GamePrizeRaffle(ownerIds[i], gameId, reward);\\n                _users[ownerIds[i]].gamePrizeTotal += reward;\\n                _games[gameId].users[ownerIds[i]].gamePrizeTotal += reward;\\n                prizeSum += reward;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        emit GamePrizeRaffled(gameId, prizeSum);\\n        _games[gameId].state.gamePrizeTotal += prizeSum;\\n        return fund - prizeSum;\\n    }\\n\\n    /// @return rewardSum\\n    function _processEnter(uint8 gameId, uint96 value, uint64 userId) internal returns (uint96) {\\n        uint96 rewardDelta;\\n        (uint64[] memory userIds, uint96 reward, uint64 level) = _games[gameId].enterQueue(userId, value, _rewardPcnt);\\n\\n        emit Enter(userId, gameId, level);\\n        for (uint256 i; i < userIds.length;) {\\n            if (userIds[i] != 0) {\\n                _txRefId(userIds[i], reward);\\n                rewardDelta += reward;\\n                _users[userIds[i]].rewardTotal += reward;\\n                emit Reward(userIds[i], gameId, reward, userId);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return rewardDelta;\\n    }\\n\\n    function _processRefReward(uint8 gameId, uint96 value, uint64 userId) internal returns (uint96 refRewardSum) {\\n        uint96 missedRefRewardSum;\\n        uint64 upId = _refNft.upIdOf(userId);\\n        uint256 balance = balanceOfRefId(userId, gameId);\\n        uint256 upBalance = balanceOfRefId(upId, gameId);\\n\\n        uint96 reward;\\n        for (uint8 i; i < REF_LEVELS;) {\\n            if (upId == 0) {\\n                break;\\n            }\\n            unchecked {\\n                reward = Utils._pcnt(value, _refRewardPcnts()[i]);\\n            }\\n            if (upBalance >= balance) {\\n                (bool ok,) = payable(_refNft.ownerOf(upId)).call{value: reward}(\\\"\\\");\\n                if (ok) {\\n                    refRewardSum += reward;\\n                    _users[upId].refRewardTotal += reward;\\n                    _games[gameId].users[upId].refRewardTotal += reward;\\n                    unchecked {\\n                        emit ReferralReward(upId, gameId, reward, userId, i + 1);\\n                    }\\n                }\\n            } else {\\n                missedRefRewardSum += reward;\\n                _users[upId].missedRefRewardTotal += reward;\\n                _games[gameId].users[upId].missedRefRewardTotal += reward;\\n                unchecked {\\n                    emit MissedReferralReward(upId, gameId, reward, userId, i + 1);\\n                }\\n            }\\n            upId = _refNft.upIdOf(upId);\\n            upBalance = balanceOfRefId(upId, gameId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        _games[gameId].state.refRewardTotal += refRewardSum;\\n        _games[gameId].state.missedRefRewardTotal += missedRefRewardSum;\\n    }\\n\\n    function _processFomo(uint8 gameId, uint64 userId, uint96 value) internal returns (uint96 topupSum) {\\n        Fomo memory fomo = _fomo;\\n        fomo.userId = userId;\\n        unchecked {\\n            fomo.raffleAt = uint64(block.timestamp) + _fomoDelay(gameId);\\n            topupSum = Utils._pcnt(value, _fomoPcnt);\\n        }\\n        fomo.fund += topupSum;\\n        _fomo = fomo;\\n        emit FomoUpdate(userId, fomo.raffleAt, fomo.fund);\\n    }\\n\\n    function _checkMegaMint(uint8 gameId, uint64 userId) internal view returns (bool) {\\n        uint64 megaLevel = _games[MEGA_TOKEN_ID].users[userId].enters;\\n        uint64 level;\\n        for (uint8 i = 1; i <= TOTAL_GAMES;) {\\n            if (i != gameId) {\\n                level = _games[i].users[userId].enters;\\n                if (level <= megaLevel) {\\n                    return false;\\n                    // break;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function _checkGame(uint8 gameId) internal pure {\\n        if (gameId == 0 || gameId > TOTAL_GAMES) revert BadGameId();\\n    }\\n\\n    function _checkGameStart(bool shouldStarted) internal view {\\n        (, bool isStarted) = getStartStatus();\\n        if ((shouldStarted && !isStarted) || (!shouldStarted && isStarted)) {\\n            revert GameStartConflict();\\n        }\\n    }\\n\\n    function _txRefId(uint64 refId, uint256 value) internal {\\n        Utils._tx(_refNft.ownerOf(refId), value);\\n    }\\n\\n    function _fomoDelay(uint8 gameId) internal pure returns (uint64) {\\n        unchecked {\\n            return _fomoDelays()[gameId - 1];\\n        }\\n    }\\n\\n    function _refRewardPcnts() internal pure returns (uint8[REF_LEVELS] memory) {\\n        return [7, 5, 4, 3, 2];\\n    }\\n\\n    function _fomoDelays() internal pure returns (uint16[TOTAL_GAMES] memory) {\\n        return [3 hours, 2.5 hours, 2 hours, 1.5 hours, 1 hours, 30 minutes];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 777\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/lib/GameCore.sol\": {\r\n        \"GameCore\": \"0xdb28dcbf81dd69697f99e8ebc161f9210aec7e64\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"regMinCount\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"regPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96[]\",\"name\":\"prices\",\"type\":\"uint96[]\"},{\"internalType\":\"address\",\"name\":\"referralNft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"metaDescriptor\",\"type\":\"address\"},{\"internalType\":\"uint64[]\",\"name\":\"gameParams\",\"type\":\"uint64[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadGameId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GameStartConflict\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LackOfBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxEntersReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RaffleNotReady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotEOA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TopListEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TxFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsafeRecipient\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"level\",\"type\":\"uint64\"}],\"name\":\"Enter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"FomoRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"raffleAt\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"FomoUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"GamePrizeFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"GamePrizeRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"GamePrizeRaffled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"GamePrizeReady\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"reward\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"refLevel\",\"type\":\"uint8\"}],\"name\":\"MissedReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"reward\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"refLevel\",\"type\":\"uint8\"}],\"name\":\"ReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"reward\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"fromId\",\"type\":\"uint64\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"GAME_PRIZE_ENTERS\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MEGA_PRIZE_ENTERS\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MEGA_TOKEN_ID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REF_LEVELS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REG_PRICE\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOP_LIST_COUNT\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_GAMES\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"ownerId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOfRefId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"refId\",\"type\":\"uint64\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fomoRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"}],\"name\":\"gamePrizeRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFomo\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"prizeFund\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"raffleAt\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"fomoTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"timeRemain\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isReady\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"}],\"name\":\"getGame\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"enters\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"rewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"refRewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"missedRefRewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"gamePrizeTotal\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"}],\"name\":\"getGameTop\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"prizeFund\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"curEnters\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minEnters\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isReady\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"}],\"name\":\"getGameTopList\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"userIds\",\"type\":\"uint64[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMegaTop\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"prizeFund\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"curEnters\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minEnters\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isReady\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMegaTopList\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"userIds\",\"type\":\"uint64[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"}],\"name\":\"getProvisionGamePrize\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"prizeAmount\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"}],\"name\":\"getProvisionMegaPrize\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"prizeAmount\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegStatus\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"regPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"regRemainCount\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardPercents\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"rewardPcnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"gamePrizePcnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"megaPrizePcnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fomoPcnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8[5]\",\"name\":\"refRewardPcnts\",\"type\":\"uint8[5]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartStatus\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"_startTime\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_isStarted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"rewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"refRewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"missedRefRewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"gamePrizeTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"fomoTotal\",\"type\":\"uint96\"}],\"internalType\":\"struct NeraGame.UserState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"}],\"name\":\"getUserGame\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"enters\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"hops\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"rewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"refRewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"missedRefRewardTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"gamePrizeTotal\",\"type\":\"uint96\"}],\"internalType\":\"struct GameCore.UserGameState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gameId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"userId\",\"type\":\"uint64\"}],\"name\":\"getUserGameProgress\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"gameHops\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxGameHops\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"gameReward\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxGameReward\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getfomoDelays\",\"outputs\":[{\"internalType\":\"uint16[6]\",\"name\":\"fomoDelays\",\"type\":\"uint16[6]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPrizeRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"ownerIdsTop\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"ownerIds\",\"type\":\"uint64[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"refId\",\"type\":\"uint64\"}],\"name\":\"register\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NeraGame", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "777", "ConstructorArguments": "000000000000000000000000166223ec20aba11ca7083702666c23270a4c745100000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000052a30e175d5df426c9e423c4d20b35f4e6b686a000000000000000000000000026feaf22de850de13c00cd29e260564cca76cf2e00000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000001bc16d674ec800000000000000000000000000000000000000000000000000004563918244f400000000000000000000000000000000000000000000000000008ac7230489e80000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000024ea0000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000014", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}