{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IUNCX_ProofOfReservesV2_UniV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// ALL RIGHTS RESERVED\\n// UNCX by SDDTech reserves all rights on this code. You may not copy these contracts.\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./uniswap-updated/INonfungiblePositionManager.sol\\\";\\n\\n/**\\n * @dev Interface of the UNCX UniswapV3 Liquidity Locker\\n */\\ninterface IUNCX_ProofOfReservesV2_UniV3 {\\n    struct FeeStruct {\\n        string name; // name by which the fee is accessed\\n        uint256 lpFee; // 100 = 1%, 10,000 = 100%\\n        uint256 collectFee; // 100 = 1%, 10,000 = 100%\\n        uint256 flatFee; // in amount tokens\\n        address flatFeeToken; // address(0) = ETH otherwise ERC20 address expected\\n    }\\n\\n    struct Lock {\\n        uint256 lock_id; // unique nonce per lock\\n        INonfungiblePositionManager nftPositionManager; // the nft position manager of the uniswap fork\\n        address pool; // the pool address\\n        uint256 nft_id; // the nft token id of the nft belonging to the nftPositionManager (there could be two nfts with id = 1, belonging to different amm forks and position managers)\\n        address owner; // the owner who can collect and withdraw\\n        address pendingOwner; //  two step process ownership transfer, the pending owner must accept ownership to own the lock\\n        address additionalCollector; // an additional address allowed to call collect (ideal for contracts to auto collect without having to use owner)\\n        address collectAddress; // The address to which automatic collections are sent\\n        uint256 unlockDate; // unlock date of the lock in seconds\\n        uint16 countryCode; // the country code of the locker / business\\n        uint256 ucf; // collect fee\\n    }\\n\\n    struct LockParams {\\n        INonfungiblePositionManager nftPositionManager; // the NFT Position manager of the Uniswap V3 fork\\n        uint256 nft_id; // the nft token_id\\n        address dustRecipient; // receiver of dust tokens which do not fit into liquidity and initial collection fees\\n        address owner; // owner of the lock\\n        address additionalCollector; // an additional address allowed to call collect (ideal for contracts to auto collect without having to use owner)\\n        address collectAddress; // The address to which automatic collections are sent\\n        uint256 unlockDate; // unlock date of the lock in seconds\\n        uint16 countryCode; // the country code of the locker / business\\n        string feeName; // The fee name key you wish to accept, use \\\"DEFAULT\\\" if in doubt\\n        bytes[] r; // use an empty array => []\\n    }\\n\\n    // User functions\\n    function lock (LockParams calldata params) external payable returns (uint256 lockId);\\n    function collect (uint256 lockId, address recipient, uint128 amount0Max, uint128 amount1Max) external returns (uint256 amount0, uint256 amount1, uint256 fee0, uint256 fee1);\\n    function withdraw (uint256 lockId, address receiver) external;\\n    function migrate (uint256 lockId) external;\\n    function relock(uint256 lockId, uint256 unlockDate) external;\\n    function setAdditionalCollector (uint256 lockId, address additionalCollector) external;\\n    function setCollectAddress (uint256 lockId, address collectAddress) external;\\n    function transferLockOwnership (uint256 lockId, address newOwner) external;\\n    function acceptLockOwnership (uint256 lockId) external;\\n    function decreaseLiquidity(uint256 lockId, INonfungiblePositionManager.DecreaseLiquidityParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\\n    function increaseLiquidity(uint256 lockId, INonfungiblePositionManager.IncreaseLiquidityParams calldata params) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);\\n\\n    // Admin functions\\n    function setMigrator(address migrator) external;\\n    function setUCF(uint256 lockId, uint256 ucf) external;\\n    function setMigrateInContract (address migrateInContract) external;\\n\\n    // Getters\\n    function getLocksLength() external view returns (uint256);\\n    function getLock(uint256 lockId) external view returns (Lock memory lock);\\n\\n    function getNumUserLocks(address user) external view returns (uint256 numLocks);\\n    function getUserLockAtIndex(address user, uint256 index) external view returns (Lock memory lock);\\n\\n    function getFee (string memory name) external view returns (FeeStruct memory);\\n    function getAmountsForLiquidity (int24 currentTick, int24 tickLower, int24 tickHigher, uint128 liquidity) external pure returns (uint256 amount0, uint256 amount1);\\n\\n    // Events\\n    event onLock(\\n        uint256 lock_id,\\n        address nftPositionManager,\\n        uint256 nft_id,\\n        address owner,\\n        address additionalCollector,\\n        address collectAddress,\\n        uint256 unlockDate,\\n        uint16 countryCode,\\n        uint256 collectFee,\\n        address poolAddress,\\n        INonfungiblePositionManager.Position position\\n    );\\n\\n    event onWithdraw(uint256 lock_id, address owner, address receiver);\\n\\n    event onLockOwnershipTransferStarted(uint256 lockId, address currentOwner, address pendingOwner);\\n\\n    event onTransferLockOwnership(uint256 lockId, address oldOwner, address newOwner);\\n\\n    event onMigrate(uint256 lockId);\\n\\n    event onSetAdditionalCollector(uint256 lockId, address additionalCollector);\\n\\n    event onSetCollectAddress(uint256 lockId, address collectAddress);\\n\\n    event onSetMigrator(address migrator);\\n\\n    event onRelock(uint256 lockId, uint256 unlockDate);\\n\\n    event onIncreaseLiquidity(uint256 lockId);\\n\\n    event onDecreaseLiquidity(uint256 lockId);\\n\\n    event onRemoveFee(bytes32 nameHash);\\n\\n    event onAddFee(bytes32 nameHash, string name, uint256 lpFee, uint256 collectFee, uint256 flatFee, address flatFeeToken);\\n\\n    event onEditFee(bytes32 nameHash, string name, uint256 lpFee, uint256 collectFee, uint256 flatFee, address flatFeeToken);\\n\\n    event onSetUCF(uint256 lockId, uint256 ucf);\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/periphery/FullRangeConvertor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Code Author: UNCX by SDDTech\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../uniswap-updated/INonfungiblePositionManager.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\\\";\\nimport \\\"../IUNCX_ProofOfReservesV2_UniV3.sol\\\";\\n\\ncontract FullRangeConvertor is IERC721Receiver, ReentrancyGuard {\\n\\n    IUNCX_ProofOfReservesV2_UniV3 public UNIV3_V2_LOCKER;\\n\\n    constructor(IUNCX_ProofOfReservesV2_UniV3 _univ3_v2_locker) {\\n      UNIV3_V2_LOCKER = _univ3_v2_locker;\\n    }\\n\\n    function convertToFullRangeAndLock (IUNCX_ProofOfReservesV2_UniV3.LockParams memory _lockParams, uint256 _amount0Min, uint256 _amount1Min) external nonReentrant returns (uint256 newLockId) {\\n      _lockParams.nftPositionManager.safeTransferFrom(msg.sender, address(this), _lockParams.nft_id);\\n\\n      INonfungiblePositionManager.Position memory position;\\n      (\\n        , // nonce\\n        , // operator\\n        , // token0\\n        , // token1\\n        position.fee, // fee\\n        position.tickLower, // tickLower\\n        position.tickUpper, // tickUpper\\n        , // liquidity\\n        , // feeGrowthInside0LastX128\\n        , // feeGrowthInside1LastX128\\n        , // tokensOwed0\\n          // tokensOwed1\\n      ) = _lockParams.nftPositionManager.positions(_lockParams.nft_id);\\n\\n      IUniswapV3Factory factory = IUniswapV3Factory(_lockParams.nftPositionManager.factory());\\n      int24 maxTick = tickSpacingToMaxTick(factory.feeAmountTickSpacing(position.fee));\\n      \\n      uint256 nftToLock;\\n      if (position.tickLower == -maxTick && position.tickUpper == maxTick) {\\n          nftToLock = _lockParams.nft_id;\\n      } else {\\n        // convert the position to full range by minting a new full range NFT\\n        nftToLock = _convertPositionToFullRange(_lockParams.nftPositionManager, _lockParams.nft_id, maxTick, _lockParams.dustRecipient, _amount0Min, _amount1Min);\\n      }\\n      \\n      _lockParams.nftPositionManager.approve(address(UNIV3_V2_LOCKER), nftToLock);\\n      _lockParams.nft_id = nftToLock;\\n      newLockId = UNIV3_V2_LOCKER.lock(_lockParams);\\n    }\\n\\n    function _convertPositionToFullRange (INonfungiblePositionManager _nftPositionManager, uint256 _tokenId, int24 _maxTick, address _dustRecipient, uint256 _amount0Min, uint256 _amount1Min) private returns (uint256) {\\n        INonfungiblePositionManager.MintParams memory mintParams;\\n        uint128 positionLiquidity;\\n        (\\n          , // nonce\\n          , // operator\\n          mintParams.token0, // token0\\n          mintParams.token1, // token1\\n          mintParams.fee, // fee\\n          , // tickLower\\n          , // tickUpper\\n          positionLiquidity,\\n          , // feeGrowthInside0LastX128\\n          , // feeGrowthInside1LastX128\\n          , // tokensOwed0\\n           // tokensOwed1\\n        ) = _nftPositionManager.positions(_tokenId);\\n\\n        _nftPositionManager.decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams(_tokenId, positionLiquidity, 0, 0, block.timestamp));\\n        _nftPositionManager.collect(INonfungiblePositionManager.CollectParams(_tokenId, address(this), type(uint128).max, type(uint128).max));\\n\\n        mintParams.tickLower = -_maxTick;\\n        mintParams.tickUpper = _maxTick;\\n        mintParams.amount0Desired = IERC20(mintParams.token0).balanceOf(address(this));\\n        mintParams.amount1Desired = IERC20(mintParams.token1).balanceOf(address(this));\\n        mintParams.amount0Min = _amount0Min;\\n        mintParams.amount1Min = _amount1Min;\\n        mintParams.recipient = address(this);\\n        mintParams.deadline = block.timestamp;\\n\\n        TransferHelper.safeApprove(mintParams.token0, address(_nftPositionManager), mintParams.amount0Desired);\\n        TransferHelper.safeApprove(mintParams.token1, address(_nftPositionManager), mintParams.amount1Desired);\\n\\n        (uint256 newNftId,,,) = _nftPositionManager.mint(mintParams);\\n\\n        _nftPositionManager.burn(_tokenId);\\n\\n        // Refund the tokens which dont fit into full range liquidity\\n        uint256 balance0 = IERC20(mintParams.token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(mintParams.token1).balanceOf(address(this));\\n        if (balance0 > 0) {\\n            TransferHelper.safeTransfer(mintParams.token0, _dustRecipient, balance0);\\n        }\\n        if (balance1 > 0) {\\n            TransferHelper.safeTransfer(mintParams.token1, _dustRecipient, balance1);\\n        }\\n        return newNftId;\\n    }\\n\\n    /**\\n    * @dev gets the maximum tick for a tickSpacing\\n    * source: https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Tick.sol\\n    */\\n    function tickSpacingToMaxTick(int24 tickSpacing) public pure returns (int24 maxTick) {\\n        maxTick = (887272 / tickSpacing) * tickSpacing;\\n    }\\n\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) public pure override returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n}\"\r\n    },\r\n    \"contracts/uniswap-updated/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n// Importing from @uniswap doesnt work with @openzepplins latest release so this is refactored\\n// Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/INonfungiblePositionManager.sol\\n\\ninterface INonfungiblePositionManager {\\n\\n    function approve(address to, uint256 tokenId) external;\\n    \\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        address recipient;\\n        uint256 deadline;\\n    }\\n\\n    function mint(\\n        MintParams calldata params\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 tokenId,\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    struct Position {\\n        uint96 nonce;\\n        address operator;\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint128 liquidity;\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        uint128 tokensOwed0;\\n        uint128 tokensOwed1;\\n    }\\n\\n    function positions(\\n        uint256 tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            uint96 nonce,\\n            address operator,\\n            address token0,\\n            address token1,\\n            uint24 fee,\\n            int24 tickLower,\\n            int24 tickUpper,\\n            uint128 liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    struct IncreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\\n    /// amount0Desired The desired amount of token0 to be spent,\\n    /// amount1Desired The desired amount of token1 to be spent,\\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\\n    /// deadline The time by which the transaction must be included to effect the change\\n    /// @return liquidity The new liquidity amount as a result of the increase\\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\n        external\\n        payable\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    struct DecreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint128 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\\n    /// amount The amount by which liquidity will be decreased,\\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\\n    /// deadline The time by which the transaction must be included to effect the change\\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    struct CollectParams {\\n        uint256 tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    function collect(\\n        CollectParams calldata params\\n    ) external payable returns (uint256 amount0, uint256 amount1);\\n\\n    function factory() external view returns (address);\\n\\n    function burn(uint256 tokenId) external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IUNCX_ProofOfReservesV2_UniV3\",\"name\":\"_univ3_v2_locker\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"UNIV3_V2_LOCKER\",\"outputs\":[{\"internalType\":\"contract IUNCX_ProofOfReservesV2_UniV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"nftPositionManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nft_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dustRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"additionalCollector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collectAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"countryCode\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"feeName\",\"type\":\"string\"},{\"internalType\":\"bytes[]\",\"name\":\"r\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IUNCX_ProofOfReservesV2_UniV3.LockParams\",\"name\":\"_lockParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Min\",\"type\":\"uint256\"}],\"name\":\"convertToFullRangeAndLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newLockId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"tickSpacingToMaxTick\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"maxTick\",\"type\":\"int24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "FullRangeConvertor", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000f1f7f21e2ea80ab110d0f95faa64655688341990", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}