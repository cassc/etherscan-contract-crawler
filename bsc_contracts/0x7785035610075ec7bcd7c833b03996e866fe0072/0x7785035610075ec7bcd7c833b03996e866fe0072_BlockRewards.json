{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 internal _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract BlockRewards is Context, Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private PSN = 10000;\r\n    uint256 private PSNH = 5000;\r\n\tuint256 public MAX_REWARDS_ACCUMULATION_CUTOFF = 86400; //24*60*60. Seconds in 1 day. Rewards will accumulate till max 24 hours until after the user will have to either compound or sell\r\n    uint256 public EGGS_TO_HATCH_1MINERS = 2880000; // 86400/2880000 = 3% APY\r\n    uint256 public DEV_PERCENT = 6;\r\n\tuint256 public JumpStartTVL_PERCENT = 2;\r\n\tuint256 public REFERRAL_PERCENT = 7;\r\n\r\n    bool private initialized = false;\r\n\tbool public sellCheck = true;\r\n    address payable private recAdd;\r\n\taddress payable private JumpStartTVLFund; //separate wallet. Only to be used for jumpstarting TVL\r\n\r\n    bool public referralWhitelistActive = false;\r\n    mapping(address => bool) public referralWhitelisted;\r\n\tuint256 public referralsNeededToEarnCommission = 3;\r\n\r\n    bool public blacklistActive = true;\r\n    mapping(address => bool) public Blacklisted;\r\n\r\n\tuint256 public ADJUSTED_REWARD_PERCENT_NEWBUYERS = 100;     //100 = No buying bonus. 125 = 25% buying bonus\r\n\tuint256 public ADJUSTED_REWARD_PERCENT = 100;\r\n\tuint256 public CAPPED_DAILY_REWARD_AMOUNT = 5000 * 1e16;    // 50 BNB/Day == 50 * 1e18 ==  5000 * 1e16 . Disabled By Default by setting a high amount- 50 BNB/day. Please see Docs for more details.\r\n\r\n\tuint256 public marketEggs;\r\n\tuint256 public MARKETEGGS_BUY_INFLATION = 0;                // By Default, no inflation on buy\r\n\tuint256 public MARKETEGGS_HATCH_INFLATION = 20;\r\n\tuint256 public MARKETEGGS_SELL_INFLATION = 100;\r\n\r\n    uint256 public totalStaked;     // Total BNB bought\r\n    uint256 public totalDeposits;   // Total Deposits\r\n    uint256 public totalCompound;   // Total BNB compounded. Not used\r\n    uint256 public totalRefBonus;   // Total BNB paid out for Referrals\r\n    uint256 public totalWithdrawn;  // Total BNB Withdrawn\r\n\r\n\tstruct User {\r\n\t\t\tuint256 initialDeposit;      // Initially Deposit\r\n\t\t\tuint256 userDeposit;         // Total Compounded Deposit including Initial Deposit\r\n\t\t\tuint256 miners;              // Your miners\r\n\t\t\tuint256 lastHatch;           // last time you bought or sold or compounded. Seconds passed since last epoch\r\n\t\t\taddress referrer;            // who referred me\r\n\t\t\tuint256 referralsCount;      // how many people i have referred\r\n\t\t\tuint256 refRewardsinBNB;     // Total BNB paid to me as Referrals\r\n\t\t\tuint256 totalWithdrawn;      // TotalWithdrawn\r\n\t\t\tuint256 farmerCompoundCount; // Added to monitor farmer consecutive compound without cap. Total amount of times i ever compounded.\r\n\t\t\tuint256 lastWithdrawTime;\r\n\t}\r\n\tmapping(address => User) public users;\r\n\r\n    constructor() {\r\n        recAdd = payable(msg.sender);\r\n\t\tJumpStartTVLFund = payable(address(0x02B6084E1d568d2cF61bb1B1Cf4B3dCb5851492C));\r\n    }\r\n\r\n    function hatchEggs() public {\r\n        require(initialized);\r\n\t\tUser storage user = users[msg.sender];\r\n\r\n        uint256 eggsByExistingMiners = getMyEggs(msg.sender);\r\n\t\tuint256 myEggs = SafeMath.div(SafeMath.mul(eggsByExistingMiners, ADJUSTED_REWARD_PERCENT),100);\r\n\r\n\t\tuser.lastHatch = block.timestamp;\r\n\r\n\t\tuint256 newMiners = SafeMath.div(myEggs, EGGS_TO_HATCH_1MINERS);\r\n        user.miners = SafeMath.add(user.miners, newMiners);\r\n\r\n\t\tuint256 eggValueInBNB = calculateTrade(myEggs, marketEggs,address(this).balance);\r\n        user.userDeposit = SafeMath.add(user.userDeposit, eggValueInBNB);\r\n        totalCompound = SafeMath.add(totalCompound, eggValueInBNB);\r\n\t\tuser.farmerCompoundCount = SafeMath.add(user.farmerCompoundCount, 1);\r\n\r\n\t\tuint256 inflation = SafeMath.div(SafeMath.mul(myEggs, MARKETEGGS_HATCH_INFLATION),100);\r\n        marketEggs=SafeMath.add(marketEggs, inflation);\r\n    }\r\n\r\n    function buyEggs(address ref) public payable nonReentrant{\r\n        require(initialized);\r\n\t\tUser storage user = users[msg.sender];\r\n\r\n        uint256 eggsBought = calculateEggBuy(msg.value,SafeMath.sub(address(this).balance,msg.value));\r\n\r\n\t\tuser.initialDeposit = SafeMath.add(user.initialDeposit, msg.value);\r\n\t\tuser.userDeposit = SafeMath.add(user.userDeposit, msg.value);\r\n\r\n        if (user.referrer == address(0)) {\r\n            if (ref != msg.sender) {\r\n                user.referrer = ref;  // set who referred me\r\n            }\r\n\r\n            address referrer = user.referrer;\r\n            if (referrer != address(0)) {\r\n                users[referrer].referralsCount = users[referrer].referralsCount.add(1);  // increment referral count for whoever referred me\r\n            }\r\n        }\r\n\r\n        if (user.referrer != address(0)) {\r\n            address referrer = user.referrer;\r\n            if (referrer != address(0)) {\r\n\r\n\t\t\t\tbool payReferral = false;\r\n\r\n\t\t\t\tif (referralWhitelistActive) { // default disabled. can enable later if needed.\r\n\t\t\t\t\tif(referralWhitelisted[referrer]) {\r\n\t\t\t\t\t\tpayReferral = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpayReferral = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(payReferral && users[referrer].referralsCount > referralsNeededToEarnCommission) {\r\n\t\t\t\t\tuint256 refRewardsBNB = SafeMath.div(SafeMath.mul(msg.value,REFERRAL_PERCENT),100);\r\n\t\t\t\t\tpayable(address(referrer)).transfer(refRewardsBNB);\r\n\r\n\t\t\t\t\tusers[referrer].refRewardsinBNB = users[referrer].refRewardsinBNB.add(refRewardsBNB);\r\n\t\t\t\t\ttotalRefBonus = totalRefBonus.add(refRewardsBNB);\r\n\r\n\t\t\t\t\tuint256 referralInflation = SafeMath.div(SafeMath.mul(eggsBought, REFERRAL_PERCENT),100);\r\n\t\t\t\t\tmarketEggs=SafeMath.add(marketEggs, referralInflation);\r\n\t\t\t\t}\r\n\r\n            }\r\n        }\r\n\r\n\t\tuint256 eggsBoughtWithBonus = applyBuyerBonus(msg.sender, eggsBought, msg.value);\r\n\r\n\t\tuint256 bonusEggs = eggsBoughtWithBonus - eggsBought;\r\n\t\tif(bonusEggs > 0) {\r\n\t\t\tmarketEggs=SafeMath.add(marketEggs, bonusEggs);\r\n\t\t}\r\n\r\n\t\teggsBoughtWithBonus = SafeMath.sub(eggsBoughtWithBonus,devFee(eggsBought)); //devFee calculated on eggBought without bonus\r\n        uint256 fee = devFee(msg.value);\r\n        recAdd.transfer(fee);\r\n\r\n\t\ttotalStaked = SafeMath.add(totalStaked, SafeMath.sub(msg.value, fee));\r\n        totalDeposits = SafeMath.add(totalDeposits, 1);\r\n\r\n        uint256 eggsProducedByExistingMiners = getMyEggs(msg.sender);\r\n\t\tif(eggsProducedByExistingMiners > 0){ // for existing Blockholders\r\n\t\t\tuint256 compoundInflation = SafeMath.div(SafeMath.mul(eggsProducedByExistingMiners, MARKETEGGS_HATCH_INFLATION),100);\r\n\t\t\tmarketEggs=SafeMath.add(marketEggs, compoundInflation);\r\n\t\t}\r\n\r\n\t\tuint256 totalEggs = SafeMath.add(eggsBoughtWithBonus, eggsProducedByExistingMiners);\r\n\r\n        uint256 newMiners = SafeMath.div(totalEggs,EGGS_TO_HATCH_1MINERS);\r\n\t\tuser.miners = SafeMath.add(user.miners, newMiners);\r\n\r\n\t\tuser.lastHatch = block.timestamp;\r\n\r\n\t\tif(MARKETEGGS_BUY_INFLATION > 0) { // by default. No Buy inflation.\r\n\t\t\tuint256 inflation = SafeMath.div(SafeMath.mul(totalEggs, MARKETEGGS_BUY_INFLATION),100);\r\n        \tmarketEggs=SafeMath.add(marketEggs, inflation);\r\n\t\t}\r\n    }\r\n\r\n\tfunction applyBuyerBonus(address adr, uint256 eggsPurchased, uint256 buyAmount) private view returns(uint256) {\r\n\t\tuint256 eggsWithBonus = eggsPurchased;\r\n\t\tif(ADJUSTED_REWARD_PERCENT_NEWBUYERS > 100) {  //  if applicable, apply Bonus to both New Buyers and Existing Buyers\r\n\t\t\tif(users[adr].miners == 0) { // for new buyers\r\n\t\t\t\teggsWithBonus =  SafeMath.div(SafeMath.mul(eggsPurchased, ADJUSTED_REWARD_PERCENT_NEWBUYERS),100); // Give Full Bonus to New Buyers\r\n\t\t\t} else {\r\n\t\t\t\t//Logic for existing buyers. Only give bonus on amount above their daily estimated reward so they don't cash out reward and buyback in for the bonus available.\r\n\t\t\t\tuint256 estimatedDailyReward = getEstimatedDailyReward(adr);\r\n\r\n\t\t\t\tif(buyAmount > estimatedDailyReward) {  // existing buyer is buying more than their daily estimated reward\r\n\t\t\t\t\tuint256 amountEligibleForBonus = SafeMath.sub(buyAmount, estimatedDailyReward);\r\n\t\t\t\t\tuint256 eggsEligibleForBonus =  SafeMath.div(SafeMath.mul(amountEligibleForBonus, eggsPurchased), buyAmount);\r\n\t\t\t\t\tuint256 bonusEggs = SafeMath.div(SafeMath.mul(SafeMath.sub(ADJUSTED_REWARD_PERCENT_NEWBUYERS, 100), eggsEligibleForBonus), 100);\r\n\t\t\t\t\teggsWithBonus = SafeMath.add(eggsPurchased, bonusEggs);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn eggsWithBonus;\r\n\t}\r\n\r\n\tfunction getEstimatedDailyReward(address adr) public view returns(uint256){\r\n\t\tuint256 myEggsInOneDay = SafeMath.mul(MAX_REWARDS_ACCUMULATION_CUTOFF, users[adr].miners);\r\n\t\tmyEggsInOneDay = SafeMath.div(SafeMath.mul(myEggsInOneDay, ADJUSTED_REWARD_PERCENT),100);\r\n\t\tuint256 estimatedDailyReward = calculateEggSell(myEggsInOneDay);  //1 day estimated reward in BNB\r\n\t\treturn estimatedDailyReward;\r\n    }\r\n\r\n    function sellEggs() public nonReentrant{\r\n        require(initialized);\r\n\r\n\t\tUser storage user = users[msg.sender];\r\n\r\n\t\tif(sellCheck){\r\n\t\t\trequire(block.timestamp.sub(user.lastHatch) >= MAX_REWARDS_ACCUMULATION_CUTOFF, \"Please wait for 24 hours before trying to sell.\");\r\n\t\t}\r\n\r\n        if (blacklistActive) {\r\n            require(!Blacklisted[msg.sender], \"Address is blacklisted.\");\r\n        }\r\n\r\n        uint256 eggsByExistingMiners = getMyEggs(msg.sender);\r\n\r\n\t\tuint256 myEggs = SafeMath.div(SafeMath.mul(eggsByExistingMiners, ADJUSTED_REWARD_PERCENT),100); // adjust reward if needed\r\n\r\n        uint256 eggValue = calculateEggSell(myEggs);   // value in BNB\r\n\r\n\t\tif (eggValue == CAPPED_DAILY_REWARD_AMOUNT) {  // exceeds daily withdrawal limit\r\n\t\t\t\t// Adjusting myEggs for setting it to CAPPED_DAILY_REWARD_AMOUNT. Adjusted amount needs to be added to marketeggs\r\n\t\t\t\tuint256 myEggsAdjusted= SafeMath.div(SafeMath.mul(eggValue,SafeMath.mul(PSN,marketEggs)), SafeMath.sub(SafeMath.mul(PSN,address(this).balance),SafeMath.mul(2,SafeMath.mul(PSNH,eggValue))));\r\n\t\t\t\tif(myEggsAdjusted <= myEggs){\r\n\t\t\t\t\tmyEggs = myEggsAdjusted;\r\n\t\t\t\t}\r\n    \t}\r\n\r\n        uint256 fee = devFee(eggValue);\r\n\t\trecAdd.transfer(fee);\r\n\r\n\t\tuint256 netEggValue= SafeMath.sub(eggValue, fee);\r\n\r\n\t\tuint256 fee2 = JumpStartTVLFee(netEggValue);\r\n\t\tJumpStartTVLFund.transfer(fee2);\r\n\r\n\t\tnetEggValue= SafeMath.sub(netEggValue, fee2);\r\n\r\n\t\tif(getBalance() < netEggValue) {\r\n            netEggValue = getBalance();\r\n        }\r\n\r\n\t\tuser.lastWithdrawTime = block.timestamp;\r\n        user.lastHatch = block.timestamp;\r\n\r\n\t\tpayable(address(msg.sender)).transfer(netEggValue);\r\n\r\n\t\tuser.totalWithdrawn = SafeMath.add(user.totalWithdrawn, netEggValue);\r\n        totalWithdrawn =  SafeMath.add(totalWithdrawn, netEggValue);\r\n\r\n\t\tuint256 inflation = SafeMath.div(SafeMath.mul(myEggs, MARKETEGGS_SELL_INFLATION),100);\r\n        marketEggs=SafeMath.add(marketEggs, inflation);\r\n    }\r\n\r\n    function userRewards(address adr) public view returns(uint256) {\r\n        uint256 myEggs = getMyEggs(adr);    // Eggs Produced by ExistingMiners\r\n\t\tmyEggs = SafeMath.div(SafeMath.mul(myEggs, ADJUSTED_REWARD_PERCENT),100);\r\n\r\n        uint256 eggValue = calculateEggSell(myEggs);\r\n        return eggValue;\r\n    }\r\n\r\n    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) private view returns(uint256) {\r\n        return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt)));\r\n    }\r\n\r\n    function calculateEggSell(uint256 eggs) public view returns(uint256) {\r\n\t\tuint256 eggValue = calculateTrade(eggs, marketEggs, address(this).balance);  // value in BNB\r\n\r\n\t\tif (eggValue > CAPPED_DAILY_REWARD_AMOUNT) {  // exceeds daily withdrawal limit\r\n    \t\t  eggValue = CAPPED_DAILY_REWARD_AMOUNT;\r\n    \t}\r\n\r\n         return eggValue;\r\n    }\r\n\r\n    function calculateEggBuy(uint256 eth,uint256 contractBalance) public view returns(uint256) {\r\n        return calculateTrade(eth, contractBalance, marketEggs);    // value in Eggs\r\n    }\r\n\r\n\tfunction calculateMiners(uint256 eth) public view returns(uint256){\r\n\t\tuint256 eggsBought = calculateEggBuy(eth, getBalance());\r\n\t\tuint256 miners = eggsBought.div(EGGS_TO_HATCH_1MINERS);\r\n \t\treturn miners;\r\n    }\r\n\r\n\tfunction calculateMinersWithBonus(uint256 eth, address adr) public view returns(uint256){\r\n\t\tuint256 eggsBoughtWithoutBonus = calculateEggBuy(eth, getBalance());\r\n\t\tuint256 eggsBoughtWithBonus =applyBuyerBonus(adr, eggsBoughtWithoutBonus, eth);\r\n\t\tuint256 miners = eggsBoughtWithBonus.div(EGGS_TO_HATCH_1MINERS);\r\n \t\treturn miners;\r\n    }\r\n\r\n    function devFee(uint256 amount) private view returns(uint256) {\r\n        return SafeMath.div(SafeMath.mul(amount, DEV_PERCENT),100);\r\n    }\r\n\r\n    function JumpStartTVLFee(uint256 amount) private view returns(uint256) {\r\n        return SafeMath.div(SafeMath.mul(amount, JumpStartTVL_PERCENT),100);\r\n    }\r\n\r\n    function seedMarket() public payable onlyOwner {\r\n        require(marketEggs == 0);\r\n        initialized = true;\r\n        marketEggs = 108000000000;\r\n    }\r\n\r\n\t//fund contract with BNB before launch.\r\n    function fundContract() external payable {}\r\n\r\n\tfunction getUserInfo(address adr) public view returns(uint256 _initialDeposit, uint256 _userDeposit, uint256 _miners,\r\n     uint256 _lastHatch, address _referrer, uint256 _referralsCount, uint256 _totalWithdrawn, uint256 _refRewardsinBNB,\r\n\t uint256 _farmerCompoundCount, uint256 _lastWithdrawTime) {\r\n         _initialDeposit = users[adr].initialDeposit;\r\n         _userDeposit = users[adr].userDeposit;\r\n         _miners = users[adr].miners;\r\n         _lastHatch = users[adr].lastHatch;\r\n         _referrer = users[adr].referrer;\r\n         _referralsCount = users[adr].referralsCount;\r\n         _totalWithdrawn = users[adr].totalWithdrawn;\r\n         _refRewardsinBNB = users[adr].refRewardsinBNB;\r\n         _farmerCompoundCount = users[adr].farmerCompoundCount;  // total # of times person has ever compounded\r\n         _lastWithdrawTime = users[adr].lastWithdrawTime;\r\n\t}\r\n\r\n    function getBalance() public view returns(uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getTimeStamp() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function getSiteInfo() public view returns (uint256 _totalStaked, uint256 _totalDeposits, uint256 _totalCompound, uint256 _totalRefBonus) {\r\n        return (totalStaked, totalDeposits, totalCompound, totalRefBonus);\r\n    }\r\n\r\n    function getMyMiners(address adr) public view returns(uint256) {\r\n        return users[adr].miners;\r\n    }\r\n\r\n    function getMyEggs(address adr) public view returns(uint256) {\r\n        uint256 secondsPassed= min(MAX_REWARDS_ACCUMULATION_CUTOFF, SafeMath.sub(block.timestamp, users[adr].lastHatch));  // time passed since last buy/sell/compound\r\n        return SafeMath.mul(secondsPassed, users[adr].miners);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n\t/** Admin functions */\r\n\r\n\tfunction changeRecAdd(address payable value) external onlyOwner{\r\n        recAdd = value;\r\n    }\r\n\r\n\tfunction changeJumpStartTVLFund(address payable value) external onlyOwner{\r\n        JumpStartTVLFund = value;\r\n    }\r\n\r\n\tfunction Set_RewardRate_NewBuyers(uint256 value) external onlyOwner {\r\n        // 100 => No Bonus. 125 => 25% New Buyer Bonus oR 1.25x more Eggs\r\n\t\trequire(value >= 100 && value <= 500);\r\n        ADJUSTED_REWARD_PERCENT_NEWBUYERS = value;\r\n    }\r\n\r\n\tfunction Set_RewardRate_ExistingBuyers(uint256 value) external onlyOwner {\r\n        // Base: 3%. if ADJUSTED_REWARD_PERCENT = 50 => 3% * 50/100 = 1.5% Net Apy. if ADJUSTED_REWARD_PERCENT = 100 =>  3% * 100/100 = 3% Net Apy\r\n\t\trequire(value >= 5 && value <= 50000);\r\n        ADJUSTED_REWARD_PERCENT = value;\r\n    }\r\n\r\n\tfunction Set_Capped_DailyRewardAmount(uint256 capped_daily_reward_amount) external onlyOwner {\r\n\t\t// 50 BNB/Day == 50 * 1e18  ==  5000 * 1e16.\r\n\t\trequire(capped_daily_reward_amount >= 0);\r\n        CAPPED_DAILY_REWARD_AMOUNT = capped_daily_reward_amount * 1e16;\r\n    }\r\n\r\n \tfunction Set_Referral_Percent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100);\r\n        REFERRAL_PERCENT = value;\r\n    }\r\n\r\n \tfunction Set_Dev_Percent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 15);\r\n        DEV_PERCENT = value;\r\n    }\r\n\r\n\tfunction Set_JumpStartTVL_PERCENT(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0);\r\n        JumpStartTVL_PERCENT = value;\r\n    }\r\n\r\n\tfunction SetSellCheckActive(bool isSellCheckActive) external onlyOwner{\r\n        sellCheck = isSellCheckActive;\r\n    }\r\n\r\n\tfunction Set_MarketEggs_Buy_Inflation(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0);\r\n        MARKETEGGS_BUY_INFLATION = value;\r\n    }\r\n\r\n\tfunction Set_MarketEggs_Hatch_Inflation(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0);\r\n        MARKETEGGS_HATCH_INFLATION = value;\r\n    }\r\n\r\n\tfunction Set_MarketEggs_Sell_Inflation(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0);\r\n        MARKETEGGS_SELL_INFLATION = value;\r\n    }\r\n\r\n\tfunction SetBlacklistActive(bool isActive) external onlyOwner{\r\n        blacklistActive = isActive;\r\n    }\r\n\r\n    function blackListWallet(address Wallet, bool isBlacklisted) external onlyOwner{\r\n        Blacklisted[Wallet] = isBlacklisted;\r\n    }\r\n\r\n    function blackMultipleWallets(address[] calldata Wallet, bool isBlacklisted) external onlyOwner{\r\n        for(uint256 i = 0; i < Wallet.length; i++) {\r\n            Blacklisted[Wallet[i]] = isBlacklisted;\r\n        }\r\n    }\r\n\r\n    function checkIfBlacklisted(address Wallet) external onlyOwner view returns(bool blacklisted){\r\n        blacklisted = Blacklisted[Wallet];\r\n    }\r\n\r\n\tfunction setReferralWhitelistActive(bool isActive) external onlyOwner{\r\n        referralWhitelistActive = isActive;\r\n    }\r\n\r\n    function whitelistReferralWallet(address Wallet, bool isWhitelisted) external onlyOwner{\r\n        referralWhitelisted[Wallet] = isWhitelisted;\r\n    }\r\n\r\n    function whitelistMultipleReferralWallets(address[] calldata Wallet, bool isWhitelisted) external onlyOwner{\r\n        for(uint256 i = 0; i < Wallet.length; i++) {\r\n            referralWhitelisted[Wallet[i]] = isWhitelisted;\r\n        }\r\n    }\r\n\r\n    function checkIfReferralWhitelisted(address Wallet) external onlyOwner view returns(bool whitelisted){\r\n        whitelisted = referralWhitelisted[Wallet];\r\n    }\r\n\r\n\tfunction Set_ReferralsNeededToEarnCommission(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0);\r\n        referralsNeededToEarnCommission = value;\r\n    }\r\n\r\n\tfunction Override_Reentrancy_Status() external onlyOwner {\r\n\t\t// Set to 1 (_NOT_ENTERED) to override if ever need to\r\n\t\t_status = 1;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADJUSTED_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADJUSTED_REWARD_PERCENT_NEWBUYERS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAPPED_DAILY_REWARD_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEV_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EGGS_TO_HATCH_1MINERS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"JumpStartTVL_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETEGGS_BUY_INFLATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETEGGS_HATCH_INFLATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETEGGS_SELL_INFLATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REWARDS_ACCUMULATION_CUTOFF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Override_Reentrancy_Status\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"SetBlacklistActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isSellCheckActive\",\"type\":\"bool\"}],\"name\":\"SetSellCheckActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"capped_daily_reward_amount\",\"type\":\"uint256\"}],\"name\":\"Set_Capped_DailyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_Dev_Percent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_JumpStartTVL_PERCENT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_MarketEggs_Buy_Inflation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_MarketEggs_Hatch_Inflation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_MarketEggs_Sell_Inflation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_Referral_Percent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_ReferralsNeededToEarnCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_RewardRate_ExistingBuyers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Set_RewardRate_NewBuyers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBlacklisted\",\"type\":\"bool\"}],\"name\":\"blackListWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"Wallet\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isBlacklisted\",\"type\":\"bool\"}],\"name\":\"blackMultipleWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklistActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"buyEggs\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"calculateEggBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggs\",\"type\":\"uint256\"}],\"name\":\"calculateEggSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"calculateMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"calculateMinersWithBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"changeJumpStartTVLFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"changeRecAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"}],\"name\":\"checkIfBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"}],\"name\":\"checkIfReferralWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getEstimatedDailyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMyEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMyMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSiteInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalCompound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalRefBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_miners\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastHatch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referralsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refRewardsinBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_farmerCompoundCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastWithdrawTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hatchEggs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralWhitelistActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralsNeededToEarnCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedMarket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellEggs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"setReferralWhitelistActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCompound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRefBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"userRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"miners\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastHatch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refRewardsinBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farmerCompoundCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"Wallet\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"whitelistMultipleReferralWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"whitelistReferralWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlockRewards", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7d1fc8e76a6ad21a3e9c05706c1b020ab6e047d30a77349bb2d7c0c5f1320632"}