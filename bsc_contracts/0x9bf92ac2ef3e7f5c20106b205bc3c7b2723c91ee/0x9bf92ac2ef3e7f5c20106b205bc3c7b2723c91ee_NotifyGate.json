{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/INotifyGate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"oz-custom/contracts/oz/token/ERC20/IERC20.sol\\\";\\nimport {\\n    IERC20Permit\\n} from \\\"oz-custom/contracts/oz/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport {\\n    IERC721,\\n    ERC721TokenReceiver\\n} from \\\"oz-custom/contracts/oz/token/ERC721/ERC721.sol\\\";\\n\\ninterface INotifyGate {\\n    error NofifyGate__ExecutionFailed();\\n\\n    event Notified(\\n        address indexed sender,\\n        bytes indexed message,\\n        address indexed token,\\n        uint256 value\\n    );\\n\\n    function notifyWithNative(bytes calldata message_) external payable;\\n\\n    function notifyWithERC20(\\n        IERC20 token_,\\n        uint256 value_,\\n        uint256 deadline_,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes calldata message_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/internal/BKFundForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {FundForwarder} from \\\"oz-custom/contracts/internal/FundForwarder.sol\\\";\\n\\nimport {ITreasury} from \\\"oz-custom/contracts/presets/interfaces/ITreasury.sol\\\";\\n\\nimport {\\n    ERC165Checker\\n} from \\\"oz-custom/contracts/oz/utils/introspection/ERC165Checker.sol\\\";\\n\\nabstract contract BKFundForwarder is FundForwarder {\\n    using ERC165Checker for address;\\n\\n    function safeRecoverHeader() public pure override returns (bytes memory) {\\n        /// @dev value is equal keccak256(\\\"SAFE_RECOVER_HEADER\\\")\\n        return\\n            bytes.concat(\\n                bytes32(\\n                    0x556d79614195ebefcc31ab1ee514b9953934b87d25857902370689cbd29b49de\\n                )\\n            );\\n    }\\n\\n    function safeTransferHeader() public pure override returns (bytes memory) {\\n        /// @dev value is equal keccak256(\\\"SAFE_TRANSFER\\\")\\n        return\\n            bytes.concat(\\n                bytes32(\\n                    0xc9627ddb76e5ee80829319617b557cc79498bbbc5553d8c632749a7511825f5d\\n                )\\n            );\\n    }\\n\\n    function _checkValidAddress(address vault_) internal view override {\\n        super._checkValidAddress(vault_);\\n        if (!vault_.supportsInterface(type(ITreasury).interfaceId))\\n            revert FundForwarder__InvalidArgument();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NotifyGate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {FundForwarder, BKFundForwarder} from \\\"./internal/BKFundForwarder.sol\\\";\\n\\nimport {\\n    Roles,\\n    Manager,\\n    IAuthority\\n} from \\\"oz-custom/contracts/presets/base/Manager.sol\\\";\\nimport {\\n    ReentrancyGuard\\n} from \\\"oz-custom/contracts/oz/security/ReentrancyGuard.sol\\\";\\n\\nimport {INotifyGate} from \\\"./interfaces/INotifyGate.sol\\\";\\nimport {\\n    IWithdrawable\\n} from \\\"oz-custom/contracts/internal/interfaces/IWithdrawable.sol\\\";\\n\\nimport {\\n    IFundForwarder\\n} from \\\"oz-custom/contracts/internal/interfaces/IFundForwarder.sol\\\";\\n\\nimport {\\n    IERC20,\\n    IERC20Permit\\n} from \\\"oz-custom/contracts/oz/token/ERC20/extensions/IERC20Permit.sol\\\";\\n\\nimport {\\n    IERC721,\\n    ERC721TokenReceiver\\n} from \\\"oz-custom/contracts/oz/token/ERC721/ERC721.sol\\\";\\n\\ncontract NotifyGate is\\n    Manager,\\n    INotifyGate,\\n    ReentrancyGuard,\\n    BKFundForwarder,\\n    ERC721TokenReceiver\\n{\\n    constructor(\\n        IAuthority authority_\\n    ) payable ReentrancyGuard() Manager(authority_, 0) {\\n        _changeVault(IFundForwarder(address(authority_)).vault());\\n    }\\n\\n    function changeVault(\\n        address vault_\\n    ) external override onlyRole(Roles.TREASURER_ROLE) {\\n        _changeVault(vault_);\\n    }\\n\\n    function notifyWithNative(bytes calldata message_) external payable {\\n        _safeNativeTransfer(vault(), msg.value, \\\"\\\");\\n        emit Notified(_msgSender(), message_, address(0), msg.value);\\n    }\\n\\n    function onERC721Received(\\n        address from_,\\n        address,\\n        uint256 tokenId_,\\n        bytes calldata message_\\n    ) external override returns (bytes4) {\\n        address nft = _msgSender();\\n        IERC721(nft).safeTransferFrom(\\n            address(this),\\n            vault(),\\n            tokenId_,\\n            safeTransferHeader()\\n        );\\n\\n        emit Notified(from_, message_, nft, tokenId_);\\n\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function notifyWithERC20(\\n        IERC20 token_,\\n        uint256 value_,\\n        uint256 deadline_,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes calldata message_\\n    ) external nonReentrant {\\n        address user = _msgSender();\\n        if (token_.allowance(user, address(this)) < value_) {\\n            IERC20Permit(address(token_)).permit(\\n                user,\\n                address(this),\\n                value_,\\n                deadline_,\\n                v,\\n                r,\\n                s\\n            );\\n        }\\n\\n        address _vault = vault();\\n\\n        _safeERC20TransferFrom(token_, user, _vault, value_);\\n\\n        if (\\n            IWithdrawable(_vault).notifyERC20Transfer(\\n                address(token_),\\n                value_,\\n                safeTransferHeader()\\n            ) != IWithdrawable.notifyERC20Transfer.selector\\n        ) revert NofifyGate__ExecutionFailed();\\n\\n        emit Notified(user, message_, address(token_), value_);\\n    }\\n\\n    function _beforeRecover(\\n        bytes memory\\n    ) internal override whenPaused onlyRole(Roles.OPERATOR_ROLE) {}\\n\\n    function _afterRecover(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) internal override {}\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/FundForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../oz/utils/Context.sol\\\";\\n\\nimport {Transferable} from \\\"./Transferable.sol\\\";\\nimport {ProxyChecker} from \\\"./ProxyChecker.sol\\\";\\n\\nimport {IFundForwarder} from \\\"./interfaces/IFundForwarder.sol\\\";\\n\\nimport {ErrorHandler} from \\\"../libraries/ErrorHandler.sol\\\";\\n\\n/**\\n * @title FundForwarder\\n * @dev Abstract contract for forwarding funds to a specified address.\\n */\\nabstract contract FundForwarder is\\n    Context,\\n    ProxyChecker,\\n    Transferable,\\n    IFundForwarder\\n{\\n    using ErrorHandler for bool;\\n    /**\\n     * @dev Address to forward funds to\\n     */\\n    bytes32 private __vault;\\n\\n    /**\\n     * @dev Receives funds and forwards them to the vault address\\n     */\\n    receive() external payable virtual onlyEOA {\\n        _beforeRecover(\\\"\\\");\\n        address _vault = vault();\\n\\n        _safeNativeTransfer(_vault, msg.value, safeRecoverHeader());\\n\\n        emit Forwarded(_msgSender(), msg.value);\\n\\n        _afterRecover(_vault, address(0), msg.value, \\\"\\\");\\n    }\\n\\n    function recover(RecoveryCallData[] calldata calldata_) external virtual {\\n        _beforeRecover(\\\"\\\");\\n\\n        address _vault = vault();\\n        address sender = _msgSender();\\n        uint256 length = calldata_.length;\\n        bytes[] memory results = new bytes[](length);\\n\\n        bool ok;\\n        bytes memory result;\\n        for (uint256 i; i < length; ) {\\n            (ok, result) = calldata_[i].token.call{value: calldata_[i].value}(\\n                abi.encodePacked(calldata_[i].fnSelector, calldata_[i].params)\\n            );\\n\\n            ok.handleRevertIfNotSuccess(result);\\n\\n            results[i] = result;\\n\\n            _afterRecover(\\n                _vault,\\n                calldata_[i].token,\\n                calldata_[i].value,\\n                calldata_[i].params\\n            );\\n\\n            emit Recovered(\\n                sender,\\n                calldata_[i].token,\\n                calldata_[i].value,\\n                calldata_[i].params\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IFundForwarder\\n    function recoverNative() external virtual {\\n        _beforeRecover(\\\"\\\");\\n        address sender = _msgSender();\\n        _onlyEOA(sender);\\n\\n        address _vault = vault();\\n        uint256 balance = address(this).balance;\\n        _safeNativeTransfer(_vault, balance, safeRecoverHeader());\\n\\n        emit Recovered(sender, address(0), balance, \\\"\\\");\\n\\n        _afterRecover(_vault, address(0), balance, \\\"\\\");\\n    }\\n\\n    function vault() public view virtual returns (address vault_) {\\n        assembly {\\n            vault_ := sload(__vault.slot)\\n        }\\n\\n        _checkValidAddress(vault_);\\n    }\\n\\n    function safeRecoverHeader() public pure virtual returns (bytes memory);\\n\\n    function safeTransferHeader() public pure virtual returns (bytes memory);\\n\\n    /**\\n     * @dev Changes the vault address\\n     * @param vault_ New vault address\\n     */\\n    function _changeVault(address vault_) internal virtual {\\n        _checkValidAddress(vault_);\\n\\n        assembly {\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"VaultUpdated(address,address,address)\\\")\\n                0x2afec66505e0ceed692012e3833f6609d4933ded34732135bc05f28423744065,\\n                caller(),\\n                sload(__vault.slot),\\n                vault_\\n            )\\n\\n            sstore(__vault.slot, vault_)\\n        }\\n    }\\n\\n    function _beforeRecover(bytes memory data_) internal virtual;\\n\\n    function _afterRecover(\\n        address vault_,\\n        address token_,\\n        uint256 value_,\\n        bytes memory params_\\n    ) internal virtual;\\n\\n    /**\\n     *@dev Asserts that the given address is not the zero address\\n     *@param addr_ The address to check\\n     *@custom:throws FundForwarder__InvalidArgument if the address is the zero address\\n     */\\n    function _checkValidAddress(address addr_) internal view virtual {\\n        if (addr_ == address(0) || addr_ == address(this))\\n            revert FundForwarder__InvalidArgument();\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/interfaces/IBlacklistable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IBlacklistable {\\n    event UserStatusSet(\\n        address indexed operator,\\n        address indexed account,\\n        bool indexed isBlacklisted\\n    );\\n\\n    /**\\n     * @dev Set the status of an account to either blacklisted or not blacklisted.\\n     * @param account_ The address to change the status of.\\n     * @param status The new status for the address. True for blacklisted, false for not blacklisted.\\n     */\\n    function setUserStatus(address account_, bool status) external;\\n\\n    /**\\n     * @dev Check if an address is blacklisted.\\n     * @param account_ The address to check.\\n     * @return True if the address is blacklisted, false otherwise.\\n     */\\n    function isBlacklisted(address account_) external view returns (bool);\\n\\n    function areBlacklisted(\\n        address[] calldata accounts_\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/interfaces/IFundForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"../../oz/token/ERC20/IERC20.sol\\\";\\n\\nimport {\\n    IERC721,\\n    IERC721Enumerable\\n} from \\\"../../oz/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IFundForwarder {\\n    error FundForwarder__InvalidArgument();\\n\\n    struct RecoveryCallData {\\n        address token;\\n        uint256 value;\\n        bytes4 fnSelector;\\n        bytes params;\\n    }\\n\\n    /**\\n     * @dev Emits when the vault address is updated\\n     * @param from Old vault address\\n     * @param to New vault address\\n     */\\n    event VaultUpdated(address indexed from, address indexed to);\\n\\n    /**\\n     *@dev Emits when a single ERC721 token is recovered\\n     *@param operator Address of the contract calling this function\\n     *@param token Address of the token contract\\n     *@param value Token ID of the recovered token\\n     */\\n    event Recovered(\\n        address indexed operator,\\n        address indexed token,\\n        uint256 indexed value,\\n        bytes params\\n    );\\n\\n    /**\\n     * @dev Emits when funds are forwarded\\n     * @param from Address of the sender\\n     * @param amount Amount of funds forwarded\\n     */\\n    event Forwarded(address indexed from, uint256 indexed amount);\\n\\n    function safeRecoverHeader() external pure returns (bytes memory);\\n\\n    function safeTransferHeader() external pure returns (bytes memory);\\n\\n    function changeVault(address vault_) external;\\n\\n    function vault() external view returns (address);\\n\\n    /**\\n     * @dev Recovers native currency to the vault address\\n     */\\n    function recoverNative() external;\\n\\n    function recover(RecoveryCallData[] calldata calldata_) external;\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/interfaces/IWithdrawable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IWithdrawable {\\n    event Withdrawn(\\n        address indexed token,\\n        address indexed to,\\n        uint256 indexed value\\n    );\\n\\n    /**\\n     * @dev Event emitted when funds are received by the contract\\n     */\\n    event Received(\\n        address indexed sender,\\n        address indexed token,\\n        bytes value,\\n        bytes data\\n    );\\n\\n    function notifyERC20Transfer(\\n        address token_,\\n        uint256 value_,\\n        bytes calldata data_\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Withdraws the given amount of tokens or Ether from the contract\\n     * @param token_ Address of the token contract to withdraw. If zero address, withdraw Ether.\\n     * @param to_ Address to send the tokens or Ether to\\n     * @param amount_ Amount of tokens or Ether to withdraw\\n     */\\n    function withdraw(\\n        address token_,\\n        address to_,\\n        uint256 amount_,\\n        bytes calldata data_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/ProxyChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Revert error if call is made from a proxy contract\\n */\\nerror ProxyChecker__EOAUnallowed();\\n/**\\n * @dev Revert error if call is made from an externally owned account\\n */\\nerror ProxyChecker__ProxyUnallowed();\\n\\n/**\\n * @title ProxyChecker\\n * @dev Abstract contract for checking if a call was made by a proxy contract or an externally owned account.\\n */\\nabstract contract ProxyChecker {\\n    modifier onlyProxy() {\\n        _onlyProxy(msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to allow a function to be called only by an externally owned account\\n     */\\n    modifier onlyEOA() {\\n        _onlyEOA(msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the sender is an externally owned account\\n     * @param sender_ Address of the sender\\n     */\\n    function _onlyEOA(address sender_) internal view {\\n        _onlyEOA(sender_, _txOrigin());\\n    }\\n\\n    /**\\n     * @dev Check if the sender is an externally owned account\\n     * @param msgSender_ Address of the sender\\n     * @param txOrigin_ Origin of the transaction\\n     */\\n    function _onlyEOA(address msgSender_, address txOrigin_) internal pure {\\n        if (_isProxyCall(msgSender_, txOrigin_))\\n            revert ProxyChecker__ProxyUnallowed();\\n    }\\n\\n    /**\\n     * @dev Check if the sender is a proxy contract\\n     * @param sender_ Address of the sender\\n     */\\n    function _onlyProxy(address sender_) internal view {\\n        if (!(_isProxyCall(sender_, _txOrigin()) || _isProxy(sender_)))\\n            revert ProxyChecker__EOAUnallowed();\\n    }\\n\\n    /**\\n     * @dev Check if the sender is a proxy contract\\n     * @param msgSender_ Address of the sender\\n     * @param txOrigin_ Origin of the transaction\\n     */\\n    function _onlyProxy(address msgSender_, address txOrigin_) internal view {\\n        if (!(_isProxyCall(msgSender_, txOrigin_) || _isProxy(msgSender_)))\\n            revert ProxyChecker__EOAUnallowed();\\n    }\\n\\n    /**\\n     * @dev Check if the call was made by a proxy contract\\n     * @param msgSender_ Address of the sender\\n     * @param txOrigin_ Origin of the transaction\\n     * @return True if the call was made by a proxy contract, false otherwise\\n     */\\n    function _isProxyCall(\\n        address msgSender_,\\n        address txOrigin_\\n    ) internal pure returns (bool) {\\n        return msgSender_ != txOrigin_;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is a proxy contract\\n     * @param caller_ Address of the caller\\n     * @return True if the caller is a proxy contract, false otherwise\\n     */\\n    function _isProxy(address caller_) internal view returns (bool) {\\n        return caller_.code.length != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the origin of the transaction\\n     * @return Origin of the transaction\\n     */\\n    function _txOrigin() internal view returns (address) {\\n        return tx.origin;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/internal/Transferable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"../oz/token/ERC20/IERC20.sol\\\";\\n\\nerror Transferable__TransferFailed();\\nerror Transferable__InvalidArguments();\\n\\n/**\\n * @dev Library for transferring Ether and tokens between accounts\\n */\\nabstract contract Transferable {\\n    /**\\n     * @dev Reverts the transaction if the transfer fails\\n     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.\\n     * @param from_ Address to transfer from\\n     * @param to_ Address to transfer to\\n     * @param value_ Amount of tokens or Ether to transfer\\n     */\\n    function _safeTransferFrom(\\n        address token_,\\n        address from_,\\n        address to_,\\n        uint256 value_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, value_);\\n\\n        if (\\n            token_ == address(0)\\n                ? _nativeTransfer(to_, value_, data_)\\n                : _ERC20TransferFrom(IERC20(token_), from_, to_, value_)\\n        ) return;\\n\\n        revert Transferable__TransferFailed();\\n    }\\n\\n    /**\\n     * @dev Reverts the transaction if the transfer fails\\n     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.\\n     * @param to_ Address to transfer to\\n     * @param value_ Amount of tokens or Ether to transfer\\n     */\\n    function _safeTransfer(\\n        address token_,\\n        address to_,\\n        uint256 value_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, value_);\\n\\n        if (\\n            token_ == address(0)\\n                ? _nativeTransfer(to_, value_, data_)\\n                : _ERC20Transfer(IERC20(token_), to_, value_)\\n        ) return;\\n\\n        revert Transferable__TransferFailed();\\n    }\\n\\n    /**\\n     * @dev Reverts the transaction if the Ether transfer fails\\n     * @param to_ Address to transfer to\\n     * @param amount_ Amount of Ether to transfer\\n     */\\n    function _safeNativeTransfer(\\n        address to_,\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n        if (!_nativeTransfer(to_, amount_, data_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _safeERC20Transfer(\\n        IERC20 token_,\\n        address to_,\\n        uint256 amount_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n        if (!_ERC20Transfer(token_, to_, amount_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _safeERC20TransferFrom(\\n        IERC20 token_,\\n        address from_,\\n        address to_,\\n        uint256 amount_\\n    ) internal virtual {\\n        __checkValidTransfer(to_, amount_);\\n\\n        if (!_ERC20TransferFrom(token_, from_, to_, amount_))\\n            revert Transferable__TransferFailed();\\n    }\\n\\n    function _nativeTransfer(\\n        address to_,\\n        uint256 amount_,\\n        bytes memory data_\\n    ) internal virtual returns (bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(\\n                gas(),\\n                to_,\\n                amount_,\\n                add(data_, 32),\\n                mload(data_),\\n                0,\\n                0\\n            )\\n        }\\n    }\\n\\n    function _ERC20Transfer(\\n        IERC20 token_,\\n        address to_,\\n        uint256 value_\\n    ) internal virtual returns (bool success) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to_) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), value_) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n    }\\n\\n    function _ERC20TransferFrom(\\n        IERC20 token_,\\n        address from_,\\n        address to_,\\n        uint256 value_\\n    ) internal virtual returns (bool success) {\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), from_)\\n            mstore(add(freeMemoryPointer, 36), to_)\\n            mstore(add(freeMemoryPointer, 68), value_)\\n\\n            success := and(\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n    }\\n\\n    function __checkValidTransfer(address to_, uint256 value_) private pure {\\n        if (value_ == 0 || to_ == address(0))\\n            revert Transferable__InvalidArguments();\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/ErrorHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nerror ErrorHandler__ExecutionFailed();\\n\\nlibrary ErrorHandler {\\n    function handleRevertIfNotSuccess(\\n        bool ok_,\\n        bytes memory revertData_\\n    ) internal pure {\\n        assembly {\\n            if iszero(ok_) {\\n                let revertLength := mload(revertData_)\\n                if iszero(iszero(revertLength)) {\\n                    // Start of revert data bytes. The 0x20 offset is always the same.\\n                    revert(add(revertData_, 0x20), revertLength)\\n                }\\n\\n                //  revert ErrorHandler__ExecutionFailed()\\n                mstore(0x00, 0xa94eec76)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/libraries/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary Roles {\\n    bytes32 public constant PROXY_ROLE =\\n        0x77d72916e966418e6dc58a19999ae9934bef3f749f1547cde0a86e809f19c89b;\\n    bytes32 public constant SIGNER_ROLE =\\n        0xe2f4eaae4a9751e85a3e4a7b9587827a877f29914755229b07a7b2da98285f70;\\n    bytes32 public constant PAUSER_ROLE =\\n        0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a;\\n    bytes32 public constant MINTER_ROLE =\\n        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\\n    bytes32 public constant OPERATOR_ROLE =\\n        0x97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b929;\\n    bytes32 public constant UPGRADER_ROLE =\\n        0x189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e3;\\n    bytes32 public constant TREASURER_ROLE =\\n        0x3496e2e73c4d42b75d702e60d9e48102720b8691234415963a5a857b86425d07;\\n    bytes32 public constant FACTORY_ROLE =\\n        0xdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee27;\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    error AccessControl__Unauthorized();\\n    error AccessControl__RoleMissing(bytes32 role, address account);\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\ninterface IPausable {\\n    error Pausable__Paused();\\n    error Pausable__NotPaused();\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address indexed account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address indexed account);\\n\\n    /**\\n     * @dev Pauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Unpauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.\\n     */\\n    function unpause() external;\\n\\n    function paused() external view returns (bool isPaused);\\n}\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context, IPausable {\\n    uint256 private __paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() payable {\\n        assembly {\\n            sstore(__paused.slot, 1)\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool isPaused) {\\n        assembly {\\n            isPaused := eq(2, sload(__paused.slot))\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        assembly {\\n            if eq(2, sload(__paused.slot)) {\\n                mstore(0x00, 0x059519da)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        assembly {\\n            if eq(1, sload(__paused.slot)) {\\n                mstore(0x00, 0x59488a5a)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        address sender = _msgSender();\\n        assembly {\\n            sstore(__paused.slot, 2)\\n            log2(\\n                0,\\n                0,\\n                /// @dev value is equal to keccak256(\\\"Paused(address)\\\")\\n                0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258,\\n                sender\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        address sender = _msgSender();\\n        assembly {\\n            sstore(__paused.slot, 1)\\n            log2(\\n                0,\\n                0,\\n                /// @dev value is equal to keccak256(\\\"Unpaused(address)\\\")\\n                0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa,\\n                sender\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.10;\\n\\nerror ReentrancyGuard__Locked();\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private __locked;\\n\\n    modifier nonReentrant() {\\n        __nonReentrantBefore();\\n        _;\\n        __nonReentrantAfter();\\n    }\\n\\n    constructor() payable {\\n        assembly {\\n            sstore(__locked.slot, 1)\\n        }\\n    }\\n\\n    function __nonReentrantBefore() private {\\n        assembly {\\n            if eq(sload(__locked.slot), 2) {\\n                mstore(0x00, 0xc0d27a97)\\n                revert(0x1c, 0x04)\\n            }\\n            sstore(__locked.slot, 2)\\n        }\\n    }\\n\\n    function __nonReentrantAfter() private {\\n        assembly {\\n            sstore(__locked.slot, 1)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    error ERC20Permit__Expired();\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    error ERC20__StringTooLong();\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.10;\\n\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {ERC165, IERC165} from \\\"../../utils/introspection/ERC165.sol\\\";\\nimport {BitMaps} from \\\"../../utils/structs/BitMaps.sol\\\";\\nimport {IERC721} from \\\"./IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"./extensions/IERC721Metadata.sol\\\";\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n    string public symbol;\\n\\n    function _baseURI() internal view virtual returns (string memory);\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => bytes32) internal _ownerOf;\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(\\n        uint256 id\\n    ) public view virtual override returns (address owner) {\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x20, _ownerOf.slot)\\n            owner := sload(keccak256(0x00, 0x40))\\n\\n            if iszero(owner) {\\n                // Store the function selector of `ERC721__NotMinted()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0xf2c8ced6)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    function balanceOf(\\n        address owner\\n    ) public view virtual override returns (uint256 balance_) {\\n        assembly {\\n            if iszero(owner) {\\n                // Store the function selector of `ERC721__NonZeroAddress()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0xf8a06d80)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // balance_ = _balanceOf[owner]\\n            mstore(0x00, owner)\\n            mstore(0x20, _balanceOf.slot)\\n            balance_ := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => bytes32) internal _getApproved;\\n    mapping(address => BitMaps.BitMap) internal _isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) payable {\\n        if (bytes(_name).length > 32 || bytes(_symbol).length > 32)\\n            revert ERC721__StringTooLong();\\n\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address sender = _msgSender();\\n        assembly {\\n            /// @dev owner = _ownerOf[id]\\n            mstore(0x00, id)\\n            mstore(0x20, _ownerOf.slot)\\n            let owner := sload(keccak256(0x00, 0x40))\\n\\n            /// @dev if (sender != owner)\\n            if iszero(eq(sender, owner)) {\\n                // check whether sender has approval for all id of owner\\n                mstore(0x00, owner)\\n                mstore(0x20, _isApprovedForAll.slot)\\n                // store _isApprovedForAll[owner] key at 0x20\\n                mstore(0x20, keccak256(0x00, 0x40))\\n                // override last 248 bit of sender as index to 0x00 for hashing\\n                mstore(0x00, shr(0x08, sender))\\n\\n                // revert if the approved bit is not set\\n                if iszero(\\n                    and(\\n                        sload(keccak256(0x00, 0x40)),\\n                        shl(and(sender, 0xff), 0x01)\\n                    )\\n                ) {\\n                    // Store the function selector of `ERC721__Unauthorized()`.\\n                    // Revert with (offset, size).\\n                    mstore(0x00, 0x1fad8706)\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            //  _getApproved[id] = spender\\n            mstore(0x00, id)\\n            mstore(0x20, _getApproved.slot)\\n            sstore(keccak256(0x00, 0x40), spender)\\n\\n            // emit Approval(owner, spender, id)\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Approval(address,address,uint256)\\\")\\n                0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925,\\n                owner,\\n                spender,\\n                id\\n            )\\n        }\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public virtual {\\n        address sender = _msgSender();\\n        assembly {\\n            //  _isApprovedForAll[sender].setTo(operator, approved)\\n            mstore(0, sender)\\n            mstore(32, _isApprovedForAll.slot)\\n            mstore(32, keccak256(0, 64))\\n            mstore(0, shr(8, operator))\\n\\n            let mapKey := keccak256(0, 64)\\n            let value := sload(mapKey)\\n\\n            // The following sets the bit at `shift` without branching.\\n            let shift := and(operator, 0xff)\\n            // Isolate the bit at `shift`.\\n            let x := and(shr(shift, value), 1)\\n            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.\\n            x := xor(x, approved)\\n            // Shifts the bit back. Then, xor with value.\\n            // Only the bit at `shift` will be flipped if they differ.\\n            // Every other bit will stay the same, as they are xor'ed with zeroes.\\n            value := xor(value, shl(shift, x))\\n\\n            sstore(mapKey, value)\\n\\n            //  emit ApprovalForAll(sender, operator, approved)\\n            mstore(0x00, approved)\\n\\n            log3(\\n                0x00,\\n                0x20,\\n                /// @dev value is equal to keccak256(\\\"ApprovalForAll(address,address,bool)\\\")\\n                0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31,\\n                sender,\\n                operator\\n            )\\n        }\\n    }\\n\\n    function getApproved(\\n        uint256 tokenId\\n    ) external view returns (address approval) {\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _getApproved.slot)\\n            approval := sload(keccak256(0x00, 0x40))\\n        }\\n    }\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool approved) {\\n        assembly {\\n            mstore(0x00, owner)\\n            mstore(0x20, _isApprovedForAll.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, shr(0x08, operator))\\n            approved := and(\\n                sload(keccak256(0x00, 0x40)),\\n                shl(and(operator, 0xff), 1)\\n            )\\n        }\\n    }\\n\\n    function _isApprovedOrOwner(\\n        address spender,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool isApprovedOrOwner_) {\\n        address owner = ownerOf(tokenId);\\n        assembly {\\n            // if spender is owner\\n            if eq(spender, owner) {\\n                isApprovedOrOwner_ := true\\n            }\\n\\n            if iszero(isApprovedOrOwner_) {\\n                // if _getApproved[tokenId] == spender\\n                mstore(0x00, tokenId)\\n                mstore(0x20, _getApproved.slot)\\n                let approved := sload(keccak256(0x00, 0x40))\\n                if eq(approved, spender) {\\n                    isApprovedOrOwner_ := true\\n                }\\n\\n                if iszero(isApprovedOrOwner_) {\\n                    // if _isApprovedForAll[owner][spender] == true\\n                    mstore(0x00, owner)\\n                    mstore(0x20, _isApprovedForAll.slot)\\n                    // store _isApprovedForAll[owner] key at 0x20\\n                    mstore(0x20, keccak256(0x00, 0x40))\\n\\n                    // store last 248 bit of spender as index\\n                    mstore(0x00, shr(0x08, spender))\\n\\n                    // check if the bit is turned in the bitmap\\n                    approved := and(\\n                        sload(keccak256(0x00, 0x40)),\\n                        shl(and(spender, 0xff), 1)\\n                    )\\n\\n                    if approved {\\n                        isApprovedOrOwner_ := true\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 /* firstTokenId */,\\n        uint256 batchSize\\n    ) internal virtual {\\n        assembly {\\n            if gt(batchSize, 1) {\\n                mstore(0x20, _balanceOf.slot)\\n                let key\\n                let balanceBefore\\n                if iszero(iszero(from)) {\\n                    mstore(0x00, from)\\n                    key := keccak256(0x00, 0x40)\\n                    balanceBefore := sload(key)\\n                    //  underflow check\\n                    if gt(balanceBefore, batchSize) {\\n                        revert(0, 0)\\n                    }\\n                    sstore(key, sub(balanceBefore, batchSize))\\n                }\\n                if iszero(iszero(to)) {\\n                    mstore(0x00, to)\\n                    key := keccak256(0x00, 0x40)\\n                    balanceBefore := sload(key)\\n                    //  overflow check\\n                    balanceBefore := add(balanceBefore, batchSize)\\n                    if lt(balanceBefore, batchSize) {\\n                        revert(0, 0)\\n                    }\\n                    sstore(key, balanceBefore)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        _beforeTokenTransfer(from, to, id, 1);\\n\\n        address sender = _msgSender();\\n        assembly {\\n            if iszero(to) {\\n                // Store the function selector of `ERC721__InvalidRecipient()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x28ede692)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x00, id)\\n            mstore(32, _ownerOf.slot)\\n            let ownerOfKey := keccak256(0, 64)\\n\\n            if iszero(eq(from, sload(ownerOfKey))) {\\n                // Store the function selector of `ERC721__WrongFrom()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x0ef14eef)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x20, _getApproved.slot)\\n            let approvedKey := keccak256(0x00, 0x40)\\n\\n            if iszero(eq(sender, from)) {\\n                if iszero(eq(sender, sload(approvedKey))) {\\n                    mstore(0x00, from)\\n                    mstore(0x20, _isApprovedForAll.slot)\\n\\n                    mstore(0x20, keccak256(0x00, 0x40))\\n                    mstore(0x00, shr(0x08, sender))\\n\\n                    if iszero(\\n                        and(sload(keccak256(0, 64)), shl(and(sender, 0xff), 1))\\n                    ) {\\n                        // Store the function selector of `ERC721__Unauthorized()`.\\n                        // Revert with (offset, size).\\n                        mstore(0x00, 0x1fad8706)\\n                        revert(0x1c, 0x04)\\n                    }\\n                }\\n            }\\n\\n            // Underflow of the sender's balance is impossible because we check for\\n            // ownership above and the recipient's balance can't realistically\\n\\n            //  ++_balanceOf[to];\\n            mstore(0x00, to)\\n            mstore(0x20, _balanceOf.slot)\\n            let key := keccak256(0x00, 0x40)\\n            let balanceBefore := add(1, sload(key))\\n            sstore(key, balanceBefore)\\n\\n            //  --_balanceOf[from];\\n            mstore(0x00, from)\\n            key := keccak256(0x00, 0x40)\\n            balanceBefore := sub(sload(key), 1)\\n            sstore(key, balanceBefore)\\n\\n            //  _ownerOf[id] = to\\n            sstore(ownerOfKey, to)\\n            //  delete _getApproved[id];\\n            sstore(approvedKey, 0)\\n\\n            // emit Transfer(from, to, id);\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                from,\\n                to,\\n                id\\n            )\\n        }\\n\\n        _afterTokenTransfer(from, to, id, 1);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        assembly {\\n            // if to == address(0) revert\\n            if iszero(to) {\\n                // Store the function selector of `ERC721__InvalidRecipient()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x28ede692)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // cache tokenId at 0x00 for later use\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _ownerOf.slot)\\n            let key := keccak256(0x00, 0x40)\\n\\n            if iszero(eq(from, sload(key))) {\\n                // Store the function selector of `ERC721__WrongFrom()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x0ef14eef)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            //  _ownerOf[tokenId] = to\\n            sstore(key, to)\\n\\n            //  emit Transfer(from, to, tokenId);\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                from,\\n                to,\\n                tokenId\\n            )\\n\\n            // delete _getApproved[tokenId];\\n            mstore(0x20, _getApproved.slot)\\n            mstore(keccak256(0x00, 0x40), 0)\\n\\n            // ++_balanceOf[to]\\n            // cached _balanceOf slot for later use\\n            mstore(0x20, _balanceOf.slot)\\n            mstore(0x00, to)\\n            key := keccak256(0x00, 0x40)\\n            sstore(key, add(1, sload(key)))\\n\\n            // --_balanceOf[from]\\n            mstore(0x00, from)\\n            key := keccak256(0x00, 0x40)\\n            sstore(key, sub(sload(key), 1))\\n        }\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        _beforeTokenTransfer(address(0), to, id, 1);\\n\\n        assembly {\\n            if iszero(to) {\\n                // Store the function selector of `ERC721__InvalidRecipient()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0x28ede692)\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0, id)\\n            mstore(32, _ownerOf.slot)\\n            let key := keccak256(0, 64)\\n            /// @dev cachedVal = _ownerOf[id]\\n            let cachedVal := sload(key)\\n\\n            /// @dev if (owner != 0) revert\\n            if iszero(iszero(cachedVal)) {\\n                mstore(0x00, 0xec125a85)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            /// @dev emit Transfer(address(0), to, id)\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                0,\\n                to,\\n                id\\n            )\\n\\n            /// @dev _ownerOf[id] = to\\n            sstore(key, to)\\n\\n            mstore(0, to)\\n            mstore(32, _balanceOf.slot)\\n            key := keccak256(0, 64)\\n            /// @dev cachedVal = _balanceOf[to] + 1\\n            cachedVal := add(sload(key), 1)\\n            sstore(key, cachedVal)\\n        }\\n\\n        _afterTokenTransfer(address(0), to, id, 1);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        bytes32 key;\\n        address owner;\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x20, _ownerOf.slot)\\n            key := keccak256(0x00, 0x40)\\n            owner := sload(key)\\n            if iszero(owner) {\\n                // Store the function selector of `ERC721__NotMinted()`.\\n                // Revert with (offset, size).\\n                mstore(0x00, 0xf2c8ced6)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        _beforeTokenTransfer(owner, address(0), id, 1);\\n\\n        assembly {\\n            // delete _ownerOf[id]\\n            sstore(key, 0)\\n\\n            //  delete _getApproved[id];\\n            mstore(0x00, id)\\n            mstore(0x20, _getApproved.slot)\\n            sstore(keccak256(0x00, 0x40), 0)\\n\\n            //  emit Transfer(owner, address(0), id);\\n            log4(\\n                0x00,\\n                0x00,\\n                /// @dev value is equal to keccak256(\\\"Transfer(address,address,uint256)\\\")\\n                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,\\n                owner,\\n                0,\\n                id\\n            )\\n\\n            // Ownership check above ensures no underflow.\\n            //  --_balanceOf[owner]\\n            mstore(0x00, owner)\\n            mstore(0x20, _balanceOf.slot)\\n            key := keccak256(0x00, 0x40)\\n            sstore(key, sub(sload(key), 1))\\n        }\\n\\n        _afterTokenTransfer(owner, address(0), id, 1);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    _msgSender(),\\n                    address(0),\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        if (\\n            !(to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    _msgSender(),\\n                    address(0),\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector)\\n        ) revert ERC721__UnsafeRecipient();\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    error ERC721Enumerable__OutOfBounds();\\n    error ERC721Enumerable__GlobalIndexOutOfBounds();\\n    error ERC721Enumerable__ConsecutiveTransferNotSupported();\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(\\n        address owner,\\n        uint256 index\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    error ERC721__NotMinted();\\n    error ERC721__WrongFrom();\\n    error ERC721__Unauthorized();\\n    error ERC721__StringTooLong();\\n    error ERC721__AlreadyMinted();\\n    error ERC721__NonZeroAddress();\\n    error ERC721__UnsafeRecipient();\\n    error ERC721__InvalidRecipient();\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(\\n        uint256 tokenId\\n    ) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address sender) {\\n        assembly {\\n            sender := caller()\\n        }\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant __INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(\\n                account,\\n                type(IERC165).interfaceId\\n            ) &&\\n            !supportsERC165InterfaceUnchecked(account, __INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        address account,\\n        bytes4 interfaceId\\n    ) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return\\n            supportsERC165(account) &&\\n            supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] calldata interfaceIds\\n    ) internal view returns (bool[] memory interfaceIdsSupported) {\\n        uint256 length = interfaceIds.length;\\n\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        interfaceIdsSupported = new bool[](length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i; i < length; ) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(\\n                    account,\\n                    interfaceIds[i]\\n                );\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(\\n        address account,\\n        bytes4[] calldata interfaceIds\\n    ) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) return false;\\n\\n        uint256 length = interfaceIds.length;\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i; i < length; ) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i]))\\n                return false;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(\\n        address account,\\n        bytes4 interfaceId\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(\\n            abi.encodeCall(IERC165.supportsInterface, (interfaceId))\\n        );\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/oz/utils/structs/BitMaps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(\\n        BitMap storage bitmap,\\n        uint256 index\\n    ) internal view returns (bool isSet) {\\n        assembly {\\n            mstore(0, shr(8, index))\\n            mstore(32, bitmap.slot)\\n            // Assign isSet to whether the value is non zero.\\n            isSet := and(sload(keccak256(0, 64)), shl(and(index, 0xff), 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(\\n        BitMap storage bitmap,\\n        uint256 index,\\n        bool shouldSet\\n    ) internal {\\n        assembly {\\n            mstore(0, shr(8, index))\\n            mstore(32, bitmap.slot)\\n            let mapKey := keccak256(0, 64)\\n            let value := sload(mapKey)\\n\\n            // The following sets the bit at `shift` without branching.\\n            let shift := and(index, 0xff)\\n            // Isolate the bit at `shift`.\\n            let x := and(shr(shift, value), 1)\\n            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.\\n            x := xor(x, shouldSet)\\n            // Shifts the bit back. Then, xor with value.\\n            // Only the bit at `shift` will be flipped if they differ.\\n            // Every other bit will stay the same, as they are xor'ed with zeroes.\\n            value := xor(value, shl(shift, x))\\n\\n            sstore(mapKey, value)\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        assembly {\\n            mstore(0, shr(8, index))\\n            mstore(32, bitmap.slot)\\n            let key := keccak256(0, 64)\\n            let value := sload(key)\\n            value := or(value, shl(and(index, 0xff), 1))\\n            sstore(key, value)\\n        }\\n    }\\n\\n    function setBatch(\\n        BitMap storage bitmap_,\\n        uint256[] calldata values_\\n    ) internal {\\n        assembly {\\n            let length := values_.length\\n            let i := add(calldataload(values_.offset), 0x20)\\n            mstore(0x20, bitmap_.slot)\\n            for {\\n                let end := add(i, shl(5, length))\\n            } lt(i, end) {\\n                i := add(i, 0x20)\\n            } {\\n                mstore(0x00, shr(8, mload(i)))\\n                let key := keccak256(0x00, 0x40)\\n                sstore(key, or(sload(key), shl(and(mload(i), 0xff), 1)))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/presets/base/interfaces/IManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IAuthority} from \\\"../../interfaces/IAuthority.sol\\\";\\n\\ninterface IManager {\\n    error Manager__Paused();\\n    error Manager__NotPaused();\\n    error Manager__AlreadySet();\\n    error Manager__Blacklisted();\\n    error Manager__Unauthorized();\\n    error Manager__RequestFailed();\\n    error Manager__InvalidArgument();\\n    error Manager__ExecutionFailed();\\n\\n    event AuthorityUpdated(\\n        address indexed operator,\\n        IAuthority indexed from,\\n        IAuthority indexed to\\n    );\\n    event RequestRoleCached(address indexed operator, bytes32 indexed role);\\n\\n    /**\\n     * @notice Updates the authority of this contract. This can only be done by an operator.\\n     * @param authority_ The new authority contract.\\n     * @dev The authority contract must allow this contract to have the role specified in the constructor.\\n     * @custom:throws Manager__AlreadySet if the new authority is the same as the current authority.\\n     * @custom:throws Manager__RequestFailed if the request to the new authority contract fails.\\n     */\\n    function updateAuthority(IAuthority authority_) external;\\n\\n    /**\\n     * @notice Returns the authority contract of this contract.\\n     * @return authority_ is The address of the authority contract.\\n     */\\n    function authority() external view returns (IAuthority authority_);\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/presets/base/Manager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Context} from \\\"../../oz/utils/Context.sol\\\";\\n\\nimport {ProxyChecker} from \\\"../../internal/ProxyChecker.sol\\\";\\n\\nimport {IManager, IAuthority} from \\\"./interfaces/IManager.sol\\\";\\nimport {IPausable} from \\\"../../oz/security/Pausable.sol\\\";\\nimport {IAccessControl} from \\\"../../oz/access/IAccessControl.sol\\\";\\nimport {IBlacklistable} from \\\"../../internal/interfaces/IBlacklistable.sol\\\";\\n\\nimport {Roles} from \\\"../../libraries/Roles.sol\\\";\\nimport {ErrorHandler} from \\\"../../libraries/ErrorHandler.sol\\\";\\n\\nimport {ERC165Checker} from \\\"../../oz/utils/introspection/ERC165Checker.sol\\\";\\n\\nabstract contract Manager is Context, IManager, ProxyChecker {\\n    using ErrorHandler for bool;\\n    using ERC165Checker for address;\\n\\n    bytes32 private __authority;\\n    bytes32 private __requestedRole;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    modifier onlyWhitelisted() {\\n        _checkBlacklist(_msgSender());\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    constructor(IAuthority authority_, bytes32 role_) payable {\\n        __checkAuthority(address(authority_));\\n\\n        assembly {\\n            sstore(__requestedRole.slot, role_)\\n        }\\n        address sender = _msgSender();\\n        emit RequestRoleCached(sender, role_);\\n\\n        (bool ok, bytes memory revertData) = address(authority_).call(\\n            abi.encodeCall(IAuthority.requestAccess, (role_))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(revertData);\\n\\n        __updateAuthority(authority_);\\n        emit AuthorityUpdated(sender, IAuthority(address(0)), authority_);\\n    }\\n\\n    /// @inheritdoc IManager\\n    function updateAuthority(\\n        IAuthority authority_\\n    ) external onlyRole(Roles.OPERATOR_ROLE) {\\n        __checkAuthority(address(authority_));\\n\\n        IAuthority old = authority();\\n        if (old == authority_) revert Manager__AlreadySet();\\n        (bool ok, bytes memory revertData) = address(authority_).call(\\n            abi.encodeCall(IAuthority.requestAccess, (__requestedRole))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(revertData);\\n\\n        __updateAuthority(authority_);\\n\\n        emit AuthorityUpdated(_msgSender(), old, authority_);\\n    }\\n\\n    /// @inheritdoc IManager\\n    function authority() public view returns (IAuthority) {\\n        return IAuthority(_authority());\\n    }\\n\\n    /**\\n     * @notice Returns the address of the authority contract, for internal use.\\n     * @dev This function is for internal use only and should not be called by external contracts.\\n     * @return authority_ is the address of the authority contract.\\n     */\\n    function _authority() internal view returns (address authority_) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            authority_ := sload(__authority.slot)\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the given account is blacklisted by the authority contract.\\n     * @param account_ The address to check for blacklisting.\\n     * @dev This function should be called before allowing the given account to perform certain actions.\\n     * @custom:throws Manager__Blacklisted if the given account is blacklisted.\\n     */\\n    function _checkBlacklist(address account_) internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IBlacklistable.isBlacklisted, (account_))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (abi.decode(returnOrRevertData, (bool)))\\n            revert Manager__Blacklisted();\\n    }\\n\\n    function _checkBlacklistMulti(address[] memory accounts_) internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IBlacklistable.areBlacklisted, (accounts_))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (abi.decode(returnOrRevertData, (bool)))\\n            revert Manager__Blacklisted();\\n    }\\n\\n    /**\\n     * @notice Checks if the given account has the given role.\\n     * @param role_ The role to check for.\\n     * @param account_ The address to check for the role.\\n     * @dev This function should be called before allowing the given account to perform certain actions.\\n     * @custom:throws Manager__Unauthorized if the given account does not have the given role.\\n     */\\n    function _checkRole(bytes32 role_, address account_) internal view {\\n        if (!_hasRole(role_, account_)) revert Manager__Unauthorized();\\n    }\\n\\n    function __updateAuthority(IAuthority authority_) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            sstore(__authority.slot, authority_)\\n        }\\n    }\\n\\n    function _requirePaused() internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IPausable.paused, ())\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (!abi.decode(returnOrRevertData, (bool)))\\n            revert Manager__NotPaused();\\n    }\\n\\n    function _requireNotPaused() internal view {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IPausable.paused, ())\\n        );\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        if (abi.decode(returnOrRevertData, (bool))) revert Manager__Paused();\\n    }\\n\\n    function _hasRole(\\n        bytes32 role_,\\n        address account_\\n    ) internal view returns (bool) {\\n        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(\\n            abi.encodeCall(IAccessControl.hasRole, (role_, account_))\\n        );\\n\\n        ok.handleRevertIfNotSuccess(returnOrRevertData);\\n\\n        return abi.decode(returnOrRevertData, (bool));\\n    }\\n\\n    function __checkAuthority(address authority_) private view {\\n        if (\\n            authority_ == address(0) ||\\n            !_isProxy(authority_) ||\\n            !authority_.supportsInterface(type(IAuthority).interfaceId)\\n        ) revert Manager__InvalidArgument();\\n    }\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/presets/interfaces/IAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IAuthority {\\n    error Authority__InvalidRole();\\n    error Authority__LengthMismatch();\\n\\n    event VaultMultiUpdated(\\n        address indexed operator,\\n        address indexed vault,\\n        bool[] success\\n    );\\n\\n    event ProxyAccessGranted(address indexed operator, address indexed proxy);\\n\\n    /**\\n     * @dev Sets the admin of the specified role to the specified admin role.\\n     * @param role bytes32 representing the role to set the admin of\\n     * @param adminRole bytes32 representing the role to set as the admin of the role\\n     */\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\\n\\n    /**\\n     * @dev Allows a user to request access to the contract as a proxy.\\n     * Only callable by accounts with the OPERATOR_ROLE and only if the sender is a proxy of the caller.\\n     * Grants the PROXY_ROLE and the specified role to the sender.\\n     * @param role bytes32 representing the role to grant to the sender in addition to the PROXY_ROLE\\n     */\\n    function requestAccess(bytes32 role) external;\\n}\\n\"\r\n    },\r\n    \"oz-custom/contracts/presets/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface ITreasury {\\n    error Treasury__Expired();\\n    error Treasury__LengthMismatch();\\n    error Treasury__InvalidBalance();\\n    error Treasury__InvalidArgument();\\n    error Treasury__InvalidSignature();\\n    error Treasury__MistakenTransfer();\\n    error Treasury__InvalidTokenAddress();\\n    error Treasury__InvalidFunctionCall();\\n    error Treasury__UnauthorizedWithdrawal();\\n\\n    event BalanceInitiated(address indexed operator, uint256 indexed balance);\\n\\n    function withdraw(\\n        address token_,\\n        address to_,\\n        uint256 value_,\\n        uint256 amount_, // if withdraw ERC1155\\n        uint256 deadline_,\\n        bytes calldata signature_\\n    ) external;\\n\\n    function nonces(address account_) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FundForwarder__InvalidArgument\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__AlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__Blacklisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__InvalidArgument\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__RequestFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Manager__Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NofifyGate__ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProxyChecker__ProxyUnallowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Transferable__InvalidArguments\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Transferable__TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IAuthority\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IAuthority\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Forwarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Notified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"RequestRoleCached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"VaultUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"changeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"}],\"name\":\"notifyWithERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"}],\"name\":\"notifyWithNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message_\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct IFundForwarder.RecoveryCallData[]\",\"name\":\"calldata_\",\"type\":\"tuple[]\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeRecoverHeader\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeTransferHeader\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"updateAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NotifyGate", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "00000000000000000000000038e586659c83c7ea2cbc7b796b08b8179eddebc5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}