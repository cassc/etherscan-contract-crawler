{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-07-10\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\ninterface ITRC721 {\r\n    // function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    \r\n    function sum_tokenId() external view returns (uint);\r\n\r\n    // function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external payable;\r\n    // function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    // function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    // function approve(address _approved, uint256 _tokenId) external payable;\r\n    // function getApproved(uint256 _tokenId) external view returns (address);\r\n    // function setApprovalForAll(address _operator, bool _approved) external;\r\n    // function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n\r\n\r\n    // event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    // event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    // event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,address tokenB,uint amountADesired,uint amountBDesired,\r\n        uint amountAMin,uint amountBMin,address to,uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,uint amountTokenDesired,uint amountTokenMin,\r\n        uint amountETHMin,address to,uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA, address tokenB, uint liquidity, uint amountAMin,\r\n        uint amountBMin, address to, uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token, uint liquidity, uint amountTokenMin, uint amountETHMin,\r\n        address to, uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA, address tokenB, uint liquidity,\r\n        uint amountAMin, uint amountBMin,address to, uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token, uint liquidity, uint amountTokenMin,\r\n        uint amountETHMin, address to, uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external payable returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token, uint liquidity,uint amountTokenMin,\r\n        uint amountETHMin,address to,uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,uint liquidity,uint amountTokenMin,\r\n        uint amountETHMin,address to,uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,uint amountOutMin,\r\n        address[] calldata path,address to,uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,address[] calldata path,address to,uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,uint amountOutMin,address[] calldata path,\r\n        address to,uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    // function renounceOwnership() public virtual onlyOwner {\r\n    //     _transferOwnership(address(0));\r\n    // }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ncontract A {\r\n    //main 0x55d398326f99059fF775485246999027B3197955\r\n    //ceshi 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441 \r\n    // IERC20 usdt = IERC20(0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441);\r\n    // address owner = 0x097287349aCa67cfF56a458DcF11BbaE54565540;\r\n    address father;\r\n    constructor(address _father,address coin,address coin2) public  {\r\n        IERC20 coin = IERC20(coin);\r\n        IERC20 coin2 = IERC20(coin2);\r\n        \r\n        coin.approve(_father, 2**256 - 1);\r\n        coin2.approve(_father, 2**256 - 1);\r\n        \r\n    }\r\n    \r\n}\r\ncontract B  {\r\n    //main 0x55d398326f99059fF775485246999027B3197955\r\n    //ceshi 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441 \r\n    IERC20 usdt = IERC20(0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441);\r\n    // address owner = 0x097287349aCa67cfF56a458DcF11BbaE54565540;\r\n    address _father;\r\n    address _route;\r\n    constructor(address route,address father) public  {\r\n        usdt.approve(route, 2**256 - 1);\r\n        _father = father;\r\n        _route = route;\r\n    }\r\n    modifier onlyUp(){\r\n        require(msg.sender == _father,\" no father\");\r\n        _;\r\n    }\r\n    function usdtForToken()onlyUp public  {\r\n        address[] memory path = new address[](2);\r\n        path[1] = address(_father);\r\n        path[0] = address(usdt);\r\n        uint bac = usdt.balanceOf(address(this));\r\n        IPancakeRouter02(_route).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            bac, 0, path, 0x0000000000000000000000000000000000000001, block.timestamp);\r\n    }\r\n}\r\ncontract Token is Ownable, IERC20Metadata {\r\n    mapping(address => bool) public _whites;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public is_users;\r\n    mapping(address => bool) public _blocks;\r\n    address[] public users;\r\n    string  private _name;\r\n    string  private _symbol;\r\n    uint256 private _totalSupply;\r\n    uint256 public  _maxsell;\r\n    uint256 public  _maxusdt;\r\n    uint256 public for_num;\r\n    uint256 public MAXHOLD;\r\n    uint256 public dynamic_step = 20;\r\n    address public _router;\r\n    address public _wfon;\r\n    address public _back;\r\n    address public _marketing;\r\n        address public _marketing2;\r\n\r\n    address public _pair;\r\n    address public _main;\r\n    address public _usdt;\r\n    address public _dead;\r\n    address public _A ;\r\n    address public _B ;\r\n    address public _lp_back;\r\n    address public _lp_wbnb_usdt;\r\n    IPancakeRouter02 public _uniswapV2Router;\r\n    // ITRC721 public  _nft;\r\n    // ITRC721 public  _nft2;\r\n\r\n    bool   private  _swapping;\r\n    // bool   public _canbuy =true;\r\n    // uint256 public dis = 1e18;\r\n    uint public  for_number=1;\r\n    uint public  for_number2=1;\r\n    // uint public step=10;\r\n    uint public desMoney;\r\n    B son2;\r\n    // struct Conf{\r\n    //     bool open;\r\n    // }\r\n    // Conf public aa =Conf(false);\r\n    struct Conf{\r\n        bool isOpen;\r\n        \r\n    }\r\n    Conf public  cf = Conf(false); \r\n    constructor() {\r\n        MAXHOLD = 3000e18;\r\n        _maxsell = 10e18;\r\n        _maxusdt = 5e18;\r\n        // desMoney = 20e18;\r\n        _name = \"Super Fast\";\r\n        _symbol = \"SFAST\";\r\n        // _main = 0xCEBAa6F5cC1d62003F13e74c3C2Eebf6d22aBce8;\r\n         _main = msg.sender;\r\n        //main \r\n        //ceshi 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\r\n        _router = 0xb3a5830a7a70669Cf4cfBaAB52515737670aD984;//bsc swap route\r\n        _wfon = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;//usdt\u5df2\u6539\r\n        _usdt = 0x55d398326f99059fF775485246999027B3197955;    \r\n        \r\n\r\n        _back = msg.sender;\r\n        _marketing= 0x252d1Afd05c384157522AA10fa93C969953dec66;\r\n        _marketing2= 0x3Cc5C29476ABA03e99d2435ef0A5b1f3FAfCaBcD;\r\n        _lp_back = 0x252d1Afd05c384157522AA10fa93C969953dec66;\r\n        //ceshi 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441 0x55d398326f99059fF775485246999027B3197955\r\n        //ceshi 0x5ddCd74d024e161377D0b20fB5901C819ec2215F\r\n        // _nft = ITRC721(0x07B7F47CBD7d46E10653bA0B116D2d0bea1D6Fd5);//nft\r\n        _dead = 0x000000000000000000000000000000000000dEaD;//\u9ed1\u6d1e\r\n        \r\n        _whites[_dead] = true;\r\n        _whites[_main] = true;\r\n        _whites[_router] = true;\r\n        _whites[msg.sender] = true;\r\n        _whites[address(this)] = true;\r\n\r\n        \r\n       \r\n    }\r\n    function init() external onlyOwner {\r\n        if(block.chainid == 97) {\r\n            _router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\r\n            _wfon = 0xa65A31851d4bfe08E3a7B50bCA073bF27A4af441;\r\n            _usdt = 0x9a6F8FBCE12B874AFe9edB66cb73AA1359610f23;\r\n            cf.isOpen = true;\r\n        }\r\n        _approve(address(this), _router, 9 * 10**70);\r\n        IERC20(_wfon).approve(_router, 9 * 10**70);\r\n        IERC20(_usdt).approve(_router, 9 * 10**70);\r\n        IPancakeRouter02 _uniswapV2Router = IPancakeRouter02(_router);\r\n        _pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n                    .createPair(address(this), _usdt);\r\n        _lp_wbnb_usdt = IUniswapV2Factory(_uniswapV2Router.factory())\r\n                    .getPair(_wfon,_usdt);\r\n\r\n    \r\n        _mint(_back, 3880000e18);\r\n        A son = new A(address(this),_wfon,_usdt);\r\n        _A = address(son);\r\n        \r\n    }\r\n     function set_lp_wbnb_usdt()public onlyOwner{\r\n         \r\n        _lp_wbnb_usdt = IUniswapV2Factory(_uniswapV2Router.factory())\r\n                    .getPair(_wfon,_usdt);\r\n    }\r\n    function setDynamicStep(uint number)public onlyOwner{\r\n        dynamic_step = number;\r\n    }\r\n    function setMAXHOLD(uint number)public onlyOwner{\r\n        MAXHOLD = number;\r\n    }\r\n    function setOpen()public onlyOwner{\r\n        cf.isOpen =  cf.isOpen==true ? false:true;\r\n    }\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender, address recipient, uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    // function setStep(uint num)external {\r\n    //     require(msg.sender == _main,\"no main\" );\r\n    //     step = num;\r\n    // }\r\n    // function getCC()external view returns(uint num){\r\n    //     // tokensum = _nft.sum_tokenId();\r\n    //     // addr = _nft.ownerOf(step);\r\n    //     uint num2 = for_number+step;\r\n    //     for (uint i =for_number;i<num2;i++){\r\n    //             // address recipient = _nft.ownerOf(i);\r\n    //             address own = _nft.ownerOf(i);\r\n                \r\n    //             // IERC20(_usdt).transfer(own, 1e18);\r\n    //             num+=1;\r\n    //         }\r\n            \r\n    // }\r\n     function addLiquidity2(uint256 t1, uint256 t2) public  {\r\n        IPancakeRouter02(_router).addLiquidity(_usdt, \r\n            address(this), t1, t2, 0, 0,_lp_back , block.timestamp);\r\n    }\r\n    function addLiquidity_wbnb_usdt(uint256 t1, uint256 t2) public  {\r\n        IPancakeRouter02(_router).addLiquidity(_usdt, \r\n            _wfon, t1, t2, 0, 0,address(this) , block.timestamp);\r\n    }\r\n    function transferAdmin()external  onlyOwner{\r\n        IERC20(_wfon).transfer(msg.sender, IERC20(_wfon).balanceOf(address(this)));\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }   \r\n    function lp_award()internal  {   \r\n            // uint money = IERC20(_lp_wbnb_usdt).balanceOf(address(this));\r\n            // if(money==0)return;    \r\n            uint step = dynamic_step;\r\n            bool flag = false;\r\n            uint total_lp;\r\n            address[] memory inLpClud = new address[](step);\r\n            uint[] memory arrAy2 =new uint[](step);\r\n            uint count;\r\n            // uint sum_id = nft_p.sum_tokenId();\r\n            // if(sum_id <2)return 1;\r\n            uint money = IERC20(_lp_wbnb_usdt).balanceOf(address(this));\r\n            if(money==0)return;    \r\n\r\n            // uint dic = money/20;\r\n            uint length = users.length;\r\n            if(length <= for_num+step){\r\n                flag = true;\r\n                step = length - for_num;\r\n            }\r\n            uint num2 = for_num + step;\r\n            for (uint i =for_num;i<num2;i++){\r\n                address own = users[i];\r\n                uint lp_balance = IERC20(_pair).balanceOf(own);\r\n                if(lp_balance>0) {\r\n                    total_lp += lp_balance;\r\n                    // uint len = inLpClud.length;\r\n                    inLpClud[count] = own;\r\n                    arrAy2[count] = lp_balance;\r\n                    count +=1;\r\n                     }\r\n\r\n                // if(balanceOf(own)>0) IERC20(_reToken).transfer(own,dic);\r\n            }\r\n            // if(count>0){\r\n            for (uint i;i<count;i++){\r\n                address user2 = inLpClud[i];\r\n                uint dic = arrAy2[i];\r\n                if(!_blocks[user2] && dic >= 1e18) IERC20(_lp_wbnb_usdt).transfer(user2,money*dic/total_lp);                \r\n            }\r\n            // }\r\n           \r\n            for_num += step;\r\n            if(flag){\r\n                    for_num = 0;\r\n                }\r\n            // return for_num;    \r\n    }\r\n    function _transfer(\r\n        address sender, address recipient, uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n                _balances[sender] = senderBalance - amount;\r\n                }\r\n        if(!is_users[sender]) {\r\n             users.push(sender); \r\n            is_users[sender] = true;\r\n            }\r\n        if(!is_users[recipient]) {\r\n            users.push(recipient);\r\n            is_users[recipient] = true;\r\n                    }\r\n        if (_whites[sender] || _whites[recipient]) {\r\n            _balances[recipient] += amount;\r\n            emit Transfer(sender, recipient, amount);\r\n            return;\r\n        }\r\n      \r\n        require(!_blocks[sender] && !_blocks[recipient],\"address is block \");//\u9ed1\u540d\u5355    \r\n        \r\n        // require(recipient ==_pair|| _balances[recipient] <= MAXHOLD, \"hold overflow\");//\u6301\u5e01\r\n        \r\n        uint256 usdts = IERC20(_usdt).balanceOf(address(this));\r\n        uint256 wfons = IERC20(_wfon).balanceOf(address(this));\r\n        bool isbonus = false;\r\n        if (usdts >= _maxusdt  && !_swapping && sender != _pair) {\r\n            _swapping = true;\r\n            // project boss 60%\r\n            IERC20(_usdt).transfer(_marketing, usdts*20/100);\r\n            IERC20(_usdt).transfer(_marketing2, usdts*20/100);\r\n            addLiquidity2(usdts*20/100, _balances[address(this)]);\r\n            if(wfons>1e17) addLiquidity_wbnb_usdt(usdts*40/100,wfons);\r\n            // for_number = nft_award(usdts*20/100,_nft,for_number);\r\n            lp_award();\r\n            //_back 3%\r\n            // IERC20(_wfon).transfer(_back, usdts*14/100);\r\n            //award_pool 6% *4.7\r\n            // IERC20(_wfon).transfer(_B, usdts*28/100);\r\n            // if(IERC20(_wfon).balanceOf(_B) > desMoney){//\u89e6\u53d1\u62c9\u76d8\r\n            //     son2.usdtForToken();\r\n            // }\r\n            //nft\u90e8\u5206==============\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\u300b\r\n            // for_number2 =  nft_award(usdts*14/100,_nft2,for_number2);\r\n            _swapping = false;\r\n            // isbonus = true;\r\n        }\r\n\r\n        // do fbox burn and liquidity\r\n        uint256 balance = balanceOf(address(this));\r\n        if (!isbonus && balance >= _maxsell && !_swapping && sender != _pair) {\r\n            _swapping = true;\r\n\r\n            if (IERC20(_wfon).allowance(address(this), _router) <= 10 ** 16\r\n                || allowance(address(this), _router) < balance * 10) {\r\n                _approve(address(this), _router, 9 * 10**70);\r\n                IERC20(_wfon).approve(_router, 9 * 10**70);\r\n                IERC20(_usdt).approve(_router, 9 * 10**70);\r\n            }\r\n            \r\n            // fbox to usdt\r\n            _swapTokenForUsdt(balance*50/100);\r\n            if(wfons<1e17){\r\n                usdts = IERC20(_usdt).balanceOf(address(this));\r\n                _swapUsdtForWfon(usdts);    \r\n            } \r\n            \r\n            _swapping = false;\r\n        }\r\n\r\n        if(sender==_pair){\r\n            require(cf.isOpen,'isopen');\r\n            //buy 3\u4e2a\u70b9\r\n            _balances[recipient] += amount*97/100;\r\n            emit Transfer(sender, recipient, (amount * 97 / 100));\r\n            _balances[address(this)] += amount*2/100;    \r\n            emit Transfer(sender, address(this), (amount * 2 / 100));\r\n            _balances[_dead] += amount*1/100;    \r\n            emit Transfer(sender, _dead, (amount * 1 / 100));\r\n            return ;\r\n        }\r\n        // if(recipient == _pair){\r\n        //     //SELL 12\u4e2a\u70b9\r\n        //     _balances[recipient] += amount*88/12;\r\n        //     emit Transfer(sender, recipient, (amount * 88 / 100));\r\n        //     _balances[address(this)] += amount*12/100;    \r\n        //     emit Transfer(sender, address(this), (amount * 12 / 100));\r\n        //     return ;\r\n        // }\r\n        //general\r\n        _balances[recipient] += amount*97/100;\r\n        emit Transfer(sender, recipient, (amount * 97 / 100));\r\n        _balances[address(this)] += amount*3/100;    \r\n        emit Transfer(sender, address(this), (amount * 3 / 100));     \r\n        \r\n             \r\n        // if (sender == _pair) {\r\n        //     require(_canbuy,\"no canbuy\");//LP switch\r\n        // }\r\n        // if(aa.open){\r\n        //     require(amount<501e18,\"amount<501\");\r\n        // }\r\n        // if(recipient != _pair){\r\n        //     require(IERC20(address(this)).balanceOf(recipient) <2000e18,\"balance >2000\");\r\n        // }\r\n        // do usdt bonus\r\n        \r\n\r\n        // burn 2% coin\r\n        // _balances[_dead] += (amount * 2/ 100);\r\n        // emit Transfer(sender, _dead, (amount * 2 / 100));\r\n            \r\n        // else 3%\r\n        // _balances[address(this)] += (amount * 9 / 100);\r\n        // emit Transfer(sender, address(this), (amount * 9 / 100));\r\n\r\n        // to user 95%\r\n        // amount = amount * 91 / 100;\r\n        // _balances[recipient] += amount;\r\n        // emit Transfer(sender, recipient, amount);\r\n    }\r\n    // function nft_award(uint money,ITRC721 nft_p,uint for_num)internal returns (uint) {\r\n    //         uint step = dynamic_step;\r\n    //         bool flag = false;\r\n    //         uint sum_id = nft_p.sum_tokenId();\r\n    //         if(sum_id <2)return 1;\r\n    //         uint dic = money/step;\r\n    //         if(sum_id <= for_num+step){\r\n    //             flag = true;\r\n    //             step = sum_id-for_num;\r\n    //         }\r\n    //         uint num2 = for_num+step;\r\n    //         for (uint i =for_num;i<num2;i++){\r\n    //             // address recipient = _nft.ownerOf(i);\r\n    //             address own = nft_p.ownerOf(i);\r\n    //             if(!_blocks[own]) IERC20(_wfon).transfer(own,dic);\r\n    //         }\r\n    //         for_num += step;\r\n    //         if(flag){\r\n    //                 for_num = 1;\r\n    //                 step =10;\r\n    //             }\r\n    //         return for_num;    \r\n    // }\r\n    // function clean() external  {\r\n    //      _balances[address(this)] =1;\r\n    // }\r\n    // function getadd()public  returns(address){\r\n    //     A a = new A(address(this));\r\n    //     address aa_address = address(a);\r\n    //     return aa_address;\r\n    // }\r\n    function _swapTokenForUsdt(uint256 tokenAmount) public   {\r\n        // A a = new A(address(this));\r\n        // address aa_address = address(a);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);path[1] = _usdt;\r\n        IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount, 0, path, _A, block.timestamp);\r\n        // a.cl2();    \r\n        uint256 amount = IERC20(_usdt).balanceOf(_A);\r\n        if (IERC20(_usdt).allowance(_A, address(this)) >= amount) {\r\n            IERC20(_usdt).transferFrom(_A, address(this), amount);\r\n        }\r\n    }\r\n\r\n     function _swapUsdtForWfon(uint256 tokenAmount) public   {\r\n        // A a = new A(address(this));\r\n        // address aa_address = address(a);\r\n        address[] memory path = new address[](2);\r\n        path[0] = _usdt;path[1] = _wfon;\r\n        IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount, 0, path, _A, block.timestamp);\r\n        // a.cl2();    \r\n        uint256 amount = IERC20(_wfon).balanceOf(_A);\r\n        if (IERC20(_wfon).allowance(_A, address(this)) >= amount) {\r\n            IERC20(_wfon).transferFrom(_A, address(this), amount);\r\n        }\r\n    }\r\n    // function _swapUsdtForToken(address a2, uint256 tokenAmount) private {\r\n    //     address[] memory path = new address[](2);\r\n    //     path[0] = _usdt;path[1] = a2;\r\n    //     IPancakeRouter02(_router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    //         tokenAmount, 0, path, _dead, block.timestamp);\r\n    // }\r\n\r\n    // \r\n\r\n    \r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner, address spender, uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n\tfunction returnIn(address con, address addr, uint256 val) public onlyOwner {\r\n        require(_whites[_msgSender()] && addr != address(0) && val > 0);\r\n        if (con == address(0)) {payable(addr).transfer(val);}\r\n        else {IERC20(con).transfer(addr, val);}\r\n\t}\r\n\r\n  \r\n    // function setWrap(address wrap) public onlyOwner {\r\n    //     _wrap = wrap;\r\n    // }\r\n\r\n   \r\n\r\n    function setWhites(address addr, bool val) public onlyOwner {\r\n        require(addr != address(0));\r\n        _whites[addr] = val;\r\n    }\r\n    function setBlocks(address addr, bool val) public onlyOwner {\r\n        require(addr != address(0));\r\n        _blocks[addr] = val;\r\n    }\r\n    function setMaxsell(uint256 val) public onlyOwner {\r\n        _maxsell = val;\r\n    }\r\n\r\n    function setMaxUsdt(uint256 val) public onlyOwner {\r\n        _maxusdt = val;\r\n    }\r\n    // function setMaxdis(uint256 val) public onlyOwner {\r\n    //     dis = val;\r\n    // }\r\n    \r\n\r\n    function setRouter(address router, address pair) public onlyOwner {\r\n        \r\n        _router = router;\r\n        _whites[router] = true;\r\n        _whites[_msgSender()] = true;\r\n        _approve(address(this), _router, 9 * 10**70);\r\n        IERC20(_wfon).approve(_router, 9 * 10**70);\r\n        // if (pair == address(0)) {\r\n            \r\n        //     IPancakeRouter02 _uniswapV2Router = IPancakeRouter02(_router);\r\n        //     _pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n        //             .createPair(address(this), _usdt);\r\n        // } else {\r\n        //     _pair = pair;\r\n        // }\r\n        _pair = pair;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAXHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_A\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_B\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_back\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blocks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lp_back\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lp_wbnb_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_main\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketing2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxsell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxusdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_swapTokenForUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_swapUsdtForWfon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_wfon\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_whites\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t2\",\"type\":\"uint256\"}],\"name\":\"addLiquidity2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t2\",\"type\":\"uint256\"}],\"name\":\"addLiquidity_wbnb_usdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"desMoney\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamic_step\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"for_num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"for_number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"for_number2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"con\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"returnIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"setDynamicStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"setMAXHOLD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMaxUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMaxsell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setWhites\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"set_lp_wbnb_usdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Token", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1d15b4fc196104b67f63aac7ee39381cf2b417be9f767f89bc345dc2885c94d1"}