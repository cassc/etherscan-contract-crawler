{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.18;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.18;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: swap.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @title TokenSwap: A contract for swapping tokens using two Uniswap routers\r\n/// @notice This contract allows users to deposit tokens, swap them using two Uniswap routers, and withdraw tokens.\r\ncontract TokenSwap is Ownable {\r\n    constructor(address initialOwner) Ownable(initialOwner) {}\r\n\r\n    // Mapping to store user deposits\r\n    mapping(address => mapping(address => uint256)) public deposits; // Mapping user -> token -> amount\r\n\r\n    // Mapping to track deposited tokens for each user\r\n    mapping(address => address[]) public userDepositedTokens; // Mapping user -> tokens\r\n\r\n    mapping(address => uint256) public accumulatedFees; // Mapping token -> accumulated fee\r\n\r\n    // Vriable to store the fee percentage\r\n    uint256 public feePercentageNumerator = 25; // Numerator for the fee percentage\r\n    uint256 public feePercentageDenominator = 1000; // Denominator for the fee percentage\r\n\r\n    /// @dev Event emitted when the fee percentage is changed\r\n    event FeePercentageChanged(\r\n        uint256 newFeePercentageNumerator,\r\n        uint256 newFeePercentageDenominator\r\n    );\r\n\r\n    /// @dev Event emitted when tokens are swapped\r\n    event TokensSwapped(\r\n        address indexed user,\r\n        address router1Address,\r\n        address router2Address,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 swapAmount,\r\n        uint256 amountOutFinal,\r\n        address[] pathsIn,\r\n        address[] pathsOut\r\n    );\r\n\r\n    // Event emitted when tokens are deposited\r\n    event TokensDeposited(address indexed user, address token, uint256 amount);\r\n\r\n    // Event emitted when tokens are withdrawn\r\n    event TokensWithdrawn(address indexed user, address token, uint256 amount);\r\n\r\n    /// @dev Modifier to prevent reentrancy\r\n    bool private locked;\r\n\r\n    /// @dev Prevents reentrancy by ensuring that the function is not called recursively\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    /// @dev Mapping to store the expected code hash of trusted routers\r\n    mapping(address => bytes32) public expectedCodeHash;\r\n\r\n    /// @dev Modifier to ensure that the provided router is trusted\r\n    modifier onlyTrustedRouter(address routerAddress) {\r\n        require(isTrustedRouter(routerAddress), \"Untrusted router\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if a router is trusted based on its code hash\r\n    /// @param routerAddress The address of the router contract\r\n    /// @return true if the router is trusted, false otherwise\r\n    function isTrustedRouter(address routerAddress) public view returns (bool) {\r\n        return\r\n            expectedCodeHash[routerAddress] != bytes32(0) &&\r\n            getCodeHash(routerAddress) == expectedCodeHash[routerAddress];\r\n    }\r\n\r\n    /// @notice Sets or removes routers as trusted by updating their expected code hashes\r\n    /// @param routerAddresses An array of addresses of the router contracts to be updated\r\n    /// @param add Boolean flag indicating whether to add (true) or remove (false) the routers\r\n    function setTrustedRouters(\r\n        address[] calldata routerAddresses,\r\n        bool add\r\n    ) external onlyOwner {\r\n        for (uint256 i = 0; i < routerAddresses.length; i++) {\r\n            if (add) {\r\n                // Add router by setting its expected code hash\r\n                expectedCodeHash[routerAddresses[i]] = getCodeHash(\r\n                    routerAddresses[i]\r\n                );\r\n            } else {\r\n                // Remove router by setting its expected code hash to zero\r\n                expectedCodeHash[routerAddresses[i]] = bytes32(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCodeHash(address target) internal view returns (bytes32) {\r\n        bytes32 codeHash;\r\n        assembly {\r\n            codeHash := extcodehash(target)\r\n        }\r\n        return codeHash;\r\n    }\r\n\r\n    /// @param router1Address The address of the first Uniswap router\r\n    /// @param router2Address The address of the second Uniswap router\r\n    /// @param tokenIn The address of the input token\r\n    /// @param tokenOut The address of the output token\r\n    /// @param swapAmount The amount of input tokens to be swapped\r\n    /// @param amountOutMin The minimum amount of output tokens expected from the first swap\r\n    /// @param amountOutFinal The minimum amount of output tokens expected from the second swap\r\n    /// @param pathsIn An array of addresses representing the swap path for the first swap\r\n    /// @param pathsOut An array of addresses representing the swap path for the second swap\r\n    struct SwapInfo {\r\n        address router1Address;\r\n        address router2Address;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 swapAmount;\r\n        uint256 amountOutMin;\r\n        uint256 amountOutFinal;\r\n        address[] pathsIn;\r\n        address[] pathsOut;\r\n    }\r\n\r\n    /// @notice Swap tokens using two Uniswap routers\r\n    /// @param swapInfo Struct containing swap-related information\r\n    function swapTokens(\r\n        SwapInfo memory swapInfo\r\n    )\r\n        external\r\n        noReentrancy\r\n        onlyTrustedRouter(swapInfo.router1Address)\r\n        onlyTrustedRouter(swapInfo.router2Address)\r\n    {\r\n        // Checks if user has enough tokens to swap\r\n        require(\r\n            deposits[msg.sender][swapInfo.tokenIn] >= swapInfo.swapAmount,\r\n            \"Swap amount exceeds deposited amount\"\r\n        );\r\n\r\n        require(\r\n            swapInfo.tokenIn != swapInfo.tokenOut,\r\n            \"TokenIn and TokenOut must be different\"\r\n        );\r\n        require(swapInfo.swapAmount > 0, \"Invalid swap amount\");\r\n        require(\r\n            swapInfo.pathsIn.length > 0 && swapInfo.pathsOut.length > 0,\r\n            \"Swap paths must not be empty\"\r\n        );\r\n        require(\r\n            swapInfo.pathsIn[0] == swapInfo.tokenIn &&\r\n                swapInfo.pathsIn[swapInfo.pathsIn.length - 1] ==\r\n                swapInfo.tokenOut,\r\n            \"Invalid pathsIn\"\r\n        );\r\n        require(\r\n            swapInfo.pathsOut[0] == swapInfo.tokenOut &&\r\n                swapInfo.pathsOut[swapInfo.pathsOut.length - 1] ==\r\n                swapInfo.tokenIn,\r\n            \"Invalid pathsOut\"\r\n        );\r\n        require(swapInfo.amountOutMin > 0, \"Invalid amountOutMin\");\r\n        require(swapInfo.amountOutFinal > 0, \"Invalid amountOutFinal\");\r\n\r\n        // Check if the contract is approved to spend the user's tokens\r\n        uint256 allowance = IERC20(swapInfo.tokenIn).allowance(\r\n            msg.sender,\r\n            address(this)\r\n        );\r\n        require(\r\n            allowance >= swapInfo.swapAmount,\r\n            \"Not enough allowance, please approve the contract to spend your tokens\"\r\n        );\r\n\r\n        // Effects: Update the user's deposit\r\n        deposits[msg.sender][swapInfo.tokenIn] -= swapInfo.swapAmount;\r\n\r\n        // Check if router1 has allowance, if not, approve it\r\n        if (allowance < swapInfo.swapAmount) {\r\n            IERC20(swapInfo.tokenIn).approve(\r\n                swapInfo.router1Address,\r\n                type(uint256).max\r\n            );\r\n        }\r\n\r\n        // Interactions: Perform the first token swap\r\n        uint256[] memory amounts = IUniswapV2Router(swapInfo.router1Address)\r\n            .swapExactTokensForTokens(\r\n                swapInfo.swapAmount,\r\n                swapInfo.amountOutMin,\r\n                swapInfo.pathsIn,\r\n                address(this),\r\n                block.timestamp + 300\r\n            );\r\n\r\n        uint256 amountOut = amounts[amounts.length - 1];\r\n\r\n        // Check if router2 has allowance, if not, approve it\r\n        allowance = IERC20(swapInfo.tokenOut).allowance(\r\n            address(this),\r\n            swapInfo.router2Address\r\n        );\r\n        if (allowance < amountOut) {\r\n            IERC20(swapInfo.tokenOut).approve(\r\n                swapInfo.router2Address,\r\n                type(uint256).max\r\n            );\r\n        }\r\n\r\n        // Interactions: Perform the second token swap\r\n        uint256[] memory amounts2 = IUniswapV2Router(swapInfo.router2Address)\r\n            .swapExactTokensForTokens(\r\n                amountOut,\r\n                swapInfo.amountOutFinal,\r\n                swapInfo.pathsOut,\r\n                address(this),\r\n                block.timestamp + 300\r\n            );\r\n\r\n        // Emit an event indicating the tokens were swapped\r\n        emit TokensSwapped(\r\n            msg.sender,\r\n            swapInfo.router1Address,\r\n            swapInfo.router2Address,\r\n            swapInfo.tokenIn,\r\n            swapInfo.tokenOut,\r\n            swapInfo.swapAmount,\r\n            swapInfo.amountOutFinal,\r\n            swapInfo.pathsIn,\r\n            swapInfo.pathsOut\r\n        );\r\n\r\n        // Update the user's deposit after the second swap\r\n        deposits[msg.sender][swapInfo.tokenIn] += amounts2[amounts2.length - 1];\r\n    }\r\n\r\n    /// @notice Deposit tokens into the contract\r\n    /// @param tokenAddress The address of the token to be deposited\r\n    /// @param amount The amount of tokens to be deposited\r\n    function deposit(address tokenAddress, uint256 amount) external {\r\n        // Ensure that the contract is approved to spend the specified amount of tokens\r\n        require(\r\n            IERC20(tokenAddress).allowance(msg.sender, address(this)) >= amount,\r\n            \"Token allowance too low\"\r\n        );\r\n        // Calculate the fee\r\n        uint256 fee = (amount * feePercentageNumerator) /\r\n            feePercentageDenominator; // Use the dynamically changeable fee\r\n\r\n        // Update the accumulated fee for the token\r\n        accumulatedFees[tokenAddress] += fee;\r\n\r\n        // Calculate the actual amount to be deposited after deducting the fee\r\n        uint256 depositAmount = amount - fee;\r\n\r\n        // Transfer the amount to the contract\r\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\r\n\r\n        // Update the user's deposit with the amount minus fee\r\n        deposits[msg.sender][tokenAddress] += depositAmount;\r\n\r\n        if (!contains(userDepositedTokens[msg.sender], tokenAddress)) {\r\n            userDepositedTokens[msg.sender].push(tokenAddress);\r\n        }\r\n\r\n        // Emit the TokensDeposited event\r\n        emit TokensDeposited(msg.sender, tokenAddress, depositAmount);\r\n    }\r\n\r\n    /// @notice Get the deposit balance for a user and a specific token\r\n    /// @param user The user's address\r\n    /// @param token The address of the token\r\n    /// @return The amount of the specified token deposited by the user\r\n    function getDepositBalance(\r\n        address user,\r\n        address token\r\n    ) external view returns (uint256) {\r\n        return deposits[user][token];\r\n    }\r\n\r\n    /// @notice Get the list of deposited tokens for a user\r\n    /// @param user The user's address\r\n    /// @return An array of addresses representing the tokens deposited by the user\r\n    function getDepositedTokens(\r\n        address user\r\n    ) external view returns (address[] memory) {\r\n        return userDepositedTokens[user];\r\n    }\r\n\r\n    /// @notice Withdraw tokens from the contract\r\n    /// @param tokenAddress The address of the token to be withdrawn\r\n    /// @param amount The amount of tokens to be withdrawn\r\n    function withdraw(\r\n        address tokenAddress,\r\n        uint256 amount\r\n    ) external noReentrancy {\r\n        // Checks if the withdrawal amount is valid\r\n        require(amount > 0, \"Withdraw amount must be greater than zero\");\r\n        require(\r\n            deposits[msg.sender][tokenAddress] >= amount,\r\n            \"Insufficient deposited amount\"\r\n        );\r\n\r\n        // Effects: Update the user's deposit\r\n        deposits[msg.sender][tokenAddress] -= amount;\r\n\r\n        // Interactions: Transfer the tokens to the user\r\n        IERC20(tokenAddress).transfer(msg.sender, amount);\r\n\r\n        // Emit the TokensWithdrawn event\r\n        emit TokensWithdrawn(msg.sender, tokenAddress, amount);\r\n    }\r\n\r\n    /// @dev Internal function to check if an element is in an array\r\n    /// @param array The array to search\r\n    /// @param element The element to search for\r\n    /// @return true if the element is in the array, false otherwise\r\n    function contains(\r\n        address[] memory array,\r\n        address element\r\n    ) internal pure returns (bool) {\r\n        for (uint256 i = 0; i < array.length; i++) {\r\n            if (array[i] == element) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Sets the fee percentage for deposits with fractional precision.\r\n    /// @dev Only the owner of the contract can call this function.\r\n    /// @param newFeePercentageNumerator The new numerator for the fee percentage.\r\n    /// @param newFeePercentageDenominator The new denominator for the fee percentage.\r\n    /// @dev Emits a `FeePercentageChanged` event upon successful update.\r\n    function setFeePercentage(\r\n        uint256 newFeePercentageNumerator,\r\n        uint256 newFeePercentageDenominator\r\n    ) external onlyOwner {\r\n        require(\r\n            newFeePercentageNumerator <= 1000,\r\n            \"Fee percentage numerator must be <= 1000\"\r\n        );\r\n        require(\r\n            newFeePercentageDenominator != 0,\r\n            \"Denominator must not be zero\"\r\n        );\r\n        require(\r\n            newFeePercentageNumerator <= newFeePercentageDenominator,\r\n            \"Numerator must be less than or equal to the denominator\"\r\n        );\r\n\r\n        feePercentageNumerator = newFeePercentageNumerator;\r\n        feePercentageDenominator = newFeePercentageDenominator;\r\n\r\n        emit FeePercentageChanged(\r\n            newFeePercentageNumerator,\r\n            newFeePercentageDenominator\r\n        );\r\n    }\r\n\r\n    /// @notice Allows the owner to withdraw accumulated fees from the contract.\r\n    /// @dev Only the owner of the contract can call this function.\r\n    /// @param tokenAddress The address of the token to be withdrawn.\r\n    /// @param amount The amount of tokens to be withdrawn.\r\n    /// @dev Requires that the contract has enough balance of the specified token.\r\n    function withdrawFees(\r\n        address tokenAddress,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        require(amount > 0, \"Withdraw amount must be greater than zero\");\r\n        require(\r\n            IERC20(tokenAddress).balanceOf(address(this)) >= amount,\r\n            \"Insufficient contract balance\"\r\n        );\r\n        require(\r\n            accumulatedFees[tokenAddress] >= amount,\r\n            \"Insufficient accumulated fees\"\r\n        );\r\n\r\n        // Update the accumulated fee for the token\r\n        accumulatedFees[tokenAddress] -= amount;\r\n\r\n        // Transfer the tokens to the owner\r\n        IERC20(tokenAddress).transfer(msg.sender, amount);\r\n\r\n        // Emit the TokensWithdrawn event\r\n        emit TokensWithdrawn(msg.sender, tokenAddress, amount);\r\n    }\r\n\r\n    function getAccumulatedFee(address token) external view returns (uint256) {\r\n        return accumulatedFees[token];\r\n    }\r\n}\r\n\r\n// Interface for the Uniswap V2 Router\r\ninterface IUniswapV2Router {\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\n// Interface for the ERC-20 Token Standard\r\ninterface IERC20 {\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeePercentageNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeePercentageDenominator\",\"type\":\"uint256\"}],\"name\":\"FeePercentageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router1Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router2Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOutFinal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"pathsIn\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"pathsOut\",\"type\":\"address[]\"}],\"name\":\"TokensSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accumulatedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"expectedCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentageDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentageNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getAccumulatedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDepositedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"name\":\"isTrustedRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeePercentageNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newFeePercentageDenominator\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"routerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"setTrustedRouters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router1Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router2Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutFinal\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pathsIn\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pathsOut\",\"type\":\"address[]\"}],\"internalType\":\"struct TokenSwap.SwapInfo\",\"name\":\"swapInfo\",\"type\":\"tuple\"}],\"name\":\"swapTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userDepositedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenSwap", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008f28e2889e82ef459e089dc018ec4d14405be4fe", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4ce43c6a68308a51e7dc6ed0d31c9bdff3a2cac77d7cfd6fea858ffe4409b80"}