{"SourceCode": "//www.bigcockcoin.com\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\n// Interface for the ERC20 standard as defined in the EIP.\r\ninterface IERC20 {\r\n        // Returns the total token supply.\r\n    function totalSupply() external view returns (uint256);\r\n    // Returns the account balance of another account with address `account`.\r\n    function balanceOf(address account) external view returns (uint256);\r\n    // Transfers `amount` tokens to `recipient`, and MUST fire the Transfer event.\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    // Returns the amount which `spender` is still allowed to withdraw from `owner`.\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    // Sets `amount` as the allowance of `spender` over the caller\u2019s tokens.\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    // Transfers `amount` tokens from `sender` to `recipient`, and MUST fire the Transfer event.\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    // MUST trigger when tokens are transferred, including zero value transfers.\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    // MUST trigger on any successful call to `approve(address spender, uint256 value)`.\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// A library for handling binary fixed point numbers (numbers with a fixed number of digits after the decimal point).\r\nlibrary Address{\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n// Provides information about the current execution context, including the sender of the transaction.\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    // Returns the calldata of the current call.\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n// Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions.\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    // Event to notify when ownership is transferred.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    // Initializes the contract setting the deployer as the initial owner.\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n    // Returns the address of the current owner.\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    // Modifier to restrict functions to only the owner of the contract.\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    // Leaves the contract without owner, which will not be able to call `onlyOwner` functions anymore.\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n    // Transfers ownership of the contract to a new account (`newOwner`).\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n    // Internal function to set the owner of the contract.\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n// Interface to define creating pairs for two tokens.\r\ninterface IFactory{\r\n        function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n// Router interface that defines necessary methods.\r\ninterface IRouter {\r\n        // Returns the factory address.\r\n    function factory() external pure returns (address);\r\n        // Returns the canonical WETH address.\r\n    function WETH() external pure returns (address);\r\n        // Adds liquidity to the AMM and returns the amounts added as well as liquidity tokens created.\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    // Swaps an exact amount of input tokens for as many output tokens as possible, supporting fee on transfer tokens.\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline) external;\r\n}\r\n// Contract that represents the token logic and behavior.\r\ncontract BIGCOCKCOIN is Context, IERC20, Ownable {\r\n    using Address for address payable;\r\n\r\n    // Mapping to store reflected token ownership as part of a reflection mechanism.\r\n    mapping (address => uint256) private _rOwned;\r\n\r\n    // Mapping to store actual token ownership for accounts that are excluded from reward mechanisms.\r\n    mapping (address => uint256) private _tOwned;\r\n\r\n    // Mapping to store allowances: how much a spender is allowed to transfer on behalf of the token owner.\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    // Mapping to keep track of accounts that are excluded from paying fees.\r\n    mapping (address => bool) private _isExcludedFromFee;\r\n\r\n    // Mapping to keep track of accounts that are excluded from receiving rewards.\r\n    mapping (address => bool) private _isExcluded;\r\n\r\n    // Array to store addresses that are excluded from rewards.\r\n    address[] private _excluded;\r\n\r\n    // Public boolean to enable or disable swapping tokens within the contract.\r\n    bool public swapEnabled = true;\r\n\r\n    // Boolean to prevent reentrancy in swap logic.\r\n    bool private swapping;\r\n\r\n    // Router interface to interact with router contracts for token swaps and liquidity management.\r\n    IRouter public router;\r\n\r\n    // Address of the liquidity pair for this token on the AMM (Automated Market Maker).\r\n    address public pair;\r\n\r\n    // Token decimal places, indicating how divisible the token is.\r\n    uint8 private constant _decimals = 9;\r\n\r\n    // Maximum value for uint256, used in reflection calculations.\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    // Total supply of the tokens, calculated by multiplying the desired number of tokens by 10 raised to the power of `_decimals`.\r\n    uint256 private _tTotal = 69000000000 * 10**_decimals;\r\n\r\n    // Reflected total supply, used in the reflection mechanism.\r\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n\r\n    // Threshold for the number of tokens in the contract to trigger swapping and liquidity addition.\r\n    uint256 public swapTokensAtAmount = _tTotal * 10 / 1000; // 1 = 0.1%\r\n\r\n    // Maximum number of tokens that can be transacted in a single transfer.\r\n    uint256 public maxTxAmount = _tTotal;\r\n\r\n    // Maximum number of tokens that can be held in a single wallet.\r\n    uint256 public maxWalletAmount = _tTotal * 42 / 1000;\r\n\r\n    // Address that is used to 'burn' tokens by sending tokens to an address that no one controls.\r\n    address public constant deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // Address for the marketing wallet where marketing funds will be collected.\r\n    address public marketingWallet = 0x6BF3e9857784C5b50BA11e339EC8500C44FAb0FB;\r\n\r\n    // The name of the token.\r\n    string private constant _name = \"Big Cock Coin\";\r\n\r\n    // The ticker symbol of the token.\r\n    string private constant _symbol = \"COCK\";\r\n\r\n    // Timestamp marking the start of the token operation.\r\n    uint256 public startTimestamp;\r\n\r\n    // Initial burn fee as a percentage (with two extra digits for precision, e.g., 5 means 0.5%).\r\n    uint256 private constant INITIAL_BURN_FEE = 5;\r\n\r\n    // Maximum burn fee that the token can have as a percentage.\r\n    uint256 private constant MAX_BURN_FEE = 42; // 4.2% fee, represented as 42 for precision.\r\n\r\n    // The period after which the burn fee will double. Initially set to double every 10 minutes.\r\n    uint256 private constant BURN_DOUBLING_PERIOD = 365 days;\r\n\r\n    // The multiplier used to increase the burn fee every period defined by `BURN_DOUBLING_PERIOD`.\r\n    uint256 private constant FEE_MULTIPLIER = 2;\r\n\r\n    struct Taxes {\r\n        uint256 rfi;\r\n        uint256 marketing;\r\n        uint256 liquidity;\r\n    }\r\n    Taxes private taxes = Taxes(1,7,1); // Initialize with the static fees\r\n\r\n    // Public function to get the current taxes including all fees as percentages\r\n    function getCurrentSellTaxes() public view returns (string memory reflectionPercentage, string memory marketingPercentage, string memory liquidityPercentage, string memory burnPercentage) {\r\n        uint256 currentBurnFee = getCurrentBurnFee();\r\n        \r\n        // Determine the correct burn percentage string based on the burn fee\r\n        if (currentBurnFee == 5) {\r\n            burnPercentage = \"0.5%\";\r\n        } else if (currentBurnFee == 10) {\r\n            burnPercentage = \"1%\";\r\n        } else if (currentBurnFee == 20) {\r\n            burnPercentage = \"2%\";\r\n        } else if (currentBurnFee == 40) {\r\n            burnPercentage = \"4%\";\r\n        } else if (currentBurnFee > 40) {\r\n            burnPercentage = \"4.20%\";\r\n        } else {\r\n            burnPercentage = \"4%\";\r\n        }\r\n        \r\n        // Static values for other fees\r\n        reflectionPercentage = \"1%\";\r\n        marketingPercentage = \"0.7%\";\r\n        liquidityPercentage = \"1%\";\r\n        \r\n        return (reflectionPercentage, marketingPercentage, liquidityPercentage, burnPercentage);\r\n    }\r\n\r\n    struct TotFeesPaidStruct{\r\n        uint256 rfi;\r\n        uint256 marketing;\r\n        uint256 liquidity;\r\n        uint256 burn;\r\n    }\r\n    TotFeesPaidStruct public totFeesPaid;\r\n\r\n    struct valuesFromGetValues{\r\n      uint256 rAmount;\r\n      uint256 rTransferAmount;\r\n      uint256 rRfi;\r\n      uint256 rMarketing;\r\n      uint256 rLiquidity;\r\n      uint256 rBurn;\r\n      uint256 tTransferAmount;\r\n      uint256 tRfi;\r\n      uint256 tMarketing;\r\n      uint256 tLiquidity;\r\n      uint256 tBurn;\r\n    }\r\n\r\n    event UpdatedRouter(address oldRouter, address newRouter);\r\n\r\n    modifier lockTheSwap {\r\n        swapping = true;\r\n        _;\r\n        swapping = false;\r\n    }\r\n\r\n// This constructor function sets up a new token with a router and pair for swapping,\r\n// excludes certain addresses from rewards and fees, and emits a transfer event to the owner.\r\n    constructor () {\r\n        \r\n        IRouter _router = IRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        address _pair = IFactory(_router.factory())\r\n            .createPair(address(this), _router.WETH());\r\n\r\n        router = _router; \r\n        pair = _pair;\r\n        \r\n        excludeFromReward(pair);\r\n        excludeFromReward(deadAddress);\r\n\r\n        _rOwned[owner()] = _rTotal;\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[marketingWallet]=true;\r\n        _isExcludedFromFee[deadAddress] = true;\r\n        \r\n        emit Transfer(address(0), owner(), _tTotal);\r\n        startTimestamp = block.timestamp; // Initialize the start timestamp\r\n\r\n    }\r\n// This function returns the name of the token.\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n            // This function returns the symbol of the token.\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n        // This function returns the number of decimals the token uses.\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    // This function returns the total supply of the token.\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    // This function returns the balance of a given account. If the account is excluded from reward, it returns the total owned tokens; otherwise, it returns the reflected token balance.\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    // This function transfers a given amount of tokens to a recipient and returns a boolean value indicating success.\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    // This function returns the remaining number of tokens that an owner allowed a spender to use on their behalf.\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n// This function sets the amount of allowance a spender is allowed to use on the owner's behalf and returns a boolean value indicating success.\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n// This function transfers a given amount of tokens from a sender to a recipient, assuming the transaction is allowed by the current allowance.\r\n// It then deducts the transferred amount from the sender's allowance for the caller of the function.\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n// This function increases the allowance granted to a spender by the caller by a specified amount and returns a boolean to indicate a successful operation.\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n// This function decreases the allowance granted to a spender by the caller by a specified amount and ensures the allowance does not fall below zero.\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n// This function checks if an account is excluded from rewards and returns a boolean reflecting the exclusion status.\r\n\r\n    function isExcludedFromReward(address account) public view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n// This function calculates the reflection amount from a given token amount with an option to deduct the transfer fee, and returns the reflection amount.\r\n// It ensures the token amount is less than the total supply and calculates based on whether the fee should be deducted.\r\n    function reflectionFromToken(uint256 tAmount, bool deductTransferRfi) public view returns(uint256) {\r\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\r\n        if (!deductTransferRfi) {\r\n            valuesFromGetValues memory s = _getValues(tAmount, true);\r\n            return s.rAmount;\r\n        } else {\r\n            valuesFromGetValues memory s = _getValues(tAmount, true);\r\n            return s.rTransferAmount;\r\n        }\r\n    }\r\n// This function converts a reflection amount to the token equivalent.\r\n// It requires that the reflection amount is less than the total reflections, and uses the current rate for the conversion.\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount/currentRate;\r\n    }\r\n// This function excludes an account from receiving rewards. It is restricted to the owner of the contract.\r\n// If the account has a reflected balance, it's converted to the token balance.\r\n// It then marks the account as excluded and adds it to the list of excluded accounts.\r\n    function excludeFromReward(address account) public onlyOwner {\r\n        require(!_isExcluded[account], \"Account is already excluded\");\r\n        if(_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n// This function includes a previously excluded account back into rewards. It is restricted to the owner of the contract.\r\n// It removes the account from the excluded list, resets their token owned to zero, and marks them as not excluded.\r\n    function includeInReward(address account) external onlyOwner {\r\n        require(_isExcluded[account], \"Account is not excluded\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tOwned[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n// This function allows the contract owner to exclude an account from paying fees.\r\n    function excludeFromFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n// This function allows the contract owner to include an account in paying fees.\r\n    function includeInFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = false;\r\n    }\r\n\r\n// This function allows anyone to check if an account is excluded from paying fees.\r\n    function isExcludedFromFee(address account) public view returns(bool) {\r\n        return _isExcludedFromFee[account];\r\n    }\r\n// This private function reflects a portion of transaction fees (RFI) by decreasing the total reflections and increasing the total fees paid.\r\n    function _reflectRfi(uint256 rRfi, uint256 tRfi) private {\r\n        _rTotal -=rRfi;\r\n        totFeesPaid.rfi +=tRfi;\r\n    }\r\n// This private function handles taking liquidity fees by increasing the total fees paid and updating balances if the contract is excluded from rewards.\r\n    function _takeLiquidity(uint256 rLiquidity, uint256 tLiquidity) private {\r\n        totFeesPaid.liquidity +=tLiquidity;\r\n\r\n        if(_isExcluded[address(this)])\r\n        {\r\n            _tOwned[address(this)]+=tLiquidity;\r\n        }\r\n        _rOwned[address(this)] +=rLiquidity;\r\n    }\r\n// This private function is used to take the marketing fee from a transaction. It updates the total marketing fees paid and adjusts the contract's token and reflection balances.\r\n    function _takeMarketing(uint256 rMarketing, uint256 tMarketing) private {\r\n        totFeesPaid.marketing +=tMarketing;\r\n\r\n        if(_isExcluded[address(this)])\r\n        {\r\n            _tOwned[address(this)]+=tMarketing;\r\n        }\r\n        _rOwned[address(this)] +=rMarketing;\r\n    }\r\n    // This private function handles the burning of tokens. It calculates the burn amount based on the transaction amount and the current burn fee,\r\n// then updates the total fees paid for burning, decreases the total supply, and emits a transfer event to the burn address.\r\n    function _takeBurn(uint256 tAmount) private {\r\n        uint256 currentBurnFee = getCurrentBurnFee(); // This will now return 5 for 0.5%\r\n        uint256 tBurn = tAmount * currentBurnFee / 1000; // Divide by 1000 to account for the two extra zeros\r\n        uint256 rBurn = tBurn * _getRate();\r\n\r\n        totFeesPaid.burn += tBurn;\r\n\r\n        if(_isExcluded[deadAddress]) {\r\n            _tOwned[deadAddress] += tBurn;\r\n        }\r\n        _rOwned[deadAddress] += rBurn;\r\n        \r\n        // Decrease the total supply\r\n        _rTotal = _rTotal - rBurn;\r\n        _tTotal = _tTotal - tBurn;\r\n\r\n        emit Transfer(msg.sender, deadAddress, tBurn); // Emit the Transfer event here\r\n    }\r\n// This private function retrieves the calculated values for both token and reflection amounts for a transaction,\r\n// based on whether a fee is taken and the current rate of reflection to tokens.\r\n    function _getValues(uint256 tAmount, bool takeFee) private view returns (valuesFromGetValues memory to_return) {\r\n        to_return = _getTValues(tAmount, takeFee);\r\n        (to_return.rAmount, to_return.rTransferAmount, to_return.rRfi, to_return.rMarketing, to_return.rLiquidity, to_return.rBurn) = _getRValues(to_return, tAmount, takeFee, _getRate());\r\n        return to_return;\r\n    }\r\n\r\n    // Internal function to get the current burn fee\r\n    function getCurrentBurnFee() internal view returns (uint256) {\r\n        uint256 timeSinceStart = block.timestamp - startTimestamp;\r\n        uint256 hoursSinceStart = timeSinceStart / BURN_DOUBLING_PERIOD; // Change '1 years' to '1 hours' for hourly update\r\n\r\n        uint256 currentBurnFee = INITIAL_BURN_FEE;\r\n        for (uint256 i = 0; i < hoursSinceStart; i++) {\r\n            currentBurnFee *= FEE_MULTIPLIER;\r\n            if (currentBurnFee >= MAX_BURN_FEE) {\r\n                return MAX_BURN_FEE;\r\n            }\r\n        }\r\n\r\n        return currentBurnFee;\r\n    }\r\n// This private function calculates the transaction values when taking fees into account.\r\n// It returns a structure with all the calculated values for reflection fee, marketing, liquidity, burn, and the total transfer amount.\r\n    function _getTValues(uint256 tAmount, bool takeFee) private view returns (valuesFromGetValues memory s) {\r\n        if (!takeFee) {\r\n            s.tTransferAmount = tAmount;\r\n            return s;\r\n        }\r\n\r\n        // Static fees\r\n        s.tRfi = tAmount * taxes.rfi / 100;\r\n        s.tMarketing = tAmount * taxes.marketing / 1000;\r\n        s.tLiquidity = tAmount * taxes.liquidity / 100;\r\n\r\n        // Dynamic burn fee\r\n        s.tBurn = tAmount * getCurrentBurnFee() / 1000; // Divide by 1000 to account for the two extra zeros\r\n\r\n        // Calculate the total transfer amount after fees\r\n        s.tTransferAmount = tAmount - s.tRfi - s.tMarketing - s.tLiquidity - s.tBurn;\r\n        return s;\r\n    }\r\n// This private function calculates the reflection values for a transaction, taking into account the current rate and whether fees are applied.\r\n// It returns the reflection amount, reflection transfer amount, and reflection amounts for each fee type.\r\n    function _getRValues(\r\n        valuesFromGetValues memory s, \r\n        uint256 tAmount, \r\n        bool takeFee, \r\n        uint256 currentRate\r\n    ) \r\n        private \r\n        pure // Change this line from 'view' to 'pure'\r\n        returns (\r\n            uint256 rAmount, \r\n            uint256 rTransferAmount, \r\n            uint256 rRfi, \r\n            uint256 rMarketing, \r\n            uint256 rLiquidity, \r\n            uint256 rBurn\r\n        ) \r\n    {\r\n        rAmount = tAmount * currentRate;\r\n\r\n        if (!takeFee) {\r\n            return (rAmount, rAmount, 0, 0, 0, 0);\r\n        }\r\n    // Calculate reflection amounts based on the token fee values\r\n        rRfi = s.tRfi * currentRate;\r\n        rMarketing = s.tMarketing * currentRate;\r\n        rLiquidity = s.tLiquidity * currentRate;\r\n        rBurn = s.tBurn * currentRate; // Reflective burn calculated from the dynamic tBurn\r\n        rTransferAmount = rAmount - rRfi - rMarketing - rLiquidity - rBurn;\r\n        return (rAmount, rTransferAmount, rRfi, rMarketing, rLiquidity, rBurn);\r\n    }\r\n\r\n// This private function calculates the current rate of reflections to tokens by dividing the total reflections by the total supply of tokens.\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply/tSupply;\r\n    }\r\n// This private function calculates the current reflection and token supply by subtracting the owned amounts of excluded accounts from the totals.\r\n// It ensures that the supplies are only reduced if the excluded accounts' balances are valid.\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\r\n            rSupply = rSupply-_rOwned[_excluded[i]];\r\n            tSupply = tSupply-_tOwned[_excluded[i]];\r\n        }\r\n        if (rSupply < _rTotal/_tTotal) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n// This private function approves a spender to spend up to a certain amount of the owner's tokens.\r\n// It requires that neither the owner nor the spender is the zero address, and emits an Approval event.\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    // This private function is responsible for transferring tokens from one address to another.\r\n    // It requires non-zero addresses, a non-zero amount, and that the sender has enough balance.\r\n    // It checks if fees should be taken based on the sender or recipient being excluded from fees and conducts a feeless transaction in case of buys from a liquidity pool.\r\n    // It also ensures that the transaction does not exceed the maximum allowed amount per wallet or transaction.\r\n    // If conditions are met, it may trigger a swap and liquidity addition before executing the transfer.\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        require(amount <= balanceOf(from), \"You are trying to transfer more than your balance\");\r\n\r\n        // Check max wallet amount for every transfer except when selling (to == pair), when to is the owner, the dead address, or the marketing wallet\r\n        if (to != pair && to != owner() && to != deadAddress && to != marketingWallet) {\r\n            require(balanceOf(to) + amount <= maxWalletAmount, \"You are exceeding maxWalletAmount\");\r\n        }\r\n\r\n        // Indicate if fee should be taken\r\n        bool takeFee = !(_isExcludedFromFee[from] || _isExcludedFromFee[to]);\r\n\r\n        // If it's a buy transaction from liquidity pool, do not take a fee\r\n        if (from == pair) {\r\n            takeFee = false;\r\n        }\r\n\r\n        // Check max transaction amount if fee is taken\r\n        if (takeFee) {\r\n            require(amount <= maxTxAmount, \"You are exceeding maxTxAmount\");\r\n        }\r\n\r\n        bool canSwap = balanceOf(address(this)) >= swapTokensAtAmount;\r\n        if (!swapping && swapEnabled && canSwap && from != pair && takeFee) {\r\n            swapAndLiquify(swapTokensAtAmount);\r\n        }\r\n\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n    }\r\n\r\n\r\n\r\n// This method is responsible for taking fees and transferring the tokens accordingly.\r\n// It calculates the values required for transfer and fee deduction.\r\n// It adjusts the token and reflection balances of the sender and recipient.\r\n// It also handles the distribution of various fees (RFI, liquidity, marketing, and burn) based on the calculated amounts.    \r\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee) private {\r\n\r\n        valuesFromGetValues memory s = _getValues(tAmount, takeFee);\r\n\r\n        if (_isExcluded[sender] ) {  //from excluded\r\n                _tOwned[sender] = _tOwned[sender]-tAmount;\r\n        }\r\n        if (_isExcluded[recipient]) { //to excluded\r\n                _tOwned[recipient] = _tOwned[recipient]+s.tTransferAmount;\r\n        }\r\n\r\n        _rOwned[sender] = _rOwned[sender]-s.rAmount;\r\n        _rOwned[recipient] = _rOwned[recipient]+s.rTransferAmount;\r\n        \r\n        if(s.rRfi > 0 || s.tRfi > 0) _reflectRfi(s.rRfi, s.tRfi);\r\n        if(s.rLiquidity > 0 || s.tLiquidity > 0) {\r\n            _takeLiquidity(s.rLiquidity,s.tLiquidity);\r\n        }\r\n        if(s.rMarketing > 0 || s.tMarketing > 0){\r\n            _takeMarketing(s.rMarketing, s.tMarketing);\r\n        }\r\n        if(s.rBurn > 0 || s.tBurn > 0){\r\n            _takeBurn(tAmount); // Call _takeBurn with the tAmount\r\n        }\r\n        \r\n        emit Transfer(sender, recipient, s.tTransferAmount);\r\n        emit Transfer(sender, address(this), s.tLiquidity + s.tMarketing);\r\n        \r\n    }\r\n// This function is used to swap a portion of the tokens held by the contract for BNB and then add liquidity to the PancakeSwap (or similar) exchange.\r\n// It locks the swap during its execution to prevent reentrancy. The function calculates the number of tokens to be swapped for BNB and the number to be added as liquidity.\r\n// It then performs the token swap, calculates the BNB to be paired with the remaining tokens, and finally, adds liquidity to the exchange.\r\n    function swapAndLiquify(uint256 tokens) private lockTheSwap{\r\n    // Calculate the number of tokens to swap for BNB and the number to add for liquidity\r\n        uint256 denominator = (taxes.liquidity + taxes.marketing ) * 2;\r\n        uint256 tokensToAddLiquidityWith = tokens * taxes.liquidity / denominator;\r\n        uint256 toSwap = tokens - tokensToAddLiquidityWith;\r\n\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        swapTokensForBNB(toSwap);\r\n\r\n        uint256 deltaBalance = address(this).balance - initialBalance;\r\n        uint256 unitBalance= deltaBalance / (denominator - taxes.liquidity);\r\n        uint256 bnbToAddLiquidityWith = unitBalance * taxes.liquidity;\r\n\r\n        if(bnbToAddLiquidityWith > 0){\r\n            // Add liquidity to pancake\r\n            addLiquidity(tokensToAddLiquidityWith, bnbToAddLiquidityWith);\r\n        }\r\n\r\n        uint256 marketingAmt = unitBalance * 2 * taxes.marketing;\r\n        if(marketingAmt > 0){\r\n            payable(marketingWallet).sendValue(marketingAmt);\r\n        }\r\n\r\n    }\r\n// This private function is used for swapping tokens for BNB.\r\n    function addLiquidity(uint256 tokenAmount, uint256 bnbAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(router), tokenAmount);\r\n\r\n        // add the liquidity\r\n        router.addLiquidityETH{value: bnbAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            marketingWallet,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapTokensForBNB(uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        _approve(address(this), address(router), tokenAmount);\r\n\r\n        // make the swap\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n// This function updates the marketing wallet address and ensures it is excluded from transaction fees.\r\n    function updatemarketingWallet(address newWallet) external onlyOwner{\r\n        marketingWallet = newWallet;\r\n        _isExcludedFromFee[marketingWallet] = true;\r\n    }\r\n// This function updates the threshold amount that triggers the swapAndLiquify function when tokens are transferred.\r\n    function updateSwapTokensAtAmount(uint256 amount) external onlyOwner{\r\n        swapTokensAtAmount = _tTotal * amount / 1000; // THRESHOLD : 1 = 0.1% \r\n    }\r\n// This function toggles the swap functionality on or off.\r\n    function updateSwapEnabled(bool _enabled) external onlyOwner{\r\n        swapEnabled = _enabled;\r\n    }\r\n    // This function updates the router and pair addresses for swapping and liquidity operations.\r\n    function updateRouterAndPair(address newRouter, address newPair) external onlyOwner{\r\n        router = IRouter(newRouter);\r\n        pair = newPair;\r\n    }\r\n\r\n    // Use this in case BNB are sent to the contract by mistake\r\n    function rescueBNB(uint256 weiAmount) external onlyOwner {\r\n        require(address(this).balance >= weiAmount, \"Insufficient BNB balance\");\r\n\r\n        // Using call to send BNB which is safer post-EIP-1884\r\n        (bool success, ) = payable(msg.sender).call{value: weiAmount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    \r\n    // Function to allow admin to claim *other* BEP20 tokens sent to this contract (by mistake)\r\n    // Owner cannot transfer out catecoin from this smart contract\r\n    function rescueAnyBEP20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner {\r\n        bool success = IERC20(_tokenAddr).transfer(_to, _amount);\r\n        require(success, \"Token transfer failed\");\r\n    }\r\n\r\n// This function calculates the remaining time until the burn fee is scheduled to double again.\r\n// It breaks down the remaining time into days, hours, minutes, and seconds. If the burn fee has reached its maximum, all values will be zero.\r\n    function timeUntilNextBurnFeeDoubles() public view returns (uint256 daysRemaining, uint256 hoursRemaining, uint256 minutesRemaining, uint256 secondsRemaining) {\r\n        uint256 currentBurnFee = getCurrentBurnFee();\r\n        if (currentBurnFee >= MAX_BURN_FEE) {\r\n            // The burn fee has reached its maximum and will not increase further.\r\n            daysRemaining = 0;\r\n            hoursRemaining = 0;\r\n            minutesRemaining = 0;\r\n            secondsRemaining = 0;\r\n            return (daysRemaining, hoursRemaining, minutesRemaining, secondsRemaining);\r\n        }\r\n        uint256 timeSinceStart = block.timestamp - startTimestamp;\r\n        uint256 periodsSinceStart = timeSinceStart / BURN_DOUBLING_PERIOD;\r\n        uint256 nextIncreaseTime = startTimestamp + ((periodsSinceStart + 1) * BURN_DOUBLING_PERIOD);\r\n        uint256 timeToNextIncrease = nextIncreaseTime > block.timestamp ? nextIncreaseTime - block.timestamp : 0;\r\n\r\n        // Convert time to days, hours, minutes, and seconds.\r\n        daysRemaining = timeToNextIncrease / (24 * 60 * 60);\r\n        hoursRemaining = (timeToNextIncrease % (24 * 60 * 60)) / (60 * 60);\r\n        minutesRemaining = (timeToNextIncrease % (60 * 60)) / 60;\r\n        secondsRemaining = timeToNextIncrease % 60;\r\n        return (daysRemaining, hoursRemaining, minutesRemaining, secondsRemaining);\r\n    }\r\n\r\n    receive() external payable{\r\n    }\r\n}\r\n\r\n//how big will your $COCK get?", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"UpdatedRouter\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSellTaxes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"reflectionPercentage\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"marketingPercentage\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"liquidityPercentage\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"burnPercentage\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferRfi\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rescueAnyBEP20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"rescueBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeUntilNextBurnFeeDoubles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daysRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hoursRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minutesRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsRemaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totFeesPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rfi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newPair\",\"type\":\"address\"}],\"name\":\"updateRouterAndPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"updateSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updatemarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BIGCOCKCOIN", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7432a4d2522295fd2e80269ed80b6489ecf3db27673f0776dac3d0cba6a8cae0"}