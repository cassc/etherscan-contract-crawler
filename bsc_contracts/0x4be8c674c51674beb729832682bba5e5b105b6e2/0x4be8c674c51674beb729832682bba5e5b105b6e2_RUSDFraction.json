{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RUSDFraction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// pragma solidity 0.7.6;\\n\\nimport \\\"./RUSD-additional/CastU256U128.sol\\\";\\nimport \\\"./RUSD-additional/CastU256U32.sol\\\";\\nimport \\\"./RUSD-additional/SafeMathInt.sol\\\";\\nimport \\\"./RUSD-additional/SafeMath.sol\\\";\\nimport \\\"./RUSD-additional/Initializable.sol\\\";\\nimport \\\"./RUSD-additional/IERC20.sol\\\";\\nimport \\\"./RUSD-additional/Ownable.sol\\\";\\nimport \\\"./RUSD-additional/ERC20Detailed.sol\\\";\\nimport \\\"./RUSD-additional/IProviderPair.sol\\\";\\n\\ninterface IRouter {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IRUSDRewards {\\n    function _updateRewardsPerToken() external;\\n\\n    function _updateUserRewards(address user) external;\\n}\\n\\ncontract RUSDFraction is ERC20Detailed, Ownable {\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n    using CastU256U32 for uint256;\\n    using CastU256U128 for uint256;\\n\\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\\n    event LogMonetaryPolicyUpdated(address monetaryPolicy);\\n    event LogDeveloperAddress(address developer);\\n    event LogLiquidityAddress(address liquidityPool);\\n    event LogDeveloperFee(\\n        uint256 sellDeveloperPercent,\\n        uint256 buyDeveloperPercent\\n    );\\n    event LogLiquidityFee(uint256 sellLiquidityFee, uint256 buyLiquidityFee);\\n\\n    modifier validRecipient(address to) {\\n        require(to != address(0x0));\\n        require(to != address(this));\\n        _;\\n    }\\n\\n    struct Fees {\\n        uint256 devSellFee;\\n        uint256 devBuyFee;\\n        uint256 rewardPoolSellFee;\\n        uint256 rewardPoolBuyFee;\\n        uint256 reflectoBBSellFee;\\n        uint256 reflectoBBBuyFee;\\n        uint256 liquiditySellFee;\\n        uint256 liquidityBuyFee;\\n    }\\n    mapping(address => Fees) public usersFees;\\n    mapping(address => bool) public isCustomFee;\\n    mapping(address => bool) public isExcludedFromAllFees;\\n\\n    mapping(address => uint256) public timeOfSell;\\n    mapping(address => uint256) public amountOfSell;\\n    uint256 public sellLimit;\\n\\n    uint256 private constant DECIMALS = 9;\\n    uint256 private constant MAX_UINT256 = type(uint256).max;\\n    uint256 private constant INITIAL_FRACTIONS_SUPPLY =\\n        50 * 10**6 * 10**DECIMALS; // 50 million\\n\\n    // TOTAL_FRAC is a multiple of INITIAL_FRACTIONS_SUPPLY so that _fracsPerRUSD is an integer.\\n    // Use the highest value that fits in a uint256 for max granularity.\\n    uint256 private constant TOTAL_FRAC =\\n        MAX_UINT256 - (MAX_UINT256 % INITIAL_FRACTIONS_SUPPLY);\\n\\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_FRAC + 1) - 1) / 2\\n    uint256 private constant MAX_SUPPLY = type(uint128).max; // (2^128) - 1\\n\\n    address public monetaryPolicy;\\n    IProviderPair[] public providerPairs;\\n    IRUSDRewards public rusdRewardContract;\\n    address public developer;\\n    address public liquidityPool;\\n    uint256 public sellDeveloperPercent;\\n    uint256 public buyDeveloperPercent;\\n    uint256 public sellLiquidityFee;\\n    uint256 public buyLiquidityFee;\\n    uint256 public buyBackPool;\\n    uint256 public buyBackContract;\\n    uint256 public sellBackPool;\\n    uint256 public sellBackContract;\\n    address public reflectoAdd;\\n    address public poolAddress;\\n    uint256 private _totalSupply;\\n    uint256 private _fracsPerRUSD;\\n    mapping(address => uint256) public nonces;\\n\\n    bytes32 public constant PERMIT_TYPEHASH_META =\\n        0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\n\\n    mapping(address => uint256) private _fracBalances;\\n\\n    // This is denominated in fractions, because the fracs-fractions conversion might change before\\n    // it's fully paid.\\n    mapping(address => mapping(address => uint256)) private _allowedFractions;\\n\\n    // EIP-2612: permit \u2013 712-signed approvals\\n    // https://eips.ethereum.org/EIPS/eip-2612\\n    string public constant EIP712_REVISION = \\\"1\\\";\\n    bytes32 public constant EIP712_DOMAIN =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\n            \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n        );\\n\\n    function excludeFromAllFees(address holder_, bool isExcluded)\\n        external\\n        onlyOwner\\n    {\\n        isExcludedFromAllFees[holder_] = isExcluded;\\n    }\\n\\n    /* SETTER FUNCTIONS */\\n    function setMonetaryPolicy(address monetaryPolicy_) external onlyOwner {\\n        monetaryPolicy = monetaryPolicy_;\\n        emit LogMonetaryPolicyUpdated(monetaryPolicy_);\\n    }\\n\\n    modifier onlyMonetaryPolicy() {\\n        require(msg.sender == monetaryPolicy);\\n        _;\\n    }\\n\\n    function setDeveloperAddress(address developer_) external onlyOwner {\\n        developer = developer_;\\n        emit LogDeveloperAddress(developer_);\\n    }\\n\\n    function setLiquidityPool(address liquidityPool_) external onlyOwner {\\n        liquidityPool = liquidityPool_;\\n        emit LogLiquidityAddress(liquidityPool_);\\n    }\\n\\n    function setRewardContract(IRUSDRewards _rusdRewardContract)\\n        public\\n        onlyOwner\\n    {\\n        rusdRewardContract = _rusdRewardContract;\\n    }\\n\\n    function setDeveloperPercent(uint256 sellPercent_, uint256 buyPercent_)\\n        external\\n        onlyOwner\\n    {\\n        sellDeveloperPercent = sellPercent_;\\n        buyDeveloperPercent = buyPercent_;\\n        emit LogDeveloperFee(sellPercent_, buyPercent_);\\n    }\\n\\n    function setLiquiditypercent(\\n        uint256 sellLiquidityFee_,\\n        uint256 buyLiquidityFee_\\n    ) external onlyOwner {\\n        buyLiquidityFee = buyLiquidityFee_;\\n        sellLiquidityFee = sellLiquidityFee_;\\n        emit LogLiquidityFee(sellLiquidityFee_, buyLiquidityFee_);\\n    }\\n\\n    function setReflectoPoolAddress(address poolAddress_) external onlyOwner {\\n        poolAddress = poolAddress_;\\n    }\\n\\n    function setSellLimit(uint256 sellLimit_) external onlyOwner {\\n        sellLimit = sellLimit_;\\n    }\\n\\n    function setReflectoContractAddress(address reflectoAdd_)\\n        external\\n        onlyOwner\\n    {\\n        reflectoAdd = reflectoAdd_;\\n    }\\n\\n    function setCustomFees(\\n        address holder_,\\n        uint256 devSellFee_,\\n        uint256 devBuyFee_,\\n        uint256 rewardPoolSellFee_,\\n        uint256 rewardPoolBuyFee_,\\n        uint256 reflectoBBSellFee_,\\n        uint256 reflectoBBBuyFee_,\\n        uint256 liquiditySellFee_,\\n        uint256 liquidityBuyFee_,\\n        bool isCustomFee_\\n    ) external onlyOwner {\\n        usersFees[holder_].devSellFee = devSellFee_;\\n        usersFees[holder_].devBuyFee = devBuyFee_;\\n        usersFees[holder_].rewardPoolSellFee = rewardPoolSellFee_;\\n        usersFees[holder_].rewardPoolBuyFee = rewardPoolBuyFee_;\\n        usersFees[holder_].reflectoBBSellFee = reflectoBBSellFee_;\\n        usersFees[holder_].reflectoBBBuyFee = reflectoBBBuyFee_;\\n        usersFees[holder_].liquiditySellFee = liquiditySellFee_;\\n        usersFees[holder_].liquidityBuyFee = liquidityBuyFee_;\\n        isCustomFee[holder_] = isCustomFee_;\\n    }\\n\\n    function setBuySellFee(\\n        uint256 buyBackPool_,\\n        uint256 buyBackContract_,\\n        uint256 sellBackPool_,\\n        uint256 sellBackContract_\\n    ) external onlyOwner {\\n        buyBackPool = buyBackPool_;\\n        buyBackContract = buyBackContract_;\\n        sellBackPool = sellBackPool_;\\n        sellBackContract = sellBackContract_;\\n    }\\n\\n    function addProviderPair(IProviderPair _providerPair) external onlyOwner {\\n        require(providerPairs.length <= 30, \\\"cannot add more than 30\\\");\\n        providerPairs.push(_providerPair);\\n    }\\n\\n    function rebase(uint256 epoch, int256 supplyDelta)\\n        external\\n        onlyMonetaryPolicy\\n        returns (uint256)\\n    {\\n        if (supplyDelta == 0) {\\n            emit LogRebase(epoch, _totalSupply);\\n            return _totalSupply;\\n        }\\n\\n        if (supplyDelta < 0) {\\n            // reduce the supply\\n            _totalSupply = _totalSupply.sub(uint256(supplyDelta.abs()));\\n        } else {\\n            // add to the supply\\n            _totalSupply = _totalSupply.add(uint256(supplyDelta));\\n        }\\n\\n        if (_totalSupply > MAX_SUPPLY) {\\n            _totalSupply = MAX_SUPPLY;\\n        }\\n\\n        _fracsPerRUSD = TOTAL_FRAC.div(_totalSupply);\\n        // The applied supplyDelta can deviate from the requested supplyDelta,\\n        // but this deviation is guaranteed to be < (_totalSupply^2)/(TOTAL_FRAC - _totalSupply).\\n        //\\n        // In the case of _totalSupply <= MAX_UINT128 (our current supply cap), this\\n        // deviation is guaranteed to be < 1, so we can omit this step. If the supply cap is\\n        // ever increased, it must be re-included.\\n        // _totalSupply = TOTAL_FRAC.div(_fracsPerRUSD)\\n        rusdRewardContract._updateRewardsPerToken();\\n        emit LogRebase(epoch, _totalSupply);\\n        return _totalSupply;\\n    }\\n\\n    function initialize(address owner_, IRUSDRewards _rusdRewardContract)\\n        public\\n        initializer\\n    {\\n        rusdRewardContract = _rusdRewardContract;\\n        ERC20Detailed.initialize(\\\"REFLECTO USD\\\", \\\"RUSD\\\", uint8(DECIMALS));\\n        Ownable.initialize(owner_);\\n\\n        sellLimit = 200000000000;\\n\\n        sellDeveloperPercent = 10; //0.1%\\n        buyDeveloperPercent = 10; //0.1%\\n        sellLiquidityFee = 300; //3%\\n        buyLiquidityFee = 300; //3%\\n        buyBackPool = 25; //0.25%   RUSD will be converted to Reflecto and goes into the pool\\n        buyBackContract = 25; //0.25%   RUSD is converted into BNB and BNB is stored in Reflecto contract\\n        sellBackPool = 25; //0.25%\\n        sellBackContract = 25; //0.25%\\n\\n        _totalSupply = INITIAL_FRACTIONS_SUPPLY; // 50m\\n        _fracBalances[owner_] = TOTAL_FRAC; // 50m\\n        _fracsPerRUSD = TOTAL_FRAC.div(_totalSupply); // how many fracs make up 1 Fraction\\n        emit Transfer(address(0x0), owner_, _totalSupply);\\n    }\\n\\n    /**\\n     * @return The total number of Fractions.\\n     */\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @param who The address to query.\\n     * @return The balance of the specified address.\\n     */\\n    function balanceOf(address who) external view override returns (uint256) {\\n        return _fracBalances[who].div(_fracsPerRUSD);\\n    }\\n\\n    /**\\n     * @param who The address to query.\\n     * @return The fracs balance of the specified address.\\n     */\\n    function scaledBalanceOf(address who) external view returns (uint256) {\\n        return _fracBalances[who];\\n    }\\n\\n    /**\\n     * @return the total number of fracs.\\n     */\\n    function scaledTotalSupply() external pure returns (uint256) {\\n        return TOTAL_FRAC;\\n    }\\n\\n    function getChainID() external view returns (uint256) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n\\n    /**\\n     * @return The computed DOMAIN_SEPARATOR to be used off-chain services\\n     *         which implement EIP-712.\\n     *         https://eips.ethereum.org/EIPS/eip-2612\\n     **/\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return\\n            keccak256(\\n                abi.encode(\\n                    EIP712_DOMAIN,\\n                    keccak256(bytes(name())),\\n                    keccak256(bytes(EIP712_REVISION)),\\n                    chainId,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function mint(address _to, uint256 _value) external onlyMonetaryPolicy {\\n        uint256 fracValue = _value.mul(_fracsPerRUSD);\\n        _fracBalances[_to] = _fracBalances[_to].add(fracValue);\\n        _totalSupply = _totalSupply.add(_value);\\n    }\\n\\n    function burn(address _to, uint256 _value) external onlyMonetaryPolicy {\\n        uint256 fracValue = _value.mul(_fracsPerRUSD);\\n        require(\\n            _fracBalances[_to] >= fracValue,\\n            \\\"Value must be less then balance\\\"\\n        );\\n        _fracBalances[_to] = _fracBalances[_to].sub(fracValue);\\n        _totalSupply = _totalSupply.sub(_value);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 value,\\n        Fees memory usersFees\\n    ) internal virtual {\\n        uint256 fracValue = value.mul(_fracsPerRUSD);\\n        _fracBalances[sender] = _fracBalances[sender].sub(fracValue);\\n        uint256 fracDeveloper;\\n        uint256 fracLiquidity;\\n        uint256 fracTo;\\n        uint256 poolFee;\\n        uint256 contractFee;\\n\\n        if (block.timestamp > timeOfSell[sender] + 1 days) {\\n            amountOfSell[sender] = 0;\\n        }\\n\\n        if (providerPairs.length > 0) {\\n            for (uint8 i = 0; i < providerPairs.length; i++) {\\n                if (recipient == address(providerPairs[i])) {\\n                    require(\\n                        value + amountOfSell[sender] <= sellLimit,\\n                        \\\"One day needs to pass to be able to sell again\\\"\\n                    );\\n                    poolFee = (fracValue.mul(usersFees.rewardPoolSellFee)).div(\\n                        10000\\n                    );\\n                    contractFee = (fracValue.mul(usersFees.reflectoBBSellFee))\\n                        .div(10000);\\n                    _fracBalances[poolAddress] = _fracBalances[poolAddress].add(\\n                        poolFee\\n                    );\\n                    _fracBalances[reflectoAdd] = _fracBalances[reflectoAdd].add(\\n                        contractFee\\n                    );\\n                    fracDeveloper = (fracValue.mul(usersFees.devSellFee)).div(\\n                        10000\\n                    );\\n                    fracLiquidity = (fracValue.mul(usersFees.liquiditySellFee))\\n                        .div(10000);\\n                    fracTo = fracValue.sub(\\n                        fracDeveloper.add(fracLiquidity).add(poolFee).add(\\n                            contractFee\\n                        )\\n                    );\\n                    timeOfSell[sender] = block.timestamp;\\n                    amountOfSell[sender] = amountOfSell[sender] + value;\\n                } else if (sender == address(providerPairs[i])) {\\n                    poolFee = (fracValue.mul(usersFees.rewardPoolBuyFee)).div(\\n                        10000\\n                    );\\n                    contractFee = (fracValue.mul(usersFees.reflectoBBBuyFee))\\n                        .div(10000);\\n                    _fracBalances[poolAddress] = _fracBalances[poolAddress].add(\\n                        poolFee\\n                    );\\n                    _fracBalances[reflectoAdd] = _fracBalances[reflectoAdd].add(\\n                        contractFee\\n                    );\\n                    fracDeveloper = (fracValue.mul(usersFees.devBuyFee)).div(\\n                        10000\\n                    );\\n                    fracLiquidity = (fracValue.mul(usersFees.liquidityBuyFee))\\n                        .div(10000);\\n                    fracTo = fracValue.sub(\\n                        fracDeveloper.add(fracLiquidity).add(poolFee).add(\\n                            contractFee\\n                        )\\n                    );\\n                } else {\\n                    fracDeveloper = (fracValue.mul(usersFees.devBuyFee)).div(\\n                        10000\\n                    );\\n                    fracLiquidity = (fracValue.mul(usersFees.liquidityBuyFee))\\n                        .div(10000);\\n                    fracTo = fracValue.sub(fracDeveloper.add(fracLiquidity));\\n                }\\n            }\\n        } else {\\n            fracDeveloper = (fracValue.mul(usersFees.devBuyFee)).div(10000);\\n            fracLiquidity = (fracValue.mul(usersFees.liquidityBuyFee)).div(\\n                10000\\n            );\\n            fracTo = fracValue.sub(fracDeveloper.add(fracLiquidity));\\n        }\\n        _fracBalances[developer] = _fracBalances[developer].add(fracDeveloper);\\n        _fracBalances[liquidityPool] = _fracBalances[liquidityPool].add(\\n            fracLiquidity\\n        );\\n        _fracBalances[recipient] = _fracBalances[recipient].add(fracTo);\\n\\n        rusdRewardContract._updateRewardsPerToken();\\n        rusdRewardContract._updateUserRewards(sender);\\n        rusdRewardContract._updateUserRewards(recipient);\\n\\n        emit Transfer(sender, recipient, fracTo.div(_fracsPerRUSD));\\n        emit Transfer(sender, developer, fracDeveloper.div(_fracsPerRUSD));\\n        emit Transfer(sender, liquidityPool, fracLiquidity.div(_fracsPerRUSD));\\n        emit Transfer(sender, poolAddress, poolFee.div(_fracsPerRUSD));\\n        emit Transfer(sender, reflectoAdd, contractFee.div(_fracsPerRUSD));\\n    }\\n\\n    function _normalTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) internal virtual {\\n        uint256 fracValue = _value.mul(_fracsPerRUSD);\\n\\n        _fracBalances[_from] = _fracBalances[_from].sub(fracValue);\\n        _fracBalances[_to] = _fracBalances[_to].add(fracValue);\\n\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n     * @dev Transfer tokens to a specified address.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     * @return True on success, false otherwise.\\n     */\\n    function transfer(address to, uint256 value)\\n        external\\n        override\\n        validRecipient(to)\\n        returns (bool)\\n    {\\n        if (isExcludedFromAllFees[msg.sender] || isExcludedFromAllFees[to]) {\\n            _normalTransfer(msg.sender, to, value);\\n        } else {\\n            if (isCustomFee[msg.sender]) {\\n                _transfer(msg.sender, to, value, usersFees[msg.sender]);\\n            } else if (isCustomFee[to]) {\\n                _transfer(msg.sender, to, value, usersFees[to]);\\n            } else {\\n                Fees memory uFees = Fees(\\n                    sellDeveloperPercent,\\n                    buyDeveloperPercent,\\n                    sellBackPool,\\n                    buyBackPool,\\n                    sellBackContract,\\n                    buyBackContract,\\n                    sellLiquidityFee,\\n                    buyLiquidityFee\\n                );\\n                _transfer(msg.sender, to, value, uFees);\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function removeProvider(IProviderPair _providerPair) external onlyOwner{\\n        bool flag=false;\\n        for(uint8 i=0;i < providerPairs.length; i++){\\n            if(providerPairs[i]== _providerPair){\\n                providerPairs[i]= providerPairs[providerPairs.length-1];\\n                providerPairs.pop();\\n                flag = false;\\n                break;\\n            }else{\\n                flag = true;\\n         }\\n        }\\n        if(flag==true){\\n            revert();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\\n     * @param owner_ The address which owns the funds.\\n     * @param spender The address which will spend the funds.\\n     * @return The number of tokens still available for the spender.\\n     */\\n    function allowance(address owner_, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowedFractions[owner_][spender];\\n    }\\n\\n    /**x\\n     * @dev Transfer tokens from one address to another.\\n     * @param from The address you want to send tokens from.\\n     * @param to The address you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override validRecipient(to) returns (bool) {\\n        if (isExcludedFromAllFees[from] || isExcludedFromAllFees[to]) {\\n            _normalTransfer(from, to, value);\\n        } else {\\n            if (isCustomFee[from]) {\\n                _transfer(from, to, value, usersFees[from]);\\n            } else if (isCustomFee[to]) {\\n                _transfer(from, to, value, usersFees[to]);\\n            } else {\\n                Fees memory uFees = Fees(\\n                    sellDeveloperPercent,\\n                    buyDeveloperPercent,\\n                    sellBackPool,\\n                    buyBackPool,\\n                    sellBackContract,\\n                    buyBackContract,\\n                    sellLiquidityFee,\\n                    buyLiquidityFee\\n                );\\n                _transfer(from, to, value, uFees);\\n            }\\n        }\\n        _allowedFractions[from][msg.sender] = _allowedFractions[from][\\n            msg.sender\\n        ].sub(value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\\n     * msg.sender. This method is included for ERC20 compatibility.\\n     * increaseAllowance and decreaseAllowance should be used instead.\\n     * Changing an allowance with this method brings the risk that someone may transfer both\\n     * the old and the new allowance - if they are both greater than zero - if a transfer\\n     * transaction is mined before the later approve() call is mined.\\n     *\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _allowedFractions[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\\n     * This method should be used instead of approve() to avoid the double approval vulnerability\\n     * described above.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        returns (bool)\\n    {\\n        _allowedFractions[msg.sender][spender] = _allowedFractions[msg.sender][\\n            spender\\n        ].add(addedValue);\\n\\n        emit Approval(\\n            msg.sender,\\n            spender,\\n            _allowedFractions[msg.sender][spender]\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\\n     *\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        external\\n        returns (bool)\\n    {\\n        uint256 oldValue = _allowedFractions[msg.sender][spender];\\n        _allowedFractions[msg.sender][spender] = (subtractedValue >= oldValue)\\n            ? 0\\n            : oldValue.sub(subtractedValue);\\n\\n        emit Approval(\\n            msg.sender,\\n            spender,\\n            _allowedFractions[msg.sender][spender]\\n        );\\n        return true;\\n    }\\n\\n    // --- Approve by signature ---\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR(),\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH_META,\\n                        holder,\\n                        spender,\\n                        nonce,\\n                        expiry,\\n                        allowed\\n                    )\\n                )\\n            )\\n        );\\n\\n        require(holder != address(0), \\\"Reflecto/invalid-address-0\\\");\\n        require(\\n            holder == ecrecover(digest, v, r, s),\\n            \\\"Reflecto/invalid-permit\\\"\\n        );\\n        require(\\n            expiry == 0 || block.timestamp <= expiry,\\n            \\\"Reflecto/permit-expired\\\"\\n        );\\n        require(nonce == nonces[holder]++, \\\"Reflecto/invalid-nonce\\\");\\n        uint256 wad = allowed ? _totalSupply : 0;\\n\\n        _allowedFractions[holder][spender] = wad;\\n        emit Approval(holder, spender, wad);\\n    }\\n\\n    function convertTokenToBuyBack(address wbnb, address token, address routerAddress) external onlyOwner {\\n        address[] memory bnbPath = new address[](2);\\n        bnbPath[0] = token;\\n        bnbPath[1] = wbnb;\\n        uint256 amountIn = IERC20(token).balanceOf(address(this));\\n\\n        uint256 deadline = block.timestamp + 1000;\\n        IERC20(token).approve(routerAddress, amountIn);\\n        \\n        IRouter(routerAddress).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountIn,\\n            0,\\n            bnbPath,\\n            reflectoAdd,\\n            deadline\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RUSD-additional/CastU256U128.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\nlibrary CastU256U128 {\\n    /// @dev Safely cast an uint256 to an uint128\\n    function u128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max, \\\"Cast overflow\\\");\\n        y = uint128(x);\\n    }\\n}\"\r\n    },\r\n    \"contracts/RUSD-additional/CastU256U32.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\nlibrary CastU256U32 {\\n    /// @dev Safely cast an uint256 to an u32\\n    function u32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max, \\\"Cast overflow\\\");\\n        y = uint32(x);\\n    }\\n}\"\r\n    },\r\n    \"contracts/RUSD-additional/SafeMathInt.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n/**\\n * @title SafeMathInt\\n * @dev Math operations for int256 with overflow safety checks.\\n */\\nlibrary SafeMathInt {\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\n\\n    /**\\n     * @dev Multiplies two int256 variables and fails on overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a * b;\\n\\n        // Detect overflow when multiplying MIN_INT256 with -1\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\n        require((b == 0) || (c / b == a));\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Division of two int256 variables and fails on overflow.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        // Prevent overflow when dividing MIN_INT256 by -1\\n        require(b != -1 || a != MIN_INT256);\\n\\n        // Solidity already throws when dividing by 0.\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Subtracts two int256 variables and fails on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two int256 variables and fails on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Converts to absolute value, and fails on overflow.\\n     */\\n    function abs(int256 a) internal pure returns (int256) {\\n        require(a != MIN_INT256);\\n        return a < 0 ? -a : a;\\n    }\\n}\"\r\n    },\r\n    \"contracts/RUSD-additional/SafeMath.sol\": {\r\n      \"content\": \"\\npragma solidity 0.7.6;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two numbers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two numbers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/RUSD-additional/Initializable.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private initializing;\\n\\n    /**\\n     * @dev Modifier to use in the initializer function of a contract.\\n     */\\n    modifier initializer() {\\n        require(\\n            initializing || isConstructor() || !initialized,\\n            \\\"Contract instance has already been initialized\\\"\\n        );\\n\\n        bool wasInitializing = initializing;\\n        initializing = true;\\n        initialized = true;\\n\\n        _;\\n\\n        initializing = wasInitializing;\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n\\n        // MINOR CHANGE HERE:\\n\\n        // previous code\\n        // uint256 cs;\\n        // assembly { cs := extcodesize(address) }\\n        // return cs == 0;\\n\\n        // current code\\n        address _self = address(this);\\n        uint256 cs;\\n        assembly {\\n            cs := extcodesize(_self)\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\\n\"\r\n    },\r\n    \"contracts/RUSD-additional/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\"\r\n    },\r\n    \"contracts/RUSD-additional/Ownable.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable is Initializable {\\n    address private _owner;\\n\\n    event OwnershipRenounced(address indexed previousOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    function initialize(address sender) public virtual initializer {\\n        _owner = sender;\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipRenounced(_owner);\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/RUSD-additional/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\nimport \\\"./Initializable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\nabstract contract ERC20Detailed is Initializable, IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    function initialize(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals\\n    ) public virtual initializer {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @return the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @return the number of decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\"\r\n    },\r\n    \"contracts/RUSD-additional/IProviderPair.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\ninterface IProviderPair {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112,\\n            uint112,\\n            uint32\\n        );\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"developer\",\"type\":\"address\"}],\"name\":\"LogDeveloperAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellDeveloperPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyDeveloperPercent\",\"type\":\"uint256\"}],\"name\":\"LogDeveloperFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidityPool\",\"type\":\"address\"}],\"name\":\"LogLiquidityAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellLiquidityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyLiquidityFee\",\"type\":\"uint256\"}],\"name\":\"LogLiquidityFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"monetaryPolicy\",\"type\":\"address\"}],\"name\":\"LogMonetaryPolicyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_REVISION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH_META\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProviderPair\",\"name\":\"_providerPair\",\"type\":\"address\"}],\"name\":\"addProviderPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountOfSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDeveloperPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wbnb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"name\":\"convertTokenToBuyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"excludeFromAllFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"contract IRUSDRewards\",\"name\":\"_rusdRewardContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCustomFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromAllFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monetaryPolicy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"providerPairs\",\"outputs\":[{\"internalType\":\"contract IProviderPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyDelta\",\"type\":\"int256\"}],\"name\":\"rebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectoAdd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProviderPair\",\"name\":\"_providerPair\",\"type\":\"address\"}],\"name\":\"removeProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rusdRewardContract\",\"outputs\":[{\"internalType\":\"contract IRUSDRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"scaledBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaledTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBackContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBackPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellDeveloperPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyBackPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBackContract_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellBackPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellBackContract_\",\"type\":\"uint256\"}],\"name\":\"setBuySellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"devSellFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devBuyFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoolSellFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoolBuyFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectoBBSellFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectoBBBuyFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySellFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBuyFee_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCustomFee_\",\"type\":\"bool\"}],\"name\":\"setCustomFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"developer_\",\"type\":\"address\"}],\"name\":\"setDeveloperAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellPercent_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPercent_\",\"type\":\"uint256\"}],\"name\":\"setDeveloperPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidityPool_\",\"type\":\"address\"}],\"name\":\"setLiquidityPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellLiquidityFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyLiquidityFee_\",\"type\":\"uint256\"}],\"name\":\"setLiquiditypercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"monetaryPolicy_\",\"type\":\"address\"}],\"name\":\"setMonetaryPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reflectoAdd_\",\"type\":\"address\"}],\"name\":\"setReflectoContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress_\",\"type\":\"address\"}],\"name\":\"setReflectoPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRUSDRewards\",\"name\":\"_rusdRewardContract\",\"type\":\"address\"}],\"name\":\"setRewardContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellLimit_\",\"type\":\"uint256\"}],\"name\":\"setSellLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeOfSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"devSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoolSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoolBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectoBBSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectoBBBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBuyFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RUSDFraction", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}