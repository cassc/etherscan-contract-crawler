{"SourceCode": "/*  \r\n \r\n* SPDX-License-Identifier: None\r\n*/\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface ICCVRF {\r\n    function requestRandomness(uint256 requestID, uint256 howManyNumbers) external payable;\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n   function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\r\n    \r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function getAmountsOut(\r\n            uint256 amountIn,\r\n            address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IDEXPair {\r\n    function sync() external;\r\n}\r\n\r\ncontract PangeaLasVegas is IBEP20, Ownable {\r\n    string constant _name = \"Pangea Las Vegas\";\r\n    string constant _symbol = \"PLV\";\r\n    uint8 constant _decimals = 9;\r\n    uint256 _totalSupply = 1_000_000 * (10**_decimals);\r\n    uint256 circulatingSupplyLimit = 1_000 * (10**_decimals); \r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public addressWithoutLimits;\r\n\r\n    bool public enabled = false;\r\n    \r\n    uint256 public tax = 5;\r\n    uint256 public liq = 1;\r\n    uint256 public marketing = 1;\r\n    uint256 public jackpot = 3;\r\n\r\n    uint256 public jackpotBalance;   \r\n    uint256 public maxJackpotBalanceBeforeDistribute = 25 ether;\r\n    uint256 public minBuy = 0.032 ether;\r\n\r\n    uint256 public launchTime = type(uint256).max;\r\n    \r\n    bool public jackpotWillBeDistributed;\r\n    bool public winnersHaveBeenChosen;\r\n\r\n    bool public payJackpotInToken = true;\r\n    uint256 public totalJackpotPayouts;\r\n\r\n    bool private isSwapping;\r\n    uint256 public swapTokensAtAmount = 0 * (10**_decimals);\r\n    \r\n    ICCVRF public randomnessSupplier = ICCVRF(0xC0de0aB6E25cc34FB26dE4617313ca559f78C0dE);\r\n    mapping (uint256 => bool) public nonceProcessed;\r\n    uint256 public vrfCost = 0.002 ether;\r\n    uint256 public nonce;\r\n\r\n    IDEXRouter public router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address public marketingWallet = 0x45cAeeB1B197Dbf2ce24aF4E46a147E7a5f36098;\r\n\r\n    address public pair;\r\n    address public constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address public constant ZERO = 0x0000000000000000000000000000000000000000;\r\n    \r\n    address[] public allBuysSinceLastJackpot;\r\n    address[] private pathForBuyingJackpot = new address[](2);\r\n    address[] private pathForSelling = new address[](2);\r\n    address[] private pathForBuying = new address[](2);\r\n    address[] private pathFromBNBToBUSD = new address[](2);\r\n\r\n    struct Token {\r\n        IBEP20 contractAddress;\r\n        uint256 percentage;\r\n        bool active;\r\n    }    \r\n    \r\n    mapping(address => bool) public permitedTokens;    \r\n    \r\n    Token[] public tokens;\r\n\r\n    struct Winners{\r\n        uint256 round;\r\n        address winner;\r\n        uint256 prize;\r\n    }\r\n\r\n    Winners[] public winners;\r\n    address[] public winnersOfCurrent;\r\n\r\n    modifier contractSelling() {isSwapping = true; _; isSwapping = false;}\r\n    modifier onlyVRF() {if(msg.sender != address(randomnessSupplier)) return; _;}\r\n\r\n    event Winner(address winner, uint256 tokensWon);\r\n\r\n    constructor() {\r\n        pathForBuyingJackpot[0] = WETH;\r\n\r\n        \r\n        pathForSelling[0] = address(this);\r\n        pathForSelling[1] = WETH;\r\n        \r\n        pathForBuying[0] = WETH;\r\n        pathForBuying[1] = address(this);\r\n\r\n        pathFromBNBToBUSD[0] = WETH;\r\n        pathFromBNBToBUSD[1] = BUSD;\r\n        \r\n        pair = IDEXFactory(IDEXRouter(router).factory()).createPair(WETH, address(this));\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n        addressWithoutLimits[msg.sender] = true;\r\n        addressWithoutLimits[address(this)] = true;     \r\n\r\n        tokens.push(Token({contractAddress: IBEP20(0x68F483B06F1E96B10239e333b598f145Da8571c2), percentage: 50, active: true}));\r\n        tokens.push(Token({contractAddress: IBEP20(0xFACE67C5CE2bb48c29779b0Dede5360cC9ef5fd5), percentage: 50, active: true}));\r\n        permitedTokens[0x68F483B06F1E96B10239e333b598f145Da8571c2] = true;\r\n        permitedTokens[0xFACE67C5CE2bb48c29779b0Dede5360cC9ef5fd5] = true;        \r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n    function name() public pure override returns (string memory) {return _name;}\r\n    function totalSupply() public view override returns (uint256) {return _totalSupply;}\r\n    function decimals() public pure override returns (uint8) {return _decimals;}\r\n    function symbol() public pure override returns (string memory) {return _symbol;}\r\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\r\n    function allowance(address holder, address spender) public view override returns (uint256) {return _allowances[holder][spender];}\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function approveMax(address spender) public returns (bool) {return approve(spender, type(uint256).max);}\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {return _transferFrom(msg.sender, recipient, amount);}\r\n    function circulatingSupply() public view returns(uint256) {return _totalSupply - _balances[DEAD] - _balances[ZERO];}\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            require(_allowances[sender][msg.sender] >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n        }\r\n        \r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function conditionsToSwapAreMet(address sender) internal view returns (bool) {\r\n        return sender != pair && _balances[address(this)] > swapTokensAtAmount;\r\n    }\r\n    \r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if(addressWithoutLimits[sender]|| addressWithoutLimits[recipient]) return _basicTransfer(sender, recipient, amount);\r\n        \r\n        if(isSwapping == true) return _lowGasTransfer(sender, recipient, amount);\r\n        \r\n        require(enabled, \"Trading not live yet\");\r\n   \r\n        if(winnersHaveBeenChosen && jackpotWillBeDistributed) distributeJackpot();\r\n        \r\n        if(sender == pair && bigEnoughBuy(amount)){\r\n            allBuysSinceLastJackpot.push(recipient);\r\n        }\r\n\r\n        // if we have enough tokens, let's sell them for jackpot, marketing and liquidity\r\n        if (conditionsToSwapAreMet(sender)) letTheContractSell();\r\n       \r\n       \r\n        \r\n        // calculate effective amount that get's transferred\r\n        uint256 finalamount = takeTax(sender, recipient, amount);\r\n            \r\n             \r\n\r\n        // do the transfer\r\n        return _basicTransfer(sender, recipient, finalamount);\r\n    }\r\n\r\n    function takeTax(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        // tax free for wallet to wallet\r\n        if(sender != pair && recipient != pair) return amount;\r\n\r\n        \r\n        uint256 taxAmount = amount * tax / 100;\r\n\r\n\r\n        if (taxAmount > 0) _lowGasTransfer(sender, address(this), taxAmount);\r\n        return amount - taxAmount;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if(recipient == DEAD && circulatingSupply() - amount < circulatingSupplyLimit) amount = circulatingSupply() - circulatingSupplyLimit;\r\n        \r\n        return _lowGasTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _lowGasTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function letTheContractSell() internal {\r\n        uint256 tokensThatTheContractWillSell = _balances[address(this)] * (tax - liq) / tax;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokensThatTheContractWillSell,\r\n            0,\r\n            pathForSelling,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        // adding tokens to liquidity pool\r\n        if(_balances[address(this)] > 0){\r\n            _lowGasTransfer(address(this), pair, _balances[address(this)]);\r\n            IDEXPair(pair).sync();\r\n        }\r\n       \r\n        // dividing the BNB between marketing and jackpot\r\n        uint256 contractBalanceWithoutJackpot = address(this).balance - jackpotBalance;\r\n        payable(marketingWallet).transfer(contractBalanceWithoutJackpot * marketing / tax);\r\n        jackpotBalance += contractBalanceWithoutJackpot * jackpot / tax;\r\n\r\n        if(jackpotBalanceInBUSD() > maxJackpotBalanceBeforeDistribute) drawWinnersOfJackpotDistribution();\r\n    }\r\n\r\n    function bigEnoughBuy(uint256 amount) public view returns (bool) {\r\n        if (minBuy == 0) return true;\r\n        uint256 tokensOut = router.getAmountsOut(minBuy, pathForBuying)[1] * 9975 / 10000; \r\n        return amount >= tokensOut;\r\n    }\r\n\r\n    function jackpotBalanceInBUSD() public view returns (uint256) {\r\n        if(jackpotBalance == 0) return 0;\r\n        return router.getAmountsOut(jackpotBalance, pathFromBNBToBUSD)[1];\r\n    }\r\n\r\n    function getTokens() public view returns(Token[] memory) {\r\n        return tokens;\r\n    }\r\n\r\n    function getPayoutTokens() public view returns (Token[] memory) {\r\n        uint length = getTokens().length;\r\n        Token[] memory result = new Token[](length);\r\n        for (uint256 index; index < length; index++) {\r\n                result[index] = Token({\r\n                        contractAddress: IBEP20(getTokens()[index].contractAddress), \r\n                        percentage: getTokens()[index].percentage, \r\n                        active: getTokens()[index].active\r\n                });\r\n         }\r\n         return result;\r\n    }\r\n\r\n\r\n/////////////////// ADMIN FUNCTIONS ///////////////////////////////////////////////////////////////////////\r\n    function launch() external onlyOwner {\r\n        require(enabled == false, \"Already Live\");\r\n        enabled = !enabled;\r\n        launchTime = block.timestamp;\r\n    }\r\n\r\n    function updatePayJackpotInToken(bool value) external onlyOwner {\r\n        payJackpotInToken = value;\r\n    }\r\n    \r\n    function setMinBuy(uint256 amount) external onlyOwner {\r\n        minBuy = amount;\r\n    }\r\n    \r\n    function setPermitedToken(address _tokenAddress, bool _active) external onlyOwner { \r\n        permitedTokens[_tokenAddress] = _active;\r\n    }    \r\n    \r\n    function addtokenOptions(address[] memory _contractAddress, uint[] memory _percentage, bool[] memory _active) public onlyOwner {\r\n         uint totalPercentage; \r\n         uint counter = tokens.length; \r\n         \r\n\r\n         for(uint256 i = 0; i < _contractAddress.length; i++) {\r\n                 tokens.push(Token({\r\n                     contractAddress: IBEP20(_contractAddress[i]),\r\n                     percentage: _percentage[i],\r\n                     active: _active[i]\r\n                 }));\r\n         }\r\n         if(counter > 0) {\r\n             for(uint256 i = 0; i < counter; i++ ){\r\n                totalPercentage = totalPercentage + tokens[i].percentage;\r\n                if(totalPercentage > 100) revert();\r\n             }\r\n         }\r\n    }\r\n\r\n    function updateRewardTokenState(uint index, bool _active, uint256 _percentage) public  onlyOwner {\r\n            require(_percentage < 100, \"Percentage cannot be grater then 100\");\r\n            require(tokens.length > index, \"Token: Out of bounds\");\r\n            uint totalPercentage = 0; \r\n            uint counter = tokens.length; \r\n            if(counter > 0) {\r\n                for(uint256 i = 0; i< counter; i++ ){\r\n                    totalPercentage = totalPercentage + tokens[i].percentage;\r\n                    if(totalPercentage + _percentage > 100) revert();\r\n                }\r\n            }\r\n            tokens[index].active = _active;\r\n            tokens[index].percentage = _percentage;\r\n    }\r\n\r\n    function removeTokenOptions(uint index) public onlyOwner  {\r\n            require(tokens.length > index, \"BEP20: Out of bounds\");\r\n            for (uint256 i = index; i < tokens.length - 1; i++) {\r\n                tokens[i] = tokens[i+1];\r\n            }\r\n            tokens.pop();\r\n    }    \r\n    \r\n    function makeContractSell() external onlyOwner {\r\n        letTheContractSell();\r\n    }\r\n\r\n    function addBNBToJackpotManually() external payable {\r\n        if (msg.value > 0) jackpotBalance += msg.value;\r\n    }\r\n\r\n    function airdropToWallets(address[] memory airdropWallets, uint256[] memory amount) external onlyOwner {\r\n        for (uint256 i = 0; i < airdropWallets.length; i++) {\r\n            _basicTransfer(msg.sender, airdropWallets[i], amount[i] * (10**_decimals));\r\n        }\r\n    }\r\n\r\n    function setJackpotSettings(\r\n\r\n        uint256 _maxJackpotBalanceBeforeDistribute\r\n    ) external onlyOwner {\r\n        maxJackpotBalanceBeforeDistribute = _maxJackpotBalanceBeforeDistribute * 1 ether;\r\n\r\n    }\r\n\r\n    function setContractSells(uint256 minAmountOfTokensToSell) external onlyOwner{\r\n        swapTokensAtAmount = minAmountOfTokensToSell * (10 ** _decimals);\r\n    }\r\n\r\n    function setWallets(address marketingAddress) external onlyOwner {\r\n        marketingWallet = marketingAddress;\r\n    }\r\n\r\n    function setTax(uint256 newLiq, uint256 newMarketing, uint256 newJackpot) external onlyOwner {\r\n        liq = newLiq;\r\n        marketing = newMarketing;\r\n        jackpot = newJackpot;\r\n        tax = liq + marketing + jackpot;\r\n        require(tax <= 6, \"Tax limited to max 6%\");\r\n    }\r\n\r\n    function setAddressWithoutLimits(address unlimitedAddress, bool status) external onlyOwner {\r\n        addressWithoutLimits[unlimitedAddress] = status;\r\n    }\r\n\r\n    function rescueAnyToken(address token) external onlyOwner {\r\n        require(token != address(this), \"Can't rescue Pangea\");\r\n        IBEP20(token).transfer(msg.sender, IBEP20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function drawWinnersOfJackpotDistribution() internal {\r\n        jackpotWillBeDistributed = true;\r\n        randomnessSupplier.requestRandomness{value: vrfCost}(nonce, 1);\r\n        jackpotBalance -= vrfCost;\r\n    }\r\n\r\n    function supplyRandomness(uint256 _nonce, uint256[] memory randomNumbers) external onlyVRF {\r\n        if(nonceProcessed[_nonce]) {\r\n            if(winnersOfCurrent[0] == address(0)) winnersOfCurrent[0] = allBuysSinceLastJackpot[(randomNumbers[0] % allBuysSinceLastJackpot.length)];\r\n        } else{\r\n            nonceProcessed[_nonce] = true;\r\n            winnersOfCurrent.push(allBuysSinceLastJackpot[(randomNumbers[0] % allBuysSinceLastJackpot.length)]);\r\n        }\r\n\r\n        if(!bigEnoughBuy(_balances[winnersOfCurrent[0]])) winnersOfCurrent[0] = address(0);\r\n        \r\n        if(winnersOfCurrent[0] == address(0)) {\r\n            randomnessSupplier.requestRandomness{value: vrfCost}(_nonce, 1);\r\n            jackpotBalance -= vrfCost;\r\n        } else {\r\n            winnersHaveBeenChosen = true;\r\n            delete allBuysSinceLastJackpot;\r\n        }\r\n    }\r\n\r\n    function distributeJackpot() internal {\r\n        uint256 carryOver = jackpotBalance / 100;\r\n        jackpotBalance = jackpotBalance - carryOver;\r\n\r\n        if(!payJackpotInToken) {\r\n            payable(winnersOfCurrent[0]).transfer(jackpotBalance);\r\n            jackpotBalance = 0;\r\n            jackpotWillBeDistributed = false;\r\n            winnersHaveBeenChosen = false;\r\n        } else {\r\n            buyBacks();\r\n            totalJackpotPayouts++;\r\n        }\r\n        delete winnersOfCurrent;\r\n        jackpotBalance = carryOver;\r\n        jackpotWillBeDistributed = false;\r\n        winnersHaveBeenChosen = false;\r\n        nonce++;\r\n    }\r\n\r\n    function buyBacks() internal {\r\n             address[] memory path = new address[](2);\r\n             uint deadline = block.timestamp;\r\n             for(uint256 i = 0; i < tokens.length; i++) {\r\n                  path[0] = WETH;\r\n                  path[1] = address(tokens[i].contractAddress);\r\n                  uint buyAmount = jackpotBalance * tokens[i].percentage / 100;\r\n                  if(tokens[i].active == true)  try router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: buyAmount}(0, path, winnersOfCurrent[0], deadline) { continue; } catch { revert(); }\r\n            }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensWon\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addBNBToJackpotManually\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressWithoutLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contractAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percentage\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_active\",\"type\":\"bool[]\"}],\"name\":\"addtokenOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"airdropWallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"airdropToWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBuysSinceLastJackpot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bigEnoughBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPayoutTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IBEP20\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct PangeaLasVegas.Token[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IBEP20\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct PangeaLasVegas.Token[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBalanceInBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotWillBeDistributed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeContractSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxJackpotBalanceBeforeDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payJackpotInToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permitedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomnessSupplier\",\"outputs\":[{\"internalType\":\"contract ICCVRF\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeTokenOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueAnyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unlimitedAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAddressWithoutLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmountOfTokensToSell\",\"type\":\"uint256\"}],\"name\":\"setContractSells\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxJackpotBalanceBeforeDistribute\",\"type\":\"uint256\"}],\"name\":\"setJackpotSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setPermitedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMarketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newJackpot\",\"type\":\"uint256\"}],\"name\":\"setTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketingAddress\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomNumbers\",\"type\":\"uint256[]\"}],\"name\":\"supplyRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalJackpotPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"updatePayJackpotInToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"updateRewardTokenState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrfCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winnersHaveBeenChosen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winnersOfCurrent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PangeaLasVegas", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7314c04390e2ad7a434d68f01416fb60d972df7e0e3cac0da6bc0e8292c2349d"}