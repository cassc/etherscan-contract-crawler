{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GoldGrinder.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\ncontract GoldGrinder is Ownable {\\n\\n    uint256 public constant GOLD_TO_HIRE_1MINER = 100 *1 days /9;//960k golds to hire 1 miner, 9%apr daily\\n    uint256 private constant PSN = 10000;\\n    uint256 private PSNH = 5000;\\n    uint256 private constant devFeeVal = 2;\\n    bool private _initialized;\\n    mapping (address => uint256) public goldMiners;\\n    mapping (address => uint256) private claimedGold;\\n    mapping (address => uint256) private lastHireTime;\\n    mapping (address => address) private referrals;\\n    uint256 private marketGold = 100000*GOLD_TO_HIRE_1MINER;\\n\\n    mapping (address => bool) private hasParticipated;\\n    uint256 public uniqueUsers;\\n\\n    modifier initialized {\\n      require(_initialized, \\\"Contract not initialized\\\");\\n      _;\\n   }\\n    \\n    function hireMiner(address ref) public initialized {\\n        \\n        if(ref != msg.sender && referrals[msg.sender] == address(0) && ref!= address(0)) {\\n            referrals[msg.sender] = ref;\\n        }\\n        \\n        uint256 goldUsed = getMyGold(msg.sender);\\n        uint256 myGoldRewards = getGoldSincelastHireTime(msg.sender);\\n        claimedGold[msg.sender] += myGoldRewards;\\n\\n        uint256 newMiners = claimedGold[msg.sender]/GOLD_TO_HIRE_1MINER;\\n        \\n        claimedGold[msg.sender] -=(GOLD_TO_HIRE_1MINER * newMiners);\\n        goldMiners[msg.sender] += newMiners;\\n        \\n        lastHireTime[msg.sender] = block.timestamp;\\n        \\n        //send referral gold\\n        claimedGold[referrals[msg.sender]] += goldUsed/8;\\n        \\n        //boost market to nerf miners hoarding\\n        marketGold += goldUsed/5;\\n\\n        if(!hasParticipated[msg.sender]) {\\n            hasParticipated[msg.sender] = true;\\n            uniqueUsers++;\\n        }\\n        if(!hasParticipated[ref] && ref!= address(0)) {\\n            hasParticipated[ref] = true;\\n            uniqueUsers++;\\n        }\\n    }\\n    \\n    function sellGold() public initialized{\\n        uint256 hasGold = getMyGold(msg.sender);\\n        uint256 goldValue = calculateGoldSell(hasGold);\\n        uint256 fee = devFee(goldValue);\\n        claimedGold[msg.sender] = 0;\\n        lastHireTime[msg.sender] = block.timestamp;\\n        marketGold += hasGold;\\n        payable(owner()).transfer(fee);\\n        payable (msg.sender).transfer(goldValue-fee);\\n        if(goldMiners[msg.sender] == 0) uniqueUsers--;\\n    }\\n    \\n    function buyGold(address ref) external payable initialized {\\n        _buyGold(ref,msg.value);\\n    }\\n\\n    //to prevent sniping\\n    function seedMarket() public payable onlyOwner  {\\n        require(!_initialized, \\\"Already initialized\\\");\\n        _initialized = true;\\n        _buyGold(0x0000000000000000000000000000000000000000,msg.value);\\n    }\\n    \\n    function _buyGold(address ref, uint256 amount) private\\n    {\\n        uint256 goldBought = calculateGoldBuy(amount,address(this).balance-amount);\\n        goldBought -= devFee(goldBought);\\n        uint256 fee = devFee(amount);\\n        payable(owner()).transfer(fee);\\n        claimedGold[msg.sender] += goldBought;\\n\\n        hireMiner(ref);\\n    }\\n    function goldRewardsToBNB(address adr) external view returns(uint256) {\\n        uint256 hasGold = getMyGold(adr);\\n        uint256 goldValue;\\n        try  this.calculateGoldSell(hasGold) returns (uint256 value) {goldValue=value;} catch{}\\n        return goldValue;\\n    }\\n\\n    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) private view returns(uint256) {\\n        return (PSN*bs)/(PSNH+(PSN*rs+PSNH*rt)/rt);\\n    }\\n    \\n    function calculateGoldSell(uint256 gold) public view returns(uint256) {\\n        return calculateTrade(gold,marketGold,address(this).balance);\\n    }\\n    \\n    function calculateGoldBuy(uint256 eth,uint256 contractBalance) public view returns(uint256) {\\n        return calculateTrade(eth,contractBalance,marketGold);\\n    }\\n    \\n    function calculateGoldBuySimple(uint256 eth) external view returns(uint256) {\\n        return calculateGoldBuy(eth,address(this).balance);\\n    }\\n    \\n    function devFee(uint256 amount) private pure returns(uint256) {\\n        return amount*devFeeVal/100;\\n    }\\n    \\n    function getMyGold(address adr) public view returns(uint256) {\\n        return claimedGold[adr]+ getGoldSincelastHireTime(adr);\\n    }\\n    \\n    function getGoldSincelastHireTime(address adr) public view returns(uint256) {\\n        return Math.min(GOLD_TO_HIRE_1MINER,block.timestamp-lastHireTime[adr])*goldMiners[adr];\\n    }\\n    \\n    /*for the front end, it returns a value between 0 and GOLD_TO_HIRE_1MINER, when reached GOLD_TO_HIRE_1MINER \\n    user will stop accumulating gold and should compound or sell to get others\\n    */\\n    function getGoldAccumulationValue(address adr) public view returns(uint256) {\\n        return Math.min(GOLD_TO_HIRE_1MINER,block.timestamp-lastHireTime[adr]);\\n    }\\n    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GOLD_TO_HIRE_1MINER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"buyGold\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"calculateGoldBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"calculateGoldBuySimple\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gold\",\"type\":\"uint256\"}],\"name\":\"calculateGoldSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getGoldAccumulationValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getGoldSincelastHireTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMyGold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"goldMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"goldRewardsToBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"hireMiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedMarket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniqueUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GoldGrinder", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}