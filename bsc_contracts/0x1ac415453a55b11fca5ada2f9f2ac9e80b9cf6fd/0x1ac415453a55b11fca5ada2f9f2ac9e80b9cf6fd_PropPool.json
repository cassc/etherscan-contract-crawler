{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ninterface IStableSwapRouter {\r\n    enum FLAG {\r\n        STABLE_SWAP,\r\n        V2_EXACT_IN\r\n    }\r\n    \r\n    function swap(\r\n        IERC20 srcToken,\r\n        IERC20 dstToken,\r\n        uint256 amount,\r\n        uint256 minReturn,\r\n        FLAG flag\r\n    ) external payable returns (uint256 returnAmount);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface INexusToken {\r\n    function mintWithBacking(\r\n        uint256 numTokens,\r\n        address recipient\r\n    ) external returns (uint256);\r\n}\r\n\r\n/**\r\n    Prop Pool Submission Contract\r\n\r\n    - User spends predetermined amount of money ($5,000) for Prop Pool\r\n    - If User has not been confirmed before, he waits in Escrow for owner to approve him\r\n    - Once Approved, user can be automatically confirmed and no Escrow is needed\r\n    - Once confirmed, user gets points added to his total (staking points)\r\n    - USDT comes into the contract, we need to automatically convert it to NEXUS and add to the rewards\r\n        - rewards are split evenly based on the number of points in the pool\r\n    - Send $5,000 immediately to wallet specified by owner\r\n */\r\ncontract PropPool is Ownable, ReentrancyGuard, IERC20 {\r\n\r\n    // name and symbol for tokenized contract\r\n    string private constant _name = \"Prop Pools\";\r\n    string private constant _symbol = \"PropPools\";\r\n    uint8 private constant _decimals = 0;\r\n\r\n    // User Info\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        bool isConfirmed;\r\n    }\r\n\r\n    // Address => UserInfo\r\n    mapping ( address => UserInfo ) public userInfo;\r\n\r\n    // List of users waiting to be confirmed\r\n    address[] public escrowUsers;\r\n    mapping ( address => uint256 ) public pointsInEscrow;\r\n\r\n    // Tracks Dividends\r\n    uint256 public totalRewards;\r\n    uint256 private totalShares;\r\n    uint256 private dividendsPerPoint;\r\n    uint256 private constant precision = 10**18;\r\n\r\n    // minimum entry fee in USDT\r\n    uint256 public entryFee = 5_000 * 10**18;\r\n\r\n    // Token used to enter the pool\r\n    address public entryToken = 0xE02b3F47B0528440a948cE53C8Cc2882A8d34164;\r\n\r\n    // Nexus Token, the payout token\r\n    address public nexusToken;\r\n\r\n    // mint token for nexus\r\n    address public constant mintToken = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\r\n\r\n    // reward token that is converted into NEXUS\r\n    address public conversionToken = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    // fund recipient\r\n    address public fundRecipient;\r\n\r\n    // pause function\r\n    bool public paused;\r\n\r\n    // router\r\n    address public router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    constructor(\r\n        address nexusToken_,\r\n        address fundRecipient_\r\n    ) {\r\n        nexusToken = nexusToken_;\r\n        fundRecipient = fundRecipient_;\r\n    }\r\n\r\n    function setEntryFee(uint256 newMin) external onlyOwner {\r\n        entryFee = newMin;\r\n    }\r\n\r\n    function setEntryToken(address newToken) external onlyOwner {\r\n        entryToken = newToken;\r\n    }\r\n\r\n    // reward token to be converted into usdc then nexus\r\n    function setConversionToken(address newToken) external onlyOwner {\r\n        conversionToken = newToken;\r\n    }\r\n\r\n    function setNexusToken(address newToken) external onlyOwner {\r\n        nexusToken = newToken;\r\n    }\r\n\r\n    function setRouter(address newRouter) external onlyOwner {\r\n        router = newRouter;\r\n    }\r\n\r\n    function setFundRecipient(address newRecipient) external onlyOwner {\r\n        fundRecipient = newRecipient;\r\n    }\r\n\r\n    function pauseBuying(bool isPaused) external onlyOwner {\r\n        paused = isPaused;\r\n    }\r\n\r\n    function getEscrowUsers() external view returns (address[] memory) {\r\n        return escrowUsers;\r\n    }\r\n\r\n    /** Returns the total number of tokens in existence */\r\n    function totalSupply() external view override returns (uint256) { \r\n        return totalShares; \r\n    }\r\n\r\n    /** Returns the number of tokens owned by `account` */\r\n    function balanceOf(address account) public view override returns (uint256) { \r\n        return userInfo[account].amount;\r\n    }\r\n\r\n    /** Returns the number of tokens `spender` can transfer from `holder` */\r\n    function allowance(address, address) external pure override returns (uint256) { \r\n        return 0; \r\n    }\r\n    \r\n    /** Token Name */\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /** Token Ticker Symbol */\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /** Tokens decimals */\r\n    function decimals() public pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /** Approves `spender` to transfer `amount` tokens from caller */\r\n    function approve(address, uint256) public override returns (bool) {\r\n        emit Approval(msg.sender, address(0), 0);\r\n        return true;\r\n    }\r\n  \r\n    /** Transfer Function */\r\n    function transfer(address, uint256) external override returns (bool) {\r\n        emit Transfer(address(0), address(0), 0);\r\n        return true;\r\n    }\r\n\r\n    /** Transfer Function */\r\n    function transferFrom(address, address, uint256) external override returns (bool) {\r\n        emit Transfer(address(0), address(0), 0);\r\n        return true;\r\n    }\r\n\r\n    function withdrawForeignToken(address token_) external onlyOwner {\r\n        require(\r\n            IERC20(token_).transfer(\r\n                msg.sender,\r\n                IERC20(token_).balanceOf(address(this))\r\n            ),\r\n            'Failure On Token Withdraw'\r\n        );\r\n    }\r\n\r\n    function withdrawETH() external onlyOwner {\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function claimRewardsFor(address[] calldata users) external onlyOwner nonReentrant {\r\n        uint len = users.length;\r\n        for (uint i = 0; i < len;) {\r\n            _claimReward(users[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function confirmUser(address user, uint256 index) external onlyOwner {\r\n        require(\r\n            escrowUsers[index] == user,\r\n            'Invalid Index'\r\n        );\r\n        require(\r\n            pointsInEscrow[user] > 0,\r\n            'Zero Points'\r\n        );\r\n\r\n        // get the users escrow points\r\n        uint256 nPoints = pointsInEscrow[user];\r\n\r\n        // delete the points for reentry\r\n        delete pointsInEscrow[user];\r\n\r\n        // remove user from array\r\n        escrowUsers[index] = escrowUsers[escrowUsers.length - 1];\r\n        escrowUsers.pop();\r\n\r\n        // set user to be confirmed\r\n        userInfo[user].isConfirmed = true;\r\n\r\n        // award user points\r\n        _stakePoints(user, nPoints);\r\n    }\r\n\r\n\r\n    function convert(uint256 minReturn) external nonReentrant {\r\n        // convert USDT into USDC, then swap into nexus, deposit as rewards\r\n\r\n        // get USDT balance\r\n        uint256 balance = IERC20(conversionToken).balanceOf(address(this));\r\n\r\n        // approve of router\r\n        IERC20(conversionToken).approve(router, balance);\r\n\r\n        // swap USDT to USDC\r\n        IStableSwapRouter(router).swap(\r\n            IERC20(conversionToken), \r\n            IERC20(mintToken), \r\n            balance, \r\n            minReturn, \r\n            IStableSwapRouter.FLAG.STABLE_SWAP\r\n        );\r\n\r\n        // note USDC amount received\r\n        uint256 received = IERC20(mintToken).balanceOf(address(this));\r\n\r\n        // approve of nexus\r\n        IERC20(mintToken).approve(nexusToken, received);\r\n\r\n        // mint NEXUS, noting amount minted\r\n        uint256 balanceBefore = IERC20(nexusToken).balanceOf(address(this));\r\n        INexusToken(nexusToken).mintWithBacking(\r\n            received,\r\n            address(this)\r\n        );\r\n        uint256 balanceAfter = IERC20(nexusToken).balanceOf(address(this));\r\n        require(\r\n            balanceAfter > balanceBefore,\r\n            'Zero Received'\r\n        );\r\n\r\n        // calculate amount received\r\n        uint256 amountMinted;\r\n        unchecked {\r\n            amountMinted = balanceAfter - balanceBefore;\r\n        }\r\n        \r\n        // add to rewards\r\n        _depositRewards(amountMinted);\r\n    }\r\n\r\n    function buyPools(uint nPools) external nonReentrant {\r\n        require(\r\n            paused == false,\r\n            'Buying Is Paused'\r\n        );\r\n\r\n        // calculate cost\r\n        uint256 cost = entryFee * nPools;\r\n\r\n        // transfer in cost\r\n        uint256 received = _transferIn(entryToken, cost);\r\n        require(\r\n            received >= cost,\r\n            'Invalid Transfer In'\r\n        );\r\n\r\n        // transfer cost to fund recipient\r\n        IERC20(entryToken).transfer(fundRecipient, cost);\r\n\r\n        // stake points if user has been approved\r\n        if (userInfo[msg.sender].isConfirmed) {\r\n            _stakePoints(msg.sender, nPools);\r\n        } else {\r\n            _holdPointsInEscrow(msg.sender, nPools);\r\n        }\r\n    }\r\n\r\n    function claimRewards() external nonReentrant {\r\n        _claimReward(msg.sender);\r\n    }\r\n\r\n    function giveRewards(uint256 amount) external payable nonReentrant {\r\n        uint256 received = _transferIn(nexusToken, amount);\r\n        _depositRewards(received);\r\n    }\r\n\r\n\r\n    function _holdPointsInEscrow(address user, uint256 nPoints) internal {\r\n\r\n        // add to list if they are not already in list\r\n        if (pointsInEscrow[user] == 0) {\r\n            escrowUsers.push(user);\r\n        }\r\n\r\n        // add to points\r\n        unchecked {\r\n            pointsInEscrow[user] += nPoints;\r\n        }\r\n    }\r\n\r\n    function _stakePoints(address user, uint nPoints) internal {\r\n\r\n        // claim reward if applicable\r\n        if (userInfo[user].amount > 0) {\r\n            _claimReward(user);\r\n        }\r\n\r\n        // increment points\r\n        unchecked {\r\n            userInfo[user].amount += nPoints;\r\n            totalShares += nPoints;\r\n        }\r\n        \r\n        // reset reward debt\r\n        userInfo[user].totalExcluded = getCumulativeDividends(userInfo[user].amount);\r\n\r\n        // emit Transfer Event\r\n        emit Transfer(address(0), user, nPoints);\r\n    }\r\n\r\n\r\n    function _depositRewards(uint256 amount) internal {\r\n        if (totalShares > 0) {\r\n            unchecked {\r\n                dividendsPerPoint += ( amount * precision ) / totalShares;\r\n                totalRewards += amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _claimReward(address user) internal {\r\n\r\n        // exit if zero value locked\r\n        if (userInfo[user].amount == 0) {\r\n            return;\r\n        }\r\n\r\n        // fetch pending rewards\r\n        uint256 amount = pendingRewards(user);\r\n        uint256 balance = IERC20(nexusToken).balanceOf(address(this));\r\n\r\n        // prevent overflow\r\n        if (amount > balance) {\r\n            amount = balance;\r\n        }\r\n        \r\n        // exit if zero rewards\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        // update total excluded\r\n        userInfo[user].totalExcluded = getCumulativeDividends(userInfo[user].amount);\r\n\r\n        // transfer reward to user\r\n        IERC20(nexusToken).transfer(user, amount);\r\n    }\r\n\r\n    function _transferIn(address token, uint256 amount) internal returns (uint256) {\r\n        require(\r\n            IERC20(token).balanceOf(msg.sender) >= amount,\r\n            'Insufficient Balance'\r\n        );\r\n        require(\r\n            IERC20(token).allowance(msg.sender, address(this)) >= amount,\r\n            'Insufficient Allowance'\r\n        );\r\n\r\n        uint256 before = IERC20(token).balanceOf(address(this));\r\n\r\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n\r\n        uint256 After = IERC20(token).balanceOf(address(this));\r\n        require(\r\n            After > before,\r\n            'Zero Received'\r\n        );\r\n        return After - before;\r\n    }\r\n\r\n\r\n    function pendingRewards(address user) public view returns (uint256) {\r\n        if(userInfo[user].amount == 0){ return 0; }\r\n\r\n        uint256 cumulativeRewards = getCumulativeDividends(userInfo[user].amount);\r\n        uint256 excludedRewards = userInfo[user].totalExcluded;\r\n\r\n        if(cumulativeRewards <= excludedRewards){ return 0; }\r\n\r\n        return cumulativeRewards - excludedRewards;\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return ( share * dividendsPerPoint ) / precision;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nexusToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fundRecipient_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nPools\",\"type\":\"uint256\"}],\"name\":\"buyPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"claimRewardsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"confirmUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conversionToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrowUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEscrowUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"giveRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nexusToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"pauseBuying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pointsInEscrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setConversionToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMin\",\"type\":\"uint256\"}],\"name\":\"setEntryFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setEntryToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"setFundRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setNexusToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isConfirmed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"withdrawForeignToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PropPool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e02b3f47b0528440a948ce53c8cc2882a8d341640000000000000000000000007fc9d4d95f55706ad6021742793a7e28d69715d5", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8dd277c854603a5eb9482c6229ecd9652160b1923c7526788dae9179f9626f00"}